<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h", "content": "//===- llvm/Analysis/AssumptionCache.h - Track @llvm.assume -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains a pass that keeps track of @llvm.assume intrinsics in\n// the functions of a module (allowing assumptions within any function to be\n// found cheaply by other parts of the optimizer).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_ASSUMPTIONCACHE_H\n#define LLVM_ANALYSIS_ASSUMPTIONCACHE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Pass.h\"\n#include <memory>\n\nnamespace llvm {\n\nclass CallInst;\nclass Function;\nclass raw_ostream;\nclass Value;\n\n/// A cache of \\@llvm.assume calls within a function.\n///\n/// This cache provides fast lookup of assumptions within a function by caching\n/// them and amortizing the cost of scanning for them across all queries. Passes\n/// that create new assumptions are required to call registerAssumption() to\n/// register any new \\@llvm.assume calls that they create. Deletions of\n/// \\@llvm.assume calls do not require special handling.\nclass AssumptionCache {\npublic:\n  /// Value of ResultElem::Index indicating that the argument to the call of the\n  /// llvm.assume.\n  enum : unsigned { ExprResultIdx = std::numeric_limits<unsigned>::max() };\n\n  struct ResultElem {\n    WeakVH Assume;\n\n    /// contains either ExprResultIdx or the index of the operand bundle\n    /// containing the knowledge.\n    unsigned Index;\n    operator Value *() const { return Assume; }\n  };\n\nprivate:\n  /// The function for which this cache is handling assumptions.\n  ///\n  /// We track this to lazily populate our assumptions.\n  Function &F;\n\n  /// Vector of weak value handles to calls of the \\@llvm.assume\n  /// intrinsic.\n  SmallVector<ResultElem, 4> AssumeHandles;\n\n  class AffectedValueCallbackVH final : public CallbackVH {\n    AssumptionCache *AC;\n\n    void deleted() override;\n    void allUsesReplacedWith(Value *) override;\n\n  public:\n    using DMI = DenseMapInfo<Value *>;\n\n    AffectedValueCallbackVH(Value *V, AssumptionCache *AC = nullptr)\n        : CallbackVH(V), AC(AC) {}\n  };\n\n  friend AffectedValueCallbackVH;\n\n  /// A map of values about which an assumption might be providing\n  /// information to the relevant set of assumptions.\n  using AffectedValuesMap =\n      DenseMap<AffectedValueCallbackVH, SmallVector<ResultElem, 1>,\n               AffectedValueCallbackVH::DMI>;\n  AffectedValuesMap AffectedValues;\n\n  /// Get the vector of assumptions which affect a value from the cache.\n  SmallVector<ResultElem, 1> &getOrInsertAffectedValues(Value *V);\n\n  /// Move affected values in the cache for OV to be affected values for NV.\n  void transferAffectedValuesInCache(Value *OV, Value *NV);\n\n  /// Flag tracking whether we have scanned the function yet.\n  ///\n  /// We want to be as lazy about this as possible, and so we scan the function\n  /// at the last moment.\n  bool Scanned = false;\n\n  /// Scan the function for assumptions and add them to the cache.\n  void scanFunction();\n\npublic:\n  /// Construct an AssumptionCache from a function by scanning all of\n  /// its instructions.\n  AssumptionCache(Function &F) : F(F) {}\n\n  /// This cache is designed to be self-updating and so it should never be\n  /// invalidated.\n  bool invalidate(Function &, const PreservedAnalyses &,\n                  FunctionAnalysisManager::Invalidator &) {\n    return false;\n  }\n\n  /// Add an \\@llvm.assume intrinsic to this function's cache.\n  ///\n  /// The call passed in must be an instruction within this function and must\n  /// not already be in the cache.\n  void registerAssumption(CallInst *CI);\n\n  /// Remove an \\@llvm.assume intrinsic from this function's cache if it has\n  /// been added to the cache earlier.\n  void unregisterAssumption(CallInst *CI);\n\n  /// Update the cache of values being affected by this assumption (i.e.\n  /// the values about which this assumption provides information).\n  void updateAffectedValues(CallInst *CI);\n\n  /// Clear the cache of \\@llvm.assume intrinsics for a function.\n  ///\n  /// It will be re-scanned the next time it is requested.\n  void clear() {\n    AssumeHandles.clear();\n    AffectedValues.clear();\n    Scanned = false;\n  }\n\n  /// Access the list of assumption handles currently tracked for this\n  /// function.\n  ///\n  /// Note that these produce weak handles that may be null. The caller must\n  /// handle that case.\n  /// FIXME: We should replace this with pointee_iterator<filter_iterator<...>>\n  /// when we can write that to filter out the null values. Then caller code\n  /// will become simpler.\n  MutableArrayRef<ResultElem> assumptions() {\n    if (!Scanned)\n      scanFunction();\n    return AssumeHandles;\n  }\n\n  /// Access the list of assumptions which affect this value.\n  MutableArrayRef<ResultElem> assumptionsFor(const Value *V) {\n    if (!Scanned)\n      scanFunction();\n\n    auto AVI = AffectedValues.find_as(const_cast<Value *>(V));\n    if (AVI == AffectedValues.end())\n      return MutableArrayRef<ResultElem>();\n\n    return AVI->second;\n  }\n};\n\n/// A function analysis which provides an \\c AssumptionCache.\n///\n/// This analysis is intended for use with the new pass manager and will vend\n/// assumption caches for a given function.\nclass AssumptionAnalysis : public AnalysisInfoMixin<AssumptionAnalysis> {\n  friend AnalysisInfoMixin<AssumptionAnalysis>;\n\n  static AnalysisKey Key;\n\npublic:\n  using Result = AssumptionCache;\n\n  AssumptionCache run(Function &F, FunctionAnalysisManager &) {\n    return AssumptionCache(F);\n  }\n};\n\n/// Printer pass for the \\c AssumptionAnalysis results.\nclass AssumptionPrinterPass : public PassInfoMixin<AssumptionPrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit AssumptionPrinterPass(raw_ostream &OS) : OS(OS) {}\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// An immutable pass that tracks lazily created \\c AssumptionCache\n/// objects.\n///\n/// This is essentially a workaround for the legacy pass manager's weaknesses\n/// which associates each assumption cache with Function and clears it if the\n/// function is deleted. The nature of the AssumptionCache is that it is not\n/// invalidated by any changes to the function body and so this is sufficient\n/// to be conservatively correct.\nclass AssumptionCacheTracker : public ImmutablePass {\n  /// A callback value handle applied to function objects, which we use to\n  /// delete our cache of intrinsics for a function when it is deleted.\n  class FunctionCallbackVH final : public CallbackVH {\n    AssumptionCacheTracker *ACT;\n\n    void deleted() override;\n\n  public:\n    using DMI = DenseMapInfo<Value *>;\n\n    FunctionCallbackVH(Value *V, AssumptionCacheTracker *ACT = nullptr)\n        : CallbackVH(V), ACT(ACT) {}\n  };\n\n  friend FunctionCallbackVH;\n\n  using FunctionCallsMap =\n      DenseMap<FunctionCallbackVH, std::unique_ptr<AssumptionCache>,\n               FunctionCallbackVH::DMI>;\n\n  FunctionCallsMap AssumptionCaches;\n\npublic:\n  /// Get the cached assumptions for a function.\n  ///\n  /// If no assumptions are cached, this will scan the function. Otherwise, the\n  /// existing cache will be returned.\n  AssumptionCache &getAssumptionCache(Function &F);\n\n  /// Return the cached assumptions for a function if it has already been\n  /// scanned. Otherwise return nullptr.\n  AssumptionCache *lookupAssumptionCache(Function &F);\n\n  AssumptionCacheTracker();\n  ~AssumptionCacheTracker() override;\n\n  void releaseMemory() override {\n    verifyAnalysis();\n    AssumptionCaches.shrink_and_clear();\n  }\n\n  void verifyAnalysis() const override;\n\n  bool doFinalization(Module &) override {\n    verifyAnalysis();\n    return false;\n  }\n\n  static char ID; // Pass identification, replacement for typeid\n};\n\ntemplate<> struct simplify_type<AssumptionCache::ResultElem> {\n  using SimpleType = Value *;\n\n  static SimpleType getSimplifiedValue(AssumptionCache::ResultElem &Val) {\n    return Val;\n  }\n};\ntemplate<> struct simplify_type<const AssumptionCache::ResultElem> {\n  using SimpleType = /*const*/ Value *;\n\n  static SimpleType getSimplifiedValue(const AssumptionCache::ResultElem &Val) {\n    return Val;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ANALYSIS_ASSUMPTIONCACHE_H\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h", "content": "//===- BlockFrequencyInfo.h - Block Frequency Analysis ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Loops should be simplified before this analysis.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_BLOCKFREQUENCYINFO_H\n#define LLVM_ANALYSIS_BLOCKFREQUENCYINFO_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/BlockFrequency.h\"\n#include <cstdint>\n#include <memory>\n\nnamespace llvm {\n\nclass BasicBlock;\nclass BranchProbabilityInfo;\nclass Function;\nclass LoopInfo;\nclass Module;\nclass raw_ostream;\ntemplate <class BlockT> class BlockFrequencyInfoImpl;\n\nenum PGOViewCountsType { PGOVCT_None, PGOVCT_Graph, PGOVCT_Text };\n\n/// BlockFrequencyInfo pass uses BlockFrequencyInfoImpl implementation to\n/// estimate IR basic block frequencies.\nclass BlockFrequencyInfo {\n  using ImplType = BlockFrequencyInfoImpl<BasicBlock>;\n\n  std::unique_ptr<ImplType> BFI;\n\npublic:\n  BlockFrequencyInfo();\n  BlockFrequencyInfo(const Function &F, const BranchProbabilityInfo &BPI,\n                     const LoopInfo &LI);\n  BlockFrequencyInfo(const BlockFrequencyInfo &) = delete;\n  BlockFrequencyInfo &operator=(const BlockFrequencyInfo &) = delete;\n  BlockFrequencyInfo(BlockFrequencyInfo &&Arg);\n  BlockFrequencyInfo &operator=(BlockFrequencyInfo &&RHS);\n  ~BlockFrequencyInfo();\n\n  /// Handle invalidation explicitly.\n  bool invalidate(Function &F, const PreservedAnalyses &PA,\n                  FunctionAnalysisManager::Invalidator &);\n\n  const Function *getFunction() const;\n  const BranchProbabilityInfo *getBPI() const;\n  void view(StringRef = \"BlockFrequencyDAGs\") const;\n\n  /// getblockFreq - Return block frequency. Return 0 if we don't have the\n  /// information. Please note that initial frequency is equal to ENTRY_FREQ. It\n  /// means that we should not rely on the value itself, but only on the\n  /// comparison to the other block frequencies. We do this to avoid using of\n  /// floating points.\n  BlockFrequency getBlockFreq(const BasicBlock *BB) const;\n\n  /// Returns the estimated profile count of \\p BB.\n  /// This computes the relative block frequency of \\p BB and multiplies it by\n  /// the enclosing function's count (if available) and returns the value.\n  Optional<uint64_t> getBlockProfileCount(const BasicBlock *BB,\n                                          bool AllowSynthetic = false) const;\n\n  /// Returns the estimated profile count of \\p Freq.\n  /// This uses the frequency \\p Freq and multiplies it by\n  /// the enclosing function's count (if available) and returns the value.\n  Optional<uint64_t> getProfileCountFromFreq(uint64_t Freq) const;\n\n  /// Returns true if \\p BB is an irreducible loop header\n  /// block. Otherwise false.\n  bool isIrrLoopHeader(const BasicBlock *BB);\n\n  // Set the frequency of the given basic block.\n  void setBlockFreq(const BasicBlock *BB, uint64_t Freq);\n\n  /// Set the frequency of \\p ReferenceBB to \\p Freq and scale the frequencies\n  /// of the blocks in \\p BlocksToScale such that their frequencies relative\n  /// to \\p ReferenceBB remain unchanged.\n  void setBlockFreqAndScale(const BasicBlock *ReferenceBB, uint64_t Freq,\n                            SmallPtrSetImpl<BasicBlock *> &BlocksToScale);\n\n  /// calculate - compute block frequency info for the given function.\n  void calculate(const Function &F, const BranchProbabilityInfo &BPI,\n                 const LoopInfo &LI);\n\n  // Print the block frequency Freq to OS using the current functions entry\n  // frequency to convert freq into a relative decimal form.\n  raw_ostream &printBlockFreq(raw_ostream &OS, const BlockFrequency Freq) const;\n\n  // Convenience method that attempts to look up the frequency associated with\n  // BB and print it to OS.\n  raw_ostream &printBlockFreq(raw_ostream &OS, const BasicBlock *BB) const;\n\n  uint64_t getEntryFreq() const;\n  void releaseMemory();\n  void print(raw_ostream &OS) const;\n\n  // Compare to the other BFI and verify they match.\n  void verifyMatch(BlockFrequencyInfo &Other) const;\n};\n\n/// Analysis pass which computes \\c BlockFrequencyInfo.\nclass BlockFrequencyAnalysis\n    : public AnalysisInfoMixin<BlockFrequencyAnalysis> {\n  friend AnalysisInfoMixin<BlockFrequencyAnalysis>;\n\n  static AnalysisKey Key;\n\npublic:\n  /// Provide the result type for this analysis pass.\n  using Result = BlockFrequencyInfo;\n\n  /// Run the analysis pass over a function and produce BFI.\n  Result run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Printer pass for the \\c BlockFrequencyInfo results.\nclass BlockFrequencyPrinterPass\n    : public PassInfoMixin<BlockFrequencyPrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit BlockFrequencyPrinterPass(raw_ostream &OS) : OS(OS) {}\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Legacy analysis pass which computes \\c BlockFrequencyInfo.\nclass BlockFrequencyInfoWrapperPass : public FunctionPass {\n  BlockFrequencyInfo BFI;\n\npublic:\n  static char ID;\n\n  BlockFrequencyInfoWrapperPass();\n  ~BlockFrequencyInfoWrapperPass() override;\n\n  BlockFrequencyInfo &getBFI() { return BFI; }\n  const BlockFrequencyInfo &getBFI() const { return BFI; }\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n\n  bool runOnFunction(Function &F) override;\n  void releaseMemory() override;\n  void print(raw_ostream &OS, const Module *M) const override;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ANALYSIS_BLOCKFREQUENCYINFO_H\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h", "content": "//===- BranchProbabilityInfo.h - Branch Probability Analysis ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This pass is used to evaluate branch probabilties.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_BRANCHPROBABILITYINFO_H\n#define LLVM_ANALYSIS_BRANCHPROBABILITYINFO_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/CFG.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/BranchProbability.h\"\n#include \"llvm/Support/Casting.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <utility>\n\nnamespace llvm {\n\nclass Function;\nclass Loop;\nclass LoopInfo;\nclass raw_ostream;\nclass DominatorTree;\nclass PostDominatorTree;\nclass TargetLibraryInfo;\nclass Value;\n\n/// Analysis providing branch probability information.\n///\n/// This is a function analysis which provides information on the relative\n/// probabilities of each \"edge\" in the function's CFG where such an edge is\n/// defined by a pair (PredBlock and an index in the successors). The\n/// probability of an edge from one block is always relative to the\n/// probabilities of other edges from the block. The probabilites of all edges\n/// from a block sum to exactly one (100%).\n/// We use a pair (PredBlock and an index in the successors) to uniquely\n/// identify an edge, since we can have multiple edges from Src to Dst.\n/// As an example, we can have a switch which jumps to Dst with value 0 and\n/// value 10.\n///\n/// Process of computing branch probabilities can be logically viewed as three\n/// step process:\n///\n///   First, if there is a profile information associated with the branch then\n/// it is trivially translated to branch probabilities. There is one exception\n/// from this rule though. Probabilities for edges leading to \"unreachable\"\n/// blocks (blocks with the estimated weight not greater than\n/// UNREACHABLE_WEIGHT) are evaluated according to static estimation and\n/// override profile information. If no branch probabilities were calculated\n/// on this step then take the next one.\n///\n///   Second, estimate absolute execution weights for each block based on\n/// statically known information. Roots of such information are \"cold\",\n/// \"unreachable\", \"noreturn\" and \"unwind\" blocks. Those blocks get their\n/// weights set to BlockExecWeight::COLD, BlockExecWeight::UNREACHABLE,\n/// BlockExecWeight::NORETURN and BlockExecWeight::UNWIND respectively. Then the\n/// weights are propagated to the other blocks up the domination line. In\n/// addition, if all successors have estimated weights set then maximum of these\n/// weights assigned to the block itself (while this is not ideal heuristic in\n/// theory it's simple and works reasonably well in most cases) and the process\n/// repeats. Once the process of weights propagation converges branch\n/// probabilities are set for all such branches that have at least one successor\n/// with the weight set. Default execution weight (BlockExecWeight::DEFAULT) is\n/// used for any successors which doesn't have its weight set. For loop back\n/// branches we use their weights scaled by loop trip count equal to\n/// 'LBH_TAKEN_WEIGHT/LBH_NOTTAKEN_WEIGHT'.\n///\n/// Here is a simple example demonstrating how the described algorithm works.\n///\n///          BB1\n///         /   \\\n///        v     v\n///      BB2     BB3\n///     /   \\\n///    v     v\n///  ColdBB  UnreachBB\n///\n/// Initially, ColdBB is associated with COLD_WEIGHT and UnreachBB with\n/// UNREACHABLE_WEIGHT. COLD_WEIGHT is set to BB2 as maximum between its\n/// successors. BB1 and BB3 has no explicit estimated weights and assumed to\n/// have DEFAULT_WEIGHT. Based on assigned weights branches will have the\n/// following probabilities:\n/// P(BB1->BB2) = COLD_WEIGHT/(COLD_WEIGHT + DEFAULT_WEIGHT) =\n///   0xffff / (0xffff + 0xfffff) = 0.0588(5.9%)\n/// P(BB1->BB3) = DEFAULT_WEIGHT_WEIGHT/(COLD_WEIGHT + DEFAULT_WEIGHT) =\n///          0xfffff / (0xffff + 0xfffff) = 0.941(94.1%)\n/// P(BB2->ColdBB) = COLD_WEIGHT/(COLD_WEIGHT + UNREACHABLE_WEIGHT) = 1(100%)\n/// P(BB2->UnreachBB) =\n///   UNREACHABLE_WEIGHT/(COLD_WEIGHT+UNREACHABLE_WEIGHT) = 0(0%)\n///\n/// If no branch probabilities were calculated on this step then take the next\n/// one.\n///\n///   Third, apply different kinds of local heuristics for each individual\n/// branch until first match. For example probability of a pointer to be null is\n/// estimated as PH_TAKEN_WEIGHT/(PH_TAKEN_WEIGHT + PH_NONTAKEN_WEIGHT). If\n/// no local heuristic has been matched then branch is left with no explicit\n/// probability set and assumed to have default probability.\nclass BranchProbabilityInfo {\npublic:\n  BranchProbabilityInfo() = default;\n\n  BranchProbabilityInfo(const Function &F, const LoopInfo &LI,\n                        const TargetLibraryInfo *TLI = nullptr,\n                        DominatorTree *DT = nullptr,\n                        PostDominatorTree *PDT = nullptr) {\n    calculate(F, LI, TLI, DT, PDT);\n  }\n\n  BranchProbabilityInfo(BranchProbabilityInfo &&Arg)\n      : Probs(std::move(Arg.Probs)), LastF(Arg.LastF),\n        EstimatedBlockWeight(std::move(Arg.EstimatedBlockWeight)) {}\n\n  BranchProbabilityInfo(const BranchProbabilityInfo &) = delete;\n  BranchProbabilityInfo &operator=(const BranchProbabilityInfo &) = delete;\n\n  BranchProbabilityInfo &operator=(BranchProbabilityInfo &&RHS) {\n    releaseMemory();\n    Probs = std::move(RHS.Probs);\n    EstimatedBlockWeight = std::move(RHS.EstimatedBlockWeight);\n    return *this;\n  }\n\n  bool invalidate(Function &, const PreservedAnalyses &PA,\n                  FunctionAnalysisManager::Invalidator &);\n\n  void releaseMemory();\n\n  void print(raw_ostream &OS) const;\n\n  /// Get an edge's probability, relative to other out-edges of the Src.\n  ///\n  /// This routine provides access to the fractional probability between zero\n  /// (0%) and one (100%) of this edge executing, relative to other edges\n  /// leaving the 'Src' block. The returned probability is never zero, and can\n  /// only be one if the source block has only one successor.\n  BranchProbability getEdgeProbability(const BasicBlock *Src,\n                                       unsigned IndexInSuccessors) const;\n\n  /// Get the probability of going from Src to Dst.\n  ///\n  /// It returns the sum of all probabilities for edges from Src to Dst.\n  BranchProbability getEdgeProbability(const BasicBlock *Src,\n                                       const BasicBlock *Dst) const;\n\n  BranchProbability getEdgeProbability(const BasicBlock *Src,\n                                       const_succ_iterator Dst) const;\n\n  /// Test if an edge is hot relative to other out-edges of the Src.\n  ///\n  /// Check whether this edge out of the source block is 'hot'. We define hot\n  /// as having a relative probability >= 80%.\n  bool isEdgeHot(const BasicBlock *Src, const BasicBlock *Dst) const;\n\n  /// Retrieve the hot successor of a block if one exists.\n  ///\n  /// Given a basic block, look through its successors and if one exists for\n  /// which \\see isEdgeHot would return true, return that successor block.\n  const BasicBlock *getHotSucc(const BasicBlock *BB) const;\n\n  /// Print an edge's probability.\n  ///\n  /// Retrieves an edge's probability similarly to \\see getEdgeProbability, but\n  /// then prints that probability to the provided stream. That stream is then\n  /// returned.\n  raw_ostream &printEdgeProbability(raw_ostream &OS, const BasicBlock *Src,\n                                    const BasicBlock *Dst) const;\n\npublic:\n  /// Set the raw probabilities for all edges from the given block.\n  ///\n  /// This allows a pass to explicitly set edge probabilities for a block. It\n  /// can be used when updating the CFG to update the branch probability\n  /// information.\n  void setEdgeProbability(const BasicBlock *Src,\n                          const SmallVectorImpl<BranchProbability> &Probs);\n\n  /// Copy outgoing edge probabilities from \\p Src to \\p Dst.\n  ///\n  /// This allows to keep probabilities unset for the destination if they were\n  /// unset for source.\n  void copyEdgeProbabilities(BasicBlock *Src, BasicBlock *Dst);\n\n  static BranchProbability getBranchProbStackProtector(bool IsLikely) {\n    static const BranchProbability LikelyProb((1u << 20) - 1, 1u << 20);\n    return IsLikely ? LikelyProb : LikelyProb.getCompl();\n  }\n\n  void calculate(const Function &F, const LoopInfo &LI,\n                 const TargetLibraryInfo *TLI, DominatorTree *DT,\n                 PostDominatorTree *PDT);\n\n  /// Forget analysis results for the given basic block.\n  void eraseBlock(const BasicBlock *BB);\n\n  // Data structure to track SCCs for handling irreducible loops.\n  class SccInfo {\n    // Enum of types to classify basic blocks in SCC. Basic block belonging to\n    // SCC is 'Inner' until it is either 'Header' or 'Exiting'. Note that a\n    // basic block can be 'Header' and 'Exiting' at the same time.\n    enum SccBlockType {\n      Inner = 0x0,\n      Header = 0x1,\n      Exiting = 0x2,\n    };\n    // Map of basic blocks to SCC IDs they belong to. If basic block doesn't\n    // belong to any SCC it is not in the map.\n    using SccMap = DenseMap<const BasicBlock *, int>;\n    // Each basic block in SCC is attributed with one or several types from\n    // SccBlockType. Map value has uint32_t type (instead of SccBlockType)\n    // since basic block may be for example \"Header\" and \"Exiting\" at the same\n    // time and we need to be able to keep more than one value from\n    // SccBlockType.\n    using SccBlockTypeMap = DenseMap<const BasicBlock *, uint32_t>;\n    // Vector containing classification of basic blocks for all  SCCs where i'th\n    // vector element corresponds to SCC with ID equal to i.\n    using SccBlockTypeMaps = std::vector<SccBlockTypeMap>;\n\n    SccMap SccNums;\n    SccBlockTypeMaps SccBlocks;\n\n  public:\n    explicit SccInfo(const Function &F);\n\n    /// If \\p BB belongs to some SCC then ID of that SCC is returned, otherwise\n    /// -1 is returned. If \\p BB belongs to more than one SCC at the same time\n    /// result is undefined.\n    int getSCCNum(const BasicBlock *BB) const;\n    /// Returns true if \\p BB is a 'header' block in SCC with \\p SccNum ID,\n    /// false otherwise.\n    bool isSCCHeader(const BasicBlock *BB, int SccNum) const {\n      return getSccBlockType(BB, SccNum) & Header;\n    }\n    /// Returns true if \\p BB is an 'exiting' block in SCC with \\p SccNum ID,\n    /// false otherwise.\n    bool isSCCExitingBlock(const BasicBlock *BB, int SccNum) const {\n      return getSccBlockType(BB, SccNum) & Exiting;\n    }\n    /// Fills in \\p Enters vector with all such blocks that don't belong to\n    /// SCC with \\p SccNum ID but there is an edge to a block belonging to the\n    /// SCC.\n    void getSccEnterBlocks(int SccNum,\n                           SmallVectorImpl<BasicBlock *> &Enters) const;\n    /// Fills in \\p Exits vector with all such blocks that don't belong to\n    /// SCC with \\p SccNum ID but there is an edge from a block belonging to the\n    /// SCC.\n    void getSccExitBlocks(int SccNum,\n                          SmallVectorImpl<BasicBlock *> &Exits) const;\n\n  private:\n    /// Returns \\p BB's type according to classification given by SccBlockType\n    /// enum. Please note that \\p BB must belong to SSC with \\p SccNum ID.\n    uint32_t getSccBlockType(const BasicBlock *BB, int SccNum) const;\n    /// Calculates \\p BB's type and stores it in internal data structures for\n    /// future use. Please note that \\p BB must belong to SSC with \\p SccNum ID.\n    void calculateSccBlockType(const BasicBlock *BB, int SccNum);\n  };\n\nprivate:\n  // We need to store CallbackVH's in order to correctly handle basic block\n  // removal.\n  class BasicBlockCallbackVH final : public CallbackVH {\n    BranchProbabilityInfo *BPI;\n\n    void deleted() override {\n      assert(BPI != nullptr);\n      BPI->eraseBlock(cast<BasicBlock>(getValPtr()));\n    }\n\n  public:\n    BasicBlockCallbackVH(const Value *V, BranchProbabilityInfo *BPI = nullptr)\n        : CallbackVH(const_cast<Value *>(V)), BPI(BPI) {}\n  };\n\n  /// Pair of Loop and SCC ID number. Used to unify handling of normal and\n  /// SCC based loop representations.\n  using LoopData = std::pair<Loop *, int>;\n  /// Helper class to keep basic block along with its loop data information.\n  class LoopBlock {\n  public:\n    explicit LoopBlock(const BasicBlock *BB, const LoopInfo &LI,\n                       const SccInfo &SccI);\n\n    const BasicBlock *getBlock() const { return BB; }\n    BasicBlock *getBlock() { return const_cast<BasicBlock *>(BB); }\n    LoopData getLoopData() const { return LD; }\n    Loop *getLoop() const { return LD.first; }\n    int getSccNum() const { return LD.second; }\n\n    bool belongsToLoop() const { return getLoop() || getSccNum() != -1; }\n    bool belongsToSameLoop(const LoopBlock &LB) const {\n      return (LB.getLoop() && getLoop() == LB.getLoop()) ||\n             (LB.getSccNum() != -1 && getSccNum() == LB.getSccNum());\n    }\n\n  private:\n    const BasicBlock *const BB = nullptr;\n    LoopData LD = {nullptr, -1};\n  };\n\n  // Pair of LoopBlocks representing an edge from first to second block.\n  using LoopEdge = std::pair<const LoopBlock &, const LoopBlock &>;\n\n  DenseSet<BasicBlockCallbackVH, DenseMapInfo<Value*>> Handles;\n\n  // Since we allow duplicate edges from one basic block to another, we use\n  // a pair (PredBlock and an index in the successors) to specify an edge.\n  using Edge = std::pair<const BasicBlock *, unsigned>;\n\n  DenseMap<Edge, BranchProbability> Probs;\n\n  /// Track the last function we run over for printing.\n  const Function *LastF = nullptr;\n\n  const LoopInfo *LI = nullptr;\n\n  /// Keeps information about all SCCs in a function.\n  std::unique_ptr<const SccInfo> SccI;\n\n  /// Keeps mapping of a basic block to its estimated weight.\n  SmallDenseMap<const BasicBlock *, uint32_t> EstimatedBlockWeight;\n\n  /// Keeps mapping of a loop to estimated weight to enter the loop.\n  SmallDenseMap<LoopData, uint32_t> EstimatedLoopWeight;\n\n  /// Helper to construct LoopBlock for \\p BB.\n  LoopBlock getLoopBlock(const BasicBlock *BB) const {\n    return LoopBlock(BB, *LI, *SccI.get());\n  }\n\n  /// Returns true if destination block belongs to some loop and source block is\n  /// either doesn't belong to any loop or belongs to a loop which is not inner\n  /// relative to the destination block.\n  bool isLoopEnteringEdge(const LoopEdge &Edge) const;\n  /// Returns true if source block belongs to some loop and destination block is\n  /// either doesn't belong to any loop or belongs to a loop which is not inner\n  /// relative to the source block.\n  bool isLoopExitingEdge(const LoopEdge &Edge) const;\n  /// Returns true if \\p Edge is either enters to or exits from some loop, false\n  /// in all other cases.\n  bool isLoopEnteringExitingEdge(const LoopEdge &Edge) const;\n  /// Returns true if source and destination blocks belongs to the same loop and\n  /// destination block is loop header.\n  bool isLoopBackEdge(const LoopEdge &Edge) const;\n  // Fills in \\p Enters vector with all \"enter\" blocks to a loop \\LB belongs to.\n  void getLoopEnterBlocks(const LoopBlock &LB,\n                          SmallVectorImpl<BasicBlock *> &Enters) const;\n  // Fills in \\p Exits vector with all \"exit\" blocks from a loop \\LB belongs to.\n  void getLoopExitBlocks(const LoopBlock &LB,\n                         SmallVectorImpl<BasicBlock *> &Exits) const;\n\n  /// Returns estimated weight for \\p BB. None if \\p BB has no estimated weight.\n  Optional<uint32_t> getEstimatedBlockWeight(const BasicBlock *BB) const;\n\n  /// Returns estimated weight to enter \\p L. In other words it is weight of\n  /// loop's header block not scaled by trip count. Returns None if \\p L has no\n  /// no estimated weight.\n  Optional<uint32_t> getEstimatedLoopWeight(const LoopData &L) const;\n\n  /// Return estimated weight for \\p Edge. Returns None if estimated weight is\n  /// unknown.\n  Optional<uint32_t> getEstimatedEdgeWeight(const LoopEdge &Edge) const;\n\n  /// Iterates over all edges leading from \\p SrcBB to \\p Successors and\n  /// returns maximum of all estimated weights. If at least one edge has unknown\n  /// estimated weight None is returned.\n  template <class IterT>\n  Optional<uint32_t>\n  getMaxEstimatedEdgeWeight(const LoopBlock &SrcBB,\n                            iterator_range<IterT> Successors) const;\n\n  /// If \\p LoopBB has no estimated weight then set it to \\p BBWeight and\n  /// return true. Otherwise \\p BB's weight remains unchanged and false is\n  /// returned. In addition all blocks/loops that might need their weight to be\n  /// re-estimated are put into BlockWorkList/LoopWorkList.\n  bool updateEstimatedBlockWeight(LoopBlock &LoopBB, uint32_t BBWeight,\n                                  SmallVectorImpl<BasicBlock *> &BlockWorkList,\n                                  SmallVectorImpl<LoopBlock> &LoopWorkList);\n\n  /// Starting from \\p LoopBB (including \\p LoopBB itself) propagate \\p BBWeight\n  /// up the domination tree.\n  void propagateEstimatedBlockWeight(const LoopBlock &LoopBB, DominatorTree *DT,\n                                     PostDominatorTree *PDT, uint32_t BBWeight,\n                                     SmallVectorImpl<BasicBlock *> &WorkList,\n                                     SmallVectorImpl<LoopBlock> &LoopWorkList);\n\n  /// Returns block's weight encoded in the IR.\n  Optional<uint32_t> getInitialEstimatedBlockWeight(const BasicBlock *BB);\n\n  // Computes estimated weights for all blocks in \\p F.\n  void computeEestimateBlockWeight(const Function &F, DominatorTree *DT,\n                                   PostDominatorTree *PDT);\n\n  /// Based on computed weights by \\p computeEstimatedBlockWeight set\n  /// probabilities on branches.\n  bool calcEstimatedHeuristics(const BasicBlock *BB);\n  bool calcMetadataWeights(const BasicBlock *BB);\n  bool calcPointerHeuristics(const BasicBlock *BB);\n  bool calcZeroHeuristics(const BasicBlock *BB, const TargetLibraryInfo *TLI);\n  bool calcFloatingPointHeuristics(const BasicBlock *BB);\n};\n\n/// Analysis pass which computes \\c BranchProbabilityInfo.\nclass BranchProbabilityAnalysis\n    : public AnalysisInfoMixin<BranchProbabilityAnalysis> {\n  friend AnalysisInfoMixin<BranchProbabilityAnalysis>;\n\n  static AnalysisKey Key;\n\npublic:\n  /// Provide the result type for this analysis pass.\n  using Result = BranchProbabilityInfo;\n\n  /// Run the analysis pass over a function and produce BPI.\n  BranchProbabilityInfo run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Printer pass for the \\c BranchProbabilityAnalysis results.\nclass BranchProbabilityPrinterPass\n    : public PassInfoMixin<BranchProbabilityPrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit BranchProbabilityPrinterPass(raw_ostream &OS) : OS(OS) {}\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Legacy analysis pass which computes \\c BranchProbabilityInfo.\nclass BranchProbabilityInfoWrapperPass : public FunctionPass {\n  BranchProbabilityInfo BPI;\n\npublic:\n  static char ID;\n\n  BranchProbabilityInfoWrapperPass();\n\n  BranchProbabilityInfo &getBPI() { return BPI; }\n  const BranchProbabilityInfo &getBPI() const { return BPI; }\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n  bool runOnFunction(Function &F) override;\n  void releaseMemory() override;\n  void print(raw_ostream &OS, const Module *M = nullptr) const override;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ANALYSIS_BRANCHPROBABILITYINFO_H\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h", "content": "//===- llvm/Analysis/LoopInfo.h - Natural Loop Calculator -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the LoopInfo class that is used to identify natural loops\n// and determine the loop depth of various nodes of the CFG.  A natural loop\n// has exactly one entry-point, which is called the header. Note that natural\n// loops may actually be several loops that share the same header node.\n//\n// This analysis calculates the nesting structure of loops in a function.  For\n// each natural loop identified, this analysis identifies natural loops\n// contained entirely within the loop and the basic blocks the make up the loop.\n//\n// It can calculate on the fly various bits of information, for example:\n//\n//  * whether there is a preheader for the loop\n//  * the number of back edges to the header\n//  * whether or not a particular block branches out of the loop\n//  * the successor blocks of the loop\n//  * the loop depth\n//  * etc...\n//\n// Note that this analysis specifically identifies *Loops* not cycles or SCCs\n// in the CFG.  There can be strongly connected components in the CFG which\n// this analysis will not recognize and that will not be represented by a Loop\n// instance.  In particular, a Loop might be inside such a non-loop SCC, or a\n// non-loop SCC might contain a sub-SCC which is a Loop.\n//\n// For an overview of terminology used in this API (and thus all of our loop\n// analyses or transforms), see docs/LoopTerminology.rst.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_LOOPINFO_H\n#define LLVM_ANALYSIS_LOOPINFO_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/IR/CFG.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <algorithm>\n#include <utility>\n\nnamespace llvm {\n\nclass DominatorTree;\nclass LoopInfo;\nclass Loop;\nclass InductionDescriptor;\nclass MDNode;\nclass MemorySSAUpdater;\nclass ScalarEvolution;\nclass raw_ostream;\ntemplate <class N, bool IsPostDom> class DominatorTreeBase;\ntemplate <class N, class M> class LoopInfoBase;\ntemplate <class N, class M> class LoopBase;\n\n//===----------------------------------------------------------------------===//\n/// Instances of this class are used to represent loops that are detected in the\n/// flow graph.\n///\ntemplate <class BlockT, class LoopT> class LoopBase {\n  LoopT *ParentLoop;\n  // Loops contained entirely within this one.\n  std::vector<LoopT *> SubLoops;\n\n  // The list of blocks in this loop. First entry is the header node.\n  std::vector<BlockT *> Blocks;\n\n  SmallPtrSet<const BlockT *, 8> DenseBlockSet;\n\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  /// Indicator that this loop is no longer a valid loop.\n  bool IsInvalid = false;\n#endif\n\n  LoopBase(const LoopBase<BlockT, LoopT> &) = delete;\n  const LoopBase<BlockT, LoopT> &\n  operator=(const LoopBase<BlockT, LoopT> &) = delete;\n\npublic:\n  /// Return the nesting level of this loop.  An outer-most loop has depth 1,\n  /// for consistency with loop depth values used for basic blocks, where depth\n  /// 0 is used for blocks not inside any loops.\n  unsigned getLoopDepth() const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    unsigned D = 1;\n    for (const LoopT *CurLoop = ParentLoop; CurLoop;\n         CurLoop = CurLoop->ParentLoop)\n      ++D;\n    return D;\n  }\n  BlockT *getHeader() const { return getBlocks().front(); }\n  /// Return the parent loop if it exists or nullptr for top\n  /// level loops.\n\n  /// A loop is either top-level in a function (that is, it is not\n  /// contained in any other loop) or it is entirely enclosed in\n  /// some other loop.\n  /// If a loop is top-level, it has no parent, otherwise its\n  /// parent is the innermost loop in which it is enclosed.\n  LoopT *getParentLoop() const { return ParentLoop; }\n\n  /// This is a raw interface for bypassing addChildLoop.\n  void setParentLoop(LoopT *L) {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    ParentLoop = L;\n  }\n\n  /// Return true if the specified loop is contained within in this loop.\n  bool contains(const LoopT *L) const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    if (L == this)\n      return true;\n    if (!L)\n      return false;\n    return contains(L->getParentLoop());\n  }\n\n  /// Return true if the specified basic block is in this loop.\n  bool contains(const BlockT *BB) const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return DenseBlockSet.count(BB);\n  }\n\n  /// Return true if the specified instruction is in this loop.\n  template <class InstT> bool contains(const InstT *Inst) const {\n    return contains(Inst->getParent());\n  }\n\n  /// Return the loops contained entirely within this loop.\n  const std::vector<LoopT *> &getSubLoops() const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return SubLoops;\n  }\n  std::vector<LoopT *> &getSubLoopsVector() {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return SubLoops;\n  }\n  typedef typename std::vector<LoopT *>::const_iterator iterator;\n  typedef\n      typename std::vector<LoopT *>::const_reverse_iterator reverse_iterator;\n  iterator begin() const { return getSubLoops().begin(); }\n  iterator end() const { return getSubLoops().end(); }\n  reverse_iterator rbegin() const { return getSubLoops().rbegin(); }\n  reverse_iterator rend() const { return getSubLoops().rend(); }\n\n  // LoopInfo does not detect irreducible control flow, just natural\n  // loops. That is, it is possible that there is cyclic control\n  // flow within the \"innermost loop\" or around the \"outermost\n  // loop\".\n\n  /// Return true if the loop does not contain any (natural) loops.\n  bool isInnermost() const { return getSubLoops().empty(); }\n  /// Return true if the loop does not have a parent (natural) loop\n  // (i.e. it is outermost, which is the same as top-level).\n  bool isOutermost() const { return getParentLoop() == nullptr; }\n\n  /// Get a list of the basic blocks which make up this loop.\n  ArrayRef<BlockT *> getBlocks() const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return Blocks;\n  }\n  typedef typename ArrayRef<BlockT *>::const_iterator block_iterator;\n  block_iterator block_begin() const { return getBlocks().begin(); }\n  block_iterator block_end() const { return getBlocks().end(); }\n  inline iterator_range<block_iterator> blocks() const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return make_range(block_begin(), block_end());\n  }\n\n  /// Get the number of blocks in this loop in constant time.\n  /// Invalidate the loop, indicating that it is no longer a loop.\n  unsigned getNumBlocks() const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return Blocks.size();\n  }\n\n  /// Return a direct, mutable handle to the blocks vector so that we can\n  /// mutate it efficiently with techniques like `std::remove`.\n  std::vector<BlockT *> &getBlocksVector() {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return Blocks;\n  }\n  /// Return a direct, mutable handle to the blocks set so that we can\n  /// mutate it efficiently.\n  SmallPtrSetImpl<const BlockT *> &getBlocksSet() {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return DenseBlockSet;\n  }\n\n  /// Return a direct, immutable handle to the blocks set.\n  const SmallPtrSetImpl<const BlockT *> &getBlocksSet() const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    return DenseBlockSet;\n  }\n\n  /// Return true if this loop is no longer valid.  The only valid use of this\n  /// helper is \"assert(L.isInvalid())\" or equivalent, since IsInvalid is set to\n  /// true by the destructor.  In other words, if this accessor returns true,\n  /// the caller has already triggered UB by calling this accessor; and so it\n  /// can only be called in a context where a return value of true indicates a\n  /// programmer error.\n  bool isInvalid() const {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    return IsInvalid;\n#else\n    return false;\n#endif\n  }\n\n  /// True if terminator in the block can branch to another block that is\n  /// outside of the current loop. \\p BB must be inside the loop.\n  bool isLoopExiting(const BlockT *BB) const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    assert(contains(BB) && \"Exiting block must be part of the loop\");\n    for (const auto *Succ : children<const BlockT *>(BB)) {\n      if (!contains(Succ))\n        return true;\n    }\n    return false;\n  }\n\n  /// Returns true if \\p BB is a loop-latch.\n  /// A latch block is a block that contains a branch back to the header.\n  /// This function is useful when there are multiple latches in a loop\n  /// because \\fn getLoopLatch will return nullptr in that case.\n  bool isLoopLatch(const BlockT *BB) const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    assert(contains(BB) && \"block does not belong to the loop\");\n\n    BlockT *Header = getHeader();\n    auto PredBegin = GraphTraits<Inverse<BlockT *>>::child_begin(Header);\n    auto PredEnd = GraphTraits<Inverse<BlockT *>>::child_end(Header);\n    return std::find(PredBegin, PredEnd, BB) != PredEnd;\n  }\n\n  /// Calculate the number of back edges to the loop header.\n  unsigned getNumBackEdges() const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    unsigned NumBackEdges = 0;\n    BlockT *H = getHeader();\n\n    for (const auto Pred : children<Inverse<BlockT *>>(H))\n      if (contains(Pred))\n        ++NumBackEdges;\n\n    return NumBackEdges;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // APIs for simple analysis of the loop.\n  //\n  // Note that all of these methods can fail on general loops (ie, there may not\n  // be a preheader, etc).  For best success, the loop simplification and\n  // induction variable canonicalization pass should be used to normalize loops\n  // for easy analysis.  These methods assume canonical loops.\n\n  /// Return all blocks inside the loop that have successors outside of the\n  /// loop. These are the blocks _inside of the current loop_ which branch out.\n  /// The returned list is always unique.\n  void getExitingBlocks(SmallVectorImpl<BlockT *> &ExitingBlocks) const;\n\n  /// If getExitingBlocks would return exactly one block, return that block.\n  /// Otherwise return null.\n  BlockT *getExitingBlock() const;\n\n  /// Return all of the successor blocks of this loop. These are the blocks\n  /// _outside of the current loop_ which are branched to.\n  void getExitBlocks(SmallVectorImpl<BlockT *> &ExitBlocks) const;\n\n  /// If getExitBlocks would return exactly one block, return that block.\n  /// Otherwise return null.\n  BlockT *getExitBlock() const;\n\n  /// Return true if no exit block for the loop has a predecessor that is\n  /// outside the loop.\n  bool hasDedicatedExits() const;\n\n  /// Return all unique successor blocks of this loop.\n  /// These are the blocks _outside of the current loop_ which are branched to.\n  void getUniqueExitBlocks(SmallVectorImpl<BlockT *> &ExitBlocks) const;\n\n  /// Return all unique successor blocks of this loop except successors from\n  /// Latch block are not considered. If the exit comes from Latch has also\n  /// non Latch predecessor in a loop it will be added to ExitBlocks.\n  /// These are the blocks _outside of the current loop_ which are branched to.\n  void getUniqueNonLatchExitBlocks(SmallVectorImpl<BlockT *> &ExitBlocks) const;\n\n  /// If getUniqueExitBlocks would return exactly one block, return that block.\n  /// Otherwise return null.\n  BlockT *getUniqueExitBlock() const;\n\n  /// Return true if this loop does not have any exit blocks.\n  bool hasNoExitBlocks() const;\n\n  /// Edge type.\n  typedef std::pair<BlockT *, BlockT *> Edge;\n\n  /// Return all pairs of (_inside_block_,_outside_block_).\n  void getExitEdges(SmallVectorImpl<Edge> &ExitEdges) const;\n\n  /// If there is a preheader for this loop, return it. A loop has a preheader\n  /// if there is only one edge to the header of the loop from outside of the\n  /// loop. If this is the case, the block branching to the header of the loop\n  /// is the preheader node.\n  ///\n  /// This method returns null if there is no preheader for the loop.\n  BlockT *getLoopPreheader() const;\n\n  /// If the given loop's header has exactly one unique predecessor outside the\n  /// loop, return it. Otherwise return null.\n  ///  This is less strict that the loop \"preheader\" concept, which requires\n  /// the predecessor to have exactly one successor.\n  BlockT *getLoopPredecessor() const;\n\n  /// If there is a single latch block for this loop, return it.\n  /// A latch block is a block that contains a branch back to the header.\n  BlockT *getLoopLatch() const;\n\n  /// Return all loop latch blocks of this loop. A latch block is a block that\n  /// contains a branch back to the header.\n  void getLoopLatches(SmallVectorImpl<BlockT *> &LoopLatches) const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    BlockT *H = getHeader();\n    for (const auto Pred : children<Inverse<BlockT *>>(H))\n      if (contains(Pred))\n        LoopLatches.push_back(Pred);\n  }\n\n  /// Return all inner loops in the loop nest rooted by the loop in preorder,\n  /// with siblings in forward program order.\n  template <class Type>\n  static void getInnerLoopsInPreorder(const LoopT &L,\n                                      SmallVectorImpl<Type> &PreOrderLoops) {\n    SmallVector<LoopT *, 4> PreOrderWorklist;\n    PreOrderWorklist.append(L.rbegin(), L.rend());\n\n    while (!PreOrderWorklist.empty()) {\n      LoopT *L = PreOrderWorklist.pop_back_val();\n      // Sub-loops are stored in forward program order, but will process the\n      // worklist backwards so append them in reverse order.\n      PreOrderWorklist.append(L->rbegin(), L->rend());\n      PreOrderLoops.push_back(L);\n    }\n  }\n\n  /// Return all loops in the loop nest rooted by the loop in preorder, with\n  /// siblings in forward program order.\n  SmallVector<const LoopT *, 4> getLoopsInPreorder() const {\n    SmallVector<const LoopT *, 4> PreOrderLoops;\n    const LoopT *CurLoop = static_cast<const LoopT *>(this);\n    PreOrderLoops.push_back(CurLoop);\n    getInnerLoopsInPreorder(*CurLoop, PreOrderLoops);\n    return PreOrderLoops;\n  }\n  SmallVector<LoopT *, 4> getLoopsInPreorder() {\n    SmallVector<LoopT *, 4> PreOrderLoops;\n    LoopT *CurLoop = static_cast<LoopT *>(this);\n    PreOrderLoops.push_back(CurLoop);\n    getInnerLoopsInPreorder(*CurLoop, PreOrderLoops);\n    return PreOrderLoops;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // APIs for updating loop information after changing the CFG\n  //\n\n  /// This method is used by other analyses to update loop information.\n  /// NewBB is set to be a new member of the current loop.\n  /// Because of this, it is added as a member of all parent loops, and is added\n  /// to the specified LoopInfo object as being in the current basic block.  It\n  /// is not valid to replace the loop header with this method.\n  void addBasicBlockToLoop(BlockT *NewBB, LoopInfoBase<BlockT, LoopT> &LI);\n\n  /// This is used when splitting loops up. It replaces the OldChild entry in\n  /// our children list with NewChild, and updates the parent pointer of\n  /// OldChild to be null and the NewChild to be this loop.\n  /// This updates the loop depth of the new child.\n  void replaceChildLoopWith(LoopT *OldChild, LoopT *NewChild);\n\n  /// Add the specified loop to be a child of this loop.\n  /// This updates the loop depth of the new child.\n  void addChildLoop(LoopT *NewChild) {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    assert(!NewChild->ParentLoop && \"NewChild already has a parent!\");\n    NewChild->ParentLoop = static_cast<LoopT *>(this);\n    SubLoops.push_back(NewChild);\n  }\n\n  /// This removes the specified child from being a subloop of this loop. The\n  /// loop is not deleted, as it will presumably be inserted into another loop.\n  LoopT *removeChildLoop(iterator I) {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    assert(I != SubLoops.end() && \"Cannot remove end iterator!\");\n    LoopT *Child = *I;\n    assert(Child->ParentLoop == this && \"Child is not a child of this loop!\");\n    SubLoops.erase(SubLoops.begin() + (I - begin()));\n    Child->ParentLoop = nullptr;\n    return Child;\n  }\n\n  /// This removes the specified child from being a subloop of this loop. The\n  /// loop is not deleted, as it will presumably be inserted into another loop.\n  LoopT *removeChildLoop(LoopT *Child) {\n    return removeChildLoop(llvm::find(*this, Child));\n  }\n\n  /// This adds a basic block directly to the basic block list.\n  /// This should only be used by transformations that create new loops.  Other\n  /// transformations should use addBasicBlockToLoop.\n  void addBlockEntry(BlockT *BB) {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    Blocks.push_back(BB);\n    DenseBlockSet.insert(BB);\n  }\n\n  /// interface to reverse Blocks[from, end of loop] in this loop\n  void reverseBlock(unsigned from) {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    std::reverse(Blocks.begin() + from, Blocks.end());\n  }\n\n  /// interface to do reserve() for Blocks\n  void reserveBlocks(unsigned size) {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    Blocks.reserve(size);\n  }\n\n  /// This method is used to move BB (which must be part of this loop) to be the\n  /// loop header of the loop (the block that dominates all others).\n  void moveToHeader(BlockT *BB) {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    if (Blocks[0] == BB)\n      return;\n    for (unsigned i = 0;; ++i) {\n      assert(i != Blocks.size() && \"Loop does not contain BB!\");\n      if (Blocks[i] == BB) {\n        Blocks[i] = Blocks[0];\n        Blocks[0] = BB;\n        return;\n      }\n    }\n  }\n\n  /// This removes the specified basic block from the current loop, updating the\n  /// Blocks as appropriate. This does not update the mapping in the LoopInfo\n  /// class.\n  void removeBlockFromLoop(BlockT *BB) {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    auto I = find(Blocks, BB);\n    assert(I != Blocks.end() && \"N is not in this list!\");\n    Blocks.erase(I);\n\n    DenseBlockSet.erase(BB);\n  }\n\n  /// Verify loop structure\n  void verifyLoop() const;\n\n  /// Verify loop structure of this loop and all nested loops.\n  void verifyLoopNest(DenseSet<const LoopT *> *Loops) const;\n\n  /// Returns true if the loop is annotated parallel.\n  ///\n  /// Derived classes can override this method using static template\n  /// polymorphism.\n  bool isAnnotatedParallel() const { return false; }\n\n  /// Print loop with all the BBs inside it.\n  void print(raw_ostream &OS, unsigned Depth = 0, bool Verbose = false) const;\n\nprotected:\n  friend class LoopInfoBase<BlockT, LoopT>;\n\n  /// This creates an empty loop.\n  LoopBase() : ParentLoop(nullptr) {}\n\n  explicit LoopBase(BlockT *BB) : ParentLoop(nullptr) {\n    Blocks.push_back(BB);\n    DenseBlockSet.insert(BB);\n  }\n\n  // Since loop passes like SCEV are allowed to key analysis results off of\n  // `Loop` pointers, we cannot re-use pointers within a loop pass manager.\n  // This means loop passes should not be `delete` ing `Loop` objects directly\n  // (and risk a later `Loop` allocation re-using the address of a previous one)\n  // but should be using LoopInfo::markAsRemoved, which keeps around the `Loop`\n  // pointer till the end of the lifetime of the `LoopInfo` object.\n  //\n  // To make it easier to follow this rule, we mark the destructor as\n  // non-public.\n  ~LoopBase() {\n    for (auto *SubLoop : SubLoops)\n      SubLoop->~LoopT();\n\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    IsInvalid = true;\n#endif\n    SubLoops.clear();\n    Blocks.clear();\n    DenseBlockSet.clear();\n    ParentLoop = nullptr;\n  }\n};\n\ntemplate <class BlockT, class LoopT>\nraw_ostream &operator<<(raw_ostream &OS, const LoopBase<BlockT, LoopT> &Loop) {\n  Loop.print(OS);\n  return OS;\n}\n\n// Implementation in LoopInfoImpl.h\nextern template class LoopBase<BasicBlock, Loop>;\n\n/// Represents a single loop in the control flow graph.  Note that not all SCCs\n/// in the CFG are necessarily loops.\nclass Loop : public LoopBase<BasicBlock, Loop> {\npublic:\n  /// A range representing the start and end location of a loop.\n  class LocRange {\n    DebugLoc Start;\n    DebugLoc End;\n\n  public:\n    LocRange() {}\n    LocRange(DebugLoc Start) : Start(Start), End(Start) {}\n    LocRange(DebugLoc Start, DebugLoc End)\n        : Start(std::move(Start)), End(std::move(End)) {}\n\n    const DebugLoc &getStart() const { return Start; }\n    const DebugLoc &getEnd() const { return End; }\n\n    /// Check for null.\n    ///\n    explicit operator bool() const { return Start && End; }\n  };\n\n  /// Return true if the specified value is loop invariant.\n  bool isLoopInvariant(const Value *V) const;\n\n  /// Return true if all the operands of the specified instruction are loop\n  /// invariant.\n  bool hasLoopInvariantOperands(const Instruction *I) const;\n\n  /// If the given value is an instruction inside of the loop and it can be\n  /// hoisted, do so to make it trivially loop-invariant.\n  /// Return true if the value after any hoisting is loop invariant. This\n  /// function can be used as a slightly more aggressive replacement for\n  /// isLoopInvariant.\n  ///\n  /// If InsertPt is specified, it is the point to hoist instructions to.\n  /// If null, the terminator of the loop preheader is used.\n  bool makeLoopInvariant(Value *V, bool &Changed,\n                         Instruction *InsertPt = nullptr,\n                         MemorySSAUpdater *MSSAU = nullptr) const;\n\n  /// If the given instruction is inside of the loop and it can be hoisted, do\n  /// so to make it trivially loop-invariant.\n  /// Return true if the instruction after any hoisting is loop invariant. This\n  /// function can be used as a slightly more aggressive replacement for\n  /// isLoopInvariant.\n  ///\n  /// If InsertPt is specified, it is the point to hoist instructions to.\n  /// If null, the terminator of the loop preheader is used.\n  ///\n  bool makeLoopInvariant(Instruction *I, bool &Changed,\n                         Instruction *InsertPt = nullptr,\n                         MemorySSAUpdater *MSSAU = nullptr) const;\n\n  /// Check to see if the loop has a canonical induction variable: an integer\n  /// recurrence that starts at 0 and increments by one each time through the\n  /// loop. If so, return the phi node that corresponds to it.\n  ///\n  /// The IndVarSimplify pass transforms loops to have a canonical induction\n  /// variable.\n  ///\n  PHINode *getCanonicalInductionVariable() const;\n\n  /// Obtain the unique incoming and back edge. Return false if they are\n  /// non-unique or the loop is dead; otherwise, return true.\n  bool getIncomingAndBackEdge(BasicBlock *&Incoming,\n                              BasicBlock *&Backedge) const;\n\n  /// Below are some utilities to get the loop guard, loop bounds and induction\n  /// variable, and to check if a given phinode is an auxiliary induction\n  /// variable, if the loop is guarded, and if the loop is canonical.\n  ///\n  /// Here is an example:\n  /// \\code\n  /// for (int i = lb; i < ub; i+=step)\n  ///   <loop body>\n  /// --- pseudo LLVMIR ---\n  /// beforeloop:\n  ///   guardcmp = (lb < ub)\n  ///   if (guardcmp) goto preheader; else goto afterloop\n  /// preheader:\n  /// loop:\n  ///   i_1 = phi[{lb, preheader}, {i_2, latch}]\n  ///   <loop body>\n  ///   i_2 = i_1 + step\n  /// latch:\n  ///   cmp = (i_2 < ub)\n  ///   if (cmp) goto loop\n  /// exit:\n  /// afterloop:\n  /// \\endcode\n  ///\n  /// - getBounds\n  ///   - getInitialIVValue      --> lb\n  ///   - getStepInst            --> i_2 = i_1 + step\n  ///   - getStepValue           --> step\n  ///   - getFinalIVValue        --> ub\n  ///   - getCanonicalPredicate  --> '<'\n  ///   - getDirection           --> Increasing\n  ///\n  /// - getInductionVariable            --> i_1\n  /// - isAuxiliaryInductionVariable(x) --> true if x == i_1\n  /// - getLoopGuardBranch()\n  ///                 --> `if (guardcmp) goto preheader; else goto afterloop`\n  /// - isGuarded()                     --> true\n  /// - isCanonical                     --> false\n  struct LoopBounds {\n    /// Return the LoopBounds object if\n    /// - the given \\p IndVar is an induction variable\n    /// - the initial value of the induction variable can be found\n    /// - the step instruction of the induction variable can be found\n    /// - the final value of the induction variable can be found\n    ///\n    /// Else None.\n    static Optional<Loop::LoopBounds> getBounds(const Loop &L, PHINode &IndVar,\n                                                ScalarEvolution &SE);\n\n    /// Get the initial value of the loop induction variable.\n    Value &getInitialIVValue() const { return InitialIVValue; }\n\n    /// Get the instruction that updates the loop induction variable.\n    Instruction &getStepInst() const { return StepInst; }\n\n    /// Get the step that the loop induction variable gets updated by in each\n    /// loop iteration. Return nullptr if not found.\n    Value *getStepValue() const { return StepValue; }\n\n    /// Get the final value of the loop induction variable.\n    Value &getFinalIVValue() const { return FinalIVValue; }\n\n    /// Return the canonical predicate for the latch compare instruction, if\n    /// able to be calcuated. Else BAD_ICMP_PREDICATE.\n    ///\n    /// A predicate is considered as canonical if requirements below are all\n    /// satisfied:\n    /// 1. The first successor of the latch branch is the loop header\n    ///    If not, inverse the predicate.\n    /// 2. One of the operands of the latch comparison is StepInst\n    ///    If not, and\n    ///    - if the current calcuated predicate is not ne or eq, flip the\n    ///      predicate.\n    ///    - else if the loop is increasing, return slt\n    ///      (notice that it is safe to change from ne or eq to sign compare)\n    ///    - else if the loop is decreasing, return sgt\n    ///      (notice that it is safe to change from ne or eq to sign compare)\n    ///\n    /// Here is an example when both (1) and (2) are not satisfied:\n    /// \\code\n    /// loop.header:\n    ///  %iv = phi [%initialiv, %loop.preheader], [%inc, %loop.header]\n    ///  %inc = add %iv, %step\n    ///  %cmp = slt %iv, %finaliv\n    ///  br %cmp, %loop.exit, %loop.header\n    /// loop.exit:\n    /// \\endcode\n    /// - The second successor of the latch branch is the loop header instead\n    ///   of the first successor (slt -> sge)\n    /// - The first operand of the latch comparison (%cmp) is the IndVar (%iv)\n    ///   instead of the StepInst (%inc) (sge -> sgt)\n    ///\n    /// The predicate would be sgt if both (1) and (2) are satisfied.\n    /// getCanonicalPredicate() returns sgt for this example.\n    /// Note: The IR is not changed.\n    ICmpInst::Predicate getCanonicalPredicate() const;\n\n    /// An enum for the direction of the loop\n    /// - for (int i = 0; i < ub; ++i)  --> Increasing\n    /// - for (int i = ub; i > 0; --i)  --> Descresing\n    /// - for (int i = x; i != y; i+=z) --> Unknown\n    enum class Direction { Increasing, Decreasing, Unknown };\n\n    /// Get the direction of the loop.\n    Direction getDirection() const;\n\n  private:\n    LoopBounds(const Loop &Loop, Value &I, Instruction &SI, Value *SV, Value &F,\n               ScalarEvolution &SE)\n        : L(Loop), InitialIVValue(I), StepInst(SI), StepValue(SV),\n          FinalIVValue(F), SE(SE) {}\n\n    const Loop &L;\n\n    // The initial value of the loop induction variable\n    Value &InitialIVValue;\n\n    // The instruction that updates the loop induction variable\n    Instruction &StepInst;\n\n    // The value that the loop induction variable gets updated by in each loop\n    // iteration\n    Value *StepValue;\n\n    // The final value of the loop induction variable\n    Value &FinalIVValue;\n\n    ScalarEvolution &SE;\n  };\n\n  /// Return the struct LoopBounds collected if all struct members are found,\n  /// else None.\n  Optional<LoopBounds> getBounds(ScalarEvolution &SE) const;\n\n  /// Return the loop induction variable if found, else return nullptr.\n  /// An instruction is considered as the loop induction variable if\n  /// - it is an induction variable of the loop; and\n  /// - it is used to determine the condition of the branch in the loop latch\n  ///\n  /// Note: the induction variable doesn't need to be canonical, i.e. starts at\n  /// zero and increments by one each time through the loop (but it can be).\n  PHINode *getInductionVariable(ScalarEvolution &SE) const;\n\n  /// Get the loop induction descriptor for the loop induction variable. Return\n  /// true if the loop induction variable is found.\n  bool getInductionDescriptor(ScalarEvolution &SE,\n                              InductionDescriptor &IndDesc) const;\n\n  /// Return true if the given PHINode \\p AuxIndVar is\n  /// - in the loop header\n  /// - not used outside of the loop\n  /// - incremented by a loop invariant step for each loop iteration\n  /// - step instruction opcode should be add or sub\n  /// Note: auxiliary induction variable is not required to be used in the\n  ///       conditional branch in the loop latch. (but it can be)\n  bool isAuxiliaryInductionVariable(PHINode &AuxIndVar,\n                                    ScalarEvolution &SE) const;\n\n  /// Return the loop guard branch, if it exists.\n  ///\n  /// This currently only works on simplified loop, as it requires a preheader\n  /// and a latch to identify the guard. It will work on loops of the form:\n  /// \\code\n  /// GuardBB:\n  ///   br cond1, Preheader, ExitSucc <== GuardBranch\n  /// Preheader:\n  ///   br Header\n  /// Header:\n  ///  ...\n  ///   br Latch\n  /// Latch:\n  ///   br cond2, Header, ExitBlock\n  /// ExitBlock:\n  ///   br ExitSucc\n  /// ExitSucc:\n  /// \\endcode\n  BranchInst *getLoopGuardBranch() const;\n\n  /// Return true iff the loop is\n  /// - in simplify rotated form, and\n  /// - guarded by a loop guard branch.\n  bool isGuarded() const { return (getLoopGuardBranch() != nullptr); }\n\n  /// Return true if the loop is in rotated form.\n  ///\n  /// This does not check if the loop was rotated by loop rotation, instead it\n  /// only checks if the loop is in rotated form (has a valid latch that exists\n  /// the loop).\n  bool isRotatedForm() const {\n    assert(!isInvalid() && \"Loop not in a valid state!\");\n    BasicBlock *Latch = getLoopLatch();\n    return Latch && isLoopExiting(Latch);\n  }\n\n  /// Return true if the loop induction variable starts at zero and increments\n  /// by one each time through the loop.\n  bool isCanonical(ScalarEvolution &SE) const;\n\n  /// Return true if the Loop is in LCSSA form.\n  bool isLCSSAForm(const DominatorTree &DT) const;\n\n  /// Return true if this Loop and all inner subloops are in LCSSA form.\n  bool isRecursivelyLCSSAForm(const DominatorTree &DT,\n                              const LoopInfo &LI) const;\n\n  /// Return true if the Loop is in the form that the LoopSimplify form\n  /// transforms loops to, which is sometimes called normal form.\n  bool isLoopSimplifyForm() const;\n\n  /// Return true if the loop body is safe to clone in practice.\n  bool isSafeToClone() const;\n\n  /// Returns true if the loop is annotated parallel.\n  ///\n  /// A parallel loop can be assumed to not contain any dependencies between\n  /// iterations by the compiler. That is, any loop-carried dependency checking\n  /// can be skipped completely when parallelizing the loop on the target\n  /// machine. Thus, if the parallel loop information originates from the\n  /// programmer, e.g. via the OpenMP parallel for pragma, it is the\n  /// programmer's responsibility to ensure there are no loop-carried\n  /// dependencies. The final execution order of the instructions across\n  /// iterations is not guaranteed, thus, the end result might or might not\n  /// implement actual concurrent execution of instructions across multiple\n  /// iterations.\n  bool isAnnotatedParallel() const;\n\n  /// Return the llvm.loop loop id metadata node for this loop if it is present.\n  ///\n  /// If this loop contains the same llvm.loop metadata on each branch to the\n  /// header then the node is returned. If any latch instruction does not\n  /// contain llvm.loop or if multiple latches contain different nodes then\n  /// 0 is returned.\n  MDNode *getLoopID() const;\n  /// Set the llvm.loop loop id metadata for this loop.\n  ///\n  /// The LoopID metadata node will be added to each terminator instruction in\n  /// the loop that branches to the loop header.\n  ///\n  /// The LoopID metadata node should have one or more operands and the first\n  /// operand should be the node itself.\n  void setLoopID(MDNode *LoopID) const;\n\n  /// Add llvm.loop.unroll.disable to this loop's loop id metadata.\n  ///\n  /// Remove existing unroll metadata and add unroll disable metadata to\n  /// indicate the loop has already been unrolled.  This prevents a loop\n  /// from being unrolled more than is directed by a pragma if the loop\n  /// unrolling pass is run more than once (which it generally is).\n  void setLoopAlreadyUnrolled();\n\n  /// Add llvm.loop.mustprogress to this loop's loop id metadata.\n  void setLoopMustProgress();\n\n  void dump() const;\n  void dumpVerbose() const;\n\n  /// Return the debug location of the start of this loop.\n  /// This looks for a BB terminating instruction with a known debug\n  /// location by looking at the preheader and header blocks. If it\n  /// cannot find a terminating instruction with location information,\n  /// it returns an unknown location.\n  DebugLoc getStartLoc() const;\n\n  /// Return the source code span of the loop.\n  LocRange getLocRange() const;\n\n  StringRef getName() const {\n    if (BasicBlock *Header = getHeader())\n      if (Header->hasName())\n        return Header->getName();\n    return \"<unnamed loop>\";\n  }\n\nprivate:\n  Loop() = default;\n\n  friend class LoopInfoBase<BasicBlock, Loop>;\n  friend class LoopBase<BasicBlock, Loop>;\n  explicit Loop(BasicBlock *BB) : LoopBase<BasicBlock, Loop>(BB) {}\n  ~Loop() = default;\n};\n\n//===----------------------------------------------------------------------===//\n/// This class builds and contains all of the top-level loop\n/// structures in the specified function.\n///\n\ntemplate <class BlockT, class LoopT> class LoopInfoBase {\n  // BBMap - Mapping of basic blocks to the inner most loop they occur in\n  DenseMap<const BlockT *, LoopT *> BBMap;\n  std::vector<LoopT *> TopLevelLoops;\n  BumpPtrAllocator LoopAllocator;\n\n  friend class LoopBase<BlockT, LoopT>;\n  friend class LoopInfo;\n\n  void operator=(const LoopInfoBase &) = delete;\n  LoopInfoBase(const LoopInfoBase &) = delete;\n\npublic:\n  LoopInfoBase() {}\n  ~LoopInfoBase() { releaseMemory(); }\n\n  LoopInfoBase(LoopInfoBase &&Arg)\n      : BBMap(std::move(Arg.BBMap)),\n        TopLevelLoops(std::move(Arg.TopLevelLoops)),\n        LoopAllocator(std::move(Arg.LoopAllocator)) {\n    // We have to clear the arguments top level loops as we've taken ownership.\n    Arg.TopLevelLoops.clear();\n  }\n  LoopInfoBase &operator=(LoopInfoBase &&RHS) {\n    BBMap = std::move(RHS.BBMap);\n\n    for (auto *L : TopLevelLoops)\n      L->~LoopT();\n\n    TopLevelLoops = std::move(RHS.TopLevelLoops);\n    LoopAllocator = std::move(RHS.LoopAllocator);\n    RHS.TopLevelLoops.clear();\n    return *this;\n  }\n\n  void releaseMemory() {\n    BBMap.clear();\n\n    for (auto *L : TopLevelLoops)\n      L->~LoopT();\n    TopLevelLoops.clear();\n    LoopAllocator.Reset();\n  }\n\n  template <typename... ArgsTy> LoopT *AllocateLoop(ArgsTy &&... Args) {\n    LoopT *Storage = LoopAllocator.Allocate<LoopT>();\n    return new (Storage) LoopT(std::forward<ArgsTy>(Args)...);\n  }\n\n  /// iterator/begin/end - The interface to the top-level loops in the current\n  /// function.\n  ///\n  typedef typename std::vector<LoopT *>::const_iterator iterator;\n  typedef\n      typename std::vector<LoopT *>::const_reverse_iterator reverse_iterator;\n  iterator begin() const { return TopLevelLoops.begin(); }\n  iterator end() const { return TopLevelLoops.end(); }\n  reverse_iterator rbegin() const { return TopLevelLoops.rbegin(); }\n  reverse_iterator rend() const { return TopLevelLoops.rend(); }\n  bool empty() const { return TopLevelLoops.empty(); }\n\n  /// Return all of the loops in the function in preorder across the loop\n  /// nests, with siblings in forward program order.\n  ///\n  /// Note that because loops form a forest of trees, preorder is equivalent to\n  /// reverse postorder.\n  SmallVector<LoopT *, 4> getLoopsInPreorder();\n\n  /// Return all of the loops in the function in preorder across the loop\n  /// nests, with siblings in *reverse* program order.\n  ///\n  /// Note that because loops form a forest of trees, preorder is equivalent to\n  /// reverse postorder.\n  ///\n  /// Also note that this is *not* a reverse preorder. Only the siblings are in\n  /// reverse program order.\n  SmallVector<LoopT *, 4> getLoopsInReverseSiblingPreorder();\n\n  /// Return the inner most loop that BB lives in. If a basic block is in no\n  /// loop (for example the entry node), null is returned.\n  LoopT *getLoopFor(const BlockT *BB) const { return BBMap.lookup(BB); }\n\n  /// Same as getLoopFor.\n  const LoopT *operator[](const BlockT *BB) const { return getLoopFor(BB); }\n\n  /// Return the loop nesting level of the specified block. A depth of 0 means\n  /// the block is not inside any loop.\n  unsigned getLoopDepth(const BlockT *BB) const {\n    const LoopT *L = getLoopFor(BB);\n    return L ? L->getLoopDepth() : 0;\n  }\n\n  // True if the block is a loop header node\n  bool isLoopHeader(const BlockT *BB) const {\n    const LoopT *L = getLoopFor(BB);\n    return L && L->getHeader() == BB;\n  }\n\n  /// Return the top-level loops.\n  const std::vector<LoopT *> &getTopLevelLoops() const { return TopLevelLoops; }\n\n  /// Return the top-level loops.\n  std::vector<LoopT *> &getTopLevelLoopsVector() { return TopLevelLoops; }\n\n  /// This removes the specified top-level loop from this loop info object.\n  /// The loop is not deleted, as it will presumably be inserted into\n  /// another loop.\n  LoopT *removeLoop(iterator I) {\n    assert(I != end() && \"Cannot remove end iterator!\");\n    LoopT *L = *I;\n    assert(L->isOutermost() && \"Not a top-level loop!\");\n    TopLevelLoops.erase(TopLevelLoops.begin() + (I - begin()));\n    return L;\n  }\n\n  /// Change the top-level loop that contains BB to the specified loop.\n  /// This should be used by transformations that restructure the loop hierarchy\n  /// tree.\n  void changeLoopFor(BlockT *BB, LoopT *L) {\n    if (!L) {\n      BBMap.erase(BB);\n      return;\n    }\n    BBMap[BB] = L;\n  }\n\n  /// Replace the specified loop in the top-level loops list with the indicated\n  /// loop.\n  void changeTopLevelLoop(LoopT *OldLoop, LoopT *NewLoop) {\n    auto I = find(TopLevelLoops, OldLoop);\n    assert(I != TopLevelLoops.end() && \"Old loop not at top level!\");\n    *I = NewLoop;\n    assert(!NewLoop->ParentLoop && !OldLoop->ParentLoop &&\n           \"Loops already embedded into a subloop!\");\n  }\n\n  /// This adds the specified loop to the collection of top-level loops.\n  void addTopLevelLoop(LoopT *New) {\n    assert(New->isOutermost() && \"Loop already in subloop!\");\n    TopLevelLoops.push_back(New);\n  }\n\n  /// This method completely removes BB from all data structures,\n  /// including all of the Loop objects it is nested in and our mapping from\n  /// BasicBlocks to loops.\n  void removeBlock(BlockT *BB) {\n    auto I = BBMap.find(BB);\n    if (I != BBMap.end()) {\n      for (LoopT *L = I->second; L; L = L->getParentLoop())\n        L->removeBlockFromLoop(BB);\n\n      BBMap.erase(I);\n    }\n  }\n\n  // Internals\n\n  static bool isNotAlreadyContainedIn(const LoopT *SubLoop,\n                                      const LoopT *ParentLoop) {\n    if (!SubLoop)\n      return true;\n    if (SubLoop == ParentLoop)\n      return false;\n    return isNotAlreadyContainedIn(SubLoop->getParentLoop(), ParentLoop);\n  }\n\n  /// Create the loop forest using a stable algorithm.\n  void analyze(const DominatorTreeBase<BlockT, false> &DomTree);\n\n  // Debugging\n  void print(raw_ostream &OS) const;\n\n  void verify(const DominatorTreeBase<BlockT, false> &DomTree) const;\n\n  /// Destroy a loop that has been removed from the `LoopInfo` nest.\n  ///\n  /// This runs the destructor of the loop object making it invalid to\n  /// reference afterward. The memory is retained so that the *pointer* to the\n  /// loop remains valid.\n  ///\n  /// The caller is responsible for removing this loop from the loop nest and\n  /// otherwise disconnecting it from the broader `LoopInfo` data structures.\n  /// Callers that don't naturally handle this themselves should probably call\n  /// `erase' instead.\n  void destroy(LoopT *L) {\n    L->~LoopT();\n\n    // Since LoopAllocator is a BumpPtrAllocator, this Deallocate only poisons\n    // \\c L, but the pointer remains valid for non-dereferencing uses.\n    LoopAllocator.Deallocate(L);\n  }\n};\n\n// Implementation in LoopInfoImpl.h\nextern template class LoopInfoBase<BasicBlock, Loop>;\n\nclass LoopInfo : public LoopInfoBase<BasicBlock, Loop> {\n  typedef LoopInfoBase<BasicBlock, Loop> BaseT;\n\n  friend class LoopBase<BasicBlock, Loop>;\n\n  void operator=(const LoopInfo &) = delete;\n  LoopInfo(const LoopInfo &) = delete;\n\npublic:\n  LoopInfo() {}\n  explicit LoopInfo(const DominatorTreeBase<BasicBlock, false> &DomTree);\n\n  LoopInfo(LoopInfo &&Arg) : BaseT(std::move(static_cast<BaseT &>(Arg))) {}\n  LoopInfo &operator=(LoopInfo &&RHS) {\n    BaseT::operator=(std::move(static_cast<BaseT &>(RHS)));\n    return *this;\n  }\n\n  /// Handle invalidation explicitly.\n  bool invalidate(Function &F, const PreservedAnalyses &PA,\n                  FunctionAnalysisManager::Invalidator &);\n\n  // Most of the public interface is provided via LoopInfoBase.\n\n  /// Update LoopInfo after removing the last backedge from a loop. This updates\n  /// the loop forest and parent loops for each block so that \\c L is no longer\n  /// referenced, but does not actually delete \\c L immediately. The pointer\n  /// will remain valid until this LoopInfo's memory is released.\n  void erase(Loop *L);\n\n  /// Returns true if replacing From with To everywhere is guaranteed to\n  /// preserve LCSSA form.\n  bool replacementPreservesLCSSAForm(Instruction *From, Value *To) {\n    // Preserving LCSSA form is only problematic if the replacing value is an\n    // instruction.\n    Instruction *I = dyn_cast<Instruction>(To);\n    if (!I)\n      return true;\n    // If both instructions are defined in the same basic block then replacement\n    // cannot break LCSSA form.\n    if (I->getParent() == From->getParent())\n      return true;\n    // If the instruction is not defined in a loop then it can safely replace\n    // anything.\n    Loop *ToLoop = getLoopFor(I->getParent());\n    if (!ToLoop)\n      return true;\n    // If the replacing instruction is defined in the same loop as the original\n    // instruction, or in a loop that contains it as an inner loop, then using\n    // it as a replacement will not break LCSSA form.\n    return ToLoop->contains(getLoopFor(From->getParent()));\n  }\n\n  /// Checks if moving a specific instruction can break LCSSA in any loop.\n  ///\n  /// Return true if moving \\p Inst to before \\p NewLoc will break LCSSA,\n  /// assuming that the function containing \\p Inst and \\p NewLoc is currently\n  /// in LCSSA form.\n  bool movementPreservesLCSSAForm(Instruction *Inst, Instruction *NewLoc) {\n    assert(Inst->getFunction() == NewLoc->getFunction() &&\n           \"Can't reason about IPO!\");\n\n    auto *OldBB = Inst->getParent();\n    auto *NewBB = NewLoc->getParent();\n\n    // Movement within the same loop does not break LCSSA (the equality check is\n    // to avoid doing a hashtable lookup in case of intra-block movement).\n    if (OldBB == NewBB)\n      return true;\n\n    auto *OldLoop = getLoopFor(OldBB);\n    auto *NewLoop = getLoopFor(NewBB);\n\n    if (OldLoop == NewLoop)\n      return true;\n\n    // Check if Outer contains Inner; with the null loop counting as the\n    // \"outermost\" loop.\n    auto Contains = [](const Loop *Outer, const Loop *Inner) {\n      return !Outer || Outer->contains(Inner);\n    };\n\n    // To check that the movement of Inst to before NewLoc does not break LCSSA,\n    // we need to check two sets of uses for possible LCSSA violations at\n    // NewLoc: the users of NewInst, and the operands of NewInst.\n\n    // If we know we're hoisting Inst out of an inner loop to an outer loop,\n    // then the uses *of* Inst don't need to be checked.\n\n    if (!Contains(NewLoop, OldLoop)) {\n      for (Use &U : Inst->uses()) {\n        auto *UI = cast<Instruction>(U.getUser());\n        auto *UBB = isa<PHINode>(UI) ? cast<PHINode>(UI)->getIncomingBlock(U)\n                                     : UI->getParent();\n        if (UBB != NewBB && getLoopFor(UBB) != NewLoop)\n          return false;\n      }\n    }\n\n    // If we know we're sinking Inst from an outer loop into an inner loop, then\n    // the *operands* of Inst don't need to be checked.\n\n    if (!Contains(OldLoop, NewLoop)) {\n      // See below on why we can't handle phi nodes here.\n      if (isa<PHINode>(Inst))\n        return false;\n\n      for (Use &U : Inst->operands()) {\n        auto *DefI = dyn_cast<Instruction>(U.get());\n        if (!DefI)\n          return false;\n\n        // This would need adjustment if we allow Inst to be a phi node -- the\n        // new use block won't simply be NewBB.\n\n        auto *DefBlock = DefI->getParent();\n        if (DefBlock != NewBB && getLoopFor(DefBlock) != NewLoop)\n          return false;\n      }\n    }\n\n    return true;\n  }\n};\n\n// Allow clients to walk the list of nested loops...\ntemplate <> struct GraphTraits<const Loop *> {\n  typedef const Loop *NodeRef;\n  typedef LoopInfo::iterator ChildIteratorType;\n\n  static NodeRef getEntryNode(const Loop *L) { return L; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->end(); }\n};\n\ntemplate <> struct GraphTraits<Loop *> {\n  typedef Loop *NodeRef;\n  typedef LoopInfo::iterator ChildIteratorType;\n\n  static NodeRef getEntryNode(Loop *L) { return L; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->end(); }\n};\n\n/// Analysis pass that exposes the \\c LoopInfo for a function.\nclass LoopAnalysis : public AnalysisInfoMixin<LoopAnalysis> {\n  friend AnalysisInfoMixin<LoopAnalysis>;\n  static AnalysisKey Key;\n\npublic:\n  typedef LoopInfo Result;\n\n  LoopInfo run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Printer pass for the \\c LoopAnalysis results.\nclass LoopPrinterPass : public PassInfoMixin<LoopPrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit LoopPrinterPass(raw_ostream &OS) : OS(OS) {}\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Verifier pass for the \\c LoopAnalysis results.\nstruct LoopVerifierPass : public PassInfoMixin<LoopVerifierPass> {\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// The legacy pass manager's analysis pass to compute loop information.\nclass LoopInfoWrapperPass : public FunctionPass {\n  LoopInfo LI;\n\npublic:\n  static char ID; // Pass identification, replacement for typeid\n\n  LoopInfoWrapperPass();\n\n  LoopInfo &getLoopInfo() { return LI; }\n  const LoopInfo &getLoopInfo() const { return LI; }\n\n  /// Calculate the natural loop information for a given function.\n  bool runOnFunction(Function &F) override;\n\n  void verifyAnalysis() const override;\n\n  void releaseMemory() override { LI.releaseMemory(); }\n\n  void print(raw_ostream &O, const Module *M = nullptr) const override;\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n};\n\n/// Function to print a loop's contents as LLVM's text IR assembly.\nvoid printLoop(Loop &L, raw_ostream &OS, const std::string &Banner = \"\");\n\n/// Find and return the loop attribute node for the attribute @p Name in\n/// @p LoopID. Return nullptr if there is no such attribute.\nMDNode *findOptionMDForLoopID(MDNode *LoopID, StringRef Name);\n\n/// Find string metadata for a loop.\n///\n/// Returns the MDNode where the first operand is the metadata's name. The\n/// following operands are the metadata's values. If no metadata with @p Name is\n/// found, return nullptr.\nMDNode *findOptionMDForLoop(const Loop *TheLoop, StringRef Name);\n\n/// Return whether an MDNode might represent an access group.\n///\n/// Access group metadata nodes have to be distinct and empty. Being\n/// always-empty ensures that it never needs to be changed (which -- because\n/// MDNodes are designed immutable -- would require creating a new MDNode). Note\n/// that this is not a sufficient condition: not every distinct and empty NDNode\n/// is representing an access group.\nbool isValidAsAccessGroup(MDNode *AccGroup);\n\n/// Create a new LoopID after the loop has been transformed.\n///\n/// This can be used when no follow-up loop attributes are defined\n/// (llvm::makeFollowupLoopID returning None) to stop transformations to be\n/// applied again.\n///\n/// @param Context        The LLVMContext in which to create the new LoopID.\n/// @param OrigLoopID     The original LoopID; can be nullptr if the original\n///                       loop has no LoopID.\n/// @param RemovePrefixes Remove all loop attributes that have these prefixes.\n///                       Use to remove metadata of the transformation that has\n///                       been applied.\n/// @param AddAttrs       Add these loop attributes to the new LoopID.\n///\n/// @return A new LoopID that can be applied using Loop::setLoopID().\nllvm::MDNode *\nmakePostTransformationMetadata(llvm::LLVMContext &Context, MDNode *OrigLoopID,\n                               llvm::ArrayRef<llvm::StringRef> RemovePrefixes,\n                               llvm::ArrayRef<llvm::MDNode *> AddAttrs);\n\n} // End llvm namespace\n\n#endif\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h", "content": "//===- MemorySSA.h - Build Memory SSA ---------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// This file exposes an interface to building/using memory SSA to\n/// walk memory instructions using a use/def graph.\n///\n/// Memory SSA class builds an SSA form that links together memory access\n/// instructions such as loads, stores, atomics, and calls. Additionally, it\n/// does a trivial form of \"heap versioning\" Every time the memory state changes\n/// in the program, we generate a new heap version. It generates\n/// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.\n///\n/// As a trivial example,\n/// define i32 @main() #0 {\n/// entry:\n///   %call = call noalias i8* @_Znwm(i64 4) #2\n///   %0 = bitcast i8* %call to i32*\n///   %call1 = call noalias i8* @_Znwm(i64 4) #2\n///   %1 = bitcast i8* %call1 to i32*\n///   store i32 5, i32* %0, align 4\n///   store i32 7, i32* %1, align 4\n///   %2 = load i32* %0, align 4\n///   %3 = load i32* %1, align 4\n///   %add = add nsw i32 %2, %3\n///   ret i32 %add\n/// }\n///\n/// Will become\n/// define i32 @main() #0 {\n/// entry:\n///   ; 1 = MemoryDef(0)\n///   %call = call noalias i8* @_Znwm(i64 4) #3\n///   %2 = bitcast i8* %call to i32*\n///   ; 2 = MemoryDef(1)\n///   %call1 = call noalias i8* @_Znwm(i64 4) #3\n///   %4 = bitcast i8* %call1 to i32*\n///   ; 3 = MemoryDef(2)\n///   store i32 5, i32* %2, align 4\n///   ; 4 = MemoryDef(3)\n///   store i32 7, i32* %4, align 4\n///   ; MemoryUse(3)\n///   %7 = load i32* %2, align 4\n///   ; MemoryUse(4)\n///   %8 = load i32* %4, align 4\n///   %add = add nsw i32 %7, %8\n///   ret i32 %add\n/// }\n///\n/// Given this form, all the stores that could ever effect the load at %8 can be\n/// gotten by using the MemoryUse associated with it, and walking from use to\n/// def until you hit the top of the function.\n///\n/// Each def also has a list of users associated with it, so you can walk from\n/// both def to users, and users to defs. Note that we disambiguate MemoryUses,\n/// but not the RHS of MemoryDefs. You can see this above at %7, which would\n/// otherwise be a MemoryUse(4). Being disambiguated means that for a given\n/// store, all the MemoryUses on its use lists are may-aliases of that store\n/// (but the MemoryDefs on its use list may not be).\n///\n/// MemoryDefs are not disambiguated because it would require multiple reaching\n/// definitions, which would require multiple phis, and multiple memoryaccesses\n/// per instruction.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_MEMORYSSA_H\n#define LLVM_ANALYSIS_MEMORYSSA_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/ADT/simple_ilist.h\"\n#include \"llvm/Analysis/AliasAnalysis.h\"\n#include \"llvm/Analysis/MemoryLocation.h\"\n#include \"llvm/Analysis/PHITransAddr.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/DerivedUser.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <memory>\n#include <utility>\n\nnamespace llvm {\n\n/// Enables memory ssa as a dependency for loop passes.\nextern cl::opt<bool> EnableMSSALoopDependency;\n\nclass AllocaInst;\nclass Function;\nclass Instruction;\nclass MemoryAccess;\nclass MemorySSAWalker;\nclass LLVMContext;\nclass raw_ostream;\n\nnamespace MSSAHelpers {\n\nstruct AllAccessTag {};\nstruct DefsOnlyTag {};\n\n} // end namespace MSSAHelpers\n\nenum : unsigned {\n  // Used to signify what the default invalid ID is for MemoryAccess's\n  // getID()\n  INVALID_MEMORYACCESS_ID = -1U\n};\n\ntemplate <class T> class memoryaccess_def_iterator_base;\nusing memoryaccess_def_iterator = memoryaccess_def_iterator_base<MemoryAccess>;\nusing const_memoryaccess_def_iterator =\n    memoryaccess_def_iterator_base<const MemoryAccess>;\n\n// The base for all memory accesses. All memory accesses in a block are\n// linked together using an intrusive list.\nclass MemoryAccess\n    : public DerivedUser,\n      public ilist_node<MemoryAccess, ilist_tag<MSSAHelpers::AllAccessTag>>,\n      public ilist_node<MemoryAccess, ilist_tag<MSSAHelpers::DefsOnlyTag>> {\npublic:\n  using AllAccessType =\n      ilist_node<MemoryAccess, ilist_tag<MSSAHelpers::AllAccessTag>>;\n  using DefsOnlyType =\n      ilist_node<MemoryAccess, ilist_tag<MSSAHelpers::DefsOnlyTag>>;\n\n  MemoryAccess(const MemoryAccess &) = delete;\n  MemoryAccess &operator=(const MemoryAccess &) = delete;\n\n  void *operator new(size_t) = delete;\n\n  // Methods for support type inquiry through isa, cast, and\n  // dyn_cast\n  static bool classof(const Value *V) {\n    unsigned ID = V->getValueID();\n    return ID == MemoryUseVal || ID == MemoryPhiVal || ID == MemoryDefVal;\n  }\n\n  BasicBlock *getBlock() const { return Block; }\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n\n  /// The user iterators for a memory access\n  using iterator = user_iterator;\n  using const_iterator = const_user_iterator;\n\n  /// This iterator walks over all of the defs in a given\n  /// MemoryAccess. For MemoryPhi nodes, this walks arguments. For\n  /// MemoryUse/MemoryDef, this walks the defining access.\n  memoryaccess_def_iterator defs_begin();\n  const_memoryaccess_def_iterator defs_begin() const;\n  memoryaccess_def_iterator defs_end();\n  const_memoryaccess_def_iterator defs_end() const;\n\n  /// Get the iterators for the all access list and the defs only list\n  /// We default to the all access list.\n  AllAccessType::self_iterator getIterator() {\n    return this->AllAccessType::getIterator();\n  }\n  AllAccessType::const_self_iterator getIterator() const {\n    return this->AllAccessType::getIterator();\n  }\n  AllAccessType::reverse_self_iterator getReverseIterator() {\n    return this->AllAccessType::getReverseIterator();\n  }\n  AllAccessType::const_reverse_self_iterator getReverseIterator() const {\n    return this->AllAccessType::getReverseIterator();\n  }\n  DefsOnlyType::self_iterator getDefsIterator() {\n    return this->DefsOnlyType::getIterator();\n  }\n  DefsOnlyType::const_self_iterator getDefsIterator() const {\n    return this->DefsOnlyType::getIterator();\n  }\n  DefsOnlyType::reverse_self_iterator getReverseDefsIterator() {\n    return this->DefsOnlyType::getReverseIterator();\n  }\n  DefsOnlyType::const_reverse_self_iterator getReverseDefsIterator() const {\n    return this->DefsOnlyType::getReverseIterator();\n  }\n\nprotected:\n  friend class MemoryDef;\n  friend class MemoryPhi;\n  friend class MemorySSA;\n  friend class MemoryUse;\n  friend class MemoryUseOrDef;\n\n  /// Used by MemorySSA to change the block of a MemoryAccess when it is\n  /// moved.\n  void setBlock(BasicBlock *BB) { Block = BB; }\n\n  /// Used for debugging and tracking things about MemoryAccesses.\n  /// Guaranteed unique among MemoryAccesses, no guarantees otherwise.\n  inline unsigned getID() const;\n\n  MemoryAccess(LLVMContext &C, unsigned Vty, DeleteValueTy DeleteValue,\n               BasicBlock *BB, unsigned NumOperands)\n      : DerivedUser(Type::getVoidTy(C), Vty, nullptr, NumOperands, DeleteValue),\n        Block(BB) {}\n\n  // Use deleteValue() to delete a generic MemoryAccess.\n  ~MemoryAccess() = default;\n\nprivate:\n  BasicBlock *Block;\n};\n\ntemplate <>\nstruct ilist_alloc_traits<MemoryAccess> {\n  static void deleteNode(MemoryAccess *MA) { MA->deleteValue(); }\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const MemoryAccess &MA) {\n  MA.print(OS);\n  return OS;\n}\n\n/// Class that has the common methods + fields of memory uses/defs. It's\n/// a little awkward to have, but there are many cases where we want either a\n/// use or def, and there are many cases where uses are needed (defs aren't\n/// acceptable), and vice-versa.\n///\n/// This class should never be instantiated directly; make a MemoryUse or\n/// MemoryDef instead.\nclass MemoryUseOrDef : public MemoryAccess {\npublic:\n  void *operator new(size_t) = delete;\n\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(MemoryAccess);\n\n  /// Get the instruction that this MemoryUse represents.\n  Instruction *getMemoryInst() const { return MemoryInstruction; }\n\n  /// Get the access that produces the memory state used by this Use.\n  MemoryAccess *getDefiningAccess() const { return getOperand(0); }\n\n  static bool classof(const Value *MA) {\n    return MA->getValueID() == MemoryUseVal || MA->getValueID() == MemoryDefVal;\n  }\n\n  // Sadly, these have to be public because they are needed in some of the\n  // iterators.\n  inline bool isOptimized() const;\n  inline MemoryAccess *getOptimized() const;\n  inline void setOptimized(MemoryAccess *);\n\n  // Retrieve AliasResult type of the optimized access. Ideally this would be\n  // returned by the caching walker and may go away in the future.\n  Optional<AliasResult> getOptimizedAccessType() const {\n    return isOptimized() ? OptimizedAccessAlias : None;\n  }\n\n  /// Reset the ID of what this MemoryUse was optimized to, causing it to\n  /// be rewalked by the walker if necessary.\n  /// This really should only be called by tests.\n  inline void resetOptimized();\n\nprotected:\n  friend class MemorySSA;\n  friend class MemorySSAUpdater;\n\n  MemoryUseOrDef(LLVMContext &C, MemoryAccess *DMA, unsigned Vty,\n                 DeleteValueTy DeleteValue, Instruction *MI, BasicBlock *BB,\n                 unsigned NumOperands)\n      : MemoryAccess(C, Vty, DeleteValue, BB, NumOperands),\n        MemoryInstruction(MI), OptimizedAccessAlias(MayAlias) {\n    setDefiningAccess(DMA);\n  }\n\n  // Use deleteValue() to delete a generic MemoryUseOrDef.\n  ~MemoryUseOrDef() = default;\n\n  void setOptimizedAccessType(Optional<AliasResult> AR) {\n    OptimizedAccessAlias = AR;\n  }\n\n  void setDefiningAccess(MemoryAccess *DMA, bool Optimized = false,\n                         Optional<AliasResult> AR = MayAlias) {\n    if (!Optimized) {\n      setOperand(0, DMA);\n      return;\n    }\n    setOptimized(DMA);\n    setOptimizedAccessType(AR);\n  }\n\nprivate:\n  Instruction *MemoryInstruction;\n  Optional<AliasResult> OptimizedAccessAlias;\n};\n\n/// Represents read-only accesses to memory\n///\n/// In particular, the set of Instructions that will be represented by\n/// MemoryUse's is exactly the set of Instructions for which\n/// AliasAnalysis::getModRefInfo returns \"Ref\".\nclass MemoryUse final : public MemoryUseOrDef {\npublic:\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(MemoryAccess);\n\n  MemoryUse(LLVMContext &C, MemoryAccess *DMA, Instruction *MI, BasicBlock *BB)\n      : MemoryUseOrDef(C, DMA, MemoryUseVal, deleteMe, MI, BB,\n                       /*NumOperands=*/1) {}\n\n  // allocate space for exactly one operand\n  void *operator new(size_t s) { return User::operator new(s, 1); }\n\n  static bool classof(const Value *MA) {\n    return MA->getValueID() == MemoryUseVal;\n  }\n\n  void print(raw_ostream &OS) const;\n\n  void setOptimized(MemoryAccess *DMA) {\n    OptimizedID = DMA->getID();\n    setOperand(0, DMA);\n  }\n\n  bool isOptimized() const {\n    return getDefiningAccess() && OptimizedID == getDefiningAccess()->getID();\n  }\n\n  MemoryAccess *getOptimized() const {\n    return getDefiningAccess();\n  }\n\n  void resetOptimized() {\n    OptimizedID = INVALID_MEMORYACCESS_ID;\n  }\n\nprotected:\n  friend class MemorySSA;\n\nprivate:\n  static void deleteMe(DerivedUser *Self);\n\n  unsigned OptimizedID = INVALID_MEMORYACCESS_ID;\n};\n\ntemplate <>\nstruct OperandTraits<MemoryUse> : public FixedNumOperandTraits<MemoryUse, 1> {};\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(MemoryUse, MemoryAccess)\n\n/// Represents a read-write access to memory, whether it is a must-alias,\n/// or a may-alias.\n///\n/// In particular, the set of Instructions that will be represented by\n/// MemoryDef's is exactly the set of Instructions for which\n/// AliasAnalysis::getModRefInfo returns \"Mod\" or \"ModRef\".\n/// Note that, in order to provide def-def chains, all defs also have a use\n/// associated with them. This use points to the nearest reaching\n/// MemoryDef/MemoryPhi.\nclass MemoryDef final : public MemoryUseOrDef {\npublic:\n  friend class MemorySSA;\n\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(MemoryAccess);\n\n  MemoryDef(LLVMContext &C, MemoryAccess *DMA, Instruction *MI, BasicBlock *BB,\n            unsigned Ver)\n      : MemoryUseOrDef(C, DMA, MemoryDefVal, deleteMe, MI, BB,\n                       /*NumOperands=*/2),\n        ID(Ver) {}\n\n  // allocate space for exactly two operands\n  void *operator new(size_t s) { return User::operator new(s, 2); }\n\n  static bool classof(const Value *MA) {\n    return MA->getValueID() == MemoryDefVal;\n  }\n\n  void setOptimized(MemoryAccess *MA) {\n    setOperand(1, MA);\n    OptimizedID = MA->getID();\n  }\n\n  MemoryAccess *getOptimized() const {\n    return cast_or_null<MemoryAccess>(getOperand(1));\n  }\n\n  bool isOptimized() const {\n    return getOptimized() && OptimizedID == getOptimized()->getID();\n  }\n\n  void resetOptimized() {\n    OptimizedID = INVALID_MEMORYACCESS_ID;\n    setOperand(1, nullptr);\n  }\n\n  void print(raw_ostream &OS) const;\n\n  unsigned getID() const { return ID; }\n\nprivate:\n  static void deleteMe(DerivedUser *Self);\n\n  const unsigned ID;\n  unsigned OptimizedID = INVALID_MEMORYACCESS_ID;\n};\n\ntemplate <>\nstruct OperandTraits<MemoryDef> : public FixedNumOperandTraits<MemoryDef, 2> {};\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(MemoryDef, MemoryAccess)\n\ntemplate <>\nstruct OperandTraits<MemoryUseOrDef> {\n  static Use *op_begin(MemoryUseOrDef *MUD) {\n    if (auto *MU = dyn_cast<MemoryUse>(MUD))\n      return OperandTraits<MemoryUse>::op_begin(MU);\n    return OperandTraits<MemoryDef>::op_begin(cast<MemoryDef>(MUD));\n  }\n\n  static Use *op_end(MemoryUseOrDef *MUD) {\n    if (auto *MU = dyn_cast<MemoryUse>(MUD))\n      return OperandTraits<MemoryUse>::op_end(MU);\n    return OperandTraits<MemoryDef>::op_end(cast<MemoryDef>(MUD));\n  }\n\n  static unsigned operands(const MemoryUseOrDef *MUD) {\n    if (const auto *MU = dyn_cast<MemoryUse>(MUD))\n      return OperandTraits<MemoryUse>::operands(MU);\n    return OperandTraits<MemoryDef>::operands(cast<MemoryDef>(MUD));\n  }\n};\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(MemoryUseOrDef, MemoryAccess)\n\n/// Represents phi nodes for memory accesses.\n///\n/// These have the same semantic as regular phi nodes, with the exception that\n/// only one phi will ever exist in a given basic block.\n/// Guaranteeing one phi per block means guaranteeing there is only ever one\n/// valid reaching MemoryDef/MemoryPHI along each path to the phi node.\n/// This is ensured by not allowing disambiguation of the RHS of a MemoryDef or\n/// a MemoryPhi's operands.\n/// That is, given\n/// if (a) {\n///   store %a\n///   store %b\n/// }\n/// it *must* be transformed into\n/// if (a) {\n///    1 = MemoryDef(liveOnEntry)\n///    store %a\n///    2 = MemoryDef(1)\n///    store %b\n/// }\n/// and *not*\n/// if (a) {\n///    1 = MemoryDef(liveOnEntry)\n///    store %a\n///    2 = MemoryDef(liveOnEntry)\n///    store %b\n/// }\n/// even if the two stores do not conflict. Otherwise, both 1 and 2 reach the\n/// end of the branch, and if there are not two phi nodes, one will be\n/// disconnected completely from the SSA graph below that point.\n/// Because MemoryUse's do not generate new definitions, they do not have this\n/// issue.\nclass MemoryPhi final : public MemoryAccess {\n  // allocate space for exactly zero operands\n  void *operator new(size_t s) { return User::operator new(s); }\n\npublic:\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(MemoryAccess);\n\n  MemoryPhi(LLVMContext &C, BasicBlock *BB, unsigned Ver, unsigned NumPreds = 0)\n      : MemoryAccess(C, MemoryPhiVal, deleteMe, BB, 0), ID(Ver),\n        ReservedSpace(NumPreds) {\n    allocHungoffUses(ReservedSpace);\n  }\n\n  // Block iterator interface. This provides access to the list of incoming\n  // basic blocks, which parallels the list of incoming values.\n  using block_iterator = BasicBlock **;\n  using const_block_iterator = BasicBlock *const *;\n\n  block_iterator block_begin() {\n    return reinterpret_cast<block_iterator>(op_begin() + ReservedSpace);\n  }\n\n  const_block_iterator block_begin() const {\n    return reinterpret_cast<const_block_iterator>(op_begin() + ReservedSpace);\n  }\n\n  block_iterator block_end() { return block_begin() + getNumOperands(); }\n\n  const_block_iterator block_end() const {\n    return block_begin() + getNumOperands();\n  }\n\n  iterator_range<block_iterator> blocks() {\n    return make_range(block_begin(), block_end());\n  }\n\n  iterator_range<const_block_iterator> blocks() const {\n    return make_range(block_begin(), block_end());\n  }\n\n  op_range incoming_values() { return operands(); }\n\n  const_op_range incoming_values() const { return operands(); }\n\n  /// Return the number of incoming edges\n  unsigned getNumIncomingValues() const { return getNumOperands(); }\n\n  /// Return incoming value number x\n  MemoryAccess *getIncomingValue(unsigned I) const { return getOperand(I); }\n  void setIncomingValue(unsigned I, MemoryAccess *V) {\n    assert(V && \"PHI node got a null value!\");\n    setOperand(I, V);\n  }\n\n  static unsigned getOperandNumForIncomingValue(unsigned I) { return I; }\n  static unsigned getIncomingValueNumForOperand(unsigned I) { return I; }\n\n  /// Return incoming basic block number @p i.\n  BasicBlock *getIncomingBlock(unsigned I) const { return block_begin()[I]; }\n\n  /// Return incoming basic block corresponding\n  /// to an operand of the PHI.\n  BasicBlock *getIncomingBlock(const Use &U) const {\n    assert(this == U.getUser() && \"Iterator doesn't point to PHI's Uses?\");\n    return getIncomingBlock(unsigned(&U - op_begin()));\n  }\n\n  /// Return incoming basic block corresponding\n  /// to value use iterator.\n  BasicBlock *getIncomingBlock(MemoryAccess::const_user_iterator I) const {\n    return getIncomingBlock(I.getUse());\n  }\n\n  void setIncomingBlock(unsigned I, BasicBlock *BB) {\n    assert(BB && \"PHI node got a null basic block!\");\n    block_begin()[I] = BB;\n  }\n\n  /// Add an incoming value to the end of the PHI list\n  void addIncoming(MemoryAccess *V, BasicBlock *BB) {\n    if (getNumOperands() == ReservedSpace)\n      growOperands(); // Get more space!\n    // Initialize some new operands.\n    setNumHungOffUseOperands(getNumOperands() + 1);\n    setIncomingValue(getNumOperands() - 1, V);\n    setIncomingBlock(getNumOperands() - 1, BB);\n  }\n\n  /// Return the first index of the specified basic\n  /// block in the value list for this PHI.  Returns -1 if no instance.\n  int getBasicBlockIndex(const BasicBlock *BB) const {\n    for (unsigned I = 0, E = getNumOperands(); I != E; ++I)\n      if (block_begin()[I] == BB)\n        return I;\n    return -1;\n  }\n\n  MemoryAccess *getIncomingValueForBlock(const BasicBlock *BB) const {\n    int Idx = getBasicBlockIndex(BB);\n    assert(Idx >= 0 && \"Invalid basic block argument!\");\n    return getIncomingValue(Idx);\n  }\n\n  // After deleting incoming position I, the order of incoming may be changed.\n  void unorderedDeleteIncoming(unsigned I) {\n    unsigned E = getNumOperands();\n    assert(I < E && \"Cannot remove out of bounds Phi entry.\");\n    // MemoryPhi must have at least two incoming values, otherwise the MemoryPhi\n    // itself should be deleted.\n    assert(E >= 2 && \"Cannot only remove incoming values in MemoryPhis with \"\n                     \"at least 2 values.\");\n    setIncomingValue(I, getIncomingValue(E - 1));\n    setIncomingBlock(I, block_begin()[E - 1]);\n    setOperand(E - 1, nullptr);\n    block_begin()[E - 1] = nullptr;\n    setNumHungOffUseOperands(getNumOperands() - 1);\n  }\n\n  // After deleting entries that satisfy Pred, remaining entries may have\n  // changed order.\n  template <typename Fn> void unorderedDeleteIncomingIf(Fn &&Pred) {\n    for (unsigned I = 0, E = getNumOperands(); I != E; ++I)\n      if (Pred(getIncomingValue(I), getIncomingBlock(I))) {\n        unorderedDeleteIncoming(I);\n        E = getNumOperands();\n        --I;\n      }\n    assert(getNumOperands() >= 1 &&\n           \"Cannot remove all incoming blocks in a MemoryPhi.\");\n  }\n\n  // After deleting incoming block BB, the incoming blocks order may be changed.\n  void unorderedDeleteIncomingBlock(const BasicBlock *BB) {\n    unorderedDeleteIncomingIf(\n        [&](const MemoryAccess *, const BasicBlock *B) { return BB == B; });\n  }\n\n  // After deleting incoming memory access MA, the incoming accesses order may\n  // be changed.\n  void unorderedDeleteIncomingValue(const MemoryAccess *MA) {\n    unorderedDeleteIncomingIf(\n        [&](const MemoryAccess *M, const BasicBlock *) { return MA == M; });\n  }\n\n  static bool classof(const Value *V) {\n    return V->getValueID() == MemoryPhiVal;\n  }\n\n  void print(raw_ostream &OS) const;\n\n  unsigned getID() const { return ID; }\n\nprotected:\n  friend class MemorySSA;\n\n  /// this is more complicated than the generic\n  /// User::allocHungoffUses, because we have to allocate Uses for the incoming\n  /// values and pointers to the incoming blocks, all in one allocation.\n  void allocHungoffUses(unsigned N) {\n    User::allocHungoffUses(N, /* IsPhi */ true);\n  }\n\nprivate:\n  // For debugging only\n  const unsigned ID;\n  unsigned ReservedSpace;\n\n  /// This grows the operand list in response to a push_back style of\n  /// operation.  This grows the number of ops by 1.5 times.\n  void growOperands() {\n    unsigned E = getNumOperands();\n    // 2 op PHI nodes are VERY common, so reserve at least enough for that.\n    ReservedSpace = std::max(E + E / 2, 2u);\n    growHungoffUses(ReservedSpace, /* IsPhi */ true);\n  }\n\n  static void deleteMe(DerivedUser *Self);\n};\n\ninline unsigned MemoryAccess::getID() const {\n  assert((isa<MemoryDef>(this) || isa<MemoryPhi>(this)) &&\n         \"only memory defs and phis have ids\");\n  if (const auto *MD = dyn_cast<MemoryDef>(this))\n    return MD->getID();\n  return cast<MemoryPhi>(this)->getID();\n}\n\ninline bool MemoryUseOrDef::isOptimized() const {\n  if (const auto *MD = dyn_cast<MemoryDef>(this))\n    return MD->isOptimized();\n  return cast<MemoryUse>(this)->isOptimized();\n}\n\ninline MemoryAccess *MemoryUseOrDef::getOptimized() const {\n  if (const auto *MD = dyn_cast<MemoryDef>(this))\n    return MD->getOptimized();\n  return cast<MemoryUse>(this)->getOptimized();\n}\n\ninline void MemoryUseOrDef::setOptimized(MemoryAccess *MA) {\n  if (auto *MD = dyn_cast<MemoryDef>(this))\n    MD->setOptimized(MA);\n  else\n    cast<MemoryUse>(this)->setOptimized(MA);\n}\n\ninline void MemoryUseOrDef::resetOptimized() {\n  if (auto *MD = dyn_cast<MemoryDef>(this))\n    MD->resetOptimized();\n  else\n    cast<MemoryUse>(this)->resetOptimized();\n}\n\ntemplate <> struct OperandTraits<MemoryPhi> : public HungoffOperandTraits<2> {};\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(MemoryPhi, MemoryAccess)\n\n/// Encapsulates MemorySSA, including all data associated with memory\n/// accesses.\nclass MemorySSA {\npublic:\n  MemorySSA(Function &, AliasAnalysis *, DominatorTree *);\n\n  // MemorySSA must remain where it's constructed; Walkers it creates store\n  // pointers to it.\n  MemorySSA(MemorySSA &&) = delete;\n\n  ~MemorySSA();\n\n  MemorySSAWalker *getWalker();\n  MemorySSAWalker *getSkipSelfWalker();\n\n  /// Given a memory Mod/Ref'ing instruction, get the MemorySSA\n  /// access associated with it. If passed a basic block gets the memory phi\n  /// node that exists for that block, if there is one. Otherwise, this will get\n  /// a MemoryUseOrDef.\n  MemoryUseOrDef *getMemoryAccess(const Instruction *I) const {\n    return cast_or_null<MemoryUseOrDef>(ValueToMemoryAccess.lookup(I));\n  }\n\n  MemoryPhi *getMemoryAccess(const BasicBlock *BB) const {\n    return cast_or_null<MemoryPhi>(ValueToMemoryAccess.lookup(cast<Value>(BB)));\n  }\n\n  DominatorTree &getDomTree() const { return *DT; }\n\n  void dump() const;\n  void print(raw_ostream &) const;\n\n  /// Return true if \\p MA represents the live on entry value\n  ///\n  /// Loads and stores from pointer arguments and other global values may be\n  /// defined by memory operations that do not occur in the current function, so\n  /// they may be live on entry to the function. MemorySSA represents such\n  /// memory state by the live on entry definition, which is guaranteed to occur\n  /// before any other memory access in the function.\n  inline bool isLiveOnEntryDef(const MemoryAccess *MA) const {\n    return MA == LiveOnEntryDef.get();\n  }\n\n  inline MemoryAccess *getLiveOnEntryDef() const {\n    return LiveOnEntryDef.get();\n  }\n\n  // Sadly, iplists, by default, owns and deletes pointers added to the\n  // list. It's not currently possible to have two iplists for the same type,\n  // where one owns the pointers, and one does not. This is because the traits\n  // are per-type, not per-tag.  If this ever changes, we should make the\n  // DefList an iplist.\n  using AccessList = iplist<MemoryAccess, ilist_tag<MSSAHelpers::AllAccessTag>>;\n  using DefsList =\n      simple_ilist<MemoryAccess, ilist_tag<MSSAHelpers::DefsOnlyTag>>;\n\n  /// Return the list of MemoryAccess's for a given basic block.\n  ///\n  /// This list is not modifiable by the user.\n  const AccessList *getBlockAccesses(const BasicBlock *BB) const {\n    return getWritableBlockAccesses(BB);\n  }\n\n  /// Return the list of MemoryDef's and MemoryPhi's for a given basic\n  /// block.\n  ///\n  /// This list is not modifiable by the user.\n  const DefsList *getBlockDefs(const BasicBlock *BB) const {\n    return getWritableBlockDefs(BB);\n  }\n\n  /// Given two memory accesses in the same basic block, determine\n  /// whether MemoryAccess \\p A dominates MemoryAccess \\p B.\n  bool locallyDominates(const MemoryAccess *A, const MemoryAccess *B) const;\n\n  /// Given two memory accesses in potentially different blocks,\n  /// determine whether MemoryAccess \\p A dominates MemoryAccess \\p B.\n  bool dominates(const MemoryAccess *A, const MemoryAccess *B) const;\n\n  /// Given a MemoryAccess and a Use, determine whether MemoryAccess \\p A\n  /// dominates Use \\p B.\n  bool dominates(const MemoryAccess *A, const Use &B) const;\n\n  /// Verify that MemorySSA is self consistent (IE definitions dominate\n  /// all uses, uses appear in the right places).  This is used by unit tests.\n  void verifyMemorySSA() const;\n\n  /// Used in various insertion functions to specify whether we are talking\n  /// about the beginning or end of a block.\n  enum InsertionPlace { Beginning, End, BeforeTerminator };\n\nprotected:\n  // Used by Memory SSA annotater, dumpers, and wrapper pass\n  friend class MemorySSAAnnotatedWriter;\n  friend class MemorySSAPrinterLegacyPass;\n  friend class MemorySSAUpdater;\n\n  void verifyOrderingDominationAndDefUses(Function &F) const;\n  void verifyDominationNumbers(const Function &F) const;\n  void verifyPrevDefInPhis(Function &F) const;\n\n  // This is used by the use optimizer and updater.\n  AccessList *getWritableBlockAccesses(const BasicBlock *BB) const {\n    auto It = PerBlockAccesses.find(BB);\n    return It == PerBlockAccesses.end() ? nullptr : It->second.get();\n  }\n\n  // This is used by the use optimizer and updater.\n  DefsList *getWritableBlockDefs(const BasicBlock *BB) const {\n    auto It = PerBlockDefs.find(BB);\n    return It == PerBlockDefs.end() ? nullptr : It->second.get();\n  }\n\n  // These is used by the updater to perform various internal MemorySSA\n  // machinsations.  They do not always leave the IR in a correct state, and\n  // relies on the updater to fixup what it breaks, so it is not public.\n\n  void moveTo(MemoryUseOrDef *What, BasicBlock *BB, AccessList::iterator Where);\n  void moveTo(MemoryAccess *What, BasicBlock *BB, InsertionPlace Point);\n\n  // Rename the dominator tree branch rooted at BB.\n  void renamePass(BasicBlock *BB, MemoryAccess *IncomingVal,\n                  SmallPtrSetImpl<BasicBlock *> &Visited) {\n    renamePass(DT->getNode(BB), IncomingVal, Visited, true, true);\n  }\n\n  void removeFromLookups(MemoryAccess *);\n  void removeFromLists(MemoryAccess *, bool ShouldDelete = true);\n  void insertIntoListsForBlock(MemoryAccess *, const BasicBlock *,\n                               InsertionPlace);\n  void insertIntoListsBefore(MemoryAccess *, const BasicBlock *,\n                             AccessList::iterator);\n  MemoryUseOrDef *createDefinedAccess(Instruction *, MemoryAccess *,\n                                      const MemoryUseOrDef *Template = nullptr,\n                                      bool CreationMustSucceed = true);\n\nprivate:\n  template <class AliasAnalysisType> class ClobberWalkerBase;\n  template <class AliasAnalysisType> class CachingWalker;\n  template <class AliasAnalysisType> class SkipSelfWalker;\n  class OptimizeUses;\n\n  CachingWalker<AliasAnalysis> *getWalkerImpl();\n  void buildMemorySSA(BatchAAResults &BAA);\n\n  void prepareForMoveTo(MemoryAccess *, BasicBlock *);\n  void verifyUseInDefs(MemoryAccess *, MemoryAccess *) const;\n\n  using AccessMap = DenseMap<const BasicBlock *, std::unique_ptr<AccessList>>;\n  using DefsMap = DenseMap<const BasicBlock *, std::unique_ptr<DefsList>>;\n\n  void markUnreachableAsLiveOnEntry(BasicBlock *BB);\n  MemoryPhi *createMemoryPhi(BasicBlock *BB);\n  template <typename AliasAnalysisType>\n  MemoryUseOrDef *createNewAccess(Instruction *, AliasAnalysisType *,\n                                  const MemoryUseOrDef *Template = nullptr);\n  void placePHINodes(const SmallPtrSetImpl<BasicBlock *> &);\n  MemoryAccess *renameBlock(BasicBlock *, MemoryAccess *, bool);\n  void renameSuccessorPhis(BasicBlock *, MemoryAccess *, bool);\n  void renamePass(DomTreeNode *, MemoryAccess *IncomingVal,\n                  SmallPtrSetImpl<BasicBlock *> &Visited,\n                  bool SkipVisited = false, bool RenameAllUses = false);\n  AccessList *getOrCreateAccessList(const BasicBlock *);\n  DefsList *getOrCreateDefsList(const BasicBlock *);\n  void renumberBlock(const BasicBlock *) const;\n  AliasAnalysis *AA;\n  DominatorTree *DT;\n  Function &F;\n\n  // Memory SSA mappings\n  DenseMap<const Value *, MemoryAccess *> ValueToMemoryAccess;\n\n  // These two mappings contain the main block to access/def mappings for\n  // MemorySSA. The list contained in PerBlockAccesses really owns all the\n  // MemoryAccesses.\n  // Both maps maintain the invariant that if a block is found in them, the\n  // corresponding list is not empty, and if a block is not found in them, the\n  // corresponding list is empty.\n  AccessMap PerBlockAccesses;\n  DefsMap PerBlockDefs;\n  std::unique_ptr<MemoryAccess, ValueDeleter> LiveOnEntryDef;\n\n  // Domination mappings\n  // Note that the numbering is local to a block, even though the map is\n  // global.\n  mutable SmallPtrSet<const BasicBlock *, 16> BlockNumberingValid;\n  mutable DenseMap<const MemoryAccess *, unsigned long> BlockNumbering;\n\n  // Memory SSA building info\n  std::unique_ptr<ClobberWalkerBase<AliasAnalysis>> WalkerBase;\n  std::unique_ptr<CachingWalker<AliasAnalysis>> Walker;\n  std::unique_ptr<SkipSelfWalker<AliasAnalysis>> SkipWalker;\n  unsigned NextID;\n};\n\n// Internal MemorySSA utils, for use by MemorySSA classes and walkers\nclass MemorySSAUtil {\nprotected:\n  friend class GVNHoist;\n  friend class MemorySSAWalker;\n\n  // This function should not be used by new passes.\n  static bool defClobbersUseOrDef(MemoryDef *MD, const MemoryUseOrDef *MU,\n                                  AliasAnalysis &AA);\n};\n\n// This pass does eager building and then printing of MemorySSA. It is used by\n// the tests to be able to build, dump, and verify Memory SSA.\nclass MemorySSAPrinterLegacyPass : public FunctionPass {\npublic:\n  MemorySSAPrinterLegacyPass();\n\n  bool runOnFunction(Function &) override;\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n\n  static char ID;\n};\n\n/// An analysis that produces \\c MemorySSA for a function.\n///\nclass MemorySSAAnalysis : public AnalysisInfoMixin<MemorySSAAnalysis> {\n  friend AnalysisInfoMixin<MemorySSAAnalysis>;\n\n  static AnalysisKey Key;\n\npublic:\n  // Wrap MemorySSA result to ensure address stability of internal MemorySSA\n  // pointers after construction.  Use a wrapper class instead of plain\n  // unique_ptr<MemorySSA> to avoid build breakage on MSVC.\n  struct Result {\n    Result(std::unique_ptr<MemorySSA> &&MSSA) : MSSA(std::move(MSSA)) {}\n\n    MemorySSA &getMSSA() { return *MSSA.get(); }\n\n    std::unique_ptr<MemorySSA> MSSA;\n\n    bool invalidate(Function &F, const PreservedAnalyses &PA,\n                    FunctionAnalysisManager::Invalidator &Inv);\n  };\n\n  Result run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Printer pass for \\c MemorySSA.\nclass MemorySSAPrinterPass : public PassInfoMixin<MemorySSAPrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit MemorySSAPrinterPass(raw_ostream &OS) : OS(OS) {}\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Verifier pass for \\c MemorySSA.\nstruct MemorySSAVerifierPass : PassInfoMixin<MemorySSAVerifierPass> {\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Legacy analysis pass which computes \\c MemorySSA.\nclass MemorySSAWrapperPass : public FunctionPass {\npublic:\n  MemorySSAWrapperPass();\n\n  static char ID;\n\n  bool runOnFunction(Function &) override;\n  void releaseMemory() override;\n  MemorySSA &getMSSA() { return *MSSA; }\n  const MemorySSA &getMSSA() const { return *MSSA; }\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n\n  void verifyAnalysis() const override;\n  void print(raw_ostream &OS, const Module *M = nullptr) const override;\n\nprivate:\n  std::unique_ptr<MemorySSA> MSSA;\n};\n\n/// This is the generic walker interface for walkers of MemorySSA.\n/// Walkers are used to be able to further disambiguate the def-use chains\n/// MemorySSA gives you, or otherwise produce better info than MemorySSA gives\n/// you.\n/// In particular, while the def-use chains provide basic information, and are\n/// guaranteed to give, for example, the nearest may-aliasing MemoryDef for a\n/// MemoryUse as AliasAnalysis considers it, a user mant want better or other\n/// information. In particular, they may want to use SCEV info to further\n/// disambiguate memory accesses, or they may want the nearest dominating\n/// may-aliasing MemoryDef for a call or a store. This API enables a\n/// standardized interface to getting and using that info.\nclass MemorySSAWalker {\npublic:\n  MemorySSAWalker(MemorySSA *);\n  virtual ~MemorySSAWalker() = default;\n\n  using MemoryAccessSet = SmallVector<MemoryAccess *, 8>;\n\n  /// Given a memory Mod/Ref/ModRef'ing instruction, calling this\n  /// will give you the nearest dominating MemoryAccess that Mod's the location\n  /// the instruction accesses (by skipping any def which AA can prove does not\n  /// alias the location(s) accessed by the instruction given).\n  ///\n  /// Note that this will return a single access, and it must dominate the\n  /// Instruction, so if an operand of a MemoryPhi node Mod's the instruction,\n  /// this will return the MemoryPhi, not the operand. This means that\n  /// given:\n  /// if (a) {\n  ///   1 = MemoryDef(liveOnEntry)\n  ///   store %a\n  /// } else {\n  ///   2 = MemoryDef(liveOnEntry)\n  ///   store %b\n  /// }\n  /// 3 = MemoryPhi(2, 1)\n  /// MemoryUse(3)\n  /// load %a\n  ///\n  /// calling this API on load(%a) will return the MemoryPhi, not the MemoryDef\n  /// in the if (a) branch.\n  MemoryAccess *getClobberingMemoryAccess(const Instruction *I) {\n    MemoryAccess *MA = MSSA->getMemoryAccess(I);\n    assert(MA && \"Handed an instruction that MemorySSA doesn't recognize?\");\n    return getClobberingMemoryAccess(MA);\n  }\n\n  /// Does the same thing as getClobberingMemoryAccess(const Instruction *I),\n  /// but takes a MemoryAccess instead of an Instruction.\n  virtual MemoryAccess *getClobberingMemoryAccess(MemoryAccess *) = 0;\n\n  /// Given a potentially clobbering memory access and a new location,\n  /// calling this will give you the nearest dominating clobbering MemoryAccess\n  /// (by skipping non-aliasing def links).\n  ///\n  /// This version of the function is mainly used to disambiguate phi translated\n  /// pointers, where the value of a pointer may have changed from the initial\n  /// memory access. Note that this expects to be handed either a MemoryUse,\n  /// or an already potentially clobbering access. Unlike the above API, if\n  /// given a MemoryDef that clobbers the pointer as the starting access, it\n  /// will return that MemoryDef, whereas the above would return the clobber\n  /// starting from the use side of  the memory def.\n  virtual MemoryAccess *getClobberingMemoryAccess(MemoryAccess *,\n                                                  const MemoryLocation &) = 0;\n\n  /// Given a memory access, invalidate anything this walker knows about\n  /// that access.\n  /// This API is used by walkers that store information to perform basic cache\n  /// invalidation.  This will be called by MemorySSA at appropriate times for\n  /// the walker it uses or returns.\n  virtual void invalidateInfo(MemoryAccess *) {}\n\nprotected:\n  friend class MemorySSA; // For updating MSSA pointer in MemorySSA move\n                          // constructor.\n  MemorySSA *MSSA;\n};\n\n/// A MemorySSAWalker that does no alias queries, or anything else. It\n/// simply returns the links as they were constructed by the builder.\nclass DoNothingMemorySSAWalker final : public MemorySSAWalker {\npublic:\n  // Keep the overrides below from hiding the Instruction overload of\n  // getClobberingMemoryAccess.\n  using MemorySSAWalker::getClobberingMemoryAccess;\n\n  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *) override;\n  MemoryAccess *getClobberingMemoryAccess(MemoryAccess *,\n                                          const MemoryLocation &) override;\n};\n\nusing MemoryAccessPair = std::pair<MemoryAccess *, MemoryLocation>;\nusing ConstMemoryAccessPair = std::pair<const MemoryAccess *, MemoryLocation>;\n\n/// Iterator base class used to implement const and non-const iterators\n/// over the defining accesses of a MemoryAccess.\ntemplate <class T>\nclass memoryaccess_def_iterator_base\n    : public iterator_facade_base<memoryaccess_def_iterator_base<T>,\n                                  std::forward_iterator_tag, T, ptrdiff_t, T *,\n                                  T *> {\n  using BaseT = typename memoryaccess_def_iterator_base::iterator_facade_base;\n\npublic:\n  memoryaccess_def_iterator_base(T *Start) : Access(Start) {}\n  memoryaccess_def_iterator_base() = default;\n\n  bool operator==(const memoryaccess_def_iterator_base &Other) const {\n    return Access == Other.Access && (!Access || ArgNo == Other.ArgNo);\n  }\n\n  // This is a bit ugly, but for MemoryPHI's, unlike PHINodes, you can't get the\n  // block from the operand in constant time (In a PHINode, the uselist has\n  // both, so it's just subtraction). We provide it as part of the\n  // iterator to avoid callers having to linear walk to get the block.\n  // If the operation becomes constant time on MemoryPHI's, this bit of\n  // abstraction breaking should be removed.\n  BasicBlock *getPhiArgBlock() const {\n    MemoryPhi *MP = dyn_cast<MemoryPhi>(Access);\n    assert(MP && \"Tried to get phi arg block when not iterating over a PHI\");\n    return MP->getIncomingBlock(ArgNo);\n  }\n\n  typename BaseT::iterator::pointer operator*() const {\n    assert(Access && \"Tried to access past the end of our iterator\");\n    // Go to the first argument for phis, and the defining access for everything\n    // else.\n    if (const MemoryPhi *MP = dyn_cast<MemoryPhi>(Access))\n      return MP->getIncomingValue(ArgNo);\n    return cast<MemoryUseOrDef>(Access)->getDefiningAccess();\n  }\n\n  using BaseT::operator++;\n  memoryaccess_def_iterator_base &operator++() {\n    assert(Access && \"Hit end of iterator\");\n    if (const MemoryPhi *MP = dyn_cast<MemoryPhi>(Access)) {\n      if (++ArgNo >= MP->getNumIncomingValues()) {\n        ArgNo = 0;\n        Access = nullptr;\n      }\n    } else {\n      Access = nullptr;\n    }\n    return *this;\n  }\n\nprivate:\n  T *Access = nullptr;\n  unsigned ArgNo = 0;\n};\n\ninline memoryaccess_def_iterator MemoryAccess::defs_begin() {\n  return memoryaccess_def_iterator(this);\n}\n\ninline const_memoryaccess_def_iterator MemoryAccess::defs_begin() const {\n  return const_memoryaccess_def_iterator(this);\n}\n\ninline memoryaccess_def_iterator MemoryAccess::defs_end() {\n  return memoryaccess_def_iterator();\n}\n\ninline const_memoryaccess_def_iterator MemoryAccess::defs_end() const {\n  return const_memoryaccess_def_iterator();\n}\n\n/// GraphTraits for a MemoryAccess, which walks defs in the normal case,\n/// and uses in the inverse case.\ntemplate <> struct GraphTraits<MemoryAccess *> {\n  using NodeRef = MemoryAccess *;\n  using ChildIteratorType = memoryaccess_def_iterator;\n\n  static NodeRef getEntryNode(NodeRef N) { return N; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->defs_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->defs_end(); }\n};\n\ntemplate <> struct GraphTraits<Inverse<MemoryAccess *>> {\n  using NodeRef = MemoryAccess *;\n  using ChildIteratorType = MemoryAccess::iterator;\n\n  static NodeRef getEntryNode(NodeRef N) { return N; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->user_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->user_end(); }\n};\n\n/// Provide an iterator that walks defs, giving both the memory access,\n/// and the current pointer location, updating the pointer location as it\n/// changes due to phi node translation.\n///\n/// This iterator, while somewhat specialized, is what most clients actually\n/// want when walking upwards through MemorySSA def chains. It takes a pair of\n/// <MemoryAccess,MemoryLocation>, and walks defs, properly translating the\n/// memory location through phi nodes for the user.\nclass upward_defs_iterator\n    : public iterator_facade_base<upward_defs_iterator,\n                                  std::forward_iterator_tag,\n                                  const MemoryAccessPair> {\n  using BaseT = upward_defs_iterator::iterator_facade_base;\n\npublic:\n  upward_defs_iterator(const MemoryAccessPair &Info, DominatorTree *DT,\n                       bool *PerformedPhiTranslation = nullptr)\n      : DefIterator(Info.first), Location(Info.second),\n        OriginalAccess(Info.first), DT(DT),\n        PerformedPhiTranslation(PerformedPhiTranslation) {\n    CurrentPair.first = nullptr;\n\n    WalkingPhi = Info.first && isa<MemoryPhi>(Info.first);\n    fillInCurrentPair();\n  }\n\n  upward_defs_iterator() { CurrentPair.first = nullptr; }\n\n  bool operator==(const upward_defs_iterator &Other) const {\n    return DefIterator == Other.DefIterator;\n  }\n\n  BaseT::iterator::reference operator*() const {\n    assert(DefIterator != OriginalAccess->defs_end() &&\n           \"Tried to access past the end of our iterator\");\n    return CurrentPair;\n  }\n\n  using BaseT::operator++;\n  upward_defs_iterator &operator++() {\n    assert(DefIterator != OriginalAccess->defs_end() &&\n           \"Tried to access past the end of the iterator\");\n    ++DefIterator;\n    if (DefIterator != OriginalAccess->defs_end())\n      fillInCurrentPair();\n    return *this;\n  }\n\n  BasicBlock *getPhiArgBlock() const { return DefIterator.getPhiArgBlock(); }\n\nprivate:\n  /// Returns true if \\p Ptr is guaranteed to be loop invariant for any possible\n  /// loop. In particular, this guarantees that it only references a single\n  /// MemoryLocation during execution of the containing function.\n  bool IsGuaranteedLoopInvariant(Value *Ptr) const;\n\n  void fillInCurrentPair() {\n    CurrentPair.first = *DefIterator;\n    CurrentPair.second = Location;\n    if (WalkingPhi && Location.Ptr) {\n      // Mark size as unknown, if the location is not guaranteed to be\n      // loop-invariant for any possible loop in the function. Setting the size\n      // to unknown guarantees that any memory accesses that access locations\n      // after the pointer are considered as clobbers, which is important to\n      // catch loop carried dependences.\n      if (Location.Ptr &&\n          !IsGuaranteedLoopInvariant(const_cast<Value *>(Location.Ptr)))\n        CurrentPair.second =\n            Location.getWithNewSize(LocationSize::beforeOrAfterPointer());\n      PHITransAddr Translator(\n          const_cast<Value *>(Location.Ptr),\n          OriginalAccess->getBlock()->getModule()->getDataLayout(), nullptr);\n\n      if (!Translator.PHITranslateValue(OriginalAccess->getBlock(),\n                                        DefIterator.getPhiArgBlock(), DT,\n                                        true)) {\n        Value *TransAddr = Translator.getAddr();\n        if (TransAddr != Location.Ptr) {\n          CurrentPair.second = CurrentPair.second.getWithNewPtr(TransAddr);\n\n          if (TransAddr &&\n              !IsGuaranteedLoopInvariant(const_cast<Value *>(TransAddr)))\n            CurrentPair.second = CurrentPair.second.getWithNewSize(\n                LocationSize::beforeOrAfterPointer());\n\n          if (PerformedPhiTranslation)\n            *PerformedPhiTranslation = true;\n        }\n      }\n    }\n  }\n\n  MemoryAccessPair CurrentPair;\n  memoryaccess_def_iterator DefIterator;\n  MemoryLocation Location;\n  MemoryAccess *OriginalAccess = nullptr;\n  DominatorTree *DT = nullptr;\n  bool WalkingPhi = false;\n  bool *PerformedPhiTranslation = nullptr;\n};\n\ninline upward_defs_iterator\nupward_defs_begin(const MemoryAccessPair &Pair, DominatorTree &DT,\n                  bool *PerformedPhiTranslation = nullptr) {\n  return upward_defs_iterator(Pair, &DT, PerformedPhiTranslation);\n}\n\ninline upward_defs_iterator upward_defs_end() { return upward_defs_iterator(); }\n\ninline iterator_range<upward_defs_iterator>\nupward_defs(const MemoryAccessPair &Pair, DominatorTree &DT) {\n  return make_range(upward_defs_begin(Pair, DT), upward_defs_end());\n}\n\n/// Walks the defining accesses of MemoryDefs. Stops after we hit something that\n/// has no defining use (e.g. a MemoryPhi or liveOnEntry). Note that, when\n/// comparing against a null def_chain_iterator, this will compare equal only\n/// after walking said Phi/liveOnEntry.\n///\n/// The UseOptimizedChain flag specifies whether to walk the clobbering\n/// access chain, or all the accesses.\n///\n/// Normally, MemoryDef are all just def/use linked together, so a def_chain on\n/// a MemoryDef will walk all MemoryDefs above it in the program until it hits\n/// a phi node.  The optimized chain walks the clobbering access of a store.\n/// So if you are just trying to find, given a store, what the next\n/// thing that would clobber the same memory is, you want the optimized chain.\ntemplate <class T, bool UseOptimizedChain = false>\nstruct def_chain_iterator\n    : public iterator_facade_base<def_chain_iterator<T, UseOptimizedChain>,\n                                  std::forward_iterator_tag, MemoryAccess *> {\n  def_chain_iterator() : MA(nullptr) {}\n  def_chain_iterator(T MA) : MA(MA) {}\n\n  T operator*() const { return MA; }\n\n  def_chain_iterator &operator++() {\n    // N.B. liveOnEntry has a null defining access.\n    if (auto *MUD = dyn_cast<MemoryUseOrDef>(MA)) {\n      if (UseOptimizedChain && MUD->isOptimized())\n        MA = MUD->getOptimized();\n      else\n        MA = MUD->getDefiningAccess();\n    } else {\n      MA = nullptr;\n    }\n\n    return *this;\n  }\n\n  bool operator==(const def_chain_iterator &O) const { return MA == O.MA; }\n\nprivate:\n  T MA;\n};\n\ntemplate <class T>\ninline iterator_range<def_chain_iterator<T>>\ndef_chain(T MA, MemoryAccess *UpTo = nullptr) {\n#ifdef EXPENSIVE_CHECKS\n  assert((!UpTo || find(def_chain(MA), UpTo) != def_chain_iterator<T>()) &&\n         \"UpTo isn't in the def chain!\");\n#endif\n  return make_range(def_chain_iterator<T>(MA), def_chain_iterator<T>(UpTo));\n}\n\ntemplate <class T>\ninline iterator_range<def_chain_iterator<T, true>> optimized_def_chain(T MA) {\n  return make_range(def_chain_iterator<T, true>(MA),\n                    def_chain_iterator<T, true>(nullptr));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ANALYSIS_MEMORYSSA_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/PostDominators.h", "content": "//=- llvm/Analysis/PostDominators.h - Post Dominator Calculation --*- C++ -*-=//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file exposes interfaces to post dominance information.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_POSTDOMINATORS_H\n#define LLVM_ANALYSIS_POSTDOMINATORS_H\n\n#include \"llvm/ADT/DepthFirstIterator.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Pass.h\"\n\nnamespace llvm {\n\nclass Function;\nclass raw_ostream;\n\n/// PostDominatorTree Class - Concrete subclass of DominatorTree that is used to\n/// compute the post-dominator tree.\nclass PostDominatorTree : public PostDomTreeBase<BasicBlock> {\npublic:\n  using Base = PostDomTreeBase<BasicBlock>;\n\n  PostDominatorTree() = default;\n  explicit PostDominatorTree(Function &F) { recalculate(F); }\n  /// Handle invalidation explicitly.\n  bool invalidate(Function &F, const PreservedAnalyses &PA,\n                  FunctionAnalysisManager::Invalidator &);\n\n  // Ensure base-class overloads are visible.\n  using Base::dominates;\n\n  /// Return true if \\p I1 dominates \\p I2. This checks if \\p I2 comes before\n  /// \\p I1 if they belongs to the same basic block.\n  bool dominates(const Instruction *I1, const Instruction *I2) const;\n};\n\n/// Analysis pass which computes a \\c PostDominatorTree.\nclass PostDominatorTreeAnalysis\n    : public AnalysisInfoMixin<PostDominatorTreeAnalysis> {\n  friend AnalysisInfoMixin<PostDominatorTreeAnalysis>;\n\n  static AnalysisKey Key;\n\npublic:\n  /// Provide the result type for this analysis pass.\n  using Result = PostDominatorTree;\n\n  /// Run the analysis pass over a function and produce a post dominator\n  ///        tree.\n  PostDominatorTree run(Function &F, FunctionAnalysisManager &);\n};\n\n/// Printer pass for the \\c PostDominatorTree.\nclass PostDominatorTreePrinterPass\n    : public PassInfoMixin<PostDominatorTreePrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit PostDominatorTreePrinterPass(raw_ostream &OS);\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\nstruct PostDominatorTreeWrapperPass : public FunctionPass {\n  static char ID; // Pass identification, replacement for typeid\n\n  PostDominatorTree DT;\n\n  PostDominatorTreeWrapperPass();\n\n  PostDominatorTree &getPostDomTree() { return DT; }\n  const PostDominatorTree &getPostDomTree() const { return DT; }\n\n  bool runOnFunction(Function &F) override;\n\n  void verifyAnalysis() const override;\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override {\n    AU.setPreservesAll();\n  }\n\n  void releaseMemory() override { DT.reset(); }\n\n  void print(raw_ostream &OS, const Module*) const override;\n};\n\nFunctionPass* createPostDomTree();\n\ntemplate <> struct GraphTraits<PostDominatorTree*>\n  : public GraphTraits<DomTreeNode*> {\n  static NodeRef getEntryNode(PostDominatorTree *DT) {\n    return DT->getRootNode();\n  }\n\n  static nodes_iterator nodes_begin(PostDominatorTree *N) {\n    if (getEntryNode(N))\n      return df_begin(getEntryNode(N));\n    else\n      return df_end(getEntryNode(N));\n  }\n\n  static nodes_iterator nodes_end(PostDominatorTree *N) {\n    return df_end(getEntryNode(N));\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ANALYSIS_POSTDOMINATORS_H\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h", "content": "//===- llvm/Analysis/ScalarEvolution.h - Scalar Evolution -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// The ScalarEvolution class is an LLVM pass which can be used to analyze and\n// categorize scalar expressions in loops.  It specializes in recognizing\n// general induction variables, representing them with the abstract and opaque\n// SCEV class.  Given this analysis, trip counts of loops and other important\n// properties can be obtained.\n//\n// This analysis is primarily useful for induction variable substitution and\n// strength reduction.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_SCALAREVOLUTION_H\n#define LLVM_ANALYSIS_SCALAREVOLUTION_H\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/IR/ConstantRange.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/IR/ValueMap.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <utility>\n\nnamespace llvm {\n\nclass AssumptionCache;\nclass BasicBlock;\nclass Constant;\nclass ConstantInt;\nclass DataLayout;\nclass DominatorTree;\nclass GEPOperator;\nclass Instruction;\nclass LLVMContext;\nclass Loop;\nclass LoopInfo;\nclass raw_ostream;\nclass ScalarEvolution;\nclass SCEVAddRecExpr;\nclass SCEVUnknown;\nclass StructType;\nclass TargetLibraryInfo;\nclass Type;\nclass Value;\nenum SCEVTypes : unsigned short;\n\n/// This class represents an analyzed expression in the program.  These are\n/// opaque objects that the client is not allowed to do much with directly.\n///\nclass SCEV : public FoldingSetNode {\n  friend struct FoldingSetTrait<SCEV>;\n\n  /// A reference to an Interned FoldingSetNodeID for this node.  The\n  /// ScalarEvolution's BumpPtrAllocator holds the data.\n  FoldingSetNodeIDRef FastID;\n\n  // The SCEV baseclass this node corresponds to\n  const SCEVTypes SCEVType;\n\nprotected:\n  // Estimated complexity of this node's expression tree size.\n  const unsigned short ExpressionSize;\n\n  /// This field is initialized to zero and may be used in subclasses to store\n  /// miscellaneous information.\n  unsigned short SubclassData = 0;\n\npublic:\n  /// NoWrapFlags are bitfield indices into SubclassData.\n  ///\n  /// Add and Mul expressions may have no-unsigned-wrap <NUW> or\n  /// no-signed-wrap <NSW> properties, which are derived from the IR\n  /// operator. NSW is a misnomer that we use to mean no signed overflow or\n  /// underflow.\n  ///\n  /// AddRec expressions may have a no-self-wraparound <NW> property if, in\n  /// the integer domain, abs(step) * max-iteration(loop) <=\n  /// unsigned-max(bitwidth).  This means that the recurrence will never reach\n  /// its start value if the step is non-zero.  Computing the same value on\n  /// each iteration is not considered wrapping, and recurrences with step = 0\n  /// are trivially <NW>.  <NW> is independent of the sign of step and the\n  /// value the add recurrence starts with.\n  ///\n  /// Note that NUW and NSW are also valid properties of a recurrence, and\n  /// either implies NW. For convenience, NW will be set for a recurrence\n  /// whenever either NUW or NSW are set.\n  enum NoWrapFlags {\n    FlagAnyWrap = 0,    // No guarantee.\n    FlagNW = (1 << 0),  // No self-wrap.\n    FlagNUW = (1 << 1), // No unsigned wrap.\n    FlagNSW = (1 << 2), // No signed wrap.\n    NoWrapMask = (1 << 3) - 1\n  };\n\n  explicit SCEV(const FoldingSetNodeIDRef ID, SCEVTypes SCEVTy,\n                unsigned short ExpressionSize)\n      : FastID(ID), SCEVType(SCEVTy), ExpressionSize(ExpressionSize) {}\n  SCEV(const SCEV &) = delete;\n  SCEV &operator=(const SCEV &) = delete;\n\n  SCEVTypes getSCEVType() const { return SCEVType; }\n\n  /// Return the LLVM type of this SCEV expression.\n  Type *getType() const;\n\n  /// Return true if the expression is a constant zero.\n  bool isZero() const;\n\n  /// Return true if the expression is a constant one.\n  bool isOne() const;\n\n  /// Return true if the expression is a constant all-ones value.\n  bool isAllOnesValue() const;\n\n  /// Return true if the specified scev is negated, but not a constant.\n  bool isNonConstantNegative() const;\n\n  // Returns estimated size of the mathematical expression represented by this\n  // SCEV. The rules of its calculation are following:\n  // 1) Size of a SCEV without operands (like constants and SCEVUnknown) is 1;\n  // 2) Size SCEV with operands Op1, Op2, ..., OpN is calculated by formula:\n  //    (1 + Size(Op1) + ... + Size(OpN)).\n  // This value gives us an estimation of time we need to traverse through this\n  // SCEV and all its operands recursively. We may use it to avoid performing\n  // heavy transformations on SCEVs of excessive size for sake of saving the\n  // compilation time.\n  unsigned short getExpressionSize() const {\n    return ExpressionSize;\n  }\n\n  /// Print out the internal representation of this scalar to the specified\n  /// stream.  This should really only be used for debugging purposes.\n  void print(raw_ostream &OS) const;\n\n  /// This method is used for debugging.\n  void dump() const;\n};\n\n// Specialize FoldingSetTrait for SCEV to avoid needing to compute\n// temporary FoldingSetNodeID values.\ntemplate <> struct FoldingSetTrait<SCEV> : DefaultFoldingSetTrait<SCEV> {\n  static void Profile(const SCEV &X, FoldingSetNodeID &ID) { ID = X.FastID; }\n\n  static bool Equals(const SCEV &X, const FoldingSetNodeID &ID, unsigned IDHash,\n                     FoldingSetNodeID &TempID) {\n    return ID == X.FastID;\n  }\n\n  static unsigned ComputeHash(const SCEV &X, FoldingSetNodeID &TempID) {\n    return X.FastID.ComputeHash();\n  }\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const SCEV &S) {\n  S.print(OS);\n  return OS;\n}\n\n/// An object of this class is returned by queries that could not be answered.\n/// For example, if you ask for the number of iterations of a linked-list\n/// traversal loop, you will get one of these.  None of the standard SCEV\n/// operations are valid on this class, it is just a marker.\nstruct SCEVCouldNotCompute : public SCEV {\n  SCEVCouldNotCompute();\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const SCEV *S);\n};\n\n/// This class represents an assumption made using SCEV expressions which can\n/// be checked at run-time.\nclass SCEVPredicate : public FoldingSetNode {\n  friend struct FoldingSetTrait<SCEVPredicate>;\n\n  /// A reference to an Interned FoldingSetNodeID for this node.  The\n  /// ScalarEvolution's BumpPtrAllocator holds the data.\n  FoldingSetNodeIDRef FastID;\n\npublic:\n  enum SCEVPredicateKind { P_Union, P_Equal, P_Wrap };\n\nprotected:\n  SCEVPredicateKind Kind;\n  ~SCEVPredicate() = default;\n  SCEVPredicate(const SCEVPredicate &) = default;\n  SCEVPredicate &operator=(const SCEVPredicate &) = default;\n\npublic:\n  SCEVPredicate(const FoldingSetNodeIDRef ID, SCEVPredicateKind Kind);\n\n  SCEVPredicateKind getKind() const { return Kind; }\n\n  /// Returns the estimated complexity of this predicate.  This is roughly\n  /// measured in the number of run-time checks required.\n  virtual unsigned getComplexity() const { return 1; }\n\n  /// Returns true if the predicate is always true. This means that no\n  /// assumptions were made and nothing needs to be checked at run-time.\n  virtual bool isAlwaysTrue() const = 0;\n\n  /// Returns true if this predicate implies \\p N.\n  virtual bool implies(const SCEVPredicate *N) const = 0;\n\n  /// Prints a textual representation of this predicate with an indentation of\n  /// \\p Depth.\n  virtual void print(raw_ostream &OS, unsigned Depth = 0) const = 0;\n\n  /// Returns the SCEV to which this predicate applies, or nullptr if this is\n  /// a SCEVUnionPredicate.\n  virtual const SCEV *getExpr() const = 0;\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const SCEVPredicate &P) {\n  P.print(OS);\n  return OS;\n}\n\n// Specialize FoldingSetTrait for SCEVPredicate to avoid needing to compute\n// temporary FoldingSetNodeID values.\ntemplate <>\nstruct FoldingSetTrait<SCEVPredicate> : DefaultFoldingSetTrait<SCEVPredicate> {\n  static void Profile(const SCEVPredicate &X, FoldingSetNodeID &ID) {\n    ID = X.FastID;\n  }\n\n  static bool Equals(const SCEVPredicate &X, const FoldingSetNodeID &ID,\n                     unsigned IDHash, FoldingSetNodeID &TempID) {\n    return ID == X.FastID;\n  }\n\n  static unsigned ComputeHash(const SCEVPredicate &X,\n                              FoldingSetNodeID &TempID) {\n    return X.FastID.ComputeHash();\n  }\n};\n\n/// This class represents an assumption that two SCEV expressions are equal,\n/// and this can be checked at run-time.\nclass SCEVEqualPredicate final : public SCEVPredicate {\n  /// We assume that LHS == RHS.\n  const SCEV *LHS;\n  const SCEV *RHS;\n\npublic:\n  SCEVEqualPredicate(const FoldingSetNodeIDRef ID, const SCEV *LHS,\n                     const SCEV *RHS);\n\n  /// Implementation of the SCEVPredicate interface\n  bool implies(const SCEVPredicate *N) const override;\n  void print(raw_ostream &OS, unsigned Depth = 0) const override;\n  bool isAlwaysTrue() const override;\n  const SCEV *getExpr() const override;\n\n  /// Returns the left hand side of the equality.\n  const SCEV *getLHS() const { return LHS; }\n\n  /// Returns the right hand side of the equality.\n  const SCEV *getRHS() const { return RHS; }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const SCEVPredicate *P) {\n    return P->getKind() == P_Equal;\n  }\n};\n\n/// This class represents an assumption made on an AddRec expression. Given an\n/// affine AddRec expression {a,+,b}, we assume that it has the nssw or nusw\n/// flags (defined below) in the first X iterations of the loop, where X is a\n/// SCEV expression returned by getPredicatedBackedgeTakenCount).\n///\n/// Note that this does not imply that X is equal to the backedge taken\n/// count. This means that if we have a nusw predicate for i32 {0,+,1} with a\n/// predicated backedge taken count of X, we only guarantee that {0,+,1} has\n/// nusw in the first X iterations. {0,+,1} may still wrap in the loop if we\n/// have more than X iterations.\nclass SCEVWrapPredicate final : public SCEVPredicate {\npublic:\n  /// Similar to SCEV::NoWrapFlags, but with slightly different semantics\n  /// for FlagNUSW. The increment is considered to be signed, and a + b\n  /// (where b is the increment) is considered to wrap if:\n  ///    zext(a + b) != zext(a) + sext(b)\n  ///\n  /// If Signed is a function that takes an n-bit tuple and maps to the\n  /// integer domain as the tuples value interpreted as twos complement,\n  /// and Unsigned a function that takes an n-bit tuple and maps to the\n  /// integer domain as as the base two value of input tuple, then a + b\n  /// has IncrementNUSW iff:\n  ///\n  /// 0 <= Unsigned(a) + Signed(b) < 2^n\n  ///\n  /// The IncrementNSSW flag has identical semantics with SCEV::FlagNSW.\n  ///\n  /// Note that the IncrementNUSW flag is not commutative: if base + inc\n  /// has IncrementNUSW, then inc + base doesn't neccessarily have this\n  /// property. The reason for this is that this is used for sign/zero\n  /// extending affine AddRec SCEV expressions when a SCEVWrapPredicate is\n  /// assumed. A {base,+,inc} expression is already non-commutative with\n  /// regards to base and inc, since it is interpreted as:\n  ///     (((base + inc) + inc) + inc) ...\n  enum IncrementWrapFlags {\n    IncrementAnyWrap = 0,     // No guarantee.\n    IncrementNUSW = (1 << 0), // No unsigned with signed increment wrap.\n    IncrementNSSW = (1 << 1), // No signed with signed increment wrap\n                              // (equivalent with SCEV::NSW)\n    IncrementNoWrapMask = (1 << 2) - 1\n  };\n\n  /// Convenient IncrementWrapFlags manipulation methods.\n  LLVM_NODISCARD static SCEVWrapPredicate::IncrementWrapFlags\n  clearFlags(SCEVWrapPredicate::IncrementWrapFlags Flags,\n             SCEVWrapPredicate::IncrementWrapFlags OffFlags) {\n    assert((Flags & IncrementNoWrapMask) == Flags && \"Invalid flags value!\");\n    assert((OffFlags & IncrementNoWrapMask) == OffFlags &&\n           \"Invalid flags value!\");\n    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags & ~OffFlags);\n  }\n\n  LLVM_NODISCARD static SCEVWrapPredicate::IncrementWrapFlags\n  maskFlags(SCEVWrapPredicate::IncrementWrapFlags Flags, int Mask) {\n    assert((Flags & IncrementNoWrapMask) == Flags && \"Invalid flags value!\");\n    assert((Mask & IncrementNoWrapMask) == Mask && \"Invalid mask value!\");\n\n    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags & Mask);\n  }\n\n  LLVM_NODISCARD static SCEVWrapPredicate::IncrementWrapFlags\n  setFlags(SCEVWrapPredicate::IncrementWrapFlags Flags,\n           SCEVWrapPredicate::IncrementWrapFlags OnFlags) {\n    assert((Flags & IncrementNoWrapMask) == Flags && \"Invalid flags value!\");\n    assert((OnFlags & IncrementNoWrapMask) == OnFlags &&\n           \"Invalid flags value!\");\n\n    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags | OnFlags);\n  }\n\n  /// Returns the set of SCEVWrapPredicate no wrap flags implied by a\n  /// SCEVAddRecExpr.\n  LLVM_NODISCARD static SCEVWrapPredicate::IncrementWrapFlags\n  getImpliedFlags(const SCEVAddRecExpr *AR, ScalarEvolution &SE);\n\nprivate:\n  const SCEVAddRecExpr *AR;\n  IncrementWrapFlags Flags;\n\npublic:\n  explicit SCEVWrapPredicate(const FoldingSetNodeIDRef ID,\n                             const SCEVAddRecExpr *AR,\n                             IncrementWrapFlags Flags);\n\n  /// Returns the set assumed no overflow flags.\n  IncrementWrapFlags getFlags() const { return Flags; }\n\n  /// Implementation of the SCEVPredicate interface\n  const SCEV *getExpr() const override;\n  bool implies(const SCEVPredicate *N) const override;\n  void print(raw_ostream &OS, unsigned Depth = 0) const override;\n  bool isAlwaysTrue() const override;\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const SCEVPredicate *P) {\n    return P->getKind() == P_Wrap;\n  }\n};\n\n/// This class represents a composition of other SCEV predicates, and is the\n/// class that most clients will interact with.  This is equivalent to a\n/// logical \"AND\" of all the predicates in the union.\n///\n/// NB! Unlike other SCEVPredicate sub-classes this class does not live in the\n/// ScalarEvolution::Preds folding set.  This is why the \\c add function is sound.\nclass SCEVUnionPredicate final : public SCEVPredicate {\nprivate:\n  using PredicateMap =\n      DenseMap<const SCEV *, SmallVector<const SCEVPredicate *, 4>>;\n\n  /// Vector with references to all predicates in this union.\n  SmallVector<const SCEVPredicate *, 16> Preds;\n\n  /// Maps SCEVs to predicates for quick look-ups.\n  PredicateMap SCEVToPreds;\n\npublic:\n  SCEVUnionPredicate();\n\n  const SmallVectorImpl<const SCEVPredicate *> &getPredicates() const {\n    return Preds;\n  }\n\n  /// Adds a predicate to this union.\n  void add(const SCEVPredicate *N);\n\n  /// Returns a reference to a vector containing all predicates which apply to\n  /// \\p Expr.\n  ArrayRef<const SCEVPredicate *> getPredicatesForExpr(const SCEV *Expr);\n\n  /// Implementation of the SCEVPredicate interface\n  bool isAlwaysTrue() const override;\n  bool implies(const SCEVPredicate *N) const override;\n  void print(raw_ostream &OS, unsigned Depth) const override;\n  const SCEV *getExpr() const override;\n\n  /// We estimate the complexity of a union predicate as the size number of\n  /// predicates in the union.\n  unsigned getComplexity() const override { return Preds.size(); }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const SCEVPredicate *P) {\n    return P->getKind() == P_Union;\n  }\n};\n\n/// The main scalar evolution driver. Because client code (intentionally)\n/// can't do much with the SCEV objects directly, they must ask this class\n/// for services.\nclass ScalarEvolution {\n  friend class ScalarEvolutionsTest;\n\npublic:\n  /// An enum describing the relationship between a SCEV and a loop.\n  enum LoopDisposition {\n    LoopVariant,   ///< The SCEV is loop-variant (unknown).\n    LoopInvariant, ///< The SCEV is loop-invariant.\n    LoopComputable ///< The SCEV varies predictably with the loop.\n  };\n\n  /// An enum describing the relationship between a SCEV and a basic block.\n  enum BlockDisposition {\n    DoesNotDominateBlock,  ///< The SCEV does not dominate the block.\n    DominatesBlock,        ///< The SCEV dominates the block.\n    ProperlyDominatesBlock ///< The SCEV properly dominates the block.\n  };\n\n  /// Convenient NoWrapFlags manipulation that hides enum casts and is\n  /// visible in the ScalarEvolution name space.\n  LLVM_NODISCARD static SCEV::NoWrapFlags maskFlags(SCEV::NoWrapFlags Flags,\n                                                    int Mask) {\n    return (SCEV::NoWrapFlags)(Flags & Mask);\n  }\n  LLVM_NODISCARD static SCEV::NoWrapFlags setFlags(SCEV::NoWrapFlags Flags,\n                                                   SCEV::NoWrapFlags OnFlags) {\n    return (SCEV::NoWrapFlags)(Flags | OnFlags);\n  }\n  LLVM_NODISCARD static SCEV::NoWrapFlags\n  clearFlags(SCEV::NoWrapFlags Flags, SCEV::NoWrapFlags OffFlags) {\n    return (SCEV::NoWrapFlags)(Flags & ~OffFlags);\n  }\n\n  ScalarEvolution(Function &F, TargetLibraryInfo &TLI, AssumptionCache &AC,\n                  DominatorTree &DT, LoopInfo &LI);\n  ScalarEvolution(ScalarEvolution &&Arg);\n  ~ScalarEvolution();\n\n  LLVMContext &getContext() const { return F.getContext(); }\n\n  /// Test if values of the given type are analyzable within the SCEV\n  /// framework. This primarily includes integer types, and it can optionally\n  /// include pointer types if the ScalarEvolution class has access to\n  /// target-specific information.\n  bool isSCEVable(Type *Ty) const;\n\n  /// Return the size in bits of the specified type, for which isSCEVable must\n  /// return true.\n  uint64_t getTypeSizeInBits(Type *Ty) const;\n\n  /// Return a type with the same bitwidth as the given type and which\n  /// represents how SCEV will treat the given type, for which isSCEVable must\n  /// return true. For pointer types, this is the pointer-sized integer type.\n  Type *getEffectiveSCEVType(Type *Ty) const;\n\n  // Returns a wider type among {Ty1, Ty2}.\n  Type *getWiderType(Type *Ty1, Type *Ty2) const;\n\n  /// Return true if the SCEV is a scAddRecExpr or it contains\n  /// scAddRecExpr. The result will be cached in HasRecMap.\n  bool containsAddRecurrence(const SCEV *S);\n\n  /// Erase Value from ValueExprMap and ExprValueMap.\n  void eraseValueFromMap(Value *V);\n\n  /// Return a SCEV expression for the full generality of the specified\n  /// expression.\n  const SCEV *getSCEV(Value *V);\n\n  const SCEV *getConstant(ConstantInt *V);\n  const SCEV *getConstant(const APInt &Val);\n  const SCEV *getConstant(Type *Ty, uint64_t V, bool isSigned = false);\n  const SCEV *getPtrToIntExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);\n  const SCEV *getTruncateExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);\n  const SCEV *getZeroExtendExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);\n  const SCEV *getSignExtendExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);\n  const SCEV *getAnyExtendExpr(const SCEV *Op, Type *Ty);\n  const SCEV *getAddExpr(SmallVectorImpl<const SCEV *> &Ops,\n                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,\n                         unsigned Depth = 0);\n  const SCEV *getAddExpr(const SCEV *LHS, const SCEV *RHS,\n                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,\n                         unsigned Depth = 0) {\n    SmallVector<const SCEV *, 2> Ops = {LHS, RHS};\n    return getAddExpr(Ops, Flags, Depth);\n  }\n  const SCEV *getAddExpr(const SCEV *Op0, const SCEV *Op1, const SCEV *Op2,\n                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,\n                         unsigned Depth = 0) {\n    SmallVector<const SCEV *, 3> Ops = {Op0, Op1, Op2};\n    return getAddExpr(Ops, Flags, Depth);\n  }\n  const SCEV *getMulExpr(SmallVectorImpl<const SCEV *> &Ops,\n                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,\n                         unsigned Depth = 0);\n  const SCEV *getMulExpr(const SCEV *LHS, const SCEV *RHS,\n                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,\n                         unsigned Depth = 0) {\n    SmallVector<const SCEV *, 2> Ops = {LHS, RHS};\n    return getMulExpr(Ops, Flags, Depth);\n  }\n  const SCEV *getMulExpr(const SCEV *Op0, const SCEV *Op1, const SCEV *Op2,\n                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,\n                         unsigned Depth = 0) {\n    SmallVector<const SCEV *, 3> Ops = {Op0, Op1, Op2};\n    return getMulExpr(Ops, Flags, Depth);\n  }\n  const SCEV *getUDivExpr(const SCEV *LHS, const SCEV *RHS);\n  const SCEV *getUDivExactExpr(const SCEV *LHS, const SCEV *RHS);\n  const SCEV *getURemExpr(const SCEV *LHS, const SCEV *RHS);\n  const SCEV *getAddRecExpr(const SCEV *Start, const SCEV *Step, const Loop *L,\n                            SCEV::NoWrapFlags Flags);\n  const SCEV *getAddRecExpr(SmallVectorImpl<const SCEV *> &Operands,\n                            const Loop *L, SCEV::NoWrapFlags Flags);\n  const SCEV *getAddRecExpr(const SmallVectorImpl<const SCEV *> &Operands,\n                            const Loop *L, SCEV::NoWrapFlags Flags) {\n    SmallVector<const SCEV *, 4> NewOp(Operands.begin(), Operands.end());\n    return getAddRecExpr(NewOp, L, Flags);\n  }\n\n  /// Checks if \\p SymbolicPHI can be rewritten as an AddRecExpr under some\n  /// Predicates. If successful return these <AddRecExpr, Predicates>;\n  /// The function is intended to be called from PSCEV (the caller will decide\n  /// whether to actually add the predicates and carry out the rewrites).\n  Optional<std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>>\n  createAddRecFromPHIWithCasts(const SCEVUnknown *SymbolicPHI);\n\n  /// Returns an expression for a GEP\n  ///\n  /// \\p GEP The GEP. The indices contained in the GEP itself are ignored,\n  /// instead we use IndexExprs.\n  /// \\p IndexExprs The expressions for the indices.\n  const SCEV *getGEPExpr(GEPOperator *GEP,\n                         const SmallVectorImpl<const SCEV *> &IndexExprs);\n  const SCEV *getAbsExpr(const SCEV *Op, bool IsNSW);\n  const SCEV *getSignumExpr(const SCEV *Op);\n  const SCEV *getMinMaxExpr(SCEVTypes Kind,\n                            SmallVectorImpl<const SCEV *> &Operands);\n  const SCEV *getSMaxExpr(const SCEV *LHS, const SCEV *RHS);\n  const SCEV *getSMaxExpr(SmallVectorImpl<const SCEV *> &Operands);\n  const SCEV *getUMaxExpr(const SCEV *LHS, const SCEV *RHS);\n  const SCEV *getUMaxExpr(SmallVectorImpl<const SCEV *> &Operands);\n  const SCEV *getSMinExpr(const SCEV *LHS, const SCEV *RHS);\n  const SCEV *getSMinExpr(SmallVectorImpl<const SCEV *> &Operands);\n  const SCEV *getUMinExpr(const SCEV *LHS, const SCEV *RHS);\n  const SCEV *getUMinExpr(SmallVectorImpl<const SCEV *> &Operands);\n  const SCEV *getUnknown(Value *V);\n  const SCEV *getCouldNotCompute();\n\n  /// Return a SCEV for the constant 0 of a specific type.\n  const SCEV *getZero(Type *Ty) { return getConstant(Ty, 0); }\n\n  /// Return a SCEV for the constant 1 of a specific type.\n  const SCEV *getOne(Type *Ty) { return getConstant(Ty, 1); }\n\n  /// Return a SCEV for the constant -1 of a specific type.\n  const SCEV *getMinusOne(Type *Ty) {\n    return getConstant(Ty, -1, /*isSigned=*/true);\n  }\n\n  /// Return an expression for sizeof ScalableTy that is type IntTy, where\n  /// ScalableTy is a scalable vector type.\n  const SCEV *getSizeOfScalableVectorExpr(Type *IntTy,\n                                          ScalableVectorType *ScalableTy);\n\n  /// Return an expression for the alloc size of AllocTy that is type IntTy\n  const SCEV *getSizeOfExpr(Type *IntTy, Type *AllocTy);\n\n  /// Return an expression for the store size of StoreTy that is type IntTy\n  const SCEV *getStoreSizeOfExpr(Type *IntTy, Type *StoreTy);\n\n  /// Return an expression for offsetof on the given field with type IntTy\n  const SCEV *getOffsetOfExpr(Type *IntTy, StructType *STy, unsigned FieldNo);\n\n  /// Return the SCEV object corresponding to -V.\n  const SCEV *getNegativeSCEV(const SCEV *V,\n                              SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap);\n\n  /// Return the SCEV object corresponding to ~V.\n  const SCEV *getNotSCEV(const SCEV *V);\n\n  /// Return LHS-RHS.  Minus is represented in SCEV as A+B*-1.\n  const SCEV *getMinusSCEV(const SCEV *LHS, const SCEV *RHS,\n                           SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,\n                           unsigned Depth = 0);\n\n  /// Return a SCEV corresponding to a conversion of the input value to the\n  /// specified type.  If the type must be extended, it is zero extended.\n  const SCEV *getTruncateOrZeroExtend(const SCEV *V, Type *Ty,\n                                      unsigned Depth = 0);\n\n  /// Return a SCEV corresponding to a conversion of the input value to the\n  /// specified type.  If the type must be extended, it is sign extended.\n  const SCEV *getTruncateOrSignExtend(const SCEV *V, Type *Ty,\n                                      unsigned Depth = 0);\n\n  /// Return a SCEV corresponding to a conversion of the input value to the\n  /// specified type.  If the type must be extended, it is zero extended.  The\n  /// conversion must not be narrowing.\n  const SCEV *getNoopOrZeroExtend(const SCEV *V, Type *Ty);\n\n  /// Return a SCEV corresponding to a conversion of the input value to the\n  /// specified type.  If the type must be extended, it is sign extended.  The\n  /// conversion must not be narrowing.\n  const SCEV *getNoopOrSignExtend(const SCEV *V, Type *Ty);\n\n  /// Return a SCEV corresponding to a conversion of the input value to the\n  /// specified type. If the type must be extended, it is extended with\n  /// unspecified bits. The conversion must not be narrowing.\n  const SCEV *getNoopOrAnyExtend(const SCEV *V, Type *Ty);\n\n  /// Return a SCEV corresponding to a conversion of the input value to the\n  /// specified type.  The conversion must not be widening.\n  const SCEV *getTruncateOrNoop(const SCEV *V, Type *Ty);\n\n  /// Promote the operands to the wider of the types using zero-extension, and\n  /// then perform a umax operation with them.\n  const SCEV *getUMaxFromMismatchedTypes(const SCEV *LHS, const SCEV *RHS);\n\n  /// Promote the operands to the wider of the types using zero-extension, and\n  /// then perform a umin operation with them.\n  const SCEV *getUMinFromMismatchedTypes(const SCEV *LHS, const SCEV *RHS);\n\n  /// Promote the operands to the wider of the types using zero-extension, and\n  /// then perform a umin operation with them. N-ary function.\n  const SCEV *getUMinFromMismatchedTypes(SmallVectorImpl<const SCEV *> &Ops);\n\n  /// Transitively follow the chain of pointer-type operands until reaching a\n  /// SCEV that does not have a single pointer operand. This returns a\n  /// SCEVUnknown pointer for well-formed pointer-type expressions, but corner\n  /// cases do exist.\n  const SCEV *getPointerBase(const SCEV *V);\n\n  /// Return a SCEV expression for the specified value at the specified scope\n  /// in the program.  The L value specifies a loop nest to evaluate the\n  /// expression at, where null is the top-level or a specified loop is\n  /// immediately inside of the loop.\n  ///\n  /// This method can be used to compute the exit value for a variable defined\n  /// in a loop by querying what the value will hold in the parent loop.\n  ///\n  /// In the case that a relevant loop exit value cannot be computed, the\n  /// original value V is returned.\n  const SCEV *getSCEVAtScope(const SCEV *S, const Loop *L);\n\n  /// This is a convenience function which does getSCEVAtScope(getSCEV(V), L).\n  const SCEV *getSCEVAtScope(Value *V, const Loop *L);\n\n  /// Test whether entry to the loop is protected by a conditional between LHS\n  /// and RHS.  This is used to help avoid max expressions in loop trip\n  /// counts, and to eliminate casts.\n  bool isLoopEntryGuardedByCond(const Loop *L, ICmpInst::Predicate Pred,\n                                const SCEV *LHS, const SCEV *RHS);\n\n  /// Test whether entry to the basic block is protected by a conditional\n  /// between LHS and RHS.\n  bool isBasicBlockEntryGuardedByCond(const BasicBlock *BB,\n                                      ICmpInst::Predicate Pred, const SCEV *LHS,\n                                      const SCEV *RHS);\n\n  /// Test whether the backedge of the loop is protected by a conditional\n  /// between LHS and RHS.  This is used to eliminate casts.\n  bool isLoopBackedgeGuardedByCond(const Loop *L, ICmpInst::Predicate Pred,\n                                   const SCEV *LHS, const SCEV *RHS);\n\n  /// Returns the maximum trip count of the loop if it is a single-exit\n  /// loop and we can compute a small maximum for that loop.\n  ///\n  /// Implemented in terms of the \\c getSmallConstantTripCount overload with\n  /// the single exiting block passed to it. See that routine for details.\n  unsigned getSmallConstantTripCount(const Loop *L);\n\n  /// Returns the maximum trip count of this loop as a normal unsigned\n  /// value. Returns 0 if the trip count is unknown or not constant. This\n  /// \"trip count\" assumes that control exits via ExitingBlock. More\n  /// precisely, it is the number of times that control may reach ExitingBlock\n  /// before taking the branch. For loops with multiple exits, it may not be\n  /// the number times that the loop header executes if the loop exits\n  /// prematurely via another branch.\n  unsigned getSmallConstantTripCount(const Loop *L,\n                                     const BasicBlock *ExitingBlock);\n\n  /// Returns the upper bound of the loop trip count as a normal unsigned\n  /// value.\n  /// Returns 0 if the trip count is unknown or not constant.\n  unsigned getSmallConstantMaxTripCount(const Loop *L);\n\n  /// Returns the largest constant divisor of the trip count of the\n  /// loop if it is a single-exit loop and we can compute a small maximum for\n  /// that loop.\n  ///\n  /// Implemented in terms of the \\c getSmallConstantTripMultiple overload with\n  /// the single exiting block passed to it. See that routine for details.\n  unsigned getSmallConstantTripMultiple(const Loop *L);\n\n  /// Returns the largest constant divisor of the trip count of this loop as a\n  /// normal unsigned value, if possible. This means that the actual trip\n  /// count is always a multiple of the returned value (don't forget the trip\n  /// count could very well be zero as well!). As explained in the comments\n  /// for getSmallConstantTripCount, this assumes that control exits the loop\n  /// via ExitingBlock.\n  unsigned getSmallConstantTripMultiple(const Loop *L,\n                                        const BasicBlock *ExitingBlock);\n\n  /// The terms \"backedge taken count\" and \"exit count\" are used\n  /// interchangeably to refer to the number of times the backedge of a loop \n  /// has executed before the loop is exited.\n  enum ExitCountKind {\n    /// An expression exactly describing the number of times the backedge has\n    /// executed when a loop is exited.\n    Exact,\n    /// A constant which provides an upper bound on the exact trip count.\n    ConstantMaximum,\n    /// An expression which provides an upper bound on the exact trip count.\n    SymbolicMaximum,\n  };\n\n  /// Return the number of times the backedge executes before the given exit\n  /// would be taken; if not exactly computable, return SCEVCouldNotCompute. \n  /// For a single exit loop, this value is equivelent to the result of\n  /// getBackedgeTakenCount.  The loop is guaranteed to exit (via *some* exit)\n  /// before the backedge is executed (ExitCount + 1) times.  Note that there\n  /// is no guarantee about *which* exit is taken on the exiting iteration.\n  const SCEV *getExitCount(const Loop *L, const BasicBlock *ExitingBlock,\n                           ExitCountKind Kind = Exact);\n\n  /// If the specified loop has a predictable backedge-taken count, return it,\n  /// otherwise return a SCEVCouldNotCompute object. The backedge-taken count is\n  /// the number of times the loop header will be branched to from within the\n  /// loop, assuming there are no abnormal exists like exception throws. This is\n  /// one less than the trip count of the loop, since it doesn't count the first\n  /// iteration, when the header is branched to from outside the loop.\n  ///\n  /// Note that it is not valid to call this method on a loop without a\n  /// loop-invariant backedge-taken count (see\n  /// hasLoopInvariantBackedgeTakenCount).\n  const SCEV *getBackedgeTakenCount(const Loop *L, ExitCountKind Kind = Exact);\n\n  /// Similar to getBackedgeTakenCount, except it will add a set of\n  /// SCEV predicates to Predicates that are required to be true in order for\n  /// the answer to be correct. Predicates can be checked with run-time\n  /// checks and can be used to perform loop versioning.\n  const SCEV *getPredicatedBackedgeTakenCount(const Loop *L,\n                                              SCEVUnionPredicate &Predicates);\n\n  /// When successful, this returns a SCEVConstant that is greater than or equal\n  /// to (i.e. a \"conservative over-approximation\") of the value returend by\n  /// getBackedgeTakenCount.  If such a value cannot be computed, it returns the\n  /// SCEVCouldNotCompute object.\n  const SCEV *getConstantMaxBackedgeTakenCount(const Loop *L) {\n    return getBackedgeTakenCount(L, ConstantMaximum);\n  }\n\n  /// When successful, this returns a SCEV that is greater than or equal\n  /// to (i.e. a \"conservative over-approximation\") of the value returend by\n  /// getBackedgeTakenCount.  If such a value cannot be computed, it returns the\n  /// SCEVCouldNotCompute object.\n  const SCEV *getSymbolicMaxBackedgeTakenCount(const Loop *L) {\n    return getBackedgeTakenCount(L, SymbolicMaximum);\n  }\n\n  /// Return true if the backedge taken count is either the value returned by\n  /// getConstantMaxBackedgeTakenCount or zero.\n  bool isBackedgeTakenCountMaxOrZero(const Loop *L);\n\n  /// Return true if the specified loop has an analyzable loop-invariant\n  /// backedge-taken count.\n  bool hasLoopInvariantBackedgeTakenCount(const Loop *L);\n\n  // This method should be called by the client when it made any change that\n  // would invalidate SCEV's answers, and the client wants to remove all loop\n  // information held internally by ScalarEvolution. This is intended to be used\n  // when the alternative to forget a loop is too expensive (i.e. large loop\n  // bodies).\n  void forgetAllLoops();\n\n  /// This method should be called by the client when it has changed a loop in\n  /// a way that may effect ScalarEvolution's ability to compute a trip count,\n  /// or if the loop is deleted.  This call is potentially expensive for large\n  /// loop bodies.\n  void forgetLoop(const Loop *L);\n\n  // This method invokes forgetLoop for the outermost loop of the given loop\n  // \\p L, making ScalarEvolution forget about all this subtree. This needs to\n  // be done whenever we make a transform that may affect the parameters of the\n  // outer loop, such as exit counts for branches.\n  void forgetTopmostLoop(const Loop *L);\n\n  /// This method should be called by the client when it has changed a value\n  /// in a way that may effect its value, or which may disconnect it from a\n  /// def-use chain linking it to a loop.\n  void forgetValue(Value *V);\n\n  /// Called when the client has changed the disposition of values in\n  /// this loop.\n  ///\n  /// We don't have a way to invalidate per-loop dispositions. Clear and\n  /// recompute is simpler.\n  void forgetLoopDispositions(const Loop *L);\n\n  /// Determine the minimum number of zero bits that S is guaranteed to end in\n  /// (at every loop iteration).  It is, at the same time, the minimum number\n  /// of times S is divisible by 2.  For example, given {4,+,8} it returns 2.\n  /// If S is guaranteed to be 0, it returns the bitwidth of S.\n  uint32_t GetMinTrailingZeros(const SCEV *S);\n\n  /// Determine the unsigned range for a particular SCEV.\n  /// NOTE: This returns a copy of the reference returned by getRangeRef.\n  ConstantRange getUnsignedRange(const SCEV *S) {\n    return getRangeRef(S, HINT_RANGE_UNSIGNED);\n  }\n\n  /// Determine the min of the unsigned range for a particular SCEV.\n  APInt getUnsignedRangeMin(const SCEV *S) {\n    return getRangeRef(S, HINT_RANGE_UNSIGNED).getUnsignedMin();\n  }\n\n  /// Determine the max of the unsigned range for a particular SCEV.\n  APInt getUnsignedRangeMax(const SCEV *S) {\n    return getRangeRef(S, HINT_RANGE_UNSIGNED).getUnsignedMax();\n  }\n\n  /// Determine the signed range for a particular SCEV.\n  /// NOTE: This returns a copy of the reference returned by getRangeRef.\n  ConstantRange getSignedRange(const SCEV *S) {\n    return getRangeRef(S, HINT_RANGE_SIGNED);\n  }\n\n  /// Determine the min of the signed range for a particular SCEV.\n  APInt getSignedRangeMin(const SCEV *S) {\n    return getRangeRef(S, HINT_RANGE_SIGNED).getSignedMin();\n  }\n\n  /// Determine the max of the signed range for a particular SCEV.\n  APInt getSignedRangeMax(const SCEV *S) {\n    return getRangeRef(S, HINT_RANGE_SIGNED).getSignedMax();\n  }\n\n  /// Test if the given expression is known to be negative.\n  bool isKnownNegative(const SCEV *S);\n\n  /// Test if the given expression is known to be positive.\n  bool isKnownPositive(const SCEV *S);\n\n  /// Test if the given expression is known to be non-negative.\n  bool isKnownNonNegative(const SCEV *S);\n\n  /// Test if the given expression is known to be non-positive.\n  bool isKnownNonPositive(const SCEV *S);\n\n  /// Test if the given expression is known to be non-zero.\n  bool isKnownNonZero(const SCEV *S);\n\n  /// Splits SCEV expression \\p S into two SCEVs. One of them is obtained from\n  /// \\p S by substitution of all AddRec sub-expression related to loop \\p L\n  /// with initial value of that SCEV. The second is obtained from \\p S by\n  /// substitution of all AddRec sub-expressions related to loop \\p L with post\n  /// increment of this AddRec in the loop \\p L. In both cases all other AddRec\n  /// sub-expressions (not related to \\p L) remain the same.\n  /// If the \\p S contains non-invariant unknown SCEV the function returns\n  /// CouldNotCompute SCEV in both values of std::pair.\n  /// For example, for SCEV S={0, +, 1}<L1> + {0, +, 1}<L2> and loop L=L1\n  /// the function returns pair:\n  /// first = {0, +, 1}<L2>\n  /// second = {1, +, 1}<L1> + {0, +, 1}<L2>\n  /// We can see that for the first AddRec sub-expression it was replaced with\n  /// 0 (initial value) for the first element and to {1, +, 1}<L1> (post\n  /// increment value) for the second one. In both cases AddRec expression\n  /// related to L2 remains the same.\n  std::pair<const SCEV *, const SCEV *> SplitIntoInitAndPostInc(const Loop *L,\n                                                                const SCEV *S);\n\n  /// We'd like to check the predicate on every iteration of the most dominated\n  /// loop between loops used in LHS and RHS.\n  /// To do this we use the following list of steps:\n  /// 1. Collect set S all loops on which either LHS or RHS depend.\n  /// 2. If S is non-empty\n  /// a. Let PD be the element of S which is dominated by all other elements.\n  /// b. Let E(LHS) be value of LHS on entry of PD.\n  ///    To get E(LHS), we should just take LHS and replace all AddRecs that are\n  ///    attached to PD on with their entry values.\n  ///    Define E(RHS) in the same way.\n  /// c. Let B(LHS) be value of L on backedge of PD.\n  ///    To get B(LHS), we should just take LHS and replace all AddRecs that are\n  ///    attached to PD on with their backedge values.\n  ///    Define B(RHS) in the same way.\n  /// d. Note that E(LHS) and E(RHS) are automatically available on entry of PD,\n  ///    so we can assert on that.\n  /// e. Return true if isLoopEntryGuardedByCond(Pred, E(LHS), E(RHS)) &&\n  ///                   isLoopBackedgeGuardedByCond(Pred, B(LHS), B(RHS))\n  bool isKnownViaInduction(ICmpInst::Predicate Pred, const SCEV *LHS,\n                           const SCEV *RHS);\n\n  /// Test if the given expression is known to satisfy the condition described\n  /// by Pred, LHS, and RHS.\n  bool isKnownPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,\n                        const SCEV *RHS);\n\n  /// Test if the given expression is known to satisfy the condition described\n  /// by Pred, LHS, and RHS in the given Context.\n  bool isKnownPredicateAt(ICmpInst::Predicate Pred, const SCEV *LHS,\n                        const SCEV *RHS, const Instruction *Context);\n\n  /// Test if the condition described by Pred, LHS, RHS is known to be true on\n  /// every iteration of the loop of the recurrency LHS.\n  bool isKnownOnEveryIteration(ICmpInst::Predicate Pred,\n                               const SCEVAddRecExpr *LHS, const SCEV *RHS);\n\n  /// A predicate is said to be monotonically increasing if may go from being\n  /// false to being true as the loop iterates, but never the other way\n  /// around.  A predicate is said to be monotonically decreasing if may go\n  /// from being true to being false as the loop iterates, but never the other\n  /// way around.\n  enum MonotonicPredicateType {\n    MonotonicallyIncreasing,\n    MonotonicallyDecreasing\n  };\n\n  /// If, for all loop invariant X, the predicate \"LHS `Pred` X\" is\n  /// monotonically increasing or decreasing, returns\n  /// Some(MonotonicallyIncreasing) and Some(MonotonicallyDecreasing)\n  /// respectively. If we could not prove either of these facts, returns None.\n  Optional<MonotonicPredicateType>\n  getMonotonicPredicateType(const SCEVAddRecExpr *LHS,\n                            ICmpInst::Predicate Pred);\n\n  struct LoopInvariantPredicate {\n    ICmpInst::Predicate Pred;\n    const SCEV *LHS;\n    const SCEV *RHS;\n\n    LoopInvariantPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,\n                           const SCEV *RHS)\n        : Pred(Pred), LHS(LHS), RHS(RHS) {}\n  };\n  /// If the result of the predicate LHS `Pred` RHS is loop invariant with\n  /// respect to L, return a LoopInvariantPredicate with LHS and RHS being\n  /// invariants, available at L's entry. Otherwise, return None.\n  Optional<LoopInvariantPredicate>\n  getLoopInvariantPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,\n                            const SCEV *RHS, const Loop *L);\n\n  /// If the result of the predicate LHS `Pred` RHS is loop invariant with\n  /// respect to L at given Context during at least first MaxIter iterations,\n  /// return a LoopInvariantPredicate with LHS and RHS being invariants,\n  /// available at L's entry. Otherwise, return None. The predicate should be\n  /// the loop's exit condition.\n  Optional<LoopInvariantPredicate>\n  getLoopInvariantExitCondDuringFirstIterations(ICmpInst::Predicate Pred,\n                                                const SCEV *LHS,\n                                                const SCEV *RHS, const Loop *L,\n                                                const Instruction *Context,\n                                                const SCEV *MaxIter);\n\n  /// Simplify LHS and RHS in a comparison with predicate Pred. Return true\n  /// iff any changes were made. If the operands are provably equal or\n  /// unequal, LHS and RHS are set to the same value and Pred is set to either\n  /// ICMP_EQ or ICMP_NE.\n  bool SimplifyICmpOperands(ICmpInst::Predicate &Pred, const SCEV *&LHS,\n                            const SCEV *&RHS, unsigned Depth = 0);\n\n  /// Return the \"disposition\" of the given SCEV with respect to the given\n  /// loop.\n  LoopDisposition getLoopDisposition(const SCEV *S, const Loop *L);\n\n  /// Return true if the value of the given SCEV is unchanging in the\n  /// specified loop.\n  bool isLoopInvariant(const SCEV *S, const Loop *L);\n\n  /// Determine if the SCEV can be evaluated at loop's entry. It is true if it\n  /// doesn't depend on a SCEVUnknown of an instruction which is dominated by\n  /// the header of loop L.\n  bool isAvailableAtLoopEntry(const SCEV *S, const Loop *L);\n\n  /// Return true if the given SCEV changes value in a known way in the\n  /// specified loop.  This property being true implies that the value is\n  /// variant in the loop AND that we can emit an expression to compute the\n  /// value of the expression at any particular loop iteration.\n  bool hasComputableLoopEvolution(const SCEV *S, const Loop *L);\n\n  /// Return the \"disposition\" of the given SCEV with respect to the given\n  /// block.\n  BlockDisposition getBlockDisposition(const SCEV *S, const BasicBlock *BB);\n\n  /// Return true if elements that makes up the given SCEV dominate the\n  /// specified basic block.\n  bool dominates(const SCEV *S, const BasicBlock *BB);\n\n  /// Return true if elements that makes up the given SCEV properly dominate\n  /// the specified basic block.\n  bool properlyDominates(const SCEV *S, const BasicBlock *BB);\n\n  /// Test whether the given SCEV has Op as a direct or indirect operand.\n  bool hasOperand(const SCEV *S, const SCEV *Op) const;\n\n  /// Return the size of an element read or written by Inst.\n  const SCEV *getElementSize(Instruction *Inst);\n\n  /// Compute the array dimensions Sizes from the set of Terms extracted from\n  /// the memory access function of this SCEVAddRecExpr (second step of\n  /// delinearization).\n  void findArrayDimensions(SmallVectorImpl<const SCEV *> &Terms,\n                           SmallVectorImpl<const SCEV *> &Sizes,\n                           const SCEV *ElementSize);\n\n  void print(raw_ostream &OS) const;\n  void verify() const;\n  bool invalidate(Function &F, const PreservedAnalyses &PA,\n                  FunctionAnalysisManager::Invalidator &Inv);\n\n  /// Collect parametric terms occurring in step expressions (first step of\n  /// delinearization).\n  void collectParametricTerms(const SCEV *Expr,\n                              SmallVectorImpl<const SCEV *> &Terms);\n\n  /// Return in Subscripts the access functions for each dimension in Sizes\n  /// (third step of delinearization).\n  void computeAccessFunctions(const SCEV *Expr,\n                              SmallVectorImpl<const SCEV *> &Subscripts,\n                              SmallVectorImpl<const SCEV *> &Sizes);\n\n  /// Gathers the individual index expressions from a GEP instruction.\n  ///\n  /// This function optimistically assumes the GEP references into a fixed size\n  /// array. If this is actually true, this function returns a list of array\n  /// subscript expressions in \\p Subscripts and a list of integers describing\n  /// the size of the individual array dimensions in \\p Sizes. Both lists have\n  /// either equal length or the size list is one element shorter in case there\n  /// is no known size available for the outermost array dimension. Returns true\n  /// if successful and false otherwise.\n  bool getIndexExpressionsFromGEP(const GetElementPtrInst *GEP,\n                                  SmallVectorImpl<const SCEV *> &Subscripts,\n                                  SmallVectorImpl<int> &Sizes);\n\n  /// Split this SCEVAddRecExpr into two vectors of SCEVs representing the\n  /// subscripts and sizes of an array access.\n  ///\n  /// The delinearization is a 3 step process: the first two steps compute the\n  /// sizes of each subscript and the third step computes the access functions\n  /// for the delinearized array:\n  ///\n  /// 1. Find the terms in the step functions\n  /// 2. Compute the array size\n  /// 3. Compute the access function: divide the SCEV by the array size\n  ///    starting with the innermost dimensions found in step 2. The Quotient\n  ///    is the SCEV to be divided in the next step of the recursion. The\n  ///    Remainder is the subscript of the innermost dimension. Loop over all\n  ///    array dimensions computed in step 2.\n  ///\n  /// To compute a uniform array size for several memory accesses to the same\n  /// object, one can collect in step 1 all the step terms for all the memory\n  /// accesses, and compute in step 2 a unique array shape. This guarantees\n  /// that the array shape will be the same across all memory accesses.\n  ///\n  /// FIXME: We could derive the result of steps 1 and 2 from a description of\n  /// the array shape given in metadata.\n  ///\n  /// Example:\n  ///\n  /// A[][n][m]\n  ///\n  /// for i\n  ///   for j\n  ///     for k\n  ///       A[j+k][2i][5i] =\n  ///\n  /// The initial SCEV:\n  ///\n  /// A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k]\n  ///\n  /// 1. Find the different terms in the step functions:\n  /// -> [2*m, 5, n*m, n*m]\n  ///\n  /// 2. Compute the array size: sort and unique them\n  /// -> [n*m, 2*m, 5]\n  /// find the GCD of all the terms = 1\n  /// divide by the GCD and erase constant terms\n  /// -> [n*m, 2*m]\n  /// GCD = m\n  /// divide by GCD -> [n, 2]\n  /// remove constant terms\n  /// -> [n]\n  /// size of the array is A[unknown][n][m]\n  ///\n  /// 3. Compute the access function\n  /// a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m\n  /// Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k\n  /// Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k\n  /// The remainder is the subscript of the innermost array dimension: [5i].\n  ///\n  /// b. Divide Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k by next outer size n\n  /// Quotient: {{{0,+,0}_i, +, 1}_j, +, 1}_k\n  /// Remainder: {{{0,+,2}_i, +, 0}_j, +, 0}_k\n  /// The Remainder is the subscript of the next array dimension: [2i].\n  ///\n  /// The subscript of the outermost dimension is the Quotient: [j+k].\n  ///\n  /// Overall, we have: A[][n][m], and the access function: A[j+k][2i][5i].\n  void delinearize(const SCEV *Expr, SmallVectorImpl<const SCEV *> &Subscripts,\n                   SmallVectorImpl<const SCEV *> &Sizes,\n                   const SCEV *ElementSize);\n\n  /// Return the DataLayout associated with the module this SCEV instance is\n  /// operating on.\n  const DataLayout &getDataLayout() const {\n    return F.getParent()->getDataLayout();\n  }\n\n  const SCEVPredicate *getEqualPredicate(const SCEV *LHS, const SCEV *RHS);\n\n  const SCEVPredicate *\n  getWrapPredicate(const SCEVAddRecExpr *AR,\n                   SCEVWrapPredicate::IncrementWrapFlags AddedFlags);\n\n  /// Re-writes the SCEV according to the Predicates in \\p A.\n  const SCEV *rewriteUsingPredicate(const SCEV *S, const Loop *L,\n                                    SCEVUnionPredicate &A);\n  /// Tries to convert the \\p S expression to an AddRec expression,\n  /// adding additional predicates to \\p Preds as required.\n  const SCEVAddRecExpr *convertSCEVToAddRecWithPredicates(\n      const SCEV *S, const Loop *L,\n      SmallPtrSetImpl<const SCEVPredicate *> &Preds);\n\n  /// Compute \\p LHS - \\p RHS and returns the result as an APInt if it is a\n  /// constant, and None if it isn't.\n  ///\n  /// This is intended to be a cheaper version of getMinusSCEV.  We can be\n  /// frugal here since we just bail out of actually constructing and\n  /// canonicalizing an expression in the cases where the result isn't going\n  /// to be a constant.\n  Optional<APInt> computeConstantDifference(const SCEV *LHS, const SCEV *RHS);\n\n  /// Update no-wrap flags of an AddRec. This may drop the cached info about\n  /// this AddRec (such as range info) in case if new flags may potentially\n  /// sharpen it.\n  void setNoWrapFlags(SCEVAddRecExpr *AddRec, SCEV::NoWrapFlags Flags);\n\n  /// Try to apply information from loop guards for \\p L to \\p Expr.\n  const SCEV *applyLoopGuards(const SCEV *Expr, const Loop *L);\n\nprivate:\n  /// A CallbackVH to arrange for ScalarEvolution to be notified whenever a\n  /// Value is deleted.\n  class SCEVCallbackVH final : public CallbackVH {\n    ScalarEvolution *SE;\n\n    void deleted() override;\n    void allUsesReplacedWith(Value *New) override;\n\n  public:\n    SCEVCallbackVH(Value *V, ScalarEvolution *SE = nullptr);\n  };\n\n  friend class SCEVCallbackVH;\n  friend class SCEVExpander;\n  friend class SCEVUnknown;\n\n  /// The function we are analyzing.\n  Function &F;\n\n  /// Does the module have any calls to the llvm.experimental.guard intrinsic\n  /// at all?  If this is false, we avoid doing work that will only help if\n  /// thare are guards present in the IR.\n  bool HasGuards;\n\n  /// The target library information for the target we are targeting.\n  TargetLibraryInfo &TLI;\n\n  /// The tracker for \\@llvm.assume intrinsics in this function.\n  AssumptionCache &AC;\n\n  /// The dominator tree.\n  DominatorTree &DT;\n\n  /// The loop information for the function we are currently analyzing.\n  LoopInfo &LI;\n\n  /// This SCEV is used to represent unknown trip counts and things.\n  std::unique_ptr<SCEVCouldNotCompute> CouldNotCompute;\n\n  /// The type for HasRecMap.\n  using HasRecMapType = DenseMap<const SCEV *, bool>;\n\n  /// This is a cache to record whether a SCEV contains any scAddRecExpr.\n  HasRecMapType HasRecMap;\n\n  /// The type for ExprValueMap.\n  using ValueOffsetPair = std::pair<Value *, ConstantInt *>;\n  using ExprValueMapType = DenseMap<const SCEV *, SetVector<ValueOffsetPair>>;\n\n  /// ExprValueMap -- This map records the original values from which\n  /// the SCEV expr is generated from.\n  ///\n  /// We want to represent the mapping as SCEV -> ValueOffsetPair instead\n  /// of SCEV -> Value:\n  /// Suppose we know S1 expands to V1, and\n  ///  S1 = S2 + C_a\n  ///  S3 = S2 + C_b\n  /// where C_a and C_b are different SCEVConstants. Then we'd like to\n  /// expand S3 as V1 - C_a + C_b instead of expanding S2 literally.\n  /// It is helpful when S2 is a complex SCEV expr.\n  ///\n  /// In order to do that, we represent ExprValueMap as a mapping from\n  /// SCEV to ValueOffsetPair. We will save both S1->{V1, 0} and\n  /// S2->{V1, C_a} into the map when we create SCEV for V1. When S3\n  /// is expanded, it will first expand S2 to V1 - C_a because of\n  /// S2->{V1, C_a} in the map, then expand S3 to V1 - C_a + C_b.\n  ///\n  /// Note: S->{V, Offset} in the ExprValueMap means S can be expanded\n  /// to V - Offset.\n  ExprValueMapType ExprValueMap;\n\n  /// The type for ValueExprMap.\n  using ValueExprMapType =\n      DenseMap<SCEVCallbackVH, const SCEV *, DenseMapInfo<Value *>>;\n\n  /// This is a cache of the values we have analyzed so far.\n  ValueExprMapType ValueExprMap;\n\n  /// Mark predicate values currently being processed by isImpliedCond.\n  SmallPtrSet<const Value *, 6> PendingLoopPredicates;\n\n  /// Mark SCEVUnknown Phis currently being processed by getRangeRef.\n  SmallPtrSet<const PHINode *, 6> PendingPhiRanges;\n\n  // Mark SCEVUnknown Phis currently being processed by isImpliedViaMerge.\n  SmallPtrSet<const PHINode *, 6> PendingMerges;\n\n  /// Set to true by isLoopBackedgeGuardedByCond when we're walking the set of\n  /// conditions dominating the backedge of a loop.\n  bool WalkingBEDominatingConds = false;\n\n  /// Set to true by isKnownPredicateViaSplitting when we're trying to prove a\n  /// predicate by splitting it into a set of independent predicates.\n  bool ProvingSplitPredicate = false;\n\n  /// Memoized values for the GetMinTrailingZeros\n  DenseMap<const SCEV *, uint32_t> MinTrailingZerosCache;\n\n  /// Return the Value set from which the SCEV expr is generated.\n  SetVector<ValueOffsetPair> *getSCEVValues(const SCEV *S);\n\n  /// Private helper method for the GetMinTrailingZeros method\n  uint32_t GetMinTrailingZerosImpl(const SCEV *S);\n\n  /// Information about the number of loop iterations for which a loop exit's\n  /// branch condition evaluates to the not-taken path.  This is a temporary\n  /// pair of exact and max expressions that are eventually summarized in\n  /// ExitNotTakenInfo and BackedgeTakenInfo.\n  struct ExitLimit {\n    const SCEV *ExactNotTaken; // The exit is not taken exactly this many times\n    const SCEV *MaxNotTaken; // The exit is not taken at most this many times\n\n    // Not taken either exactly MaxNotTaken or zero times\n    bool MaxOrZero = false;\n\n    /// A set of predicate guards for this ExitLimit. The result is only valid\n    /// if all of the predicates in \\c Predicates evaluate to 'true' at\n    /// run-time.\n    SmallPtrSet<const SCEVPredicate *, 4> Predicates;\n\n    void addPredicate(const SCEVPredicate *P) {\n      assert(!isa<SCEVUnionPredicate>(P) && \"Only add leaf predicates here!\");\n      Predicates.insert(P);\n    }\n\n    /// Construct either an exact exit limit from a constant, or an unknown\n    /// one from a SCEVCouldNotCompute.  No other types of SCEVs are allowed\n    /// as arguments and asserts enforce that internally.\n    /*implicit*/ ExitLimit(const SCEV *E);\n\n    ExitLimit(\n        const SCEV *E, const SCEV *M, bool MaxOrZero,\n        ArrayRef<const SmallPtrSetImpl<const SCEVPredicate *> *> PredSetList);\n\n    ExitLimit(const SCEV *E, const SCEV *M, bool MaxOrZero,\n              const SmallPtrSetImpl<const SCEVPredicate *> &PredSet);\n\n    ExitLimit(const SCEV *E, const SCEV *M, bool MaxOrZero);\n\n    /// Test whether this ExitLimit contains any computed information, or\n    /// whether it's all SCEVCouldNotCompute values.\n    bool hasAnyInfo() const {\n      return !isa<SCEVCouldNotCompute>(ExactNotTaken) ||\n             !isa<SCEVCouldNotCompute>(MaxNotTaken);\n    }\n\n    bool hasOperand(const SCEV *S) const;\n\n    /// Test whether this ExitLimit contains all information.\n    bool hasFullInfo() const {\n      return !isa<SCEVCouldNotCompute>(ExactNotTaken);\n    }\n  };\n\n  /// Information about the number of times a particular loop exit may be\n  /// reached before exiting the loop.\n  struct ExitNotTakenInfo {\n    PoisoningVH<BasicBlock> ExitingBlock;\n    const SCEV *ExactNotTaken;\n    const SCEV *MaxNotTaken;\n    std::unique_ptr<SCEVUnionPredicate> Predicate;\n\n    explicit ExitNotTakenInfo(PoisoningVH<BasicBlock> ExitingBlock,\n                              const SCEV *ExactNotTaken,\n                              const SCEV *MaxNotTaken,\n                              std::unique_ptr<SCEVUnionPredicate> Predicate)\n      : ExitingBlock(ExitingBlock), ExactNotTaken(ExactNotTaken),\n        MaxNotTaken(ExactNotTaken), Predicate(std::move(Predicate)) {}\n\n    bool hasAlwaysTruePredicate() const {\n      return !Predicate || Predicate->isAlwaysTrue();\n    }\n  };\n\n  /// Information about the backedge-taken count of a loop. This currently\n  /// includes an exact count and a maximum count.\n  ///\n  class BackedgeTakenInfo {\n    /// A list of computable exits and their not-taken counts.  Loops almost\n    /// never have more than one computable exit.\n    SmallVector<ExitNotTakenInfo, 1> ExitNotTaken;\n\n    /// Expression indicating the least constant maximum backedge-taken count of\n    /// the loop that is known, or a SCEVCouldNotCompute. This expression is\n    /// only valid if the redicates associated with all loop exits are true.\n    const SCEV *ConstantMax;\n\n    /// Indicating if \\c ExitNotTaken has an element for every exiting block in\n    /// the loop.\n    bool IsComplete;\n\n    /// Expression indicating the least maximum backedge-taken count of the loop\n    /// that is known, or a SCEVCouldNotCompute. Lazily computed on first query.\n    const SCEV *SymbolicMax = nullptr;\n\n    /// True iff the backedge is taken either exactly Max or zero times.\n    bool MaxOrZero = false;\n\n    bool isComplete() const { return IsComplete; }\n    const SCEV *getConstantMax() const { return ConstantMax; }\n\n  public:\n    BackedgeTakenInfo() : ConstantMax(nullptr), IsComplete(false) {}\n    BackedgeTakenInfo(BackedgeTakenInfo &&) = default;\n    BackedgeTakenInfo &operator=(BackedgeTakenInfo &&) = default;\n\n    using EdgeExitInfo = std::pair<BasicBlock *, ExitLimit>;\n\n    /// Initialize BackedgeTakenInfo from a list of exact exit counts.\n    BackedgeTakenInfo(ArrayRef<EdgeExitInfo> ExitCounts, bool IsComplete,\n                      const SCEV *ConstantMax, bool MaxOrZero);\n\n    /// Test whether this BackedgeTakenInfo contains any computed information,\n    /// or whether it's all SCEVCouldNotCompute values.\n    bool hasAnyInfo() const {\n      return !ExitNotTaken.empty() ||\n             !isa<SCEVCouldNotCompute>(getConstantMax());\n    }\n\n    /// Test whether this BackedgeTakenInfo contains complete information.\n    bool hasFullInfo() const { return isComplete(); }\n\n    /// Return an expression indicating the exact *backedge-taken*\n    /// count of the loop if it is known or SCEVCouldNotCompute\n    /// otherwise.  If execution makes it to the backedge on every\n    /// iteration (i.e. there are no abnormal exists like exception\n    /// throws and thread exits) then this is the number of times the\n    /// loop header will execute minus one.\n    ///\n    /// If the SCEV predicate associated with the answer can be different\n    /// from AlwaysTrue, we must add a (non null) Predicates argument.\n    /// The SCEV predicate associated with the answer will be added to\n    /// Predicates. A run-time check needs to be emitted for the SCEV\n    /// predicate in order for the answer to be valid.\n    ///\n    /// Note that we should always know if we need to pass a predicate\n    /// argument or not from the way the ExitCounts vector was computed.\n    /// If we allowed SCEV predicates to be generated when populating this\n    /// vector, this information can contain them and therefore a\n    /// SCEVPredicate argument should be added to getExact.\n    const SCEV *getExact(const Loop *L, ScalarEvolution *SE,\n                         SCEVUnionPredicate *Predicates = nullptr) const;\n\n    /// Return the number of times this loop exit may fall through to the back\n    /// edge, or SCEVCouldNotCompute. The loop is guaranteed not to exit via\n    /// this block before this number of iterations, but may exit via another\n    /// block.\n    const SCEV *getExact(const BasicBlock *ExitingBlock,\n                         ScalarEvolution *SE) const;\n\n    /// Get the constant max backedge taken count for the loop.\n    const SCEV *getConstantMax(ScalarEvolution *SE) const;\n\n    /// Get the constant max backedge taken count for the particular loop exit.\n    const SCEV *getConstantMax(const BasicBlock *ExitingBlock,\n                               ScalarEvolution *SE) const;\n\n    /// Get the symbolic max backedge taken count for the loop.\n    const SCEV *getSymbolicMax(const Loop *L, ScalarEvolution *SE);\n\n    /// Return true if the number of times this backedge is taken is either the\n    /// value returned by getConstantMax or zero.\n    bool isConstantMaxOrZero(ScalarEvolution *SE) const;\n\n    /// Return true if any backedge taken count expressions refer to the given\n    /// subexpression.\n    bool hasOperand(const SCEV *S, ScalarEvolution *SE) const;\n\n    /// Invalidate this result and free associated memory.\n    void clear();\n  };\n\n  /// Cache the backedge-taken count of the loops for this function as they\n  /// are computed.\n  DenseMap<const Loop *, BackedgeTakenInfo> BackedgeTakenCounts;\n\n  /// Cache the predicated backedge-taken count of the loops for this\n  /// function as they are computed.\n  DenseMap<const Loop *, BackedgeTakenInfo> PredicatedBackedgeTakenCounts;\n\n  /// This map contains entries for all of the PHI instructions that we\n  /// attempt to compute constant evolutions for.  This allows us to avoid\n  /// potentially expensive recomputation of these properties.  An instruction\n  /// maps to null if we are unable to compute its exit value.\n  DenseMap<PHINode *, Constant *> ConstantEvolutionLoopExitValue;\n\n  /// This map contains entries for all the expressions that we attempt to\n  /// compute getSCEVAtScope information for, which can be expensive in\n  /// extreme cases.\n  DenseMap<const SCEV *, SmallVector<std::pair<const Loop *, const SCEV *>, 2>>\n      ValuesAtScopes;\n\n  /// Memoized computeLoopDisposition results.\n  DenseMap<const SCEV *,\n           SmallVector<PointerIntPair<const Loop *, 2, LoopDisposition>, 2>>\n      LoopDispositions;\n\n  struct LoopProperties {\n    /// Set to true if the loop contains no instruction that can have side\n    /// effects (i.e. via throwing an exception, volatile or atomic access).\n    bool HasNoAbnormalExits;\n\n    /// Set to true if the loop contains no instruction that can abnormally exit\n    /// the loop (i.e. via throwing an exception, by terminating the thread\n    /// cleanly or by infinite looping in a called function).  Strictly\n    /// speaking, the last one is not leaving the loop, but is identical to\n    /// leaving the loop for reasoning about undefined behavior.\n    bool HasNoSideEffects;\n  };\n\n  /// Cache for \\c getLoopProperties.\n  DenseMap<const Loop *, LoopProperties> LoopPropertiesCache;\n\n  /// Return a \\c LoopProperties instance for \\p L, creating one if necessary.\n  LoopProperties getLoopProperties(const Loop *L);\n\n  bool loopHasNoSideEffects(const Loop *L) {\n    return getLoopProperties(L).HasNoSideEffects;\n  }\n\n  bool loopHasNoAbnormalExits(const Loop *L) {\n    return getLoopProperties(L).HasNoAbnormalExits;\n  }\n\n  /// Compute a LoopDisposition value.\n  LoopDisposition computeLoopDisposition(const SCEV *S, const Loop *L);\n\n  /// Memoized computeBlockDisposition results.\n  DenseMap<\n      const SCEV *,\n      SmallVector<PointerIntPair<const BasicBlock *, 2, BlockDisposition>, 2>>\n      BlockDispositions;\n\n  /// Compute a BlockDisposition value.\n  BlockDisposition computeBlockDisposition(const SCEV *S, const BasicBlock *BB);\n\n  /// Memoized results from getRange\n  DenseMap<const SCEV *, ConstantRange> UnsignedRanges;\n\n  /// Memoized results from getRange\n  DenseMap<const SCEV *, ConstantRange> SignedRanges;\n\n  /// Used to parameterize getRange\n  enum RangeSignHint { HINT_RANGE_UNSIGNED, HINT_RANGE_SIGNED };\n\n  /// Set the memoized range for the given SCEV.\n  const ConstantRange &setRange(const SCEV *S, RangeSignHint Hint,\n                                ConstantRange CR) {\n    DenseMap<const SCEV *, ConstantRange> &Cache =\n        Hint == HINT_RANGE_UNSIGNED ? UnsignedRanges : SignedRanges;\n\n    auto Pair = Cache.try_emplace(S, std::move(CR));\n    if (!Pair.second)\n      Pair.first->second = std::move(CR);\n    return Pair.first->second;\n  }\n\n  /// Determine the range for a particular SCEV.\n  /// NOTE: This returns a reference to an entry in a cache. It must be\n  /// copied if its needed for longer.\n  const ConstantRange &getRangeRef(const SCEV *S, RangeSignHint Hint);\n\n  /// Determines the range for the affine SCEVAddRecExpr {\\p Start,+,\\p Stop}.\n  /// Helper for \\c getRange.\n  ConstantRange getRangeForAffineAR(const SCEV *Start, const SCEV *Stop,\n                                    const SCEV *MaxBECount, unsigned BitWidth);\n\n  /// Determines the range for the affine non-self-wrapping SCEVAddRecExpr {\\p\n  /// Start,+,\\p Stop}<nw>.\n  ConstantRange getRangeForAffineNoSelfWrappingAR(const SCEVAddRecExpr *AddRec,\n                                                  const SCEV *MaxBECount,\n                                                  unsigned BitWidth,\n                                                  RangeSignHint SignHint);\n\n  /// Try to compute a range for the affine SCEVAddRecExpr {\\p Start,+,\\p\n  /// Stop} by \"factoring out\" a ternary expression from the add recurrence.\n  /// Helper called by \\c getRange.\n  ConstantRange getRangeViaFactoring(const SCEV *Start, const SCEV *Stop,\n                                     const SCEV *MaxBECount, unsigned BitWidth);\n\n  /// We know that there is no SCEV for the specified value.  Analyze the\n  /// expression.\n  const SCEV *createSCEV(Value *V);\n\n  /// Provide the special handling we need to analyze PHI SCEVs.\n  const SCEV *createNodeForPHI(PHINode *PN);\n\n  /// Helper function called from createNodeForPHI.\n  const SCEV *createAddRecFromPHI(PHINode *PN);\n\n  /// A helper function for createAddRecFromPHI to handle simple cases.\n  const SCEV *createSimpleAffineAddRec(PHINode *PN, Value *BEValueV,\n                                            Value *StartValueV);\n\n  /// Helper function called from createNodeForPHI.\n  const SCEV *createNodeFromSelectLikePHI(PHINode *PN);\n\n  /// Provide special handling for a select-like instruction (currently this\n  /// is either a select instruction or a phi node).  \\p I is the instruction\n  /// being processed, and it is assumed equivalent to \"Cond ? TrueVal :\n  /// FalseVal\".\n  const SCEV *createNodeForSelectOrPHI(Instruction *I, Value *Cond,\n                                       Value *TrueVal, Value *FalseVal);\n\n  /// Provide the special handling we need to analyze GEP SCEVs.\n  const SCEV *createNodeForGEP(GEPOperator *GEP);\n\n  /// Implementation code for getSCEVAtScope; called at most once for each\n  /// SCEV+Loop pair.\n  const SCEV *computeSCEVAtScope(const SCEV *S, const Loop *L);\n\n  /// This looks up computed SCEV values for all instructions that depend on\n  /// the given instruction and removes them from the ValueExprMap map if they\n  /// reference SymName. This is used during PHI resolution.\n  void forgetSymbolicName(Instruction *I, const SCEV *SymName);\n\n  /// Return the BackedgeTakenInfo for the given loop, lazily computing new\n  /// values if the loop hasn't been analyzed yet. The returned result is\n  /// guaranteed not to be predicated.\n  BackedgeTakenInfo &getBackedgeTakenInfo(const Loop *L);\n\n  /// Similar to getBackedgeTakenInfo, but will add predicates as required\n  /// with the purpose of returning complete information.\n  const BackedgeTakenInfo &getPredicatedBackedgeTakenInfo(const Loop *L);\n\n  /// Compute the number of times the specified loop will iterate.\n  /// If AllowPredicates is set, we will create new SCEV predicates as\n  /// necessary in order to return an exact answer.\n  BackedgeTakenInfo computeBackedgeTakenCount(const Loop *L,\n                                              bool AllowPredicates = false);\n\n  /// Compute the number of times the backedge of the specified loop will\n  /// execute if it exits via the specified block. If AllowPredicates is set,\n  /// this call will try to use a minimal set of SCEV predicates in order to\n  /// return an exact answer.\n  ExitLimit computeExitLimit(const Loop *L, BasicBlock *ExitingBlock,\n                             bool AllowPredicates = false);\n\n  /// Compute the number of times the backedge of the specified loop will\n  /// execute if its exit condition were a conditional branch of ExitCond.\n  ///\n  /// \\p ControlsExit is true if ExitCond directly controls the exit\n  /// branch. In this case, we can assume that the loop exits only if the\n  /// condition is true and can infer that failing to meet the condition prior\n  /// to integer wraparound results in undefined behavior.\n  ///\n  /// If \\p AllowPredicates is set, this call will try to use a minimal set of\n  /// SCEV predicates in order to return an exact answer.\n  ExitLimit computeExitLimitFromCond(const Loop *L, Value *ExitCond,\n                                     bool ExitIfTrue, bool ControlsExit,\n                                     bool AllowPredicates = false);\n\n  /// Return a symbolic upper bound for the backedge taken count of the loop.\n  /// This is more general than getConstantMaxBackedgeTakenCount as it returns\n  /// an arbitrary expression as opposed to only constants.\n  const SCEV *computeSymbolicMaxBackedgeTakenCount(const Loop *L);\n\n  // Helper functions for computeExitLimitFromCond to avoid exponential time\n  // complexity.\n\n  class ExitLimitCache {\n    // It may look like we need key on the whole (L, ExitIfTrue, ControlsExit,\n    // AllowPredicates) tuple, but recursive calls to\n    // computeExitLimitFromCondCached from computeExitLimitFromCondImpl only\n    // vary the in \\c ExitCond and \\c ControlsExit parameters.  We remember the\n    // initial values of the other values to assert our assumption.\n    SmallDenseMap<PointerIntPair<Value *, 1>, ExitLimit> TripCountMap;\n\n    const Loop *L;\n    bool ExitIfTrue;\n    bool AllowPredicates;\n\n  public:\n    ExitLimitCache(const Loop *L, bool ExitIfTrue, bool AllowPredicates)\n        : L(L), ExitIfTrue(ExitIfTrue), AllowPredicates(AllowPredicates) {}\n\n    Optional<ExitLimit> find(const Loop *L, Value *ExitCond, bool ExitIfTrue,\n                             bool ControlsExit, bool AllowPredicates);\n\n    void insert(const Loop *L, Value *ExitCond, bool ExitIfTrue,\n                bool ControlsExit, bool AllowPredicates, const ExitLimit &EL);\n  };\n\n  using ExitLimitCacheTy = ExitLimitCache;\n\n  ExitLimit computeExitLimitFromCondCached(ExitLimitCacheTy &Cache,\n                                           const Loop *L, Value *ExitCond,\n                                           bool ExitIfTrue,\n                                           bool ControlsExit,\n                                           bool AllowPredicates);\n  ExitLimit computeExitLimitFromCondImpl(ExitLimitCacheTy &Cache, const Loop *L,\n                                         Value *ExitCond, bool ExitIfTrue,\n                                         bool ControlsExit,\n                                         bool AllowPredicates);\n  Optional<ScalarEvolution::ExitLimit>\n  computeExitLimitFromCondFromBinOp(ExitLimitCacheTy &Cache, const Loop *L,\n                                    Value *ExitCond, bool ExitIfTrue,\n                                    bool ControlsExit, bool AllowPredicates);\n\n  /// Compute the number of times the backedge of the specified loop will\n  /// execute if its exit condition were a conditional branch of the ICmpInst\n  /// ExitCond and ExitIfTrue. If AllowPredicates is set, this call will try\n  /// to use a minimal set of SCEV predicates in order to return an exact\n  /// answer.\n  ExitLimit computeExitLimitFromICmp(const Loop *L, ICmpInst *ExitCond,\n                                     bool ExitIfTrue,\n                                     bool IsSubExpr,\n                                     bool AllowPredicates = false);\n\n  /// Compute the number of times the backedge of the specified loop will\n  /// execute if its exit condition were a switch with a single exiting case\n  /// to ExitingBB.\n  ExitLimit computeExitLimitFromSingleExitSwitch(const Loop *L,\n                                                 SwitchInst *Switch,\n                                                 BasicBlock *ExitingBB,\n                                                 bool IsSubExpr);\n\n  /// Given an exit condition of 'icmp op load X, cst', try to see if we can\n  /// compute the backedge-taken count.\n  ExitLimit computeLoadConstantCompareExitLimit(LoadInst *LI, Constant *RHS,\n                                                const Loop *L,\n                                                ICmpInst::Predicate p);\n\n  /// Compute the exit limit of a loop that is controlled by a\n  /// \"(IV >> 1) != 0\" type comparison.  We cannot compute the exact trip\n  /// count in these cases (since SCEV has no way of expressing them), but we\n  /// can still sometimes compute an upper bound.\n  ///\n  /// Return an ExitLimit for a loop whose backedge is guarded by `LHS Pred\n  /// RHS`.\n  ExitLimit computeShiftCompareExitLimit(Value *LHS, Value *RHS, const Loop *L,\n                                         ICmpInst::Predicate Pred);\n\n  /// If the loop is known to execute a constant number of times (the\n  /// condition evolves only from constants), try to evaluate a few iterations\n  /// of the loop until we get the exit condition gets a value of ExitWhen\n  /// (true or false).  If we cannot evaluate the exit count of the loop,\n  /// return CouldNotCompute.\n  const SCEV *computeExitCountExhaustively(const Loop *L, Value *Cond,\n                                           bool ExitWhen);\n\n  /// Return the number of times an exit condition comparing the specified\n  /// value to zero will execute.  If not computable, return CouldNotCompute.\n  /// If AllowPredicates is set, this call will try to use a minimal set of\n  /// SCEV predicates in order to return an exact answer.\n  ExitLimit howFarToZero(const SCEV *V, const Loop *L, bool IsSubExpr,\n                         bool AllowPredicates = false);\n\n  /// Return the number of times an exit condition checking the specified\n  /// value for nonzero will execute.  If not computable, return\n  /// CouldNotCompute.\n  ExitLimit howFarToNonZero(const SCEV *V, const Loop *L);\n\n  /// Return the number of times an exit condition containing the specified\n  /// less-than comparison will execute.  If not computable, return\n  /// CouldNotCompute.\n  ///\n  /// \\p isSigned specifies whether the less-than is signed.\n  ///\n  /// \\p ControlsExit is true when the LHS < RHS condition directly controls\n  /// the branch (loops exits only if condition is true). In this case, we can\n  /// use NoWrapFlags to skip overflow checks.\n  ///\n  /// If \\p AllowPredicates is set, this call will try to use a minimal set of\n  /// SCEV predicates in order to return an exact answer.\n  ExitLimit howManyLessThans(const SCEV *LHS, const SCEV *RHS, const Loop *L,\n                             bool isSigned, bool ControlsExit,\n                             bool AllowPredicates = false);\n\n  ExitLimit howManyGreaterThans(const SCEV *LHS, const SCEV *RHS, const Loop *L,\n                                bool isSigned, bool IsSubExpr,\n                                bool AllowPredicates = false);\n\n  /// Return a predecessor of BB (which may not be an immediate predecessor)\n  /// which has exactly one successor from which BB is reachable, or null if\n  /// no such block is found.\n  std::pair<const BasicBlock *, const BasicBlock *>\n  getPredecessorWithUniqueSuccessorForBB(const BasicBlock *BB) const;\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the given FoundCondValue value evaluates to true in given\n  /// Context. If Context is nullptr, then the found predicate is true\n  /// everywhere. LHS and FoundLHS may have different type width.\n  bool isImpliedCond(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS,\n                     const Value *FoundCondValue, bool Inverse,\n                     const Instruction *Context = nullptr);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the given FoundCondValue value evaluates to true in given\n  /// Context. If Context is nullptr, then the found predicate is true\n  /// everywhere. LHS and FoundLHS must have same type width.\n  bool isImpliedCondBalancedTypes(ICmpInst::Predicate Pred, const SCEV *LHS,\n                                  const SCEV *RHS,\n                                  ICmpInst::Predicate FoundPred,\n                                  const SCEV *FoundLHS, const SCEV *FoundRHS,\n                                  const Instruction *Context);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the condition described by FoundPred, FoundLHS, FoundRHS is\n  /// true in given Context. If Context is nullptr, then the found predicate is\n  /// true everywhere.\n  bool isImpliedCond(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS,\n                     ICmpInst::Predicate FoundPred, const SCEV *FoundLHS,\n                     const SCEV *FoundRHS,\n                     const Instruction *Context = nullptr);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is\n  /// true in given Context. If Context is nullptr, then the found predicate is\n  /// true everywhere.\n  bool isImpliedCondOperands(ICmpInst::Predicate Pred, const SCEV *LHS,\n                             const SCEV *RHS, const SCEV *FoundLHS,\n                             const SCEV *FoundRHS,\n                             const Instruction *Context = nullptr);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is\n  /// true. Here LHS is an operation that includes FoundLHS as one of its\n  /// arguments.\n  bool isImpliedViaOperations(ICmpInst::Predicate Pred,\n                              const SCEV *LHS, const SCEV *RHS,\n                              const SCEV *FoundLHS, const SCEV *FoundRHS,\n                              unsigned Depth = 0);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true.\n  /// Use only simple non-recursive types of checks, such as range analysis etc.\n  bool isKnownViaNonRecursiveReasoning(ICmpInst::Predicate Pred,\n                                       const SCEV *LHS, const SCEV *RHS);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is\n  /// true.\n  bool isImpliedCondOperandsHelper(ICmpInst::Predicate Pred, const SCEV *LHS,\n                                   const SCEV *RHS, const SCEV *FoundLHS,\n                                   const SCEV *FoundRHS);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is\n  /// true.  Utility function used by isImpliedCondOperands.  Tries to get\n  /// cases like \"X `sgt` 0 => X - 1 `sgt` -1\".\n  bool isImpliedCondOperandsViaRanges(ICmpInst::Predicate Pred, const SCEV *LHS,\n                                      const SCEV *RHS, const SCEV *FoundLHS,\n                                      const SCEV *FoundRHS);\n\n  /// Return true if the condition denoted by \\p LHS \\p Pred \\p RHS is implied\n  /// by a call to @llvm.experimental.guard in \\p BB.\n  bool isImpliedViaGuard(const BasicBlock *BB, ICmpInst::Predicate Pred,\n                         const SCEV *LHS, const SCEV *RHS);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is\n  /// true.\n  ///\n  /// This routine tries to rule out certain kinds of integer overflow, and\n  /// then tries to reason about arithmetic properties of the predicates.\n  bool isImpliedCondOperandsViaNoOverflow(ICmpInst::Predicate Pred,\n                                          const SCEV *LHS, const SCEV *RHS,\n                                          const SCEV *FoundLHS,\n                                          const SCEV *FoundRHS);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is\n  /// true.\n  ///\n  /// This routine tries to weaken the known condition basing on fact that\n  /// FoundLHS is an AddRec.\n  bool isImpliedCondOperandsViaAddRecStart(ICmpInst::Predicate Pred,\n                                           const SCEV *LHS, const SCEV *RHS,\n                                           const SCEV *FoundLHS,\n                                           const SCEV *FoundRHS,\n                                           const Instruction *Context);\n\n  /// Test whether the condition described by Pred, LHS, and RHS is true\n  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is\n  /// true.\n  ///\n  /// This routine tries to figure out predicate for Phis which are SCEVUnknown\n  /// if it is true for every possible incoming value from their respective\n  /// basic blocks.\n  bool isImpliedViaMerge(ICmpInst::Predicate Pred,\n                         const SCEV *LHS, const SCEV *RHS,\n                         const SCEV *FoundLHS, const SCEV *FoundRHS,\n                         unsigned Depth);\n\n  /// If we know that the specified Phi is in the header of its containing\n  /// loop, we know the loop executes a constant number of times, and the PHI\n  /// node is just a recurrence involving constants, fold it.\n  Constant *getConstantEvolutionLoopExitValue(PHINode *PN, const APInt &BEs,\n                                              const Loop *L);\n\n  /// Test if the given expression is known to satisfy the condition described\n  /// by Pred and the known constant ranges of LHS and RHS.\n  bool isKnownPredicateViaConstantRanges(ICmpInst::Predicate Pred,\n                                         const SCEV *LHS, const SCEV *RHS);\n\n  /// Try to prove the condition described by \"LHS Pred RHS\" by ruling out\n  /// integer overflow.\n  ///\n  /// For instance, this will return true for \"A s< (A + C)<nsw>\" if C is\n  /// positive.\n  bool isKnownPredicateViaNoOverflow(ICmpInst::Predicate Pred, const SCEV *LHS,\n                                     const SCEV *RHS);\n\n  /// Try to split Pred LHS RHS into logical conjunctions (and's) and try to\n  /// prove them individually.\n  bool isKnownPredicateViaSplitting(ICmpInst::Predicate Pred, const SCEV *LHS,\n                                    const SCEV *RHS);\n\n  /// Try to match the Expr as \"(L + R)<Flags>\".\n  bool splitBinaryAdd(const SCEV *Expr, const SCEV *&L, const SCEV *&R,\n                      SCEV::NoWrapFlags &Flags);\n\n  /// Drop memoized information computed for S.\n  void forgetMemoizedResults(const SCEV *S);\n\n  /// Return an existing SCEV for V if there is one, otherwise return nullptr.\n  const SCEV *getExistingSCEV(Value *V);\n\n  /// Return false iff given SCEV contains a SCEVUnknown with NULL value-\n  /// pointer.\n  bool checkValidity(const SCEV *S) const;\n\n  /// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be\n  /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}.  This is\n  /// equivalent to proving no signed (resp. unsigned) wrap in\n  /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`\n  /// (resp. `SCEVZeroExtendExpr`).\n  template <typename ExtendOpTy>\n  bool proveNoWrapByVaryingStart(const SCEV *Start, const SCEV *Step,\n                                 const Loop *L);\n\n  /// Try to prove NSW or NUW on \\p AR relying on ConstantRange manipulation.\n  SCEV::NoWrapFlags proveNoWrapViaConstantRanges(const SCEVAddRecExpr *AR);\n\n  /// Try to prove NSW on \\p AR by proving facts about conditions known  on\n  /// entry and backedge.\n  SCEV::NoWrapFlags proveNoSignedWrapViaInduction(const SCEVAddRecExpr *AR);\n\n  /// Try to prove NUW on \\p AR by proving facts about conditions known on\n  /// entry and backedge.\n  SCEV::NoWrapFlags proveNoUnsignedWrapViaInduction(const SCEVAddRecExpr *AR);\n\n  Optional<MonotonicPredicateType>\n  getMonotonicPredicateTypeImpl(const SCEVAddRecExpr *LHS,\n                                ICmpInst::Predicate Pred);\n\n  /// Return SCEV no-wrap flags that can be proven based on reasoning about\n  /// how poison produced from no-wrap flags on this value (e.g. a nuw add)\n  /// would trigger undefined behavior on overflow.\n  SCEV::NoWrapFlags getNoWrapFlagsFromUB(const Value *V);\n\n  /// Return true if the SCEV corresponding to \\p I is never poison.  Proving\n  /// this is more complex than proving that just \\p I is never poison, since\n  /// SCEV commons expressions across control flow, and you can have cases\n  /// like:\n  ///\n  ///   idx0 = a + b;\n  ///   ptr[idx0] = 100;\n  ///   if (<condition>) {\n  ///     idx1 = a +nsw b;\n  ///     ptr[idx1] = 200;\n  ///   }\n  ///\n  /// where the SCEV expression (+ a b) is guaranteed to not be poison (and\n  /// hence not sign-overflow) only if \"<condition>\" is true.  Since both\n  /// `idx0` and `idx1` will be mapped to the same SCEV expression, (+ a b),\n  /// it is not okay to annotate (+ a b) with <nsw> in the above example.\n  bool isSCEVExprNeverPoison(const Instruction *I);\n\n  /// This is like \\c isSCEVExprNeverPoison but it specifically works for\n  /// instructions that will get mapped to SCEV add recurrences.  Return true\n  /// if \\p I will never generate poison under the assumption that \\p I is an\n  /// add recurrence on the loop \\p L.\n  bool isAddRecNeverPoison(const Instruction *I, const Loop *L);\n\n  /// Similar to createAddRecFromPHI, but with the additional flexibility of\n  /// suggesting runtime overflow checks in case casts are encountered.\n  /// If successful, the analysis records that for this loop, \\p SymbolicPHI,\n  /// which is the UnknownSCEV currently representing the PHI, can be rewritten\n  /// into an AddRec, assuming some predicates; The function then returns the\n  /// AddRec and the predicates as a pair, and caches this pair in\n  /// PredicatedSCEVRewrites.\n  /// If the analysis is not successful, a mapping from the \\p SymbolicPHI to\n  /// itself (with no predicates) is recorded, and a nullptr with an empty\n  /// predicates vector is returned as a pair.\n  Optional<std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>>\n  createAddRecFromPHIWithCastsImpl(const SCEVUnknown *SymbolicPHI);\n\n  /// Compute the backedge taken count knowing the interval difference, the\n  /// stride and presence of the equality in the comparison.\n  const SCEV *computeBECount(const SCEV *Delta, const SCEV *Stride,\n                             bool Equality);\n\n  /// Compute the maximum backedge count based on the range of values\n  /// permitted by Start, End, and Stride. This is for loops of the form\n  /// {Start, +, Stride} LT End.\n  ///\n  /// Precondition: the induction variable is known to be positive.  We *don't*\n  /// assert these preconditions so please be careful.\n  const SCEV *computeMaxBECountForLT(const SCEV *Start, const SCEV *Stride,\n                                     const SCEV *End, unsigned BitWidth,\n                                     bool IsSigned);\n\n  /// Verify if an linear IV with positive stride can overflow when in a\n  /// less-than comparison, knowing the invariant term of the comparison,\n  /// the stride and the knowledge of NSW/NUW flags on the recurrence.\n  bool doesIVOverflowOnLT(const SCEV *RHS, const SCEV *Stride, bool IsSigned,\n                          bool NoWrap);\n\n  /// Verify if an linear IV with negative stride can overflow when in a\n  /// greater-than comparison, knowing the invariant term of the comparison,\n  /// the stride and the knowledge of NSW/NUW flags on the recurrence.\n  bool doesIVOverflowOnGT(const SCEV *RHS, const SCEV *Stride, bool IsSigned,\n                          bool NoWrap);\n\n  /// Get add expr already created or create a new one.\n  const SCEV *getOrCreateAddExpr(ArrayRef<const SCEV *> Ops,\n                                 SCEV::NoWrapFlags Flags);\n\n  /// Get mul expr already created or create a new one.\n  const SCEV *getOrCreateMulExpr(ArrayRef<const SCEV *> Ops,\n                                 SCEV::NoWrapFlags Flags);\n\n  // Get addrec expr already created or create a new one.\n  const SCEV *getOrCreateAddRecExpr(ArrayRef<const SCEV *> Ops,\n                                    const Loop *L, SCEV::NoWrapFlags Flags);\n\n  /// Return x if \\p Val is f(x) where f is a 1-1 function.\n  const SCEV *stripInjectiveFunctions(const SCEV *Val) const;\n\n  /// Find all of the loops transitively used in \\p S, and fill \\p LoopsUsed.\n  /// A loop is considered \"used\" by an expression if it contains\n  /// an add rec on said loop.\n  void getUsedLoops(const SCEV *S, SmallPtrSetImpl<const Loop *> &LoopsUsed);\n\n  /// Find all of the loops transitively used in \\p S, and update \\c LoopUsers\n  /// accordingly.\n  void addToLoopUseLists(const SCEV *S);\n\n  /// Try to match the pattern generated by getURemExpr(A, B). If successful,\n  /// Assign A and B to LHS and RHS, respectively.\n  bool matchURem(const SCEV *Expr, const SCEV *&LHS, const SCEV *&RHS);\n\n  /// Look for a SCEV expression with type `SCEVType` and operands `Ops` in\n  /// `UniqueSCEVs`.\n  ///\n  /// The first component of the returned tuple is the SCEV if found and null\n  /// otherwise.  The second component is the `FoldingSetNodeID` that was\n  /// constructed to look up the SCEV and the third component is the insertion\n  /// point.\n  std::tuple<SCEV *, FoldingSetNodeID, void *>\n  findExistingSCEVInCache(SCEVTypes SCEVType, ArrayRef<const SCEV *> Ops);\n\n  FoldingSet<SCEV> UniqueSCEVs;\n  FoldingSet<SCEVPredicate> UniquePreds;\n  BumpPtrAllocator SCEVAllocator;\n\n  /// This maps loops to a list of SCEV expressions that (transitively) use said\n  /// loop.\n  DenseMap<const Loop *, SmallVector<const SCEV *, 4>> LoopUsers;\n\n  /// Cache tentative mappings from UnknownSCEVs in a Loop, to a SCEV expression\n  /// they can be rewritten into under certain predicates.\n  DenseMap<std::pair<const SCEVUnknown *, const Loop *>,\n           std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>>\n      PredicatedSCEVRewrites;\n\n  /// The head of a linked list of all SCEVUnknown values that have been\n  /// allocated. This is used by releaseMemory to locate them all and call\n  /// their destructors.\n  SCEVUnknown *FirstUnknown = nullptr;\n};\n\n/// Analysis pass that exposes the \\c ScalarEvolution for a function.\nclass ScalarEvolutionAnalysis\n    : public AnalysisInfoMixin<ScalarEvolutionAnalysis> {\n  friend AnalysisInfoMixin<ScalarEvolutionAnalysis>;\n\n  static AnalysisKey Key;\n\npublic:\n  using Result = ScalarEvolution;\n\n  ScalarEvolution run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Verifier pass for the \\c ScalarEvolutionAnalysis results.\nclass ScalarEvolutionVerifierPass\n    : public PassInfoMixin<ScalarEvolutionVerifierPass> {\npublic:\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Printer pass for the \\c ScalarEvolutionAnalysis results.\nclass ScalarEvolutionPrinterPass\n    : public PassInfoMixin<ScalarEvolutionPrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit ScalarEvolutionPrinterPass(raw_ostream &OS) : OS(OS) {}\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\nclass ScalarEvolutionWrapperPass : public FunctionPass {\n  std::unique_ptr<ScalarEvolution> SE;\n\npublic:\n  static char ID;\n\n  ScalarEvolutionWrapperPass();\n\n  ScalarEvolution &getSE() { return *SE; }\n  const ScalarEvolution &getSE() const { return *SE; }\n\n  bool runOnFunction(Function &F) override;\n  void releaseMemory() override;\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n  void print(raw_ostream &OS, const Module * = nullptr) const override;\n  void verifyAnalysis() const override;\n};\n\n/// An interface layer with SCEV used to manage how we see SCEV expressions\n/// for values in the context of existing predicates. We can add new\n/// predicates, but we cannot remove them.\n///\n/// This layer has multiple purposes:\n///   - provides a simple interface for SCEV versioning.\n///   - guarantees that the order of transformations applied on a SCEV\n///     expression for a single Value is consistent across two different\n///     getSCEV calls. This means that, for example, once we've obtained\n///     an AddRec expression for a certain value through expression\n///     rewriting, we will continue to get an AddRec expression for that\n///     Value.\n///   - lowers the number of expression rewrites.\nclass PredicatedScalarEvolution {\npublic:\n  PredicatedScalarEvolution(ScalarEvolution &SE, Loop &L);\n\n  const SCEVUnionPredicate &getUnionPredicate() const;\n\n  /// Returns the SCEV expression of V, in the context of the current SCEV\n  /// predicate.  The order of transformations applied on the expression of V\n  /// returned by ScalarEvolution is guaranteed to be preserved, even when\n  /// adding new predicates.\n  const SCEV *getSCEV(Value *V);\n\n  /// Get the (predicated) backedge count for the analyzed loop.\n  const SCEV *getBackedgeTakenCount();\n\n  /// Adds a new predicate.\n  void addPredicate(const SCEVPredicate &Pred);\n\n  /// Attempts to produce an AddRecExpr for V by adding additional SCEV\n  /// predicates. If we can't transform the expression into an AddRecExpr we\n  /// return nullptr and not add additional SCEV predicates to the current\n  /// context.\n  const SCEVAddRecExpr *getAsAddRec(Value *V);\n\n  /// Proves that V doesn't overflow by adding SCEV predicate.\n  void setNoOverflow(Value *V, SCEVWrapPredicate::IncrementWrapFlags Flags);\n\n  /// Returns true if we've proved that V doesn't wrap by means of a SCEV\n  /// predicate.\n  bool hasNoOverflow(Value *V, SCEVWrapPredicate::IncrementWrapFlags Flags);\n\n  /// Returns the ScalarEvolution analysis used.\n  ScalarEvolution *getSE() const { return &SE; }\n\n  /// We need to explicitly define the copy constructor because of FlagsMap.\n  PredicatedScalarEvolution(const PredicatedScalarEvolution &);\n\n  /// Print the SCEV mappings done by the Predicated Scalar Evolution.\n  /// The printed text is indented by \\p Depth.\n  void print(raw_ostream &OS, unsigned Depth) const;\n\n  /// Check if \\p AR1 and \\p AR2 are equal, while taking into account\n  /// Equal predicates in Preds.\n  bool areAddRecsEqualWithPreds(const SCEVAddRecExpr *AR1,\n                                const SCEVAddRecExpr *AR2) const;\n\nprivate:\n  /// Increments the version number of the predicate.  This needs to be called\n  /// every time the SCEV predicate changes.\n  void updateGeneration();\n\n  /// Holds a SCEV and the version number of the SCEV predicate used to\n  /// perform the rewrite of the expression.\n  using RewriteEntry = std::pair<unsigned, const SCEV *>;\n\n  /// Maps a SCEV to the rewrite result of that SCEV at a certain version\n  /// number. If this number doesn't match the current Generation, we will\n  /// need to do a rewrite. To preserve the transformation order of previous\n  /// rewrites, we will rewrite the previous result instead of the original\n  /// SCEV.\n  DenseMap<const SCEV *, RewriteEntry> RewriteMap;\n\n  /// Records what NoWrap flags we've added to a Value *.\n  ValueMap<Value *, SCEVWrapPredicate::IncrementWrapFlags> FlagsMap;\n\n  /// The ScalarEvolution analysis.\n  ScalarEvolution &SE;\n\n  /// The analyzed Loop.\n  const Loop &L;\n\n  /// The SCEVPredicate that forms our context. We will rewrite all\n  /// expressions assuming that this predicate true.\n  SCEVUnionPredicate Preds;\n\n  /// Marks the version of the SCEV predicate used. When rewriting a SCEV\n  /// expression we mark it with the version of the predicate. We use this to\n  /// figure out if the predicate has changed from the last rewrite of the\n  /// SCEV. If so, we need to perform a new rewrite.\n  unsigned Generation = 0;\n\n  /// The backedge taken count.\n  const SCEV *BackedgeCount = nullptr;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ANALYSIS_SCALAREVOLUTION_H\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Dominators.h", "content": "//===- Dominators.h - Dominator Info Calculation ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DominatorTree class, which provides fast and efficient\n// dominance queries.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_DOMINATORS_H\n#define LLVM_IR_DOMINATORS_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/DepthFirstIterator.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/CFG.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/GenericDomTree.h\"\n#include <utility>\n\nnamespace llvm {\n\nclass Function;\nclass Instruction;\nclass Module;\nclass raw_ostream;\n\nextern template class DomTreeNodeBase<BasicBlock>;\nextern template class DominatorTreeBase<BasicBlock, false>; // DomTree\nextern template class DominatorTreeBase<BasicBlock, true>; // PostDomTree\n\nextern template class cfg::Update<BasicBlock *>;\n\nnamespace DomTreeBuilder {\nusing BBDomTree = DomTreeBase<BasicBlock>;\nusing BBPostDomTree = PostDomTreeBase<BasicBlock>;\n\nusing BBUpdates = ArrayRef<llvm::cfg::Update<BasicBlock *>>;\n\nusing BBDomTreeGraphDiff = GraphDiff<BasicBlock *, false>;\nusing BBPostDomTreeGraphDiff = GraphDiff<BasicBlock *, true>;\n\nextern template void Calculate<BBDomTree>(BBDomTree &DT);\nextern template void CalculateWithUpdates<BBDomTree>(BBDomTree &DT,\n                                                     BBUpdates U);\n\nextern template void Calculate<BBPostDomTree>(BBPostDomTree &DT);\n\nextern template void InsertEdge<BBDomTree>(BBDomTree &DT, BasicBlock *From,\n                                           BasicBlock *To);\nextern template void InsertEdge<BBPostDomTree>(BBPostDomTree &DT,\n                                               BasicBlock *From,\n                                               BasicBlock *To);\n\nextern template void DeleteEdge<BBDomTree>(BBDomTree &DT, BasicBlock *From,\n                                           BasicBlock *To);\nextern template void DeleteEdge<BBPostDomTree>(BBPostDomTree &DT,\n                                               BasicBlock *From,\n                                               BasicBlock *To);\n\nextern template void ApplyUpdates<BBDomTree>(BBDomTree &DT,\n                                             BBDomTreeGraphDiff &,\n                                             BBDomTreeGraphDiff *);\nextern template void ApplyUpdates<BBPostDomTree>(BBPostDomTree &DT,\n                                                 BBPostDomTreeGraphDiff &,\n                                                 BBPostDomTreeGraphDiff *);\n\nextern template bool Verify<BBDomTree>(const BBDomTree &DT,\n                                       BBDomTree::VerificationLevel VL);\nextern template bool Verify<BBPostDomTree>(const BBPostDomTree &DT,\n                                           BBPostDomTree::VerificationLevel VL);\n}  // namespace DomTreeBuilder\n\nusing DomTreeNode = DomTreeNodeBase<BasicBlock>;\n\nclass BasicBlockEdge {\n  const BasicBlock *Start;\n  const BasicBlock *End;\n\npublic:\n  BasicBlockEdge(const BasicBlock *Start_, const BasicBlock *End_) :\n    Start(Start_), End(End_) {}\n\n  BasicBlockEdge(const std::pair<BasicBlock *, BasicBlock *> &Pair)\n      : Start(Pair.first), End(Pair.second) {}\n\n  BasicBlockEdge(const std::pair<const BasicBlock *, const BasicBlock *> &Pair)\n      : Start(Pair.first), End(Pair.second) {}\n\n  const BasicBlock *getStart() const {\n    return Start;\n  }\n\n  const BasicBlock *getEnd() const {\n    return End;\n  }\n\n  /// Check if this is the only edge between Start and End.\n  bool isSingleEdge() const;\n};\n\ntemplate <> struct DenseMapInfo<BasicBlockEdge> {\n  using BBInfo = DenseMapInfo<const BasicBlock *>;\n\n  static unsigned getHashValue(const BasicBlockEdge *V);\n\n  static inline BasicBlockEdge getEmptyKey() {\n    return BasicBlockEdge(BBInfo::getEmptyKey(), BBInfo::getEmptyKey());\n  }\n\n  static inline BasicBlockEdge getTombstoneKey() {\n    return BasicBlockEdge(BBInfo::getTombstoneKey(), BBInfo::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const BasicBlockEdge &Edge) {\n    return hash_combine(BBInfo::getHashValue(Edge.getStart()),\n                        BBInfo::getHashValue(Edge.getEnd()));\n  }\n\n  static bool isEqual(const BasicBlockEdge &LHS, const BasicBlockEdge &RHS) {\n    return BBInfo::isEqual(LHS.getStart(), RHS.getStart()) &&\n           BBInfo::isEqual(LHS.getEnd(), RHS.getEnd());\n  }\n};\n\n/// Concrete subclass of DominatorTreeBase that is used to compute a\n/// normal dominator tree.\n///\n/// Definition: A block is said to be forward statically reachable if there is\n/// a path from the entry of the function to the block.  A statically reachable\n/// block may become statically unreachable during optimization.\n///\n/// A forward unreachable block may appear in the dominator tree, or it may\n/// not.  If it does, dominance queries will return results as if all reachable\n/// blocks dominate it.  When asking for a Node corresponding to a potentially\n/// unreachable block, calling code must handle the case where the block was\n/// unreachable and the result of getNode() is nullptr.\n///\n/// Generally, a block known to be unreachable when the dominator tree is\n/// constructed will not be in the tree.  One which becomes unreachable after\n/// the dominator tree is initially constructed may still exist in the tree,\n/// even if the tree is properly updated. Calling code should not rely on the\n/// preceding statements; this is stated only to assist human understanding.\nclass DominatorTree : public DominatorTreeBase<BasicBlock, false> {\n public:\n  using Base = DominatorTreeBase<BasicBlock, false>;\n\n  DominatorTree() = default;\n  explicit DominatorTree(Function &F) { recalculate(F); }\n  explicit DominatorTree(DominatorTree &DT, DomTreeBuilder::BBUpdates U) {\n    recalculate(*DT.Parent, U);\n  }\n\n  /// Handle invalidation explicitly.\n  bool invalidate(Function &F, const PreservedAnalyses &PA,\n                  FunctionAnalysisManager::Invalidator &);\n\n  // Ensure base-class overloads are visible.\n  using Base::dominates;\n\n  /// Return true if the (end of the) basic block BB dominates the use U.\n  bool dominates(const BasicBlock *BB, const Use &U) const;\n\n  /// Return true if value Def dominates use U, in the sense that Def is\n  /// available at U, and could be substituted as the used value without\n  /// violating the SSA dominance requirement.\n  ///\n  /// In particular, it is worth noting that:\n  ///  * Non-instruction Defs dominate everything.\n  ///  * Def does not dominate a use in Def itself (outside of degenerate cases\n  ///    like unreachable code or trivial phi cycles).\n  ///  * Invoke/callbr Defs only dominate uses in their default destination.\n  bool dominates(const Value *Def, const Use &U) const;\n  /// Return true if value Def dominates all possible uses inside instruction\n  /// User. Same comments as for the Use-based API apply.\n  bool dominates(const Value *Def, const Instruction *User) const;\n  // Does not accept Value to avoid ambiguity with dominance checks between\n  // two basic blocks.\n  bool dominates(const Instruction *Def, const BasicBlock *BB) const;\n\n  /// Return true if an edge dominates a use.\n  ///\n  /// If BBE is not a unique edge between start and end of the edge, it can\n  /// never dominate the use.\n  bool dominates(const BasicBlockEdge &BBE, const Use &U) const;\n  bool dominates(const BasicBlockEdge &BBE, const BasicBlock *BB) const;\n  /// Returns true if edge \\p BBE1 dominates edge \\p BBE2.\n  bool dominates(const BasicBlockEdge &BBE1, const BasicBlockEdge &BBE2) const;\n\n  // Ensure base class overloads are visible.\n  using Base::isReachableFromEntry;\n\n  /// Provide an overload for a Use.\n  bool isReachableFromEntry(const Use &U) const;\n\n  // Pop up a GraphViz/gv window with the Dominator Tree rendered using `dot`.\n  void viewGraph(const Twine &Name, const Twine &Title);\n  void viewGraph();\n};\n\n//===-------------------------------------\n// DominatorTree GraphTraits specializations so the DominatorTree can be\n// iterable by generic graph iterators.\n\ntemplate <class Node, class ChildIterator> struct DomTreeGraphTraitsBase {\n  using NodeRef = Node *;\n  using ChildIteratorType = ChildIterator;\n  using nodes_iterator = df_iterator<Node *, df_iterator_default_set<Node*>>;\n\n  static NodeRef getEntryNode(NodeRef N) { return N; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->end(); }\n\n  static nodes_iterator nodes_begin(NodeRef N) {\n    return df_begin(getEntryNode(N));\n  }\n\n  static nodes_iterator nodes_end(NodeRef N) { return df_end(getEntryNode(N)); }\n};\n\ntemplate <>\nstruct GraphTraits<DomTreeNode *>\n    : public DomTreeGraphTraitsBase<DomTreeNode, DomTreeNode::const_iterator> {\n};\n\ntemplate <>\nstruct GraphTraits<const DomTreeNode *>\n    : public DomTreeGraphTraitsBase<const DomTreeNode,\n                                    DomTreeNode::const_iterator> {};\n\ntemplate <> struct GraphTraits<DominatorTree*>\n  : public GraphTraits<DomTreeNode*> {\n  static NodeRef getEntryNode(DominatorTree *DT) { return DT->getRootNode(); }\n\n  static nodes_iterator nodes_begin(DominatorTree *N) {\n    return df_begin(getEntryNode(N));\n  }\n\n  static nodes_iterator nodes_end(DominatorTree *N) {\n    return df_end(getEntryNode(N));\n  }\n};\n\n/// Analysis pass which computes a \\c DominatorTree.\nclass DominatorTreeAnalysis : public AnalysisInfoMixin<DominatorTreeAnalysis> {\n  friend AnalysisInfoMixin<DominatorTreeAnalysis>;\n  static AnalysisKey Key;\n\npublic:\n  /// Provide the result typedef for this analysis pass.\n  using Result = DominatorTree;\n\n  /// Run the analysis pass over a function and produce a dominator tree.\n  DominatorTree run(Function &F, FunctionAnalysisManager &);\n};\n\n/// Printer pass for the \\c DominatorTree.\nclass DominatorTreePrinterPass\n    : public PassInfoMixin<DominatorTreePrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit DominatorTreePrinterPass(raw_ostream &OS);\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Verifier pass for the \\c DominatorTree.\nstruct DominatorTreeVerifierPass : PassInfoMixin<DominatorTreeVerifierPass> {\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Legacy analysis pass which computes a \\c DominatorTree.\nclass DominatorTreeWrapperPass : public FunctionPass {\n  DominatorTree DT;\n\npublic:\n  static char ID;\n\n  DominatorTreeWrapperPass();\n\n  DominatorTree &getDomTree() { return DT; }\n  const DominatorTree &getDomTree() const { return DT; }\n\n  bool runOnFunction(Function &F) override;\n\n  void verifyAnalysis() const override;\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override {\n    AU.setPreservesAll();\n  }\n\n  void releaseMemory() override { DT.reset(); }\n\n  void print(raw_ostream &OS, const Module *M = nullptr) const override;\n};\n} // end namespace llvm\n\n#endif // LLVM_IR_DOMINATORS_H\n"}, "60": {"id": 60, "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "content": "//===- llvm/unittest/Analysis/LoopPassManagerTest.cpp - LPM tests ---------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/Transforms/Scalar/LoopPassManager.h\"\n#include \"llvm/Analysis/AliasAnalysis.h\"\n#include \"llvm/Analysis/AssumptionCache.h\"\n#include \"llvm/Analysis/BlockFrequencyInfo.h\"\n#include \"llvm/Analysis/BranchProbabilityInfo.h\"\n#include \"llvm/Analysis/MemorySSA.h\"\n#include \"llvm/Analysis/PostDominators.h\"\n#include \"llvm/Analysis/ScalarEvolution.h\"\n#include \"llvm/Analysis/TargetLibraryInfo.h\"\n#include \"llvm/Analysis/TargetTransformInfo.h\"\n#include \"llvm/AsmParser/Parser.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Support/SourceMgr.h\"\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nusing namespace llvm;\n\nnamespace {\n\nusing testing::DoDefault;\nusing testing::Return;\nusing testing::Expectation;\nusing testing::Invoke;\nusing testing::InvokeWithoutArgs;\nusing testing::_;\n\ntemplate <typename DerivedT, typename IRUnitT,\n          typename AnalysisManagerT = AnalysisManager<IRUnitT>,\n          typename... ExtraArgTs>\nclass MockAnalysisHandleBase {\npublic:\n  class Analysis : public AnalysisInfoMixin<Analysis> {\n    friend AnalysisInfoMixin<Analysis>;\n    friend MockAnalysisHandleBase;\n    static AnalysisKey Key;\n\n    DerivedT *Handle;\n\n    Analysis(DerivedT &Handle) : Handle(&Handle) {\n      static_assert(std::is_base_of<MockAnalysisHandleBase, DerivedT>::value,\n                    \"Must pass the derived type to this template!\");\n    }\n\n  public:\n    class Result {\n      friend MockAnalysisHandleBase;\n\n      DerivedT *Handle;\n\n      Result(DerivedT &Handle) : Handle(&Handle) {}\n\n    public:\n      // Forward invalidation events to the mock handle.\n      bool invalidate(IRUnitT &IR, const PreservedAnalyses &PA,\n                      typename AnalysisManagerT::Invalidator &Inv) {\n        return Handle->invalidate(IR, PA, Inv);\n      }\n    };\n\n    Result run(IRUnitT &IR, AnalysisManagerT &AM, ExtraArgTs... ExtraArgs) {\n      return Handle->run(IR, AM, ExtraArgs...);\n    }\n  };\n\n  Analysis getAnalysis() { return Analysis(static_cast<DerivedT &>(*this)); }\n  typename Analysis::Result getResult() {\n    return typename Analysis::Result(static_cast<DerivedT &>(*this));\n  }\n\nprotected:\n  // FIXME: MSVC seems unable to handle a lambda argument to Invoke from within\n  // the template, so we use a boring static function.\n  static bool invalidateCallback(IRUnitT &IR, const PreservedAnalyses &PA,\n                                 typename AnalysisManagerT::Invalidator &Inv) {\n    auto PAC = PA.template getChecker<Analysis>();\n    return !PAC.preserved() &&\n           !PAC.template preservedSet<AllAnalysesOn<IRUnitT>>();\n  }\n\n  /// Derived classes should call this in their constructor to set up default\n  /// mock actions. (We can't do this in our constructor because this has to\n  /// run after the DerivedT is constructed.)\n  void setDefaults() {\n    ON_CALL(static_cast<DerivedT &>(*this),\n            run(_, _, testing::Matcher<ExtraArgTs>(_)...))\n        .WillByDefault(Return(this->getResult()));\n    ON_CALL(static_cast<DerivedT &>(*this), invalidate(_, _, _))\n        .WillByDefault(Invoke(&invalidateCallback));\n  }\n};\n\ntemplate <typename DerivedT, typename IRUnitT, typename AnalysisManagerT,\n          typename... ExtraArgTs>\nAnalysisKey MockAnalysisHandleBase<DerivedT, IRUnitT, AnalysisManagerT,\n                                   ExtraArgTs...>::Analysis::Key;\n\n/// Mock handle for loop analyses.\n///\n/// This is provided as a template accepting an (optional) integer. Because\n/// analyses are identified and queried by type, this allows constructing\n/// multiple handles with distinctly typed nested 'Analysis' types that can be\n/// registered and queried. If you want to register multiple loop analysis\n/// passes, you'll need to instantiate this type with different values for I.\n/// For example:\n///\n///   MockLoopAnalysisHandleTemplate<0> h0;\n///   MockLoopAnalysisHandleTemplate<1> h1;\n///   typedef decltype(h0)::Analysis Analysis0;\n///   typedef decltype(h1)::Analysis Analysis1;\ntemplate <size_t I = static_cast<size_t>(-1)>\nstruct MockLoopAnalysisHandleTemplate\n    : MockAnalysisHandleBase<MockLoopAnalysisHandleTemplate<I>, Loop,\n                             LoopAnalysisManager,\n                             LoopStandardAnalysisResults &> {\n  typedef typename MockLoopAnalysisHandleTemplate::Analysis Analysis;\n\n  MOCK_METHOD3_T(run, typename Analysis::Result(Loop &, LoopAnalysisManager &,\n                                                LoopStandardAnalysisResults &));\n\n  MOCK_METHOD3_T(invalidate, bool(Loop &, const PreservedAnalyses &,\n                                  LoopAnalysisManager::Invalidator &));\n\n  MockLoopAnalysisHandleTemplate() { this->setDefaults(); }\n};\n\ntypedef MockLoopAnalysisHandleTemplate<> MockLoopAnalysisHandle;\n\nstruct MockFunctionAnalysisHandle\n    : MockAnalysisHandleBase<MockFunctionAnalysisHandle, Function> {\n  MOCK_METHOD2(run, Analysis::Result(Function &, FunctionAnalysisManager &));\n\n  MOCK_METHOD3(invalidate, bool(Function &, const PreservedAnalyses &,\n                                FunctionAnalysisManager::Invalidator &));\n\n  MockFunctionAnalysisHandle() { setDefaults(); }\n};\n\ntemplate <typename DerivedT, typename IRUnitT,\n          typename AnalysisManagerT = AnalysisManager<IRUnitT>,\n          typename... ExtraArgTs>\nclass MockPassHandleBase {\npublic:\n  class Pass : public PassInfoMixin<Pass> {\n    friend MockPassHandleBase;\n\n    DerivedT *Handle;\n\n    Pass(DerivedT &Handle) : Handle(&Handle) {\n      static_assert(std::is_base_of<MockPassHandleBase, DerivedT>::value,\n                    \"Must pass the derived type to this template!\");\n    }\n\n  public:\n    PreservedAnalyses run(IRUnitT &IR, AnalysisManagerT &AM,\n                          ExtraArgTs... ExtraArgs) {\n      return Handle->run(IR, AM, ExtraArgs...);\n    }\n  };\n\n  Pass getPass() { return Pass(static_cast<DerivedT &>(*this)); }\n\nprotected:\n  /// Derived classes should call this in their constructor to set up default\n  /// mock actions. (We can't do this in our constructor because this has to\n  /// run after the DerivedT is constructed.)\n  void setDefaults() {\n    ON_CALL(static_cast<DerivedT &>(*this),\n            run(_, _, testing::Matcher<ExtraArgTs>(_)...))\n        .WillByDefault(Return(PreservedAnalyses::all()));\n  }\n};\n\nstruct MockLoopPassHandle\n    : MockPassHandleBase<MockLoopPassHandle, Loop, LoopAnalysisManager,\n                         LoopStandardAnalysisResults &, LPMUpdater &> {\n  MOCK_METHOD4(run,\n               PreservedAnalyses(Loop &, LoopAnalysisManager &,\n                                 LoopStandardAnalysisResults &, LPMUpdater &));\n  MockLoopPassHandle() { setDefaults(); }\n};\n\nstruct MockLoopNestPassHandle\n    : MockPassHandleBase<MockLoopNestPassHandle, LoopNest, LoopAnalysisManager,\n                         LoopStandardAnalysisResults &, LPMUpdater &> {\n  MOCK_METHOD4(run,\n               PreservedAnalyses(LoopNest &, LoopAnalysisManager &,\n                                 LoopStandardAnalysisResults &, LPMUpdater &));\n\n  MockLoopNestPassHandle() { setDefaults(); }\n};\n\nstruct MockFunctionPassHandle\n    : MockPassHandleBase<MockFunctionPassHandle, Function> {\n  MOCK_METHOD2(run, PreservedAnalyses(Function &, FunctionAnalysisManager &));\n\n  MockFunctionPassHandle() { setDefaults(); }\n};\n\nstruct MockModulePassHandle : MockPassHandleBase<MockModulePassHandle, Module> {\n  MOCK_METHOD2(run, PreservedAnalyses(Module &, ModuleAnalysisManager &));\n\n  MockModulePassHandle() { setDefaults(); }\n};\n\n/// Define a custom matcher for objects which support a 'getName' method\n/// returning a StringRef.\n///\n/// LLVM often has IR objects or analysis objects which expose a StringRef name\n/// and in tests it is convenient to match these by name for readability. This\n/// matcher supports any type exposing a getName() method of this form.\n///\n/// It should be used as:\n///\n///   HasName(\"my_function\")\n///\n/// No namespace or other qualification is required.\nMATCHER_P(HasName, Name, \"\") {\n  // The matcher's name and argument are printed in the case of failure, but we\n  // also want to print out the name of the argument. This uses an implicitly\n  // avaiable std::ostream, so we have to construct a std::string.\n  *result_listener << \"has name '\" << arg.getName().str() << \"'\";\n  return Name == arg.getName();\n}\n\nstd::unique_ptr<Module> parseIR(LLVMContext &C, const char *IR) {\n  SMDiagnostic Err;\n  return parseAssemblyString(IR, Err, C);\n}\n\nclass LoopPassManagerTest : public ::testing::Test {\nprotected:\n  LLVMContext Context;\n  std::unique_ptr<Module> M;\n\n  LoopAnalysisManager LAM;\n  FunctionAnalysisManager FAM;\n  ModuleAnalysisManager MAM;\n\n  MockLoopAnalysisHandle MLAHandle;\n  MockLoopPassHandle MLPHandle;\n  MockLoopNestPassHandle MLNPHandle;\n  MockFunctionPassHandle MFPHandle;\n  MockModulePassHandle MMPHandle;\n\n  static PreservedAnalyses\n  getLoopAnalysisResult(Loop &L, LoopAnalysisManager &AM,\n                        LoopStandardAnalysisResults &AR, LPMUpdater &) {\n    (void)AM.getResult<MockLoopAnalysisHandle::Analysis>(L, AR);\n    return PreservedAnalyses::all();\n  };\n\npublic:\n  LoopPassManagerTest()\n      : M(parseIR(Context,\n                  \"define void @f(i1* %ptr) {\\n\"\n                  \"entry:\\n\"\n                  \"  br label %loop.0\\n\"\n                  \"loop.0:\\n\"\n                  \"  %cond.0 = load volatile i1, i1* %ptr\\n\"\n                  \"  br i1 %cond.0, label %loop.0.0.ph, label %end\\n\"\n                  \"loop.0.0.ph:\\n\"\n                  \"  br label %loop.0.0\\n\"\n                  \"loop.0.0:\\n\"\n                  \"  %cond.0.0 = load volatile i1, i1* %ptr\\n\"\n                  \"  br i1 %cond.0.0, label %loop.0.0, label %loop.0.1.ph\\n\"\n                  \"loop.0.1.ph:\\n\"\n                  \"  br label %loop.0.1\\n\"\n                  \"loop.0.1:\\n\"\n                  \"  %cond.0.1 = load volatile i1, i1* %ptr\\n\"\n                  \"  br i1 %cond.0.1, label %loop.0.1, label %loop.0.latch\\n\"\n                  \"loop.0.latch:\\n\"\n                  \"  br label %loop.0\\n\"\n                  \"end:\\n\"\n                  \"  ret void\\n\"\n                  \"}\\n\"\n                  \"\\n\"\n                  \"define void @g(i1* %ptr) {\\n\"\n                  \"entry:\\n\"\n                  \"  br label %loop.g.0\\n\"\n                  \"loop.g.0:\\n\"\n                  \"  %cond.0 = load volatile i1, i1* %ptr\\n\"\n                  \"  br i1 %cond.0, label %loop.g.0, label %end\\n\"\n                  \"end:\\n\"\n                  \"  ret void\\n\"\n                  \"}\\n\")),\n        LAM(true), FAM(true), MAM(true) {\n    // Register our mock analysis.\n    LAM.registerPass([&] { return MLAHandle.getAnalysis(); });\n\n    // We need DominatorTreeAnalysis for LoopAnalysis.\n    FAM.registerPass([&] { return DominatorTreeAnalysis(); });\n    FAM.registerPass([&] { return LoopAnalysis(); });\n    // We also allow loop passes to assume a set of other analyses and so need\n    // those.\n    FAM.registerPass([&] { return AAManager(); });\n    FAM.registerPass([&] { return AssumptionAnalysis(); });\n    FAM.registerPass([&] { return BlockFrequencyAnalysis(); });\n    FAM.registerPass([&] { return BranchProbabilityAnalysis(); });\n    FAM.registerPass([&] { return PostDominatorTreeAnalysis(); });\n    FAM.registerPass([&] { return MemorySSAAnalysis(); });\n    FAM.registerPass([&] { return ScalarEvolutionAnalysis(); });\n    FAM.registerPass([&] { return TargetLibraryAnalysis(); });\n    FAM.registerPass([&] { return TargetIRAnalysis(); });\n\n    // Register required pass instrumentation analysis.\n    LAM.registerPass([&] { return PassInstrumentationAnalysis(); });\n    FAM.registerPass([&] { return PassInstrumentationAnalysis(); });\n    MAM.registerPass([&] { return PassInstrumentationAnalysis(); });\n\n    // Cross-register proxies.\n    LAM.registerPass([&] { return FunctionAnalysisManagerLoopProxy(FAM); });\n    FAM.registerPass([&] { return LoopAnalysisManagerFunctionProxy(LAM); });\n    FAM.registerPass([&] { return ModuleAnalysisManagerFunctionProxy(MAM); });\n    MAM.registerPass([&] { return FunctionAnalysisManagerModuleProxy(FAM); });\n  }\n};\n\nTEST_F(LoopPassManagerTest, Basic) {\n  ModulePassManager MPM(true);\n  ::testing::InSequence MakeExpectationsSequenced;\n\n  // First we just visit all the loops in all the functions and get their\n  // analysis results. This will run the analysis a total of four times,\n  // once for each loop.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.0\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.g.0\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.g.0\"), _, _));\n  // Wire the loop pass through pass managers into the module pipeline.\n  {\n    LoopPassManager LPM(true);\n    LPM.addPass(MLPHandle.getPass());\n    FunctionPassManager FPM(true);\n    FPM.addPass(createFunctionToLoopPassAdaptor(std::move(LPM)));\n    MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n  }\n\n  // Next we run two passes over the loops. The first one invalidates the\n  // analyses for one loop, the second ones try to get the analysis results.\n  // This should force only one analysis to re-run within the loop PM, but will\n  // also invalidate everything after the loop pass manager finishes.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.0\"), _, _, _))\n      .WillOnce(DoDefault())\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1\"), _, _, _))\n      .WillOnce(InvokeWithoutArgs([] { return PreservedAnalyses::none(); }))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .WillOnce(DoDefault())\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.g.0\"), _, _, _))\n      .WillOnce(DoDefault())\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  // Wire two loop pass runs into the module pipeline.\n  {\n    LoopPassManager LPM(true);\n    LPM.addPass(MLPHandle.getPass());\n    LPM.addPass(MLPHandle.getPass());\n    FunctionPassManager FPM(true);\n    FPM.addPass(createFunctionToLoopPassAdaptor(std::move(LPM)));\n    MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n  }\n\n  // And now run the pipeline across the module.\n  MPM.run(*M, MAM);\n}\n\nTEST_F(LoopPassManagerTest, FunctionPassInvalidationOfLoopAnalyses) {\n  ModulePassManager MPM(true);\n  FunctionPassManager FPM(true);\n  // We process each function completely in sequence.\n  ::testing::Sequence FSequence, GSequence;\n\n  // First, force the analysis result to be computed for each loop.\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _))\n      .InSequence(FSequence)\n      .WillOnce(DoDefault());\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _))\n      .InSequence(FSequence)\n      .WillOnce(DoDefault());\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _))\n      .InSequence(FSequence)\n      .WillOnce(DoDefault());\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.g.0\"), _, _))\n      .InSequence(GSequence)\n      .WillOnce(DoDefault());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>()));\n\n  // No need to re-run if we require again from a fresh loop pass manager.\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>()));\n  // For 'f', preserve most things but not the specific loop analyses.\n  auto PA = getLoopPassPreservedAnalyses();\n  if (EnableMSSALoopDependency)\n    PA.preserve<MemorySSAAnalysis>();\n  EXPECT_CALL(MFPHandle, run(HasName(\"f\"), _))\n      .InSequence(FSequence)\n      .WillOnce(Return(PA));\n  EXPECT_CALL(MLAHandle, invalidate(HasName(\"loop.0.0\"), _, _))\n      .InSequence(FSequence)\n      .WillOnce(DoDefault());\n  // On one loop, skip the invalidation (as though we did an internal update).\n  EXPECT_CALL(MLAHandle, invalidate(HasName(\"loop.0.1\"), _, _))\n      .InSequence(FSequence)\n      .WillOnce(Return(false));\n  EXPECT_CALL(MLAHandle, invalidate(HasName(\"loop.0\"), _, _))\n      .InSequence(FSequence)\n      .WillOnce(DoDefault());\n  // Now two loops still have to be recomputed.\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _))\n      .InSequence(FSequence)\n      .WillOnce(DoDefault());\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _))\n      .InSequence(FSequence)\n      .WillOnce(DoDefault());\n  // Preserve things in the second function to ensure invalidation remains\n  // isolated to one function.\n  EXPECT_CALL(MFPHandle, run(HasName(\"g\"), _))\n      .InSequence(GSequence)\n      .WillOnce(DoDefault());\n  FPM.addPass(MFPHandle.getPass());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>()));\n\n  EXPECT_CALL(MFPHandle, run(HasName(\"f\"), _))\n      .InSequence(FSequence)\n      .WillOnce(DoDefault());\n  // For 'g', fail to preserve anything, causing the loops themselves to be\n  // cleared. We don't get an invalidation event here as the loop is gone, but\n  // we should still have to recompute the analysis.\n  EXPECT_CALL(MFPHandle, run(HasName(\"g\"), _))\n      .InSequence(GSequence)\n      .WillOnce(Return(PreservedAnalyses::none()));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.g.0\"), _, _))\n      .InSequence(GSequence)\n      .WillOnce(DoDefault());\n  FPM.addPass(MFPHandle.getPass());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>()));\n\n  MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n\n  // Verify with a separate function pass run that we didn't mess up 'f's\n  // cache. No analysis runs should be necessary here.\n  MPM.addPass(createModuleToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>())));\n\n  MPM.run(*M, MAM);\n}\n\nTEST_F(LoopPassManagerTest, ModulePassInvalidationOfLoopAnalyses) {\n  ModulePassManager MPM(true);\n  ::testing::InSequence MakeExpectationsSequenced;\n\n  // First, force the analysis result to be computed for each loop.\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.g.0\"), _, _));\n  MPM.addPass(createModuleToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>())));\n\n  // Walking all the way out and all the way back in doesn't re-run the\n  // analysis.\n  MPM.addPass(createModuleToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>())));\n\n  // But a module pass that doesn't preserve the actual mock loop analysis\n  // invalidates all the way down and forces recomputing.\n  EXPECT_CALL(MMPHandle, run(_, _)).WillOnce(InvokeWithoutArgs([] {\n    auto PA = getLoopPassPreservedAnalyses();\n    PA.preserve<FunctionAnalysisManagerModuleProxy>();\n    if (EnableMSSALoopDependency)\n      PA.preserve<MemorySSAAnalysis>();\n    return PA;\n  }));\n  // All the loop analyses from both functions get invalidated before we\n  // recompute anything.\n  EXPECT_CALL(MLAHandle, invalidate(HasName(\"loop.0.0\"), _, _));\n  // On one loop, again skip the invalidation (as though we did an internal\n  // update).\n  EXPECT_CALL(MLAHandle, invalidate(HasName(\"loop.0.1\"), _, _))\n      .WillOnce(Return(false));\n  EXPECT_CALL(MLAHandle, invalidate(HasName(\"loop.0\"), _, _));\n  EXPECT_CALL(MLAHandle, invalidate(HasName(\"loop.g.0\"), _, _));\n  // Now all but one of the loops gets re-analyzed.\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.g.0\"), _, _));\n  MPM.addPass(MMPHandle.getPass());\n  MPM.addPass(createModuleToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>())));\n\n  // Verify that the cached values persist.\n  MPM.addPass(createModuleToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>())));\n\n  // Now we fail to preserve the loop analysis and observe that the loop\n  // analyses are cleared (so no invalidation event) as the loops themselves\n  // are no longer valid.\n  EXPECT_CALL(MMPHandle, run(_, _)).WillOnce(InvokeWithoutArgs([] {\n    auto PA = PreservedAnalyses::none();\n    PA.preserve<FunctionAnalysisManagerModuleProxy>();\n    return PA;\n  }));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.g.0\"), _, _));\n  MPM.addPass(MMPHandle.getPass());\n  MPM.addPass(createModuleToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>())));\n\n  // Verify that the cached values persist.\n  MPM.addPass(createModuleToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>())));\n\n  // Next, check that even if we preserve everything within the function itelf,\n  // if the function's module pass proxy isn't preserved and the potential set\n  // of functions changes, the clear reaches the loop analyses as well. This\n  // will again trigger re-runs but not invalidation events.\n  EXPECT_CALL(MMPHandle, run(_, _)).WillOnce(InvokeWithoutArgs([] {\n    auto PA = PreservedAnalyses::none();\n    PA.preserveSet<AllAnalysesOn<Function>>();\n    PA.preserveSet<AllAnalysesOn<Loop>>();\n    return PA;\n  }));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.g.0\"), _, _));\n  MPM.addPass(MMPHandle.getPass());\n  MPM.addPass(createModuleToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>())));\n\n  MPM.run(*M, MAM);\n}\n\n// Test that if any of the bundled analyses provided in the LPM's signature\n// become invalid, the analysis proxy itself becomes invalid and we clear all\n// loop analysis results.\nTEST_F(LoopPassManagerTest, InvalidationOfBundledAnalyses) {\n  ModulePassManager MPM(true);\n  FunctionPassManager FPM(true);\n  ::testing::InSequence MakeExpectationsSequenced;\n\n  // First, force the analysis result to be computed for each loop.\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>()));\n\n  // No need to re-run if we require again from a fresh loop pass manager.\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>()));\n\n  // Preserving everything but the loop analyses themselves results in\n  // invalidation and running.\n  EXPECT_CALL(MFPHandle, run(HasName(\"f\"), _))\n      .WillOnce(Return(getLoopPassPreservedAnalyses()));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n  FPM.addPass(MFPHandle.getPass());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>()));\n\n  // The rest don't invalidate analyses, they only trigger re-runs because we\n  // clear the cache completely.\n  EXPECT_CALL(MFPHandle, run(HasName(\"f\"), _)).WillOnce(InvokeWithoutArgs([] {\n    auto PA = PreservedAnalyses::none();\n    // Not preserving `AAManager`.\n    PA.preserve<DominatorTreeAnalysis>();\n    PA.preserve<LoopAnalysis>();\n    PA.preserve<LoopAnalysisManagerFunctionProxy>();\n    PA.preserve<ScalarEvolutionAnalysis>();\n    return PA;\n  }));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n  FPM.addPass(MFPHandle.getPass());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>()));\n\n  EXPECT_CALL(MFPHandle, run(HasName(\"f\"), _)).WillOnce(InvokeWithoutArgs([] {\n    auto PA = PreservedAnalyses::none();\n    PA.preserve<AAManager>();\n    // Not preserving `DominatorTreeAnalysis`.\n    PA.preserve<LoopAnalysis>();\n    PA.preserve<LoopAnalysisManagerFunctionProxy>();\n    PA.preserve<ScalarEvolutionAnalysis>();\n    return PA;\n  }));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n  FPM.addPass(MFPHandle.getPass());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>()));\n\n  EXPECT_CALL(MFPHandle, run(HasName(\"f\"), _)).WillOnce(InvokeWithoutArgs([] {\n    auto PA = PreservedAnalyses::none();\n    PA.preserve<AAManager>();\n    PA.preserve<DominatorTreeAnalysis>();\n    // Not preserving the `LoopAnalysis`.\n    PA.preserve<LoopAnalysisManagerFunctionProxy>();\n    PA.preserve<ScalarEvolutionAnalysis>();\n    return PA;\n  }));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n  FPM.addPass(MFPHandle.getPass());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>()));\n\n  EXPECT_CALL(MFPHandle, run(HasName(\"f\"), _)).WillOnce(InvokeWithoutArgs([] {\n    auto PA = PreservedAnalyses::none();\n    PA.preserve<AAManager>();\n    PA.preserve<DominatorTreeAnalysis>();\n    PA.preserve<LoopAnalysis>();\n    // Not preserving the `LoopAnalysisManagerFunctionProxy`.\n    PA.preserve<ScalarEvolutionAnalysis>();\n    return PA;\n  }));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n  FPM.addPass(MFPHandle.getPass());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>()));\n\n  EXPECT_CALL(MFPHandle, run(HasName(\"f\"), _)).WillOnce(InvokeWithoutArgs([] {\n    auto PA = PreservedAnalyses::none();\n    PA.preserve<AAManager>();\n    PA.preserve<DominatorTreeAnalysis>();\n    PA.preserve<LoopAnalysis>();\n    PA.preserve<LoopAnalysisManagerFunctionProxy>();\n    // Not preserving `ScalarEvolutionAnalysis`.\n    return PA;\n  }));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n  FPM.addPass(MFPHandle.getPass());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      RequireAnalysisLoopPass<MockLoopAnalysisHandle::Analysis>()));\n\n  // After all the churn on 'f', we'll compute the loop analysis results for\n  // 'g' once with a requires pass and then run our mock pass over g a bunch\n  // but just get cached results each time.\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.g.0\"), _, _));\n  EXPECT_CALL(MFPHandle, run(HasName(\"g\"), _)).Times(6);\n\n  MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n  MPM.run(*M, MAM);\n}\n\nTEST_F(LoopPassManagerTest, IndirectInvalidation) {\n  // We need two distinct analysis types and handles.\n  enum { A, B };\n  MockLoopAnalysisHandleTemplate<A> MLAHandleA;\n  MockLoopAnalysisHandleTemplate<B> MLAHandleB;\n  LAM.registerPass([&] { return MLAHandleA.getAnalysis(); });\n  LAM.registerPass([&] { return MLAHandleB.getAnalysis(); });\n  typedef decltype(MLAHandleA)::Analysis AnalysisA;\n  typedef decltype(MLAHandleB)::Analysis AnalysisB;\n\n  // Set up AnalysisA to depend on our AnalysisB. For testing purposes we just\n  // need to get the AnalysisB results in AnalysisA's run method and check if\n  // AnalysisB gets invalidated in AnalysisA's invalidate method.\n  ON_CALL(MLAHandleA, run(_, _, _))\n      .WillByDefault(Invoke([&](Loop &L, LoopAnalysisManager &AM,\n                                LoopStandardAnalysisResults &AR) {\n        (void)AM.getResult<AnalysisB>(L, AR);\n        return MLAHandleA.getResult();\n      }));\n  ON_CALL(MLAHandleA, invalidate(_, _, _))\n      .WillByDefault(Invoke([](Loop &L, const PreservedAnalyses &PA,\n                               LoopAnalysisManager::Invalidator &Inv) {\n        auto PAC = PA.getChecker<AnalysisA>();\n        return !(PAC.preserved() || PAC.preservedSet<AllAnalysesOn<Loop>>()) ||\n               Inv.invalidate<AnalysisB>(L, PA);\n      }));\n\n  ::testing::InSequence MakeExpectationsSequenced;\n\n  // Compute the analyses across all of 'f' first.\n  EXPECT_CALL(MLAHandleA, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandleB, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandleA, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLAHandleB, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLAHandleA, run(HasName(\"loop.0\"), _, _));\n  EXPECT_CALL(MLAHandleB, run(HasName(\"loop.0\"), _, _));\n\n  // Now we invalidate AnalysisB (but not AnalysisA) for one of the loops and\n  // preserve everything for the rest. This in turn triggers that one loop to\n  // recompute both AnalysisB *and* AnalysisA if indirect invalidation is\n  // working.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.0\"), _, _, _))\n      .WillOnce(InvokeWithoutArgs([] {\n        auto PA = getLoopPassPreservedAnalyses();\n        // Specifically preserve AnalysisA so that it would survive if it\n        // didn't depend on AnalysisB.\n        PA.preserve<AnalysisA>();\n        return PA;\n      }));\n  // It happens that AnalysisB is invalidated first. That shouldn't matter\n  // though, and we should still call AnalysisA's invalidation.\n  EXPECT_CALL(MLAHandleB, invalidate(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandleA, invalidate(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.0\"), _, _, _))\n      .WillOnce(Invoke([](Loop &L, LoopAnalysisManager &AM,\n                          LoopStandardAnalysisResults &AR, LPMUpdater &) {\n        (void)AM.getResult<AnalysisA>(L, AR);\n        return PreservedAnalyses::all();\n      }));\n  EXPECT_CALL(MLAHandleA, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandleB, run(HasName(\"loop.0.0\"), _, _));\n  // The rest of the loops should run and get cached results.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke([](Loop &L, LoopAnalysisManager &AM,\n                                LoopStandardAnalysisResults &AR, LPMUpdater &) {\n        (void)AM.getResult<AnalysisA>(L, AR);\n        return PreservedAnalyses::all();\n      }));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke([](Loop &L, LoopAnalysisManager &AM,\n                                LoopStandardAnalysisResults &AR, LPMUpdater &) {\n        (void)AM.getResult<AnalysisA>(L, AR);\n        return PreservedAnalyses::all();\n      }));\n\n  // The run over 'g' should be boring, with us just computing the analyses once\n  // up front and then running loop passes and getting cached results.\n  EXPECT_CALL(MLAHandleA, run(HasName(\"loop.g.0\"), _, _));\n  EXPECT_CALL(MLAHandleB, run(HasName(\"loop.g.0\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.g.0\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke([](Loop &L, LoopAnalysisManager &AM,\n                                LoopStandardAnalysisResults &AR, LPMUpdater &) {\n        (void)AM.getResult<AnalysisA>(L, AR);\n        return PreservedAnalyses::all();\n      }));\n\n  // Build the pipeline and run it.\n  ModulePassManager MPM(true);\n  FunctionPassManager FPM(true);\n  FPM.addPass(\n      createFunctionToLoopPassAdaptor(RequireAnalysisLoopPass<AnalysisA>()));\n  LoopPassManager LPM(true);\n  LPM.addPass(MLPHandle.getPass());\n  LPM.addPass(MLPHandle.getPass());\n  FPM.addPass(createFunctionToLoopPassAdaptor(std::move(LPM)));\n  MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n  MPM.run(*M, MAM);\n}\n\nTEST_F(LoopPassManagerTest, IndirectOuterPassInvalidation) {\n  typedef decltype(MLAHandle)::Analysis LoopAnalysis;\n\n  MockFunctionAnalysisHandle MFAHandle;\n  FAM.registerPass([&] { return MFAHandle.getAnalysis(); });\n  typedef decltype(MFAHandle)::Analysis FunctionAnalysis;\n\n  // Set up the loop analysis to depend on both the function and module\n  // analysis.\n  ON_CALL(MLAHandle, run(_, _, _))\n      .WillByDefault(Invoke([&](Loop &L, LoopAnalysisManager &AM,\n                                LoopStandardAnalysisResults &AR) {\n        auto &FAMP = AM.getResult<FunctionAnalysisManagerLoopProxy>(L, AR);\n        Function &F = *L.getHeader()->getParent();\n        // This call will assert when trying to get the actual analysis if the\n        // FunctionAnalysis can be invalidated. Only check its existence.\n        // Alternatively, use FAM above, for the purposes of this unittest.\n        if (FAMP.cachedResultExists<FunctionAnalysis>(F))\n          FAMP.registerOuterAnalysisInvalidation<FunctionAnalysis,\n                                                 LoopAnalysis>();\n        return MLAHandle.getResult();\n      }));\n\n  ::testing::InSequence MakeExpectationsSequenced;\n\n  // Compute the analyses across all of 'f' first.\n  EXPECT_CALL(MFPHandle, run(HasName(\"f\"), _))\n      .WillOnce(Invoke([](Function &F, FunctionAnalysisManager &AM) {\n        // Force the computing of the function analysis so it is available in\n        // this function.\n        (void)AM.getResult<FunctionAnalysis>(F);\n        return PreservedAnalyses::all();\n      }));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n\n  // Now invalidate the function analysis but preserve the loop analyses.\n  // This should trigger immediate invalidation of the loop analyses, despite\n  // the fact that they were preserved.\n  EXPECT_CALL(MFPHandle, run(HasName(\"f\"), _)).WillOnce(InvokeWithoutArgs([] {\n    auto PA = getLoopPassPreservedAnalyses();\n    if (EnableMSSALoopDependency)\n      PA.preserve<MemorySSAAnalysis>();\n    PA.preserveSet<AllAnalysesOn<Loop>>();\n    return PA;\n  }));\n  EXPECT_CALL(MLAHandle, invalidate(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandle, invalidate(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLAHandle, invalidate(HasName(\"loop.0\"), _, _));\n\n  // And re-running a requires pass recomputes them.\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n\n  // When we run over 'g' we don't populate the cache with the function\n  // analysis.\n  EXPECT_CALL(MFPHandle, run(HasName(\"g\"), _))\n      .WillOnce(Return(PreservedAnalyses::all()));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.g.0\"), _, _));\n\n  // Which means that no extra invalidation occurs and cached values are used.\n  EXPECT_CALL(MFPHandle, run(HasName(\"g\"), _)).WillOnce(InvokeWithoutArgs([] {\n    auto PA = getLoopPassPreservedAnalyses();\n    if (EnableMSSALoopDependency)\n      PA.preserve<MemorySSAAnalysis>();\n    PA.preserveSet<AllAnalysesOn<Loop>>();\n    return PA;\n  }));\n\n  // Build the pipeline and run it.\n  ModulePassManager MPM(true);\n  FunctionPassManager FPM(true);\n  FPM.addPass(MFPHandle.getPass());\n  FPM.addPass(\n      createFunctionToLoopPassAdaptor(RequireAnalysisLoopPass<LoopAnalysis>()));\n  FPM.addPass(MFPHandle.getPass());\n  FPM.addPass(\n      createFunctionToLoopPassAdaptor(RequireAnalysisLoopPass<LoopAnalysis>()));\n  MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n  MPM.run(*M, MAM);\n}\n\nTEST_F(LoopPassManagerTest, LoopChildInsertion) {\n  // Super boring module with three loops in a single loop nest.\n  M = parseIR(Context, \"define void @f(i1* %ptr) {\\n\"\n                       \"entry:\\n\"\n                       \"  br label %loop.0\\n\"\n                       \"loop.0:\\n\"\n                       \"  %cond.0 = load volatile i1, i1* %ptr\\n\"\n                       \"  br i1 %cond.0, label %loop.0.0.ph, label %end\\n\"\n                       \"loop.0.0.ph:\\n\"\n                       \"  br label %loop.0.0\\n\"\n                       \"loop.0.0:\\n\"\n                       \"  %cond.0.0 = load volatile i1, i1* %ptr\\n\"\n                       \"  br i1 %cond.0.0, label %loop.0.0, label %loop.0.1.ph\\n\"\n                       \"loop.0.1.ph:\\n\"\n                       \"  br label %loop.0.1\\n\"\n                       \"loop.0.1:\\n\"\n                       \"  %cond.0.1 = load volatile i1, i1* %ptr\\n\"\n                       \"  br i1 %cond.0.1, label %loop.0.1, label %loop.0.2.ph\\n\"\n                       \"loop.0.2.ph:\\n\"\n                       \"  br label %loop.0.2\\n\"\n                       \"loop.0.2:\\n\"\n                       \"  %cond.0.2 = load volatile i1, i1* %ptr\\n\"\n                       \"  br i1 %cond.0.2, label %loop.0.2, label %loop.0.latch\\n\"\n                       \"loop.0.latch:\\n\"\n                       \"  br label %loop.0\\n\"\n                       \"end:\\n\"\n                       \"  ret void\\n\"\n                       \"}\\n\");\n\n  // Build up variables referring into the IR so we can rewrite it below\n  // easily.\n  Function &F = *M->begin();\n  ASSERT_THAT(F, HasName(\"f\"));\n  Argument &Ptr = *F.arg_begin();\n  auto BBI = F.begin();\n  BasicBlock &EntryBB = *BBI++;\n  ASSERT_THAT(EntryBB, HasName(\"entry\"));\n  BasicBlock &Loop0BB = *BBI++;\n  ASSERT_THAT(Loop0BB, HasName(\"loop.0\"));\n  BasicBlock &Loop00PHBB = *BBI++;\n  ASSERT_THAT(Loop00PHBB, HasName(\"loop.0.0.ph\"));\n  BasicBlock &Loop00BB = *BBI++;\n  ASSERT_THAT(Loop00BB, HasName(\"loop.0.0\"));\n  BasicBlock &Loop01PHBB = *BBI++;\n  ASSERT_THAT(Loop01PHBB, HasName(\"loop.0.1.ph\"));\n  BasicBlock &Loop01BB = *BBI++;\n  ASSERT_THAT(Loop01BB, HasName(\"loop.0.1\"));\n  BasicBlock &Loop02PHBB = *BBI++;\n  ASSERT_THAT(Loop02PHBB, HasName(\"loop.0.2.ph\"));\n  BasicBlock &Loop02BB = *BBI++;\n  ASSERT_THAT(Loop02BB, HasName(\"loop.0.2\"));\n  BasicBlock &Loop0LatchBB = *BBI++;\n  ASSERT_THAT(Loop0LatchBB, HasName(\"loop.0.latch\"));\n  BasicBlock &EndBB = *BBI++;\n  ASSERT_THAT(EndBB, HasName(\"end\"));\n  ASSERT_THAT(BBI, F.end());\n  auto CreateCondBr = [&](BasicBlock *TrueBB, BasicBlock *FalseBB,\n                          const char *Name, BasicBlock *BB) {\n    auto *Cond = new LoadInst(Type::getInt1Ty(Context), &Ptr, Name,\n                              /*isVolatile*/ true, BB);\n    BranchInst::Create(TrueBB, FalseBB, Cond, BB);\n  };\n\n  // Build the pass managers and register our pipeline. We build a single loop\n  // pass pipeline consisting of three mock pass runs over each loop. After\n  // this we run both domtree and loop verification passes to make sure that\n  // the IR remained valid during our mutations.\n  ModulePassManager MPM(true);\n  FunctionPassManager FPM(true);\n  LoopPassManager LPM(true);\n  LPM.addPass(MLPHandle.getPass());\n  LPM.addPass(MLPHandle.getPass());\n  LPM.addPass(MLPHandle.getPass());\n  FPM.addPass(createFunctionToLoopPassAdaptor(std::move(LPM)));\n  FPM.addPass(DominatorTreeVerifierPass());\n  FPM.addPass(LoopVerifierPass());\n  MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n\n  // All the visit orders are deterministic, so we use simple fully order\n  // expectations.\n  ::testing::InSequence MakeExpectationsSequenced;\n\n  // We run loop passes three times over each of the loops.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.0\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.0\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n\n  // When running over the middle loop, the second run inserts two new child\n  // loops, inserting them and itself into the worklist.\n  BasicBlock *NewLoop010BB, *NewLoop01LatchBB;\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1\"), _, _, _))\n      .WillOnce(Invoke([&](Loop &L, LoopAnalysisManager &AM,\n                           LoopStandardAnalysisResults &AR,\n                           LPMUpdater &Updater) {\n        auto *NewLoop = AR.LI.AllocateLoop();\n        L.addChildLoop(NewLoop);\n        auto *NewLoop010PHBB =\n            BasicBlock::Create(Context, \"loop.0.1.0.ph\", &F, &Loop02PHBB);\n        NewLoop010BB =\n            BasicBlock::Create(Context, \"loop.0.1.0\", &F, &Loop02PHBB);\n        NewLoop01LatchBB =\n            BasicBlock::Create(Context, \"loop.0.1.latch\", &F, &Loop02PHBB);\n        Loop01BB.getTerminator()->replaceUsesOfWith(&Loop01BB, NewLoop010PHBB);\n        BranchInst::Create(NewLoop010BB, NewLoop010PHBB);\n        CreateCondBr(NewLoop01LatchBB, NewLoop010BB, \"cond.0.1.0\",\n                     NewLoop010BB);\n        BranchInst::Create(&Loop01BB, NewLoop01LatchBB);\n        AR.DT.addNewBlock(NewLoop010PHBB, &Loop01BB);\n        AR.DT.addNewBlock(NewLoop010BB, NewLoop010PHBB);\n        AR.DT.addNewBlock(NewLoop01LatchBB, NewLoop010BB);\n        EXPECT_TRUE(AR.DT.verify());\n        L.addBasicBlockToLoop(NewLoop010PHBB, AR.LI);\n        NewLoop->addBasicBlockToLoop(NewLoop010BB, AR.LI);\n        L.addBasicBlockToLoop(NewLoop01LatchBB, AR.LI);\n        NewLoop->verifyLoop();\n        L.verifyLoop();\n        Updater.addChildLoops({NewLoop});\n        return PreservedAnalyses::all();\n      }));\n\n  // We should immediately drop down to fully visit the new inner loop.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1.0\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1.0\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1.0\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  // After visiting the inner loop, we should re-visit the second loop\n  // reflecting its new loop nest structure.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n\n  // In the second run over the middle loop after we've visited the new child,\n  // we add another child to check that we can repeatedly add children, and add\n  // children to a loop that already has children.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1\"), _, _, _))\n      .WillOnce(Invoke([&](Loop &L, LoopAnalysisManager &AM,\n                           LoopStandardAnalysisResults &AR,\n                           LPMUpdater &Updater) {\n        auto *NewLoop = AR.LI.AllocateLoop();\n        L.addChildLoop(NewLoop);\n        auto *NewLoop011PHBB = BasicBlock::Create(Context, \"loop.0.1.1.ph\", &F, NewLoop01LatchBB);\n        auto *NewLoop011BB = BasicBlock::Create(Context, \"loop.0.1.1\", &F, NewLoop01LatchBB);\n        NewLoop010BB->getTerminator()->replaceUsesOfWith(NewLoop01LatchBB,\n                                                         NewLoop011PHBB);\n        BranchInst::Create(NewLoop011BB, NewLoop011PHBB);\n        CreateCondBr(NewLoop01LatchBB, NewLoop011BB, \"cond.0.1.1\",\n                     NewLoop011BB);\n        AR.DT.addNewBlock(NewLoop011PHBB, NewLoop010BB);\n        auto *NewDTNode = AR.DT.addNewBlock(NewLoop011BB, NewLoop011PHBB);\n        AR.DT.changeImmediateDominator(AR.DT[NewLoop01LatchBB], NewDTNode);\n        EXPECT_TRUE(AR.DT.verify());\n        L.addBasicBlockToLoop(NewLoop011PHBB, AR.LI);\n        NewLoop->addBasicBlockToLoop(NewLoop011BB, AR.LI);\n        NewLoop->verifyLoop();\n        L.verifyLoop();\n        Updater.addChildLoops({NewLoop});\n        return PreservedAnalyses::all();\n      }));\n\n  // Again, we should immediately drop down to visit the new, unvisited child\n  // loop. We don't need to revisit the other child though.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1.1\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1.1\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1.1\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  // And now we should pop back up to the second loop and do a full pipeline of\n  // three passes on its current form.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1\"), _, _, _))\n      .Times(3)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.2\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.2\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.2\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  // Now that all the expected actions are registered, run the pipeline over\n  // our module. All of our expectations are verified when the test finishes.\n  MPM.run(*M, MAM);\n}\n\nTEST_F(LoopPassManagerTest, LoopPeerInsertion) {\n  // Super boring module with two loop nests and loop nest with two child\n  // loops.\n  M = parseIR(Context, \"define void @f(i1* %ptr) {\\n\"\n                       \"entry:\\n\"\n                       \"  br label %loop.0\\n\"\n                       \"loop.0:\\n\"\n                       \"  %cond.0 = load volatile i1, i1* %ptr\\n\"\n                       \"  br i1 %cond.0, label %loop.0.0.ph, label %loop.2.ph\\n\"\n                       \"loop.0.0.ph:\\n\"\n                       \"  br label %loop.0.0\\n\"\n                       \"loop.0.0:\\n\"\n                       \"  %cond.0.0 = load volatile i1, i1* %ptr\\n\"\n                       \"  br i1 %cond.0.0, label %loop.0.0, label %loop.0.2.ph\\n\"\n                       \"loop.0.2.ph:\\n\"\n                       \"  br label %loop.0.2\\n\"\n                       \"loop.0.2:\\n\"\n                       \"  %cond.0.2 = load volatile i1, i1* %ptr\\n\"\n                       \"  br i1 %cond.0.2, label %loop.0.2, label %loop.0.latch\\n\"\n                       \"loop.0.latch:\\n\"\n                       \"  br label %loop.0\\n\"\n                       \"loop.2.ph:\\n\"\n                       \"  br label %loop.2\\n\"\n                       \"loop.2:\\n\"\n                       \"  %cond.2 = load volatile i1, i1* %ptr\\n\"\n                       \"  br i1 %cond.2, label %loop.2, label %end\\n\"\n                       \"end:\\n\"\n                       \"  ret void\\n\"\n                       \"}\\n\");\n\n  // Build up variables referring into the IR so we can rewrite it below\n  // easily.\n  Function &F = *M->begin();\n  ASSERT_THAT(F, HasName(\"f\"));\n  Argument &Ptr = *F.arg_begin();\n  auto BBI = F.begin();\n  BasicBlock &EntryBB = *BBI++;\n  ASSERT_THAT(EntryBB, HasName(\"entry\"));\n  BasicBlock &Loop0BB = *BBI++;\n  ASSERT_THAT(Loop0BB, HasName(\"loop.0\"));\n  BasicBlock &Loop00PHBB = *BBI++;\n  ASSERT_THAT(Loop00PHBB, HasName(\"loop.0.0.ph\"));\n  BasicBlock &Loop00BB = *BBI++;\n  ASSERT_THAT(Loop00BB, HasName(\"loop.0.0\"));\n  BasicBlock &Loop02PHBB = *BBI++;\n  ASSERT_THAT(Loop02PHBB, HasName(\"loop.0.2.ph\"));\n  BasicBlock &Loop02BB = *BBI++;\n  ASSERT_THAT(Loop02BB, HasName(\"loop.0.2\"));\n  BasicBlock &Loop0LatchBB = *BBI++;\n  ASSERT_THAT(Loop0LatchBB, HasName(\"loop.0.latch\"));\n  BasicBlock &Loop2PHBB = *BBI++;\n  ASSERT_THAT(Loop2PHBB, HasName(\"loop.2.ph\"));\n  BasicBlock &Loop2BB = *BBI++;\n  ASSERT_THAT(Loop2BB, HasName(\"loop.2\"));\n  BasicBlock &EndBB = *BBI++;\n  ASSERT_THAT(EndBB, HasName(\"end\"));\n  ASSERT_THAT(BBI, F.end());\n  auto CreateCondBr = [&](BasicBlock *TrueBB, BasicBlock *FalseBB,\n                          const char *Name, BasicBlock *BB) {\n    auto *Cond = new LoadInst(Type::getInt1Ty(Context), &Ptr, Name,\n                              /*isVolatile*/ true, BB);\n    BranchInst::Create(TrueBB, FalseBB, Cond, BB);\n  };\n\n  // Build the pass managers and register our pipeline. We build a single loop\n  // pass pipeline consisting of three mock pass runs over each loop. After\n  // this we run both domtree and loop verification passes to make sure that\n  // the IR remained valid during our mutations.\n  ModulePassManager MPM(true);\n  FunctionPassManager FPM(true);\n  LoopPassManager LPM(true);\n  LPM.addPass(MLPHandle.getPass());\n  LPM.addPass(MLPHandle.getPass());\n  LPM.addPass(MLPHandle.getPass());\n  FPM.addPass(createFunctionToLoopPassAdaptor(std::move(LPM)));\n  FPM.addPass(DominatorTreeVerifierPass());\n  FPM.addPass(LoopVerifierPass());\n  MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n\n  // All the visit orders are deterministic, so we use simple fully order\n  // expectations.\n  ::testing::InSequence MakeExpectationsSequenced;\n\n  // We run loop passes three times over each of the loops.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.0\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n\n  // On the second run, we insert a sibling loop.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.0\"), _, _, _))\n      .WillOnce(Invoke([&](Loop &L, LoopAnalysisManager &AM,\n                           LoopStandardAnalysisResults &AR,\n                           LPMUpdater &Updater) {\n        auto *NewLoop = AR.LI.AllocateLoop();\n        L.getParentLoop()->addChildLoop(NewLoop);\n        auto *NewLoop01PHBB = BasicBlock::Create(Context, \"loop.0.1.ph\", &F, &Loop02PHBB);\n        auto *NewLoop01BB = BasicBlock::Create(Context, \"loop.0.1\", &F, &Loop02PHBB);\n        BranchInst::Create(NewLoop01BB, NewLoop01PHBB);\n        CreateCondBr(&Loop02PHBB, NewLoop01BB, \"cond.0.1\", NewLoop01BB);\n        Loop00BB.getTerminator()->replaceUsesOfWith(&Loop02PHBB, NewLoop01PHBB);\n        AR.DT.addNewBlock(NewLoop01PHBB, &Loop00BB);\n        auto *NewDTNode = AR.DT.addNewBlock(NewLoop01BB, NewLoop01PHBB);\n        AR.DT.changeImmediateDominator(AR.DT[&Loop02PHBB], NewDTNode);\n        EXPECT_TRUE(AR.DT.verify());\n        L.getParentLoop()->addBasicBlockToLoop(NewLoop01PHBB, AR.LI);\n        NewLoop->addBasicBlockToLoop(NewLoop01BB, AR.LI);\n        L.getParentLoop()->verifyLoop();\n        Updater.addSiblingLoops({NewLoop});\n        return PreservedAnalyses::all();\n      }));\n  // We finish processing this loop as sibling loops don't perturb the\n  // postorder walk.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.0\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n\n  // We visit the inserted sibling next.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.2\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.2\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.2\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  // Next, on the third pass run on the last inner loop we add more new\n  // siblings, more than one, and one with nested child loops. By doing this at\n  // the end we make sure that edge case works well.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.2\"), _, _, _))\n      .WillOnce(Invoke([&](Loop &L, LoopAnalysisManager &AM,\n                           LoopStandardAnalysisResults &AR,\n                           LPMUpdater &Updater) {\n        Loop *NewLoops[] = {AR.LI.AllocateLoop(), AR.LI.AllocateLoop(),\n                            AR.LI.AllocateLoop()};\n        L.getParentLoop()->addChildLoop(NewLoops[0]);\n        L.getParentLoop()->addChildLoop(NewLoops[1]);\n        NewLoops[1]->addChildLoop(NewLoops[2]);\n        auto *NewLoop03PHBB =\n            BasicBlock::Create(Context, \"loop.0.3.ph\", &F, &Loop0LatchBB);\n        auto *NewLoop03BB =\n            BasicBlock::Create(Context, \"loop.0.3\", &F, &Loop0LatchBB);\n        auto *NewLoop04PHBB =\n            BasicBlock::Create(Context, \"loop.0.4.ph\", &F, &Loop0LatchBB);\n        auto *NewLoop04BB =\n            BasicBlock::Create(Context, \"loop.0.4\", &F, &Loop0LatchBB);\n        auto *NewLoop040PHBB =\n            BasicBlock::Create(Context, \"loop.0.4.0.ph\", &F, &Loop0LatchBB);\n        auto *NewLoop040BB =\n            BasicBlock::Create(Context, \"loop.0.4.0\", &F, &Loop0LatchBB);\n        auto *NewLoop04LatchBB =\n            BasicBlock::Create(Context, \"loop.0.4.latch\", &F, &Loop0LatchBB);\n        Loop02BB.getTerminator()->replaceUsesOfWith(&Loop0LatchBB, NewLoop03PHBB);\n        BranchInst::Create(NewLoop03BB, NewLoop03PHBB);\n        CreateCondBr(NewLoop04PHBB, NewLoop03BB, \"cond.0.3\", NewLoop03BB);\n        BranchInst::Create(NewLoop04BB, NewLoop04PHBB);\n        CreateCondBr(&Loop0LatchBB, NewLoop040PHBB, \"cond.0.4\", NewLoop04BB);\n        BranchInst::Create(NewLoop040BB, NewLoop040PHBB);\n        CreateCondBr(NewLoop04LatchBB, NewLoop040BB, \"cond.0.4.0\", NewLoop040BB);\n        BranchInst::Create(NewLoop04BB, NewLoop04LatchBB);\n        AR.DT.addNewBlock(NewLoop03PHBB, &Loop02BB);\n        AR.DT.addNewBlock(NewLoop03BB, NewLoop03PHBB);\n        AR.DT.addNewBlock(NewLoop04PHBB, NewLoop03BB);\n        auto *NewDTNode = AR.DT.addNewBlock(NewLoop04BB, NewLoop04PHBB);\n        AR.DT.changeImmediateDominator(AR.DT[&Loop0LatchBB], NewDTNode);\n        AR.DT.addNewBlock(NewLoop040PHBB, NewLoop04BB);\n        AR.DT.addNewBlock(NewLoop040BB, NewLoop040PHBB);\n        AR.DT.addNewBlock(NewLoop04LatchBB, NewLoop040BB);\n        EXPECT_TRUE(AR.DT.verify());\n        L.getParentLoop()->addBasicBlockToLoop(NewLoop03PHBB, AR.LI);\n        NewLoops[0]->addBasicBlockToLoop(NewLoop03BB, AR.LI);\n        L.getParentLoop()->addBasicBlockToLoop(NewLoop04PHBB, AR.LI);\n        NewLoops[1]->addBasicBlockToLoop(NewLoop04BB, AR.LI);\n        NewLoops[1]->addBasicBlockToLoop(NewLoop040PHBB, AR.LI);\n        NewLoops[2]->addBasicBlockToLoop(NewLoop040BB, AR.LI);\n        NewLoops[1]->addBasicBlockToLoop(NewLoop04LatchBB, AR.LI);\n        L.getParentLoop()->verifyLoop();\n        Updater.addSiblingLoops({NewLoops[0], NewLoops[1]});\n        return PreservedAnalyses::all();\n      }));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.3\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.3\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.3\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  // Note that we need to visit the inner loop of this added sibling before the\n  // sibling itself!\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.4.0\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.4.0\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.4.0\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.4\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.4\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.4\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  // And only now do we visit the outermost loop of the nest.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n  // On the second pass, we add sibling loops which become new top-level loops.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .WillOnce(Invoke([&](Loop &L, LoopAnalysisManager &AM,\n                           LoopStandardAnalysisResults &AR,\n                           LPMUpdater &Updater) {\n        auto *NewLoop = AR.LI.AllocateLoop();\n        AR.LI.addTopLevelLoop(NewLoop);\n        auto *NewLoop1PHBB = BasicBlock::Create(Context, \"loop.1.ph\", &F, &Loop2BB);\n        auto *NewLoop1BB = BasicBlock::Create(Context, \"loop.1\", &F, &Loop2BB);\n        BranchInst::Create(NewLoop1BB, NewLoop1PHBB);\n        CreateCondBr(&Loop2PHBB, NewLoop1BB, \"cond.1\", NewLoop1BB);\n        Loop0BB.getTerminator()->replaceUsesOfWith(&Loop2PHBB, NewLoop1PHBB);\n        AR.DT.addNewBlock(NewLoop1PHBB, &Loop0BB);\n        auto *NewDTNode = AR.DT.addNewBlock(NewLoop1BB, NewLoop1PHBB);\n        AR.DT.changeImmediateDominator(AR.DT[&Loop2PHBB], NewDTNode);\n        EXPECT_TRUE(AR.DT.verify());\n        NewLoop->addBasicBlockToLoop(NewLoop1BB, AR.LI);\n        NewLoop->verifyLoop();\n        Updater.addSiblingLoops({NewLoop});\n        return PreservedAnalyses::all();\n      }));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.1\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.1\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.1\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.2\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.2\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.2\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  // Now that all the expected actions are registered, run the pipeline over\n  // our module. All of our expectations are verified when the test finishes.\n  MPM.run(*M, MAM);\n}\n\nTEST_F(LoopPassManagerTest, LoopDeletion) {\n  // Build a module with a single loop nest that contains one outer loop with\n  // three subloops, and one of those with its own subloop. We will\n  // incrementally delete all of these to test different deletion scenarios.\n  M = parseIR(Context, \"define void @f(i1* %ptr) {\\n\"\n                       \"entry:\\n\"\n                       \"  br label %loop.0\\n\"\n                       \"loop.0:\\n\"\n                       \"  %cond.0 = load volatile i1, i1* %ptr\\n\"\n                       \"  br i1 %cond.0, label %loop.0.0.ph, label %end\\n\"\n                       \"loop.0.0.ph:\\n\"\n                       \"  br label %loop.0.0\\n\"\n                       \"loop.0.0:\\n\"\n                       \"  %cond.0.0 = load volatile i1, i1* %ptr\\n\"\n                       \"  br i1 %cond.0.0, label %loop.0.0, label %loop.0.1.ph\\n\"\n                       \"loop.0.1.ph:\\n\"\n                       \"  br label %loop.0.1\\n\"\n                       \"loop.0.1:\\n\"\n                       \"  %cond.0.1 = load volatile i1, i1* %ptr\\n\"\n                       \"  br i1 %cond.0.1, label %loop.0.1, label %loop.0.2.ph\\n\"\n                       \"loop.0.2.ph:\\n\"\n                       \"  br label %loop.0.2\\n\"\n                       \"loop.0.2:\\n\"\n                       \"  %cond.0.2 = load volatile i1, i1* %ptr\\n\"\n                       \"  br i1 %cond.0.2, label %loop.0.2.0.ph, label %loop.0.latch\\n\"\n                       \"loop.0.2.0.ph:\\n\"\n                       \"  br label %loop.0.2.0\\n\"\n                       \"loop.0.2.0:\\n\"\n                       \"  %cond.0.2.0 = load volatile i1, i1* %ptr\\n\"\n                       \"  br i1 %cond.0.2.0, label %loop.0.2.0, label %loop.0.2.latch\\n\"\n                       \"loop.0.2.latch:\\n\"\n                       \"  br label %loop.0.2\\n\"\n                       \"loop.0.latch:\\n\"\n                       \"  br label %loop.0\\n\"\n                       \"end:\\n\"\n                       \"  ret void\\n\"\n                       \"}\\n\");\n\n  // Build up variables referring into the IR so we can rewrite it below\n  // easily.\n  Function &F = *M->begin();\n  ASSERT_THAT(F, HasName(\"f\"));\n  Argument &Ptr = *F.arg_begin();\n  auto BBI = F.begin();\n  BasicBlock &EntryBB = *BBI++;\n  ASSERT_THAT(EntryBB, HasName(\"entry\"));\n  BasicBlock &Loop0BB = *BBI++;\n  ASSERT_THAT(Loop0BB, HasName(\"loop.0\"));\n  BasicBlock &Loop00PHBB = *BBI++;\n  ASSERT_THAT(Loop00PHBB, HasName(\"loop.0.0.ph\"));\n  BasicBlock &Loop00BB = *BBI++;\n  ASSERT_THAT(Loop00BB, HasName(\"loop.0.0\"));\n  BasicBlock &Loop01PHBB = *BBI++;\n  ASSERT_THAT(Loop01PHBB, HasName(\"loop.0.1.ph\"));\n  BasicBlock &Loop01BB = *BBI++;\n  ASSERT_THAT(Loop01BB, HasName(\"loop.0.1\"));\n  BasicBlock &Loop02PHBB = *BBI++;\n  ASSERT_THAT(Loop02PHBB, HasName(\"loop.0.2.ph\"));\n  BasicBlock &Loop02BB = *BBI++;\n  ASSERT_THAT(Loop02BB, HasName(\"loop.0.2\"));\n  BasicBlock &Loop020PHBB = *BBI++;\n  ASSERT_THAT(Loop020PHBB, HasName(\"loop.0.2.0.ph\"));\n  BasicBlock &Loop020BB = *BBI++;\n  ASSERT_THAT(Loop020BB, HasName(\"loop.0.2.0\"));\n  BasicBlock &Loop02LatchBB = *BBI++;\n  ASSERT_THAT(Loop02LatchBB, HasName(\"loop.0.2.latch\"));\n  BasicBlock &Loop0LatchBB = *BBI++;\n  ASSERT_THAT(Loop0LatchBB, HasName(\"loop.0.latch\"));\n  BasicBlock &EndBB = *BBI++;\n  ASSERT_THAT(EndBB, HasName(\"end\"));\n  ASSERT_THAT(BBI, F.end());\n\n  // Helper to do the actual deletion of a loop. We directly encode this here\n  // to isolate ourselves from the rest of LLVM and for simplicity. Here we can\n  // egregiously cheat based on knowledge of the test case. For example, we\n  // have no PHI nodes and there is always a single i-dom.\n  auto EraseLoop = [](Loop &L, BasicBlock &IDomBB,\n                      LoopStandardAnalysisResults &AR, LPMUpdater &Updater) {\n    assert(L.isInnermost() && \"Can only delete leaf loops with this routine!\");\n    SmallVector<BasicBlock *, 4> LoopBBs(L.block_begin(), L.block_end());\n    Updater.markLoopAsDeleted(L, L.getName());\n    IDomBB.getTerminator()->replaceUsesOfWith(L.getHeader(),\n                                              L.getUniqueExitBlock());\n    for (BasicBlock *LoopBB : LoopBBs) {\n      SmallVector<DomTreeNode *, 4> ChildNodes(AR.DT[LoopBB]->begin(),\n                                               AR.DT[LoopBB]->end());\n      for (DomTreeNode *ChildNode : ChildNodes)\n        AR.DT.changeImmediateDominator(ChildNode, AR.DT[&IDomBB]);\n      AR.DT.eraseNode(LoopBB);\n      AR.LI.removeBlock(LoopBB);\n      LoopBB->dropAllReferences();\n    }\n    for (BasicBlock *LoopBB : LoopBBs)\n      LoopBB->eraseFromParent();\n\n    AR.LI.erase(&L);\n  };\n\n  // Build up the pass managers.\n  ModulePassManager MPM(true);\n  FunctionPassManager FPM(true);\n  // We run several loop pass pipelines across the loop nest, but they all take\n  // the same form of three mock pass runs in a loop pipeline followed by\n  // domtree and loop verification. We use a lambda to stamp this out each\n  // time.\n  auto AddLoopPipelineAndVerificationPasses = [&] {\n    LoopPassManager LPM(true);\n    LPM.addPass(MLPHandle.getPass());\n    LPM.addPass(MLPHandle.getPass());\n    LPM.addPass(MLPHandle.getPass());\n    FPM.addPass(createFunctionToLoopPassAdaptor(std::move(LPM)));\n    FPM.addPass(DominatorTreeVerifierPass());\n    FPM.addPass(LoopVerifierPass());\n  };\n\n  // All the visit orders are deterministic so we use simple fully order\n  // expectations.\n  ::testing::InSequence MakeExpectationsSequenced;\n\n  // We run the loop pipeline with three passes over each of the loops. When\n  // running over the middle loop, the second pass in the pipeline deletes it.\n  // This should prevent the third pass from visiting it but otherwise leave\n  // the process unimpacted.\n  AddLoopPipelineAndVerificationPasses();\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.0\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.0\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.0\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.1\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1\"), _, _, _))\n      .WillOnce(\n          Invoke([&](Loop &L, LoopAnalysisManager &AM,\n                     LoopStandardAnalysisResults &AR, LPMUpdater &Updater) {\n            Loop *ParentL = L.getParentLoop();\n            AR.SE.forgetLoop(&L);\n            EraseLoop(L, Loop01PHBB, AR, Updater);\n            ParentL->verifyLoop();\n            return PreservedAnalyses::all();\n          }));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.2.0\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.2.0\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.2.0\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.2\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.2\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.2\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  // Run the loop pipeline again. This time we delete the last loop, which\n  // contains a nested loop within it and insert a new loop into the nest. This\n  // makes sure we can handle nested loop deletion.\n  AddLoopPipelineAndVerificationPasses();\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.0\"), _, _, _))\n      .Times(3)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.2.0\"), _, _, _))\n      .Times(3)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.2\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  BasicBlock *NewLoop03PHBB;\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.2\"), _, _, _))\n      .WillOnce(\n          Invoke([&](Loop &L, LoopAnalysisManager &AM,\n                     LoopStandardAnalysisResults &AR, LPMUpdater &Updater) {\n            AR.SE.forgetLoop(*L.begin());\n            EraseLoop(**L.begin(), Loop020PHBB, AR, Updater);\n\n            auto *ParentL = L.getParentLoop();\n            AR.SE.forgetLoop(&L);\n            EraseLoop(L, Loop02PHBB, AR, Updater);\n\n            // Now insert a new sibling loop.\n            auto *NewSibling = AR.LI.AllocateLoop();\n            ParentL->addChildLoop(NewSibling);\n            NewLoop03PHBB =\n                BasicBlock::Create(Context, \"loop.0.3.ph\", &F, &Loop0LatchBB);\n            auto *NewLoop03BB =\n                BasicBlock::Create(Context, \"loop.0.3\", &F, &Loop0LatchBB);\n            BranchInst::Create(NewLoop03BB, NewLoop03PHBB);\n            auto *Cond =\n                new LoadInst(Type::getInt1Ty(Context), &Ptr, \"cond.0.3\",\n                             /*isVolatile*/ true, NewLoop03BB);\n            BranchInst::Create(&Loop0LatchBB, NewLoop03BB, Cond, NewLoop03BB);\n            Loop02PHBB.getTerminator()->replaceUsesOfWith(&Loop0LatchBB,\n                                                          NewLoop03PHBB);\n            AR.DT.addNewBlock(NewLoop03PHBB, &Loop02PHBB);\n            AR.DT.addNewBlock(NewLoop03BB, NewLoop03PHBB);\n            AR.DT.changeImmediateDominator(AR.DT[&Loop0LatchBB],\n                                           AR.DT[NewLoop03BB]);\n            EXPECT_TRUE(AR.DT.verify());\n            ParentL->addBasicBlockToLoop(NewLoop03PHBB, AR.LI);\n            NewSibling->addBasicBlockToLoop(NewLoop03BB, AR.LI);\n            NewSibling->verifyLoop();\n            ParentL->verifyLoop();\n            Updater.addSiblingLoops({NewSibling});\n            return PreservedAnalyses::all();\n          }));\n\n  // To respect our inner-to-outer traversal order, we must visit the\n  // newly-inserted sibling of the loop we just deleted before we visit the\n  // outer loop. When we do so, this must compute a fresh analysis result, even\n  // though our new loop has the same pointer value as the loop we deleted.\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.3\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLAHandle, run(HasName(\"loop.0.3\"), _, _));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.3\"), _, _, _))\n      .Times(2)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .Times(3)\n      .WillRepeatedly(Invoke(getLoopAnalysisResult));\n\n  // In the final loop pipeline run we delete every loop, including the last\n  // loop of the nest. We do this again in the second pass in the pipeline, and\n  // as a consequence we never make it to three runs on any loop. We also cover\n  // deleting multiple loops in a single pipeline, deleting the first loop and\n  // deleting the (last) top level loop.\n  AddLoopPipelineAndVerificationPasses();\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.0\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.0\"), _, _, _))\n      .WillOnce(\n          Invoke([&](Loop &L, LoopAnalysisManager &AM,\n                     LoopStandardAnalysisResults &AR, LPMUpdater &Updater) {\n            AR.SE.forgetLoop(&L);\n            EraseLoop(L, Loop00PHBB, AR, Updater);\n            return PreservedAnalyses::all();\n          }));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.3\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.3\"), _, _, _))\n      .WillOnce(\n          Invoke([&](Loop &L, LoopAnalysisManager &AM,\n                     LoopStandardAnalysisResults &AR, LPMUpdater &Updater) {\n            AR.SE.forgetLoop(&L);\n            EraseLoop(L, *NewLoop03PHBB, AR, Updater);\n            return PreservedAnalyses::all();\n          }));\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .WillOnce(Invoke(getLoopAnalysisResult));\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .WillOnce(\n          Invoke([&](Loop &L, LoopAnalysisManager &AM,\n                     LoopStandardAnalysisResults &AR, LPMUpdater &Updater) {\n            AR.SE.forgetLoop(&L);\n            EraseLoop(L, EntryBB, AR, Updater);\n            return PreservedAnalyses::all();\n          }));\n\n  // Add the function pass pipeline now that it is fully built up and run it\n  // over the module's one function.\n  MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n  MPM.run(*M, MAM);\n}\n\nTEST_F(LoopPassManagerTest, HandleLoopNestPass) {\n  ::testing::Sequence FSequence, GSequence;\n\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.0\"), _, _, _))\n      .Times(2)\n      .InSequence(FSequence);\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0.1\"), _, _, _))\n      .Times(2)\n      .InSequence(FSequence);\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0\"), _, _, _)).InSequence(FSequence);\n  EXPECT_CALL(MLNPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .InSequence(FSequence);\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.0\"), _, _, _)).InSequence(FSequence);\n  EXPECT_CALL(MLNPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .InSequence(FSequence);\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.g.0\"), _, _, _))\n      .InSequence(GSequence);\n  EXPECT_CALL(MLNPHandle, run(HasName(\"loop.g.0\"), _, _, _))\n      .InSequence(GSequence);\n  EXPECT_CALL(MLPHandle, run(HasName(\"loop.g.0\"), _, _, _))\n      .InSequence(GSequence);\n  EXPECT_CALL(MLNPHandle, run(HasName(\"loop.g.0\"), _, _, _))\n      .InSequence(GSequence);\n\n  EXPECT_CALL(MLNPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .InSequence(FSequence);\n  EXPECT_CALL(MLNPHandle, run(HasName(\"loop.g.0\"), _, _, _))\n      .InSequence(GSequence);\n\n  EXPECT_CALL(MLNPHandle, run(HasName(\"loop.0\"), _, _, _))\n      .InSequence(FSequence);\n  EXPECT_CALL(MLNPHandle, run(HasName(\"loop.g.0\"), _, _, _))\n      .InSequence(GSequence);\n\n  ModulePassManager MPM(true);\n  FunctionPassManager FPM(true);\n\n  {\n    LoopPassManager LPM(true);\n    LPM.addPass(MLPHandle.getPass());\n    LPM.addPass(MLNPHandle.getPass());\n    LPM.addPass(MLPHandle.getPass());\n    LPM.addPass(MLNPHandle.getPass());\n\n    auto Adaptor = createFunctionToLoopPassAdaptor(std::move(LPM));\n    ASSERT_FALSE(Adaptor.isLoopNestMode());\n    FPM.addPass(std::move(Adaptor));\n  }\n\n  {\n    auto Adaptor = createFunctionToLoopPassAdaptor(MLNPHandle.getPass());\n    ASSERT_TRUE(Adaptor.isLoopNestMode());\n    FPM.addPass(std::move(Adaptor));\n  }\n\n  {\n    LoopPassManager LPM(true);\n    LPM.addPass(MLNPHandle.getPass());\n    auto Adaptor = createFunctionToLoopPassAdaptor(MLNPHandle.getPass());\n    ASSERT_TRUE(Adaptor.isLoopNestMode());\n    FPM.addPass(std::move(Adaptor));\n  }\n\n  MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n  MPM.run(*M, MAM);\n}\n\n} // namespace\n"}, "61": {"id": 61, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/gtest.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file defines the public API for Google Test.  It should be\n// included by any test program that uses Google Test.\n//\n// IMPORTANT NOTE: Due to limitation of the C++ language, we have to\n// leave some internal implementation details in this header file.\n// They are clearly marked by comments like this:\n//\n//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n//\n// Such code is NOT meant to be used by a user directly, and is subject\n// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user\n// program!\n//\n// Acknowledgment: Google Test borrowed the idea of automatic test\n// registration from Barthelemy Dagenais' (barthelemy@prologique.com)\n// easyUnit framework.\n\n#ifndef GTEST_INCLUDE_GTEST_GTEST_H_\n#define GTEST_INCLUDE_GTEST_GTEST_H_\n\n#include <limits>\n#include <ostream>\n#include <vector>\n\n#include \"gtest/internal/gtest-internal.h\"\n#include \"gtest/internal/gtest-string.h\"\n#include \"gtest/gtest-death-test.h\"\n#include \"gtest/gtest-message.h\"\n#include \"gtest/gtest-param-test.h\"\n#include \"gtest/gtest-printers.h\"\n#include \"gtest/gtest_prod.h\"\n#include \"gtest/gtest-test-part.h\"\n#include \"gtest/gtest-typed-test.h\"\n\n// Depending on the platform, different string classes are available.\n// On Linux, in addition to ::std::string, Google also makes use of\n// class ::string, which has the same interface as ::std::string, but\n// has a different implementation.\n//\n// You can define GTEST_HAS_GLOBAL_STRING to 1 to indicate that\n// ::string is available AND is a distinct type to ::std::string, or\n// define it to 0 to indicate otherwise.\n//\n// If ::std::string and ::string are the same class on your platform\n// due to aliasing, you should define GTEST_HAS_GLOBAL_STRING to 0.\n//\n// If you do not define GTEST_HAS_GLOBAL_STRING, it is defined\n// heuristically.\n\nnamespace testing {\n\n// Declares the flags.\n\n// This flag temporary enables the disabled tests.\nGTEST_DECLARE_bool_(also_run_disabled_tests);\n\n// This flag brings the debugger on an assertion failure.\nGTEST_DECLARE_bool_(break_on_failure);\n\n// This flag controls whether Google Test catches all test-thrown exceptions\n// and logs them as failures.\nGTEST_DECLARE_bool_(catch_exceptions);\n\n// This flag enables using colors in terminal output. Available values are\n// \"yes\" to enable colors, \"no\" (disable colors), or \"auto\" (the default)\n// to let Google Test decide.\nGTEST_DECLARE_string_(color);\n\n// This flag sets up the filter to select by name using a glob pattern\n// the tests to run. If the filter is not given all tests are executed.\nGTEST_DECLARE_string_(filter);\n\n// This flag causes the Google Test to list tests. None of the tests listed\n// are actually run if the flag is provided.\nGTEST_DECLARE_bool_(list_tests);\n\n// This flag controls whether Google Test emits a detailed XML report to a file\n// in addition to its normal textual output.\nGTEST_DECLARE_string_(output);\n\n// This flags control whether Google Test prints the elapsed time for each\n// test.\nGTEST_DECLARE_bool_(print_time);\n\n// This flag specifies the random number seed.\nGTEST_DECLARE_int32_(random_seed);\n\n// This flag sets how many times the tests are repeated. The default value\n// is 1. If the value is -1 the tests are repeating forever.\nGTEST_DECLARE_int32_(repeat);\n\n// This flag controls whether Google Test includes Google Test internal\n// stack frames in failure stack traces.\nGTEST_DECLARE_bool_(show_internal_stack_frames);\n\n// When this flag is specified, tests' order is randomized on every iteration.\nGTEST_DECLARE_bool_(shuffle);\n\n// This flag specifies the maximum number of stack frames to be\n// printed in a failure message.\nGTEST_DECLARE_int32_(stack_trace_depth);\n\n// When this flag is specified, a failed assertion will throw an\n// exception if exceptions are enabled, or exit the program with a\n// non-zero code otherwise.\nGTEST_DECLARE_bool_(throw_on_failure);\n\n// When this flag is set with a \"host:port\" string, on supported\n// platforms test results are streamed to the specified port on\n// the specified host machine.\nGTEST_DECLARE_string_(stream_result_to);\n\n// The upper limit for valid stack trace depths.\nconst int kMaxStackTraceDepth = 100;\n\nnamespace internal {\n\nclass AssertHelper;\nclass DefaultGlobalTestPartResultReporter;\nclass ExecDeathTest;\nclass NoExecDeathTest;\nclass FinalSuccessChecker;\nclass GTestFlagSaver;\nclass StreamingListenerTest;\nclass TestResultAccessor;\nclass TestEventListenersAccessor;\nclass TestEventRepeater;\nclass UnitTestRecordPropertyTestHelper;\nclass WindowsDeathTest;\nclass UnitTestImpl* GetUnitTestImpl();\nvoid ReportFailureInUnknownLocation(TestPartResult::Type result_type,\n                                    const std::string& message);\n\n}  // namespace internal\n\n// The friend relationship of some of these classes is cyclic.\n// If we don't forward declare them the compiler might confuse the classes\n// in friendship clauses with same named classes on the scope.\nclass Test;\nclass TestCase;\nclass TestInfo;\nclass UnitTest;\n\n// A class for indicating whether an assertion was successful.  When\n// the assertion wasn't successful, the AssertionResult object\n// remembers a non-empty message that describes how it failed.\n//\n// To create an instance of this class, use one of the factory functions\n// (AssertionSuccess() and AssertionFailure()).\n//\n// This class is useful for two purposes:\n//   1. Defining predicate functions to be used with Boolean test assertions\n//      EXPECT_TRUE/EXPECT_FALSE and their ASSERT_ counterparts\n//   2. Defining predicate-format functions to be\n//      used with predicate assertions (ASSERT_PRED_FORMAT*, etc).\n//\n// For example, if you define IsEven predicate:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure() << n << \" is odd\";\n//   }\n//\n// Then the failed expectation EXPECT_TRUE(IsEven(Fib(5)))\n// will print the message\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false (5 is odd)\n//   Expected: true\n//\n// instead of a more opaque\n//\n//   Value of: IsEven(Fib(5))\n//     Actual: false\n//   Expected: true\n//\n// in case IsEven is a simple Boolean predicate.\n//\n// If you expect your predicate to be reused and want to support informative\n// messages in EXPECT_FALSE and ASSERT_FALSE (negative assertions show up\n// about half as often as positive ones in our tests), supply messages for\n// both success and failure cases:\n//\n//   testing::AssertionResult IsEven(int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess() << n << \" is even\";\n//     else\n//       return testing::AssertionFailure() << n << \" is odd\";\n//   }\n//\n// Then a statement EXPECT_FALSE(IsEven(Fib(6))) will print\n//\n//   Value of: IsEven(Fib(6))\n//     Actual: true (8 is even)\n//   Expected: false\n//\n// NB: Predicates that support negative Boolean assertions have reduced\n// performance in positive ones so be careful not to use them in tests\n// that have lots (tens of thousands) of positive Boolean assertions.\n//\n// To use this class with EXPECT_PRED_FORMAT assertions such as:\n//\n//   // Verifies that Foo() returns an even number.\n//   EXPECT_PRED_FORMAT1(IsEven, Foo());\n//\n// you need to define:\n//\n//   testing::AssertionResult IsEven(const char* expr, int n) {\n//     if ((n % 2) == 0)\n//       return testing::AssertionSuccess();\n//     else\n//       return testing::AssertionFailure()\n//         << \"Expected: \" << expr << \" is even\\n  Actual: it's \" << n;\n//   }\n//\n// If Foo() returns 5, you will see the following message:\n//\n//   Expected: Foo() is even\n//     Actual: it's 5\n//\nclass GTEST_API_ AssertionResult {\n public:\n  // Copy constructor.\n  // Used in EXPECT_TRUE/FALSE(assertion_result).\n  AssertionResult(const AssertionResult& other);\n\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 /* forcing value to bool */)\n\n  // Used in the EXPECT_TRUE/FALSE(bool_expression).\n  //\n  // T must be contextually convertible to bool.\n  //\n  // The second parameter prevents this overload from being considered if\n  // the argument is implicitly convertible to AssertionResult. In that case\n  // we want AssertionResult's copy constructor to be used.\n  template <typename T>\n  explicit AssertionResult(\n      const T& success,\n      typename internal::EnableIf<\n          !internal::ImplicitlyConvertible<T, AssertionResult>::value>::type*\n          /*enabler*/ = NULL)\n      : success_(success) {}\n\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n\n  // Assignment operator.\n  AssertionResult& operator=(AssertionResult other) {\n    swap(other);\n    return *this;\n  }\n\n  // Returns true iff the assertion succeeded.\n  operator bool() const { return success_; }  // NOLINT\n\n  // Returns the assertion's negation. Used with EXPECT/ASSERT_FALSE.\n  AssertionResult operator!() const;\n\n  // Returns the text streamed into this AssertionResult. Test assertions\n  // use it when they fail (i.e., the predicate's outcome doesn't match the\n  // assertion's expectation). When nothing has been streamed into the\n  // object, returns an empty string.\n  const char* message() const {\n    return message_.get() != NULL ?  message_->c_str() : \"\";\n  }\n  // TODO(vladl@google.com): Remove this after making sure no clients use it.\n  // Deprecated; please use message() instead.\n  const char* failure_message() const { return message(); }\n\n  // Streams a custom failure message into this object.\n  template <typename T> AssertionResult& operator<<(const T& value) {\n    AppendMessage(Message() << value);\n    return *this;\n  }\n\n  // Allows streaming basic output manipulators such as endl or flush into\n  // this object.\n  AssertionResult& operator<<(\n      ::std::ostream& (*basic_manipulator)(::std::ostream& stream)) {\n    AppendMessage(Message() << basic_manipulator);\n    return *this;\n  }\n\n private:\n  // Appends the contents of message to message_.\n  void AppendMessage(const Message& a_message) {\n    if (message_.get() == NULL)\n      message_.reset(new ::std::string);\n    message_->append(a_message.GetString().c_str());\n  }\n\n  // Swap the contents of this AssertionResult with other.\n  void swap(AssertionResult& other);\n\n  // Stores result of the assertion predicate.\n  bool success_;\n  // Stores the message describing the condition in case the expectation\n  // construct is not satisfied with the predicate's outcome.\n  // Referenced via a pointer to avoid taking too much stack frame space\n  // with test assertions.\n  internal::scoped_ptr< ::std::string> message_;\n};\n\n// Makes a successful assertion result.\nGTEST_API_ AssertionResult AssertionSuccess();\n\n// Makes a failed assertion result.\nGTEST_API_ AssertionResult AssertionFailure();\n\n// Makes a failed assertion result with the given failure message.\n// Deprecated; use AssertionFailure() << msg.\nGTEST_API_ AssertionResult AssertionFailure(const Message& msg);\n\n// The abstract class that all tests inherit from.\n//\n// In Google Test, a unit test program contains one or many TestCases, and\n// each TestCase contains one or many Tests.\n//\n// When you define a test using the TEST macro, you don't need to\n// explicitly derive from Test - the TEST macro automatically does\n// this for you.\n//\n// The only time you derive from Test is when defining a test fixture\n// to be used a TEST_F.  For example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     void SetUp() override { ... }\n//     void TearDown() override { ... }\n//     ...\n//   };\n//\n//   TEST_F(FooTest, Bar) { ... }\n//   TEST_F(FooTest, Baz) { ... }\n//\n// Test is not copyable.\nclass GTEST_API_ Test {\n public:\n  friend class TestInfo;\n\n  // Defines types for pointers to functions that set up and tear down\n  // a test case.\n  typedef internal::SetUpTestCaseFunc SetUpTestCaseFunc;\n  typedef internal::TearDownTestCaseFunc TearDownTestCaseFunc;\n\n  // The d'tor is virtual as we intend to inherit from Test.\n  virtual ~Test();\n\n  // Sets up the stuff shared by all tests in this test case.\n  //\n  // Google Test will call Foo::SetUpTestCase() before running the first\n  // test in test case Foo.  Hence a sub-class can define its own\n  // SetUpTestCase() method to shadow the one defined in the super\n  // class.\n  static void SetUpTestCase() {}\n\n  // Tears down the stuff shared by all tests in this test case.\n  //\n  // Google Test will call Foo::TearDownTestCase() after running the last\n  // test in test case Foo.  Hence a sub-class can define its own\n  // TearDownTestCase() method to shadow the one defined in the super\n  // class.\n  static void TearDownTestCase() {}\n\n  // Returns true iff the current test has a fatal failure.\n  static bool HasFatalFailure();\n\n  // Returns true iff the current test has a non-fatal failure.\n  static bool HasNonfatalFailure();\n\n  // Returns true iff the current test has a (either fatal or\n  // non-fatal) failure.\n  static bool HasFailure() { return HasFatalFailure() || HasNonfatalFailure(); }\n\n  // Logs a property for the current test, test case, or for the entire\n  // invocation of the test program when used outside of the context of a\n  // test case.  Only the last value for a given key is remembered.  These\n  // are public static so they can be called from utility functions that are\n  // not members of the test fixture.  Calls to RecordProperty made during\n  // lifespan of the test (from the moment its constructor starts to the\n  // moment its destructor finishes) will be output in XML as attributes of\n  // the <testcase> element.  Properties recorded from fixture's\n  // SetUpTestCase or TearDownTestCase are logged as attributes of the\n  // corresponding <testsuite> element.  Calls to RecordProperty made in the\n  // global context (before or after invocation of RUN_ALL_TESTS and from\n  // SetUp/TearDown method of Environment objects registered with Google\n  // Test) will be output as attributes of the <testsuites> element.\n  static void RecordProperty(const std::string& key, const std::string& value);\n  static void RecordProperty(const std::string& key, int value);\n\n protected:\n  // Creates a Test object.\n  Test();\n\n  // Sets up the test fixture.\n  virtual void SetUp();\n\n  // Tears down the test fixture.\n  virtual void TearDown();\n\n private:\n  // Returns true iff the current test has the same fixture class as\n  // the first test in the current test case.\n  static bool HasSameFixtureClass();\n\n  // Runs the test after the test fixture has been set up.\n  //\n  // A sub-class must implement this to define the test logic.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION DIRECTLY IN A USER PROGRAM.\n  // Instead, use the TEST or TEST_F macro.\n  virtual void TestBody() = 0;\n\n  // Sets up, executes, and tears down the test.\n  void Run();\n\n  // Deletes self.  We deliberately pick an unusual name for this\n  // internal method to avoid clashing with names used in user TESTs.\n  void DeleteSelf_() { delete this; }\n\n  const internal::scoped_ptr< GTEST_FLAG_SAVER_ > gtest_flag_saver_;\n\n  // Often a user misspells SetUp() as Setup() and spends a long time\n  // wondering why it is never called by Google Test.  The declaration of\n  // the following method is solely for catching such an error at\n  // compile time:\n  //\n  //   - The return type is deliberately chosen to be not void, so it\n  //   will be a conflict if void Setup() is declared in the user's\n  //   test fixture.\n  //\n  //   - This method is private, so it will be another compiler error\n  //   if the method is called from the user's test fixture.\n  //\n  // DO NOT OVERRIDE THIS FUNCTION.\n  //\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return NULL; }\n\n  // We disallow copying Tests.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Test);\n};\n\ntypedef internal::TimeInMillis TimeInMillis;\n\n// A copyable object representing a user specified test property which can be\n// output as a key/value string pair.\n//\n// Don't inherit from TestProperty as its destructor is not virtual.\nclass TestProperty {\n public:\n  // C'tor.  TestProperty does NOT have a default constructor.\n  // Always use this constructor (with parameters) to create a\n  // TestProperty object.\n  TestProperty(const std::string& a_key, const std::string& a_value) :\n    key_(a_key), value_(a_value) {\n  }\n\n  // Gets the user supplied key.\n  const char* key() const {\n    return key_.c_str();\n  }\n\n  // Gets the user supplied value.\n  const char* value() const {\n    return value_.c_str();\n  }\n\n  // Sets a new value, overriding the one supplied in the constructor.\n  void SetValue(const std::string& new_value) {\n    value_ = new_value;\n  }\n\n private:\n  // The key supplied by the user.\n  std::string key_;\n  // The value supplied by the user.\n  std::string value_;\n};\n\n// The result of a single Test.  This includes a list of\n// TestPartResults, a list of TestProperties, a count of how many\n// death tests there are in the Test, and how much time it took to run\n// the Test.\n//\n// TestResult is not copyable.\nclass GTEST_API_ TestResult {\n public:\n  // Creates an empty TestResult.\n  TestResult();\n\n  // D'tor.  Do not inherit from TestResult.\n  ~TestResult();\n\n  // Gets the number of all test parts.  This is the sum of the number\n  // of successful test parts and the number of failed test parts.\n  int total_part_count() const;\n\n  // Returns the number of the test properties.\n  int test_property_count() const;\n\n  // Returns true iff the test passed (i.e. no test part failed).\n  bool Passed() const { return !Failed(); }\n\n  // Returns true iff the test failed.\n  bool Failed() const;\n\n  // Returns true iff the test fatally failed.\n  bool HasFatalFailure() const;\n\n  // Returns true iff the test has a non-fatal failure.\n  bool HasNonfatalFailure() const;\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Returns the i-th test part result among all the results. i can range\n  // from 0 to test_property_count() - 1. If i is not in that range, aborts\n  // the program.\n  const TestPartResult& GetTestPartResult(int i) const;\n\n  // Returns the i-th test property. i can range from 0 to\n  // test_property_count() - 1. If i is not in that range, aborts the\n  // program.\n  const TestProperty& GetTestProperty(int i) const;\n\n private:\n  friend class TestInfo;\n  friend class TestCase;\n  friend class UnitTest;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::ExecDeathTest;\n  friend class internal::TestResultAccessor;\n  friend class internal::UnitTestImpl;\n  friend class internal::WindowsDeathTest;\n\n  // Gets the vector of TestPartResults.\n  const std::vector<TestPartResult>& test_part_results() const {\n    return test_part_results_;\n  }\n\n  // Gets the vector of TestProperties.\n  const std::vector<TestProperty>& test_properties() const {\n    return test_properties_;\n  }\n\n  // Sets the elapsed time.\n  void set_elapsed_time(TimeInMillis elapsed) { elapsed_time_ = elapsed; }\n\n  // Adds a test property to the list. The property is validated and may add\n  // a non-fatal failure if invalid (e.g., if it conflicts with reserved\n  // key names). If a property is already recorded for the same key, the\n  // value will be updated, rather than storing multiple values for the same\n  // key.  xml_element specifies the element for which the property is being\n  // recorded and is used for validation.\n  void RecordProperty(const std::string& xml_element,\n                      const TestProperty& test_property);\n\n  // Adds a failure if the key is a reserved attribute of Google Test\n  // testcase tags.  Returns true if the property is valid.\n  // TODO(russr): Validate attribute names are legal and human readable.\n  static bool ValidateTestProperty(const std::string& xml_element,\n                                   const TestProperty& test_property);\n\n  // Adds a test part result to the list.\n  void AddTestPartResult(const TestPartResult& test_part_result);\n\n  // Returns the death test count.\n  int death_test_count() const { return death_test_count_; }\n\n  // Increments the death test count, returning the new count.\n  int increment_death_test_count() { return ++death_test_count_; }\n\n  // Clears the test part results.\n  void ClearTestPartResults();\n\n  // Clears the object.\n  void Clear();\n\n  // Protects mutable state of the property vector and of owned\n  // properties, whose values may be updated.\n  internal::Mutex test_properites_mutex_;\n\n  // The vector of TestPartResults\n  std::vector<TestPartResult> test_part_results_;\n  // The vector of TestProperties\n  std::vector<TestProperty> test_properties_;\n  // Running count of death tests.\n  int death_test_count_;\n  // The elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n\n  // We disallow copying TestResult.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestResult);\n};  // class TestResult\n\n// A TestInfo object stores the following information about a test:\n//\n//   Test case name\n//   Test name\n//   Whether the test should be run\n//   A function pointer that creates the test object when invoked\n//   Test result\n//\n// The constructor of TestInfo registers itself with the UnitTest\n// singleton such that the RUN_ALL_TESTS() macro knows which tests to\n// run.\nclass GTEST_API_ TestInfo {\n public:\n  // Destructs a TestInfo object.  This function is not virtual, so\n  // don't inherit from TestInfo.\n  ~TestInfo();\n\n  // Returns the test case name.\n  const char* test_case_name() const { return test_case_name_.c_str(); }\n\n  // Returns the test name.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a typed\n  // or a type-parameterized test.\n  const char* type_param() const {\n    if (type_param_.get() != NULL)\n      return type_param_->c_str();\n    return NULL;\n  }\n\n  // Returns the text representation of the value parameter, or NULL if this\n  // is not a value-parameterized test.\n  const char* value_param() const {\n    if (value_param_.get() != NULL)\n      return value_param_->c_str();\n    return NULL;\n  }\n\n  // Returns the file name where this test is defined.\n  const char* file() const { return location_.file.c_str(); }\n\n  // Returns the line where this test is defined.\n  int line() const { return location_.line; }\n\n  // Returns true if this test should run, that is if the test is not\n  // disabled (or it is disabled but the also_run_disabled_tests flag has\n  // been specified) and its full name matches the user-specified filter.\n  //\n  // Google Test allows the user to filter the tests by their full names.\n  // The full name of a test Bar in test case Foo is defined as\n  // \"Foo.Bar\".  Only the tests that match the filter will run.\n  //\n  // A filter is a colon-separated list of glob (not regex) patterns,\n  // optionally followed by a '-' and a colon-separated list of\n  // negative patterns (tests to exclude).  A test is run if it\n  // matches one of the positive patterns and does not match any of\n  // the negative patterns.\n  //\n  // For example, *A*:Foo.* is a filter that matches any string that\n  // contains the character 'A' or starts with \"Foo.\".\n  bool should_run() const { return should_run_; }\n\n  // Returns true iff this test will appear in the XML report.\n  bool is_reportable() const {\n    // For now, the XML report includes all tests matching the filter.\n    // In the future, we may trim tests that are excluded because of\n    // sharding.\n    return matches_filter_;\n  }\n\n  // Returns the result of the test.\n  const TestResult* result() const { return &result_; }\n\n private:\n#if GTEST_HAS_DEATH_TEST\n  friend class internal::DefaultDeathTestFactory;\n#endif  // GTEST_HAS_DEATH_TEST\n  friend class Test;\n  friend class TestCase;\n  friend class internal::UnitTestImpl;\n  friend class internal::StreamingListenerTest;\n  friend TestInfo* internal::MakeAndRegisterTestInfo(\n      const char* test_case_name,\n      const char* name,\n      const char* type_param,\n      const char* value_param,\n      internal::CodeLocation code_location,\n      internal::TypeId fixture_class_id,\n      Test::SetUpTestCaseFunc set_up_tc,\n      Test::TearDownTestCaseFunc tear_down_tc,\n      internal::TestFactoryBase* factory);\n\n  // Constructs a TestInfo object. The newly constructed instance assumes\n  // ownership of the factory object.\n  TestInfo(const std::string& test_case_name,\n           const std::string& name,\n           const char* a_type_param,   // NULL if not a type-parameterized test\n           const char* a_value_param,  // NULL if not a value-parameterized test\n           internal::CodeLocation a_code_location,\n           internal::TypeId fixture_class_id,\n           internal::TestFactoryBase* factory);\n\n  // Increments the number of death tests encountered in this test so\n  // far.\n  int increment_death_test_count() {\n    return result_.increment_death_test_count();\n  }\n\n  // Creates the test object, runs it, records its result, and then\n  // deletes it.\n  void Run();\n\n  static void ClearTestResult(TestInfo* test_info) {\n    test_info->result_.Clear();\n  }\n\n  // These fields are immutable properties of the test.\n  const std::string test_case_name_;     // Test case name\n  const std::string name_;               // Test name\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const internal::scoped_ptr<const ::std::string> type_param_;\n  // Text representation of the value parameter, or NULL if this is not a\n  // value-parameterized test.\n  const internal::scoped_ptr<const ::std::string> value_param_;\n  internal::CodeLocation location_;\n  const internal::TypeId fixture_class_id_;   // ID of the test fixture class\n  bool should_run_;                 // True iff this test should run\n  bool is_disabled_;                // True iff this test is disabled\n  bool matches_filter_;             // True if this test matches the\n                                    // user-specified filter.\n  internal::TestFactoryBase* const factory_;  // The factory that creates\n                                              // the test object\n\n  // This field is mutable and needs to be reset before running the\n  // test for the second time.\n  TestResult result_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestInfo);\n};\n\n// A test case, which consists of a vector of TestInfos.\n//\n// TestCase is not copyable.\nclass GTEST_API_ TestCase {\n public:\n  // Creates a TestCase with the given name.\n  //\n  // TestCase does NOT have a default constructor.  Always use this\n  // constructor to create a TestCase object.\n  //\n  // Arguments:\n  //\n  //   name:         name of the test case\n  //   a_type_param: the name of the test's type parameter, or NULL if\n  //                 this is not a type-parameterized test.\n  //   set_up_tc:    pointer to the function that sets up the test case\n  //   tear_down_tc: pointer to the function that tears down the test case\n  TestCase(const char* name, const char* a_type_param,\n           Test::SetUpTestCaseFunc set_up_tc,\n           Test::TearDownTestCaseFunc tear_down_tc);\n\n  // Destructor of TestCase.\n  virtual ~TestCase();\n\n  // Gets the name of the TestCase.\n  const char* name() const { return name_.c_str(); }\n\n  // Returns the name of the parameter type, or NULL if this is not a\n  // type-parameterized test case.\n  const char* type_param() const {\n    if (type_param_.get() != NULL)\n      return type_param_->c_str();\n    return NULL;\n  }\n\n  // Returns true if any test in this test case should run.\n  bool should_run() const { return should_run_; }\n\n  // Gets the number of successful tests in this test case.\n  int successful_test_count() const;\n\n  // Gets the number of failed tests in this test case.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests in this test case.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Get the number of tests in this test case that should run.\n  int test_to_run_count() const;\n\n  // Gets the number of all tests in this test case.\n  int total_test_count() const;\n\n  // Returns true iff the test case passed.\n  bool Passed() const { return !Failed(); }\n\n  // Returns true iff the test case failed.\n  bool Failed() const { return failed_test_count() > 0; }\n\n  // Returns the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const { return elapsed_time_; }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  const TestInfo* GetTestInfo(int i) const;\n\n  // Returns the TestResult that holds test properties recorded during\n  // execution of SetUpTestCase and TearDownTestCase.\n  const TestResult& ad_hoc_test_result() const { return ad_hoc_test_result_; }\n\n private:\n  friend class Test;\n  friend class internal::UnitTestImpl;\n\n  // Gets the (mutable) vector of TestInfos in this TestCase.\n  std::vector<TestInfo*>& test_info_list() { return test_info_list_; }\n\n  // Gets the (immutable) vector of TestInfos in this TestCase.\n  const std::vector<TestInfo*>& test_info_list() const {\n    return test_info_list_;\n  }\n\n  // Returns the i-th test among all the tests. i can range from 0 to\n  // total_test_count() - 1. If i is not in that range, returns NULL.\n  TestInfo* GetMutableTestInfo(int i);\n\n  // Sets the should_run member.\n  void set_should_run(bool should) { should_run_ = should; }\n\n  // Adds a TestInfo to this test case.  Will delete the TestInfo upon\n  // destruction of the TestCase object.\n  void AddTestInfo(TestInfo * test_info);\n\n  // Clears the results of all tests in this test case.\n  void ClearResult();\n\n  // Clears the results of all tests in the given test case.\n  static void ClearTestCaseResult(TestCase* test_case) {\n    test_case->ClearResult();\n  }\n\n  // Runs every test in this TestCase.\n  void Run();\n\n  // Runs SetUpTestCase() for this TestCase.  This wrapper is needed\n  // for catching exceptions thrown from SetUpTestCase().\n  void RunSetUpTestCase() { (*set_up_tc_)(); }\n\n  // Runs TearDownTestCase() for this TestCase.  This wrapper is\n  // needed for catching exceptions thrown from TearDownTestCase().\n  void RunTearDownTestCase() { (*tear_down_tc_)(); }\n\n  // Returns true iff test passed.\n  static bool TestPassed(const TestInfo* test_info) {\n    return test_info->should_run() && test_info->result()->Passed();\n  }\n\n  // Returns true iff test failed.\n  static bool TestFailed(const TestInfo* test_info) {\n    return test_info->should_run() && test_info->result()->Failed();\n  }\n\n  // Returns true iff the test is disabled and will be reported in the XML\n  // report.\n  static bool TestReportableDisabled(const TestInfo* test_info) {\n    return test_info->is_reportable() && test_info->is_disabled_;\n  }\n\n  // Returns true iff test is disabled.\n  static bool TestDisabled(const TestInfo* test_info) {\n    return test_info->is_disabled_;\n  }\n\n  // Returns true iff this test will appear in the XML report.\n  static bool TestReportable(const TestInfo* test_info) {\n    return test_info->is_reportable();\n  }\n\n  // Returns true if the given test should run.\n  static bool ShouldRunTest(const TestInfo* test_info) {\n    return test_info->should_run();\n  }\n\n  // Shuffles the tests in this test case.\n  void ShuffleTests(internal::Random* random);\n\n  // Restores the test order to before the first shuffle.\n  void UnshuffleTests();\n\n  // Name of the test case.\n  std::string name_;\n  // Name of the parameter type, or NULL if this is not a typed or a\n  // type-parameterized test.\n  const internal::scoped_ptr<const ::std::string> type_param_;\n  // The vector of TestInfos in their original order.  It owns the\n  // elements in the vector.\n  std::vector<TestInfo*> test_info_list_;\n  // Provides a level of indirection for the test list to allow easy\n  // shuffling and restoring the test order.  The i-th element in this\n  // vector is the index of the i-th test in the shuffled test list.\n  std::vector<int> test_indices_;\n  // Pointer to the function that sets up the test case.\n  Test::SetUpTestCaseFunc set_up_tc_;\n  // Pointer to the function that tears down the test case.\n  Test::TearDownTestCaseFunc tear_down_tc_;\n  // True iff any test in this test case should run.\n  bool should_run_;\n  // Elapsed time, in milliseconds.\n  TimeInMillis elapsed_time_;\n  // Holds test properties recorded during execution of SetUpTestCase and\n  // TearDownTestCase.\n  TestResult ad_hoc_test_result_;\n\n  // We disallow copying TestCases.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestCase);\n};\n\n// An Environment object is capable of setting up and tearing down an\n// environment.  You should subclass this to define your own\n// environment(s).\n//\n// An Environment object does the set-up and tear-down in virtual\n// methods SetUp() and TearDown() instead of the constructor and the\n// destructor, as:\n//\n//   1. You cannot safely throw from a destructor.  This is a problem\n//      as in some cases Google Test is used where exceptions are enabled, and\n//      we may want to implement ASSERT_* using exceptions where they are\n//      available.\n//   2. You cannot use ASSERT_* directly in a constructor or\n//      destructor.\nclass Environment {\n public:\n  // The d'tor is virtual as we need to subclass Environment.\n  virtual ~Environment() {}\n\n  // Override this to define how to set up the environment.\n  virtual void SetUp() {}\n\n  // Override this to define how to tear down the environment.\n  virtual void TearDown() {}\n private:\n  // If you see an error about overriding the following function or\n  // about it being private, you have mis-spelled SetUp() as Setup().\n  struct Setup_should_be_spelled_SetUp {};\n  virtual Setup_should_be_spelled_SetUp* Setup() { return NULL; }\n};\n\n// The interface for tracing execution of tests. The methods are organized in\n// the order the corresponding events are fired.\nclass TestEventListener {\n public:\n  virtual ~TestEventListener() {}\n\n  // Fired before any test activity starts.\n  virtual void OnTestProgramStart(const UnitTest& unit_test) = 0;\n\n  // Fired before each iteration of tests starts.  There may be more than\n  // one iteration if GTEST_FLAG(repeat) is set. iteration is the iteration\n  // index, starting from 0.\n  virtual void OnTestIterationStart(const UnitTest& unit_test,\n                                    int iteration) = 0;\n\n  // Fired before environment set-up for each iteration of tests starts.\n  virtual void OnEnvironmentsSetUpStart(const UnitTest& unit_test) = 0;\n\n  // Fired after environment set-up for each iteration of tests ends.\n  virtual void OnEnvironmentsSetUpEnd(const UnitTest& unit_test) = 0;\n\n  // Fired before the test case starts.\n  virtual void OnTestCaseStart(const TestCase& test_case) = 0;\n\n  // Fired before the test starts.\n  virtual void OnTestStart(const TestInfo& test_info) = 0;\n\n  // Fired after a failed assertion or a SUCCEED() invocation.\n  virtual void OnTestPartResult(const TestPartResult& test_part_result) = 0;\n\n  // Fired after the test ends.\n  virtual void OnTestEnd(const TestInfo& test_info) = 0;\n\n  // Fired after the test case ends.\n  virtual void OnTestCaseEnd(const TestCase& test_case) = 0;\n\n  // Fired before environment tear-down for each iteration of tests starts.\n  virtual void OnEnvironmentsTearDownStart(const UnitTest& unit_test) = 0;\n\n  // Fired after environment tear-down for each iteration of tests ends.\n  virtual void OnEnvironmentsTearDownEnd(const UnitTest& unit_test) = 0;\n\n  // Fired after each iteration of tests finishes.\n  virtual void OnTestIterationEnd(const UnitTest& unit_test,\n                                  int iteration) = 0;\n\n  // Fired after all test activities have ended.\n  virtual void OnTestProgramEnd(const UnitTest& unit_test) = 0;\n};\n\n// The convenience class for users who need to override just one or two\n// methods and are not concerned that a possible change to a signature of\n// the methods they override will not be caught during the build.  For\n// comments about each method please see the definition of TestEventListener\n// above.\nclass EmptyTestEventListener : public TestEventListener {\n public:\n  virtual void OnTestProgramStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestIterationStart(const UnitTest& /*unit_test*/,\n                                    int /*iteration*/) {}\n  virtual void OnEnvironmentsSetUpStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnEnvironmentsSetUpEnd(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestCaseStart(const TestCase& /*test_case*/) {}\n  virtual void OnTestStart(const TestInfo& /*test_info*/) {}\n  virtual void OnTestPartResult(const TestPartResult& /*test_part_result*/) {}\n  virtual void OnTestEnd(const TestInfo& /*test_info*/) {}\n  virtual void OnTestCaseEnd(const TestCase& /*test_case*/) {}\n  virtual void OnEnvironmentsTearDownStart(const UnitTest& /*unit_test*/) {}\n  virtual void OnEnvironmentsTearDownEnd(const UnitTest& /*unit_test*/) {}\n  virtual void OnTestIterationEnd(const UnitTest& /*unit_test*/,\n                                  int /*iteration*/) {}\n  virtual void OnTestProgramEnd(const UnitTest& /*unit_test*/) {}\n};\n\n// TestEventListeners lets users add listeners to track events in Google Test.\nclass GTEST_API_ TestEventListeners {\n public:\n  TestEventListeners();\n  ~TestEventListeners();\n\n  // Appends an event listener to the end of the list. Google Test assumes\n  // the ownership of the listener (i.e. it will delete the listener when\n  // the test program finishes).\n  void Append(TestEventListener* listener);\n\n  // Removes the given event listener from the list and returns it.  It then\n  // becomes the caller's responsibility to delete the listener. Returns\n  // NULL if the listener is not found in the list.\n  TestEventListener* Release(TestEventListener* listener);\n\n  // Returns the standard listener responsible for the default console\n  // output.  Can be removed from the listeners list to shut down default\n  // console output.  Note that removing this object from the listener list\n  // with Release transfers its ownership to the caller and makes this\n  // function return NULL the next time.\n  TestEventListener* default_result_printer() const {\n    return default_result_printer_;\n  }\n\n  // Returns the standard listener responsible for the default XML output\n  // controlled by the --gtest_output=xml flag.  Can be removed from the\n  // listeners list by users who want to shut down the default XML output\n  // controlled by this flag and substitute it with custom one.  Note that\n  // removing this object from the listener list with Release transfers its\n  // ownership to the caller and makes this function return NULL the next\n  // time.\n  TestEventListener* default_xml_generator() const {\n    return default_xml_generator_;\n  }\n\n private:\n  friend class TestCase;\n  friend class TestInfo;\n  friend class internal::DefaultGlobalTestPartResultReporter;\n  friend class internal::NoExecDeathTest;\n  friend class internal::TestEventListenersAccessor;\n  friend class internal::UnitTestImpl;\n\n  // Returns repeater that broadcasts the TestEventListener events to all\n  // subscribers.\n  TestEventListener* repeater();\n\n  // Sets the default_result_printer attribute to the provided listener.\n  // The listener is also added to the listener list and previous\n  // default_result_printer is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultResultPrinter(TestEventListener* listener);\n\n  // Sets the default_xml_generator attribute to the provided listener.  The\n  // listener is also added to the listener list and previous\n  // default_xml_generator is removed from it and deleted. The listener can\n  // also be NULL in which case it will not be added to the list. Does\n  // nothing if the previous and the current listener objects are the same.\n  void SetDefaultXmlGenerator(TestEventListener* listener);\n\n  // Controls whether events will be forwarded by the repeater to the\n  // listeners in the list.\n  bool EventForwardingEnabled() const;\n  void SuppressEventForwarding();\n\n  // The actual list of listeners.\n  internal::TestEventRepeater* repeater_;\n  // Listener responsible for the standard result output.\n  TestEventListener* default_result_printer_;\n  // Listener responsible for the creation of the XML output file.\n  TestEventListener* default_xml_generator_;\n\n  // We disallow copying TestEventListeners.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventListeners);\n};\n\n// A UnitTest consists of a vector of TestCases.\n//\n// This is a singleton class.  The only instance of UnitTest is\n// created when UnitTest::GetInstance() is first called.  This\n// instance is never deleted.\n//\n// UnitTest is not copyable.\n//\n// This class is thread-safe as long as the methods are called\n// according to their specification.\nclass GTEST_API_ UnitTest {\n public:\n  // Gets the singleton UnitTest object.  The first time this method\n  // is called, a UnitTest object is constructed and returned.\n  // Consecutive calls will return the same object.\n  static UnitTest* GetInstance();\n\n  // Runs all tests in this UnitTest object and prints the result.\n  // Returns 0 if successful, or 1 otherwise.\n  //\n  // This method can only be called from the main thread.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  int Run() GTEST_MUST_USE_RESULT_;\n\n  // Returns the working directory when the first TEST() or TEST_F()\n  // was executed.  The UnitTest object owns the string.\n  const char* original_working_dir() const;\n\n  // Returns the TestCase object for the test that's currently running,\n  // or NULL if no test is running.\n  const TestCase* current_test_case() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Returns the TestInfo object for the test that's currently running,\n  // or NULL if no test is running.\n  const TestInfo* current_test_info() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Returns the random seed used at the start of the current test run.\n  int random_seed() const;\n\n#if GTEST_HAS_PARAM_TEST\n  // Returns the ParameterizedTestCaseRegistry object used to keep track of\n  // value-parameterized tests and instantiate and register them.\n  //\n  // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n  internal::ParameterizedTestCaseRegistry& parameterized_test_registry()\n      GTEST_LOCK_EXCLUDED_(mutex_);\n#endif  // GTEST_HAS_PARAM_TEST\n\n  // Gets the number of successful test cases.\n  int successful_test_case_count() const;\n\n  // Gets the number of failed test cases.\n  int failed_test_case_count() const;\n\n  // Gets the number of all test cases.\n  int total_test_case_count() const;\n\n  // Gets the number of all test cases that contain at least one test\n  // that should run.\n  int test_case_to_run_count() const;\n\n  // Gets the number of successful tests.\n  int successful_test_count() const;\n\n  // Gets the number of failed tests.\n  int failed_test_count() const;\n\n  // Gets the number of disabled tests that will be reported in the XML report.\n  int reportable_disabled_test_count() const;\n\n  // Gets the number of disabled tests.\n  int disabled_test_count() const;\n\n  // Gets the number of tests to be printed in the XML report.\n  int reportable_test_count() const;\n\n  // Gets the number of all tests.\n  int total_test_count() const;\n\n  // Gets the number of tests that should run.\n  int test_to_run_count() const;\n\n  // Gets the time of the test program start, in ms from the start of the\n  // UNIX epoch.\n  TimeInMillis start_timestamp() const;\n\n  // Gets the elapsed time, in milliseconds.\n  TimeInMillis elapsed_time() const;\n\n  // Returns true iff the unit test passed (i.e. all test cases passed).\n  bool Passed() const;\n\n  // Returns true iff the unit test failed (i.e. some test case failed\n  // or something outside of all tests failed).\n  bool Failed() const;\n\n  // Gets the i-th test case among all the test cases. i can range from 0 to\n  // total_test_case_count() - 1. If i is not in that range, returns NULL.\n  const TestCase* GetTestCase(int i) const;\n\n  // Returns the TestResult containing information on test failures and\n  // properties logged outside of individual test cases.\n  const TestResult& ad_hoc_test_result() const;\n\n  // Returns the list of event listeners that can be used to track events\n  // inside Google Test.\n  TestEventListeners& listeners();\n\n private:\n  // Registers and returns a global test environment.  When a test\n  // program is run, all global test environments will be set-up in\n  // the order they were registered.  After all tests in the program\n  // have finished, all global test environments will be torn-down in\n  // the *reverse* order they were registered.\n  //\n  // The UnitTest object takes ownership of the given environment.\n  //\n  // This method can only be called from the main thread.\n  Environment* AddEnvironment(Environment* env);\n\n  // Adds a TestPartResult to the current TestResult object.  All\n  // Google Test assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc)\n  // eventually call this to report their results.  The user code\n  // should use the assertion macros instead of calling this directly.\n  void AddTestPartResult(TestPartResult::Type result_type,\n                         const char* file_name,\n                         int line_number,\n                         const std::string& message,\n                         const std::string& os_stack_trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Adds a TestProperty to the current TestResult object when invoked from\n  // inside a test, to current TestCase's ad_hoc_test_result_ when invoked\n  // from SetUpTestCase or TearDownTestCase, or to the global property set\n  // when invoked elsewhere.  If the result already contains a property with\n  // the same key, the value will be updated.\n  void RecordProperty(const std::string& key, const std::string& value);\n\n  // Gets the i-th test case among all the test cases. i can range from 0 to\n  // total_test_case_count() - 1. If i is not in that range, returns NULL.\n  TestCase* GetMutableTestCase(int i);\n\n  // Accessors for the implementation object.\n  internal::UnitTestImpl* impl() { return impl_; }\n  const internal::UnitTestImpl* impl() const { return impl_; }\n\n  // These classes and funcions are friends as they need to access private\n  // members of UnitTest.\n  friend class Test;\n  friend class internal::AssertHelper;\n  friend class internal::ScopedTrace;\n  friend class internal::StreamingListenerTest;\n  friend class internal::UnitTestRecordPropertyTestHelper;\n  friend Environment* AddGlobalTestEnvironment(Environment* env);\n  friend internal::UnitTestImpl* internal::GetUnitTestImpl();\n  friend void internal::ReportFailureInUnknownLocation(\n      TestPartResult::Type result_type,\n      const std::string& message);\n\n  // Creates an empty UnitTest.\n  UnitTest();\n\n  // D'tor\n  virtual ~UnitTest();\n\n  // Pushes a trace defined by SCOPED_TRACE() on to the per-thread\n  // Google Test trace stack.\n  void PushGTestTrace(const internal::TraceInfo& trace)\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Pops a trace from the per-thread Google Test trace stack.\n  void PopGTestTrace()\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  // Protects mutable state in *impl_.  This is mutable as some const\n  // methods need to lock it too.\n  mutable internal::Mutex mutex_;\n\n  // Opaque implementation object.  This field is never changed once\n  // the object is constructed.  We don't mark it as const here, as\n  // doing so will cause a warning in the constructor of UnitTest.\n  // Mutable state in *impl_ is protected by mutex_.\n  internal::UnitTestImpl* impl_;\n\n  // We disallow copying UnitTest.\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(UnitTest);\n};\n\n// A convenient wrapper for adding an environment for the test\n// program.\n//\n// You should call this before RUN_ALL_TESTS() is called, probably in\n// main().  If you use gtest_main, you need to call this before main()\n// starts for it to take effect.  For example, you can define a global\n// variable like this:\n//\n//   testing::Environment* const foo_env =\n//       testing::AddGlobalTestEnvironment(new FooEnvironment);\n//\n// However, we strongly recommend you to write your own main() and\n// call AddGlobalTestEnvironment() there, as relying on initialization\n// of global variables makes the code harder to read and may cause\n// problems when you register multiple environments from different\n// translation units and the environments have dependencies among them\n// (remember that the compiler doesn't guarantee the order in which\n// global variables from different translation units are initialized).\ninline Environment* AddGlobalTestEnvironment(Environment* env) {\n  return UnitTest::GetInstance()->AddEnvironment(env);\n}\n\n// Initializes Google Test.  This must be called before calling\n// RUN_ALL_TESTS().  In particular, it parses a command line for the\n// flags that Google Test recognizes.  Whenever a Google Test flag is\n// seen, it is removed from argv, and *argc is decremented.\n//\n// No value is returned.  Instead, the Google Test flag variables are\n// updated.\n//\n// Calling the function for the second time has no user-visible effect.\nGTEST_API_ void InitGoogleTest(int* argc, char** argv);\n\n// This overloaded version can be used in Windows programs compiled in\n// UNICODE mode.\nGTEST_API_ void InitGoogleTest(int* argc, wchar_t** argv);\n\nnamespace internal {\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperEQ. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_* in a tight loop.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperEQFailure(const char* lhs_expression,\n                                   const char* rhs_expression,\n                                   const T1& lhs, const T2& rhs) {\n  return EqFailure(lhs_expression,\n                   rhs_expression,\n                   FormatForComparisonFailureMessage(lhs, rhs),\n                   FormatForComparisonFailureMessage(rhs, lhs),\n                   false);\n}\n\n// The helper function for {ASSERT|EXPECT}_EQ.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperEQ(const char* lhs_expression,\n                            const char* rhs_expression,\n                            const T1& lhs,\n                            const T2& rhs) {\nGTEST_DISABLE_MSC_WARNINGS_PUSH_(4389 /* signed/unsigned mismatch */)\n  if (lhs == rhs) {\n    return AssertionSuccess();\n  }\nGTEST_DISABLE_MSC_WARNINGS_POP_()\n\n  return CmpHelperEQFailure(lhs_expression, rhs_expression, lhs, rhs);\n}\n\n// With this overloaded version, we allow anonymous enums to be used\n// in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous enums\n// can be implicitly cast to BiggestInt.\nGTEST_API_ AssertionResult CmpHelperEQ(const char* lhs_expression,\n                                       const char* rhs_expression,\n                                       BiggestInt lhs,\n                                       BiggestInt rhs);\n\n// The helper class for {ASSERT|EXPECT}_EQ.  The template argument\n// lhs_is_null_literal is true iff the first argument to ASSERT_EQ()\n// is a null pointer literal.  The following default implementation is\n// for lhs_is_null_literal being false.\ntemplate <bool lhs_is_null_literal>\nclass EqHelper {\n public:\n  // This templatized version is for the general case.\n  template <typename T1, typename T2>\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression,\n                                 const T1& lhs,\n                                 const T2& rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  // With this overloaded version, we allow anonymous enums to be used\n  // in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous\n  // enums can be implicitly cast to BiggestInt.\n  //\n  // Even though its body looks the same as the above version, we\n  // cannot merge the two, as it will make anonymous enums unhappy.\n  static AssertionResult Compare(const char* lhs_expression,\n                                 const char* rhs_expression,\n                                 BiggestInt lhs,\n                                 BiggestInt rhs) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n};\n\n// This specialization is used when the first argument to ASSERT_EQ()\n// is a null pointer literal, like NULL, false, or 0.\ntemplate <>\nclass EqHelper<true> {\n public:\n  // We define two overloaded versions of Compare().  The first\n  // version will be picked when the second argument to ASSERT_EQ() is\n  // NOT a pointer, e.g. ASSERT_EQ(0, AnIntFunction()) or\n  // EXPECT_EQ(false, a_bool).\n  template <typename T1, typename T2>\n  static AssertionResult Compare(\n      const char* lhs_expression,\n      const char* rhs_expression,\n      const T1& lhs,\n      const T2& rhs,\n      // The following line prevents this overload from being considered if T2\n      // is not a pointer type.  We need this because ASSERT_EQ(NULL, my_ptr)\n      // expands to Compare(\"\", \"\", NULL, my_ptr), which requires a conversion\n      // to match the Secret* in the other overload, which would otherwise make\n      // this template match better.\n      typename EnableIf<!is_pointer<T2>::value>::type* = 0) {\n    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);\n  }\n\n  // This version will be picked when the second argument to ASSERT_EQ() is a\n  // pointer, e.g. ASSERT_EQ(NULL, a_pointer).\n  template <typename T>\n  static AssertionResult Compare(\n      const char* lhs_expression,\n      const char* rhs_expression,\n      // We used to have a second template parameter instead of Secret*.  That\n      // template parameter would deduce to 'long', making this a better match\n      // than the first overload even without the first overload's EnableIf.\n      // Unfortunately, gcc with -Wconversion-null warns when \"passing NULL to\n      // non-pointer argument\" (even a deduced integral argument), so the old\n      // implementation caused warnings in user code.\n      Secret* /* lhs (NULL) */,\n      T* rhs) {\n    // We already know that 'lhs' is a null pointer.\n    return CmpHelperEQ(lhs_expression, rhs_expression,\n                       static_cast<T*>(NULL), rhs);\n  }\n};\n\n// Separate the error generating code from the code path to reduce the stack\n// frame size of CmpHelperOP. This helps reduce the overhead of some sanitizers\n// when calling EXPECT_OP in a tight loop.\ntemplate <typename T1, typename T2>\nAssertionResult CmpHelperOpFailure(const char* expr1, const char* expr2,\n                                   const T1& val1, const T2& val2,\n                                   const char* op) {\n  return AssertionFailure()\n         << \"Expected: (\" << expr1 << \") \" << op << \" (\" << expr2\n         << \"), actual: \" << FormatForComparisonFailureMessage(val1, val2)\n         << \" vs \" << FormatForComparisonFailureMessage(val2, val1);\n}\n\n// A macro for implementing the helper functions needed to implement\n// ASSERT_?? and EXPECT_??.  It is here just to avoid copy-and-paste\n// of similar code.\n//\n// For each templatized helper function, we also define an overloaded\n// version for BiggestInt in order to reduce code bloat and allow\n// anonymous enums to be used with {ASSERT|EXPECT}_?? when compiled\n// with gcc 4.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n#define GTEST_IMPL_CMP_HELPER_(op_name, op)\\\ntemplate <typename T1, typename T2>\\\nAssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \\\n                                   const T1& val1, const T2& val2) {\\\n  if (val1 op val2) {\\\n    return AssertionSuccess();\\\n  } else {\\\n    return CmpHelperOpFailure(expr1, expr2, val1, val2, #op);\\\n  }\\\n}\\\nGTEST_API_ AssertionResult CmpHelper##op_name(\\\n    const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2)\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\n\n// Implements the helper function for {ASSERT|EXPECT}_NE\nGTEST_IMPL_CMP_HELPER_(NE, !=);\n// Implements the helper function for {ASSERT|EXPECT}_LE\nGTEST_IMPL_CMP_HELPER_(LE, <=);\n// Implements the helper function for {ASSERT|EXPECT}_LT\nGTEST_IMPL_CMP_HELPER_(LT, <);\n// Implements the helper function for {ASSERT|EXPECT}_GE\nGTEST_IMPL_CMP_HELPER_(GE, >=);\n// Implements the helper function for {ASSERT|EXPECT}_GT\nGTEST_IMPL_CMP_HELPER_(GT, >);\n\n#undef GTEST_IMPL_CMP_HELPER_\n\n// The helper function for {ASSERT|EXPECT}_STREQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1,\n                                          const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASEEQ.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASEEQ(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1,\n                                              const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRNE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const char* s1,\n                                          const char* s2);\n\n// The helper function for {ASSERT|EXPECT}_STRCASENE.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRCASENE(const char* s1_expression,\n                                              const char* s2_expression,\n                                              const char* s1,\n                                              const char* s2);\n\n\n// Helper function for *_STREQ on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTREQ(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1,\n                                          const wchar_t* s2);\n\n// Helper function for *_STRNE on wide strings.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult CmpHelperSTRNE(const char* s1_expression,\n                                          const char* s2_expression,\n                                          const wchar_t* s1,\n                                          const wchar_t* s2);\n\n}  // namespace internal\n\n// IsSubstring() and IsNotSubstring() are intended to be used as the\n// first argument to {EXPECT,ASSERT}_PRED_FORMAT2(), not by\n// themselves.  They check whether needle is a substring of haystack\n// (NULL is considered a substring of itself only), and return an\n// appropriate error message when they fail.\n//\n// The {needle,haystack}_expr arguments are the stringified\n// expressions that generated the two real arguments.\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const char* needle, const char* haystack);\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const wchar_t* needle, const wchar_t* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const char* needle, const char* haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const wchar_t* needle, const wchar_t* haystack);\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::string& needle, const ::std::string& haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::string& needle, const ::std::string& haystack);\n\n#if GTEST_HAS_STD_WSTRING\nGTEST_API_ AssertionResult IsSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::wstring& needle, const ::std::wstring& haystack);\nGTEST_API_ AssertionResult IsNotSubstring(\n    const char* needle_expr, const char* haystack_expr,\n    const ::std::wstring& needle, const ::std::wstring& haystack);\n#endif  // GTEST_HAS_STD_WSTRING\n\nnamespace internal {\n\n// Helper template function for comparing floating-points.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\ntemplate <typename RawType>\nAssertionResult CmpHelperFloatingPointEQ(const char* lhs_expression,\n                                         const char* rhs_expression,\n                                         RawType lhs_value,\n                                         RawType rhs_value) {\n  const FloatingPoint<RawType> lhs(lhs_value), rhs(rhs_value);\n\n  if (lhs.AlmostEquals(rhs)) {\n    return AssertionSuccess();\n  }\n\n  ::std::stringstream lhs_ss;\n  lhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\n         << lhs_value;\n\n  ::std::stringstream rhs_ss;\n  rhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)\n         << rhs_value;\n\n  return EqFailure(lhs_expression,\n                   rhs_expression,\n                   StringStreamToString(&lhs_ss),\n                   StringStreamToString(&rhs_ss),\n                   false);\n}\n\n// Helper function for implementing ASSERT_NEAR.\n//\n// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.\nGTEST_API_ AssertionResult DoubleNearPredFormat(const char* expr1,\n                                                const char* expr2,\n                                                const char* abs_error_expr,\n                                                double val1,\n                                                double val2,\n                                                double abs_error);\n\n// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.\n// A class that enables one to stream messages to assertion macros\nclass GTEST_API_ AssertHelper {\n public:\n  // Constructor.\n  AssertHelper(TestPartResult::Type type,\n               const char* file,\n               int line,\n               const char* message);\n  ~AssertHelper();\n\n  // Message assignment is a semantic trick to enable assertion\n  // streaming; see the GTEST_MESSAGE_ macro below.\n  void operator=(const Message& message) const;\n\n private:\n  // We put our data in a struct so that the size of the AssertHelper class can\n  // be as small as possible.  This is important because gcc is incapable of\n  // re-using stack space even for temporary variables, so every EXPECT_EQ\n  // reserves stack space for another AssertHelper.\n  struct AssertHelperData {\n    AssertHelperData(TestPartResult::Type t,\n                     const char* srcfile,\n                     int line_num,\n                     const char* msg)\n        : type(t), file(srcfile), line(line_num), message(msg) { }\n\n    TestPartResult::Type const type;\n    const char* const file;\n    int const line;\n    std::string const message;\n\n   private:\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelperData);\n  };\n\n  AssertHelperData* const data_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelper);\n};\n\n}  // namespace internal\n\n#if GTEST_HAS_PARAM_TEST\n// The pure interface class that all value-parameterized tests inherit from.\n// A value-parameterized class must inherit from both ::testing::Test and\n// ::testing::WithParamInterface. In most cases that just means inheriting\n// from ::testing::TestWithParam, but more complicated test hierarchies\n// may need to inherit from Test and WithParamInterface at different levels.\n//\n// This interface has support for accessing the test parameter value via\n// the GetParam() method.\n//\n// Use it with one of the parameter generator defining functions, like Range(),\n// Values(), ValuesIn(), Bool(), and Combine().\n//\n// class FooTest : public ::testing::TestWithParam<int> {\n//  protected:\n//   FooTest() {\n//     // Can use GetParam() here.\n//   }\n//   virtual ~FooTest() {\n//     // Can use GetParam() here.\n//   }\n//   virtual void SetUp() {\n//     // Can use GetParam() here.\n//   }\n//   virtual void TearDown {\n//     // Can use GetParam() here.\n//   }\n// };\n// TEST_P(FooTest, DoesBar) {\n//   // Can use GetParam() method here.\n//   Foo foo;\n//   ASSERT_TRUE(foo.DoesBar(GetParam()));\n// }\n// INSTANTIATE_TEST_CASE_P(OneToTenRange, FooTest, ::testing::Range(1, 10));\n\ntemplate <typename T>\nclass WithParamInterface {\n public:\n  typedef T ParamType;\n  virtual ~WithParamInterface() {}\n\n  // The current parameter value. Is also available in the test fixture's\n  // constructor. This member function is non-static, even though it only\n  // references static data, to reduce the opportunity for incorrect uses\n  // like writing 'WithParamInterface<bool>::GetParam()' for a test that\n  // uses a fixture whose parameter type is int.\n  const ParamType& GetParam() const {\n    GTEST_CHECK_(parameter_ != NULL)\n        << \"GetParam() can only be called inside a value-parameterized test \"\n        << \"-- did you intend to write TEST_P instead of TEST_F?\";\n    return *parameter_;\n  }\n\n private:\n  // Sets parameter value. The caller is responsible for making sure the value\n  // remains alive and unchanged throughout the current test.\n  static void SetParam(const ParamType* parameter) {\n    parameter_ = parameter;\n  }\n\n  // Static value used for accessing parameter during a test lifetime.\n  static const ParamType* parameter_;\n\n  // TestClass must be a subclass of WithParamInterface<T> and Test.\n  template <class TestClass> friend class internal::ParameterizedTestFactory;\n};\n\ntemplate <typename T>\nconst T* WithParamInterface<T>::parameter_ = NULL;\n\n// Most value-parameterized classes can ignore the existence of\n// WithParamInterface, and can just inherit from ::testing::TestWithParam.\n\ntemplate <typename T>\nclass TestWithParam : public Test, public WithParamInterface<T> {\n};\n\n#endif  // GTEST_HAS_PARAM_TEST\n\n// Macros for indicating success/failure in test code.\n\n// ADD_FAILURE unconditionally adds a failure to the current test.\n// SUCCEED generates a success - it doesn't automatically make the\n// current test successful, as a test is only successful when it has\n// no failure.\n//\n// EXPECT_* verifies that a certain condition is satisfied.  If not,\n// it behaves like ADD_FAILURE.  In particular:\n//\n//   EXPECT_TRUE  verifies that a Boolean condition is true.\n//   EXPECT_FALSE verifies that a Boolean condition is false.\n//\n// FAIL and ASSERT_* are similar to ADD_FAILURE and EXPECT_*, except\n// that they will also abort the current function on failure.  People\n// usually want the fail-fast behavior of FAIL and ASSERT_*, but those\n// writing data-driven tests often find themselves using ADD_FAILURE\n// and EXPECT_* more.\n\n// Generates a nonfatal failure with a generic message.\n#define ADD_FAILURE() GTEST_NONFATAL_FAILURE_(\"Failed\")\n\n// Generates a nonfatal failure at the given source file location with\n// a generic message.\n#define ADD_FAILURE_AT(file, line) \\\n  GTEST_MESSAGE_AT_(file, line, \"Failed\", \\\n                    ::testing::TestPartResult::kNonFatalFailure)\n\n// Generates a fatal failure with a generic message.\n#define GTEST_FAIL() GTEST_FATAL_FAILURE_(\"Failed\")\n\n// Define this macro to 1 to omit the definition of FAIL(), which is a\n// generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_FAIL\n# define FAIL() GTEST_FAIL()\n#endif\n\n// Generates a success with a generic message.\n#define GTEST_SUCCEED() GTEST_SUCCESS_(\"Succeeded\")\n\n// Define this macro to 1 to omit the definition of SUCCEED(), which\n// is a generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_SUCCEED\n# define SUCCEED() GTEST_SUCCEED()\n#endif\n\n// Macros for testing exceptions.\n//\n//    * {ASSERT|EXPECT}_THROW(statement, expected_exception):\n//         Tests that the statement throws the expected exception.\n//    * {ASSERT|EXPECT}_NO_THROW(statement):\n//         Tests that the statement doesn't throw any exception.\n//    * {ASSERT|EXPECT}_ANY_THROW(statement):\n//         Tests that the statement throws an exception.\n\n#define EXPECT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define EXPECT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_NONFATAL_FAILURE_)\n#define ASSERT_THROW(statement, expected_exception) \\\n  GTEST_TEST_THROW_(statement, expected_exception, GTEST_FATAL_FAILURE_)\n#define ASSERT_NO_THROW(statement) \\\n  GTEST_TEST_NO_THROW_(statement, GTEST_FATAL_FAILURE_)\n#define ASSERT_ANY_THROW(statement) \\\n  GTEST_TEST_ANY_THROW_(statement, GTEST_FATAL_FAILURE_)\n\n// Boolean assertions. Condition can be either a Boolean expression or an\n// AssertionResult. For more information on how to use AssertionResult with\n// these macros see comments on that class.\n#define EXPECT_TRUE(condition) \\\n  GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define EXPECT_FALSE(condition) \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_NONFATAL_FAILURE_)\n#define ASSERT_TRUE(condition) \\\n  GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \\\n                      GTEST_FATAL_FAILURE_)\n#define ASSERT_FALSE(condition) \\\n  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \\\n                      GTEST_FATAL_FAILURE_)\n\n// Includes the auto-generated header that implements a family of\n// generic predicate assertion macros.\n#include \"gtest/gtest_pred_impl.h\"\n\n// Macros for testing equalities and inequalities.\n//\n//    * {ASSERT|EXPECT}_EQ(v1, v2): Tests that v1 == v2\n//    * {ASSERT|EXPECT}_NE(v1, v2): Tests that v1 != v2\n//    * {ASSERT|EXPECT}_LT(v1, v2): Tests that v1 < v2\n//    * {ASSERT|EXPECT}_LE(v1, v2): Tests that v1 <= v2\n//    * {ASSERT|EXPECT}_GT(v1, v2): Tests that v1 > v2\n//    * {ASSERT|EXPECT}_GE(v1, v2): Tests that v1 >= v2\n//\n// When they are not, Google Test prints both the tested expressions and\n// their actual values.  The values must be compatible built-in types,\n// or you will get a compiler error.  By \"compatible\" we mean that the\n// values can be compared by the respective operator.\n//\n// Note:\n//\n//   1. It is possible to make a user-defined type work with\n//   {ASSERT|EXPECT}_??(), but that requires overloading the\n//   comparison operators and is thus discouraged by the Google C++\n//   Usage Guide.  Therefore, you are advised to use the\n//   {ASSERT|EXPECT}_TRUE() macro to assert that two objects are\n//   equal.\n//\n//   2. The {ASSERT|EXPECT}_??() macros do pointer comparisons on\n//   pointers (in particular, C strings).  Therefore, if you use it\n//   with two C strings, you are testing how their locations in memory\n//   are related, not how their content is related.  To compare two C\n//   strings by content, use {ASSERT|EXPECT}_STR*().\n//\n//   3. {ASSERT|EXPECT}_EQ(v1, v2) is preferred to\n//   {ASSERT|EXPECT}_TRUE(v1 == v2), as the former tells you\n//   what the actual value is when it fails, and similarly for the\n//   other comparisons.\n//\n//   4. Do not depend on the order in which {ASSERT|EXPECT}_??()\n//   evaluate their arguments, which is undefined.\n//\n//   5. These macros evaluate their arguments exactly once.\n//\n// Examples:\n//\n//   EXPECT_NE(5, Foo());\n//   EXPECT_EQ(NULL, a_pointer);\n//   ASSERT_LT(i, array_size);\n//   ASSERT_GT(records.size(), 0) << \"There is no record left.\";\n\n#define EXPECT_EQ(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal:: \\\n                      EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\\n                      val1, val2)\n#define EXPECT_NE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define EXPECT_LE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define EXPECT_LT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define EXPECT_GE(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define EXPECT_GT(val1, val2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n#define GTEST_ASSERT_EQ(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal:: \\\n                      EqHelper<GTEST_IS_NULL_LITERAL_(val1)>::Compare, \\\n                      val1, val2)\n#define GTEST_ASSERT_NE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)\n#define GTEST_ASSERT_LE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)\n#define GTEST_ASSERT_LT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)\n#define GTEST_ASSERT_GE(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)\n#define GTEST_ASSERT_GT(val1, val2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)\n\n// Define macro GTEST_DONT_DEFINE_ASSERT_XY to 1 to omit the definition of\n// ASSERT_XY(), which clashes with some users' own code.\n\n#if !GTEST_DONT_DEFINE_ASSERT_EQ\n# define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_NE\n# define ASSERT_NE(val1, val2) GTEST_ASSERT_NE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_LE\n# define ASSERT_LE(val1, val2) GTEST_ASSERT_LE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_LT\n# define ASSERT_LT(val1, val2) GTEST_ASSERT_LT(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_GE\n# define ASSERT_GE(val1, val2) GTEST_ASSERT_GE(val1, val2)\n#endif\n\n#if !GTEST_DONT_DEFINE_ASSERT_GT\n# define ASSERT_GT(val1, val2) GTEST_ASSERT_GT(val1, val2)\n#endif\n\n// C-string Comparisons.  All tests treat NULL and any non-NULL string\n// as different.  Two NULLs are equal.\n//\n//    * {ASSERT|EXPECT}_STREQ(s1, s2):     Tests that s1 == s2\n//    * {ASSERT|EXPECT}_STRNE(s1, s2):     Tests that s1 != s2\n//    * {ASSERT|EXPECT}_STRCASEEQ(s1, s2): Tests that s1 == s2, ignoring case\n//    * {ASSERT|EXPECT}_STRCASENE(s1, s2): Tests that s1 != s2, ignoring case\n//\n// For wide or narrow string objects, you can use the\n// {ASSERT|EXPECT}_??() macros.\n//\n// Don't depend on the order in which the arguments are evaluated,\n// which is undefined.\n//\n// These macros evaluate their arguments exactly once.\n\n#define EXPECT_STREQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define EXPECT_STRNE(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define EXPECT_STRCASEEQ(s1, s2) \\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define EXPECT_STRCASENE(s1, s2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n#define ASSERT_STREQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)\n#define ASSERT_STRNE(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)\n#define ASSERT_STRCASEEQ(s1, s2) \\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)\n#define ASSERT_STRCASENE(s1, s2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)\n\n// Macros for comparing floating-point numbers.\n//\n//    * {ASSERT|EXPECT}_FLOAT_EQ(val1, val2):\n//         Tests that two float values are almost equal.\n//    * {ASSERT|EXPECT}_DOUBLE_EQ(val1, val2):\n//         Tests that two double values are almost equal.\n//    * {ASSERT|EXPECT}_NEAR(v1, v2, abs_error):\n//         Tests that v1 and v2 are within the given distance to each other.\n//\n// Google Test uses ULP-based comparison to automatically pick a default\n// error bound that is appropriate for the operands.  See the\n// FloatingPoint template class in gtest-internal.h if you are\n// interested in the implementation details.\n\n#define EXPECT_FLOAT_EQ(val1, val2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\\n                      val1, val2)\n\n#define EXPECT_DOUBLE_EQ(val1, val2)\\\n  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\n                      val1, val2)\n\n#define ASSERT_FLOAT_EQ(val1, val2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<float>, \\\n                      val1, val2)\n\n#define ASSERT_DOUBLE_EQ(val1, val2)\\\n  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ<double>, \\\n                      val1, val2)\n\n#define EXPECT_NEAR(val1, val2, abs_error)\\\n  EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\\n                      val1, val2, abs_error)\n\n#define ASSERT_NEAR(val1, val2, abs_error)\\\n  ASSERT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \\\n                      val1, val2, abs_error)\n\n// These predicate format functions work on floating-point values, and\n// can be used in {ASSERT|EXPECT}_PRED_FORMAT2*(), e.g.\n//\n//   EXPECT_PRED_FORMAT2(testing::DoubleLE, Foo(), 5.0);\n\n// Asserts that val1 is less than, or almost equal to, val2.  Fails\n// otherwise.  In particular, it fails if either val1 or val2 is NaN.\nGTEST_API_ AssertionResult FloatLE(const char* expr1, const char* expr2,\n                                   float val1, float val2);\nGTEST_API_ AssertionResult DoubleLE(const char* expr1, const char* expr2,\n                                    double val1, double val2);\n\n\n#if GTEST_OS_WINDOWS\n\n// Macros that test for HRESULT failure and success, these are only useful\n// on Windows, and rely on Windows SDK macros and APIs to compile.\n//\n//    * {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}(expr)\n//\n// When expr unexpectedly fails or succeeds, Google Test prints the\n// expected result and the actual result with both a human-readable\n// string representation of the error, if available, as well as the\n// hex result code.\n# define EXPECT_HRESULT_SUCCEEDED(expr) \\\n    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n# define ASSERT_HRESULT_SUCCEEDED(expr) \\\n    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))\n\n# define EXPECT_HRESULT_FAILED(expr) \\\n    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n# define ASSERT_HRESULT_FAILED(expr) \\\n    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))\n\n#endif  // GTEST_OS_WINDOWS\n\n// Macros that execute statement and check that it doesn't generate new fatal\n// failures in the current thread.\n//\n//   * {ASSERT|EXPECT}_NO_FATAL_FAILURE(statement);\n//\n// Examples:\n//\n//   EXPECT_NO_FATAL_FAILURE(Process());\n//   ASSERT_NO_FATAL_FAILURE(Process()) << \"Process() failed\";\n//\n#define ASSERT_NO_FATAL_FAILURE(statement) \\\n    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_FATAL_FAILURE_)\n#define EXPECT_NO_FATAL_FAILURE(statement) \\\n    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_NONFATAL_FAILURE_)\n\n// Causes a trace (including the source file path, the current line\n// number, and the given message) to be included in every test failure\n// message generated by code in the current scope.  The effect is\n// undone when the control leaves the current scope.\n//\n// The message argument can be anything streamable to std::ostream.\n//\n// In the implementation, we include the current line number as part\n// of the dummy variable name, thus allowing multiple SCOPED_TRACE()s\n// to appear in the same block - as long as they are on different\n// lines.\n#define SCOPED_TRACE(message) \\\n  ::testing::internal::ScopedTrace GTEST_CONCAT_TOKEN_(gtest_trace_, __LINE__)(\\\n    __FILE__, __LINE__, ::testing::Message() << (message))\n\n// Compile-time assertion for type equality.\n// StaticAssertTypeEq<type1, type2>() compiles iff type1 and type2 are\n// the same type.  The value it returns is not interesting.\n//\n// Instead of making StaticAssertTypeEq a class template, we make it a\n// function template that invokes a helper class template.  This\n// prevents a user from misusing StaticAssertTypeEq<T1, T2> by\n// defining objects of that type.\n//\n// CAVEAT:\n//\n// When used inside a method of a class template,\n// StaticAssertTypeEq<T1, T2>() is effective ONLY IF the method is\n// instantiated.  For example, given:\n//\n//   template <typename T> class Foo {\n//    public:\n//     void Bar() { testing::StaticAssertTypeEq<int, T>(); }\n//   };\n//\n// the code:\n//\n//   void Test1() { Foo<bool> foo; }\n//\n// will NOT generate a compiler error, as Foo<bool>::Bar() is never\n// actually instantiated.  Instead, you need:\n//\n//   void Test2() { Foo<bool> foo; foo.Bar(); }\n//\n// to cause a compiler error.\ntemplate <typename T1, typename T2>\nbool StaticAssertTypeEq() {\n  (void)internal::StaticAssertTypeEqHelper<T1, T2>();\n  return true;\n}\n\n// Defines a test.\n//\n// The first parameter is the name of the test case, and the second\n// parameter is the name of the test within the test case.\n//\n// The convention is to end the test case name with \"Test\".  For\n// example, a test case for the Foo class can be named FooTest.\n//\n// Test code should appear between braces after an invocation of\n// this macro.  Example:\n//\n//   TEST(FooTest, InitializesCorrectly) {\n//     Foo foo;\n//     EXPECT_TRUE(foo.StatusIsOK());\n//   }\n\n// Note that we call GetTestTypeId() instead of GetTypeId<\n// ::testing::Test>() here to get the type ID of testing::Test.  This\n// is to work around a suspected linker bug when using Google Test as\n// a framework on Mac OS X.  The bug causes GetTypeId<\n// ::testing::Test>() to return different values depending on whether\n// the call is from the Google Test framework itself or from user test\n// code.  GetTestTypeId() is guaranteed to always return the same\n// value, as it always calls GetTypeId<>() from the Google Test\n// framework.\n#define GTEST_TEST(test_case_name, test_name)\\\n  GTEST_TEST_(test_case_name, test_name, \\\n              ::testing::Test, ::testing::internal::GetTestTypeId())\n\n// Define this macro to 1 to omit the definition of TEST(), which\n// is a generic name and clashes with some other libraries.\n#if !GTEST_DONT_DEFINE_TEST\n# define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)\n#endif\n\n// Defines a test that uses a test fixture.\n//\n// The first parameter is the name of the test fixture class, which\n// also doubles as the test case name.  The second parameter is the\n// name of the test within the test case.\n//\n// A test fixture class must be declared earlier.  The user should put\n// his test code between braces after using this macro.  Example:\n//\n//   class FooTest : public testing::Test {\n//    protected:\n//     virtual void SetUp() { b_.AddElement(3); }\n//\n//     Foo a_;\n//     Foo b_;\n//   };\n//\n//   TEST_F(FooTest, InitializesCorrectly) {\n//     EXPECT_TRUE(a_.StatusIsOK());\n//   }\n//\n//   TEST_F(FooTest, ReturnsElementCountCorrectly) {\n//     EXPECT_EQ(0, a_.size());\n//     EXPECT_EQ(1, b_.size());\n//   }\n\n#define TEST_F(test_fixture, test_name)\\\n  GTEST_TEST_(test_fixture, test_name, test_fixture, \\\n              ::testing::internal::GetTypeId<test_fixture>())\n\n}  // namespace testing\n\n// Use this function in main() to run all tests.  It returns 0 if all\n// tests are successful, or 1 otherwise.\n//\n// RUN_ALL_TESTS() should be invoked after the command line has been\n// parsed by InitGoogleTest().\n//\n// This function was formerly a macro; thus, it is in the global\n// namespace and has an all-caps name.\nint RUN_ALL_TESTS() GTEST_MUST_USE_RESULT_;\n\ninline int RUN_ALL_TESTS() {\n  return ::testing::UnitTest::GetInstance()->Run();\n}\n\n#endif  // GTEST_INCLUDE_GTEST_GTEST_H_\n"}, "62": {"id": 62, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googletest/include/gtest/internal/gtest-internal.h", "content": "// Copyright 2005, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Authors: wan@google.com (Zhanyong Wan), eefacm@gmail.com (Sean Mcafee)\n//\n// The Google C++ Testing Framework (Google Test)\n//\n// This header file declares functions and macros used internally by\n// Google Test.  They are subject to change without notice.\n\n#ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n#define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n#include \"gtest/internal/gtest-port.h\"\n\n#if GTEST_OS_LINUX\n# include <stdlib.h>\n# include <sys/types.h>\n# include <sys/wait.h>\n# include <unistd.h>\n#endif  // GTEST_OS_LINUX\n\n#if GTEST_HAS_EXCEPTIONS\n# include <stdexcept>\n#endif\n\n#include <ctype.h>\n#include <float.h>\n#include <string.h>\n#include <iomanip>\n#include <limits>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\n\n#include \"gtest/gtest-message.h\"\n#include \"gtest/internal/gtest-string.h\"\n#include \"gtest/internal/gtest-filepath.h\"\n#include \"gtest/internal/gtest-type-util.h\"\n\n// Due to C++ preprocessor weirdness, we need double indirection to\n// concatenate two tokens when one of them is __LINE__.  Writing\n//\n//   foo ## __LINE__\n//\n// will result in the token foo__LINE__, instead of foo followed by\n// the current line number.  For more details, see\n// http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.6\n#define GTEST_CONCAT_TOKEN_(foo, bar) GTEST_CONCAT_TOKEN_IMPL_(foo, bar)\n#define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar\n\nclass ProtocolMessage;\nnamespace proto2 { class Message; }\n\nnamespace testing {\n\n// Forward declarations.\n\nclass AssertionResult;                 // Result of an assertion.\nclass Message;                         // Represents a failure message.\nclass Test;                            // Represents a test.\nclass TestInfo;                        // Information about a test.\nclass TestPartResult;                  // Result of a test part.\nclass UnitTest;                        // A collection of test cases.\n\ntemplate <typename T>\n::std::string PrintToString(const T& value);\n\nnamespace internal {\n\nstruct TraceInfo;                      // Information about a trace point.\nclass ScopedTrace;                     // Implements scoped trace.\nclass TestInfoImpl;                    // Opaque implementation of TestInfo\nclass UnitTestImpl;                    // Opaque implementation of UnitTest\n\n// The text used in failure messages to indicate the start of the\n// stack trace.\nGTEST_API_ extern const char kStackTraceMarker[];\n\n// Two overloaded helpers for checking at compile time whether an\n// expression is a null pointer literal (i.e. NULL or any 0-valued\n// compile-time integral constant).  Their return values have\n// different sizes, so we can use sizeof() to test which version is\n// picked by the compiler.  These helpers have no implementations, as\n// we only need their signatures.\n//\n// Given IsNullLiteralHelper(x), the compiler will pick the first\n// version if x can be implicitly converted to Secret*, and pick the\n// second version otherwise.  Since Secret is a secret and incomplete\n// type, the only expression a user can write that has type Secret* is\n// a null pointer literal.  Therefore, we know that x is a null\n// pointer literal if and only if the first version is picked by the\n// compiler.\nchar IsNullLiteralHelper(Secret* p);\nchar (&IsNullLiteralHelper(...))[2];  // NOLINT\n\n// A compile-time bool constant that is true if and only if x is a\n// null pointer literal (i.e. NULL or any 0-valued compile-time\n// integral constant).\n#ifdef GTEST_ELLIPSIS_NEEDS_POD_\n// We lose support for NULL detection where the compiler doesn't like\n// passing non-POD classes through ellipsis (...).\n# define GTEST_IS_NULL_LITERAL_(x) false\n#else\n# define GTEST_IS_NULL_LITERAL_(x) \\\n    (sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)\n#endif  // GTEST_ELLIPSIS_NEEDS_POD_\n\n// Appends the user-supplied message to the Google-Test-generated message.\nGTEST_API_ std::string AppendUserMessage(\n    const std::string& gtest_msg, const Message& user_msg);\n\n#if GTEST_HAS_EXCEPTIONS\n\n// This exception is thrown by (and only by) a failed Google Test\n// assertion when GTEST_FLAG(throw_on_failure) is true (if exceptions\n// are enabled).  We derive it from std::runtime_error, which is for\n// errors presumably detectable only at run time.  Since\n// std::runtime_error inherits from std::exception, many testing\n// frameworks know how to extract and print the message inside it.\nclass GTEST_API_ GoogleTestFailureException : public ::std::runtime_error {\n public:\n  explicit GoogleTestFailureException(const TestPartResult& failure);\n};\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n// A helper class for creating scoped traces in user programs.\nclass GTEST_API_ ScopedTrace {\n public:\n  // The c'tor pushes the given source file location and message onto\n  // a trace stack maintained by Google Test.\n  ScopedTrace(const char* file, int line, const Message& message);\n\n  // The d'tor pops the info pushed by the c'tor.\n  //\n  // Note that the d'tor is not virtual in order to be efficient.\n  // Don't inherit from ScopedTrace!\n  ~ScopedTrace();\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace);\n} GTEST_ATTRIBUTE_UNUSED_;  // A ScopedTrace object does its job in its\n                            // c'tor and d'tor.  Therefore it doesn't\n                            // need to be used otherwise.\n\nnamespace edit_distance {\n// Returns the optimal edits to go from 'left' to 'right'.\n// All edits cost the same, with replace having lower priority than\n// add/remove.\n// Simple implementation of the Wagner\u2013Fischer algorithm.\n// See http://en.wikipedia.org/wiki/Wagner-Fischer_algorithm\nenum EditType { kMatch, kAdd, kRemove, kReplace };\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<size_t>& left, const std::vector<size_t>& right);\n\n// Same as above, but the input is represented as strings.\nGTEST_API_ std::vector<EditType> CalculateOptimalEdits(\n    const std::vector<std::string>& left,\n    const std::vector<std::string>& right);\n\n// Create a diff of the input strings in Unified diff format.\nGTEST_API_ std::string CreateUnifiedDiff(const std::vector<std::string>& left,\n                                         const std::vector<std::string>& right,\n                                         size_t context = 2);\n\n}  // namespace edit_distance\n\n// Calculate the diff between 'left' and 'right' and return it in unified diff\n// format.\n// If not null, stores in 'total_line_count' the total number of lines found\n// in left + right.\nGTEST_API_ std::string DiffStrings(const std::string& left,\n                                   const std::string& right,\n                                   size_t* total_line_count);\n\n// Constructs and returns the message for an equality assertion\n// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.\n//\n// The first four parameters are the expressions used in the assertion\n// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)\n// where foo is 5 and bar is 6, we have:\n//\n//   expected_expression: \"foo\"\n//   actual_expression:   \"bar\"\n//   expected_value:      \"5\"\n//   actual_value:        \"6\"\n//\n// The ignoring_case parameter is true iff the assertion is a\n// *_STRCASEEQ*.  When it's true, the string \" (ignoring case)\" will\n// be inserted into the message.\nGTEST_API_ AssertionResult EqFailure(const char* expected_expression,\n                                     const char* actual_expression,\n                                     const std::string& expected_value,\n                                     const std::string& actual_value,\n                                     bool ignoring_case);\n\n// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.\nGTEST_API_ std::string GetBoolAssertionFailureMessage(\n    const AssertionResult& assertion_result,\n    const char* expression_text,\n    const char* actual_predicate_value,\n    const char* expected_predicate_value);\n\n// This template class represents an IEEE floating-point number\n// (either single-precision or double-precision, depending on the\n// template parameters).\n//\n// The purpose of this class is to do more sophisticated number\n// comparison.  (Due to round-off error, etc, it's very unlikely that\n// two floating-points will be equal exactly.  Hence a naive\n// comparison by the == operation often doesn't work.)\n//\n// Format of IEEE floating-point:\n//\n//   The most-significant bit being the leftmost, an IEEE\n//   floating-point looks like\n//\n//     sign_bit exponent_bits fraction_bits\n//\n//   Here, sign_bit is a single bit that designates the sign of the\n//   number.\n//\n//   For float, there are 8 exponent bits and 23 fraction bits.\n//\n//   For double, there are 11 exponent bits and 52 fraction bits.\n//\n//   More details can be found at\n//   http://en.wikipedia.org/wiki/IEEE_floating-point_standard.\n//\n// Template parameter:\n//\n//   RawType: the raw floating-point type (either float or double)\ntemplate <typename RawType>\nclass FloatingPoint {\n public:\n  // Defines the unsigned integer type that has the same size as the\n  // floating point number.\n  typedef typename TypeWithSize<sizeof(RawType)>::UInt Bits;\n\n  // Constants.\n\n  // # of bits in a number.\n  static const size_t kBitCount = 8*sizeof(RawType);\n\n  // # of fraction bits in a number.\n  static const size_t kFractionBitCount =\n    std::numeric_limits<RawType>::digits - 1;\n\n  // # of exponent bits in a number.\n  static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;\n\n  // The mask for the sign bit.\n  static const Bits kSignBitMask = static_cast<Bits>(1) << (kBitCount - 1);\n\n  // The mask for the fraction bits.\n  static const Bits kFractionBitMask =\n    ~static_cast<Bits>(0) >> (kExponentBitCount + 1);\n\n  // The mask for the exponent bits.\n  static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);\n\n  // How many ULP's (Units in the Last Place) we want to tolerate when\n  // comparing two numbers.  The larger the value, the more error we\n  // allow.  A 0 value means that two numbers must be exactly the same\n  // to be considered equal.\n  //\n  // The maximum error of a single floating-point operation is 0.5\n  // units in the last place.  On Intel CPU's, all floating-point\n  // calculations are done with 80-bit precision, while double has 64\n  // bits.  Therefore, 4 should be enough for ordinary use.\n  //\n  // See the following article for more details on ULP:\n  // http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\n  static const size_t kMaxUlps = 4;\n\n  // Constructs a FloatingPoint from a raw floating-point number.\n  //\n  // On an Intel CPU, passing a non-normalized NAN (Not a Number)\n  // around may change its bits, although the new value is guaranteed\n  // to be also a NAN.  Therefore, don't expect this constructor to\n  // preserve the bits in x when x is a NAN.\n  explicit FloatingPoint(const RawType& x) { u_.value_ = x; }\n\n  // Static methods\n\n  // Reinterprets a bit pattern as a floating-point number.\n  //\n  // This function is needed to test the AlmostEquals() method.\n  static RawType ReinterpretBits(const Bits bits) {\n    FloatingPoint fp(0);\n    fp.u_.bits_ = bits;\n    return fp.u_.value_;\n  }\n\n  // Returns the floating-point number that represent positive infinity.\n  static RawType Infinity() {\n    return ReinterpretBits(kExponentBitMask);\n  }\n\n  // Returns the maximum representable finite floating-point number.\n  static RawType Max();\n\n  // Non-static methods\n\n  // Returns the bits that represents this number.\n  const Bits &bits() const { return u_.bits_; }\n\n  // Returns the exponent bits of this number.\n  Bits exponent_bits() const { return kExponentBitMask & u_.bits_; }\n\n  // Returns the fraction bits of this number.\n  Bits fraction_bits() const { return kFractionBitMask & u_.bits_; }\n\n  // Returns the sign bit of this number.\n  Bits sign_bit() const { return kSignBitMask & u_.bits_; }\n\n  // Returns true iff this is NAN (not a number).\n  bool is_nan() const {\n    // It's a NAN if the exponent bits are all ones and the fraction\n    // bits are not entirely zeros.\n    return (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0);\n  }\n\n  // Returns true iff this number is at most kMaxUlps ULP's away from\n  // rhs.  In particular, this function:\n  //\n  //   - returns false if either number is (or both are) NAN.\n  //   - treats really large numbers as almost equal to infinity.\n  //   - thinks +0.0 and -0.0 are 0 DLP's apart.\n  bool AlmostEquals(const FloatingPoint& rhs) const {\n    // The IEEE standard says that any comparison operation involving\n    // a NAN must return false.\n    if (is_nan() || rhs.is_nan()) return false;\n\n    return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)\n        <= kMaxUlps;\n  }\n\n private:\n  // The data type used to store the actual floating-point number.\n  union FloatingPointUnion {\n    RawType value_;  // The raw floating-point number.\n    Bits bits_;      // The bits that represent the number.\n  };\n\n  // Converts an integer from the sign-and-magnitude representation to\n  // the biased representation.  More precisely, let N be 2 to the\n  // power of (kBitCount - 1), an integer x is represented by the\n  // unsigned number x + N.\n  //\n  // For instance,\n  //\n  //   -N + 1 (the most negative number representable using\n  //          sign-and-magnitude) is represented by 1;\n  //   0      is represented by N; and\n  //   N - 1  (the biggest number representable using\n  //          sign-and-magnitude) is represented by 2N - 1.\n  //\n  // Read http://en.wikipedia.org/wiki/Signed_number_representations\n  // for more details on signed number representations.\n  static Bits SignAndMagnitudeToBiased(const Bits &sam) {\n    if (kSignBitMask & sam) {\n      // sam represents a negative number.\n      return ~sam + 1;\n    } else {\n      // sam represents a positive number.\n      return kSignBitMask | sam;\n    }\n  }\n\n  // Given two numbers in the sign-and-magnitude representation,\n  // returns the distance between them as an unsigned number.\n  static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &sam1,\n                                                     const Bits &sam2) {\n    const Bits biased1 = SignAndMagnitudeToBiased(sam1);\n    const Bits biased2 = SignAndMagnitudeToBiased(sam2);\n    return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1);\n  }\n\n  FloatingPointUnion u_;\n};\n\n// We cannot use std::numeric_limits<T>::max() as it clashes with the max()\n// macro defined by <windows.h>.\ntemplate <>\ninline float FloatingPoint<float>::Max() { return FLT_MAX; }\ntemplate <>\ninline double FloatingPoint<double>::Max() { return DBL_MAX; }\n\n// Typedefs the instances of the FloatingPoint template class that we\n// care to use.\ntypedef FloatingPoint<float> Float;\ntypedef FloatingPoint<double> Double;\n\n// In order to catch the mistake of putting tests that use different\n// test fixture classes in the same test case, we need to assign\n// unique IDs to fixture classes and compare them.  The TypeId type is\n// used to hold such IDs.  The user should treat TypeId as an opaque\n// type: the only operation allowed on TypeId values is to compare\n// them for equality using the == operator.\ntypedef const void* TypeId;\n\ntemplate <typename T>\nclass TypeIdHelper {\n public:\n  // dummy_ must not have a const type.  Otherwise an overly eager\n  // compiler (e.g. MSVC 7.1 & 8.0) may try to merge\n  // TypeIdHelper<T>::dummy_ for different Ts as an \"optimization\".\n  static bool dummy_;\n};\n\ntemplate <typename T>\nbool TypeIdHelper<T>::dummy_ = false;\n\n// GetTypeId<T>() returns the ID of type T.  Different values will be\n// returned for different types.  Calling the function twice with the\n// same type argument is guaranteed to return the same ID.\ntemplate <typename T>\nTypeId GetTypeId() {\n  // The compiler is required to allocate a different\n  // TypeIdHelper<T>::dummy_ variable for each T used to instantiate\n  // the template.  Therefore, the address of dummy_ is guaranteed to\n  // be unique.\n  return &(TypeIdHelper<T>::dummy_);\n}\n\n// Returns the type ID of ::testing::Test.  Always call this instead\n// of GetTypeId< ::testing::Test>() to get the type ID of\n// ::testing::Test, as the latter may give the wrong result due to a\n// suspected linker bug when compiling Google Test as a Mac OS X\n// framework.\nGTEST_API_ TypeId GetTestTypeId();\n\n// Defines the abstract factory interface that creates instances\n// of a Test object.\nclass TestFactoryBase {\n public:\n  virtual ~TestFactoryBase() {}\n\n  // Creates a test instance to run. The instance is both created and destroyed\n  // within TestInfoImpl::Run()\n  virtual Test* CreateTest() = 0;\n\n protected:\n  TestFactoryBase() {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase);\n};\n\n// This class provides implementation of TeastFactoryBase interface.\n// It is used in TEST and TEST_F macros.\ntemplate <class TestClass>\nclass TestFactoryImpl : public TestFactoryBase {\n public:\n  virtual Test* CreateTest() { return new TestClass; }\n};\n\n#if GTEST_OS_WINDOWS\n\n// Predicate-formatters for implementing the HRESULT checking macros\n// {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}\n// We pass a long instead of HRESULT to avoid causing an\n// include dependency for the HRESULT type.\nGTEST_API_ AssertionResult IsHRESULTSuccess(const char* expr,\n                                            long hr);  // NOLINT\nGTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,\n                                            long hr);  // NOLINT\n\n#endif  // GTEST_OS_WINDOWS\n\n// Types of SetUpTestCase() and TearDownTestCase() functions.\ntypedef void (*SetUpTestCaseFunc)();\ntypedef void (*TearDownTestCaseFunc)();\n\nstruct CodeLocation {\n  CodeLocation(const string& a_file, int a_line) : file(a_file), line(a_line) {}\n\n  string file;\n  int line;\n};\n\n// Creates a new TestInfo object and registers it with Google Test;\n// returns the created object.\n//\n// Arguments:\n//\n//   test_case_name:   name of the test case\n//   name:             name of the test\n//   type_param        the name of the test's type parameter, or NULL if\n//                     this is not a typed or a type-parameterized test.\n//   value_param       text representation of the test's value parameter,\n//                     or NULL if this is not a type-parameterized test.\n//   code_location:    code location where the test is defined\n//   fixture_class_id: ID of the test fixture class\n//   set_up_tc:        pointer to the function that sets up the test case\n//   tear_down_tc:     pointer to the function that tears down the test case\n//   factory:          pointer to the factory that creates a test object.\n//                     The newly created TestInfo instance will assume\n//                     ownership of the factory object.\nGTEST_API_ TestInfo* MakeAndRegisterTestInfo(\n    const char* test_case_name,\n    const char* name,\n    const char* type_param,\n    const char* value_param,\n    CodeLocation code_location,\n    TypeId fixture_class_id,\n    SetUpTestCaseFunc set_up_tc,\n    TearDownTestCaseFunc tear_down_tc,\n    TestFactoryBase* factory);\n\n// If *pstr starts with the given prefix, modifies *pstr to be right\n// past the prefix and returns true; otherwise leaves *pstr unchanged\n// and returns false.  None of pstr, *pstr, and prefix can be NULL.\nGTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);\n\n#if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// State of the definition of a type-parameterized test case.\nclass GTEST_API_ TypedTestCasePState {\n public:\n  TypedTestCasePState() : registered_(false) {}\n\n  // Adds the given test name to defined_test_names_ and return true\n  // if the test case hasn't been registered; otherwise aborts the\n  // program.\n  bool AddTestName(const char* file, int line, const char* case_name,\n                   const char* test_name) {\n    if (registered_) {\n      fprintf(stderr, \"%s Test %s must be defined before \"\n              \"REGISTER_TYPED_TEST_CASE_P(%s, ...).\\n\",\n              FormatFileLocation(file, line).c_str(), test_name, case_name);\n      fflush(stderr);\n      posix::Abort();\n    }\n    registered_tests_.insert(\n        ::std::make_pair(test_name, CodeLocation(file, line)));\n    return true;\n  }\n\n  bool TestExists(const std::string& test_name) const {\n    return registered_tests_.count(test_name) > 0;\n  }\n\n  const CodeLocation& GetCodeLocation(const std::string& test_name) const {\n    RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);\n    GTEST_CHECK_(it != registered_tests_.end());\n    return it->second;\n  }\n\n  // Verifies that registered_tests match the test names in\n  // defined_test_names_; returns registered_tests if successful, or\n  // aborts the program otherwise.\n  const char* VerifyRegisteredTestNames(\n      const char* file, int line, const char* registered_tests);\n\n private:\n  typedef ::std::map<std::string, CodeLocation> RegisteredTestsMap;\n\n  bool registered_;\n  RegisteredTestsMap registered_tests_;\n};\n\n// Skips to the first non-space char after the first comma in 'str';\n// returns NULL if no comma is found in 'str'.\ninline const char* SkipComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  if (comma == NULL) {\n    return NULL;\n  }\n  while (IsSpace(*(++comma))) {}\n  return comma;\n}\n\n// Returns the prefix of 'str' before the first comma in it; returns\n// the entire string if it contains no comma.\ninline std::string GetPrefixUntilComma(const char* str) {\n  const char* comma = strchr(str, ',');\n  return comma == NULL ? str : std::string(str, comma);\n}\n\n// Splits a given string on a given delimiter, populating a given\n// vector with the fields.\nvoid SplitString(const ::std::string& str, char delimiter,\n                 ::std::vector< ::std::string>* dest);\n\n// TypeParameterizedTest<Fixture, TestSel, Types>::Register()\n// registers a list of type-parameterized tests with Google Test.  The\n// return value is insignificant - we just need to return something\n// such that we can call this function in a namespace scope.\n//\n// Implementation note: The GTEST_TEMPLATE_ macro declares a template\n// template parameter.  It's defined in gtest-type-util.h.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel, typename Types>\nclass TypeParameterizedTest {\n public:\n  // 'index' is the index of the test in the type list 'Types'\n  // specified in INSTANTIATE_TYPED_TEST_CASE_P(Prefix, TestCase,\n  // Types).  Valid values for 'index' are [0, N - 1] where N is the\n  // length of Types.\n  static bool Register(const char* prefix,\n                       CodeLocation code_location,\n                       const char* case_name, const char* test_names,\n                       int index) {\n    typedef typename Types::Head Type;\n    typedef Fixture<Type> FixtureClass;\n    typedef typename GTEST_BIND_(TestSel, Type) TestClass;\n\n    // First, registers the first type-parameterized test in the type\n    // list.\n    MakeAndRegisterTestInfo(\n        (std::string(prefix) + (prefix[0] == '\\0' ? \"\" : \"/\") + case_name + \"/\"\n         + StreamableToString(index)).c_str(),\n        StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),\n        GetTypeName<Type>().c_str(),\n        NULL,  // No value parameter.\n        code_location,\n        GetTypeId<FixtureClass>(),\n        TestClass::SetUpTestCase,\n        TestClass::TearDownTestCase,\n        new TestFactoryImpl<TestClass>);\n\n    // Next, recurses (at compile time) with the tail of the type list.\n    return TypeParameterizedTest<Fixture, TestSel, typename Types::Tail>\n        ::Register(prefix, code_location, case_name, test_names, index + 1);\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, class TestSel>\nclass TypeParameterizedTest<Fixture, TestSel, Types0> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const char* /*case_name*/, const char* /*test_names*/,\n                       int /*index*/) {\n    return true;\n  }\n};\n\n// TypeParameterizedTestCase<Fixture, Tests, Types>::Register()\n// registers *all combinations* of 'Tests' and 'Types' with Google\n// Test.  The return value is insignificant - we just need to return\n// something such that we can call this function in a namespace scope.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Tests, typename Types>\nclass TypeParameterizedTestCase {\n public:\n  static bool Register(const char* prefix, CodeLocation code_location,\n                       const TypedTestCasePState* state,\n                       const char* case_name, const char* test_names) {\n    std::string test_name = StripTrailingSpaces(\n        GetPrefixUntilComma(test_names));\n    if (!state->TestExists(test_name)) {\n      fprintf(stderr, \"Failed to get code location for test %s.%s at %s.\",\n              case_name, test_name.c_str(),\n              FormatFileLocation(code_location.file.c_str(),\n                                 code_location.line).c_str());\n      fflush(stderr);\n      posix::Abort();\n    }\n    const CodeLocation& test_location = state->GetCodeLocation(test_name);\n\n    typedef typename Tests::Head Head;\n\n    // First, register the first test in 'Test' for each type in 'Types'.\n    TypeParameterizedTest<Fixture, Head, Types>::Register(\n        prefix, test_location, case_name, test_names, 0);\n\n    // Next, recurses (at compile time) with the tail of the test list.\n    return TypeParameterizedTestCase<Fixture, typename Tests::Tail, Types>\n        ::Register(prefix, code_location, state,\n                   case_name, SkipComma(test_names));\n  }\n};\n\n// The base case for the compile time recursion.\ntemplate <GTEST_TEMPLATE_ Fixture, typename Types>\nclass TypeParameterizedTestCase<Fixture, Templates0, Types> {\n public:\n  static bool Register(const char* /*prefix*/, CodeLocation,\n                       const TypedTestCasePState* /*state*/,\n                       const char* /*case_name*/, const char* /*test_names*/) {\n    return true;\n  }\n};\n\n#endif  // GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P\n\n// Returns the current OS stack trace as an std::string.\n//\n// The maximum number of stack frames to be included is specified by\n// the gtest_stack_trace_depth flag.  The skip_count parameter\n// specifies the number of top frames to be skipped, which doesn't\n// count against the number of frames to be included.\n//\n// For example, if Foo() calls Bar(), which in turn calls\n// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in\n// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.\nGTEST_API_ std::string GetCurrentOsStackTraceExceptTop(\n    UnitTest* unit_test, int skip_count);\n\n// Helpers for suppressing warnings on unreachable code or constant\n// condition.\n\n// Always returns true.\nGTEST_API_ bool AlwaysTrue();\n\n// Always returns false.\ninline bool AlwaysFalse() { return !AlwaysTrue(); }\n\n// Helper for suppressing false warning from Clang on a const char*\n// variable declared in a conditional expression always being NULL in\n// the else branch.\nstruct GTEST_API_ ConstCharPtr {\n  ConstCharPtr(const char* str) : value(str) {}\n  operator bool() const { return true; }\n  const char* value;\n};\n\n// A simple Linear Congruential Generator for generating random\n// numbers with a uniform distribution.  Unlike rand() and srand(), it\n// doesn't use global state (and therefore can't interfere with user\n// code).  Unlike rand_r(), it's portable.  An LCG isn't very random,\n// but it's good enough for our purposes.\nclass GTEST_API_ Random {\n public:\n  static const UInt32 kMaxRange = 1u << 31;\n\n  explicit Random(UInt32 seed) : state_(seed) {}\n\n  void Reseed(UInt32 seed) { state_ = seed; }\n\n  // Generates a random number from [0, range).  Crashes if 'range' is\n  // 0 or greater than kMaxRange.\n  UInt32 Generate(UInt32 range);\n\n private:\n  UInt32 state_;\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);\n};\n\n// Defining a variable of type CompileAssertTypesEqual<T1, T2> will cause a\n// compiler error iff T1 and T2 are different types.\ntemplate <typename T1, typename T2>\nstruct CompileAssertTypesEqual;\n\ntemplate <typename T>\nstruct CompileAssertTypesEqual<T, T> {\n};\n\n// Removes the reference from a type if it is a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::remove_reference, which is not widely available yet.\ntemplate <typename T>\nstruct RemoveReference { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveReference<T&> { typedef T type; };  // NOLINT\n\n// A handy wrapper around RemoveReference that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_REFERENCE_(T) \\\n    typename ::testing::internal::RemoveReference<T>::type\n\n// Removes const from a type if it is a const type, otherwise leaves\n// it unchanged.  This is the same as tr1::remove_const, which is not\n// widely available yet.\ntemplate <typename T>\nstruct RemoveConst { typedef T type; };  // NOLINT\ntemplate <typename T>\nstruct RemoveConst<const T> { typedef T type; };  // NOLINT\n\n// MSVC 8.0, Sun C++, and IBM XL C++ have a bug which causes the above\n// definition to fail to remove the const in 'const int[3]' and 'const\n// char[3][4]'.  The following specialization works around the bug.\ntemplate <typename T, size_t N>\nstruct RemoveConst<const T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n\n#if defined(_MSC_VER) && _MSC_VER < 1400\n// This is the only specialization that allows VC++ 7.1 to remove const in\n// 'const int[3] and 'const int[3][4]'.  However, it causes trouble with GCC\n// and thus needs to be conditionally compiled.\ntemplate <typename T, size_t N>\nstruct RemoveConst<T[N]> {\n  typedef typename RemoveConst<T>::type type[N];\n};\n#endif\n\n// A handy wrapper around RemoveConst that works when the argument\n// T depends on template parameters.\n#define GTEST_REMOVE_CONST_(T) \\\n    typename ::testing::internal::RemoveConst<T>::type\n\n// Turns const U&, U&, const U, and U all into U.\n#define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \\\n    GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))\n\n// Adds reference to a type if it is not a reference type,\n// otherwise leaves it unchanged.  This is the same as\n// tr1::add_reference, which is not widely available yet.\ntemplate <typename T>\nstruct AddReference { typedef T& type; };  // NOLINT\ntemplate <typename T>\nstruct AddReference<T&> { typedef T& type; };  // NOLINT\n\n// A handy wrapper around AddReference that works when the argument T\n// depends on template parameters.\n#define GTEST_ADD_REFERENCE_(T) \\\n    typename ::testing::internal::AddReference<T>::type\n\n// Adds a reference to const on top of T as necessary.  For example,\n// it transforms\n//\n//   char         ==> const char&\n//   const char   ==> const char&\n//   char&        ==> const char&\n//   const char&  ==> const char&\n//\n// The argument T must depend on some template parameters.\n#define GTEST_REFERENCE_TO_CONST_(T) \\\n    GTEST_ADD_REFERENCE_(const GTEST_REMOVE_REFERENCE_(T))\n\n// ImplicitlyConvertible<From, To>::value is a compile-time bool\n// constant that's true iff type From can be implicitly converted to\n// type To.\ntemplate <typename From, typename To>\nclass ImplicitlyConvertible {\n private:\n  // We need the following helper functions only for their types.\n  // They have no implementations.\n\n  // MakeFrom() is an expression whose type is From.  We cannot simply\n  // use From(), as the type From may not have a public default\n  // constructor.\n  static typename AddReference<From>::type MakeFrom();\n\n  // These two functions are overloaded.  Given an expression\n  // Helper(x), the compiler will pick the first version if x can be\n  // implicitly converted to type To; otherwise it will pick the\n  // second version.\n  //\n  // The first version returns a value of size 1, and the second\n  // version returns a value of size 2.  Therefore, by checking the\n  // size of Helper(x), which can be done at compile time, we can tell\n  // which version of Helper() is used, and hence whether x can be\n  // implicitly converted to type To.\n  static char Helper(To);\n  static char (&Helper(...))[2];  // NOLINT\n\n  // We have to put the 'public' section after the 'private' section,\n  // or MSVC refuses to compile the code.\n public:\n#if defined(__BORLANDC__)\n  // C++Builder cannot use member overload resolution during template\n  // instantiation.  The simplest workaround is to use its C++0x type traits\n  // functions (C++Builder 2009 and above only).\n  static const bool value = __is_convertible(From, To);\n#else\n  // MSVC warns about implicitly converting from double to int for\n  // possible loss of data, so we need to temporarily disable the\n  // warning.\n  GTEST_DISABLE_MSC_WARNINGS_PUSH_(4244)\n  static const bool value =\n      sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;\n  GTEST_DISABLE_MSC_WARNINGS_POP_()\n#endif  // __BORLANDC__\n};\ntemplate <typename From, typename To>\nconst bool ImplicitlyConvertible<From, To>::value;\n\n// IsAProtocolMessage<T>::value is a compile-time bool constant that's\n// true iff T is type ProtocolMessage, proto2::Message, or a subclass\n// of those.\ntemplate <typename T>\nstruct IsAProtocolMessage\n    : public bool_constant<\n  ImplicitlyConvertible<const T*, const ::ProtocolMessage*>::value ||\n  ImplicitlyConvertible<const T*, const ::proto2::Message*>::value> {\n};\n\n// When the compiler sees expression IsContainerTest<C>(0), if C is an\n// STL-style container class, the first overload of IsContainerTest\n// will be viable (since both C::iterator* and C::const_iterator* are\n// valid types and NULL can be implicitly converted to them).  It will\n// be picked over the second overload as 'int' is a perfect match for\n// the type of argument 0.  If C::iterator or C::const_iterator is not\n// a valid type, the first overload is not viable, and the second\n// overload will be picked.  Therefore, we can determine whether C is\n// a container class by checking the type of IsContainerTest<C>(0).\n// The value of the expression is insignificant.\n//\n// Note that we look for both C::iterator and C::const_iterator.  The\n// reason is that C++ injects the name of a class as a member of the\n// class itself (e.g. you can refer to class iterator as either\n// 'iterator' or 'iterator::iterator').  If we look for C::iterator\n// only, for example, we would mistakenly think that a class named\n// iterator is an STL container.\n//\n// Also note that the simpler approach of overloading\n// IsContainerTest(typename C::const_iterator*) and\n// IsContainerTest(...) doesn't work with Visual Age C++ and Sun C++.\ntypedef int IsContainer;\ntemplate <class C>\nIsContainer IsContainerTest(int /* dummy */,\n                            typename C::iterator* /* it */ = NULL,\n                            typename C::const_iterator* /* const_it */ = NULL) {\n  return 0;\n}\n\ntypedef char IsNotContainer;\ntemplate <class C>\nIsNotContainer IsContainerTest(long /* dummy */) { return '\\0'; }\n\n// EnableIf<condition>::type is void when 'Cond' is true, and\n// undefined when 'Cond' is false.  To use SFINAE to make a function\n// overload only apply when a particular expression is true, add\n// \"typename EnableIf<expression>::type* = 0\" as the last parameter.\ntemplate<bool> struct EnableIf;\ntemplate<> struct EnableIf<true> { typedef void type; };  // NOLINT\n\n// Utilities for native arrays.\n\n// ArrayEq() compares two k-dimensional native arrays using the\n// elements' operator==, where k can be any integer >= 0.  When k is\n// 0, ArrayEq() degenerates into comparing a single pair of values.\n\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline bool ArrayEq(const T& lhs, const U& rhs) { return lhs == rhs; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline bool ArrayEq(const T(&lhs)[N], const U(&rhs)[N]) {\n  return internal::ArrayEq(lhs, N, rhs);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous ArrayEq() function, arrays with different sizes would\n// lead to different copies of the template code.\ntemplate <typename T, typename U>\nbool ArrayEq(const T* lhs, size_t size, const U* rhs) {\n  for (size_t i = 0; i != size; i++) {\n    if (!internal::ArrayEq(lhs[i], rhs[i]))\n      return false;\n  }\n  return true;\n}\n\n// Finds the first element in the iterator range [begin, end) that\n// equals elem.  Element may be a native array type itself.\ntemplate <typename Iter, typename Element>\nIter ArrayAwareFind(Iter begin, Iter end, const Element& elem) {\n  for (Iter it = begin; it != end; ++it) {\n    if (internal::ArrayEq(*it, elem))\n      return it;\n  }\n  return end;\n}\n\n// CopyArray() copies a k-dimensional native array using the elements'\n// operator=, where k can be any integer >= 0.  When k is 0,\n// CopyArray() degenerates into copying a single value.\n\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to);\n\n// This generic version is used when k is 0.\ntemplate <typename T, typename U>\ninline void CopyArray(const T& from, U* to) { *to = from; }\n\n// This overload is used when k >= 1.\ntemplate <typename T, typename U, size_t N>\ninline void CopyArray(const T(&from)[N], U(*to)[N]) {\n  internal::CopyArray(from, N, *to);\n}\n\n// This helper reduces code bloat.  If we instead put its logic inside\n// the previous CopyArray() function, arrays with different sizes\n// would lead to different copies of the template code.\ntemplate <typename T, typename U>\nvoid CopyArray(const T* from, size_t size, U* to) {\n  for (size_t i = 0; i != size; i++) {\n    internal::CopyArray(from[i], to + i);\n  }\n}\n\n// The relation between an NativeArray object (see below) and the\n// native array it represents.\n// We use 2 different structs to allow non-copyable types to be used, as long\n// as RelationToSourceReference() is passed.\nstruct RelationToSourceReference {};\nstruct RelationToSourceCopy {};\n\n// Adapts a native array to a read-only STL-style container.  Instead\n// of the complete STL container concept, this adaptor only implements\n// members useful for Google Mock's container matchers.  New members\n// should be added as needed.  To simplify the implementation, we only\n// support Element being a raw type (i.e. having no top-level const or\n// reference modifier).  It's the client's responsibility to satisfy\n// this requirement.  Element can be an array type itself (hence\n// multi-dimensional arrays are supported).\ntemplate <typename Element>\nclass NativeArray {\n public:\n  // STL-style container typedefs.\n  typedef Element value_type;\n  typedef Element* iterator;\n  typedef const Element* const_iterator;\n\n  // Constructs from a native array. References the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceReference) {\n    InitRef(array, count);\n  }\n\n  // Constructs from a native array. Copies the source.\n  NativeArray(const Element* array, size_t count, RelationToSourceCopy) {\n    InitCopy(array, count);\n  }\n\n  // Copy constructor.\n  NativeArray(const NativeArray& rhs) {\n    (this->*rhs.clone_)(rhs.array_, rhs.size_);\n  }\n\n  ~NativeArray() {\n    if (clone_ != &NativeArray::InitRef)\n      delete[] array_;\n  }\n\n  // STL-style container methods.\n  size_t size() const { return size_; }\n  const_iterator begin() const { return array_; }\n  const_iterator end() const { return array_ + size_; }\n  bool operator==(const NativeArray& rhs) const {\n    return size() == rhs.size() &&\n        ArrayEq(begin(), size(), rhs.begin());\n  }\n\n private:\n  enum {\n    kCheckTypeIsNotConstOrAReference = StaticAssertTypeEqHelper<\n        Element, GTEST_REMOVE_REFERENCE_AND_CONST_(Element)>::value,\n  };\n\n  // Initializes this object with a copy of the input.\n  void InitCopy(const Element* array, size_t a_size) {\n    Element* const copy = new Element[a_size];\n    CopyArray(array, a_size, copy);\n    array_ = copy;\n    size_ = a_size;\n    clone_ = &NativeArray::InitCopy;\n  }\n\n  // Initializes this object with a reference of the input.\n  void InitRef(const Element* array, size_t a_size) {\n    array_ = array;\n    size_ = a_size;\n    clone_ = &NativeArray::InitRef;\n  }\n\n  const Element* array_;\n  size_t size_;\n  void (NativeArray::*clone_)(const Element*, size_t);\n\n  GTEST_DISALLOW_ASSIGN_(NativeArray);\n};\n\n}  // namespace internal\n}  // namespace testing\n\n#define GTEST_MESSAGE_AT_(file, line, message, result_type) \\\n  ::testing::internal::AssertHelper(result_type, file, line, message) \\\n    = ::testing::Message()\n\n#define GTEST_MESSAGE_(message, result_type) \\\n  GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)\n\n#define GTEST_FATAL_FAILURE_(message) \\\n  return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)\n\n#define GTEST_NONFATAL_FAILURE_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)\n\n#define GTEST_SUCCESS_(message) \\\n  GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)\n\n// Suppresses MSVC warnings 4072 (unreachable code) for the code following\n// statement if it returns or throws (or doesn't return or throw in some\n// situations).\n#define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \\\n  if (::testing::internal::AlwaysTrue()) { statement; }\n\n#define GTEST_TEST_THROW_(statement, expected_exception, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::ConstCharPtr gtest_msg = \"\") { \\\n    bool gtest_caught_expected = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (expected_exception const&) { \\\n      gtest_caught_expected = true; \\\n    } \\\n    catch (...) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws a different type.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n    if (!gtest_caught_expected) { \\\n      gtest_msg.value = \\\n          \"Expected: \" #statement \" throws an exception of type \" \\\n          #expected_exception \".\\n  Actual: it throws nothing.\"; \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): \\\n      fail(gtest_msg.value)\n\n#define GTEST_TEST_NO_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't throw an exception.\\n\" \\\n           \"  Actual: it throws.\")\n\n#define GTEST_TEST_ANY_THROW_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    bool gtest_caught_any = false; \\\n    try { \\\n      GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    } \\\n    catch (...) { \\\n      gtest_caught_any = true; \\\n    } \\\n    if (!gtest_caught_any) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): \\\n      fail(\"Expected: \" #statement \" throws an exception.\\n\" \\\n           \"  Actual: it doesn't.\")\n\n\n// Implements Boolean test assertions such as EXPECT_TRUE. expression can be\n// either a boolean expression or an AssertionResult. text is a textual\n// represenation of expression as it was passed into the EXPECT_TRUE.\n#define GTEST_TEST_BOOLEAN_(expression, text, actual, expected, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (const ::testing::AssertionResult gtest_ar_ = \\\n      ::testing::AssertionResult(expression)) \\\n    ; \\\n  else \\\n    fail(::testing::internal::GetBoolAssertionFailureMessage(\\\n        gtest_ar_, text, #actual, #expected).c_str())\n\n#define GTEST_TEST_NO_FATAL_FAILURE_(statement, fail) \\\n  GTEST_AMBIGUOUS_ELSE_BLOCKER_ \\\n  if (::testing::internal::AlwaysTrue()) { \\\n    ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \\\n    GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \\\n    if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \\\n      goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); \\\n    } \\\n  } else \\\n    GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): \\\n      fail(\"Expected: \" #statement \" doesn't generate new fatal \" \\\n           \"failures in the current thread.\\n\" \\\n           \"  Actual: it does.\")\n\n// Expands to the name of the class that implements the given test.\n#define GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \\\n  test_case_name##_##test_name##_Test\n\n// Helper macro for defining tests.\n#define GTEST_TEST_(test_case_name, test_name, parent_class, parent_id)\\\nclass GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\\\n public:\\\n  GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\\\n private:\\\n  virtual void TestBody();\\\n  static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\\\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(\\\n      GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\\\n};\\\n\\\n::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)\\\n  ::test_info_ =\\\n    ::testing::internal::MakeAndRegisterTestInfo(\\\n        #test_case_name, #test_name, NULL, NULL, \\\n        ::testing::internal::CodeLocation(__FILE__, __LINE__), \\\n        (parent_id), \\\n        parent_class::SetUpTestCase, \\\n        parent_class::TearDownTestCase, \\\n        new ::testing::internal::TestFactoryImpl<\\\n            GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>);\\\nvoid GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()\n\n#endif  // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_\n\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 16, "line": 169}, "message": "move constructor 'AssumptionAnalysis' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h", "reportHash": "57048c6531869d1388b6231d154dd387", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 112}, "message": "move constructor 'BlockFrequencyAnalysis' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h", "reportHash": "a7ffc7efc6173401a79c3b0e3383da1d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 18, "line": 420}, "message": "move constructor 'BranchProbabilityAnalysis' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/BranchProbabilityInfo.h", "reportHash": "29ab4369a22fc9d06ddc6c2567354f14", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 19, "line": 1224}, "message": "move constructor 'LoopAnalysis' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h", "reportHash": "5907cf6b2148fd6060feb4cfd46dd67c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 921}, "message": "move constructor 'MemorySSAAnalysis' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h", "reportHash": "2ab2962e46589688aba24fdf4478ca6e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 22, "line": 47}, "message": "move constructor 'PostDominatorTreeAnalysis' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/PostDominators.h", "reportHash": "cef3ab905b9783e96fc991db1d5cb560", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 23, "line": 2058}, "message": "move constructor 'ScalarEvolutionAnalysis' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h", "reportHash": "9e2fd901716e757e28aeaabfeb7b20fa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 252}, "message": "move constructor 'DominatorTreeAnalysis' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Dominators.h", "reportHash": "f0ddd7b0c8c2b1d03fd7c6a225017341", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 60, "line": 244}, "message": "destructor '~LoopPassManagerTest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "37d670672a47e4b779d3908921ed55fe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 61, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 62, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 62, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 60, "line": 332}, "message": "destructor '~LoopPassManagerTest_Basic_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "3220b0f90725bf4e8275ff72e070b001", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 61, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 62, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 62, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 60, "line": 391}, "message": "destructor '~LoopPassManagerTest_FunctionPassInvalidationOfLoopAnalyses_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "6120cb09f1ead65317e6b00f2fd108ee", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 61, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 62, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 62, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 60, "line": 475}, "message": "destructor '~LoopPassManagerTest_ModulePassInvalidationOfLoopAnalyses_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "c874e28a9af8dcd08375cbc142a9e7c9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 61, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 62, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 62, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 60, "line": 566}, "message": "destructor '~LoopPassManagerTest_InvalidationOfBundledAnalyses_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "4b726eae516810249fc8d980151f4de3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 61, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 62, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 62, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 60, "line": 685}, "message": "destructor '~LoopPassManagerTest_IndirectInvalidation_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "0ca5362d4dfd74403cf19c618159ce0c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 61, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 62, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 62, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 60, "line": 787}, "message": "destructor '~LoopPassManagerTest_IndirectOuterPassInvalidation_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "f556ff3db8daedf79a4324b7f4ca564b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 60, "line": 797}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "f4bcfdc1a4f39d33d50ae069481ed113", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 61, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 62, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 62, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 60, "line": 871}, "message": "destructor '~LoopPassManagerTest_LoopChildInsertion_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "c5281bc977194048474135475ae199bb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 60, "line": 927}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "92062d429ee9e5624e3b21a5af8c7bb3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 60, "line": 927}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "466f8d3ae17aebade4cd4aa25b36d43b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 61, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 62, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 62, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 60, "line": 1073}, "message": "destructor '~LoopPassManagerTest_LoopPeerInsertion_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "2d4fa691d88221f2b61135a09c2cf3bb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 60, "line": 1130}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "92062d429ee9e5624e3b21a5af8c7bb3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 60, "line": 1130}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "466f8d3ae17aebade4cd4aa25b36d43b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 61, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 62, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 62, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 60, "line": 1326}, "message": "destructor '~LoopPassManagerTest_LoopDeletion_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "6b31b33d4e7932ca3447f1c2726355be", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 60, "line": 1402}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "04eca9d870b33f6e53ad4ad30931bd99", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 20, "file": 60, "line": 1402}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "b2547af3cfc4e566548ba06becf2dde3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 47, "file": 60, "line": 1431}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "c1042f2a1c640a69fe71f6f26053a8cb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 47, "file": 60, "line": 1431}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "e3eeb9b1513cfeb8ba5bcb407373b11d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 61, "line": 2217}, "message": "expanded from macro 'TEST_F'"}, {"location": {"col": 7, "file": 62, "line": 1215}, "message": "expanded from macro 'GTEST_TEST_'"}, {"location": {"col": 3, "file": 62, "line": 1211}, "message": "expanded from macro 'GTEST_TEST_CLASS_NAME_'"}, {"location": {"col": 1, "file": 60, "line": 1605}, "message": "destructor '~LoopPassManagerTest_HandleLoopNestPass_Test' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/unittests/Transforms/Scalar/LoopPassManagerTest.cpp", "reportHash": "fb4fa2ef6a7e37d7e822c5b42e920640", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
