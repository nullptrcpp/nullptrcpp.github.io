<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTContext.h", "content": "//===- ASTContext.h - Context to hold long-lived AST nodes ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::ASTContext interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ASTCONTEXT_H\n#define LLVM_CLANG_AST_ASTCONTEXT_H\n\n#include \"clang/AST/ASTContextAllocate.h\"\n#include \"clang/AST/ASTFwd.h\"\n#include \"clang/AST/CanonicalType.h\"\n#include \"clang/AST/CommentCommandTraits.h\"\n#include \"clang/AST/ComparisonCategories.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/PrettyPrinter.h\"\n#include \"clang/AST/RawCommentList.h\"\n#include \"clang/AST/TemplateName.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/AddressSpaces.h\"\n#include \"clang/Basic/AttrKinds.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/Linkage.h\"\n#include \"clang/Basic/NoSanitizeList.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/ProfileList.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/XRayLists.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <memory>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass APFixedPoint;\nclass FixedPointSemantics;\nstruct fltSemantics;\ntemplate <typename T, unsigned N> class SmallPtrSet;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass APValue;\nclass ASTMutationListener;\nclass ASTRecordLayout;\nclass AtomicExpr;\nclass BlockExpr;\nclass BuiltinTemplateDecl;\nclass CharUnits;\nclass ConceptDecl;\nclass CXXABI;\nclass CXXConstructorDecl;\nclass CXXMethodDecl;\nclass CXXRecordDecl;\nclass DiagnosticsEngine;\nclass ParentMapContext;\nclass DynTypedNode;\nclass DynTypedNodeList;\nclass Expr;\nclass GlobalDecl;\nclass MangleContext;\nclass MangleNumberingContext;\nclass MaterializeTemporaryExpr;\nclass MemberSpecializationInfo;\nclass Module;\nstruct MSGuidDeclParts;\nclass ObjCCategoryDecl;\nclass ObjCCategoryImplDecl;\nclass ObjCContainerDecl;\nclass ObjCImplDecl;\nclass ObjCImplementationDecl;\nclass ObjCInterfaceDecl;\nclass ObjCIvarDecl;\nclass ObjCMethodDecl;\nclass ObjCPropertyDecl;\nclass ObjCPropertyImplDecl;\nclass ObjCProtocolDecl;\nclass ObjCTypeParamDecl;\nclass OMPTraitInfo;\nstruct ParsedTargetAttr;\nclass Preprocessor;\nclass Stmt;\nclass StoredDeclsMap;\nclass TargetAttr;\nclass TargetInfo;\nclass TemplateDecl;\nclass TemplateParameterList;\nclass TemplateTemplateParmDecl;\nclass TemplateTypeParmDecl;\nclass UnresolvedSetIterator;\nclass UsingShadowDecl;\nclass VarTemplateDecl;\nclass VTableContextBase;\nstruct BlockVarCopyInit;\n\nnamespace Builtin {\n\nclass Context;\n\n} // namespace Builtin\n\nenum BuiltinTemplateKind : int;\nenum OpenCLTypeKind : uint8_t;\n\nnamespace comments {\n\nclass FullComment;\n\n} // namespace comments\n\nnamespace interp {\n\nclass Context;\n\n} // namespace interp\n\nnamespace serialization {\ntemplate <class> class AbstractTypeReader;\n} // namespace serialization\n\nstruct TypeInfo {\n  uint64_t Width = 0;\n  unsigned Align = 0;\n  bool AlignIsRequired : 1;\n\n  TypeInfo() : AlignIsRequired(false) {}\n  TypeInfo(uint64_t Width, unsigned Align, bool AlignIsRequired)\n      : Width(Width), Align(Align), AlignIsRequired(AlignIsRequired) {}\n};\n\nstruct TypeInfoChars {\n  CharUnits Width;\n  CharUnits Align;\n  bool AlignIsRequired : 1;\n\n  TypeInfoChars() : AlignIsRequired(false) {}\n  TypeInfoChars(CharUnits Width, CharUnits Align, bool AlignIsRequired)\n      : Width(Width), Align(Align), AlignIsRequired(AlignIsRequired) {}\n};\n\n/// Holds long-lived AST nodes (such as types and decls) that can be\n/// referred to throughout the semantic analysis of a file.\nclass ASTContext : public RefCountedBase<ASTContext> {\n  friend class NestedNameSpecifier;\n\n  mutable SmallVector<Type *, 0> Types;\n  mutable llvm::FoldingSet<ExtQuals> ExtQualNodes;\n  mutable llvm::FoldingSet<ComplexType> ComplexTypes;\n  mutable llvm::FoldingSet<PointerType> PointerTypes;\n  mutable llvm::FoldingSet<AdjustedType> AdjustedTypes;\n  mutable llvm::FoldingSet<BlockPointerType> BlockPointerTypes;\n  mutable llvm::FoldingSet<LValueReferenceType> LValueReferenceTypes;\n  mutable llvm::FoldingSet<RValueReferenceType> RValueReferenceTypes;\n  mutable llvm::FoldingSet<MemberPointerType> MemberPointerTypes;\n  mutable llvm::ContextualFoldingSet<ConstantArrayType, ASTContext &>\n      ConstantArrayTypes;\n  mutable llvm::FoldingSet<IncompleteArrayType> IncompleteArrayTypes;\n  mutable std::vector<VariableArrayType*> VariableArrayTypes;\n  mutable llvm::FoldingSet<DependentSizedArrayType> DependentSizedArrayTypes;\n  mutable llvm::FoldingSet<DependentSizedExtVectorType>\n    DependentSizedExtVectorTypes;\n  mutable llvm::FoldingSet<DependentAddressSpaceType>\n      DependentAddressSpaceTypes;\n  mutable llvm::FoldingSet<VectorType> VectorTypes;\n  mutable llvm::FoldingSet<DependentVectorType> DependentVectorTypes;\n  mutable llvm::FoldingSet<ConstantMatrixType> MatrixTypes;\n  mutable llvm::FoldingSet<DependentSizedMatrixType> DependentSizedMatrixTypes;\n  mutable llvm::FoldingSet<FunctionNoProtoType> FunctionNoProtoTypes;\n  mutable llvm::ContextualFoldingSet<FunctionProtoType, ASTContext&>\n    FunctionProtoTypes;\n  mutable llvm::FoldingSet<DependentTypeOfExprType> DependentTypeOfExprTypes;\n  mutable llvm::FoldingSet<DependentDecltypeType> DependentDecltypeTypes;\n  mutable llvm::FoldingSet<TemplateTypeParmType> TemplateTypeParmTypes;\n  mutable llvm::FoldingSet<ObjCTypeParamType> ObjCTypeParamTypes;\n  mutable llvm::FoldingSet<SubstTemplateTypeParmType>\n    SubstTemplateTypeParmTypes;\n  mutable llvm::FoldingSet<SubstTemplateTypeParmPackType>\n    SubstTemplateTypeParmPackTypes;\n  mutable llvm::ContextualFoldingSet<TemplateSpecializationType, ASTContext&>\n    TemplateSpecializationTypes;\n  mutable llvm::FoldingSet<ParenType> ParenTypes;\n  mutable llvm::FoldingSet<ElaboratedType> ElaboratedTypes;\n  mutable llvm::FoldingSet<DependentNameType> DependentNameTypes;\n  mutable llvm::ContextualFoldingSet<DependentTemplateSpecializationType,\n                                     ASTContext&>\n    DependentTemplateSpecializationTypes;\n  llvm::FoldingSet<PackExpansionType> PackExpansionTypes;\n  mutable llvm::FoldingSet<ObjCObjectTypeImpl> ObjCObjectTypes;\n  mutable llvm::FoldingSet<ObjCObjectPointerType> ObjCObjectPointerTypes;\n  mutable llvm::FoldingSet<DependentUnaryTransformType>\n    DependentUnaryTransformTypes;\n  mutable llvm::ContextualFoldingSet<AutoType, ASTContext&> AutoTypes;\n  mutable llvm::FoldingSet<DeducedTemplateSpecializationType>\n    DeducedTemplateSpecializationTypes;\n  mutable llvm::FoldingSet<AtomicType> AtomicTypes;\n  llvm::FoldingSet<AttributedType> AttributedTypes;\n  mutable llvm::FoldingSet<PipeType> PipeTypes;\n  mutable llvm::FoldingSet<ExtIntType> ExtIntTypes;\n  mutable llvm::FoldingSet<DependentExtIntType> DependentExtIntTypes;\n\n  mutable llvm::FoldingSet<QualifiedTemplateName> QualifiedTemplateNames;\n  mutable llvm::FoldingSet<DependentTemplateName> DependentTemplateNames;\n  mutable llvm::FoldingSet<SubstTemplateTemplateParmStorage>\n    SubstTemplateTemplateParms;\n  mutable llvm::ContextualFoldingSet<SubstTemplateTemplateParmPackStorage,\n                                     ASTContext&>\n    SubstTemplateTemplateParmPacks;\n\n  /// The set of nested name specifiers.\n  ///\n  /// This set is managed by the NestedNameSpecifier class.\n  mutable llvm::FoldingSet<NestedNameSpecifier> NestedNameSpecifiers;\n  mutable NestedNameSpecifier *GlobalNestedNameSpecifier = nullptr;\n\n  /// A cache mapping from RecordDecls to ASTRecordLayouts.\n  ///\n  /// This is lazily created.  This is intentionally not serialized.\n  mutable llvm::DenseMap<const RecordDecl*, const ASTRecordLayout*>\n    ASTRecordLayouts;\n  mutable llvm::DenseMap<const ObjCContainerDecl*, const ASTRecordLayout*>\n    ObjCLayouts;\n\n  /// A cache from types to size and alignment information.\n  using TypeInfoMap = llvm::DenseMap<const Type *, struct TypeInfo>;\n  mutable TypeInfoMap MemoizedTypeInfo;\n\n  /// A cache from types to unadjusted alignment information. Only ARM and\n  /// AArch64 targets need this information, keeping it separate prevents\n  /// imposing overhead on TypeInfo size.\n  using UnadjustedAlignMap = llvm::DenseMap<const Type *, unsigned>;\n  mutable UnadjustedAlignMap MemoizedUnadjustedAlign;\n\n  /// A cache mapping from CXXRecordDecls to key functions.\n  llvm::DenseMap<const CXXRecordDecl*, LazyDeclPtr> KeyFunctions;\n\n  /// Mapping from ObjCContainers to their ObjCImplementations.\n  llvm::DenseMap<ObjCContainerDecl*, ObjCImplDecl*> ObjCImpls;\n\n  /// Mapping from ObjCMethod to its duplicate declaration in the same\n  /// interface.\n  llvm::DenseMap<const ObjCMethodDecl*,const ObjCMethodDecl*> ObjCMethodRedecls;\n\n  /// Mapping from __block VarDecls to BlockVarCopyInit.\n  llvm::DenseMap<const VarDecl *, BlockVarCopyInit> BlockVarCopyInits;\n\n  /// Mapping from GUIDs to the corresponding MSGuidDecl.\n  mutable llvm::FoldingSet<MSGuidDecl> MSGuidDecls;\n\n  /// Mapping from APValues to the corresponding TemplateParamObjects.\n  mutable llvm::FoldingSet<TemplateParamObjectDecl> TemplateParamObjectDecls;\n\n  /// A cache mapping a string value to a StringLiteral object with the same\n  /// value.\n  ///\n  /// This is lazily created.  This is intentionally not serialized.\n  mutable llvm::StringMap<StringLiteral *> StringLiteralCache;\n\n  /// MD5 hash of CUID. It is calculated when first used and cached by this\n  /// data member.\n  mutable std::string CUIDHash;\n\n  /// Representation of a \"canonical\" template template parameter that\n  /// is used in canonical template names.\n  class CanonicalTemplateTemplateParm : public llvm::FoldingSetNode {\n    TemplateTemplateParmDecl *Parm;\n\n  public:\n    CanonicalTemplateTemplateParm(TemplateTemplateParmDecl *Parm)\n        : Parm(Parm) {}\n\n    TemplateTemplateParmDecl *getParam() const { return Parm; }\n\n    void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &C) {\n      Profile(ID, C, Parm);\n    }\n\n    static void Profile(llvm::FoldingSetNodeID &ID,\n                        const ASTContext &C,\n                        TemplateTemplateParmDecl *Parm);\n  };\n  mutable llvm::ContextualFoldingSet<CanonicalTemplateTemplateParm,\n                                     const ASTContext&>\n    CanonTemplateTemplateParms;\n\n  TemplateTemplateParmDecl *\n    getCanonicalTemplateTemplateParmDecl(TemplateTemplateParmDecl *TTP) const;\n\n  /// The typedef for the __int128_t type.\n  mutable TypedefDecl *Int128Decl = nullptr;\n\n  /// The typedef for the __uint128_t type.\n  mutable TypedefDecl *UInt128Decl = nullptr;\n\n  /// The typedef for the target specific predefined\n  /// __builtin_va_list type.\n  mutable TypedefDecl *BuiltinVaListDecl = nullptr;\n\n  /// The typedef for the predefined \\c __builtin_ms_va_list type.\n  mutable TypedefDecl *BuiltinMSVaListDecl = nullptr;\n\n  /// The typedef for the predefined \\c id type.\n  mutable TypedefDecl *ObjCIdDecl = nullptr;\n\n  /// The typedef for the predefined \\c SEL type.\n  mutable TypedefDecl *ObjCSelDecl = nullptr;\n\n  /// The typedef for the predefined \\c Class type.\n  mutable TypedefDecl *ObjCClassDecl = nullptr;\n\n  /// The typedef for the predefined \\c Protocol class in Objective-C.\n  mutable ObjCInterfaceDecl *ObjCProtocolClassDecl = nullptr;\n\n  /// The typedef for the predefined 'BOOL' type.\n  mutable TypedefDecl *BOOLDecl = nullptr;\n\n  // Typedefs which may be provided defining the structure of Objective-C\n  // pseudo-builtins\n  QualType ObjCIdRedefinitionType;\n  QualType ObjCClassRedefinitionType;\n  QualType ObjCSelRedefinitionType;\n\n  /// The identifier 'bool'.\n  mutable IdentifierInfo *BoolName = nullptr;\n\n  /// The identifier 'NSObject'.\n  mutable IdentifierInfo *NSObjectName = nullptr;\n\n  /// The identifier 'NSCopying'.\n  IdentifierInfo *NSCopyingName = nullptr;\n\n  /// The identifier '__make_integer_seq'.\n  mutable IdentifierInfo *MakeIntegerSeqName = nullptr;\n\n  /// The identifier '__type_pack_element'.\n  mutable IdentifierInfo *TypePackElementName = nullptr;\n\n  QualType ObjCConstantStringType;\n  mutable RecordDecl *CFConstantStringTagDecl = nullptr;\n  mutable TypedefDecl *CFConstantStringTypeDecl = nullptr;\n\n  mutable QualType ObjCSuperType;\n\n  QualType ObjCNSStringType;\n\n  /// The typedef declaration for the Objective-C \"instancetype\" type.\n  TypedefDecl *ObjCInstanceTypeDecl = nullptr;\n\n  /// The type for the C FILE type.\n  TypeDecl *FILEDecl = nullptr;\n\n  /// The type for the C jmp_buf type.\n  TypeDecl *jmp_bufDecl = nullptr;\n\n  /// The type for the C sigjmp_buf type.\n  TypeDecl *sigjmp_bufDecl = nullptr;\n\n  /// The type for the C ucontext_t type.\n  TypeDecl *ucontext_tDecl = nullptr;\n\n  /// Type for the Block descriptor for Blocks CodeGen.\n  ///\n  /// Since this is only used for generation of debug info, it is not\n  /// serialized.\n  mutable RecordDecl *BlockDescriptorType = nullptr;\n\n  /// Type for the Block descriptor for Blocks CodeGen.\n  ///\n  /// Since this is only used for generation of debug info, it is not\n  /// serialized.\n  mutable RecordDecl *BlockDescriptorExtendedType = nullptr;\n\n  /// Declaration for the CUDA cudaConfigureCall function.\n  FunctionDecl *cudaConfigureCallDecl = nullptr;\n\n  /// Keeps track of all declaration attributes.\n  ///\n  /// Since so few decls have attrs, we keep them in a hash map instead of\n  /// wasting space in the Decl class.\n  llvm::DenseMap<const Decl*, AttrVec*> DeclAttrs;\n\n  /// A mapping from non-redeclarable declarations in modules that were\n  /// merged with other declarations to the canonical declaration that they were\n  /// merged into.\n  llvm::DenseMap<Decl*, Decl*> MergedDecls;\n\n  /// A mapping from a defining declaration to a list of modules (other\n  /// than the owning module of the declaration) that contain merged\n  /// definitions of that entity.\n  llvm::DenseMap<NamedDecl*, llvm::TinyPtrVector<Module*>> MergedDefModules;\n\n  /// Initializers for a module, in order. Each Decl will be either\n  /// something that has a semantic effect on startup (such as a variable with\n  /// a non-constant initializer), or an ImportDecl (which recursively triggers\n  /// initialization of another module).\n  struct PerModuleInitializers {\n    llvm::SmallVector<Decl*, 4> Initializers;\n    llvm::SmallVector<uint32_t, 4> LazyInitializers;\n\n    void resolve(ASTContext &Ctx);\n  };\n  llvm::DenseMap<Module*, PerModuleInitializers*> ModuleInitializers;\n\n  ASTContext &this_() { return *this; }\n\npublic:\n  /// A type synonym for the TemplateOrInstantiation mapping.\n  using TemplateOrSpecializationInfo =\n      llvm::PointerUnion<VarTemplateDecl *, MemberSpecializationInfo *>;\n\nprivate:\n  friend class ASTDeclReader;\n  friend class ASTReader;\n  friend class ASTWriter;\n  template <class> friend class serialization::AbstractTypeReader;\n  friend class CXXRecordDecl;\n\n  /// A mapping to contain the template or declaration that\n  /// a variable declaration describes or was instantiated from,\n  /// respectively.\n  ///\n  /// For non-templates, this value will be NULL. For variable\n  /// declarations that describe a variable template, this will be a\n  /// pointer to a VarTemplateDecl. For static data members\n  /// of class template specializations, this will be the\n  /// MemberSpecializationInfo referring to the member variable that was\n  /// instantiated or specialized. Thus, the mapping will keep track of\n  /// the static data member templates from which static data members of\n  /// class template specializations were instantiated.\n  ///\n  /// Given the following example:\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   static T value;\n  /// };\n  ///\n  /// template<typename T>\n  ///   T X<T>::value = T(17);\n  ///\n  /// int *x = &X<int>::value;\n  /// \\endcode\n  ///\n  /// This mapping will contain an entry that maps from the VarDecl for\n  /// X<int>::value to the corresponding VarDecl for X<T>::value (within the\n  /// class template X) and will be marked TSK_ImplicitInstantiation.\n  llvm::DenseMap<const VarDecl *, TemplateOrSpecializationInfo>\n  TemplateOrInstantiation;\n\n  /// Keeps track of the declaration from which a using declaration was\n  /// created during instantiation.\n  ///\n  /// The source and target declarations are always a UsingDecl, an\n  /// UnresolvedUsingValueDecl, or an UnresolvedUsingTypenameDecl.\n  ///\n  /// For example:\n  /// \\code\n  /// template<typename T>\n  /// struct A {\n  ///   void f();\n  /// };\n  ///\n  /// template<typename T>\n  /// struct B : A<T> {\n  ///   using A<T>::f;\n  /// };\n  ///\n  /// template struct B<int>;\n  /// \\endcode\n  ///\n  /// This mapping will contain an entry that maps from the UsingDecl in\n  /// B<int> to the UnresolvedUsingDecl in B<T>.\n  llvm::DenseMap<NamedDecl *, NamedDecl *> InstantiatedFromUsingDecl;\n\n  llvm::DenseMap<UsingShadowDecl*, UsingShadowDecl*>\n    InstantiatedFromUsingShadowDecl;\n\n  llvm::DenseMap<FieldDecl *, FieldDecl *> InstantiatedFromUnnamedFieldDecl;\n\n  /// Mapping that stores the methods overridden by a given C++\n  /// member function.\n  ///\n  /// Since most C++ member functions aren't virtual and therefore\n  /// don't override anything, we store the overridden functions in\n  /// this map on the side rather than within the CXXMethodDecl structure.\n  using CXXMethodVector = llvm::TinyPtrVector<const CXXMethodDecl *>;\n  llvm::DenseMap<const CXXMethodDecl *, CXXMethodVector> OverriddenMethods;\n\n  /// Mapping from each declaration context to its corresponding\n  /// mangling numbering context (used for constructs like lambdas which\n  /// need to be consistently numbered for the mangler).\n  llvm::DenseMap<const DeclContext *, std::unique_ptr<MangleNumberingContext>>\n      MangleNumberingContexts;\n  llvm::DenseMap<const Decl *, std::unique_ptr<MangleNumberingContext>>\n      ExtraMangleNumberingContexts;\n\n  /// Side-table of mangling numbers for declarations which rarely\n  /// need them (like static local vars).\n  llvm::MapVector<const NamedDecl *, unsigned> MangleNumbers;\n  llvm::MapVector<const VarDecl *, unsigned> StaticLocalNumbers;\n  /// Mapping the associated device lambda mangling number if present.\n  mutable llvm::DenseMap<const CXXRecordDecl *, unsigned>\n      DeviceLambdaManglingNumbers;\n\n  /// Mapping that stores parameterIndex values for ParmVarDecls when\n  /// that value exceeds the bitfield size of ParmVarDeclBits.ParameterIndex.\n  using ParameterIndexTable = llvm::DenseMap<const VarDecl *, unsigned>;\n  ParameterIndexTable ParamIndices;\n\n  ImportDecl *FirstLocalImport = nullptr;\n  ImportDecl *LastLocalImport = nullptr;\n\n  TranslationUnitDecl *TUDecl;\n  mutable ExternCContextDecl *ExternCContext = nullptr;\n  mutable BuiltinTemplateDecl *MakeIntegerSeqDecl = nullptr;\n  mutable BuiltinTemplateDecl *TypePackElementDecl = nullptr;\n\n  /// The associated SourceManager object.\n  SourceManager &SourceMgr;\n\n  /// The language options used to create the AST associated with\n  ///  this ASTContext object.\n  LangOptions &LangOpts;\n\n  /// NoSanitizeList object that is used by sanitizers to decide which\n  /// entities should not be instrumented.\n  std::unique_ptr<NoSanitizeList> NoSanitizeL;\n\n  /// Function filtering mechanism to determine whether a given function\n  /// should be imbued with the XRay \"always\" or \"never\" attributes.\n  std::unique_ptr<XRayFunctionFilter> XRayFilter;\n\n  /// ProfileList object that is used by the profile instrumentation\n  /// to decide which entities should be instrumented.\n  std::unique_ptr<ProfileList> ProfList;\n\n  /// The allocator used to create AST objects.\n  ///\n  /// AST objects are never destructed; rather, all memory associated with the\n  /// AST objects will be released when the ASTContext itself is destroyed.\n  mutable llvm::BumpPtrAllocator BumpAlloc;\n\n  /// Allocator for partial diagnostics.\n  PartialDiagnostic::DiagStorageAllocator DiagAllocator;\n\n  /// The current C++ ABI.\n  std::unique_ptr<CXXABI> ABI;\n  CXXABI *createCXXABI(const TargetInfo &T);\n\n  /// The logical -> physical address space map.\n  const LangASMap *AddrSpaceMap = nullptr;\n\n  /// Address space map mangling must be used with language specific\n  /// address spaces (e.g. OpenCL/CUDA)\n  bool AddrSpaceMapMangling;\n\n  const TargetInfo *Target = nullptr;\n  const TargetInfo *AuxTarget = nullptr;\n  clang::PrintingPolicy PrintingPolicy;\n  std::unique_ptr<interp::Context> InterpContext;\n  std::unique_ptr<ParentMapContext> ParentMapCtx;\n\npublic:\n  IdentifierTable &Idents;\n  SelectorTable &Selectors;\n  Builtin::Context &BuiltinInfo;\n  mutable DeclarationNameTable DeclarationNames;\n  IntrusiveRefCntPtr<ExternalASTSource> ExternalSource;\n  ASTMutationListener *Listener = nullptr;\n\n  /// Returns the clang bytecode interpreter context.\n  interp::Context &getInterpContext();\n\n  /// Returns the dynamic AST node parent map context.\n  ParentMapContext &getParentMapContext();\n\n  // A traversal scope limits the parts of the AST visible to certain analyses.\n  // RecursiveASTVisitor::TraverseAST will only visit reachable nodes, and\n  // getParents() will only observe reachable parent edges.\n  //\n  // The scope is defined by a set of \"top-level\" declarations.\n  // Initially, it is the entire TU: {getTranslationUnitDecl()}.\n  // Changing the scope clears the parent cache, which is expensive to rebuild.\n  std::vector<Decl *> getTraversalScope() const { return TraversalScope; }\n  void setTraversalScope(const std::vector<Decl *> &);\n\n  /// Forwards to get node parents from the ParentMapContext. New callers should\n  /// use ParentMapContext::getParents() directly.\n  template <typename NodeT> DynTypedNodeList getParents(const NodeT &Node);\n\n  const clang::PrintingPolicy &getPrintingPolicy() const {\n    return PrintingPolicy;\n  }\n\n  void setPrintingPolicy(const clang::PrintingPolicy &Policy) {\n    PrintingPolicy = Policy;\n  }\n\n  SourceManager& getSourceManager() { return SourceMgr; }\n  const SourceManager& getSourceManager() const { return SourceMgr; }\n\n  llvm::BumpPtrAllocator &getAllocator() const {\n    return BumpAlloc;\n  }\n\n  void *Allocate(size_t Size, unsigned Align = 8) const {\n    return BumpAlloc.Allocate(Size, Align);\n  }\n  template <typename T> T *Allocate(size_t Num = 1) const {\n    return static_cast<T *>(Allocate(Num * sizeof(T), alignof(T)));\n  }\n  void Deallocate(void *Ptr) const {}\n\n  /// Return the total amount of physical memory allocated for representing\n  /// AST nodes and type information.\n  size_t getASTAllocatedMemory() const {\n    return BumpAlloc.getTotalMemory();\n  }\n\n  /// Return the total memory used for various side tables.\n  size_t getSideTableAllocatedMemory() const;\n\n  PartialDiagnostic::DiagStorageAllocator &getDiagAllocator() {\n    return DiagAllocator;\n  }\n\n  const TargetInfo &getTargetInfo() const { return *Target; }\n  const TargetInfo *getAuxTargetInfo() const { return AuxTarget; }\n\n  /// getIntTypeForBitwidth -\n  /// sets integer QualTy according to specified details:\n  /// bitwidth, signed/unsigned.\n  /// Returns empty type if there is no appropriate target types.\n  QualType getIntTypeForBitwidth(unsigned DestWidth,\n                                 unsigned Signed) const;\n\n  /// getRealTypeForBitwidth -\n  /// sets floating point QualTy according to specified bitwidth.\n  /// Returns empty type if there is no appropriate target types.\n  QualType getRealTypeForBitwidth(unsigned DestWidth, bool ExplicitIEEE) const;\n\n  bool AtomicUsesUnsupportedLibcall(const AtomicExpr *E) const;\n\n  const LangOptions& getLangOpts() const { return LangOpts; }\n\n  // If this condition is false, typo correction must be performed eagerly\n  // rather than delayed in many places, as it makes use of dependent types.\n  // the condition is false for clang's C-only codepath, as it doesn't support\n  // dependent types yet.\n  bool isDependenceAllowed() const {\n    return LangOpts.CPlusPlus || LangOpts.RecoveryAST;\n  }\n\n  const NoSanitizeList &getNoSanitizeList() const { return *NoSanitizeL; }\n\n  const XRayFunctionFilter &getXRayFilter() const {\n    return *XRayFilter;\n  }\n\n  const ProfileList &getProfileList() const { return *ProfList; }\n\n  DiagnosticsEngine &getDiagnostics() const;\n\n  FullSourceLoc getFullLoc(SourceLocation Loc) const {\n    return FullSourceLoc(Loc,SourceMgr);\n  }\n\n  /// All comments in this translation unit.\n  RawCommentList Comments;\n\n  /// True if comments are already loaded from ExternalASTSource.\n  mutable bool CommentsLoaded = false;\n\n  /// Mapping from declaration to directly attached comment.\n  ///\n  /// Raw comments are owned by Comments list.  This mapping is populated\n  /// lazily.\n  mutable llvm::DenseMap<const Decl *, const RawComment *> DeclRawComments;\n\n  /// Mapping from canonical declaration to the first redeclaration in chain\n  /// that has a comment attached.\n  ///\n  /// Raw comments are owned by Comments list.  This mapping is populated\n  /// lazily.\n  mutable llvm::DenseMap<const Decl *, const Decl *> RedeclChainComments;\n\n  /// Keeps track of redeclaration chains that don't have any comment attached.\n  /// Mapping from canonical declaration to redeclaration chain that has no\n  /// comments attached to any redeclaration. Specifically it's mapping to\n  /// the last redeclaration we've checked.\n  ///\n  /// Shall not contain declarations that have comments attached to any\n  /// redeclaration in their chain.\n  mutable llvm::DenseMap<const Decl *, const Decl *> CommentlessRedeclChains;\n\n  /// Mapping from declarations to parsed comments attached to any\n  /// redeclaration.\n  mutable llvm::DenseMap<const Decl *, comments::FullComment *> ParsedComments;\n\n  /// Attaches \\p Comment to \\p OriginalD and to its redeclaration chain\n  /// and removes the redeclaration chain from the set of commentless chains.\n  ///\n  /// Don't do anything if a comment has already been attached to \\p OriginalD\n  /// or its redeclaration chain.\n  void cacheRawCommentForDecl(const Decl &OriginalD,\n                              const RawComment &Comment) const;\n\n  /// \\returns searches \\p CommentsInFile for doc comment for \\p D.\n  ///\n  /// \\p RepresentativeLocForDecl is used as a location for searching doc\n  /// comments. \\p CommentsInFile is a mapping offset -> comment of files in the\n  /// same file where \\p RepresentativeLocForDecl is.\n  RawComment *getRawCommentForDeclNoCacheImpl(\n      const Decl *D, const SourceLocation RepresentativeLocForDecl,\n      const std::map<unsigned, RawComment *> &CommentsInFile) const;\n\n  /// Return the documentation comment attached to a given declaration,\n  /// without looking into cache.\n  RawComment *getRawCommentForDeclNoCache(const Decl *D) const;\n\npublic:\n  void addComment(const RawComment &RC);\n\n  /// Return the documentation comment attached to a given declaration.\n  /// Returns nullptr if no comment is attached.\n  ///\n  /// \\param OriginalDecl if not nullptr, is set to declaration AST node that\n  /// had the comment, if the comment we found comes from a redeclaration.\n  const RawComment *\n  getRawCommentForAnyRedecl(const Decl *D,\n                            const Decl **OriginalDecl = nullptr) const;\n\n  /// Searches existing comments for doc comments that should be attached to \\p\n  /// Decls. If any doc comment is found, it is parsed.\n  ///\n  /// Requirement: All \\p Decls are in the same file.\n  ///\n  /// If the last comment in the file is already attached we assume\n  /// there are not comments left to be attached to \\p Decls.\n  void attachCommentsToJustParsedDecls(ArrayRef<Decl *> Decls,\n                                       const Preprocessor *PP);\n\n  /// Return parsed documentation comment attached to a given declaration.\n  /// Returns nullptr if no comment is attached.\n  ///\n  /// \\param PP the Preprocessor used with this TU.  Could be nullptr if\n  /// preprocessor is not available.\n  comments::FullComment *getCommentForDecl(const Decl *D,\n                                           const Preprocessor *PP) const;\n\n  /// Return parsed documentation comment attached to a given declaration.\n  /// Returns nullptr if no comment is attached. Does not look at any\n  /// redeclarations of the declaration.\n  comments::FullComment *getLocalCommentForDeclUncached(const Decl *D) const;\n\n  comments::FullComment *cloneFullComment(comments::FullComment *FC,\n                                         const Decl *D) const;\n\nprivate:\n  mutable comments::CommandTraits CommentCommandTraits;\n\n  /// Iterator that visits import declarations.\n  class import_iterator {\n    ImportDecl *Import = nullptr;\n\n  public:\n    using value_type = ImportDecl *;\n    using reference = ImportDecl *;\n    using pointer = ImportDecl *;\n    using difference_type = int;\n    using iterator_category = std::forward_iterator_tag;\n\n    import_iterator() = default;\n    explicit import_iterator(ImportDecl *Import) : Import(Import) {}\n\n    reference operator*() const { return Import; }\n    pointer operator->() const { return Import; }\n\n    import_iterator &operator++() {\n      Import = ASTContext::getNextLocalImport(Import);\n      return *this;\n    }\n\n    import_iterator operator++(int) {\n      import_iterator Other(*this);\n      ++(*this);\n      return Other;\n    }\n\n    friend bool operator==(import_iterator X, import_iterator Y) {\n      return X.Import == Y.Import;\n    }\n\n    friend bool operator!=(import_iterator X, import_iterator Y) {\n      return X.Import != Y.Import;\n    }\n  };\n\npublic:\n  comments::CommandTraits &getCommentCommandTraits() const {\n    return CommentCommandTraits;\n  }\n\n  /// Retrieve the attributes for the given declaration.\n  AttrVec& getDeclAttrs(const Decl *D);\n\n  /// Erase the attributes corresponding to the given declaration.\n  void eraseDeclAttrs(const Decl *D);\n\n  /// If this variable is an instantiated static data member of a\n  /// class template specialization, returns the templated static data member\n  /// from which it was instantiated.\n  // FIXME: Remove ?\n  MemberSpecializationInfo *getInstantiatedFromStaticDataMember(\n                                                           const VarDecl *Var);\n\n  TemplateOrSpecializationInfo\n  getTemplateOrSpecializationInfo(const VarDecl *Var);\n\n  /// Note that the static data member \\p Inst is an instantiation of\n  /// the static data member template \\p Tmpl of a class template.\n  void setInstantiatedFromStaticDataMember(VarDecl *Inst, VarDecl *Tmpl,\n                                           TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  void setTemplateOrSpecializationInfo(VarDecl *Inst,\n                                       TemplateOrSpecializationInfo TSI);\n\n  /// If the given using decl \\p Inst is an instantiation of a\n  /// (possibly unresolved) using decl from a template instantiation,\n  /// return it.\n  NamedDecl *getInstantiatedFromUsingDecl(NamedDecl *Inst);\n\n  /// Remember that the using decl \\p Inst is an instantiation\n  /// of the using decl \\p Pattern of a class template.\n  void setInstantiatedFromUsingDecl(NamedDecl *Inst, NamedDecl *Pattern);\n\n  void setInstantiatedFromUsingShadowDecl(UsingShadowDecl *Inst,\n                                          UsingShadowDecl *Pattern);\n  UsingShadowDecl *getInstantiatedFromUsingShadowDecl(UsingShadowDecl *Inst);\n\n  FieldDecl *getInstantiatedFromUnnamedFieldDecl(FieldDecl *Field);\n\n  void setInstantiatedFromUnnamedFieldDecl(FieldDecl *Inst, FieldDecl *Tmpl);\n\n  // Access to the set of methods overridden by the given C++ method.\n  using overridden_cxx_method_iterator = CXXMethodVector::const_iterator;\n  overridden_cxx_method_iterator\n  overridden_methods_begin(const CXXMethodDecl *Method) const;\n\n  overridden_cxx_method_iterator\n  overridden_methods_end(const CXXMethodDecl *Method) const;\n\n  unsigned overridden_methods_size(const CXXMethodDecl *Method) const;\n\n  using overridden_method_range =\n      llvm::iterator_range<overridden_cxx_method_iterator>;\n\n  overridden_method_range overridden_methods(const CXXMethodDecl *Method) const;\n\n  /// Note that the given C++ \\p Method overrides the given \\p\n  /// Overridden method.\n  void addOverriddenMethod(const CXXMethodDecl *Method,\n                           const CXXMethodDecl *Overridden);\n\n  /// Return C++ or ObjC overridden methods for the given \\p Method.\n  ///\n  /// An ObjC method is considered to override any method in the class's\n  /// base classes, its protocols, or its categories' protocols, that has\n  /// the same selector and is of the same kind (class or instance).\n  /// A method in an implementation is not considered as overriding the same\n  /// method in the interface or its categories.\n  void getOverriddenMethods(\n                        const NamedDecl *Method,\n                        SmallVectorImpl<const NamedDecl *> &Overridden) const;\n\n  /// Notify the AST context that a new import declaration has been\n  /// parsed or implicitly created within this translation unit.\n  void addedLocalImportDecl(ImportDecl *Import);\n\n  static ImportDecl *getNextLocalImport(ImportDecl *Import) {\n    return Import->getNextLocalImport();\n  }\n\n  using import_range = llvm::iterator_range<import_iterator>;\n\n  import_range local_imports() const {\n    return import_range(import_iterator(FirstLocalImport), import_iterator());\n  }\n\n  Decl *getPrimaryMergedDecl(Decl *D) {\n    Decl *Result = MergedDecls.lookup(D);\n    return Result ? Result : D;\n  }\n  void setPrimaryMergedDecl(Decl *D, Decl *Primary) {\n    MergedDecls[D] = Primary;\n  }\n\n  /// Note that the definition \\p ND has been merged into module \\p M,\n  /// and should be visible whenever \\p M is visible.\n  void mergeDefinitionIntoModule(NamedDecl *ND, Module *M,\n                                 bool NotifyListeners = true);\n\n  /// Clean up the merged definition list. Call this if you might have\n  /// added duplicates into the list.\n  void deduplicateMergedDefinitonsFor(NamedDecl *ND);\n\n  /// Get the additional modules in which the definition \\p Def has\n  /// been merged.\n  ArrayRef<Module*> getModulesWithMergedDefinition(const NamedDecl *Def);\n\n  /// Add a declaration to the list of declarations that are initialized\n  /// for a module. This will typically be a global variable (with internal\n  /// linkage) that runs module initializers, such as the iostream initializer,\n  /// or an ImportDecl nominating another module that has initializers.\n  void addModuleInitializer(Module *M, Decl *Init);\n\n  void addLazyModuleInitializers(Module *M, ArrayRef<uint32_t> IDs);\n\n  /// Get the initializations to perform when importing a module, if any.\n  ArrayRef<Decl*> getModuleInitializers(Module *M);\n\n  TranslationUnitDecl *getTranslationUnitDecl() const { return TUDecl; }\n\n  ExternCContextDecl *getExternCContextDecl() const;\n  BuiltinTemplateDecl *getMakeIntegerSeqDecl() const;\n  BuiltinTemplateDecl *getTypePackElementDecl() const;\n\n  // Builtin Types.\n  CanQualType VoidTy;\n  CanQualType BoolTy;\n  CanQualType CharTy;\n  CanQualType WCharTy;  // [C++ 3.9.1p5].\n  CanQualType WideCharTy; // Same as WCharTy in C++, integer type in C99.\n  CanQualType WIntTy;   // [C99 7.24.1], integer type unchanged by default promotions.\n  CanQualType Char8Ty;  // [C++20 proposal]\n  CanQualType Char16Ty; // [C++0x 3.9.1p5], integer type in C99.\n  CanQualType Char32Ty; // [C++0x 3.9.1p5], integer type in C99.\n  CanQualType SignedCharTy, ShortTy, IntTy, LongTy, LongLongTy, Int128Ty;\n  CanQualType UnsignedCharTy, UnsignedShortTy, UnsignedIntTy, UnsignedLongTy;\n  CanQualType UnsignedLongLongTy, UnsignedInt128Ty;\n  CanQualType FloatTy, DoubleTy, LongDoubleTy, Float128Ty;\n  CanQualType ShortAccumTy, AccumTy,\n      LongAccumTy;  // ISO/IEC JTC1 SC22 WG14 N1169 Extension\n  CanQualType UnsignedShortAccumTy, UnsignedAccumTy, UnsignedLongAccumTy;\n  CanQualType ShortFractTy, FractTy, LongFractTy;\n  CanQualType UnsignedShortFractTy, UnsignedFractTy, UnsignedLongFractTy;\n  CanQualType SatShortAccumTy, SatAccumTy, SatLongAccumTy;\n  CanQualType SatUnsignedShortAccumTy, SatUnsignedAccumTy,\n      SatUnsignedLongAccumTy;\n  CanQualType SatShortFractTy, SatFractTy, SatLongFractTy;\n  CanQualType SatUnsignedShortFractTy, SatUnsignedFractTy,\n      SatUnsignedLongFractTy;\n  CanQualType HalfTy; // [OpenCL 6.1.1.1], ARM NEON\n  CanQualType BFloat16Ty;\n  CanQualType Float16Ty; // C11 extension ISO/IEC TS 18661-3\n  CanQualType FloatComplexTy, DoubleComplexTy, LongDoubleComplexTy;\n  CanQualType Float128ComplexTy;\n  CanQualType VoidPtrTy, NullPtrTy;\n  CanQualType DependentTy, OverloadTy, BoundMemberTy, UnknownAnyTy;\n  CanQualType BuiltinFnTy;\n  CanQualType PseudoObjectTy, ARCUnbridgedCastTy;\n  CanQualType ObjCBuiltinIdTy, ObjCBuiltinClassTy, ObjCBuiltinSelTy;\n  CanQualType ObjCBuiltinBoolTy;\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n  CanQualType SingletonId;\n#include \"clang/Basic/OpenCLImageTypes.def\"\n  CanQualType OCLSamplerTy, OCLEventTy, OCLClkEventTy;\n  CanQualType OCLQueueTy, OCLReserveIDTy;\n  CanQualType IncompleteMatrixIdxTy;\n  CanQualType OMPArraySectionTy, OMPArrayShapingTy, OMPIteratorTy;\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n  CanQualType Id##Ty;\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n#define SVE_TYPE(Name, Id, SingletonId) \\\n  CanQualType SingletonId;\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n#define PPC_VECTOR_TYPE(Name, Id, Size) \\\n  CanQualType Id##Ty;\n#include \"clang/Basic/PPCTypes.def\"\n#define RVV_TYPE(Name, Id, SingletonId) \\\n  CanQualType SingletonId;\n#include \"clang/Basic/RISCVVTypes.def\"\n\n  // Types for deductions in C++0x [stmt.ranged]'s desugaring. Built on demand.\n  mutable QualType AutoDeductTy;     // Deduction against 'auto'.\n  mutable QualType AutoRRefDeductTy; // Deduction against 'auto &&'.\n\n  // Decl used to help define __builtin_va_list for some targets.\n  // The decl is built when constructing 'BuiltinVaListDecl'.\n  mutable Decl *VaListTagDecl = nullptr;\n\n  // Implicitly-declared type 'struct _GUID'.\n  mutable TagDecl *MSGuidTagDecl = nullptr;\n\n  /// Keep track of CUDA/HIP static device variables referenced by host code.\n  llvm::DenseSet<const VarDecl *> CUDAStaticDeviceVarReferencedByHost;\n\n  ASTContext(LangOptions &LOpts, SourceManager &SM, IdentifierTable &idents,\n             SelectorTable &sels, Builtin::Context &builtins);\n  ASTContext(const ASTContext &) = delete;\n  ASTContext &operator=(const ASTContext &) = delete;\n  ~ASTContext();\n\n  /// Attach an external AST source to the AST context.\n  ///\n  /// The external AST source provides the ability to load parts of\n  /// the abstract syntax tree as needed from some external storage,\n  /// e.g., a precompiled header.\n  void setExternalSource(IntrusiveRefCntPtr<ExternalASTSource> Source);\n\n  /// Retrieve a pointer to the external AST source associated\n  /// with this AST context, if any.\n  ExternalASTSource *getExternalSource() const {\n    return ExternalSource.get();\n  }\n\n  /// Attach an AST mutation listener to the AST context.\n  ///\n  /// The AST mutation listener provides the ability to track modifications to\n  /// the abstract syntax tree entities committed after they were initially\n  /// created.\n  void setASTMutationListener(ASTMutationListener *Listener) {\n    this->Listener = Listener;\n  }\n\n  /// Retrieve a pointer to the AST mutation listener associated\n  /// with this AST context, if any.\n  ASTMutationListener *getASTMutationListener() const { return Listener; }\n\n  void PrintStats() const;\n  const SmallVectorImpl<Type *>& getTypes() const { return Types; }\n\n  BuiltinTemplateDecl *buildBuiltinTemplateDecl(BuiltinTemplateKind BTK,\n                                                const IdentifierInfo *II) const;\n\n  /// Create a new implicit TU-level CXXRecordDecl or RecordDecl\n  /// declaration.\n  RecordDecl *buildImplicitRecord(StringRef Name,\n                                  RecordDecl::TagKind TK = TTK_Struct) const;\n\n  /// Create a new implicit TU-level typedef declaration.\n  TypedefDecl *buildImplicitTypedef(QualType T, StringRef Name) const;\n\n  /// Retrieve the declaration for the 128-bit signed integer type.\n  TypedefDecl *getInt128Decl() const;\n\n  /// Retrieve the declaration for the 128-bit unsigned integer type.\n  TypedefDecl *getUInt128Decl() const;\n\n  //===--------------------------------------------------------------------===//\n  //                           Type Constructors\n  //===--------------------------------------------------------------------===//\n\nprivate:\n  /// Return a type with extended qualifiers.\n  QualType getExtQualType(const Type *Base, Qualifiers Quals) const;\n\n  QualType getTypeDeclTypeSlow(const TypeDecl *Decl) const;\n\n  QualType getPipeType(QualType T, bool ReadOnly) const;\n\npublic:\n  /// Return the uniqued reference to the type for an address space\n  /// qualified type with the specified type and address space.\n  ///\n  /// The resulting type has a union of the qualifiers from T and the address\n  /// space. If T already has an address space specifier, it is silently\n  /// replaced.\n  QualType getAddrSpaceQualType(QualType T, LangAS AddressSpace) const;\n\n  /// Remove any existing address space on the type and returns the type\n  /// with qualifiers intact (or that's the idea anyway)\n  ///\n  /// The return type should be T with all prior qualifiers minus the address\n  /// space.\n  QualType removeAddrSpaceQualType(QualType T) const;\n\n  /// Apply Objective-C protocol qualifiers to the given type.\n  /// \\param allowOnPointerType specifies if we can apply protocol\n  /// qualifiers on ObjCObjectPointerType. It can be set to true when\n  /// constructing the canonical type of a Objective-C type parameter.\n  QualType applyObjCProtocolQualifiers(QualType type,\n      ArrayRef<ObjCProtocolDecl *> protocols, bool &hasError,\n      bool allowOnPointerType = false) const;\n\n  /// Return the uniqued reference to the type for an Objective-C\n  /// gc-qualified type.\n  ///\n  /// The resulting type has a union of the qualifiers from T and the gc\n  /// attribute.\n  QualType getObjCGCQualType(QualType T, Qualifiers::GC gcAttr) const;\n\n  /// Remove the existing address space on the type if it is a pointer size\n  /// address space and return the type with qualifiers intact.\n  QualType removePtrSizeAddrSpace(QualType T) const;\n\n  /// Return the uniqued reference to the type for a \\c restrict\n  /// qualified type.\n  ///\n  /// The resulting type has a union of the qualifiers from \\p T and\n  /// \\c restrict.\n  QualType getRestrictType(QualType T) const {\n    return T.withFastQualifiers(Qualifiers::Restrict);\n  }\n\n  /// Return the uniqued reference to the type for a \\c volatile\n  /// qualified type.\n  ///\n  /// The resulting type has a union of the qualifiers from \\p T and\n  /// \\c volatile.\n  QualType getVolatileType(QualType T) const {\n    return T.withFastQualifiers(Qualifiers::Volatile);\n  }\n\n  /// Return the uniqued reference to the type for a \\c const\n  /// qualified type.\n  ///\n  /// The resulting type has a union of the qualifiers from \\p T and \\c const.\n  ///\n  /// It can be reasonably expected that this will always be equivalent to\n  /// calling T.withConst().\n  QualType getConstType(QualType T) const { return T.withConst(); }\n\n  /// Change the ExtInfo on a function type.\n  const FunctionType *adjustFunctionType(const FunctionType *Fn,\n                                         FunctionType::ExtInfo EInfo);\n\n  /// Adjust the given function result type.\n  CanQualType getCanonicalFunctionResultType(QualType ResultType) const;\n\n  /// Change the result type of a function type once it is deduced.\n  void adjustDeducedFunctionResultType(FunctionDecl *FD, QualType ResultType);\n\n  /// Get a function type and produce the equivalent function type with the\n  /// specified exception specification. Type sugar that can be present on a\n  /// declaration of a function with an exception specification is permitted\n  /// and preserved. Other type sugar (for instance, typedefs) is not.\n  QualType getFunctionTypeWithExceptionSpec(\n      QualType Orig, const FunctionProtoType::ExceptionSpecInfo &ESI);\n\n  /// Determine whether two function types are the same, ignoring\n  /// exception specifications in cases where they're part of the type.\n  bool hasSameFunctionTypeIgnoringExceptionSpec(QualType T, QualType U);\n\n  /// Change the exception specification on a function once it is\n  /// delay-parsed, instantiated, or computed.\n  void adjustExceptionSpec(FunctionDecl *FD,\n                           const FunctionProtoType::ExceptionSpecInfo &ESI,\n                           bool AsWritten = false);\n\n  /// Get a function type and produce the equivalent function type where\n  /// pointer size address spaces in the return type and parameter tyeps are\n  /// replaced with the default address space.\n  QualType getFunctionTypeWithoutPtrSizes(QualType T);\n\n  /// Determine whether two function types are the same, ignoring pointer sizes\n  /// in the return type and parameter types.\n  bool hasSameFunctionTypeIgnoringPtrSizes(QualType T, QualType U);\n\n  /// Return the uniqued reference to the type for a complex\n  /// number with the specified element type.\n  QualType getComplexType(QualType T) const;\n  CanQualType getComplexType(CanQualType T) const {\n    return CanQualType::CreateUnsafe(getComplexType((QualType) T));\n  }\n\n  /// Return the uniqued reference to the type for a pointer to\n  /// the specified type.\n  QualType getPointerType(QualType T) const;\n  CanQualType getPointerType(CanQualType T) const {\n    return CanQualType::CreateUnsafe(getPointerType((QualType) T));\n  }\n\n  /// Return the uniqued reference to a type adjusted from the original\n  /// type to a new type.\n  QualType getAdjustedType(QualType Orig, QualType New) const;\n  CanQualType getAdjustedType(CanQualType Orig, CanQualType New) const {\n    return CanQualType::CreateUnsafe(\n        getAdjustedType((QualType)Orig, (QualType)New));\n  }\n\n  /// Return the uniqued reference to the decayed version of the given\n  /// type.  Can only be called on array and function types which decay to\n  /// pointer types.\n  QualType getDecayedType(QualType T) const;\n  CanQualType getDecayedType(CanQualType T) const {\n    return CanQualType::CreateUnsafe(getDecayedType((QualType) T));\n  }\n\n  /// Return the uniqued reference to the atomic type for the specified\n  /// type.\n  QualType getAtomicType(QualType T) const;\n\n  /// Return the uniqued reference to the type for a block of the\n  /// specified type.\n  QualType getBlockPointerType(QualType T) const;\n\n  /// Gets the struct used to keep track of the descriptor for pointer to\n  /// blocks.\n  QualType getBlockDescriptorType() const;\n\n  /// Return a read_only pipe type for the specified type.\n  QualType getReadPipeType(QualType T) const;\n\n  /// Return a write_only pipe type for the specified type.\n  QualType getWritePipeType(QualType T) const;\n\n  /// Return an extended integer type with the specified signedness and bit\n  /// count.\n  QualType getExtIntType(bool Unsigned, unsigned NumBits) const;\n\n  /// Return a dependent extended integer type with the specified signedness and\n  /// bit count.\n  QualType getDependentExtIntType(bool Unsigned, Expr *BitsExpr) const;\n\n  /// Gets the struct used to keep track of the extended descriptor for\n  /// pointer to blocks.\n  QualType getBlockDescriptorExtendedType() const;\n\n  /// Map an AST Type to an OpenCLTypeKind enum value.\n  OpenCLTypeKind getOpenCLTypeKind(const Type *T) const;\n\n  /// Get address space for OpenCL type.\n  LangAS getOpenCLTypeAddrSpace(const Type *T) const;\n\n  void setcudaConfigureCallDecl(FunctionDecl *FD) {\n    cudaConfigureCallDecl = FD;\n  }\n\n  FunctionDecl *getcudaConfigureCallDecl() {\n    return cudaConfigureCallDecl;\n  }\n\n  /// Returns true iff we need copy/dispose helpers for the given type.\n  bool BlockRequiresCopying(QualType Ty, const VarDecl *D);\n\n  /// Returns true, if given type has a known lifetime. HasByrefExtendedLayout\n  /// is set to false in this case. If HasByrefExtendedLayout returns true,\n  /// byref variable has extended lifetime.\n  bool getByrefLifetime(QualType Ty,\n                        Qualifiers::ObjCLifetime &Lifetime,\n                        bool &HasByrefExtendedLayout) const;\n\n  /// Return the uniqued reference to the type for an lvalue reference\n  /// to the specified type.\n  QualType getLValueReferenceType(QualType T, bool SpelledAsLValue = true)\n    const;\n\n  /// Return the uniqued reference to the type for an rvalue reference\n  /// to the specified type.\n  QualType getRValueReferenceType(QualType T) const;\n\n  /// Return the uniqued reference to the type for a member pointer to\n  /// the specified type in the specified class.\n  ///\n  /// The class \\p Cls is a \\c Type because it could be a dependent name.\n  QualType getMemberPointerType(QualType T, const Type *Cls) const;\n\n  /// Return a non-unique reference to the type for a variable array of\n  /// the specified element type.\n  QualType getVariableArrayType(QualType EltTy, Expr *NumElts,\n                                ArrayType::ArraySizeModifier ASM,\n                                unsigned IndexTypeQuals,\n                                SourceRange Brackets) const;\n\n  /// Return a non-unique reference to the type for a dependently-sized\n  /// array of the specified element type.\n  ///\n  /// FIXME: We will need these to be uniqued, or at least comparable, at some\n  /// point.\n  QualType getDependentSizedArrayType(QualType EltTy, Expr *NumElts,\n                                      ArrayType::ArraySizeModifier ASM,\n                                      unsigned IndexTypeQuals,\n                                      SourceRange Brackets) const;\n\n  /// Return a unique reference to the type for an incomplete array of\n  /// the specified element type.\n  QualType getIncompleteArrayType(QualType EltTy,\n                                  ArrayType::ArraySizeModifier ASM,\n                                  unsigned IndexTypeQuals) const;\n\n  /// Return the unique reference to the type for a constant array of\n  /// the specified element type.\n  QualType getConstantArrayType(QualType EltTy, const llvm::APInt &ArySize,\n                                const Expr *SizeExpr,\n                                ArrayType::ArraySizeModifier ASM,\n                                unsigned IndexTypeQuals) const;\n\n  /// Return a type for a constant array for a string literal of the\n  /// specified element type and length.\n  QualType getStringLiteralArrayType(QualType EltTy, unsigned Length) const;\n\n  /// Returns a vla type where known sizes are replaced with [*].\n  QualType getVariableArrayDecayedType(QualType Ty) const;\n\n  // Convenience struct to return information about a builtin vector type.\n  struct BuiltinVectorTypeInfo {\n    QualType ElementType;\n    llvm::ElementCount EC;\n    unsigned NumVectors;\n    BuiltinVectorTypeInfo(QualType ElementType, llvm::ElementCount EC,\n                          unsigned NumVectors)\n        : ElementType(ElementType), EC(EC), NumVectors(NumVectors) {}\n  };\n\n  /// Returns the element type, element count and number of vectors\n  /// (in case of tuple) for a builtin vector type.\n  BuiltinVectorTypeInfo\n  getBuiltinVectorTypeInfo(const BuiltinType *VecTy) const;\n\n  /// Return the unique reference to a scalable vector type of the specified\n  /// element type and scalable number of elements.\n  ///\n  /// \\pre \\p EltTy must be a built-in type.\n  QualType getScalableVectorType(QualType EltTy, unsigned NumElts) const;\n\n  /// Return the unique reference to a vector type of the specified\n  /// element type and size.\n  ///\n  /// \\pre \\p VectorType must be a built-in type.\n  QualType getVectorType(QualType VectorType, unsigned NumElts,\n                         VectorType::VectorKind VecKind) const;\n  /// Return the unique reference to the type for a dependently sized vector of\n  /// the specified element type.\n  QualType getDependentVectorType(QualType VectorType, Expr *SizeExpr,\n                                  SourceLocation AttrLoc,\n                                  VectorType::VectorKind VecKind) const;\n\n  /// Return the unique reference to an extended vector type\n  /// of the specified element type and size.\n  ///\n  /// \\pre \\p VectorType must be a built-in type.\n  QualType getExtVectorType(QualType VectorType, unsigned NumElts) const;\n\n  /// \\pre Return a non-unique reference to the type for a dependently-sized\n  /// vector of the specified element type.\n  ///\n  /// FIXME: We will need these to be uniqued, or at least comparable, at some\n  /// point.\n  QualType getDependentSizedExtVectorType(QualType VectorType,\n                                          Expr *SizeExpr,\n                                          SourceLocation AttrLoc) const;\n\n  /// Return the unique reference to the matrix type of the specified element\n  /// type and size\n  ///\n  /// \\pre \\p ElementType must be a valid matrix element type (see\n  /// MatrixType::isValidElementType).\n  QualType getConstantMatrixType(QualType ElementType, unsigned NumRows,\n                                 unsigned NumColumns) const;\n\n  /// Return the unique reference to the matrix type of the specified element\n  /// type and size\n  QualType getDependentSizedMatrixType(QualType ElementType, Expr *RowExpr,\n                                       Expr *ColumnExpr,\n                                       SourceLocation AttrLoc) const;\n\n  QualType getDependentAddressSpaceType(QualType PointeeType,\n                                        Expr *AddrSpaceExpr,\n                                        SourceLocation AttrLoc) const;\n\n  /// Return a K&R style C function type like 'int()'.\n  QualType getFunctionNoProtoType(QualType ResultTy,\n                                  const FunctionType::ExtInfo &Info) const;\n\n  QualType getFunctionNoProtoType(QualType ResultTy) const {\n    return getFunctionNoProtoType(ResultTy, FunctionType::ExtInfo());\n  }\n\n  /// Return a normal function type with a typed argument list.\n  QualType getFunctionType(QualType ResultTy, ArrayRef<QualType> Args,\n                           const FunctionProtoType::ExtProtoInfo &EPI) const {\n    return getFunctionTypeInternal(ResultTy, Args, EPI, false);\n  }\n\n  QualType adjustStringLiteralBaseType(QualType StrLTy) const;\n\nprivate:\n  /// Return a normal function type with a typed argument list.\n  QualType getFunctionTypeInternal(QualType ResultTy, ArrayRef<QualType> Args,\n                                   const FunctionProtoType::ExtProtoInfo &EPI,\n                                   bool OnlyWantCanonical) const;\n\npublic:\n  /// Return the unique reference to the type for the specified type\n  /// declaration.\n  QualType getTypeDeclType(const TypeDecl *Decl,\n                           const TypeDecl *PrevDecl = nullptr) const {\n    assert(Decl && \"Passed null for Decl param\");\n    if (Decl->TypeForDecl) return QualType(Decl->TypeForDecl, 0);\n\n    if (PrevDecl) {\n      assert(PrevDecl->TypeForDecl && \"previous decl has no TypeForDecl\");\n      Decl->TypeForDecl = PrevDecl->TypeForDecl;\n      return QualType(PrevDecl->TypeForDecl, 0);\n    }\n\n    return getTypeDeclTypeSlow(Decl);\n  }\n\n  /// Return the unique reference to the type for the specified\n  /// typedef-name decl.\n  QualType getTypedefType(const TypedefNameDecl *Decl,\n                          QualType Underlying = QualType()) const;\n\n  QualType getRecordType(const RecordDecl *Decl) const;\n\n  QualType getEnumType(const EnumDecl *Decl) const;\n\n  QualType getInjectedClassNameType(CXXRecordDecl *Decl, QualType TST) const;\n\n  QualType getAttributedType(attr::Kind attrKind,\n                             QualType modifiedType,\n                             QualType equivalentType);\n\n  QualType getSubstTemplateTypeParmType(const TemplateTypeParmType *Replaced,\n                                        QualType Replacement) const;\n  QualType getSubstTemplateTypeParmPackType(\n                                          const TemplateTypeParmType *Replaced,\n                                            const TemplateArgument &ArgPack);\n\n  QualType\n  getTemplateTypeParmType(unsigned Depth, unsigned Index,\n                          bool ParameterPack,\n                          TemplateTypeParmDecl *ParmDecl = nullptr) const;\n\n  QualType getTemplateSpecializationType(TemplateName T,\n                                         ArrayRef<TemplateArgument> Args,\n                                         QualType Canon = QualType()) const;\n\n  QualType\n  getCanonicalTemplateSpecializationType(TemplateName T,\n                                         ArrayRef<TemplateArgument> Args) const;\n\n  QualType getTemplateSpecializationType(TemplateName T,\n                                         const TemplateArgumentListInfo &Args,\n                                         QualType Canon = QualType()) const;\n\n  TypeSourceInfo *\n  getTemplateSpecializationTypeInfo(TemplateName T, SourceLocation TLoc,\n                                    const TemplateArgumentListInfo &Args,\n                                    QualType Canon = QualType()) const;\n\n  QualType getParenType(QualType NamedType) const;\n\n  QualType getMacroQualifiedType(QualType UnderlyingTy,\n                                 const IdentifierInfo *MacroII) const;\n\n  QualType getElaboratedType(ElaboratedTypeKeyword Keyword,\n                             NestedNameSpecifier *NNS, QualType NamedType,\n                             TagDecl *OwnedTagDecl = nullptr) const;\n  QualType getDependentNameType(ElaboratedTypeKeyword Keyword,\n                                NestedNameSpecifier *NNS,\n                                const IdentifierInfo *Name,\n                                QualType Canon = QualType()) const;\n\n  QualType getDependentTemplateSpecializationType(ElaboratedTypeKeyword Keyword,\n                                                  NestedNameSpecifier *NNS,\n                                                  const IdentifierInfo *Name,\n                                    const TemplateArgumentListInfo &Args) const;\n  QualType getDependentTemplateSpecializationType(\n      ElaboratedTypeKeyword Keyword, NestedNameSpecifier *NNS,\n      const IdentifierInfo *Name, ArrayRef<TemplateArgument> Args) const;\n\n  TemplateArgument getInjectedTemplateArg(NamedDecl *ParamDecl);\n\n  /// Get a template argument list with one argument per template parameter\n  /// in a template parameter list, such as for the injected class name of\n  /// a class template.\n  void getInjectedTemplateArgs(const TemplateParameterList *Params,\n                               SmallVectorImpl<TemplateArgument> &Args);\n\n  /// Form a pack expansion type with the given pattern.\n  /// \\param NumExpansions The number of expansions for the pack, if known.\n  /// \\param ExpectPackInType If \\c false, we should not expect \\p Pattern to\n  ///        contain an unexpanded pack. This only makes sense if the pack\n  ///        expansion is used in a context where the arity is inferred from\n  ///        elsewhere, such as if the pattern contains a placeholder type or\n  ///        if this is the canonical type of another pack expansion type.\n  QualType getPackExpansionType(QualType Pattern,\n                                Optional<unsigned> NumExpansions,\n                                bool ExpectPackInType = true);\n\n  QualType getObjCInterfaceType(const ObjCInterfaceDecl *Decl,\n                                ObjCInterfaceDecl *PrevDecl = nullptr) const;\n\n  /// Legacy interface: cannot provide type arguments or __kindof.\n  QualType getObjCObjectType(QualType Base,\n                             ObjCProtocolDecl * const *Protocols,\n                             unsigned NumProtocols) const;\n\n  QualType getObjCObjectType(QualType Base,\n                             ArrayRef<QualType> typeArgs,\n                             ArrayRef<ObjCProtocolDecl *> protocols,\n                             bool isKindOf) const;\n\n  QualType getObjCTypeParamType(const ObjCTypeParamDecl *Decl,\n                                ArrayRef<ObjCProtocolDecl *> protocols) const;\n  void adjustObjCTypeParamBoundType(const ObjCTypeParamDecl *Orig,\n                                    ObjCTypeParamDecl *New) const;\n\n  bool ObjCObjectAdoptsQTypeProtocols(QualType QT, ObjCInterfaceDecl *Decl);\n\n  /// QIdProtocolsAdoptObjCObjectProtocols - Checks that protocols in\n  /// QT's qualified-id protocol list adopt all protocols in IDecl's list\n  /// of protocols.\n  bool QIdProtocolsAdoptObjCObjectProtocols(QualType QT,\n                                            ObjCInterfaceDecl *IDecl);\n\n  /// Return a ObjCObjectPointerType type for the given ObjCObjectType.\n  QualType getObjCObjectPointerType(QualType OIT) const;\n\n  /// GCC extension.\n  QualType getTypeOfExprType(Expr *e) const;\n  QualType getTypeOfType(QualType t) const;\n\n  /// C++11 decltype.\n  QualType getDecltypeType(Expr *e, QualType UnderlyingType) const;\n\n  /// Unary type transforms\n  QualType getUnaryTransformType(QualType BaseType, QualType UnderlyingType,\n                                 UnaryTransformType::UTTKind UKind) const;\n\n  /// C++11 deduced auto type.\n  QualType getAutoType(QualType DeducedType, AutoTypeKeyword Keyword,\n                       bool IsDependent, bool IsPack = false,\n                       ConceptDecl *TypeConstraintConcept = nullptr,\n                       ArrayRef<TemplateArgument> TypeConstraintArgs ={}) const;\n\n  /// C++11 deduction pattern for 'auto' type.\n  QualType getAutoDeductType() const;\n\n  /// C++11 deduction pattern for 'auto &&' type.\n  QualType getAutoRRefDeductType() const;\n\n  /// C++17 deduced class template specialization type.\n  QualType getDeducedTemplateSpecializationType(TemplateName Template,\n                                                QualType DeducedType,\n                                                bool IsDependent) const;\n\n  /// Return the unique reference to the type for the specified TagDecl\n  /// (struct/union/class/enum) decl.\n  QualType getTagDeclType(const TagDecl *Decl) const;\n\n  /// Return the unique type for \"size_t\" (C99 7.17), defined in\n  /// <stddef.h>.\n  ///\n  /// The sizeof operator requires this (C99 6.5.3.4p4).\n  CanQualType getSizeType() const;\n\n  /// Return the unique signed counterpart of\n  /// the integer type corresponding to size_t.\n  CanQualType getSignedSizeType() const;\n\n  /// Return the unique type for \"intmax_t\" (C99 7.18.1.5), defined in\n  /// <stdint.h>.\n  CanQualType getIntMaxType() const;\n\n  /// Return the unique type for \"uintmax_t\" (C99 7.18.1.5), defined in\n  /// <stdint.h>.\n  CanQualType getUIntMaxType() const;\n\n  /// Return the unique wchar_t type available in C++ (and available as\n  /// __wchar_t as a Microsoft extension).\n  QualType getWCharType() const { return WCharTy; }\n\n  /// Return the type of wide characters. In C++, this returns the\n  /// unique wchar_t type. In C99, this returns a type compatible with the type\n  /// defined in <stddef.h> as defined by the target.\n  QualType getWideCharType() const { return WideCharTy; }\n\n  /// Return the type of \"signed wchar_t\".\n  ///\n  /// Used when in C++, as a GCC extension.\n  QualType getSignedWCharType() const;\n\n  /// Return the type of \"unsigned wchar_t\".\n  ///\n  /// Used when in C++, as a GCC extension.\n  QualType getUnsignedWCharType() const;\n\n  /// In C99, this returns a type compatible with the type\n  /// defined in <stddef.h> as defined by the target.\n  QualType getWIntType() const { return WIntTy; }\n\n  /// Return a type compatible with \"intptr_t\" (C99 7.18.1.4),\n  /// as defined by the target.\n  QualType getIntPtrType() const;\n\n  /// Return a type compatible with \"uintptr_t\" (C99 7.18.1.4),\n  /// as defined by the target.\n  QualType getUIntPtrType() const;\n\n  /// Return the unique type for \"ptrdiff_t\" (C99 7.17) defined in\n  /// <stddef.h>. Pointer - pointer requires this (C99 6.5.6p9).\n  QualType getPointerDiffType() const;\n\n  /// Return the unique unsigned counterpart of \"ptrdiff_t\"\n  /// integer type. The standard (C11 7.21.6.1p7) refers to this type\n  /// in the definition of %tu format specifier.\n  QualType getUnsignedPointerDiffType() const;\n\n  /// Return the unique type for \"pid_t\" defined in\n  /// <sys/types.h>. We need this to compute the correct type for vfork().\n  QualType getProcessIDType() const;\n\n  /// Return the C structure type used to represent constant CFStrings.\n  QualType getCFConstantStringType() const;\n\n  /// Returns the C struct type for objc_super\n  QualType getObjCSuperType() const;\n  void setObjCSuperType(QualType ST) { ObjCSuperType = ST; }\n\n  /// Get the structure type used to representation CFStrings, or NULL\n  /// if it hasn't yet been built.\n  QualType getRawCFConstantStringType() const {\n    if (CFConstantStringTypeDecl)\n      return getTypedefType(CFConstantStringTypeDecl);\n    return QualType();\n  }\n  void setCFConstantStringType(QualType T);\n  TypedefDecl *getCFConstantStringDecl() const;\n  RecordDecl *getCFConstantStringTagDecl() const;\n\n  // This setter/getter represents the ObjC type for an NSConstantString.\n  void setObjCConstantStringInterface(ObjCInterfaceDecl *Decl);\n  QualType getObjCConstantStringInterface() const {\n    return ObjCConstantStringType;\n  }\n\n  QualType getObjCNSStringType() const {\n    return ObjCNSStringType;\n  }\n\n  void setObjCNSStringType(QualType T) {\n    ObjCNSStringType = T;\n  }\n\n  /// Retrieve the type that \\c id has been defined to, which may be\n  /// different from the built-in \\c id if \\c id has been typedef'd.\n  QualType getObjCIdRedefinitionType() const {\n    if (ObjCIdRedefinitionType.isNull())\n      return getObjCIdType();\n    return ObjCIdRedefinitionType;\n  }\n\n  /// Set the user-written type that redefines \\c id.\n  void setObjCIdRedefinitionType(QualType RedefType) {\n    ObjCIdRedefinitionType = RedefType;\n  }\n\n  /// Retrieve the type that \\c Class has been defined to, which may be\n  /// different from the built-in \\c Class if \\c Class has been typedef'd.\n  QualType getObjCClassRedefinitionType() const {\n    if (ObjCClassRedefinitionType.isNull())\n      return getObjCClassType();\n    return ObjCClassRedefinitionType;\n  }\n\n  /// Set the user-written type that redefines 'SEL'.\n  void setObjCClassRedefinitionType(QualType RedefType) {\n    ObjCClassRedefinitionType = RedefType;\n  }\n\n  /// Retrieve the type that 'SEL' has been defined to, which may be\n  /// different from the built-in 'SEL' if 'SEL' has been typedef'd.\n  QualType getObjCSelRedefinitionType() const {\n    if (ObjCSelRedefinitionType.isNull())\n      return getObjCSelType();\n    return ObjCSelRedefinitionType;\n  }\n\n  /// Set the user-written type that redefines 'SEL'.\n  void setObjCSelRedefinitionType(QualType RedefType) {\n    ObjCSelRedefinitionType = RedefType;\n  }\n\n  /// Retrieve the identifier 'NSObject'.\n  IdentifierInfo *getNSObjectName() const {\n    if (!NSObjectName) {\n      NSObjectName = &Idents.get(\"NSObject\");\n    }\n\n    return NSObjectName;\n  }\n\n  /// Retrieve the identifier 'NSCopying'.\n  IdentifierInfo *getNSCopyingName() {\n    if (!NSCopyingName) {\n      NSCopyingName = &Idents.get(\"NSCopying\");\n    }\n\n    return NSCopyingName;\n  }\n\n  CanQualType getNSUIntegerType() const;\n\n  CanQualType getNSIntegerType() const;\n\n  /// Retrieve the identifier 'bool'.\n  IdentifierInfo *getBoolName() const {\n    if (!BoolName)\n      BoolName = &Idents.get(\"bool\");\n    return BoolName;\n  }\n\n  IdentifierInfo *getMakeIntegerSeqName() const {\n    if (!MakeIntegerSeqName)\n      MakeIntegerSeqName = &Idents.get(\"__make_integer_seq\");\n    return MakeIntegerSeqName;\n  }\n\n  IdentifierInfo *getTypePackElementName() const {\n    if (!TypePackElementName)\n      TypePackElementName = &Idents.get(\"__type_pack_element\");\n    return TypePackElementName;\n  }\n\n  /// Retrieve the Objective-C \"instancetype\" type, if already known;\n  /// otherwise, returns a NULL type;\n  QualType getObjCInstanceType() {\n    return getTypeDeclType(getObjCInstanceTypeDecl());\n  }\n\n  /// Retrieve the typedef declaration corresponding to the Objective-C\n  /// \"instancetype\" type.\n  TypedefDecl *getObjCInstanceTypeDecl();\n\n  /// Set the type for the C FILE type.\n  void setFILEDecl(TypeDecl *FILEDecl) { this->FILEDecl = FILEDecl; }\n\n  /// Retrieve the C FILE type.\n  QualType getFILEType() const {\n    if (FILEDecl)\n      return getTypeDeclType(FILEDecl);\n    return QualType();\n  }\n\n  /// Set the type for the C jmp_buf type.\n  void setjmp_bufDecl(TypeDecl *jmp_bufDecl) {\n    this->jmp_bufDecl = jmp_bufDecl;\n  }\n\n  /// Retrieve the C jmp_buf type.\n  QualType getjmp_bufType() const {\n    if (jmp_bufDecl)\n      return getTypeDeclType(jmp_bufDecl);\n    return QualType();\n  }\n\n  /// Set the type for the C sigjmp_buf type.\n  void setsigjmp_bufDecl(TypeDecl *sigjmp_bufDecl) {\n    this->sigjmp_bufDecl = sigjmp_bufDecl;\n  }\n\n  /// Retrieve the C sigjmp_buf type.\n  QualType getsigjmp_bufType() const {\n    if (sigjmp_bufDecl)\n      return getTypeDeclType(sigjmp_bufDecl);\n    return QualType();\n  }\n\n  /// Set the type for the C ucontext_t type.\n  void setucontext_tDecl(TypeDecl *ucontext_tDecl) {\n    this->ucontext_tDecl = ucontext_tDecl;\n  }\n\n  /// Retrieve the C ucontext_t type.\n  QualType getucontext_tType() const {\n    if (ucontext_tDecl)\n      return getTypeDeclType(ucontext_tDecl);\n    return QualType();\n  }\n\n  /// The result type of logical operations, '<', '>', '!=', etc.\n  QualType getLogicalOperationType() const {\n    return getLangOpts().CPlusPlus ? BoolTy : IntTy;\n  }\n\n  /// Emit the Objective-CC type encoding for the given type \\p T into\n  /// \\p S.\n  ///\n  /// If \\p Field is specified then record field names are also encoded.\n  void getObjCEncodingForType(QualType T, std::string &S,\n                              const FieldDecl *Field=nullptr,\n                              QualType *NotEncodedT=nullptr) const;\n\n  /// Emit the Objective-C property type encoding for the given\n  /// type \\p T into \\p S.\n  void getObjCEncodingForPropertyType(QualType T, std::string &S) const;\n\n  void getLegacyIntegralTypeEncoding(QualType &t) const;\n\n  /// Put the string version of the type qualifiers \\p QT into \\p S.\n  void getObjCEncodingForTypeQualifier(Decl::ObjCDeclQualifier QT,\n                                       std::string &S) const;\n\n  /// Emit the encoded type for the function \\p Decl into \\p S.\n  ///\n  /// This is in the same format as Objective-C method encodings.\n  ///\n  /// \\returns true if an error occurred (e.g., because one of the parameter\n  /// types is incomplete), false otherwise.\n  std::string getObjCEncodingForFunctionDecl(const FunctionDecl *Decl) const;\n\n  /// Emit the encoded type for the method declaration \\p Decl into\n  /// \\p S.\n  std::string getObjCEncodingForMethodDecl(const ObjCMethodDecl *Decl,\n                                           bool Extended = false) const;\n\n  /// Return the encoded type for this block declaration.\n  std::string getObjCEncodingForBlock(const BlockExpr *blockExpr) const;\n\n  /// getObjCEncodingForPropertyDecl - Return the encoded type for\n  /// this method declaration. If non-NULL, Container must be either\n  /// an ObjCCategoryImplDecl or ObjCImplementationDecl; it should\n  /// only be NULL when getting encodings for protocol properties.\n  std::string getObjCEncodingForPropertyDecl(const ObjCPropertyDecl *PD,\n                                             const Decl *Container) const;\n\n  bool ProtocolCompatibleWithProtocol(ObjCProtocolDecl *lProto,\n                                      ObjCProtocolDecl *rProto) const;\n\n  ObjCPropertyImplDecl *getObjCPropertyImplDeclForPropertyDecl(\n                                                  const ObjCPropertyDecl *PD,\n                                                  const Decl *Container) const;\n\n  /// Return the size of type \\p T for Objective-C encoding purpose,\n  /// in characters.\n  CharUnits getObjCEncodingTypeSize(QualType T) const;\n\n  /// Retrieve the typedef corresponding to the predefined \\c id type\n  /// in Objective-C.\n  TypedefDecl *getObjCIdDecl() const;\n\n  /// Represents the Objective-CC \\c id type.\n  ///\n  /// This is set up lazily, by Sema.  \\c id is always a (typedef for a)\n  /// pointer type, a pointer to a struct.\n  QualType getObjCIdType() const {\n    return getTypeDeclType(getObjCIdDecl());\n  }\n\n  /// Retrieve the typedef corresponding to the predefined 'SEL' type\n  /// in Objective-C.\n  TypedefDecl *getObjCSelDecl() const;\n\n  /// Retrieve the type that corresponds to the predefined Objective-C\n  /// 'SEL' type.\n  QualType getObjCSelType() const {\n    return getTypeDeclType(getObjCSelDecl());\n  }\n\n  /// Retrieve the typedef declaration corresponding to the predefined\n  /// Objective-C 'Class' type.\n  TypedefDecl *getObjCClassDecl() const;\n\n  /// Represents the Objective-C \\c Class type.\n  ///\n  /// This is set up lazily, by Sema.  \\c Class is always a (typedef for a)\n  /// pointer type, a pointer to a struct.\n  QualType getObjCClassType() const {\n    return getTypeDeclType(getObjCClassDecl());\n  }\n\n  /// Retrieve the Objective-C class declaration corresponding to\n  /// the predefined \\c Protocol class.\n  ObjCInterfaceDecl *getObjCProtocolDecl() const;\n\n  /// Retrieve declaration of 'BOOL' typedef\n  TypedefDecl *getBOOLDecl() const {\n    return BOOLDecl;\n  }\n\n  /// Save declaration of 'BOOL' typedef\n  void setBOOLDecl(TypedefDecl *TD) {\n    BOOLDecl = TD;\n  }\n\n  /// type of 'BOOL' type.\n  QualType getBOOLType() const {\n    return getTypeDeclType(getBOOLDecl());\n  }\n\n  /// Retrieve the type of the Objective-C \\c Protocol class.\n  QualType getObjCProtoType() const {\n    return getObjCInterfaceType(getObjCProtocolDecl());\n  }\n\n  /// Retrieve the C type declaration corresponding to the predefined\n  /// \\c __builtin_va_list type.\n  TypedefDecl *getBuiltinVaListDecl() const;\n\n  /// Retrieve the type of the \\c __builtin_va_list type.\n  QualType getBuiltinVaListType() const {\n    return getTypeDeclType(getBuiltinVaListDecl());\n  }\n\n  /// Retrieve the C type declaration corresponding to the predefined\n  /// \\c __va_list_tag type used to help define the \\c __builtin_va_list type\n  /// for some targets.\n  Decl *getVaListTagDecl() const;\n\n  /// Retrieve the C type declaration corresponding to the predefined\n  /// \\c __builtin_ms_va_list type.\n  TypedefDecl *getBuiltinMSVaListDecl() const;\n\n  /// Retrieve the type of the \\c __builtin_ms_va_list type.\n  QualType getBuiltinMSVaListType() const {\n    return getTypeDeclType(getBuiltinMSVaListDecl());\n  }\n\n  /// Retrieve the implicitly-predeclared 'struct _GUID' declaration.\n  TagDecl *getMSGuidTagDecl() const { return MSGuidTagDecl; }\n\n  /// Retrieve the implicitly-predeclared 'struct _GUID' type.\n  QualType getMSGuidType() const {\n    assert(MSGuidTagDecl && \"asked for GUID type but MS extensions disabled\");\n    return getTagDeclType(MSGuidTagDecl);\n  }\n\n  /// Return whether a declaration to a builtin is allowed to be\n  /// overloaded/redeclared.\n  bool canBuiltinBeRedeclared(const FunctionDecl *) const;\n\n  /// Return a type with additional \\c const, \\c volatile, or\n  /// \\c restrict qualifiers.\n  QualType getCVRQualifiedType(QualType T, unsigned CVR) const {\n    return getQualifiedType(T, Qualifiers::fromCVRMask(CVR));\n  }\n\n  /// Un-split a SplitQualType.\n  QualType getQualifiedType(SplitQualType split) const {\n    return getQualifiedType(split.Ty, split.Quals);\n  }\n\n  /// Return a type with additional qualifiers.\n  QualType getQualifiedType(QualType T, Qualifiers Qs) const {\n    if (!Qs.hasNonFastQualifiers())\n      return T.withFastQualifiers(Qs.getFastQualifiers());\n    QualifierCollector Qc(Qs);\n    const Type *Ptr = Qc.strip(T);\n    return getExtQualType(Ptr, Qc);\n  }\n\n  /// Return a type with additional qualifiers.\n  QualType getQualifiedType(const Type *T, Qualifiers Qs) const {\n    if (!Qs.hasNonFastQualifiers())\n      return QualType(T, Qs.getFastQualifiers());\n    return getExtQualType(T, Qs);\n  }\n\n  /// Return a type with the given lifetime qualifier.\n  ///\n  /// \\pre Neither type.ObjCLifetime() nor \\p lifetime may be \\c OCL_None.\n  QualType getLifetimeQualifiedType(QualType type,\n                                    Qualifiers::ObjCLifetime lifetime) {\n    assert(type.getObjCLifetime() == Qualifiers::OCL_None);\n    assert(lifetime != Qualifiers::OCL_None);\n\n    Qualifiers qs;\n    qs.addObjCLifetime(lifetime);\n    return getQualifiedType(type, qs);\n  }\n\n  /// getUnqualifiedObjCPointerType - Returns version of\n  /// Objective-C pointer type with lifetime qualifier removed.\n  QualType getUnqualifiedObjCPointerType(QualType type) const {\n    if (!type.getTypePtr()->isObjCObjectPointerType() ||\n        !type.getQualifiers().hasObjCLifetime())\n      return type;\n    Qualifiers Qs = type.getQualifiers();\n    Qs.removeObjCLifetime();\n    return getQualifiedType(type.getUnqualifiedType(), Qs);\n  }\n\n  unsigned char getFixedPointScale(QualType Ty) const;\n  unsigned char getFixedPointIBits(QualType Ty) const;\n  llvm::FixedPointSemantics getFixedPointSemantics(QualType Ty) const;\n  llvm::APFixedPoint getFixedPointMax(QualType Ty) const;\n  llvm::APFixedPoint getFixedPointMin(QualType Ty) const;\n\n  DeclarationNameInfo getNameForTemplate(TemplateName Name,\n                                         SourceLocation NameLoc) const;\n\n  TemplateName getOverloadedTemplateName(UnresolvedSetIterator Begin,\n                                         UnresolvedSetIterator End) const;\n  TemplateName getAssumedTemplateName(DeclarationName Name) const;\n\n  TemplateName getQualifiedTemplateName(NestedNameSpecifier *NNS,\n                                        bool TemplateKeyword,\n                                        TemplateDecl *Template) const;\n\n  TemplateName getDependentTemplateName(NestedNameSpecifier *NNS,\n                                        const IdentifierInfo *Name) const;\n  TemplateName getDependentTemplateName(NestedNameSpecifier *NNS,\n                                        OverloadedOperatorKind Operator) const;\n  TemplateName getSubstTemplateTemplateParm(TemplateTemplateParmDecl *param,\n                                            TemplateName replacement) const;\n  TemplateName getSubstTemplateTemplateParmPack(TemplateTemplateParmDecl *Param,\n                                        const TemplateArgument &ArgPack) const;\n\n  enum GetBuiltinTypeError {\n    /// No error\n    GE_None,\n\n    /// Missing a type\n    GE_Missing_type,\n\n    /// Missing a type from <stdio.h>\n    GE_Missing_stdio,\n\n    /// Missing a type from <setjmp.h>\n    GE_Missing_setjmp,\n\n    /// Missing a type from <ucontext.h>\n    GE_Missing_ucontext\n  };\n\n  QualType DecodeTypeStr(const char *&Str, const ASTContext &Context,\n                         ASTContext::GetBuiltinTypeError &Error,\n                         bool &RequireICE, bool AllowTypeModifiers) const;\n\n  /// Return the type for the specified builtin.\n  ///\n  /// If \\p IntegerConstantArgs is non-null, it is filled in with a bitmask of\n  /// arguments to the builtin that are required to be integer constant\n  /// expressions.\n  QualType GetBuiltinType(unsigned ID, GetBuiltinTypeError &Error,\n                          unsigned *IntegerConstantArgs = nullptr) const;\n\n  /// Types and expressions required to build C++2a three-way comparisons\n  /// using operator<=>, including the values return by builtin <=> operators.\n  ComparisonCategories CompCategories;\n\nprivate:\n  CanQualType getFromTargetType(unsigned Type) const;\n  TypeInfo getTypeInfoImpl(const Type *T) const;\n\n  //===--------------------------------------------------------------------===//\n  //                         Type Predicates.\n  //===--------------------------------------------------------------------===//\n\npublic:\n  /// Return one of the GCNone, Weak or Strong Objective-C garbage\n  /// collection attributes.\n  Qualifiers::GC getObjCGCAttrKind(QualType Ty) const;\n\n  /// Return true if the given vector types are of the same unqualified\n  /// type or if they are equivalent to the same GCC vector type.\n  ///\n  /// \\note This ignores whether they are target-specific (AltiVec or Neon)\n  /// types.\n  bool areCompatibleVectorTypes(QualType FirstVec, QualType SecondVec);\n\n  /// Return true if the given types are an SVE builtin and a VectorType that\n  /// is a fixed-length representation of the SVE builtin for a specific\n  /// vector-length.\n  bool areCompatibleSveTypes(QualType FirstType, QualType SecondType);\n\n  /// Return true if the given vector types are lax-compatible SVE vector types,\n  /// false otherwise.\n  bool areLaxCompatibleSveTypes(QualType FirstType, QualType SecondType);\n\n  /// Return true if the type has been explicitly qualified with ObjC ownership.\n  /// A type may be implicitly qualified with ownership under ObjC ARC, and in\n  /// some cases the compiler treats these differently.\n  bool hasDirectOwnershipQualifier(QualType Ty) const;\n\n  /// Return true if this is an \\c NSObject object with its \\c NSObject\n  /// attribute set.\n  static bool isObjCNSObjectType(QualType Ty) {\n    return Ty->isObjCNSObjectType();\n  }\n\n  //===--------------------------------------------------------------------===//\n  //                         Type Sizing and Analysis\n  //===--------------------------------------------------------------------===//\n\n  /// Return the APFloat 'semantics' for the specified scalar floating\n  /// point type.\n  const llvm::fltSemantics &getFloatTypeSemantics(QualType T) const;\n\n  /// Get the size and alignment of the specified complete type in bits.\n  TypeInfo getTypeInfo(const Type *T) const;\n  TypeInfo getTypeInfo(QualType T) const { return getTypeInfo(T.getTypePtr()); }\n\n  /// Get default simd alignment of the specified complete type in bits.\n  unsigned getOpenMPDefaultSimdAlign(QualType T) const;\n\n  /// Return the size of the specified (complete) type \\p T, in bits.\n  uint64_t getTypeSize(QualType T) const { return getTypeInfo(T).Width; }\n  uint64_t getTypeSize(const Type *T) const { return getTypeInfo(T).Width; }\n\n  /// Return the size of the character type, in bits.\n  uint64_t getCharWidth() const {\n    return getTypeSize(CharTy);\n  }\n\n  /// Convert a size in bits to a size in characters.\n  CharUnits toCharUnitsFromBits(int64_t BitSize) const;\n\n  /// Convert a size in characters to a size in bits.\n  int64_t toBits(CharUnits CharSize) const;\n\n  /// Return the size of the specified (complete) type \\p T, in\n  /// characters.\n  CharUnits getTypeSizeInChars(QualType T) const;\n  CharUnits getTypeSizeInChars(const Type *T) const;\n\n  Optional<CharUnits> getTypeSizeInCharsIfKnown(QualType Ty) const {\n    if (Ty->isIncompleteType() || Ty->isDependentType())\n      return None;\n    return getTypeSizeInChars(Ty);\n  }\n\n  Optional<CharUnits> getTypeSizeInCharsIfKnown(const Type *Ty) const {\n    return getTypeSizeInCharsIfKnown(QualType(Ty, 0));\n  }\n\n  /// Return the ABI-specified alignment of a (complete) type \\p T, in\n  /// bits.\n  unsigned getTypeAlign(QualType T) const { return getTypeInfo(T).Align; }\n  unsigned getTypeAlign(const Type *T) const { return getTypeInfo(T).Align; }\n\n  /// Return the ABI-specified natural alignment of a (complete) type \\p T,\n  /// before alignment adjustments, in bits.\n  ///\n  /// This alignment is curently used only by ARM and AArch64 when passing\n  /// arguments of a composite type.\n  unsigned getTypeUnadjustedAlign(QualType T) const {\n    return getTypeUnadjustedAlign(T.getTypePtr());\n  }\n  unsigned getTypeUnadjustedAlign(const Type *T) const;\n\n  /// Return the alignment of a type, in bits, or 0 if\n  /// the type is incomplete and we cannot determine the alignment (for\n  /// example, from alignment attributes). The returned alignment is the\n  /// Preferred alignment if NeedsPreferredAlignment is true, otherwise is the\n  /// ABI alignment.\n  unsigned getTypeAlignIfKnown(QualType T,\n                               bool NeedsPreferredAlignment = false) const;\n\n  /// Return the ABI-specified alignment of a (complete) type \\p T, in\n  /// characters.\n  CharUnits getTypeAlignInChars(QualType T) const;\n  CharUnits getTypeAlignInChars(const Type *T) const;\n\n  /// Return the PreferredAlignment of a (complete) type \\p T, in\n  /// characters.\n  CharUnits getPreferredTypeAlignInChars(QualType T) const {\n    return toCharUnitsFromBits(getPreferredTypeAlign(T));\n  }\n\n  /// getTypeUnadjustedAlignInChars - Return the ABI-specified alignment of a type,\n  /// in characters, before alignment adjustments. This method does not work on\n  /// incomplete types.\n  CharUnits getTypeUnadjustedAlignInChars(QualType T) const;\n  CharUnits getTypeUnadjustedAlignInChars(const Type *T) const;\n\n  // getTypeInfoDataSizeInChars - Return the size of a type, in chars. If the\n  // type is a record, its data size is returned.\n  TypeInfoChars getTypeInfoDataSizeInChars(QualType T) const;\n\n  TypeInfoChars getTypeInfoInChars(const Type *T) const;\n  TypeInfoChars getTypeInfoInChars(QualType T) const;\n\n  /// Determine if the alignment the type has was required using an\n  /// alignment attribute.\n  bool isAlignmentRequired(const Type *T) const;\n  bool isAlignmentRequired(QualType T) const;\n\n  /// Return the \"preferred\" alignment of the specified type \\p T for\n  /// the current target, in bits.\n  ///\n  /// This can be different than the ABI alignment in cases where it is\n  /// beneficial for performance or backwards compatibility preserving to\n  /// overalign a data type. (Note: despite the name, the preferred alignment\n  /// is ABI-impacting, and not an optimization.)\n  unsigned getPreferredTypeAlign(QualType T) const {\n    return getPreferredTypeAlign(T.getTypePtr());\n  }\n  unsigned getPreferredTypeAlign(const Type *T) const;\n\n  /// Return the default alignment for __attribute__((aligned)) on\n  /// this target, to be used if no alignment value is specified.\n  unsigned getTargetDefaultAlignForAttributeAligned() const;\n\n  /// Return the alignment in bits that should be given to a\n  /// global variable with type \\p T.\n  unsigned getAlignOfGlobalVar(QualType T) const;\n\n  /// Return the alignment in characters that should be given to a\n  /// global variable with type \\p T.\n  CharUnits getAlignOfGlobalVarInChars(QualType T) const;\n\n  /// Return a conservative estimate of the alignment of the specified\n  /// decl \\p D.\n  ///\n  /// \\pre \\p D must not be a bitfield type, as bitfields do not have a valid\n  /// alignment.\n  ///\n  /// If \\p ForAlignof, references are treated like their underlying type\n  /// and  large arrays don't get any special treatment. If not \\p ForAlignof\n  /// it computes the value expected by CodeGen: references are treated like\n  /// pointers and large arrays get extra alignment.\n  CharUnits getDeclAlign(const Decl *D, bool ForAlignof = false) const;\n\n  /// Return the alignment (in bytes) of the thrown exception object. This is\n  /// only meaningful for targets that allocate C++ exceptions in a system\n  /// runtime, such as those using the Itanium C++ ABI.\n  CharUnits getExnObjectAlignment() const;\n\n  /// Get or compute information about the layout of the specified\n  /// record (struct/union/class) \\p D, which indicates its size and field\n  /// position information.\n  const ASTRecordLayout &getASTRecordLayout(const RecordDecl *D) const;\n\n  /// Get or compute information about the layout of the specified\n  /// Objective-C interface.\n  const ASTRecordLayout &getASTObjCInterfaceLayout(const ObjCInterfaceDecl *D)\n    const;\n\n  void DumpRecordLayout(const RecordDecl *RD, raw_ostream &OS,\n                        bool Simple = false) const;\n\n  /// Get or compute information about the layout of the specified\n  /// Objective-C implementation.\n  ///\n  /// This may differ from the interface if synthesized ivars are present.\n  const ASTRecordLayout &\n  getASTObjCImplementationLayout(const ObjCImplementationDecl *D) const;\n\n  /// Get our current best idea for the key function of the\n  /// given record decl, or nullptr if there isn't one.\n  ///\n  /// The key function is, according to the Itanium C++ ABI section 5.2.3:\n  ///   ...the first non-pure virtual function that is not inline at the\n  ///   point of class definition.\n  ///\n  /// Other ABIs use the same idea.  However, the ARM C++ ABI ignores\n  /// virtual functions that are defined 'inline', which means that\n  /// the result of this computation can change.\n  const CXXMethodDecl *getCurrentKeyFunction(const CXXRecordDecl *RD);\n\n  /// Observe that the given method cannot be a key function.\n  /// Checks the key-function cache for the method's class and clears it\n  /// if matches the given declaration.\n  ///\n  /// This is used in ABIs where out-of-line definitions marked\n  /// inline are not considered to be key functions.\n  ///\n  /// \\param method should be the declaration from the class definition\n  void setNonKeyFunction(const CXXMethodDecl *method);\n\n  /// Loading virtual member pointers using the virtual inheritance model\n  /// always results in an adjustment using the vbtable even if the index is\n  /// zero.\n  ///\n  /// This is usually OK because the first slot in the vbtable points\n  /// backwards to the top of the MDC.  However, the MDC might be reusing a\n  /// vbptr from an nv-base.  In this case, the first slot in the vbtable\n  /// points to the start of the nv-base which introduced the vbptr and *not*\n  /// the MDC.  Modify the NonVirtualBaseAdjustment to account for this.\n  CharUnits getOffsetOfBaseWithVBPtr(const CXXRecordDecl *RD) const;\n\n  /// Get the offset of a FieldDecl or IndirectFieldDecl, in bits.\n  uint64_t getFieldOffset(const ValueDecl *FD) const;\n\n  /// Get the offset of an ObjCIvarDecl in bits.\n  uint64_t lookupFieldBitOffset(const ObjCInterfaceDecl *OID,\n                                const ObjCImplementationDecl *ID,\n                                const ObjCIvarDecl *Ivar) const;\n\n  /// Find the 'this' offset for the member path in a pointer-to-member\n  /// APValue.\n  CharUnits getMemberPointerPathAdjustment(const APValue &MP) const;\n\n  bool isNearlyEmpty(const CXXRecordDecl *RD) const;\n\n  VTableContextBase *getVTableContext();\n\n  /// If \\p T is null pointer, assume the target in ASTContext.\n  MangleContext *createMangleContext(const TargetInfo *T = nullptr);\n\n  void DeepCollectObjCIvars(const ObjCInterfaceDecl *OI, bool leafClass,\n                            SmallVectorImpl<const ObjCIvarDecl*> &Ivars) const;\n\n  unsigned CountNonClassIvars(const ObjCInterfaceDecl *OI) const;\n  void CollectInheritedProtocols(const Decl *CDecl,\n                          llvm::SmallPtrSet<ObjCProtocolDecl*, 8> &Protocols);\n\n  /// Return true if the specified type has unique object representations\n  /// according to (C++17 [meta.unary.prop]p9)\n  bool hasUniqueObjectRepresentations(QualType Ty) const;\n\n  //===--------------------------------------------------------------------===//\n  //                            Type Operators\n  //===--------------------------------------------------------------------===//\n\n  /// Return the canonical (structural) type corresponding to the\n  /// specified potentially non-canonical type \\p T.\n  ///\n  /// The non-canonical version of a type may have many \"decorated\" versions of\n  /// types.  Decorators can include typedefs, 'typeof' operators, etc. The\n  /// returned type is guaranteed to be free of any of these, allowing two\n  /// canonical types to be compared for exact equality with a simple pointer\n  /// comparison.\n  CanQualType getCanonicalType(QualType T) const {\n    return CanQualType::CreateUnsafe(T.getCanonicalType());\n  }\n\n  const Type *getCanonicalType(const Type *T) const {\n    return T->getCanonicalTypeInternal().getTypePtr();\n  }\n\n  /// Return the canonical parameter type corresponding to the specific\n  /// potentially non-canonical one.\n  ///\n  /// Qualifiers are stripped off, functions are turned into function\n  /// pointers, and arrays decay one level into pointers.\n  CanQualType getCanonicalParamType(QualType T) const;\n\n  /// Determine whether the given types \\p T1 and \\p T2 are equivalent.\n  bool hasSameType(QualType T1, QualType T2) const {\n    return getCanonicalType(T1) == getCanonicalType(T2);\n  }\n  bool hasSameType(const Type *T1, const Type *T2) const {\n    return getCanonicalType(T1) == getCanonicalType(T2);\n  }\n\n  /// Return this type as a completely-unqualified array type,\n  /// capturing the qualifiers in \\p Quals.\n  ///\n  /// This will remove the minimal amount of sugaring from the types, similar\n  /// to the behavior of QualType::getUnqualifiedType().\n  ///\n  /// \\param T is the qualified type, which may be an ArrayType\n  ///\n  /// \\param Quals will receive the full set of qualifiers that were\n  /// applied to the array.\n  ///\n  /// \\returns if this is an array type, the completely unqualified array type\n  /// that corresponds to it. Otherwise, returns T.getUnqualifiedType().\n  QualType getUnqualifiedArrayType(QualType T, Qualifiers &Quals);\n\n  /// Determine whether the given types are equivalent after\n  /// cvr-qualifiers have been removed.\n  bool hasSameUnqualifiedType(QualType T1, QualType T2) const {\n    return getCanonicalType(T1).getTypePtr() ==\n           getCanonicalType(T2).getTypePtr();\n  }\n\n  bool hasSameNullabilityTypeQualifier(QualType SubT, QualType SuperT,\n                                       bool IsParam) const {\n    auto SubTnullability = SubT->getNullability(*this);\n    auto SuperTnullability = SuperT->getNullability(*this);\n    if (SubTnullability.hasValue() == SuperTnullability.hasValue()) {\n      // Neither has nullability; return true\n      if (!SubTnullability)\n        return true;\n      // Both have nullability qualifier.\n      if (*SubTnullability == *SuperTnullability ||\n          *SubTnullability == NullabilityKind::Unspecified ||\n          *SuperTnullability == NullabilityKind::Unspecified)\n        return true;\n\n      if (IsParam) {\n        // Ok for the superclass method parameter to be \"nonnull\" and the subclass\n        // method parameter to be \"nullable\"\n        return (*SuperTnullability == NullabilityKind::NonNull &&\n                *SubTnullability == NullabilityKind::Nullable);\n      }\n      // For the return type, it's okay for the superclass method to specify\n      // \"nullable\" and the subclass method specify \"nonnull\"\n      return (*SuperTnullability == NullabilityKind::Nullable &&\n              *SubTnullability == NullabilityKind::NonNull);\n    }\n    return true;\n  }\n\n  bool ObjCMethodsAreEqual(const ObjCMethodDecl *MethodDecl,\n                           const ObjCMethodDecl *MethodImp);\n\n  bool UnwrapSimilarTypes(QualType &T1, QualType &T2);\n  bool UnwrapSimilarArrayTypes(QualType &T1, QualType &T2);\n\n  /// Determine if two types are similar, according to the C++ rules. That is,\n  /// determine if they are the same other than qualifiers on the initial\n  /// sequence of pointer / pointer-to-member / array (and in Clang, object\n  /// pointer) types and their element types.\n  ///\n  /// Clang offers a number of qualifiers in addition to the C++ qualifiers;\n  /// those qualifiers are also ignored in the 'similarity' check.\n  bool hasSimilarType(QualType T1, QualType T2);\n\n  /// Determine if two types are similar, ignoring only CVR qualifiers.\n  bool hasCvrSimilarType(QualType T1, QualType T2);\n\n  /// Retrieves the \"canonical\" nested name specifier for a\n  /// given nested name specifier.\n  ///\n  /// The canonical nested name specifier is a nested name specifier\n  /// that uniquely identifies a type or namespace within the type\n  /// system. For example, given:\n  ///\n  /// \\code\n  /// namespace N {\n  ///   struct S {\n  ///     template<typename T> struct X { typename T* type; };\n  ///   };\n  /// }\n  ///\n  /// template<typename T> struct Y {\n  ///   typename N::S::X<T>::type member;\n  /// };\n  /// \\endcode\n  ///\n  /// Here, the nested-name-specifier for N::S::X<T>:: will be\n  /// S::X<template-param-0-0>, since 'S' and 'X' are uniquely defined\n  /// by declarations in the type system and the canonical type for\n  /// the template type parameter 'T' is template-param-0-0.\n  NestedNameSpecifier *\n  getCanonicalNestedNameSpecifier(NestedNameSpecifier *NNS) const;\n\n  /// Retrieves the default calling convention for the current target.\n  CallingConv getDefaultCallingConvention(bool IsVariadic,\n                                          bool IsCXXMethod,\n                                          bool IsBuiltin = false) const;\n\n  /// Retrieves the \"canonical\" template name that refers to a\n  /// given template.\n  ///\n  /// The canonical template name is the simplest expression that can\n  /// be used to refer to a given template. For most templates, this\n  /// expression is just the template declaration itself. For example,\n  /// the template std::vector can be referred to via a variety of\n  /// names---std::vector, \\::std::vector, vector (if vector is in\n  /// scope), etc.---but all of these names map down to the same\n  /// TemplateDecl, which is used to form the canonical template name.\n  ///\n  /// Dependent template names are more interesting. Here, the\n  /// template name could be something like T::template apply or\n  /// std::allocator<T>::template rebind, where the nested name\n  /// specifier itself is dependent. In this case, the canonical\n  /// template name uses the shortest form of the dependent\n  /// nested-name-specifier, which itself contains all canonical\n  /// types, values, and templates.\n  TemplateName getCanonicalTemplateName(TemplateName Name) const;\n\n  /// Determine whether the given template names refer to the same\n  /// template.\n  bool hasSameTemplateName(TemplateName X, TemplateName Y);\n\n  /// Retrieve the \"canonical\" template argument.\n  ///\n  /// The canonical template argument is the simplest template argument\n  /// (which may be a type, value, expression, or declaration) that\n  /// expresses the value of the argument.\n  TemplateArgument getCanonicalTemplateArgument(const TemplateArgument &Arg)\n    const;\n\n  /// Type Query functions.  If the type is an instance of the specified class,\n  /// return the Type pointer for the underlying maximally pretty type.  This\n  /// is a member of ASTContext because this may need to do some amount of\n  /// canonicalization, e.g. to move type qualifiers into the element type.\n  const ArrayType *getAsArrayType(QualType T) const;\n  const ConstantArrayType *getAsConstantArrayType(QualType T) const {\n    return dyn_cast_or_null<ConstantArrayType>(getAsArrayType(T));\n  }\n  const VariableArrayType *getAsVariableArrayType(QualType T) const {\n    return dyn_cast_or_null<VariableArrayType>(getAsArrayType(T));\n  }\n  const IncompleteArrayType *getAsIncompleteArrayType(QualType T) const {\n    return dyn_cast_or_null<IncompleteArrayType>(getAsArrayType(T));\n  }\n  const DependentSizedArrayType *getAsDependentSizedArrayType(QualType T)\n    const {\n    return dyn_cast_or_null<DependentSizedArrayType>(getAsArrayType(T));\n  }\n\n  /// Return the innermost element type of an array type.\n  ///\n  /// For example, will return \"int\" for int[m][n]\n  QualType getBaseElementType(const ArrayType *VAT) const;\n\n  /// Return the innermost element type of a type (which needn't\n  /// actually be an array type).\n  QualType getBaseElementType(QualType QT) const;\n\n  /// Return number of constant array elements.\n  uint64_t getConstantArrayElementCount(const ConstantArrayType *CA) const;\n\n  /// Perform adjustment on the parameter type of a function.\n  ///\n  /// This routine adjusts the given parameter type @p T to the actual\n  /// parameter type used by semantic analysis (C99 6.7.5.3p[7,8],\n  /// C++ [dcl.fct]p3). The adjusted parameter type is returned.\n  QualType getAdjustedParameterType(QualType T) const;\n\n  /// Retrieve the parameter type as adjusted for use in the signature\n  /// of a function, decaying array and function types and removing top-level\n  /// cv-qualifiers.\n  QualType getSignatureParameterType(QualType T) const;\n\n  QualType getExceptionObjectType(QualType T) const;\n\n  /// Return the properly qualified result of decaying the specified\n  /// array type to a pointer.\n  ///\n  /// This operation is non-trivial when handling typedefs etc.  The canonical\n  /// type of \\p T must be an array type, this returns a pointer to a properly\n  /// qualified element of the array.\n  ///\n  /// See C99 6.7.5.3p7 and C99 6.3.2.1p3.\n  QualType getArrayDecayedType(QualType T) const;\n\n  /// Return the type that \\p PromotableType will promote to: C99\n  /// 6.3.1.1p2, assuming that \\p PromotableType is a promotable integer type.\n  QualType getPromotedIntegerType(QualType PromotableType) const;\n\n  /// Recurses in pointer/array types until it finds an Objective-C\n  /// retainable type and returns its ownership.\n  Qualifiers::ObjCLifetime getInnerObjCOwnership(QualType T) const;\n\n  /// Whether this is a promotable bitfield reference according\n  /// to C99 6.3.1.1p2, bullet 2 (and GCC extensions).\n  ///\n  /// \\returns the type this bit-field will promote to, or NULL if no\n  /// promotion occurs.\n  QualType isPromotableBitField(Expr *E) const;\n\n  /// Return the highest ranked integer type, see C99 6.3.1.8p1.\n  ///\n  /// If \\p LHS > \\p RHS, returns 1.  If \\p LHS == \\p RHS, returns 0.  If\n  /// \\p LHS < \\p RHS, return -1.\n  int getIntegerTypeOrder(QualType LHS, QualType RHS) const;\n\n  /// Compare the rank of the two specified floating point types,\n  /// ignoring the domain of the type (i.e. 'double' == '_Complex double').\n  ///\n  /// If \\p LHS > \\p RHS, returns 1.  If \\p LHS == \\p RHS, returns 0.  If\n  /// \\p LHS < \\p RHS, return -1.\n  int getFloatingTypeOrder(QualType LHS, QualType RHS) const;\n\n  /// Compare the rank of two floating point types as above, but compare equal\n  /// if both types have the same floating-point semantics on the target (i.e.\n  /// long double and double on AArch64 will return 0).\n  int getFloatingTypeSemanticOrder(QualType LHS, QualType RHS) const;\n\n  /// Return a real floating point or a complex type (based on\n  /// \\p typeDomain/\\p typeSize).\n  ///\n  /// \\param typeDomain a real floating point or complex type.\n  /// \\param typeSize a real floating point or complex type.\n  QualType getFloatingTypeOfSizeWithinDomain(QualType typeSize,\n                                             QualType typeDomain) const;\n\n  unsigned getTargetAddressSpace(QualType T) const {\n    return getTargetAddressSpace(T.getQualifiers());\n  }\n\n  unsigned getTargetAddressSpace(Qualifiers Q) const {\n    return getTargetAddressSpace(Q.getAddressSpace());\n  }\n\n  unsigned getTargetAddressSpace(LangAS AS) const;\n\n  LangAS getLangASForBuiltinAddressSpace(unsigned AS) const;\n\n  /// Get target-dependent integer value for null pointer which is used for\n  /// constant folding.\n  uint64_t getTargetNullPointerValue(QualType QT) const;\n\n  bool addressSpaceMapManglingFor(LangAS AS) const {\n    return AddrSpaceMapMangling || isTargetAddressSpace(AS);\n  }\n\nprivate:\n  // Helper for integer ordering\n  unsigned getIntegerRank(const Type *T) const;\n\npublic:\n  //===--------------------------------------------------------------------===//\n  //                    Type Compatibility Predicates\n  //===--------------------------------------------------------------------===//\n\n  /// Compatibility predicates used to check assignment expressions.\n  bool typesAreCompatible(QualType T1, QualType T2,\n                          bool CompareUnqualified = false); // C99 6.2.7p1\n\n  bool propertyTypesAreCompatible(QualType, QualType);\n  bool typesAreBlockPointerCompatible(QualType, QualType);\n\n  bool isObjCIdType(QualType T) const {\n    return T == getObjCIdType();\n  }\n\n  bool isObjCClassType(QualType T) const {\n    return T == getObjCClassType();\n  }\n\n  bool isObjCSelType(QualType T) const {\n    return T == getObjCSelType();\n  }\n\n  bool ObjCQualifiedIdTypesAreCompatible(const ObjCObjectPointerType *LHS,\n                                         const ObjCObjectPointerType *RHS,\n                                         bool ForCompare);\n\n  bool ObjCQualifiedClassTypesAreCompatible(const ObjCObjectPointerType *LHS,\n                                            const ObjCObjectPointerType *RHS);\n\n  // Check the safety of assignment from LHS to RHS\n  bool canAssignObjCInterfaces(const ObjCObjectPointerType *LHSOPT,\n                               const ObjCObjectPointerType *RHSOPT);\n  bool canAssignObjCInterfaces(const ObjCObjectType *LHS,\n                               const ObjCObjectType *RHS);\n  bool canAssignObjCInterfacesInBlockPointer(\n                                          const ObjCObjectPointerType *LHSOPT,\n                                          const ObjCObjectPointerType *RHSOPT,\n                                          bool BlockReturnType);\n  bool areComparableObjCPointerTypes(QualType LHS, QualType RHS);\n  QualType areCommonBaseCompatible(const ObjCObjectPointerType *LHSOPT,\n                                   const ObjCObjectPointerType *RHSOPT);\n  bool canBindObjCObjectType(QualType To, QualType From);\n\n  // Functions for calculating composite types\n  QualType mergeTypes(QualType, QualType, bool OfBlockPointer=false,\n                      bool Unqualified = false, bool BlockReturnType = false);\n  QualType mergeFunctionTypes(QualType, QualType, bool OfBlockPointer=false,\n                              bool Unqualified = false, bool AllowCXX = false);\n  QualType mergeFunctionParameterTypes(QualType, QualType,\n                                       bool OfBlockPointer = false,\n                                       bool Unqualified = false);\n  QualType mergeTransparentUnionType(QualType, QualType,\n                                     bool OfBlockPointer=false,\n                                     bool Unqualified = false);\n\n  QualType mergeObjCGCQualifiers(QualType, QualType);\n\n  /// This function merges the ExtParameterInfo lists of two functions. It\n  /// returns true if the lists are compatible. The merged list is returned in\n  /// NewParamInfos.\n  ///\n  /// \\param FirstFnType The type of the first function.\n  ///\n  /// \\param SecondFnType The type of the second function.\n  ///\n  /// \\param CanUseFirst This flag is set to true if the first function's\n  /// ExtParameterInfo list can be used as the composite list of\n  /// ExtParameterInfo.\n  ///\n  /// \\param CanUseSecond This flag is set to true if the second function's\n  /// ExtParameterInfo list can be used as the composite list of\n  /// ExtParameterInfo.\n  ///\n  /// \\param NewParamInfos The composite list of ExtParameterInfo. The list is\n  /// empty if none of the flags are set.\n  ///\n  bool mergeExtParameterInfo(\n      const FunctionProtoType *FirstFnType,\n      const FunctionProtoType *SecondFnType,\n      bool &CanUseFirst, bool &CanUseSecond,\n      SmallVectorImpl<FunctionProtoType::ExtParameterInfo> &NewParamInfos);\n\n  void ResetObjCLayout(const ObjCContainerDecl *CD);\n\n  //===--------------------------------------------------------------------===//\n  //                    Integer Predicates\n  //===--------------------------------------------------------------------===//\n\n  // The width of an integer, as defined in C99 6.2.6.2. This is the number\n  // of bits in an integer type excluding any padding bits.\n  unsigned getIntWidth(QualType T) const;\n\n  // Per C99 6.2.5p6, for every signed integer type, there is a corresponding\n  // unsigned integer type.  This method takes a signed type, and returns the\n  // corresponding unsigned integer type.\n  // With the introduction of fixed point types in ISO N1169, this method also\n  // accepts fixed point types and returns the corresponding unsigned type for\n  // a given fixed point type.\n  QualType getCorrespondingUnsignedType(QualType T) const;\n\n  // Per ISO N1169, this method accepts fixed point types and returns the\n  // corresponding saturated type for a given fixed point type.\n  QualType getCorrespondingSaturatedType(QualType Ty) const;\n\n  // This method accepts fixed point types and returns the corresponding signed\n  // type. Unlike getCorrespondingUnsignedType(), this only accepts unsigned\n  // fixed point types because there are unsigned integer types like bool and\n  // char8_t that don't have signed equivalents.\n  QualType getCorrespondingSignedFixedPointType(QualType Ty) const;\n\n  //===--------------------------------------------------------------------===//\n  //                    Integer Values\n  //===--------------------------------------------------------------------===//\n\n  /// Make an APSInt of the appropriate width and signedness for the\n  /// given \\p Value and integer \\p Type.\n  llvm::APSInt MakeIntValue(uint64_t Value, QualType Type) const {\n    // If Type is a signed integer type larger than 64 bits, we need to be sure\n    // to sign extend Res appropriately.\n    llvm::APSInt Res(64, !Type->isSignedIntegerOrEnumerationType());\n    Res = Value;\n    unsigned Width = getIntWidth(Type);\n    if (Width != Res.getBitWidth())\n      return Res.extOrTrunc(Width);\n    return Res;\n  }\n\n  bool isSentinelNullExpr(const Expr *E);\n\n  /// Get the implementation of the ObjCInterfaceDecl \\p D, or nullptr if\n  /// none exists.\n  ObjCImplementationDecl *getObjCImplementation(ObjCInterfaceDecl *D);\n\n  /// Get the implementation of the ObjCCategoryDecl \\p D, or nullptr if\n  /// none exists.\n  ObjCCategoryImplDecl *getObjCImplementation(ObjCCategoryDecl *D);\n\n  /// Return true if there is at least one \\@implementation in the TU.\n  bool AnyObjCImplementation() {\n    return !ObjCImpls.empty();\n  }\n\n  /// Set the implementation of ObjCInterfaceDecl.\n  void setObjCImplementation(ObjCInterfaceDecl *IFaceD,\n                             ObjCImplementationDecl *ImplD);\n\n  /// Set the implementation of ObjCCategoryDecl.\n  void setObjCImplementation(ObjCCategoryDecl *CatD,\n                             ObjCCategoryImplDecl *ImplD);\n\n  /// Get the duplicate declaration of a ObjCMethod in the same\n  /// interface, or null if none exists.\n  const ObjCMethodDecl *\n  getObjCMethodRedeclaration(const ObjCMethodDecl *MD) const;\n\n  void setObjCMethodRedeclaration(const ObjCMethodDecl *MD,\n                                  const ObjCMethodDecl *Redecl);\n\n  /// Returns the Objective-C interface that \\p ND belongs to if it is\n  /// an Objective-C method/property/ivar etc. that is part of an interface,\n  /// otherwise returns null.\n  const ObjCInterfaceDecl *getObjContainingInterface(const NamedDecl *ND) const;\n\n  /// Set the copy initialization expression of a block var decl. \\p CanThrow\n  /// indicates whether the copy expression can throw or not.\n  void setBlockVarCopyInit(const VarDecl* VD, Expr *CopyExpr, bool CanThrow);\n\n  /// Get the copy initialization expression of the VarDecl \\p VD, or\n  /// nullptr if none exists.\n  BlockVarCopyInit getBlockVarCopyInit(const VarDecl* VD) const;\n\n  /// Allocate an uninitialized TypeSourceInfo.\n  ///\n  /// The caller should initialize the memory held by TypeSourceInfo using\n  /// the TypeLoc wrappers.\n  ///\n  /// \\param T the type that will be the basis for type source info. This type\n  /// should refer to how the declarator was written in source code, not to\n  /// what type semantic analysis resolved the declarator to.\n  ///\n  /// \\param Size the size of the type info to create, or 0 if the size\n  /// should be calculated based on the type.\n  TypeSourceInfo *CreateTypeSourceInfo(QualType T, unsigned Size = 0) const;\n\n  /// Allocate a TypeSourceInfo where all locations have been\n  /// initialized to a given location, which defaults to the empty\n  /// location.\n  TypeSourceInfo *\n  getTrivialTypeSourceInfo(QualType T,\n                           SourceLocation Loc = SourceLocation()) const;\n\n  /// Add a deallocation callback that will be invoked when the\n  /// ASTContext is destroyed.\n  ///\n  /// \\param Callback A callback function that will be invoked on destruction.\n  ///\n  /// \\param Data Pointer data that will be provided to the callback function\n  /// when it is called.\n  void AddDeallocation(void (*Callback)(void *), void *Data) const;\n\n  /// If T isn't trivially destructible, calls AddDeallocation to register it\n  /// for destruction.\n  template <typename T> void addDestruction(T *Ptr) const {\n    if (!std::is_trivially_destructible<T>::value) {\n      auto DestroyPtr = [](void *V) { static_cast<T *>(V)->~T(); };\n      AddDeallocation(DestroyPtr, Ptr);\n    }\n  }\n\n  GVALinkage GetGVALinkageForFunction(const FunctionDecl *FD) const;\n  GVALinkage GetGVALinkageForVariable(const VarDecl *VD);\n\n  /// Determines if the decl can be CodeGen'ed or deserialized from PCH\n  /// lazily, only when used; this is only relevant for function or file scoped\n  /// var definitions.\n  ///\n  /// \\returns true if the function/var must be CodeGen'ed/deserialized even if\n  /// it is not used.\n  bool DeclMustBeEmitted(const Decl *D);\n\n  /// Visits all versions of a multiversioned function with the passed\n  /// predicate.\n  void forEachMultiversionedFunctionVersion(\n      const FunctionDecl *FD,\n      llvm::function_ref<void(FunctionDecl *)> Pred) const;\n\n  const CXXConstructorDecl *\n  getCopyConstructorForExceptionObject(CXXRecordDecl *RD);\n\n  void addCopyConstructorForExceptionObject(CXXRecordDecl *RD,\n                                            CXXConstructorDecl *CD);\n\n  void addTypedefNameForUnnamedTagDecl(TagDecl *TD, TypedefNameDecl *TND);\n\n  TypedefNameDecl *getTypedefNameForUnnamedTagDecl(const TagDecl *TD);\n\n  void addDeclaratorForUnnamedTagDecl(TagDecl *TD, DeclaratorDecl *DD);\n\n  DeclaratorDecl *getDeclaratorForUnnamedTagDecl(const TagDecl *TD);\n\n  void setManglingNumber(const NamedDecl *ND, unsigned Number);\n  unsigned getManglingNumber(const NamedDecl *ND) const;\n\n  void setStaticLocalNumber(const VarDecl *VD, unsigned Number);\n  unsigned getStaticLocalNumber(const VarDecl *VD) const;\n\n  /// Retrieve the context for computing mangling numbers in the given\n  /// DeclContext.\n  MangleNumberingContext &getManglingNumberContext(const DeclContext *DC);\n  enum NeedExtraManglingDecl_t { NeedExtraManglingDecl };\n  MangleNumberingContext &getManglingNumberContext(NeedExtraManglingDecl_t,\n                                                   const Decl *D);\n\n  std::unique_ptr<MangleNumberingContext> createMangleNumberingContext() const;\n\n  /// Used by ParmVarDecl to store on the side the\n  /// index of the parameter when it exceeds the size of the normal bitfield.\n  void setParameterIndex(const ParmVarDecl *D, unsigned index);\n\n  /// Used by ParmVarDecl to retrieve on the side the\n  /// index of the parameter when it exceeds the size of the normal bitfield.\n  unsigned getParameterIndex(const ParmVarDecl *D) const;\n\n  /// Return a string representing the human readable name for the specified\n  /// function declaration or file name. Used by SourceLocExpr and\n  /// PredefinedExpr to cache evaluated results.\n  StringLiteral *getPredefinedStringLiteralFromCache(StringRef Key) const;\n\n  /// Return a declaration for the global GUID object representing the given\n  /// GUID value.\n  MSGuidDecl *getMSGuidDecl(MSGuidDeclParts Parts) const;\n\n  /// Return the template parameter object of the given type with the given\n  /// value.\n  TemplateParamObjectDecl *getTemplateParamObjectDecl(QualType T,\n                                                      const APValue &V) const;\n\n  /// Parses the target attributes passed in, and returns only the ones that are\n  /// valid feature names.\n  ParsedTargetAttr filterFunctionTargetAttrs(const TargetAttr *TD) const;\n\n  void getFunctionFeatureMap(llvm::StringMap<bool> &FeatureMap,\n                             const FunctionDecl *) const;\n  void getFunctionFeatureMap(llvm::StringMap<bool> &FeatureMap,\n                             GlobalDecl GD) const;\n\n  //===--------------------------------------------------------------------===//\n  //                    Statistics\n  //===--------------------------------------------------------------------===//\n\n  /// The number of implicitly-declared default constructors.\n  unsigned NumImplicitDefaultConstructors = 0;\n\n  /// The number of implicitly-declared default constructors for\n  /// which declarations were built.\n  unsigned NumImplicitDefaultConstructorsDeclared = 0;\n\n  /// The number of implicitly-declared copy constructors.\n  unsigned NumImplicitCopyConstructors = 0;\n\n  /// The number of implicitly-declared copy constructors for\n  /// which declarations were built.\n  unsigned NumImplicitCopyConstructorsDeclared = 0;\n\n  /// The number of implicitly-declared move constructors.\n  unsigned NumImplicitMoveConstructors = 0;\n\n  /// The number of implicitly-declared move constructors for\n  /// which declarations were built.\n  unsigned NumImplicitMoveConstructorsDeclared = 0;\n\n  /// The number of implicitly-declared copy assignment operators.\n  unsigned NumImplicitCopyAssignmentOperators = 0;\n\n  /// The number of implicitly-declared copy assignment operators for\n  /// which declarations were built.\n  unsigned NumImplicitCopyAssignmentOperatorsDeclared = 0;\n\n  /// The number of implicitly-declared move assignment operators.\n  unsigned NumImplicitMoveAssignmentOperators = 0;\n\n  /// The number of implicitly-declared move assignment operators for\n  /// which declarations were built.\n  unsigned NumImplicitMoveAssignmentOperatorsDeclared = 0;\n\n  /// The number of implicitly-declared destructors.\n  unsigned NumImplicitDestructors = 0;\n\n  /// The number of implicitly-declared destructors for which\n  /// declarations were built.\n  unsigned NumImplicitDestructorsDeclared = 0;\n\npublic:\n  /// Initialize built-in types.\n  ///\n  /// This routine may only be invoked once for a given ASTContext object.\n  /// It is normally invoked after ASTContext construction.\n  ///\n  /// \\param Target The target\n  void InitBuiltinTypes(const TargetInfo &Target,\n                        const TargetInfo *AuxTarget = nullptr);\n\nprivate:\n  void InitBuiltinType(CanQualType &R, BuiltinType::Kind K);\n\n  class ObjCEncOptions {\n    unsigned Bits;\n\n    ObjCEncOptions(unsigned Bits) : Bits(Bits) {}\n\n  public:\n    ObjCEncOptions() : Bits(0) {}\n    ObjCEncOptions(const ObjCEncOptions &RHS) : Bits(RHS.Bits) {}\n\n#define OPT_LIST(V)                                                            \\\n  V(ExpandPointedToStructures, 0)                                              \\\n  V(ExpandStructures, 1)                                                       \\\n  V(IsOutermostType, 2)                                                        \\\n  V(EncodingProperty, 3)                                                       \\\n  V(IsStructField, 4)                                                          \\\n  V(EncodeBlockParameters, 5)                                                  \\\n  V(EncodeClassNames, 6)                                                       \\\n\n#define V(N,I) ObjCEncOptions& set##N() { Bits |= 1 << I; return *this; }\nOPT_LIST(V)\n#undef V\n\n#define V(N,I) bool N() const { return Bits & 1 << I; }\nOPT_LIST(V)\n#undef V\n\n#undef OPT_LIST\n\n    LLVM_NODISCARD ObjCEncOptions keepingOnly(ObjCEncOptions Mask) const {\n      return Bits & Mask.Bits;\n    }\n\n    LLVM_NODISCARD ObjCEncOptions forComponentType() const {\n      ObjCEncOptions Mask = ObjCEncOptions()\n                                .setIsOutermostType()\n                                .setIsStructField();\n      return Bits & ~Mask.Bits;\n    }\n  };\n\n  // Return the Objective-C type encoding for a given type.\n  void getObjCEncodingForTypeImpl(QualType t, std::string &S,\n                                  ObjCEncOptions Options,\n                                  const FieldDecl *Field,\n                                  QualType *NotEncodedT = nullptr) const;\n\n  // Adds the encoding of the structure's members.\n  void getObjCEncodingForStructureImpl(RecordDecl *RD, std::string &S,\n                                       const FieldDecl *Field,\n                                       bool includeVBases = true,\n                                       QualType *NotEncodedT=nullptr) const;\n\npublic:\n  // Adds the encoding of a method parameter or return type.\n  void getObjCEncodingForMethodParameter(Decl::ObjCDeclQualifier QT,\n                                         QualType T, std::string& S,\n                                         bool Extended) const;\n\n  /// Returns true if this is an inline-initialized static data member\n  /// which is treated as a definition for MSVC compatibility.\n  bool isMSStaticDataMemberInlineDefinition(const VarDecl *VD) const;\n\n  enum class InlineVariableDefinitionKind {\n    /// Not an inline variable.\n    None,\n\n    /// Weak definition of inline variable.\n    Weak,\n\n    /// Weak for now, might become strong later in this TU.\n    WeakUnknown,\n\n    /// Strong definition.\n    Strong\n  };\n\n  /// Determine whether a definition of this inline variable should\n  /// be treated as a weak or strong definition. For compatibility with\n  /// C++14 and before, for a constexpr static data member, if there is an\n  /// out-of-line declaration of the member, we may promote it from weak to\n  /// strong.\n  InlineVariableDefinitionKind\n  getInlineVariableDefinitionKind(const VarDecl *VD) const;\n\nprivate:\n  friend class DeclarationNameTable;\n  friend class DeclContext;\n\n  const ASTRecordLayout &\n  getObjCLayout(const ObjCInterfaceDecl *D,\n                const ObjCImplementationDecl *Impl) const;\n\n  /// A set of deallocations that should be performed when the\n  /// ASTContext is destroyed.\n  // FIXME: We really should have a better mechanism in the ASTContext to\n  // manage running destructors for types which do variable sized allocation\n  // within the AST. In some places we thread the AST bump pointer allocator\n  // into the datastructures which avoids this mess during deallocation but is\n  // wasteful of memory, and here we require a lot of error prone book keeping\n  // in order to track and run destructors while we're tearing things down.\n  using DeallocationFunctionsAndArguments =\n      llvm::SmallVector<std::pair<void (*)(void *), void *>, 16>;\n  mutable DeallocationFunctionsAndArguments Deallocations;\n\n  // FIXME: This currently contains the set of StoredDeclMaps used\n  // by DeclContext objects.  This probably should not be in ASTContext,\n  // but we include it here so that ASTContext can quickly deallocate them.\n  llvm::PointerIntPair<StoredDeclsMap *, 1> LastSDM;\n\n  std::vector<Decl *> TraversalScope;\n\n  std::unique_ptr<VTableContextBase> VTContext;\n\n  void ReleaseDeclContextMaps();\n\npublic:\n  enum PragmaSectionFlag : unsigned {\n    PSF_None = 0,\n    PSF_Read = 0x1,\n    PSF_Write = 0x2,\n    PSF_Execute = 0x4,\n    PSF_Implicit = 0x8,\n    PSF_ZeroInit = 0x10,\n    PSF_Invalid = 0x80000000U,\n  };\n\n  struct SectionInfo {\n    NamedDecl *Decl;\n    SourceLocation PragmaSectionLocation;\n    int SectionFlags;\n\n    SectionInfo() = default;\n    SectionInfo(NamedDecl *Decl, SourceLocation PragmaSectionLocation,\n                int SectionFlags)\n        : Decl(Decl), PragmaSectionLocation(PragmaSectionLocation),\n          SectionFlags(SectionFlags) {}\n  };\n\n  llvm::StringMap<SectionInfo> SectionInfos;\n\n  /// Return a new OMPTraitInfo object owned by this context.\n  OMPTraitInfo &getNewOMPTraitInfo();\n\n  /// Whether a C++ static variable may be externalized.\n  bool mayExternalizeStaticVar(const Decl *D) const;\n\n  /// Whether a C++ static variable should be externalized.\n  bool shouldExternalizeStaticVar(const Decl *D) const;\n\n  StringRef getCUIDHash() const;\n\nprivate:\n  /// All OMPTraitInfo objects live in this collection, one per\n  /// `pragma omp [begin] declare variant` directive.\n  SmallVector<std::unique_ptr<OMPTraitInfo>, 4> OMPTraitInfoVector;\n};\n\n/// Insertion operator for diagnostics.\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      const ASTContext::SectionInfo &Section);\n\n/// Utility function for constructing a nullary selector.\ninline Selector GetNullarySelector(StringRef name, ASTContext &Ctx) {\n  IdentifierInfo* II = &Ctx.Idents.get(name);\n  return Ctx.Selectors.getSelector(0, &II);\n}\n\n/// Utility function for constructing an unary selector.\ninline Selector GetUnarySelector(StringRef name, ASTContext &Ctx) {\n  IdentifierInfo* II = &Ctx.Idents.get(name);\n  return Ctx.Selectors.getSelector(1, &II);\n}\n\n} // namespace clang\n\n// operator new and delete aren't allowed inside namespaces.\n\n/// Placement new for using the ASTContext's allocator.\n///\n/// This placement form of operator new uses the ASTContext's allocator for\n/// obtaining memory.\n///\n/// IMPORTANT: These are also declared in clang/AST/ASTContextAllocate.h!\n/// Any changes here need to also be made there.\n///\n/// We intentionally avoid using a nothrow specification here so that the calls\n/// to this operator will not perform a null check on the result -- the\n/// underlying allocator never returns null pointers.\n///\n/// Usage looks like this (assuming there's an ASTContext 'Context' in scope):\n/// @code\n/// // Default alignment (8)\n/// IntegerLiteral *Ex = new (Context) IntegerLiteral(arguments);\n/// // Specific alignment\n/// IntegerLiteral *Ex2 = new (Context, 4) IntegerLiteral(arguments);\n/// @endcode\n/// Memory allocated through this placement new operator does not need to be\n/// explicitly freed, as ASTContext will free all of this memory when it gets\n/// destroyed. Please note that you cannot use delete on the pointer.\n///\n/// @param Bytes The number of bytes to allocate. Calculated by the compiler.\n/// @param C The ASTContext that provides the allocator.\n/// @param Alignment The alignment of the allocated memory (if the underlying\n///                  allocator supports it).\n/// @return The allocated memory. Could be nullptr.\ninline void *operator new(size_t Bytes, const clang::ASTContext &C,\n                          size_t Alignment /* = 8 */) {\n  return C.Allocate(Bytes, Alignment);\n}\n\n/// Placement delete companion to the new above.\n///\n/// This operator is just a companion to the new above. There is no way of\n/// invoking it directly; see the new operator for more details. This operator\n/// is called implicitly by the compiler if a placement new expression using\n/// the ASTContext throws in the object constructor.\ninline void operator delete(void *Ptr, const clang::ASTContext &C, size_t) {\n  C.Deallocate(Ptr);\n}\n\n/// This placement form of operator new[] uses the ASTContext's allocator for\n/// obtaining memory.\n///\n/// We intentionally avoid using a nothrow specification here so that the calls\n/// to this operator will not perform a null check on the result -- the\n/// underlying allocator never returns null pointers.\n///\n/// Usage looks like this (assuming there's an ASTContext 'Context' in scope):\n/// @code\n/// // Default alignment (8)\n/// char *data = new (Context) char[10];\n/// // Specific alignment\n/// char *data = new (Context, 4) char[10];\n/// @endcode\n/// Memory allocated through this placement new[] operator does not need to be\n/// explicitly freed, as ASTContext will free all of this memory when it gets\n/// destroyed. Please note that you cannot use delete on the pointer.\n///\n/// @param Bytes The number of bytes to allocate. Calculated by the compiler.\n/// @param C The ASTContext that provides the allocator.\n/// @param Alignment The alignment of the allocated memory (if the underlying\n///                  allocator supports it).\n/// @return The allocated memory. Could be nullptr.\ninline void *operator new[](size_t Bytes, const clang::ASTContext& C,\n                            size_t Alignment /* = 8 */) {\n  return C.Allocate(Bytes, Alignment);\n}\n\n/// Placement delete[] companion to the new[] above.\n///\n/// This operator is just a companion to the new[] above. There is no way of\n/// invoking it directly; see the new[] operator for more details. This operator\n/// is called implicitly by the compiler if a placement new[] expression using\n/// the ASTContext throws in the object constructor.\ninline void operator delete[](void *Ptr, const clang::ASTContext &C, size_t) {\n  C.Deallocate(Ptr);\n}\n\n/// Create the representation of a LazyGenerationalUpdatePtr.\ntemplate <typename Owner, typename T,\n          void (clang::ExternalASTSource::*Update)(Owner)>\ntypename clang::LazyGenerationalUpdatePtr<Owner, T, Update>::ValueType\n    clang::LazyGenerationalUpdatePtr<Owner, T, Update>::makeValue(\n        const clang::ASTContext &Ctx, T Value) {\n  // Note, this is implemented here so that ExternalASTSource.h doesn't need to\n  // include ASTContext.h. We explicitly instantiate it for all relevant types\n  // in ASTContext.cpp.\n  if (auto *Source = Ctx.getExternalSource())\n    return new (Ctx) LazyData(Source, Value);\n  return Value;\n}\n\n#endif // LLVM_CLANG_AST_ASTCONTEXT_H\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp", "content": "//===--- CGExprAgg.cpp - Emit LLVM Code from Aggregate Expressions --------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This contains code to emit Aggregate Expr nodes as LLVM code.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"CGCXXABI.h\"\n#include \"CGObjCRuntime.h\"\n#include \"CodeGenFunction.h\"\n#include \"CodeGenModule.h\"\n#include \"ConstantEmitter.h\"\n#include \"TargetInfo.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/StmtVisitor.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GlobalVariable.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/Intrinsics.h\"\nusing namespace clang;\nusing namespace CodeGen;\n\n//===----------------------------------------------------------------------===//\n//                        Aggregate Expression Emitter\n//===----------------------------------------------------------------------===//\n\nnamespace  {\nclass AggExprEmitter : public StmtVisitor<AggExprEmitter> {\n  CodeGenFunction &CGF;\n  CGBuilderTy &Builder;\n  AggValueSlot Dest;\n  bool IsResultUnused;\n\n  AggValueSlot EnsureSlot(QualType T) {\n    if (!Dest.isIgnored()) return Dest;\n    return CGF.CreateAggTemp(T, \"agg.tmp.ensured\");\n  }\n  void EnsureDest(QualType T) {\n    if (!Dest.isIgnored()) return;\n    Dest = CGF.CreateAggTemp(T, \"agg.tmp.ensured\");\n  }\n\n  // Calls `Fn` with a valid return value slot, potentially creating a temporary\n  // to do so. If a temporary is created, an appropriate copy into `Dest` will\n  // be emitted, as will lifetime markers.\n  //\n  // The given function should take a ReturnValueSlot, and return an RValue that\n  // points to said slot.\n  void withReturnValueSlot(const Expr *E,\n                           llvm::function_ref<RValue(ReturnValueSlot)> Fn);\n\npublic:\n  AggExprEmitter(CodeGenFunction &cgf, AggValueSlot Dest, bool IsResultUnused)\n    : CGF(cgf), Builder(CGF.Builder), Dest(Dest),\n    IsResultUnused(IsResultUnused) { }\n\n  //===--------------------------------------------------------------------===//\n  //                               Utilities\n  //===--------------------------------------------------------------------===//\n\n  /// EmitAggLoadOfLValue - Given an expression with aggregate type that\n  /// represents a value lvalue, this method emits the address of the lvalue,\n  /// then loads the result into DestPtr.\n  void EmitAggLoadOfLValue(const Expr *E);\n\n  enum ExprValueKind {\n    EVK_RValue,\n    EVK_NonRValue\n  };\n\n  /// EmitFinalDestCopy - Perform the final copy to DestPtr, if desired.\n  /// SrcIsRValue is true if source comes from an RValue.\n  void EmitFinalDestCopy(QualType type, const LValue &src,\n                         ExprValueKind SrcValueKind = EVK_NonRValue);\n  void EmitFinalDestCopy(QualType type, RValue src);\n  void EmitCopy(QualType type, const AggValueSlot &dest,\n                const AggValueSlot &src);\n\n  void EmitMoveFromReturnSlot(const Expr *E, RValue Src);\n\n  void EmitArrayInit(Address DestPtr, llvm::ArrayType *AType,\n                     QualType ArrayQTy, InitListExpr *E);\n\n  AggValueSlot::NeedsGCBarriers_t needsGC(QualType T) {\n    if (CGF.getLangOpts().getGC() && TypeRequiresGCollection(T))\n      return AggValueSlot::NeedsGCBarriers;\n    return AggValueSlot::DoesNotNeedGCBarriers;\n  }\n\n  bool TypeRequiresGCollection(QualType T);\n\n  //===--------------------------------------------------------------------===//\n  //                            Visitor Methods\n  //===--------------------------------------------------------------------===//\n\n  void Visit(Expr *E) {\n    ApplyDebugLocation DL(CGF, E);\n    StmtVisitor<AggExprEmitter>::Visit(E);\n  }\n\n  void VisitStmt(Stmt *S) {\n    CGF.ErrorUnsupported(S, \"aggregate expression\");\n  }\n  void VisitParenExpr(ParenExpr *PE) { Visit(PE->getSubExpr()); }\n  void VisitGenericSelectionExpr(GenericSelectionExpr *GE) {\n    Visit(GE->getResultExpr());\n  }\n  void VisitCoawaitExpr(CoawaitExpr *E) {\n    CGF.EmitCoawaitExpr(*E, Dest, IsResultUnused);\n  }\n  void VisitCoyieldExpr(CoyieldExpr *E) {\n    CGF.EmitCoyieldExpr(*E, Dest, IsResultUnused);\n  }\n  void VisitUnaryCoawait(UnaryOperator *E) { Visit(E->getSubExpr()); }\n  void VisitUnaryExtension(UnaryOperator *E) { Visit(E->getSubExpr()); }\n  void VisitSubstNonTypeTemplateParmExpr(SubstNonTypeTemplateParmExpr *E) {\n    return Visit(E->getReplacement());\n  }\n\n  void VisitConstantExpr(ConstantExpr *E) {\n    if (llvm::Value *Result = ConstantEmitter(CGF).tryEmitConstantExpr(E)) {\n      CGF.EmitAggregateStore(Result, Dest.getAddress(),\n                             E->getType().isVolatileQualified());\n      return;\n    }\n    return Visit(E->getSubExpr());\n  }\n\n  // l-values.\n  void VisitDeclRefExpr(DeclRefExpr *E) { EmitAggLoadOfLValue(E); }\n  void VisitMemberExpr(MemberExpr *ME) { EmitAggLoadOfLValue(ME); }\n  void VisitUnaryDeref(UnaryOperator *E) { EmitAggLoadOfLValue(E); }\n  void VisitStringLiteral(StringLiteral *E) { EmitAggLoadOfLValue(E); }\n  void VisitCompoundLiteralExpr(CompoundLiteralExpr *E);\n  void VisitArraySubscriptExpr(ArraySubscriptExpr *E) {\n    EmitAggLoadOfLValue(E);\n  }\n  void VisitPredefinedExpr(const PredefinedExpr *E) {\n    EmitAggLoadOfLValue(E);\n  }\n\n  // Operators.\n  void VisitCastExpr(CastExpr *E);\n  void VisitCallExpr(const CallExpr *E);\n  void VisitStmtExpr(const StmtExpr *E);\n  void VisitBinaryOperator(const BinaryOperator *BO);\n  void VisitPointerToDataMemberBinaryOperator(const BinaryOperator *BO);\n  void VisitBinAssign(const BinaryOperator *E);\n  void VisitBinComma(const BinaryOperator *E);\n  void VisitBinCmp(const BinaryOperator *E);\n  void VisitCXXRewrittenBinaryOperator(CXXRewrittenBinaryOperator *E) {\n    Visit(E->getSemanticForm());\n  }\n\n  void VisitObjCMessageExpr(ObjCMessageExpr *E);\n  void VisitObjCIvarRefExpr(ObjCIvarRefExpr *E) {\n    EmitAggLoadOfLValue(E);\n  }\n\n  void VisitDesignatedInitUpdateExpr(DesignatedInitUpdateExpr *E);\n  void VisitAbstractConditionalOperator(const AbstractConditionalOperator *CO);\n  void VisitChooseExpr(const ChooseExpr *CE);\n  void VisitInitListExpr(InitListExpr *E);\n  void VisitArrayInitLoopExpr(const ArrayInitLoopExpr *E,\n                              llvm::Value *outerBegin = nullptr);\n  void VisitImplicitValueInitExpr(ImplicitValueInitExpr *E);\n  void VisitNoInitExpr(NoInitExpr *E) { } // Do nothing.\n  void VisitCXXDefaultArgExpr(CXXDefaultArgExpr *DAE) {\n    CodeGenFunction::CXXDefaultArgExprScope Scope(CGF, DAE);\n    Visit(DAE->getExpr());\n  }\n  void VisitCXXDefaultInitExpr(CXXDefaultInitExpr *DIE) {\n    CodeGenFunction::CXXDefaultInitExprScope Scope(CGF, DIE);\n    Visit(DIE->getExpr());\n  }\n  void VisitCXXBindTemporaryExpr(CXXBindTemporaryExpr *E);\n  void VisitCXXConstructExpr(const CXXConstructExpr *E);\n  void VisitCXXInheritedCtorInitExpr(const CXXInheritedCtorInitExpr *E);\n  void VisitLambdaExpr(LambdaExpr *E);\n  void VisitCXXStdInitializerListExpr(CXXStdInitializerListExpr *E);\n  void VisitExprWithCleanups(ExprWithCleanups *E);\n  void VisitCXXScalarValueInitExpr(CXXScalarValueInitExpr *E);\n  void VisitCXXTypeidExpr(CXXTypeidExpr *E) { EmitAggLoadOfLValue(E); }\n  void VisitMaterializeTemporaryExpr(MaterializeTemporaryExpr *E);\n  void VisitOpaqueValueExpr(OpaqueValueExpr *E);\n\n  void VisitPseudoObjectExpr(PseudoObjectExpr *E) {\n    if (E->isGLValue()) {\n      LValue LV = CGF.EmitPseudoObjectLValue(E);\n      return EmitFinalDestCopy(E->getType(), LV);\n    }\n\n    CGF.EmitPseudoObjectRValue(E, EnsureSlot(E->getType()));\n  }\n\n  void VisitVAArgExpr(VAArgExpr *E);\n\n  void EmitInitializationToLValue(Expr *E, LValue Address);\n  void EmitNullInitializationToLValue(LValue Address);\n  //  case Expr::ChooseExprClass:\n  void VisitCXXThrowExpr(const CXXThrowExpr *E) { CGF.EmitCXXThrowExpr(E); }\n  void VisitAtomicExpr(AtomicExpr *E) {\n    RValue Res = CGF.EmitAtomicExpr(E);\n    EmitFinalDestCopy(E->getType(), Res);\n  }\n};\n}  // end anonymous namespace.\n\n//===----------------------------------------------------------------------===//\n//                                Utilities\n//===----------------------------------------------------------------------===//\n\n/// EmitAggLoadOfLValue - Given an expression with aggregate type that\n/// represents a value lvalue, this method emits the address of the lvalue,\n/// then loads the result into DestPtr.\nvoid AggExprEmitter::EmitAggLoadOfLValue(const Expr *E) {\n  LValue LV = CGF.EmitLValue(E);\n\n  // If the type of the l-value is atomic, then do an atomic load.\n  if (LV.getType()->isAtomicType() || CGF.LValueIsSuitableForInlineAtomic(LV)) {\n    CGF.EmitAtomicLoad(LV, E->getExprLoc(), Dest);\n    return;\n  }\n\n  EmitFinalDestCopy(E->getType(), LV);\n}\n\n/// True if the given aggregate type requires special GC API calls.\nbool AggExprEmitter::TypeRequiresGCollection(QualType T) {\n  // Only record types have members that might require garbage collection.\n  const RecordType *RecordTy = T->getAs<RecordType>();\n  if (!RecordTy) return false;\n\n  // Don't mess with non-trivial C++ types.\n  RecordDecl *Record = RecordTy->getDecl();\n  if (isa<CXXRecordDecl>(Record) &&\n      (cast<CXXRecordDecl>(Record)->hasNonTrivialCopyConstructor() ||\n       !cast<CXXRecordDecl>(Record)->hasTrivialDestructor()))\n    return false;\n\n  // Check whether the type has an object member.\n  return Record->hasObjectMember();\n}\n\nvoid AggExprEmitter::withReturnValueSlot(\n    const Expr *E, llvm::function_ref<RValue(ReturnValueSlot)> EmitCall) {\n  QualType RetTy = E->getType();\n  bool RequiresDestruction =\n      !Dest.isExternallyDestructed() &&\n      RetTy.isDestructedType() == QualType::DK_nontrivial_c_struct;\n\n  // If it makes no observable difference, save a memcpy + temporary.\n  //\n  // We need to always provide our own temporary if destruction is required.\n  // Otherwise, EmitCall will emit its own, notice that it's \"unused\", and end\n  // its lifetime before we have the chance to emit a proper destructor call.\n  bool UseTemp = Dest.isPotentiallyAliased() || Dest.requiresGCollection() ||\n                 (RequiresDestruction && !Dest.getAddress().isValid());\n\n  Address RetAddr = Address::invalid();\n  Address RetAllocaAddr = Address::invalid();\n\n  EHScopeStack::stable_iterator LifetimeEndBlock;\n  llvm::Value *LifetimeSizePtr = nullptr;\n  llvm::IntrinsicInst *LifetimeStartInst = nullptr;\n  if (!UseTemp) {\n    RetAddr = Dest.getAddress();\n  } else {\n    RetAddr = CGF.CreateMemTemp(RetTy, \"tmp\", &RetAllocaAddr);\n    uint64_t Size =\n        CGF.CGM.getDataLayout().getTypeAllocSize(CGF.ConvertTypeForMem(RetTy));\n    LifetimeSizePtr = CGF.EmitLifetimeStart(Size, RetAllocaAddr.getPointer());\n    if (LifetimeSizePtr) {\n      LifetimeStartInst =\n          cast<llvm::IntrinsicInst>(std::prev(Builder.GetInsertPoint()));\n      assert(LifetimeStartInst->getIntrinsicID() ==\n                 llvm::Intrinsic::lifetime_start &&\n             \"Last insertion wasn't a lifetime.start?\");\n\n      CGF.pushFullExprCleanup<CodeGenFunction::CallLifetimeEnd>(\n          NormalEHLifetimeMarker, RetAllocaAddr, LifetimeSizePtr);\n      LifetimeEndBlock = CGF.EHStack.stable_begin();\n    }\n  }\n\n  RValue Src =\n      EmitCall(ReturnValueSlot(RetAddr, Dest.isVolatile(), IsResultUnused,\n                               Dest.isExternallyDestructed()));\n\n  if (!UseTemp)\n    return;\n\n  assert(Dest.getPointer() != Src.getAggregatePointer());\n  EmitFinalDestCopy(E->getType(), Src);\n\n  if (!RequiresDestruction && LifetimeStartInst) {\n    // If there's no dtor to run, the copy was the last use of our temporary.\n    // Since we're not guaranteed to be in an ExprWithCleanups, clean up\n    // eagerly.\n    CGF.DeactivateCleanupBlock(LifetimeEndBlock, LifetimeStartInst);\n    CGF.EmitLifetimeEnd(LifetimeSizePtr, RetAllocaAddr.getPointer());\n  }\n}\n\n/// EmitFinalDestCopy - Perform the final copy to DestPtr, if desired.\nvoid AggExprEmitter::EmitFinalDestCopy(QualType type, RValue src) {\n  assert(src.isAggregate() && \"value must be aggregate value!\");\n  LValue srcLV = CGF.MakeAddrLValue(src.getAggregateAddress(), type);\n  EmitFinalDestCopy(type, srcLV, EVK_RValue);\n}\n\n/// EmitFinalDestCopy - Perform the final copy to DestPtr, if desired.\nvoid AggExprEmitter::EmitFinalDestCopy(QualType type, const LValue &src,\n                                       ExprValueKind SrcValueKind) {\n  // If Dest is ignored, then we're evaluating an aggregate expression\n  // in a context that doesn't care about the result.  Note that loads\n  // from volatile l-values force the existence of a non-ignored\n  // destination.\n  if (Dest.isIgnored())\n    return;\n\n  // Copy non-trivial C structs here.\n  LValue DstLV = CGF.MakeAddrLValue(\n      Dest.getAddress(), Dest.isVolatile() ? type.withVolatile() : type);\n\n  if (SrcValueKind == EVK_RValue) {\n    if (type.isNonTrivialToPrimitiveDestructiveMove() == QualType::PCK_Struct) {\n      if (Dest.isPotentiallyAliased())\n        CGF.callCStructMoveAssignmentOperator(DstLV, src);\n      else\n        CGF.callCStructMoveConstructor(DstLV, src);\n      return;\n    }\n  } else {\n    if (type.isNonTrivialToPrimitiveCopy() == QualType::PCK_Struct) {\n      if (Dest.isPotentiallyAliased())\n        CGF.callCStructCopyAssignmentOperator(DstLV, src);\n      else\n        CGF.callCStructCopyConstructor(DstLV, src);\n      return;\n    }\n  }\n\n  AggValueSlot srcAgg = AggValueSlot::forLValue(\n      src, CGF, AggValueSlot::IsDestructed, needsGC(type),\n      AggValueSlot::IsAliased, AggValueSlot::MayOverlap);\n  EmitCopy(type, Dest, srcAgg);\n}\n\n/// Perform a copy from the source into the destination.\n///\n/// \\param type - the type of the aggregate being copied; qualifiers are\n///   ignored\nvoid AggExprEmitter::EmitCopy(QualType type, const AggValueSlot &dest,\n                              const AggValueSlot &src) {\n  if (dest.requiresGCollection()) {\n    CharUnits sz = dest.getPreferredSize(CGF.getContext(), type);\n    llvm::Value *size = llvm::ConstantInt::get(CGF.SizeTy, sz.getQuantity());\n    CGF.CGM.getObjCRuntime().EmitGCMemmoveCollectable(CGF,\n                                                      dest.getAddress(),\n                                                      src.getAddress(),\n                                                      size);\n    return;\n  }\n\n  // If the result of the assignment is used, copy the LHS there also.\n  // It's volatile if either side is.  Use the minimum alignment of\n  // the two sides.\n  LValue DestLV = CGF.MakeAddrLValue(dest.getAddress(), type);\n  LValue SrcLV = CGF.MakeAddrLValue(src.getAddress(), type);\n  CGF.EmitAggregateCopy(DestLV, SrcLV, type, dest.mayOverlap(),\n                        dest.isVolatile() || src.isVolatile());\n}\n\n/// Emit the initializer for a std::initializer_list initialized with a\n/// real initializer list.\nvoid\nAggExprEmitter::VisitCXXStdInitializerListExpr(CXXStdInitializerListExpr *E) {\n  // Emit an array containing the elements.  The array is externally destructed\n  // if the std::initializer_list object is.\n  ASTContext &Ctx = CGF.getContext();\n  LValue Array = CGF.EmitLValue(E->getSubExpr());\n  assert(Array.isSimple() && \"initializer_list array not a simple lvalue\");\n  Address ArrayPtr = Array.getAddress(CGF);\n\n  const ConstantArrayType *ArrayType =\n      Ctx.getAsConstantArrayType(E->getSubExpr()->getType());\n  assert(ArrayType && \"std::initializer_list constructed from non-array\");\n\n  // FIXME: Perform the checks on the field types in SemaInit.\n  RecordDecl *Record = E->getType()->castAs<RecordType>()->getDecl();\n  RecordDecl::field_iterator Field = Record->field_begin();\n  if (Field == Record->field_end()) {\n    CGF.ErrorUnsupported(E, \"weird std::initializer_list\");\n    return;\n  }\n\n  // Start pointer.\n  if (!Field->getType()->isPointerType() ||\n      !Ctx.hasSameType(Field->getType()->getPointeeType(),\n                       ArrayType->getElementType())) {\n    CGF.ErrorUnsupported(E, \"weird std::initializer_list\");\n    return;\n  }\n\n  AggValueSlot Dest = EnsureSlot(E->getType());\n  LValue DestLV = CGF.MakeAddrLValue(Dest.getAddress(), E->getType());\n  LValue Start = CGF.EmitLValueForFieldInitialization(DestLV, *Field);\n  llvm::Value *Zero = llvm::ConstantInt::get(CGF.PtrDiffTy, 0);\n  llvm::Value *IdxStart[] = { Zero, Zero };\n  llvm::Value *ArrayStart =\n      Builder.CreateInBoundsGEP(ArrayPtr.getPointer(), IdxStart, \"arraystart\");\n  CGF.EmitStoreThroughLValue(RValue::get(ArrayStart), Start);\n  ++Field;\n\n  if (Field == Record->field_end()) {\n    CGF.ErrorUnsupported(E, \"weird std::initializer_list\");\n    return;\n  }\n\n  llvm::Value *Size = Builder.getInt(ArrayType->getSize());\n  LValue EndOrLength = CGF.EmitLValueForFieldInitialization(DestLV, *Field);\n  if (Field->getType()->isPointerType() &&\n      Ctx.hasSameType(Field->getType()->getPointeeType(),\n                      ArrayType->getElementType())) {\n    // End pointer.\n    llvm::Value *IdxEnd[] = { Zero, Size };\n    llvm::Value *ArrayEnd =\n        Builder.CreateInBoundsGEP(ArrayPtr.getPointer(), IdxEnd, \"arrayend\");\n    CGF.EmitStoreThroughLValue(RValue::get(ArrayEnd), EndOrLength);\n  } else if (Ctx.hasSameType(Field->getType(), Ctx.getSizeType())) {\n    // Length.\n    CGF.EmitStoreThroughLValue(RValue::get(Size), EndOrLength);\n  } else {\n    CGF.ErrorUnsupported(E, \"weird std::initializer_list\");\n    return;\n  }\n}\n\n/// Determine if E is a trivial array filler, that is, one that is\n/// equivalent to zero-initialization.\nstatic bool isTrivialFiller(Expr *E) {\n  if (!E)\n    return true;\n\n  if (isa<ImplicitValueInitExpr>(E))\n    return true;\n\n  if (auto *ILE = dyn_cast<InitListExpr>(E)) {\n    if (ILE->getNumInits())\n      return false;\n    return isTrivialFiller(ILE->getArrayFiller());\n  }\n\n  if (auto *Cons = dyn_cast_or_null<CXXConstructExpr>(E))\n    return Cons->getConstructor()->isDefaultConstructor() &&\n           Cons->getConstructor()->isTrivial();\n\n  // FIXME: Are there other cases where we can avoid emitting an initializer?\n  return false;\n}\n\n/// Emit initialization of an array from an initializer list.\nvoid AggExprEmitter::EmitArrayInit(Address DestPtr, llvm::ArrayType *AType,\n                                   QualType ArrayQTy, InitListExpr *E) {\n  uint64_t NumInitElements = E->getNumInits();\n\n  uint64_t NumArrayElements = AType->getNumElements();\n  assert(NumInitElements <= NumArrayElements);\n\n  QualType elementType =\n      CGF.getContext().getAsArrayType(ArrayQTy)->getElementType();\n\n  // DestPtr is an array*.  Construct an elementType* by drilling\n  // down a level.\n  llvm::Value *zero = llvm::ConstantInt::get(CGF.SizeTy, 0);\n  llvm::Value *indices[] = { zero, zero };\n  llvm::Value *begin =\n    Builder.CreateInBoundsGEP(DestPtr.getPointer(), indices, \"arrayinit.begin\");\n\n  CharUnits elementSize = CGF.getContext().getTypeSizeInChars(elementType);\n  CharUnits elementAlign =\n    DestPtr.getAlignment().alignmentOfArrayElement(elementSize);\n\n  // Consider initializing the array by copying from a global. For this to be\n  // more efficient than per-element initialization, the size of the elements\n  // with explicit initializers should be large enough.\n  if (NumInitElements * elementSize.getQuantity() > 16 &&\n      elementType.isTriviallyCopyableType(CGF.getContext())) {\n    CodeGen::CodeGenModule &CGM = CGF.CGM;\n    ConstantEmitter Emitter(CGF);\n    LangAS AS = ArrayQTy.getAddressSpace();\n    if (llvm::Constant *C = Emitter.tryEmitForInitializer(E, AS, ArrayQTy)) {\n      auto GV = new llvm::GlobalVariable(\n          CGM.getModule(), C->getType(),\n          CGM.isTypeConstant(ArrayQTy, /* ExcludeCtorDtor= */ true),\n          llvm::GlobalValue::PrivateLinkage, C, \"constinit\",\n          /* InsertBefore= */ nullptr, llvm::GlobalVariable::NotThreadLocal,\n          CGM.getContext().getTargetAddressSpace(AS));\n      Emitter.finalize(GV);\n      CharUnits Align = CGM.getContext().getTypeAlignInChars(ArrayQTy);\n      GV->setAlignment(Align.getAsAlign());\n      EmitFinalDestCopy(ArrayQTy, CGF.MakeAddrLValue(GV, ArrayQTy, Align));\n      return;\n    }\n  }\n\n  // Exception safety requires us to destroy all the\n  // already-constructed members if an initializer throws.\n  // For that, we'll need an EH cleanup.\n  QualType::DestructionKind dtorKind = elementType.isDestructedType();\n  Address endOfInit = Address::invalid();\n  EHScopeStack::stable_iterator cleanup;\n  llvm::Instruction *cleanupDominator = nullptr;\n  if (CGF.needsEHCleanup(dtorKind)) {\n    // In principle we could tell the cleanup where we are more\n    // directly, but the control flow can get so varied here that it\n    // would actually be quite complex.  Therefore we go through an\n    // alloca.\n    endOfInit = CGF.CreateTempAlloca(begin->getType(), CGF.getPointerAlign(),\n                                     \"arrayinit.endOfInit\");\n    cleanupDominator = Builder.CreateStore(begin, endOfInit);\n    CGF.pushIrregularPartialArrayCleanup(begin, endOfInit, elementType,\n                                         elementAlign,\n                                         CGF.getDestroyer(dtorKind));\n    cleanup = CGF.EHStack.stable_begin();\n\n  // Otherwise, remember that we didn't need a cleanup.\n  } else {\n    dtorKind = QualType::DK_none;\n  }\n\n  llvm::Value *one = llvm::ConstantInt::get(CGF.SizeTy, 1);\n\n  // The 'current element to initialize'.  The invariants on this\n  // variable are complicated.  Essentially, after each iteration of\n  // the loop, it points to the last initialized element, except\n  // that it points to the beginning of the array before any\n  // elements have been initialized.\n  llvm::Value *element = begin;\n\n  // Emit the explicit initializers.\n  for (uint64_t i = 0; i != NumInitElements; ++i) {\n    // Advance to the next element.\n    if (i > 0) {\n      element = Builder.CreateInBoundsGEP(element, one, \"arrayinit.element\");\n\n      // Tell the cleanup that it needs to destroy up to this\n      // element.  TODO: some of these stores can be trivially\n      // observed to be unnecessary.\n      if (endOfInit.isValid()) Builder.CreateStore(element, endOfInit);\n    }\n\n    LValue elementLV =\n      CGF.MakeAddrLValue(Address(element, elementAlign), elementType);\n    EmitInitializationToLValue(E->getInit(i), elementLV);\n  }\n\n  // Check whether there's a non-trivial array-fill expression.\n  Expr *filler = E->getArrayFiller();\n  bool hasTrivialFiller = isTrivialFiller(filler);\n\n  // Any remaining elements need to be zero-initialized, possibly\n  // using the filler expression.  We can skip this if the we're\n  // emitting to zeroed memory.\n  if (NumInitElements != NumArrayElements &&\n      !(Dest.isZeroed() && hasTrivialFiller &&\n        CGF.getTypes().isZeroInitializable(elementType))) {\n\n    // Use an actual loop.  This is basically\n    //   do { *array++ = filler; } while (array != end);\n\n    // Advance to the start of the rest of the array.\n    if (NumInitElements) {\n      element = Builder.CreateInBoundsGEP(element, one, \"arrayinit.start\");\n      if (endOfInit.isValid()) Builder.CreateStore(element, endOfInit);\n    }\n\n    // Compute the end of the array.\n    llvm::Value *end = Builder.CreateInBoundsGEP(begin,\n                      llvm::ConstantInt::get(CGF.SizeTy, NumArrayElements),\n                                                 \"arrayinit.end\");\n\n    llvm::BasicBlock *entryBB = Builder.GetInsertBlock();\n    llvm::BasicBlock *bodyBB = CGF.createBasicBlock(\"arrayinit.body\");\n\n    // Jump into the body.\n    CGF.EmitBlock(bodyBB);\n    llvm::PHINode *currentElement =\n      Builder.CreatePHI(element->getType(), 2, \"arrayinit.cur\");\n    currentElement->addIncoming(element, entryBB);\n\n    // Emit the actual filler expression.\n    {\n      // C++1z [class.temporary]p5:\n      //   when a default constructor is called to initialize an element of\n      //   an array with no corresponding initializer [...] the destruction of\n      //   every temporary created in a default argument is sequenced before\n      //   the construction of the next array element, if any\n      CodeGenFunction::RunCleanupsScope CleanupsScope(CGF);\n      LValue elementLV =\n        CGF.MakeAddrLValue(Address(currentElement, elementAlign), elementType);\n      if (filler)\n        EmitInitializationToLValue(filler, elementLV);\n      else\n        EmitNullInitializationToLValue(elementLV);\n    }\n\n    // Move on to the next element.\n    llvm::Value *nextElement =\n      Builder.CreateInBoundsGEP(currentElement, one, \"arrayinit.next\");\n\n    // Tell the EH cleanup that we finished with the last element.\n    if (endOfInit.isValid()) Builder.CreateStore(nextElement, endOfInit);\n\n    // Leave the loop if we're done.\n    llvm::Value *done = Builder.CreateICmpEQ(nextElement, end,\n                                             \"arrayinit.done\");\n    llvm::BasicBlock *endBB = CGF.createBasicBlock(\"arrayinit.end\");\n    Builder.CreateCondBr(done, endBB, bodyBB);\n    currentElement->addIncoming(nextElement, Builder.GetInsertBlock());\n\n    CGF.EmitBlock(endBB);\n  }\n\n  // Leave the partial-array cleanup if we entered one.\n  if (dtorKind) CGF.DeactivateCleanupBlock(cleanup, cleanupDominator);\n}\n\n//===----------------------------------------------------------------------===//\n//                            Visitor Methods\n//===----------------------------------------------------------------------===//\n\nvoid AggExprEmitter::VisitMaterializeTemporaryExpr(MaterializeTemporaryExpr *E){\n  Visit(E->getSubExpr());\n}\n\nvoid AggExprEmitter::VisitOpaqueValueExpr(OpaqueValueExpr *e) {\n  // If this is a unique OVE, just visit its source expression.\n  if (e->isUnique())\n    Visit(e->getSourceExpr());\n  else\n    EmitFinalDestCopy(e->getType(), CGF.getOrCreateOpaqueLValueMapping(e));\n}\n\nvoid\nAggExprEmitter::VisitCompoundLiteralExpr(CompoundLiteralExpr *E) {\n  if (Dest.isPotentiallyAliased() &&\n      E->getType().isPODType(CGF.getContext())) {\n    // For a POD type, just emit a load of the lvalue + a copy, because our\n    // compound literal might alias the destination.\n    EmitAggLoadOfLValue(E);\n    return;\n  }\n\n  AggValueSlot Slot = EnsureSlot(E->getType());\n\n  // Block-scope compound literals are destroyed at the end of the enclosing\n  // scope in C.\n  bool Destruct =\n      !CGF.getLangOpts().CPlusPlus && !Slot.isExternallyDestructed();\n  if (Destruct)\n    Slot.setExternallyDestructed();\n\n  CGF.EmitAggExpr(E->getInitializer(), Slot);\n\n  if (Destruct)\n    if (QualType::DestructionKind DtorKind = E->getType().isDestructedType())\n      CGF.pushLifetimeExtendedDestroy(\n          CGF.getCleanupKind(DtorKind), Slot.getAddress(), E->getType(),\n          CGF.getDestroyer(DtorKind), DtorKind & EHCleanup);\n}\n\n/// Attempt to look through various unimportant expressions to find a\n/// cast of the given kind.\nstatic Expr *findPeephole(Expr *op, CastKind kind, const ASTContext &ctx) {\n  op = op->IgnoreParenNoopCasts(ctx);\n  if (auto castE = dyn_cast<CastExpr>(op)) {\n    if (castE->getCastKind() == kind)\n      return castE->getSubExpr();\n  }\n  return nullptr;\n}\n\nvoid AggExprEmitter::VisitCastExpr(CastExpr *E) {\n  if (const auto *ECE = dyn_cast<ExplicitCastExpr>(E))\n    CGF.CGM.EmitExplicitCastExprType(ECE, &CGF);\n  switch (E->getCastKind()) {\n  case CK_Dynamic: {\n    // FIXME: Can this actually happen? We have no test coverage for it.\n    assert(isa<CXXDynamicCastExpr>(E) && \"CK_Dynamic without a dynamic_cast?\");\n    LValue LV = CGF.EmitCheckedLValue(E->getSubExpr(),\n                                      CodeGenFunction::TCK_Load);\n    // FIXME: Do we also need to handle property references here?\n    if (LV.isSimple())\n      CGF.EmitDynamicCast(LV.getAddress(CGF), cast<CXXDynamicCastExpr>(E));\n    else\n      CGF.CGM.ErrorUnsupported(E, \"non-simple lvalue dynamic_cast\");\n\n    if (!Dest.isIgnored())\n      CGF.CGM.ErrorUnsupported(E, \"lvalue dynamic_cast with a destination\");\n    break;\n  }\n\n  case CK_ToUnion: {\n    // Evaluate even if the destination is ignored.\n    if (Dest.isIgnored()) {\n      CGF.EmitAnyExpr(E->getSubExpr(), AggValueSlot::ignored(),\n                      /*ignoreResult=*/true);\n      break;\n    }\n\n    // GCC union extension\n    QualType Ty = E->getSubExpr()->getType();\n    Address CastPtr =\n      Builder.CreateElementBitCast(Dest.getAddress(), CGF.ConvertType(Ty));\n    EmitInitializationToLValue(E->getSubExpr(),\n                               CGF.MakeAddrLValue(CastPtr, Ty));\n    break;\n  }\n\n  case CK_LValueToRValueBitCast: {\n    if (Dest.isIgnored()) {\n      CGF.EmitAnyExpr(E->getSubExpr(), AggValueSlot::ignored(),\n                      /*ignoreResult=*/true);\n      break;\n    }\n\n    LValue SourceLV = CGF.EmitLValue(E->getSubExpr());\n    Address SourceAddress =\n        Builder.CreateElementBitCast(SourceLV.getAddress(CGF), CGF.Int8Ty);\n    Address DestAddress =\n        Builder.CreateElementBitCast(Dest.getAddress(), CGF.Int8Ty);\n    llvm::Value *SizeVal = llvm::ConstantInt::get(\n        CGF.SizeTy,\n        CGF.getContext().getTypeSizeInChars(E->getType()).getQuantity());\n    Builder.CreateMemCpy(DestAddress, SourceAddress, SizeVal);\n    break;\n  }\n\n  case CK_DerivedToBase:\n  case CK_BaseToDerived:\n  case CK_UncheckedDerivedToBase: {\n    llvm_unreachable(\"cannot perform hierarchy conversion in EmitAggExpr: \"\n                \"should have been unpacked before we got here\");\n  }\n\n  case CK_NonAtomicToAtomic:\n  case CK_AtomicToNonAtomic: {\n    bool isToAtomic = (E->getCastKind() == CK_NonAtomicToAtomic);\n\n    // Determine the atomic and value types.\n    QualType atomicType = E->getSubExpr()->getType();\n    QualType valueType = E->getType();\n    if (isToAtomic) std::swap(atomicType, valueType);\n\n    assert(atomicType->isAtomicType());\n    assert(CGF.getContext().hasSameUnqualifiedType(valueType,\n                          atomicType->castAs<AtomicType>()->getValueType()));\n\n    // Just recurse normally if we're ignoring the result or the\n    // atomic type doesn't change representation.\n    if (Dest.isIgnored() || !CGF.CGM.isPaddedAtomicType(atomicType)) {\n      return Visit(E->getSubExpr());\n    }\n\n    CastKind peepholeTarget =\n      (isToAtomic ? CK_AtomicToNonAtomic : CK_NonAtomicToAtomic);\n\n    // These two cases are reverses of each other; try to peephole them.\n    if (Expr *op =\n            findPeephole(E->getSubExpr(), peepholeTarget, CGF.getContext())) {\n      assert(CGF.getContext().hasSameUnqualifiedType(op->getType(),\n                                                     E->getType()) &&\n           \"peephole significantly changed types?\");\n      return Visit(op);\n    }\n\n    // If we're converting an r-value of non-atomic type to an r-value\n    // of atomic type, just emit directly into the relevant sub-object.\n    if (isToAtomic) {\n      AggValueSlot valueDest = Dest;\n      if (!valueDest.isIgnored() && CGF.CGM.isPaddedAtomicType(atomicType)) {\n        // Zero-initialize.  (Strictly speaking, we only need to initialize\n        // the padding at the end, but this is simpler.)\n        if (!Dest.isZeroed())\n          CGF.EmitNullInitialization(Dest.getAddress(), atomicType);\n\n        // Build a GEP to refer to the subobject.\n        Address valueAddr =\n            CGF.Builder.CreateStructGEP(valueDest.getAddress(), 0);\n        valueDest = AggValueSlot::forAddr(valueAddr,\n                                          valueDest.getQualifiers(),\n                                          valueDest.isExternallyDestructed(),\n                                          valueDest.requiresGCollection(),\n                                          valueDest.isPotentiallyAliased(),\n                                          AggValueSlot::DoesNotOverlap,\n                                          AggValueSlot::IsZeroed);\n      }\n\n      CGF.EmitAggExpr(E->getSubExpr(), valueDest);\n      return;\n    }\n\n    // Otherwise, we're converting an atomic type to a non-atomic type.\n    // Make an atomic temporary, emit into that, and then copy the value out.\n    AggValueSlot atomicSlot =\n      CGF.CreateAggTemp(atomicType, \"atomic-to-nonatomic.temp\");\n    CGF.EmitAggExpr(E->getSubExpr(), atomicSlot);\n\n    Address valueAddr = Builder.CreateStructGEP(atomicSlot.getAddress(), 0);\n    RValue rvalue = RValue::getAggregate(valueAddr, atomicSlot.isVolatile());\n    return EmitFinalDestCopy(valueType, rvalue);\n  }\n  case CK_AddressSpaceConversion:\n     return Visit(E->getSubExpr());\n\n  case CK_LValueToRValue:\n    // If we're loading from a volatile type, force the destination\n    // into existence.\n    if (E->getSubExpr()->getType().isVolatileQualified()) {\n      bool Destruct =\n          !Dest.isExternallyDestructed() &&\n          E->getType().isDestructedType() == QualType::DK_nontrivial_c_struct;\n      if (Destruct)\n        Dest.setExternallyDestructed();\n      EnsureDest(E->getType());\n      Visit(E->getSubExpr());\n\n      if (Destruct)\n        CGF.pushDestroy(QualType::DK_nontrivial_c_struct, Dest.getAddress(),\n                        E->getType());\n\n      return;\n    }\n\n    LLVM_FALLTHROUGH;\n\n\n  case CK_NoOp:\n  case CK_UserDefinedConversion:\n  case CK_ConstructorConversion:\n    assert(CGF.getContext().hasSameUnqualifiedType(E->getSubExpr()->getType(),\n                                                   E->getType()) &&\n           \"Implicit cast types must be compatible\");\n    Visit(E->getSubExpr());\n    break;\n\n  case CK_LValueBitCast:\n    llvm_unreachable(\"should not be emitting lvalue bitcast as rvalue\");\n\n  case CK_Dependent:\n  case CK_BitCast:\n  case CK_ArrayToPointerDecay:\n  case CK_FunctionToPointerDecay:\n  case CK_NullToPointer:\n  case CK_NullToMemberPointer:\n  case CK_BaseToDerivedMemberPointer:\n  case CK_DerivedToBaseMemberPointer:\n  case CK_MemberPointerToBoolean:\n  case CK_ReinterpretMemberPointer:\n  case CK_IntegralToPointer:\n  case CK_PointerToIntegral:\n  case CK_PointerToBoolean:\n  case CK_ToVoid:\n  case CK_VectorSplat:\n  case CK_IntegralCast:\n  case CK_BooleanToSignedIntegral:\n  case CK_IntegralToBoolean:\n  case CK_IntegralToFloating:\n  case CK_FloatingToIntegral:\n  case CK_FloatingToBoolean:\n  case CK_FloatingCast:\n  case CK_CPointerToObjCPointerCast:\n  case CK_BlockPointerToObjCPointerCast:\n  case CK_AnyPointerToBlockPointerCast:\n  case CK_ObjCObjectLValueCast:\n  case CK_FloatingRealToComplex:\n  case CK_FloatingComplexToReal:\n  case CK_FloatingComplexToBoolean:\n  case CK_FloatingComplexCast:\n  case CK_FloatingComplexToIntegralComplex:\n  case CK_IntegralRealToComplex:\n  case CK_IntegralComplexToReal:\n  case CK_IntegralComplexToBoolean:\n  case CK_IntegralComplexCast:\n  case CK_IntegralComplexToFloatingComplex:\n  case CK_ARCProduceObject:\n  case CK_ARCConsumeObject:\n  case CK_ARCReclaimReturnedObject:\n  case CK_ARCExtendBlockObject:\n  case CK_CopyAndAutoreleaseBlockObject:\n  case CK_BuiltinFnToFnPtr:\n  case CK_ZeroToOCLOpaqueType:\n\n  case CK_IntToOCLSampler:\n  case CK_FloatingToFixedPoint:\n  case CK_FixedPointToFloating:\n  case CK_FixedPointCast:\n  case CK_FixedPointToBoolean:\n  case CK_FixedPointToIntegral:\n  case CK_IntegralToFixedPoint:\n    llvm_unreachable(\"cast kind invalid for aggregate types\");\n  }\n}\n\nvoid AggExprEmitter::VisitCallExpr(const CallExpr *E) {\n  if (E->getCallReturnType(CGF.getContext())->isReferenceType()) {\n    EmitAggLoadOfLValue(E);\n    return;\n  }\n\n  withReturnValueSlot(E, [&](ReturnValueSlot Slot) {\n    return CGF.EmitCallExpr(E, Slot);\n  });\n}\n\nvoid AggExprEmitter::VisitObjCMessageExpr(ObjCMessageExpr *E) {\n  withReturnValueSlot(E, [&](ReturnValueSlot Slot) {\n    return CGF.EmitObjCMessageExpr(E, Slot);\n  });\n}\n\nvoid AggExprEmitter::VisitBinComma(const BinaryOperator *E) {\n  CGF.EmitIgnoredExpr(E->getLHS());\n  Visit(E->getRHS());\n}\n\nvoid AggExprEmitter::VisitStmtExpr(const StmtExpr *E) {\n  CodeGenFunction::StmtExprEvaluation eval(CGF);\n  CGF.EmitCompoundStmt(*E->getSubStmt(), true, Dest);\n}\n\nenum CompareKind {\n  CK_Less,\n  CK_Greater,\n  CK_Equal,\n};\n\nstatic llvm::Value *EmitCompare(CGBuilderTy &Builder, CodeGenFunction &CGF,\n                                const BinaryOperator *E, llvm::Value *LHS,\n                                llvm::Value *RHS, CompareKind Kind,\n                                const char *NameSuffix = \"\") {\n  QualType ArgTy = E->getLHS()->getType();\n  if (const ComplexType *CT = ArgTy->getAs<ComplexType>())\n    ArgTy = CT->getElementType();\n\n  if (const auto *MPT = ArgTy->getAs<MemberPointerType>()) {\n    assert(Kind == CK_Equal &&\n           \"member pointers may only be compared for equality\");\n    return CGF.CGM.getCXXABI().EmitMemberPointerComparison(\n        CGF, LHS, RHS, MPT, /*IsInequality*/ false);\n  }\n\n  // Compute the comparison instructions for the specified comparison kind.\n  struct CmpInstInfo {\n    const char *Name;\n    llvm::CmpInst::Predicate FCmp;\n    llvm::CmpInst::Predicate SCmp;\n    llvm::CmpInst::Predicate UCmp;\n  };\n  CmpInstInfo InstInfo = [&]() -> CmpInstInfo {\n    using FI = llvm::FCmpInst;\n    using II = llvm::ICmpInst;\n    switch (Kind) {\n    case CK_Less:\n      return {\"cmp.lt\", FI::FCMP_OLT, II::ICMP_SLT, II::ICMP_ULT};\n    case CK_Greater:\n      return {\"cmp.gt\", FI::FCMP_OGT, II::ICMP_SGT, II::ICMP_UGT};\n    case CK_Equal:\n      return {\"cmp.eq\", FI::FCMP_OEQ, II::ICMP_EQ, II::ICMP_EQ};\n    }\n    llvm_unreachable(\"Unrecognised CompareKind enum\");\n  }();\n\n  if (ArgTy->hasFloatingRepresentation())\n    return Builder.CreateFCmp(InstInfo.FCmp, LHS, RHS,\n                              llvm::Twine(InstInfo.Name) + NameSuffix);\n  if (ArgTy->isIntegralOrEnumerationType() || ArgTy->isPointerType()) {\n    auto Inst =\n        ArgTy->hasSignedIntegerRepresentation() ? InstInfo.SCmp : InstInfo.UCmp;\n    return Builder.CreateICmp(Inst, LHS, RHS,\n                              llvm::Twine(InstInfo.Name) + NameSuffix);\n  }\n\n  llvm_unreachable(\"unsupported aggregate binary expression should have \"\n                   \"already been handled\");\n}\n\nvoid AggExprEmitter::VisitBinCmp(const BinaryOperator *E) {\n  using llvm::BasicBlock;\n  using llvm::PHINode;\n  using llvm::Value;\n  assert(CGF.getContext().hasSameType(E->getLHS()->getType(),\n                                      E->getRHS()->getType()));\n  const ComparisonCategoryInfo &CmpInfo =\n      CGF.getContext().CompCategories.getInfoForType(E->getType());\n  assert(CmpInfo.Record->isTriviallyCopyable() &&\n         \"cannot copy non-trivially copyable aggregate\");\n\n  QualType ArgTy = E->getLHS()->getType();\n\n  if (!ArgTy->isIntegralOrEnumerationType() && !ArgTy->isRealFloatingType() &&\n      !ArgTy->isNullPtrType() && !ArgTy->isPointerType() &&\n      !ArgTy->isMemberPointerType() && !ArgTy->isAnyComplexType()) {\n    return CGF.ErrorUnsupported(E, \"aggregate three-way comparison\");\n  }\n  bool IsComplex = ArgTy->isAnyComplexType();\n\n  // Evaluate the operands to the expression and extract their values.\n  auto EmitOperand = [&](Expr *E) -> std::pair<Value *, Value *> {\n    RValue RV = CGF.EmitAnyExpr(E);\n    if (RV.isScalar())\n      return {RV.getScalarVal(), nullptr};\n    if (RV.isAggregate())\n      return {RV.getAggregatePointer(), nullptr};\n    assert(RV.isComplex());\n    return RV.getComplexVal();\n  };\n  auto LHSValues = EmitOperand(E->getLHS()),\n       RHSValues = EmitOperand(E->getRHS());\n\n  auto EmitCmp = [&](CompareKind K) {\n    Value *Cmp = EmitCompare(Builder, CGF, E, LHSValues.first, RHSValues.first,\n                             K, IsComplex ? \".r\" : \"\");\n    if (!IsComplex)\n      return Cmp;\n    assert(K == CompareKind::CK_Equal);\n    Value *CmpImag = EmitCompare(Builder, CGF, E, LHSValues.second,\n                                 RHSValues.second, K, \".i\");\n    return Builder.CreateAnd(Cmp, CmpImag, \"and.eq\");\n  };\n  auto EmitCmpRes = [&](const ComparisonCategoryInfo::ValueInfo *VInfo) {\n    return Builder.getInt(VInfo->getIntValue());\n  };\n\n  Value *Select;\n  if (ArgTy->isNullPtrType()) {\n    Select = EmitCmpRes(CmpInfo.getEqualOrEquiv());\n  } else if (!CmpInfo.isPartial()) {\n    Value *SelectOne =\n        Builder.CreateSelect(EmitCmp(CK_Less), EmitCmpRes(CmpInfo.getLess()),\n                             EmitCmpRes(CmpInfo.getGreater()), \"sel.lt\");\n    Select = Builder.CreateSelect(EmitCmp(CK_Equal),\n                                  EmitCmpRes(CmpInfo.getEqualOrEquiv()),\n                                  SelectOne, \"sel.eq\");\n  } else {\n    Value *SelectEq = Builder.CreateSelect(\n        EmitCmp(CK_Equal), EmitCmpRes(CmpInfo.getEqualOrEquiv()),\n        EmitCmpRes(CmpInfo.getUnordered()), \"sel.eq\");\n    Value *SelectGT = Builder.CreateSelect(EmitCmp(CK_Greater),\n                                           EmitCmpRes(CmpInfo.getGreater()),\n                                           SelectEq, \"sel.gt\");\n    Select = Builder.CreateSelect(\n        EmitCmp(CK_Less), EmitCmpRes(CmpInfo.getLess()), SelectGT, \"sel.lt\");\n  }\n  // Create the return value in the destination slot.\n  EnsureDest(E->getType());\n  LValue DestLV = CGF.MakeAddrLValue(Dest.getAddress(), E->getType());\n\n  // Emit the address of the first (and only) field in the comparison category\n  // type, and initialize it from the constant integer value selected above.\n  LValue FieldLV = CGF.EmitLValueForFieldInitialization(\n      DestLV, *CmpInfo.Record->field_begin());\n  CGF.EmitStoreThroughLValue(RValue::get(Select), FieldLV, /*IsInit*/ true);\n\n  // All done! The result is in the Dest slot.\n}\n\nvoid AggExprEmitter::VisitBinaryOperator(const BinaryOperator *E) {\n  if (E->getOpcode() == BO_PtrMemD || E->getOpcode() == BO_PtrMemI)\n    VisitPointerToDataMemberBinaryOperator(E);\n  else\n    CGF.ErrorUnsupported(E, \"aggregate binary expression\");\n}\n\nvoid AggExprEmitter::VisitPointerToDataMemberBinaryOperator(\n                                                    const BinaryOperator *E) {\n  LValue LV = CGF.EmitPointerToDataMemberBinaryExpr(E);\n  EmitFinalDestCopy(E->getType(), LV);\n}\n\n/// Is the value of the given expression possibly a reference to or\n/// into a __block variable?\nstatic bool isBlockVarRef(const Expr *E) {\n  // Make sure we look through parens.\n  E = E->IgnoreParens();\n\n  // Check for a direct reference to a __block variable.\n  if (const DeclRefExpr *DRE = dyn_cast<DeclRefExpr>(E)) {\n    const VarDecl *var = dyn_cast<VarDecl>(DRE->getDecl());\n    return (var && var->hasAttr<BlocksAttr>());\n  }\n\n  // More complicated stuff.\n\n  // Binary operators.\n  if (const BinaryOperator *op = dyn_cast<BinaryOperator>(E)) {\n    // For an assignment or pointer-to-member operation, just care\n    // about the LHS.\n    if (op->isAssignmentOp() || op->isPtrMemOp())\n      return isBlockVarRef(op->getLHS());\n\n    // For a comma, just care about the RHS.\n    if (op->getOpcode() == BO_Comma)\n      return isBlockVarRef(op->getRHS());\n\n    // FIXME: pointer arithmetic?\n    return false;\n\n  // Check both sides of a conditional operator.\n  } else if (const AbstractConditionalOperator *op\n               = dyn_cast<AbstractConditionalOperator>(E)) {\n    return isBlockVarRef(op->getTrueExpr())\n        || isBlockVarRef(op->getFalseExpr());\n\n  // OVEs are required to support BinaryConditionalOperators.\n  } else if (const OpaqueValueExpr *op\n               = dyn_cast<OpaqueValueExpr>(E)) {\n    if (const Expr *src = op->getSourceExpr())\n      return isBlockVarRef(src);\n\n  // Casts are necessary to get things like (*(int*)&var) = foo().\n  // We don't really care about the kind of cast here, except\n  // we don't want to look through l2r casts, because it's okay\n  // to get the *value* in a __block variable.\n  } else if (const CastExpr *cast = dyn_cast<CastExpr>(E)) {\n    if (cast->getCastKind() == CK_LValueToRValue)\n      return false;\n    return isBlockVarRef(cast->getSubExpr());\n\n  // Handle unary operators.  Again, just aggressively look through\n  // it, ignoring the operation.\n  } else if (const UnaryOperator *uop = dyn_cast<UnaryOperator>(E)) {\n    return isBlockVarRef(uop->getSubExpr());\n\n  // Look into the base of a field access.\n  } else if (const MemberExpr *mem = dyn_cast<MemberExpr>(E)) {\n    return isBlockVarRef(mem->getBase());\n\n  // Look into the base of a subscript.\n  } else if (const ArraySubscriptExpr *sub = dyn_cast<ArraySubscriptExpr>(E)) {\n    return isBlockVarRef(sub->getBase());\n  }\n\n  return false;\n}\n\nvoid AggExprEmitter::VisitBinAssign(const BinaryOperator *E) {\n  // For an assignment to work, the value on the right has\n  // to be compatible with the value on the left.\n  assert(CGF.getContext().hasSameUnqualifiedType(E->getLHS()->getType(),\n                                                 E->getRHS()->getType())\n         && \"Invalid assignment\");\n\n  // If the LHS might be a __block variable, and the RHS can\n  // potentially cause a block copy, we need to evaluate the RHS first\n  // so that the assignment goes the right place.\n  // This is pretty semantically fragile.\n  if (isBlockVarRef(E->getLHS()) &&\n      E->getRHS()->HasSideEffects(CGF.getContext())) {\n    // Ensure that we have a destination, and evaluate the RHS into that.\n    EnsureDest(E->getRHS()->getType());\n    Visit(E->getRHS());\n\n    // Now emit the LHS and copy into it.\n    LValue LHS = CGF.EmitCheckedLValue(E->getLHS(), CodeGenFunction::TCK_Store);\n\n    // That copy is an atomic copy if the LHS is atomic.\n    if (LHS.getType()->isAtomicType() ||\n        CGF.LValueIsSuitableForInlineAtomic(LHS)) {\n      CGF.EmitAtomicStore(Dest.asRValue(), LHS, /*isInit*/ false);\n      return;\n    }\n\n    EmitCopy(E->getLHS()->getType(),\n             AggValueSlot::forLValue(LHS, CGF, AggValueSlot::IsDestructed,\n                                     needsGC(E->getLHS()->getType()),\n                                     AggValueSlot::IsAliased,\n                                     AggValueSlot::MayOverlap),\n             Dest);\n    return;\n  }\n\n  LValue LHS = CGF.EmitLValue(E->getLHS());\n\n  // If we have an atomic type, evaluate into the destination and then\n  // do an atomic copy.\n  if (LHS.getType()->isAtomicType() ||\n      CGF.LValueIsSuitableForInlineAtomic(LHS)) {\n    EnsureDest(E->getRHS()->getType());\n    Visit(E->getRHS());\n    CGF.EmitAtomicStore(Dest.asRValue(), LHS, /*isInit*/ false);\n    return;\n  }\n\n  // Codegen the RHS so that it stores directly into the LHS.\n  AggValueSlot LHSSlot = AggValueSlot::forLValue(\n      LHS, CGF, AggValueSlot::IsDestructed, needsGC(E->getLHS()->getType()),\n      AggValueSlot::IsAliased, AggValueSlot::MayOverlap);\n  // A non-volatile aggregate destination might have volatile member.\n  if (!LHSSlot.isVolatile() &&\n      CGF.hasVolatileMember(E->getLHS()->getType()))\n    LHSSlot.setVolatile(true);\n\n  CGF.EmitAggExpr(E->getRHS(), LHSSlot);\n\n  // Copy into the destination if the assignment isn't ignored.\n  EmitFinalDestCopy(E->getType(), LHS);\n\n  if (!Dest.isIgnored() && !Dest.isExternallyDestructed() &&\n      E->getType().isDestructedType() == QualType::DK_nontrivial_c_struct)\n    CGF.pushDestroy(QualType::DK_nontrivial_c_struct, Dest.getAddress(),\n                    E->getType());\n}\n\nvoid AggExprEmitter::\nVisitAbstractConditionalOperator(const AbstractConditionalOperator *E) {\n  llvm::BasicBlock *LHSBlock = CGF.createBasicBlock(\"cond.true\");\n  llvm::BasicBlock *RHSBlock = CGF.createBasicBlock(\"cond.false\");\n  llvm::BasicBlock *ContBlock = CGF.createBasicBlock(\"cond.end\");\n\n  // Bind the common expression if necessary.\n  CodeGenFunction::OpaqueValueMapping binding(CGF, E);\n\n  CodeGenFunction::ConditionalEvaluation eval(CGF);\n  CGF.EmitBranchOnBoolExpr(E->getCond(), LHSBlock, RHSBlock,\n                           CGF.getProfileCount(E));\n\n  // Save whether the destination's lifetime is externally managed.\n  bool isExternallyDestructed = Dest.isExternallyDestructed();\n  bool destructNonTrivialCStruct =\n      !isExternallyDestructed &&\n      E->getType().isDestructedType() == QualType::DK_nontrivial_c_struct;\n  isExternallyDestructed |= destructNonTrivialCStruct;\n  Dest.setExternallyDestructed(isExternallyDestructed);\n\n  eval.begin(CGF);\n  CGF.EmitBlock(LHSBlock);\n  CGF.incrementProfileCounter(E);\n  Visit(E->getTrueExpr());\n  eval.end(CGF);\n\n  assert(CGF.HaveInsertPoint() && \"expression evaluation ended with no IP!\");\n  CGF.Builder.CreateBr(ContBlock);\n\n  // If the result of an agg expression is unused, then the emission\n  // of the LHS might need to create a destination slot.  That's fine\n  // with us, and we can safely emit the RHS into the same slot, but\n  // we shouldn't claim that it's already being destructed.\n  Dest.setExternallyDestructed(isExternallyDestructed);\n\n  eval.begin(CGF);\n  CGF.EmitBlock(RHSBlock);\n  Visit(E->getFalseExpr());\n  eval.end(CGF);\n\n  if (destructNonTrivialCStruct)\n    CGF.pushDestroy(QualType::DK_nontrivial_c_struct, Dest.getAddress(),\n                    E->getType());\n\n  CGF.EmitBlock(ContBlock);\n}\n\nvoid AggExprEmitter::VisitChooseExpr(const ChooseExpr *CE) {\n  Visit(CE->getChosenSubExpr());\n}\n\nvoid AggExprEmitter::VisitVAArgExpr(VAArgExpr *VE) {\n  Address ArgValue = Address::invalid();\n  Address ArgPtr = CGF.EmitVAArg(VE, ArgValue);\n\n  // If EmitVAArg fails, emit an error.\n  if (!ArgPtr.isValid()) {\n    CGF.ErrorUnsupported(VE, \"aggregate va_arg expression\");\n    return;\n  }\n\n  EmitFinalDestCopy(VE->getType(), CGF.MakeAddrLValue(ArgPtr, VE->getType()));\n}\n\nvoid AggExprEmitter::VisitCXXBindTemporaryExpr(CXXBindTemporaryExpr *E) {\n  // Ensure that we have a slot, but if we already do, remember\n  // whether it was externally destructed.\n  bool wasExternallyDestructed = Dest.isExternallyDestructed();\n  EnsureDest(E->getType());\n\n  // We're going to push a destructor if there isn't already one.\n  Dest.setExternallyDestructed();\n\n  Visit(E->getSubExpr());\n\n  // Push that destructor we promised.\n  if (!wasExternallyDestructed)\n    CGF.EmitCXXTemporary(E->getTemporary(), E->getType(), Dest.getAddress());\n}\n\nvoid\nAggExprEmitter::VisitCXXConstructExpr(const CXXConstructExpr *E) {\n  AggValueSlot Slot = EnsureSlot(E->getType());\n  CGF.EmitCXXConstructExpr(E, Slot);\n}\n\nvoid AggExprEmitter::VisitCXXInheritedCtorInitExpr(\n    const CXXInheritedCtorInitExpr *E) {\n  AggValueSlot Slot = EnsureSlot(E->getType());\n  CGF.EmitInheritedCXXConstructorCall(\n      E->getConstructor(), E->constructsVBase(), Slot.getAddress(),\n      E->inheritedFromVBase(), E);\n}\n\nvoid\nAggExprEmitter::VisitLambdaExpr(LambdaExpr *E) {\n  AggValueSlot Slot = EnsureSlot(E->getType());\n  LValue SlotLV = CGF.MakeAddrLValue(Slot.getAddress(), E->getType());\n\n  // We'll need to enter cleanup scopes in case any of the element\n  // initializers throws an exception.\n  SmallVector<EHScopeStack::stable_iterator, 16> Cleanups;\n  llvm::Instruction *CleanupDominator = nullptr;\n\n  CXXRecordDecl::field_iterator CurField = E->getLambdaClass()->field_begin();\n  for (LambdaExpr::const_capture_init_iterator i = E->capture_init_begin(),\n                                               e = E->capture_init_end();\n       i != e; ++i, ++CurField) {\n    // Emit initialization\n    LValue LV = CGF.EmitLValueForFieldInitialization(SlotLV, *CurField);\n    if (CurField->hasCapturedVLAType()) {\n      CGF.EmitLambdaVLACapture(CurField->getCapturedVLAType(), LV);\n      continue;\n    }\n\n    EmitInitializationToLValue(*i, LV);\n\n    // Push a destructor if necessary.\n    if (QualType::DestructionKind DtorKind =\n            CurField->getType().isDestructedType()) {\n      assert(LV.isSimple());\n      if (CGF.needsEHCleanup(DtorKind)) {\n        if (!CleanupDominator)\n          CleanupDominator = CGF.Builder.CreateAlignedLoad(\n              CGF.Int8Ty,\n              llvm::Constant::getNullValue(CGF.Int8PtrTy),\n              CharUnits::One()); // placeholder\n\n        CGF.pushDestroy(EHCleanup, LV.getAddress(CGF), CurField->getType(),\n                        CGF.getDestroyer(DtorKind), false);\n        Cleanups.push_back(CGF.EHStack.stable_begin());\n      }\n    }\n  }\n\n  // Deactivate all the partial cleanups in reverse order, which\n  // generally means popping them.\n  for (unsigned i = Cleanups.size(); i != 0; --i)\n    CGF.DeactivateCleanupBlock(Cleanups[i-1], CleanupDominator);\n\n  // Destroy the placeholder if we made one.\n  if (CleanupDominator)\n    CleanupDominator->eraseFromParent();\n}\n\nvoid AggExprEmitter::VisitExprWithCleanups(ExprWithCleanups *E) {\n  CodeGenFunction::RunCleanupsScope cleanups(CGF);\n  Visit(E->getSubExpr());\n}\n\nvoid AggExprEmitter::VisitCXXScalarValueInitExpr(CXXScalarValueInitExpr *E) {\n  QualType T = E->getType();\n  AggValueSlot Slot = EnsureSlot(T);\n  EmitNullInitializationToLValue(CGF.MakeAddrLValue(Slot.getAddress(), T));\n}\n\nvoid AggExprEmitter::VisitImplicitValueInitExpr(ImplicitValueInitExpr *E) {\n  QualType T = E->getType();\n  AggValueSlot Slot = EnsureSlot(T);\n  EmitNullInitializationToLValue(CGF.MakeAddrLValue(Slot.getAddress(), T));\n}\n\n/// Determine whether the given cast kind is known to always convert values\n/// with all zero bits in their value representation to values with all zero\n/// bits in their value representation.\nstatic bool castPreservesZero(const CastExpr *CE) {\n  switch (CE->getCastKind()) {\n    // No-ops.\n  case CK_NoOp:\n  case CK_UserDefinedConversion:\n  case CK_ConstructorConversion:\n  case CK_BitCast:\n  case CK_ToUnion:\n  case CK_ToVoid:\n    // Conversions between (possibly-complex) integral, (possibly-complex)\n    // floating-point, and bool.\n  case CK_BooleanToSignedIntegral:\n  case CK_FloatingCast:\n  case CK_FloatingComplexCast:\n  case CK_FloatingComplexToBoolean:\n  case CK_FloatingComplexToIntegralComplex:\n  case CK_FloatingComplexToReal:\n  case CK_FloatingRealToComplex:\n  case CK_FloatingToBoolean:\n  case CK_FloatingToIntegral:\n  case CK_IntegralCast:\n  case CK_IntegralComplexCast:\n  case CK_IntegralComplexToBoolean:\n  case CK_IntegralComplexToFloatingComplex:\n  case CK_IntegralComplexToReal:\n  case CK_IntegralRealToComplex:\n  case CK_IntegralToBoolean:\n  case CK_IntegralToFloating:\n    // Reinterpreting integers as pointers and vice versa.\n  case CK_IntegralToPointer:\n  case CK_PointerToIntegral:\n    // Language extensions.\n  case CK_VectorSplat:\n  case CK_NonAtomicToAtomic:\n  case CK_AtomicToNonAtomic:\n    return true;\n\n  case CK_BaseToDerivedMemberPointer:\n  case CK_DerivedToBaseMemberPointer:\n  case CK_MemberPointerToBoolean:\n  case CK_NullToMemberPointer:\n  case CK_ReinterpretMemberPointer:\n    // FIXME: ABI-dependent.\n    return false;\n\n  case CK_AnyPointerToBlockPointerCast:\n  case CK_BlockPointerToObjCPointerCast:\n  case CK_CPointerToObjCPointerCast:\n  case CK_ObjCObjectLValueCast:\n  case CK_IntToOCLSampler:\n  case CK_ZeroToOCLOpaqueType:\n    // FIXME: Check these.\n    return false;\n\n  case CK_FixedPointCast:\n  case CK_FixedPointToBoolean:\n  case CK_FixedPointToFloating:\n  case CK_FixedPointToIntegral:\n  case CK_FloatingToFixedPoint:\n  case CK_IntegralToFixedPoint:\n    // FIXME: Do all fixed-point types represent zero as all 0 bits?\n    return false;\n\n  case CK_AddressSpaceConversion:\n  case CK_BaseToDerived:\n  case CK_DerivedToBase:\n  case CK_Dynamic:\n  case CK_NullToPointer:\n  case CK_PointerToBoolean:\n    // FIXME: Preserves zeroes only if zero pointers and null pointers have the\n    // same representation in all involved address spaces.\n    return false;\n\n  case CK_ARCConsumeObject:\n  case CK_ARCExtendBlockObject:\n  case CK_ARCProduceObject:\n  case CK_ARCReclaimReturnedObject:\n  case CK_CopyAndAutoreleaseBlockObject:\n  case CK_ArrayToPointerDecay:\n  case CK_FunctionToPointerDecay:\n  case CK_BuiltinFnToFnPtr:\n  case CK_Dependent:\n  case CK_LValueBitCast:\n  case CK_LValueToRValue:\n  case CK_LValueToRValueBitCast:\n  case CK_UncheckedDerivedToBase:\n    return false;\n  }\n  llvm_unreachable(\"Unhandled clang::CastKind enum\");\n}\n\n/// isSimpleZero - If emitting this value will obviously just cause a store of\n/// zero to memory, return true.  This can return false if uncertain, so it just\n/// handles simple cases.\nstatic bool isSimpleZero(const Expr *E, CodeGenFunction &CGF) {\n  E = E->IgnoreParens();\n  while (auto *CE = dyn_cast<CastExpr>(E)) {\n    if (!castPreservesZero(CE))\n      break;\n    E = CE->getSubExpr()->IgnoreParens();\n  }\n\n  // 0\n  if (const IntegerLiteral *IL = dyn_cast<IntegerLiteral>(E))\n    return IL->getValue() == 0;\n  // +0.0\n  if (const FloatingLiteral *FL = dyn_cast<FloatingLiteral>(E))\n    return FL->getValue().isPosZero();\n  // int()\n  if ((isa<ImplicitValueInitExpr>(E) || isa<CXXScalarValueInitExpr>(E)) &&\n      CGF.getTypes().isZeroInitializable(E->getType()))\n    return true;\n  // (int*)0 - Null pointer expressions.\n  if (const CastExpr *ICE = dyn_cast<CastExpr>(E))\n    return ICE->getCastKind() == CK_NullToPointer &&\n           CGF.getTypes().isPointerZeroInitializable(E->getType()) &&\n           !E->HasSideEffects(CGF.getContext());\n  // '\\0'\n  if (const CharacterLiteral *CL = dyn_cast<CharacterLiteral>(E))\n    return CL->getValue() == 0;\n\n  // Otherwise, hard case: conservatively return false.\n  return false;\n}\n\n\nvoid\nAggExprEmitter::EmitInitializationToLValue(Expr *E, LValue LV) {\n  QualType type = LV.getType();\n  // FIXME: Ignore result?\n  // FIXME: Are initializers affected by volatile?\n  if (Dest.isZeroed() && isSimpleZero(E, CGF)) {\n    // Storing \"i32 0\" to a zero'd memory location is a noop.\n    return;\n  } else if (isa<ImplicitValueInitExpr>(E) || isa<CXXScalarValueInitExpr>(E)) {\n    return EmitNullInitializationToLValue(LV);\n  } else if (isa<NoInitExpr>(E)) {\n    // Do nothing.\n    return;\n  } else if (type->isReferenceType()) {\n    RValue RV = CGF.EmitReferenceBindingToExpr(E);\n    return CGF.EmitStoreThroughLValue(RV, LV);\n  }\n\n  switch (CGF.getEvaluationKind(type)) {\n  case TEK_Complex:\n    CGF.EmitComplexExprIntoLValue(E, LV, /*isInit*/ true);\n    return;\n  case TEK_Aggregate:\n    CGF.EmitAggExpr(\n        E, AggValueSlot::forLValue(LV, CGF, AggValueSlot::IsDestructed,\n                                   AggValueSlot::DoesNotNeedGCBarriers,\n                                   AggValueSlot::IsNotAliased,\n                                   AggValueSlot::MayOverlap, Dest.isZeroed()));\n    return;\n  case TEK_Scalar:\n    if (LV.isSimple()) {\n      CGF.EmitScalarInit(E, /*D=*/nullptr, LV, /*Captured=*/false);\n    } else {\n      CGF.EmitStoreThroughLValue(RValue::get(CGF.EmitScalarExpr(E)), LV);\n    }\n    return;\n  }\n  llvm_unreachable(\"bad evaluation kind\");\n}\n\nvoid AggExprEmitter::EmitNullInitializationToLValue(LValue lv) {\n  QualType type = lv.getType();\n\n  // If the destination slot is already zeroed out before the aggregate is\n  // copied into it, we don't have to emit any zeros here.\n  if (Dest.isZeroed() && CGF.getTypes().isZeroInitializable(type))\n    return;\n\n  if (CGF.hasScalarEvaluationKind(type)) {\n    // For non-aggregates, we can store the appropriate null constant.\n    llvm::Value *null = CGF.CGM.EmitNullConstant(type);\n    // Note that the following is not equivalent to\n    // EmitStoreThroughBitfieldLValue for ARC types.\n    if (lv.isBitField()) {\n      CGF.EmitStoreThroughBitfieldLValue(RValue::get(null), lv);\n    } else {\n      assert(lv.isSimple());\n      CGF.EmitStoreOfScalar(null, lv, /* isInitialization */ true);\n    }\n  } else {\n    // There's a potential optimization opportunity in combining\n    // memsets; that would be easy for arrays, but relatively\n    // difficult for structures with the current code.\n    CGF.EmitNullInitialization(lv.getAddress(CGF), lv.getType());\n  }\n}\n\nvoid AggExprEmitter::VisitInitListExpr(InitListExpr *E) {\n#if 0\n  // FIXME: Assess perf here?  Figure out what cases are worth optimizing here\n  // (Length of globals? Chunks of zeroed-out space?).\n  //\n  // If we can, prefer a copy from a global; this is a lot less code for long\n  // globals, and it's easier for the current optimizers to analyze.\n  if (llvm::Constant* C = CGF.CGM.EmitConstantExpr(E, E->getType(), &CGF)) {\n    llvm::GlobalVariable* GV =\n    new llvm::GlobalVariable(CGF.CGM.getModule(), C->getType(), true,\n                             llvm::GlobalValue::InternalLinkage, C, \"\");\n    EmitFinalDestCopy(E->getType(), CGF.MakeAddrLValue(GV, E->getType()));\n    return;\n  }\n#endif\n  if (E->hadArrayRangeDesignator())\n    CGF.ErrorUnsupported(E, \"GNU array range designator extension\");\n\n  if (E->isTransparent())\n    return Visit(E->getInit(0));\n\n  AggValueSlot Dest = EnsureSlot(E->getType());\n\n  LValue DestLV = CGF.MakeAddrLValue(Dest.getAddress(), E->getType());\n\n  // Handle initialization of an array.\n  if (E->getType()->isArrayType()) {\n    auto AType = cast<llvm::ArrayType>(Dest.getAddress().getElementType());\n    EmitArrayInit(Dest.getAddress(), AType, E->getType(), E);\n    return;\n  }\n\n  assert(E->getType()->isRecordType() && \"Only support structs/unions here!\");\n\n  // Do struct initialization; this code just sets each individual member\n  // to the approprate value.  This makes bitfield support automatic;\n  // the disadvantage is that the generated code is more difficult for\n  // the optimizer, especially with bitfields.\n  unsigned NumInitElements = E->getNumInits();\n  RecordDecl *record = E->getType()->castAs<RecordType>()->getDecl();\n\n  // We'll need to enter cleanup scopes in case any of the element\n  // initializers throws an exception.\n  SmallVector<EHScopeStack::stable_iterator, 16> cleanups;\n  llvm::Instruction *cleanupDominator = nullptr;\n  auto addCleanup = [&](const EHScopeStack::stable_iterator &cleanup) {\n    cleanups.push_back(cleanup);\n    if (!cleanupDominator) // create placeholder once needed\n      cleanupDominator = CGF.Builder.CreateAlignedLoad(\n          CGF.Int8Ty, llvm::Constant::getNullValue(CGF.Int8PtrTy),\n          CharUnits::One());\n  };\n\n  unsigned curInitIndex = 0;\n\n  // Emit initialization of base classes.\n  if (auto *CXXRD = dyn_cast<CXXRecordDecl>(record)) {\n    assert(E->getNumInits() >= CXXRD->getNumBases() &&\n           \"missing initializer for base class\");\n    for (auto &Base : CXXRD->bases()) {\n      assert(!Base.isVirtual() && \"should not see vbases here\");\n      auto *BaseRD = Base.getType()->getAsCXXRecordDecl();\n      Address V = CGF.GetAddressOfDirectBaseInCompleteClass(\n          Dest.getAddress(), CXXRD, BaseRD,\n          /*isBaseVirtual*/ false);\n      AggValueSlot AggSlot = AggValueSlot::forAddr(\n          V, Qualifiers(),\n          AggValueSlot::IsDestructed,\n          AggValueSlot::DoesNotNeedGCBarriers,\n          AggValueSlot::IsNotAliased,\n          CGF.getOverlapForBaseInit(CXXRD, BaseRD, Base.isVirtual()));\n      CGF.EmitAggExpr(E->getInit(curInitIndex++), AggSlot);\n\n      if (QualType::DestructionKind dtorKind =\n              Base.getType().isDestructedType()) {\n        CGF.pushDestroy(dtorKind, V, Base.getType());\n        addCleanup(CGF.EHStack.stable_begin());\n      }\n    }\n  }\n\n  // Prepare a 'this' for CXXDefaultInitExprs.\n  CodeGenFunction::FieldConstructionScope FCS(CGF, Dest.getAddress());\n\n  if (record->isUnion()) {\n    // Only initialize one field of a union. The field itself is\n    // specified by the initializer list.\n    if (!E->getInitializedFieldInUnion()) {\n      // Empty union; we have nothing to do.\n\n#ifndef NDEBUG\n      // Make sure that it's really an empty and not a failure of\n      // semantic analysis.\n      for (const auto *Field : record->fields())\n        assert(Field->isUnnamedBitfield() && \"Only unnamed bitfields allowed\");\n#endif\n      return;\n    }\n\n    // FIXME: volatility\n    FieldDecl *Field = E->getInitializedFieldInUnion();\n\n    LValue FieldLoc = CGF.EmitLValueForFieldInitialization(DestLV, Field);\n    if (NumInitElements) {\n      // Store the initializer into the field\n      EmitInitializationToLValue(E->getInit(0), FieldLoc);\n    } else {\n      // Default-initialize to null.\n      EmitNullInitializationToLValue(FieldLoc);\n    }\n\n    return;\n  }\n\n  // Here we iterate over the fields; this makes it simpler to both\n  // default-initialize fields and skip over unnamed fields.\n  for (const auto *field : record->fields()) {\n    // We're done once we hit the flexible array member.\n    if (field->getType()->isIncompleteArrayType())\n      break;\n\n    // Always skip anonymous bitfields.\n    if (field->isUnnamedBitfield())\n      continue;\n\n    // We're done if we reach the end of the explicit initializers, we\n    // have a zeroed object, and the rest of the fields are\n    // zero-initializable.\n    if (curInitIndex == NumInitElements && Dest.isZeroed() &&\n        CGF.getTypes().isZeroInitializable(E->getType()))\n      break;\n\n\n    LValue LV = CGF.EmitLValueForFieldInitialization(DestLV, field);\n    // We never generate write-barries for initialized fields.\n    LV.setNonGC(true);\n\n    if (curInitIndex < NumInitElements) {\n      // Store the initializer into the field.\n      EmitInitializationToLValue(E->getInit(curInitIndex++), LV);\n    } else {\n      // We're out of initializers; default-initialize to null\n      EmitNullInitializationToLValue(LV);\n    }\n\n    // Push a destructor if necessary.\n    // FIXME: if we have an array of structures, all explicitly\n    // initialized, we can end up pushing a linear number of cleanups.\n    bool pushedCleanup = false;\n    if (QualType::DestructionKind dtorKind\n          = field->getType().isDestructedType()) {\n      assert(LV.isSimple());\n      if (CGF.needsEHCleanup(dtorKind)) {\n        CGF.pushDestroy(EHCleanup, LV.getAddress(CGF), field->getType(),\n                        CGF.getDestroyer(dtorKind), false);\n        addCleanup(CGF.EHStack.stable_begin());\n        pushedCleanup = true;\n      }\n    }\n\n    // If the GEP didn't get used because of a dead zero init or something\n    // else, clean it up for -O0 builds and general tidiness.\n    if (!pushedCleanup && LV.isSimple())\n      if (llvm::GetElementPtrInst *GEP =\n              dyn_cast<llvm::GetElementPtrInst>(LV.getPointer(CGF)))\n        if (GEP->use_empty())\n          GEP->eraseFromParent();\n  }\n\n  // Deactivate all the partial cleanups in reverse order, which\n  // generally means popping them.\n  assert((cleanupDominator || cleanups.empty()) &&\n         \"Missing cleanupDominator before deactivating cleanup blocks\");\n  for (unsigned i = cleanups.size(); i != 0; --i)\n    CGF.DeactivateCleanupBlock(cleanups[i-1], cleanupDominator);\n\n  // Destroy the placeholder if we made one.\n  if (cleanupDominator)\n    cleanupDominator->eraseFromParent();\n}\n\nvoid AggExprEmitter::VisitArrayInitLoopExpr(const ArrayInitLoopExpr *E,\n                                            llvm::Value *outerBegin) {\n  // Emit the common subexpression.\n  CodeGenFunction::OpaqueValueMapping binding(CGF, E->getCommonExpr());\n\n  Address destPtr = EnsureSlot(E->getType()).getAddress();\n  uint64_t numElements = E->getArraySize().getZExtValue();\n\n  if (!numElements)\n    return;\n\n  // destPtr is an array*. Construct an elementType* by drilling down a level.\n  llvm::Value *zero = llvm::ConstantInt::get(CGF.SizeTy, 0);\n  llvm::Value *indices[] = {zero, zero};\n  llvm::Value *begin = Builder.CreateInBoundsGEP(destPtr.getPointer(), indices,\n                                                 \"arrayinit.begin\");\n\n  // Prepare to special-case multidimensional array initialization: we avoid\n  // emitting multiple destructor loops in that case.\n  if (!outerBegin)\n    outerBegin = begin;\n  ArrayInitLoopExpr *InnerLoop = dyn_cast<ArrayInitLoopExpr>(E->getSubExpr());\n\n  QualType elementType =\n      CGF.getContext().getAsArrayType(E->getType())->getElementType();\n  CharUnits elementSize = CGF.getContext().getTypeSizeInChars(elementType);\n  CharUnits elementAlign =\n      destPtr.getAlignment().alignmentOfArrayElement(elementSize);\n\n  llvm::BasicBlock *entryBB = Builder.GetInsertBlock();\n  llvm::BasicBlock *bodyBB = CGF.createBasicBlock(\"arrayinit.body\");\n\n  // Jump into the body.\n  CGF.EmitBlock(bodyBB);\n  llvm::PHINode *index =\n      Builder.CreatePHI(zero->getType(), 2, \"arrayinit.index\");\n  index->addIncoming(zero, entryBB);\n  llvm::Value *element = Builder.CreateInBoundsGEP(begin, index);\n\n  // Prepare for a cleanup.\n  QualType::DestructionKind dtorKind = elementType.isDestructedType();\n  EHScopeStack::stable_iterator cleanup;\n  if (CGF.needsEHCleanup(dtorKind) && !InnerLoop) {\n    if (outerBegin->getType() != element->getType())\n      outerBegin = Builder.CreateBitCast(outerBegin, element->getType());\n    CGF.pushRegularPartialArrayCleanup(outerBegin, element, elementType,\n                                       elementAlign,\n                                       CGF.getDestroyer(dtorKind));\n    cleanup = CGF.EHStack.stable_begin();\n  } else {\n    dtorKind = QualType::DK_none;\n  }\n\n  // Emit the actual filler expression.\n  {\n    // Temporaries created in an array initialization loop are destroyed\n    // at the end of each iteration.\n    CodeGenFunction::RunCleanupsScope CleanupsScope(CGF);\n    CodeGenFunction::ArrayInitLoopExprScope Scope(CGF, index);\n    LValue elementLV =\n        CGF.MakeAddrLValue(Address(element, elementAlign), elementType);\n\n    if (InnerLoop) {\n      // If the subexpression is an ArrayInitLoopExpr, share its cleanup.\n      auto elementSlot = AggValueSlot::forLValue(\n          elementLV, CGF, AggValueSlot::IsDestructed,\n          AggValueSlot::DoesNotNeedGCBarriers, AggValueSlot::IsNotAliased,\n          AggValueSlot::DoesNotOverlap);\n      AggExprEmitter(CGF, elementSlot, false)\n          .VisitArrayInitLoopExpr(InnerLoop, outerBegin);\n    } else\n      EmitInitializationToLValue(E->getSubExpr(), elementLV);\n  }\n\n  // Move on to the next element.\n  llvm::Value *nextIndex = Builder.CreateNUWAdd(\n      index, llvm::ConstantInt::get(CGF.SizeTy, 1), \"arrayinit.next\");\n  index->addIncoming(nextIndex, Builder.GetInsertBlock());\n\n  // Leave the loop if we're done.\n  llvm::Value *done = Builder.CreateICmpEQ(\n      nextIndex, llvm::ConstantInt::get(CGF.SizeTy, numElements),\n      \"arrayinit.done\");\n  llvm::BasicBlock *endBB = CGF.createBasicBlock(\"arrayinit.end\");\n  Builder.CreateCondBr(done, endBB, bodyBB);\n\n  CGF.EmitBlock(endBB);\n\n  // Leave the partial-array cleanup if we entered one.\n  if (dtorKind)\n    CGF.DeactivateCleanupBlock(cleanup, index);\n}\n\nvoid AggExprEmitter::VisitDesignatedInitUpdateExpr(DesignatedInitUpdateExpr *E) {\n  AggValueSlot Dest = EnsureSlot(E->getType());\n\n  LValue DestLV = CGF.MakeAddrLValue(Dest.getAddress(), E->getType());\n  EmitInitializationToLValue(E->getBase(), DestLV);\n  VisitInitListExpr(E->getUpdater());\n}\n\n//===----------------------------------------------------------------------===//\n//                        Entry Points into this File\n//===----------------------------------------------------------------------===//\n\n/// GetNumNonZeroBytesInInit - Get an approximate count of the number of\n/// non-zero bytes that will be stored when outputting the initializer for the\n/// specified initializer expression.\nstatic CharUnits GetNumNonZeroBytesInInit(const Expr *E, CodeGenFunction &CGF) {\n  if (auto *MTE = dyn_cast<MaterializeTemporaryExpr>(E))\n    E = MTE->getSubExpr();\n  E = E->IgnoreParenNoopCasts(CGF.getContext());\n\n  // 0 and 0.0 won't require any non-zero stores!\n  if (isSimpleZero(E, CGF)) return CharUnits::Zero();\n\n  // If this is an initlist expr, sum up the size of sizes of the (present)\n  // elements.  If this is something weird, assume the whole thing is non-zero.\n  const InitListExpr *ILE = dyn_cast<InitListExpr>(E);\n  while (ILE && ILE->isTransparent())\n    ILE = dyn_cast<InitListExpr>(ILE->getInit(0));\n  if (!ILE || !CGF.getTypes().isZeroInitializable(ILE->getType()))\n    return CGF.getContext().getTypeSizeInChars(E->getType());\n\n  // InitListExprs for structs have to be handled carefully.  If there are\n  // reference members, we need to consider the size of the reference, not the\n  // referencee.  InitListExprs for unions and arrays can't have references.\n  if (const RecordType *RT = E->getType()->getAs<RecordType>()) {\n    if (!RT->isUnionType()) {\n      RecordDecl *SD = RT->getDecl();\n      CharUnits NumNonZeroBytes = CharUnits::Zero();\n\n      unsigned ILEElement = 0;\n      if (auto *CXXRD = dyn_cast<CXXRecordDecl>(SD))\n        while (ILEElement != CXXRD->getNumBases())\n          NumNonZeroBytes +=\n              GetNumNonZeroBytesInInit(ILE->getInit(ILEElement++), CGF);\n      for (const auto *Field : SD->fields()) {\n        // We're done once we hit the flexible array member or run out of\n        // InitListExpr elements.\n        if (Field->getType()->isIncompleteArrayType() ||\n            ILEElement == ILE->getNumInits())\n          break;\n        if (Field->isUnnamedBitfield())\n          continue;\n\n        const Expr *E = ILE->getInit(ILEElement++);\n\n        // Reference values are always non-null and have the width of a pointer.\n        if (Field->getType()->isReferenceType())\n          NumNonZeroBytes += CGF.getContext().toCharUnitsFromBits(\n              CGF.getTarget().getPointerWidth(0));\n        else\n          NumNonZeroBytes += GetNumNonZeroBytesInInit(E, CGF);\n      }\n\n      return NumNonZeroBytes;\n    }\n  }\n\n  // FIXME: This overestimates the number of non-zero bytes for bit-fields.\n  CharUnits NumNonZeroBytes = CharUnits::Zero();\n  for (unsigned i = 0, e = ILE->getNumInits(); i != e; ++i)\n    NumNonZeroBytes += GetNumNonZeroBytesInInit(ILE->getInit(i), CGF);\n  return NumNonZeroBytes;\n}\n\n/// CheckAggExprForMemSetUse - If the initializer is large and has a lot of\n/// zeros in it, emit a memset and avoid storing the individual zeros.\n///\nstatic void CheckAggExprForMemSetUse(AggValueSlot &Slot, const Expr *E,\n                                     CodeGenFunction &CGF) {\n  // If the slot is already known to be zeroed, nothing to do.  Don't mess with\n  // volatile stores.\n  if (Slot.isZeroed() || Slot.isVolatile() || !Slot.getAddress().isValid())\n    return;\n\n  // C++ objects with a user-declared constructor don't need zero'ing.\n  if (CGF.getLangOpts().CPlusPlus)\n    if (const RecordType *RT = CGF.getContext()\n                       .getBaseElementType(E->getType())->getAs<RecordType>()) {\n      const CXXRecordDecl *RD = cast<CXXRecordDecl>(RT->getDecl());\n      if (RD->hasUserDeclaredConstructor())\n        return;\n    }\n\n  // If the type is 16-bytes or smaller, prefer individual stores over memset.\n  CharUnits Size = Slot.getPreferredSize(CGF.getContext(), E->getType());\n  if (Size <= CharUnits::fromQuantity(16))\n    return;\n\n  // Check to see if over 3/4 of the initializer are known to be zero.  If so,\n  // we prefer to emit memset + individual stores for the rest.\n  CharUnits NumNonZeroBytes = GetNumNonZeroBytesInInit(E, CGF);\n  if (NumNonZeroBytes*4 > Size)\n    return;\n\n  // Okay, it seems like a good idea to use an initial memset, emit the call.\n  llvm::Constant *SizeVal = CGF.Builder.getInt64(Size.getQuantity());\n\n  Address Loc = Slot.getAddress();\n  Loc = CGF.Builder.CreateElementBitCast(Loc, CGF.Int8Ty);\n  CGF.Builder.CreateMemSet(Loc, CGF.Builder.getInt8(0), SizeVal, false);\n\n  // Tell the AggExprEmitter that the slot is known zero.\n  Slot.setZeroed();\n}\n\n\n\n\n/// EmitAggExpr - Emit the computation of the specified expression of aggregate\n/// type.  The result is computed into DestPtr.  Note that if DestPtr is null,\n/// the value of the aggregate expression is not needed.  If VolatileDest is\n/// true, DestPtr cannot be 0.\nvoid CodeGenFunction::EmitAggExpr(const Expr *E, AggValueSlot Slot) {\n  assert(E && hasAggregateEvaluationKind(E->getType()) &&\n         \"Invalid aggregate expression to emit\");\n  assert((Slot.getAddress().isValid() || Slot.isIgnored()) &&\n         \"slot has bits but no address\");\n\n  // Optimize the slot if possible.\n  CheckAggExprForMemSetUse(Slot, E, *this);\n\n  AggExprEmitter(*this, Slot, Slot.isIgnored()).Visit(const_cast<Expr*>(E));\n}\n\nLValue CodeGenFunction::EmitAggExprToLValue(const Expr *E) {\n  assert(hasAggregateEvaluationKind(E->getType()) && \"Invalid argument!\");\n  Address Temp = CreateMemTemp(E->getType());\n  LValue LV = MakeAddrLValue(Temp, E->getType());\n  EmitAggExpr(E, AggValueSlot::forLValue(\n                     LV, *this, AggValueSlot::IsNotDestructed,\n                     AggValueSlot::DoesNotNeedGCBarriers,\n                     AggValueSlot::IsNotAliased, AggValueSlot::DoesNotOverlap));\n  return LV;\n}\n\nAggValueSlot::Overlap_t\nCodeGenFunction::getOverlapForFieldInit(const FieldDecl *FD) {\n  if (!FD->hasAttr<NoUniqueAddressAttr>() || !FD->getType()->isRecordType())\n    return AggValueSlot::DoesNotOverlap;\n\n  // If the field lies entirely within the enclosing class's nvsize, its tail\n  // padding cannot overlap any already-initialized object. (The only subobjects\n  // with greater addresses that might already be initialized are vbases.)\n  const RecordDecl *ClassRD = FD->getParent();\n  const ASTRecordLayout &Layout = getContext().getASTRecordLayout(ClassRD);\n  if (Layout.getFieldOffset(FD->getFieldIndex()) +\n          getContext().getTypeSize(FD->getType()) <=\n      (uint64_t)getContext().toBits(Layout.getNonVirtualSize()))\n    return AggValueSlot::DoesNotOverlap;\n\n  // The tail padding may contain values we need to preserve.\n  return AggValueSlot::MayOverlap;\n}\n\nAggValueSlot::Overlap_t CodeGenFunction::getOverlapForBaseInit(\n    const CXXRecordDecl *RD, const CXXRecordDecl *BaseRD, bool IsVirtual) {\n  // If the most-derived object is a field declared with [[no_unique_address]],\n  // the tail padding of any virtual base could be reused for other subobjects\n  // of that field's class.\n  if (IsVirtual)\n    return AggValueSlot::MayOverlap;\n\n  // If the base class is laid out entirely within the nvsize of the derived\n  // class, its tail padding cannot yet be initialized, so we can issue\n  // stores at the full width of the base class.\n  const ASTRecordLayout &Layout = getContext().getASTRecordLayout(RD);\n  if (Layout.getBaseClassOffset(BaseRD) +\n          getContext().getASTRecordLayout(BaseRD).getSize() <=\n      Layout.getNonVirtualSize())\n    return AggValueSlot::DoesNotOverlap;\n\n  // The tail padding may contain values we need to preserve.\n  return AggValueSlot::MayOverlap;\n}\n\nvoid CodeGenFunction::EmitAggregateCopy(LValue Dest, LValue Src, QualType Ty,\n                                        AggValueSlot::Overlap_t MayOverlap,\n                                        bool isVolatile) {\n  assert(!Ty->isAnyComplexType() && \"Shouldn't happen for complex\");\n\n  Address DestPtr = Dest.getAddress(*this);\n  Address SrcPtr = Src.getAddress(*this);\n\n  if (getLangOpts().CPlusPlus) {\n    if (const RecordType *RT = Ty->getAs<RecordType>()) {\n      CXXRecordDecl *Record = cast<CXXRecordDecl>(RT->getDecl());\n      assert((Record->hasTrivialCopyConstructor() ||\n              Record->hasTrivialCopyAssignment() ||\n              Record->hasTrivialMoveConstructor() ||\n              Record->hasTrivialMoveAssignment() ||\n              Record->hasAttr<TrivialABIAttr>() || Record->isUnion()) &&\n             \"Trying to aggregate-copy a type without a trivial copy/move \"\n             \"constructor or assignment operator\");\n      // Ignore empty classes in C++.\n      if (Record->isEmpty())\n        return;\n    }\n  }\n\n  if (getLangOpts().CUDAIsDevice) {\n    if (Ty->isCUDADeviceBuiltinSurfaceType()) {\n      if (getTargetHooks().emitCUDADeviceBuiltinSurfaceDeviceCopy(*this, Dest,\n                                                                  Src))\n        return;\n    } else if (Ty->isCUDADeviceBuiltinTextureType()) {\n      if (getTargetHooks().emitCUDADeviceBuiltinTextureDeviceCopy(*this, Dest,\n                                                                  Src))\n        return;\n    }\n  }\n\n  // Aggregate assignment turns into llvm.memcpy.  This is almost valid per\n  // C99 6.5.16.1p3, which states \"If the value being stored in an object is\n  // read from another object that overlaps in anyway the storage of the first\n  // object, then the overlap shall be exact and the two objects shall have\n  // qualified or unqualified versions of a compatible type.\"\n  //\n  // memcpy is not defined if the source and destination pointers are exactly\n  // equal, but other compilers do this optimization, and almost every memcpy\n  // implementation handles this case safely.  If there is a libc that does not\n  // safely handle this, we can add a target hook.\n\n  // Get data size info for this aggregate. Don't copy the tail padding if this\n  // might be a potentially-overlapping subobject, since the tail padding might\n  // be occupied by a different object. Otherwise, copying it is fine.\n  TypeInfoChars TypeInfo;\n  if (MayOverlap)\n    TypeInfo = getContext().getTypeInfoDataSizeInChars(Ty);\n  else\n    TypeInfo = getContext().getTypeInfoInChars(Ty);\n\n  llvm::Value *SizeVal = nullptr;\n  if (TypeInfo.Width.isZero()) {\n    // But note that getTypeInfo returns 0 for a VLA.\n    if (auto *VAT = dyn_cast_or_null<VariableArrayType>(\n            getContext().getAsArrayType(Ty))) {\n      QualType BaseEltTy;\n      SizeVal = emitArrayLength(VAT, BaseEltTy, DestPtr);\n      TypeInfo = getContext().getTypeInfoInChars(BaseEltTy);\n      assert(!TypeInfo.Width.isZero());\n      SizeVal = Builder.CreateNUWMul(\n          SizeVal,\n          llvm::ConstantInt::get(SizeTy, TypeInfo.Width.getQuantity()));\n    }\n  }\n  if (!SizeVal) {\n    SizeVal = llvm::ConstantInt::get(SizeTy, TypeInfo.Width.getQuantity());\n  }\n\n  // FIXME: If we have a volatile struct, the optimizer can remove what might\n  // appear to be `extra' memory ops:\n  //\n  // volatile struct { int i; } a, b;\n  //\n  // int main() {\n  //   a = b;\n  //   a = b;\n  // }\n  //\n  // we need to use a different call here.  We use isVolatile to indicate when\n  // either the source or the destination is volatile.\n\n  DestPtr = Builder.CreateElementBitCast(DestPtr, Int8Ty);\n  SrcPtr = Builder.CreateElementBitCast(SrcPtr, Int8Ty);\n\n  // Don't do any of the memmove_collectable tests if GC isn't set.\n  if (CGM.getLangOpts().getGC() == LangOptions::NonGC) {\n    // fall through\n  } else if (const RecordType *RecordTy = Ty->getAs<RecordType>()) {\n    RecordDecl *Record = RecordTy->getDecl();\n    if (Record->hasObjectMember()) {\n      CGM.getObjCRuntime().EmitGCMemmoveCollectable(*this, DestPtr, SrcPtr,\n                                                    SizeVal);\n      return;\n    }\n  } else if (Ty->isArrayType()) {\n    QualType BaseType = getContext().getBaseElementType(Ty);\n    if (const RecordType *RecordTy = BaseType->getAs<RecordType>()) {\n      if (RecordTy->getDecl()->hasObjectMember()) {\n        CGM.getObjCRuntime().EmitGCMemmoveCollectable(*this, DestPtr, SrcPtr,\n                                                      SizeVal);\n        return;\n      }\n    }\n  }\n\n  auto Inst = Builder.CreateMemCpy(DestPtr, SrcPtr, SizeVal, isVolatile);\n\n  // Determine the metadata to describe the position of any padding in this\n  // memcpy, as well as the TBAA tags for the members of the struct, in case\n  // the optimizer wishes to expand it in to scalar memory operations.\n  if (llvm::MDNode *TBAAStructTag = CGM.getTBAAStructInfo(Ty))\n    Inst->setMetadata(llvm::LLVMContext::MD_tbaa_struct, TBAAStructTag);\n\n  if (CGM.getCodeGenOpts().NewStructPathTBAA) {\n    TBAAAccessInfo TBAAInfo = CGM.mergeTBAAInfoForMemoryTransfer(\n        Dest.getTBAAInfo(), Src.getTBAAInfo());\n    CGM.DecorateInstructionWithTBAA(Inst, TBAAInfo);\n  }\n}\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 1, "line": 175}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTContext.h", "reportHash": "c5e1d97cc499296db396dbcc098c1d82", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 965}, "message": "destructor '~CmpInstInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp", "reportHash": "0d03ef4898208d11489a9a14e1a03bb5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 965}, "message": "move constructor 'CmpInstInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp", "reportHash": "d66ef58a63bcf8fe4dd3ab5b701f0eb1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 41, "line": 971}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp", "reportHash": "1d51da4f0fdb5c6b9c8dbc1e7655b2d6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 41, "line": 1020}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp", "reportHash": "5d9c4e7a303d84113940af1f137999a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 41, "line": 1020}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp", "reportHash": "bbce599fcce9c325d52d2bacdae230a0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 41, "line": 1032}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp", "reportHash": "074d7744fa996d18661f348539f3e34c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 41, "line": 1032}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp", "reportHash": "3bc49876bc4abe744551f68b5645b77b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 41, "line": 1042}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp", "reportHash": "280e1835d5db965a90f25a0fc6ad8fbe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 41, "line": 1042}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp", "reportHash": "530602222d68b02a1851eec89e99df10", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 41, "line": 1630}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp", "reportHash": "a8273c27378a177ad44e4151955ec9ef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 41, "line": 1630}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp", "reportHash": "31f7cf64adc460076ad91581c33db2e4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
