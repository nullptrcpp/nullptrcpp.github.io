<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "content": "//===--- Protocol.h - Language Server Protocol Implementation ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains structs based on the LSP specification at\n// https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md\n//\n// This is not meant to be a complete implementation, new interfaces are added\n// when they're needed.\n//\n// Each struct has a toJSON and fromJSON function, that converts between\n// the struct and a JSON representation. (See JSON.h)\n//\n// Some structs also have operator<< serialization. This is for debugging and\n// tests, and is not generally machine-readable.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_PROTOCOL_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_PROTOCOL_H\n\n#include \"URI.h\"\n#include \"index/SymbolID.h\"\n#include \"support/MemoryTree.h\"\n#include \"clang/Index/IndexSymbol.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/JSON.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <bitset>\n#include <memory>\n#include <string>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\nenum class ErrorCode {\n  // Defined by JSON RPC.\n  ParseError = -32700,\n  InvalidRequest = -32600,\n  MethodNotFound = -32601,\n  InvalidParams = -32602,\n  InternalError = -32603,\n\n  ServerNotInitialized = -32002,\n  UnknownErrorCode = -32001,\n\n  // Defined by the protocol.\n  RequestCancelled = -32800,\n  ContentModified = -32801,\n};\n// Models an LSP error as an llvm::Error.\nclass LSPError : public llvm::ErrorInfo<LSPError> {\npublic:\n  std::string Message;\n  ErrorCode Code;\n  static char ID;\n\n  LSPError(std::string Message, ErrorCode Code)\n      : Message(std::move(Message)), Code(Code) {}\n\n  void log(llvm::raw_ostream &OS) const override {\n    OS << int(Code) << \": \" << Message;\n  }\n  std::error_code convertToErrorCode() const override {\n    return llvm::inconvertibleErrorCode();\n  }\n};\n\n// URI in \"file\" scheme for a file.\nstruct URIForFile {\n  URIForFile() = default;\n\n  /// Canonicalizes \\p AbsPath via URI.\n  ///\n  /// File paths in URIForFile can come from index or local AST. Path from\n  /// index goes through URI transformation, and the final path is resolved by\n  /// URI scheme and could potentially be different from the original path.\n  /// Hence, we do the same transformation for all paths.\n  ///\n  /// Files can be referred to by several paths (e.g. in the presence of links).\n  /// Which one we prefer may depend on where we're coming from. \\p TUPath is a\n  /// hint, and should usually be the main entrypoint file we're processing.\n  static URIForFile canonicalize(llvm::StringRef AbsPath,\n                                 llvm::StringRef TUPath);\n\n  static llvm::Expected<URIForFile> fromURI(const URI &U,\n                                            llvm::StringRef HintPath);\n\n  /// Retrieves absolute path to the file.\n  llvm::StringRef file() const { return File; }\n\n  explicit operator bool() const { return !File.empty(); }\n  std::string uri() const { return URI::createFile(File).toString(); }\n\n  friend bool operator==(const URIForFile &LHS, const URIForFile &RHS) {\n    return LHS.File == RHS.File;\n  }\n\n  friend bool operator!=(const URIForFile &LHS, const URIForFile &RHS) {\n    return !(LHS == RHS);\n  }\n\n  friend bool operator<(const URIForFile &LHS, const URIForFile &RHS) {\n    return LHS.File < RHS.File;\n  }\n\nprivate:\n  explicit URIForFile(std::string &&File) : File(std::move(File)) {}\n\n  std::string File;\n};\n\n/// Serialize/deserialize \\p URIForFile to/from a string URI.\nllvm::json::Value toJSON(const URIForFile &U);\nbool fromJSON(const llvm::json::Value &, URIForFile &, llvm::json::Path);\n\nstruct TextDocumentIdentifier {\n  /// The text document's URI.\n  URIForFile uri;\n};\nllvm::json::Value toJSON(const TextDocumentIdentifier &);\nbool fromJSON(const llvm::json::Value &, TextDocumentIdentifier &,\n              llvm::json::Path);\n\nstruct VersionedTextDocumentIdentifier : public TextDocumentIdentifier {\n  /// The version number of this document. If a versioned text document\n  /// identifier is sent from the server to the client and the file is not open\n  /// in the editor (the server has not received an open notification before)\n  /// the server can send `null` to indicate that the version is known and the\n  /// content on disk is the master (as speced with document content ownership).\n  ///\n  /// The version number of a document will increase after each change,\n  /// including undo/redo. The number doesn't need to be consecutive.\n  ///\n  /// clangd extension: versions are optional, and synthesized if missing.\n  llvm::Optional<std::int64_t> version;\n};\nllvm::json::Value toJSON(const VersionedTextDocumentIdentifier &);\nbool fromJSON(const llvm::json::Value &, VersionedTextDocumentIdentifier &,\n              llvm::json::Path);\n\nstruct Position {\n  /// Line position in a document (zero-based).\n  int line = 0;\n\n  /// Character offset on a line in a document (zero-based).\n  /// WARNING: this is in UTF-16 codepoints, not bytes or characters!\n  /// Use the functions in SourceCode.h to construct/interpret Positions.\n  int character = 0;\n\n  friend bool operator==(const Position &LHS, const Position &RHS) {\n    return std::tie(LHS.line, LHS.character) ==\n           std::tie(RHS.line, RHS.character);\n  }\n  friend bool operator!=(const Position &LHS, const Position &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator<(const Position &LHS, const Position &RHS) {\n    return std::tie(LHS.line, LHS.character) <\n           std::tie(RHS.line, RHS.character);\n  }\n  friend bool operator<=(const Position &LHS, const Position &RHS) {\n    return std::tie(LHS.line, LHS.character) <=\n           std::tie(RHS.line, RHS.character);\n  }\n};\nbool fromJSON(const llvm::json::Value &, Position &, llvm::json::Path);\nllvm::json::Value toJSON(const Position &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Position &);\n\nstruct Range {\n  /// The range's start position.\n  Position start;\n\n  /// The range's end position.\n  Position end;\n\n  friend bool operator==(const Range &LHS, const Range &RHS) {\n    return std::tie(LHS.start, LHS.end) == std::tie(RHS.start, RHS.end);\n  }\n  friend bool operator!=(const Range &LHS, const Range &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator<(const Range &LHS, const Range &RHS) {\n    return std::tie(LHS.start, LHS.end) < std::tie(RHS.start, RHS.end);\n  }\n\n  bool contains(Position Pos) const { return start <= Pos && Pos < end; }\n  bool contains(Range Rng) const {\n    return start <= Rng.start && Rng.end <= end;\n  }\n};\nbool fromJSON(const llvm::json::Value &, Range &, llvm::json::Path);\nllvm::json::Value toJSON(const Range &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Range &);\n\nstruct Location {\n  /// The text document's URI.\n  URIForFile uri;\n  Range range;\n\n  friend bool operator==(const Location &LHS, const Location &RHS) {\n    return LHS.uri == RHS.uri && LHS.range == RHS.range;\n  }\n\n  friend bool operator!=(const Location &LHS, const Location &RHS) {\n    return !(LHS == RHS);\n  }\n\n  friend bool operator<(const Location &LHS, const Location &RHS) {\n    return std::tie(LHS.uri, LHS.range) < std::tie(RHS.uri, RHS.range);\n  }\n};\nllvm::json::Value toJSON(const Location &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Location &);\n\nstruct TextEdit {\n  /// The range of the text document to be manipulated. To insert\n  /// text into a document create a range where start === end.\n  Range range;\n\n  /// The string to be inserted. For delete operations use an\n  /// empty string.\n  std::string newText;\n};\ninline bool operator==(const TextEdit &L, const TextEdit &R) {\n  return std::tie(L.newText, L.range) == std::tie(R.newText, R.range);\n}\nbool fromJSON(const llvm::json::Value &, TextEdit &, llvm::json::Path);\nllvm::json::Value toJSON(const TextEdit &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const TextEdit &);\n\nstruct TextDocumentItem {\n  /// The text document's URI.\n  URIForFile uri;\n\n  /// The text document's language identifier.\n  std::string languageId;\n\n  /// The version number of this document (it will strictly increase after each\n  /// change, including undo/redo.\n  ///\n  /// clangd extension: versions are optional, and synthesized if missing.\n  llvm::Optional<int64_t> version;\n\n  /// The content of the opened text document.\n  std::string text;\n};\nbool fromJSON(const llvm::json::Value &, TextDocumentItem &, llvm::json::Path);\n\nenum class TraceLevel {\n  Off = 0,\n  Messages = 1,\n  Verbose = 2,\n};\nbool fromJSON(const llvm::json::Value &E, TraceLevel &Out, llvm::json::Path);\n\nstruct NoParams {};\ninline llvm::json::Value toJSON(const NoParams &) { return nullptr; }\ninline bool fromJSON(const llvm::json::Value &, NoParams &, llvm::json::Path) {\n  return true;\n}\nusing InitializedParams = NoParams;\n\n/// Defines how the host (editor) should sync document changes to the language\n/// server.\nenum class TextDocumentSyncKind {\n  /// Documents should not be synced at all.\n  None = 0,\n\n  /// Documents are synced by always sending the full content of the document.\n  Full = 1,\n\n  /// Documents are synced by sending the full content on open.  After that\n  /// only incremental updates to the document are send.\n  Incremental = 2,\n};\n\n/// The kind of a completion entry.\nenum class CompletionItemKind {\n  Missing = 0,\n  Text = 1,\n  Method = 2,\n  Function = 3,\n  Constructor = 4,\n  Field = 5,\n  Variable = 6,\n  Class = 7,\n  Interface = 8,\n  Module = 9,\n  Property = 10,\n  Unit = 11,\n  Value = 12,\n  Enum = 13,\n  Keyword = 14,\n  Snippet = 15,\n  Color = 16,\n  File = 17,\n  Reference = 18,\n  Folder = 19,\n  EnumMember = 20,\n  Constant = 21,\n  Struct = 22,\n  Event = 23,\n  Operator = 24,\n  TypeParameter = 25,\n};\nbool fromJSON(const llvm::json::Value &, CompletionItemKind &,\n              llvm::json::Path);\nconstexpr auto CompletionItemKindMin =\n    static_cast<size_t>(CompletionItemKind::Text);\nconstexpr auto CompletionItemKindMax =\n    static_cast<size_t>(CompletionItemKind::TypeParameter);\nusing CompletionItemKindBitset = std::bitset<CompletionItemKindMax + 1>;\nbool fromJSON(const llvm::json::Value &, CompletionItemKindBitset &,\n              llvm::json::Path);\nCompletionItemKind\nadjustKindToCapability(CompletionItemKind Kind,\n                       CompletionItemKindBitset &SupportedCompletionItemKinds);\n\n/// A symbol kind.\nenum class SymbolKind {\n  File = 1,\n  Module = 2,\n  Namespace = 3,\n  Package = 4,\n  Class = 5,\n  Method = 6,\n  Property = 7,\n  Field = 8,\n  Constructor = 9,\n  Enum = 10,\n  Interface = 11,\n  Function = 12,\n  Variable = 13,\n  Constant = 14,\n  String = 15,\n  Number = 16,\n  Boolean = 17,\n  Array = 18,\n  Object = 19,\n  Key = 20,\n  Null = 21,\n  EnumMember = 22,\n  Struct = 23,\n  Event = 24,\n  Operator = 25,\n  TypeParameter = 26\n};\nbool fromJSON(const llvm::json::Value &, SymbolKind &, llvm::json::Path);\nconstexpr auto SymbolKindMin = static_cast<size_t>(SymbolKind::File);\nconstexpr auto SymbolKindMax = static_cast<size_t>(SymbolKind::TypeParameter);\nusing SymbolKindBitset = std::bitset<SymbolKindMax + 1>;\nbool fromJSON(const llvm::json::Value &, SymbolKindBitset &, llvm::json::Path);\nSymbolKind adjustKindToCapability(SymbolKind Kind,\n                                  SymbolKindBitset &supportedSymbolKinds);\n\n// Convert a index::SymbolKind to clangd::SymbolKind (LSP)\n// Note, some are not perfect matches and should be improved when this LSP\n// issue is addressed:\n// https://github.com/Microsoft/language-server-protocol/issues/344\nSymbolKind indexSymbolKindToSymbolKind(index::SymbolKind Kind);\n\n// Determines the encoding used to measure offsets and lengths of source in LSP.\nenum class OffsetEncoding {\n  // Any string is legal on the wire. Unrecognized encodings parse as this.\n  UnsupportedEncoding,\n  // Length counts code units of UTF-16 encoded text. (Standard LSP behavior).\n  UTF16,\n  // Length counts bytes of UTF-8 encoded text. (Clangd extension).\n  UTF8,\n  // Length counts codepoints in unicode text. (Clangd extension).\n  UTF32,\n};\nllvm::json::Value toJSON(const OffsetEncoding &);\nbool fromJSON(const llvm::json::Value &, OffsetEncoding &, llvm::json::Path);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, OffsetEncoding);\n\n// Describes the content type that a client supports in various result literals\n// like `Hover`, `ParameterInfo` or `CompletionItem`.\nenum class MarkupKind {\n  PlainText,\n  Markdown,\n};\nbool fromJSON(const llvm::json::Value &, MarkupKind &, llvm::json::Path);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, MarkupKind);\n\n// This struct doesn't mirror LSP!\n// The protocol defines deeply nested structures for client capabilities.\n// Instead of mapping them all, this just parses out the bits we care about.\nstruct ClientCapabilities {\n  /// The supported set of SymbolKinds for workspace/symbol.\n  /// workspace.symbol.symbolKind.valueSet\n  llvm::Optional<SymbolKindBitset> WorkspaceSymbolKinds;\n\n  /// Whether the client accepts diagnostics with codeActions attached inline.\n  /// textDocument.publishDiagnostics.codeActionsInline.\n  bool DiagnosticFixes = false;\n\n  /// Whether the client accepts diagnostics with related locations.\n  /// textDocument.publishDiagnostics.relatedInformation.\n  bool DiagnosticRelatedInformation = false;\n\n  /// Whether the client accepts diagnostics with category attached to it\n  /// using the \"category\" extension.\n  /// textDocument.publishDiagnostics.categorySupport\n  bool DiagnosticCategory = false;\n\n  /// Client supports snippets as insert text.\n  /// textDocument.completion.completionItem.snippetSupport\n  bool CompletionSnippets = false;\n\n  /// Client supports completions with additionalTextEdit near the cursor.\n  /// This is a clangd extension. (LSP says this is for unrelated text only).\n  /// textDocument.completion.editsNearCursor\n  bool CompletionFixes = false;\n\n  /// Client supports hierarchical document symbols.\n  /// textDocument.documentSymbol.hierarchicalDocumentSymbolSupport\n  bool HierarchicalDocumentSymbol = false;\n\n  /// Client supports signature help.\n  /// textDocument.signatureHelp\n  bool HasSignatureHelp = false;\n\n  /// Client supports processing label offsets instead of a simple label string.\n  /// textDocument.signatureHelp.signatureInformation.parameterInformation.labelOffsetSupport\n  bool OffsetsInSignatureHelp = false;\n\n  /// The supported set of CompletionItemKinds for textDocument/completion.\n  /// textDocument.completion.completionItemKind.valueSet\n  llvm::Optional<CompletionItemKindBitset> CompletionItemKinds;\n\n  /// The documentation format that should be used for textDocument/completion.\n  /// textDocument.completion.completionItem.documentationFormat\n  MarkupKind CompletionDocumentationFormat = MarkupKind::PlainText;\n\n  /// Client supports CodeAction return value for textDocument/codeAction.\n  /// textDocument.codeAction.codeActionLiteralSupport.\n  bool CodeActionStructure = false;\n\n  /// Client advertises support for the semanticTokens feature.\n  /// We support the textDocument/semanticTokens request in any case.\n  /// textDocument.semanticTokens\n  bool SemanticTokens = false;\n  /// Client supports Theia semantic highlighting extension.\n  /// https://github.com/microsoft/vscode-languageserver-node/pull/367\n  /// clangd no longer supports this, we detect it just to log a warning.\n  /// textDocument.semanticHighlightingCapabilities.semanticHighlighting\n  bool TheiaSemanticHighlighting = false;\n\n  /// Supported encodings for LSP character offsets. (clangd extension).\n  llvm::Optional<std::vector<OffsetEncoding>> offsetEncoding;\n\n  /// The content format that should be used for Hover requests.\n  /// textDocument.hover.contentEncoding\n  MarkupKind HoverContentFormat = MarkupKind::PlainText;\n\n  /// The client supports testing for validity of rename operations\n  /// before execution.\n  bool RenamePrepareSupport = false;\n\n  /// The client supports progress notifications.\n  /// window.workDoneProgress\n  bool WorkDoneProgress = false;\n\n  /// The client supports implicit $/progress work-done progress streams,\n  /// without a preceding window/workDoneProgress/create.\n  /// This is a clangd extension.\n  /// window.implicitWorkDoneProgressCreate\n  bool ImplicitProgressCreation = false;\n\n  /// Whether the client implementation supports a refresh request sent from the\n  /// server to the client.\n  bool SemanticTokenRefreshSupport = false;\n};\nbool fromJSON(const llvm::json::Value &, ClientCapabilities &,\n              llvm::json::Path);\n\n/// Clangd extension that's used in the 'compilationDatabaseChanges' in\n/// workspace/didChangeConfiguration to record updates to the in-memory\n/// compilation database.\nstruct ClangdCompileCommand {\n  std::string workingDirectory;\n  std::vector<std::string> compilationCommand;\n};\nbool fromJSON(const llvm::json::Value &, ClangdCompileCommand &,\n              llvm::json::Path);\n\n/// Clangd extension: parameters configurable at any time, via the\n/// `workspace/didChangeConfiguration` notification.\n/// LSP defines this type as `any`.\nstruct ConfigurationSettings {\n  // Changes to the in-memory compilation database.\n  // The key of the map is a file name.\n  std::map<std::string, ClangdCompileCommand> compilationDatabaseChanges;\n};\nbool fromJSON(const llvm::json::Value &, ConfigurationSettings &,\n              llvm::json::Path);\n\n/// Clangd extension: parameters configurable at `initialize` time.\n/// LSP defines this type as `any`.\nstruct InitializationOptions {\n  // What we can change throught the didChangeConfiguration request, we can\n  // also set through the initialize request (initializationOptions field).\n  ConfigurationSettings ConfigSettings;\n\n  llvm::Optional<std::string> compilationDatabasePath;\n  // Additional flags to be included in the \"fallback command\" used when\n  // the compilation database doesn't describe an opened file.\n  // The command used will be approximately `clang $FILE $fallbackFlags`.\n  std::vector<std::string> fallbackFlags;\n\n  /// Clients supports show file status for textDocument/clangd.fileStatus.\n  bool FileStatus = false;\n};\nbool fromJSON(const llvm::json::Value &, InitializationOptions &,\n              llvm::json::Path);\n\nstruct InitializeParams {\n  /// The process Id of the parent process that started\n  /// the server. Is null if the process has not been started by another\n  /// process. If the parent process is not alive then the server should exit\n  /// (see exit notification) its process.\n  llvm::Optional<int> processId;\n\n  /// The rootPath of the workspace. Is null\n  /// if no folder is open.\n  ///\n  /// @deprecated in favour of rootUri.\n  llvm::Optional<std::string> rootPath;\n\n  /// The rootUri of the workspace. Is null if no\n  /// folder is open. If both `rootPath` and `rootUri` are set\n  /// `rootUri` wins.\n  llvm::Optional<URIForFile> rootUri;\n\n  // User provided initialization options.\n  // initializationOptions?: any;\n\n  /// The capabilities provided by the client (editor or tool)\n  ClientCapabilities capabilities;\n  /// The same data as capabilities, but not parsed (to expose to modules).\n  llvm::json::Object rawCapabilities;\n\n  /// The initial trace setting. If omitted trace is disabled ('off').\n  llvm::Optional<TraceLevel> trace;\n\n  /// User-provided initialization options.\n  InitializationOptions initializationOptions;\n};\nbool fromJSON(const llvm::json::Value &, InitializeParams &, llvm::json::Path);\n\nstruct WorkDoneProgressCreateParams {\n  /// The token to be used to report progress.\n  llvm::json::Value token = nullptr;\n};\nllvm::json::Value toJSON(const WorkDoneProgressCreateParams &P);\n\ntemplate <typename T> struct ProgressParams {\n  /// The progress token provided by the client or server.\n  llvm::json::Value token = nullptr;\n\n  /// The progress data.\n  T value;\n};\ntemplate <typename T> llvm::json::Value toJSON(const ProgressParams<T> &P) {\n  return llvm::json::Object{{\"token\", P.token}, {\"value\", P.value}};\n}\n/// To start progress reporting a $/progress notification with the following\n/// payload must be sent.\nstruct WorkDoneProgressBegin {\n  /// Mandatory title of the progress operation. Used to briefly inform about\n  /// the kind of operation being performed.\n  ///\n  /// Examples: \"Indexing\" or \"Linking dependencies\".\n  std::string title;\n\n  /// Controls if a cancel button should show to allow the user to cancel the\n  /// long-running operation. Clients that don't support cancellation are\n  /// allowed to ignore the setting.\n  bool cancellable = false;\n\n  /// Optional progress percentage to display (value 100 is considered 100%).\n  /// If not provided infinite progress is assumed and clients are allowed\n  /// to ignore the `percentage` value in subsequent in report notifications.\n  ///\n  /// The value should be steadily rising. Clients are free to ignore values\n  /// that are not following this rule.\n  ///\n  /// Clangd implementation note: we only send nonzero percentages in\n  /// the WorkProgressReport. 'true' here means percentages will be used.\n  bool percentage = false;\n};\nllvm::json::Value toJSON(const WorkDoneProgressBegin &);\n\n/// Reporting progress is done using the following payload.\nstruct WorkDoneProgressReport {\n  /// Mandatory title of the progress operation. Used to briefly inform about\n  /// the kind of operation being performed.\n  ///\n  /// Examples: \"Indexing\" or \"Linking dependencies\".\n  std::string title;\n\n  /// Controls enablement state of a cancel button. This property is only valid\n  /// if a cancel button got requested in the `WorkDoneProgressStart` payload.\n  ///\n  /// Clients that don't support cancellation or don't support control\n  /// the button's enablement state are allowed to ignore the setting.\n  llvm::Optional<bool> cancellable;\n\n  /// Optional, more detailed associated progress message. Contains\n  /// complementary information to the `title`.\n  ///\n  /// Examples: \"3/25 files\", \"project/src/module2\", \"node_modules/some_dep\".\n  /// If unset, the previous progress message (if any) is still valid.\n  llvm::Optional<std::string> message;\n\n  /// Optional progress percentage to display (value 100 is considered 100%).\n  /// If not provided infinite progress is assumed and clients are allowed\n  /// to ignore the `percentage` value in subsequent in report notifications.\n  ///\n  /// The value should be steadily rising. Clients are free to ignore values\n  /// that are not following this rule.\n  llvm::Optional<double> percentage;\n};\nllvm::json::Value toJSON(const WorkDoneProgressReport &);\n//\n/// Signals the end of progress reporting.\nstruct WorkDoneProgressEnd {\n  /// Optional, a final message indicating to for example indicate the outcome\n  /// of the operation.\n  llvm::Optional<std::string> message;\n};\nllvm::json::Value toJSON(const WorkDoneProgressEnd &);\n\nenum class MessageType {\n  /// An error message.\n  Error = 1,\n  /// A warning message.\n  Warning = 2,\n  /// An information message.\n  Info = 3,\n  /// A log message.\n  Log = 4,\n};\nllvm::json::Value toJSON(const MessageType &);\n\n/// The show message notification is sent from a server to a client to ask the\n/// client to display a particular message in the user interface.\nstruct ShowMessageParams {\n  /// The message type.\n  MessageType type = MessageType::Info;\n  /// The actual message.\n  std::string message;\n};\nllvm::json::Value toJSON(const ShowMessageParams &);\n\nstruct DidOpenTextDocumentParams {\n  /// The document that was opened.\n  TextDocumentItem textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DidOpenTextDocumentParams &,\n              llvm::json::Path);\n\nstruct DidCloseTextDocumentParams {\n  /// The document that was closed.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DidCloseTextDocumentParams &,\n              llvm::json::Path);\n\nstruct DidSaveTextDocumentParams {\n  /// The document that was saved.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DidSaveTextDocumentParams &,\n              llvm::json::Path);\n\nstruct TextDocumentContentChangeEvent {\n  /// The range of the document that changed.\n  llvm::Optional<Range> range;\n\n  /// The length of the range that got replaced.\n  llvm::Optional<int> rangeLength;\n\n  /// The new text of the range/document.\n  std::string text;\n};\nbool fromJSON(const llvm::json::Value &, TextDocumentContentChangeEvent &,\n              llvm::json::Path);\n\nstruct DidChangeTextDocumentParams {\n  /// The document that did change. The version number points\n  /// to the version after all provided content changes have\n  /// been applied.\n  VersionedTextDocumentIdentifier textDocument;\n\n  /// The actual content changes.\n  std::vector<TextDocumentContentChangeEvent> contentChanges;\n\n  /// Forces diagnostics to be generated, or to not be generated, for this\n  /// version of the file. If not set, diagnostics are eventually consistent:\n  /// either they will be provided for this version or some subsequent one.\n  /// This is a clangd extension.\n  llvm::Optional<bool> wantDiagnostics;\n\n  /// Force a complete rebuild of the file, ignoring all cached state. Slow!\n  /// This is useful to defeat clangd's assumption that missing headers will\n  /// stay missing.\n  /// This is a clangd extension.\n  bool forceRebuild = false;\n};\nbool fromJSON(const llvm::json::Value &, DidChangeTextDocumentParams &,\n              llvm::json::Path);\n\nenum class FileChangeType {\n  /// The file got created.\n  Created = 1,\n  /// The file got changed.\n  Changed = 2,\n  /// The file got deleted.\n  Deleted = 3\n};\nbool fromJSON(const llvm::json::Value &E, FileChangeType &Out,\n              llvm::json::Path);\n\nstruct FileEvent {\n  /// The file's URI.\n  URIForFile uri;\n  /// The change type.\n  FileChangeType type = FileChangeType::Created;\n};\nbool fromJSON(const llvm::json::Value &, FileEvent &, llvm::json::Path);\n\nstruct DidChangeWatchedFilesParams {\n  /// The actual file events.\n  std::vector<FileEvent> changes;\n};\nbool fromJSON(const llvm::json::Value &, DidChangeWatchedFilesParams &,\n              llvm::json::Path);\n\nstruct DidChangeConfigurationParams {\n  ConfigurationSettings settings;\n};\nbool fromJSON(const llvm::json::Value &, DidChangeConfigurationParams &,\n              llvm::json::Path);\n\n// Note: we do not parse FormattingOptions for *FormattingParams.\n// In general, we use a clang-format style detected from common mechanisms\n// (.clang-format files and the -fallback-style flag).\n// It would be possible to override these with FormatOptions, but:\n//  - the protocol makes FormatOptions mandatory, so many clients set them to\n//    useless values, and we can't tell when to respect them\n// - we also format in other places, where FormatOptions aren't available.\n\nstruct DocumentRangeFormattingParams {\n  /// The document to format.\n  TextDocumentIdentifier textDocument;\n\n  /// The range to format\n  Range range;\n};\nbool fromJSON(const llvm::json::Value &, DocumentRangeFormattingParams &,\n              llvm::json::Path);\n\nstruct DocumentOnTypeFormattingParams {\n  /// The document to format.\n  TextDocumentIdentifier textDocument;\n\n  /// The position at which this request was sent.\n  Position position;\n\n  /// The character that has been typed.\n  std::string ch;\n};\nbool fromJSON(const llvm::json::Value &, DocumentOnTypeFormattingParams &,\n              llvm::json::Path);\n\nstruct DocumentFormattingParams {\n  /// The document to format.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DocumentFormattingParams &,\n              llvm::json::Path);\n\nstruct DocumentSymbolParams {\n  // The text document to find symbols in.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DocumentSymbolParams &,\n              llvm::json::Path);\n\n/// Represents a related message and source code location for a diagnostic.\n/// This should be used to point to code locations that cause or related to a\n/// diagnostics, e.g when duplicating a symbol in a scope.\nstruct DiagnosticRelatedInformation {\n  /// The location of this related diagnostic information.\n  Location location;\n  /// The message of this related diagnostic information.\n  std::string message;\n};\nllvm::json::Value toJSON(const DiagnosticRelatedInformation &);\n\nstruct CodeAction;\nstruct Diagnostic {\n  /// The range at which the message applies.\n  Range range;\n\n  /// The diagnostic's severity. Can be omitted. If omitted it is up to the\n  /// client to interpret diagnostics as error, warning, info or hint.\n  int severity = 0;\n\n  /// The diagnostic's code. Can be omitted.\n  std::string code;\n\n  /// A human-readable string describing the source of this\n  /// diagnostic, e.g. 'typescript' or 'super lint'.\n  std::string source;\n\n  /// The diagnostic's message.\n  std::string message;\n\n  /// An array of related diagnostic information, e.g. when symbol-names within\n  /// a scope collide all definitions can be marked via this property.\n  llvm::Optional<std::vector<DiagnosticRelatedInformation>> relatedInformation;\n\n  /// The diagnostic's category. Can be omitted.\n  /// An LSP extension that's used to send the name of the category over to the\n  /// client. The category typically describes the compilation stage during\n  /// which the issue was produced, e.g. \"Semantic Issue\" or \"Parse Issue\".\n  llvm::Optional<std::string> category;\n\n  /// Clangd extension: code actions related to this diagnostic.\n  /// Only with capability textDocument.publishDiagnostics.codeActionsInline.\n  /// (These actions can also be obtained using textDocument/codeAction).\n  llvm::Optional<std::vector<CodeAction>> codeActions;\n};\nllvm::json::Value toJSON(const Diagnostic &);\n\n/// A LSP-specific comparator used to find diagnostic in a container like\n/// std:map.\n/// We only use the required fields of Diagnostic to do the comparison to avoid\n/// any regression issues from LSP clients (e.g. VScode), see\n/// https://git.io/vbr29\nstruct LSPDiagnosticCompare {\n  bool operator()(const Diagnostic &LHS, const Diagnostic &RHS) const {\n    return std::tie(LHS.range, LHS.message) < std::tie(RHS.range, RHS.message);\n  }\n};\nbool fromJSON(const llvm::json::Value &, Diagnostic &, llvm::json::Path);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const Diagnostic &);\n\nstruct PublishDiagnosticsParams {\n  /// The URI for which diagnostic information is reported.\n  URIForFile uri;\n  /// An array of diagnostic information items.\n  std::vector<Diagnostic> diagnostics;\n  /// The version number of the document the diagnostics are published for.\n  llvm::Optional<int64_t> version;\n};\nllvm::json::Value toJSON(const PublishDiagnosticsParams &);\n\nstruct CodeActionContext {\n  /// An array of diagnostics known on the client side overlapping the range\n  /// provided to the `textDocument/codeAction` request. They are provided so\n  /// that the server knows which errors are currently presented to the user for\n  /// the given range. There is no guarantee that these accurately reflect the\n  /// error state of the resource. The primary parameter to compute code actions\n  /// is the provided range.\n  std::vector<Diagnostic> diagnostics;\n\n  /// Requested kind of actions to return.\n  ///\n  /// Actions not of this kind are filtered out by the client before being\n  /// shown. So servers can omit computing them.\n  std::vector<std::string> only;\n};\nbool fromJSON(const llvm::json::Value &, CodeActionContext &, llvm::json::Path);\n\nstruct CodeActionParams {\n  /// The document in which the command was invoked.\n  TextDocumentIdentifier textDocument;\n\n  /// The range for which the command was invoked.\n  Range range;\n\n  /// Context carrying additional information.\n  CodeActionContext context;\n};\nbool fromJSON(const llvm::json::Value &, CodeActionParams &, llvm::json::Path);\n\nstruct WorkspaceEdit {\n  /// Holds changes to existing resources.\n  llvm::Optional<std::map<std::string, std::vector<TextEdit>>> changes;\n\n  /// Note: \"documentChanges\" is not currently used because currently there is\n  /// no support for versioned edits.\n};\nbool fromJSON(const llvm::json::Value &, WorkspaceEdit &, llvm::json::Path);\nllvm::json::Value toJSON(const WorkspaceEdit &WE);\n\n/// Arguments for the 'applyTweak' command. The server sends these commands as a\n/// response to the textDocument/codeAction request. The client can later send a\n/// command back to the server if the user requests to execute a particular code\n/// tweak.\nstruct TweakArgs {\n  /// A file provided by the client on a textDocument/codeAction request.\n  URIForFile file;\n  /// A selection provided by the client on a textDocument/codeAction request.\n  Range selection;\n  /// ID of the tweak that should be executed. Corresponds to Tweak::id().\n  std::string tweakID;\n};\nbool fromJSON(const llvm::json::Value &, TweakArgs &, llvm::json::Path);\nllvm::json::Value toJSON(const TweakArgs &A);\n\nstruct ExecuteCommandParams {\n  /// The identifier of the actual command handler.\n  std::string command;\n\n  // This is `arguments?: []any` in LSP.\n  // All clangd's commands accept a single argument (or none => null).\n  llvm::json::Value argument = nullptr;\n};\nbool fromJSON(const llvm::json::Value &, ExecuteCommandParams &,\n              llvm::json::Path);\n\nstruct Command : public ExecuteCommandParams {\n  std::string title;\n};\nllvm::json::Value toJSON(const Command &C);\n\n/// A code action represents a change that can be performed in code, e.g. to fix\n/// a problem or to refactor code.\n///\n/// A CodeAction must set either `edit` and/or a `command`. If both are\n/// supplied, the `edit` is applied first, then the `command` is executed.\nstruct CodeAction {\n  /// A short, human-readable, title for this code action.\n  std::string title;\n\n  /// The kind of the code action.\n  /// Used to filter code actions.\n  llvm::Optional<std::string> kind;\n  const static llvm::StringLiteral QUICKFIX_KIND;\n  const static llvm::StringLiteral REFACTOR_KIND;\n  const static llvm::StringLiteral INFO_KIND;\n\n  /// The diagnostics that this code action resolves.\n  llvm::Optional<std::vector<Diagnostic>> diagnostics;\n\n  /// Marks this as a preferred action. Preferred actions are used by the\n  /// `auto fix` command and can be targeted by keybindings.\n  /// A quick fix should be marked preferred if it properly addresses the\n  /// underlying error. A refactoring should be marked preferred if it is the\n  /// most reasonable choice of actions to take.\n  bool isPreferred = false;\n\n  /// The workspace edit this code action performs.\n  llvm::Optional<WorkspaceEdit> edit;\n\n  /// A command this code action executes. If a code action provides an edit\n  /// and a command, first the edit is executed and then the command.\n  llvm::Optional<Command> command;\n};\nllvm::json::Value toJSON(const CodeAction &);\n\n/// Represents programming constructs like variables, classes, interfaces etc.\n/// that appear in a document. Document symbols can be hierarchical and they\n/// have two ranges: one that encloses its definition and one that points to its\n/// most interesting range, e.g. the range of an identifier.\nstruct DocumentSymbol {\n  /// The name of this symbol.\n  std::string name;\n\n  /// More detail for this symbol, e.g the signature of a function.\n  std::string detail;\n\n  /// The kind of this symbol.\n  SymbolKind kind;\n\n  /// Indicates if this symbol is deprecated.\n  bool deprecated = false;\n\n  /// The range enclosing this symbol not including leading/trailing whitespace\n  /// but everything else like comments. This information is typically used to\n  /// determine if the clients cursor is inside the symbol to reveal in the\n  /// symbol in the UI.\n  Range range;\n\n  /// The range that should be selected and revealed when this symbol is being\n  /// picked, e.g the name of a function. Must be contained by the `range`.\n  Range selectionRange;\n\n  /// Children of this symbol, e.g. properties of a class.\n  std::vector<DocumentSymbol> children;\n};\nllvm::raw_ostream &operator<<(llvm::raw_ostream &O, const DocumentSymbol &S);\nllvm::json::Value toJSON(const DocumentSymbol &S);\n\n/// Represents information about programming constructs like variables, classes,\n/// interfaces etc.\nstruct SymbolInformation {\n  /// The name of this symbol.\n  std::string name;\n\n  /// The kind of this symbol.\n  SymbolKind kind;\n\n  /// The location of this symbol.\n  Location location;\n\n  /// The name of the symbol containing this symbol.\n  std::string containerName;\n\n  /// The score that clangd calculates to rank the returned symbols.\n  /// This excludes the fuzzy-matching score between `name` and the query.\n  /// (Specifically, the last ::-separated component).\n  /// This can be used to re-rank results as the user types, using client-side\n  /// fuzzy-matching (that score should be multiplied with this one).\n  /// This is a clangd extension, set only for workspace/symbol responses.\n  llvm::Optional<float> score;\n};\nllvm::json::Value toJSON(const SymbolInformation &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const SymbolInformation &);\n\n/// Represents information about identifier.\n/// This is returned from textDocument/symbolInfo, which is a clangd extension.\nstruct SymbolDetails {\n  std::string name;\n\n  std::string containerName;\n\n  /// Unified Symbol Resolution identifier\n  /// This is an opaque string uniquely identifying a symbol.\n  /// Unlike SymbolID, it is variable-length and somewhat human-readable.\n  /// It is a common representation across several clang tools.\n  /// (See USRGeneration.h)\n  std::string USR;\n\n  SymbolID ID;\n};\nllvm::json::Value toJSON(const SymbolDetails &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const SymbolDetails &);\nbool operator==(const SymbolDetails &, const SymbolDetails &);\n\n/// The parameters of a Workspace Symbol Request.\nstruct WorkspaceSymbolParams {\n  /// A non-empty query string\n  std::string query;\n};\nbool fromJSON(const llvm::json::Value &, WorkspaceSymbolParams &,\n              llvm::json::Path);\n\nstruct ApplyWorkspaceEditParams {\n  WorkspaceEdit edit;\n};\nllvm::json::Value toJSON(const ApplyWorkspaceEditParams &);\n\nstruct ApplyWorkspaceEditResponse {\n  bool applied = true;\n  llvm::Optional<std::string> failureReason;\n};\nbool fromJSON(const llvm::json::Value &, ApplyWorkspaceEditResponse &,\n              llvm::json::Path);\n\nstruct TextDocumentPositionParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n\n  /// The position inside the text document.\n  Position position;\n};\nbool fromJSON(const llvm::json::Value &, TextDocumentPositionParams &,\n              llvm::json::Path);\n\nenum class CompletionTriggerKind {\n  /// Completion was triggered by typing an identifier (24x7 code\n  /// complete), manual invocation (e.g Ctrl+Space) or via API.\n  Invoked = 1,\n  /// Completion was triggered by a trigger character specified by\n  /// the `triggerCharacters` properties of the `CompletionRegistrationOptions`.\n  TriggerCharacter = 2,\n  /// Completion was re-triggered as the current completion list is incomplete.\n  TriggerTriggerForIncompleteCompletions = 3\n};\n\nstruct CompletionContext {\n  /// How the completion was triggered.\n  CompletionTriggerKind triggerKind = CompletionTriggerKind::Invoked;\n  /// The trigger character (a single character) that has trigger code complete.\n  /// Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter`\n  std::string triggerCharacter;\n};\nbool fromJSON(const llvm::json::Value &, CompletionContext &, llvm::json::Path);\n\nstruct CompletionParams : TextDocumentPositionParams {\n  CompletionContext context;\n};\nbool fromJSON(const llvm::json::Value &, CompletionParams &, llvm::json::Path);\n\nstruct MarkupContent {\n  MarkupKind kind = MarkupKind::PlainText;\n  std::string value;\n};\nllvm::json::Value toJSON(const MarkupContent &MC);\n\nstruct Hover {\n  /// The hover's content\n  MarkupContent contents;\n\n  /// An optional range is a range inside a text document\n  /// that is used to visualize a hover, e.g. by changing the background color.\n  llvm::Optional<Range> range;\n};\nllvm::json::Value toJSON(const Hover &H);\n\n/// Defines whether the insert text in a completion item should be interpreted\n/// as plain text or a snippet.\nenum class InsertTextFormat {\n  Missing = 0,\n  /// The primary text to be inserted is treated as a plain string.\n  PlainText = 1,\n  /// The primary text to be inserted is treated as a snippet.\n  ///\n  /// A snippet can define tab stops and placeholders with `$1`, `$2`\n  /// and `${3:foo}`. `$0` defines the final tab stop, it defaults to the end\n  /// of the snippet. Placeholders with equal identifiers are linked, that is\n  /// typing in one will update others too.\n  ///\n  /// See also:\n  /// https//github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md\n  Snippet = 2,\n};\n\nstruct CompletionItem {\n  /// The label of this completion item. By default also the text that is\n  /// inserted when selecting this completion.\n  std::string label;\n\n  /// The kind of this completion item. Based of the kind an icon is chosen by\n  /// the editor.\n  CompletionItemKind kind = CompletionItemKind::Missing;\n\n  /// A human-readable string with additional information about this item, like\n  /// type or symbol information.\n  std::string detail;\n\n  /// A human-readable string that represents a doc-comment.\n  llvm::Optional<MarkupContent> documentation;\n\n  /// A string that should be used when comparing this item with other items.\n  /// When `falsy` the label is used.\n  std::string sortText;\n\n  /// A string that should be used when filtering a set of completion items.\n  /// When `falsy` the label is used.\n  std::string filterText;\n\n  /// A string that should be inserted to a document when selecting this\n  /// completion. When `falsy` the label is used.\n  std::string insertText;\n\n  /// The format of the insert text. The format applies to both the `insertText`\n  /// property and the `newText` property of a provided `textEdit`.\n  InsertTextFormat insertTextFormat = InsertTextFormat::Missing;\n\n  /// An edit which is applied to a document when selecting this completion.\n  /// When an edit is provided `insertText` is ignored.\n  ///\n  /// Note: The range of the edit must be a single line range and it must\n  /// contain the position at which completion has been requested.\n  llvm::Optional<TextEdit> textEdit;\n\n  /// An optional array of additional text edits that are applied when selecting\n  /// this completion. Edits must not overlap with the main edit nor with\n  /// themselves.\n  std::vector<TextEdit> additionalTextEdits;\n\n  /// Indicates if this item is deprecated.\n  bool deprecated = false;\n\n  /// The score that clangd calculates to rank the returned completions.\n  /// This excludes the fuzzy-match between `filterText` and the partial word.\n  /// This can be used to re-rank results as the user types, using client-side\n  /// fuzzy-matching (that score should be multiplied with this one).\n  /// This is a clangd extension.\n  float score = 0.f;\n\n  // TODO: Add custom commitCharacters for some of the completion items. For\n  // example, it makes sense to use () only for the functions.\n  // TODO(krasimir): The following optional fields defined by the language\n  // server protocol are unsupported:\n  //\n  // data?: any - A data entry field that is preserved on a completion item\n  //              between a completion and a completion resolve request.\n};\nllvm::json::Value toJSON(const CompletionItem &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const CompletionItem &);\n\nbool operator<(const CompletionItem &, const CompletionItem &);\n\n/// Represents a collection of completion items to be presented in the editor.\nstruct CompletionList {\n  /// The list is not complete. Further typing should result in recomputing the\n  /// list.\n  bool isIncomplete = false;\n\n  /// The completion items.\n  std::vector<CompletionItem> items;\n};\nllvm::json::Value toJSON(const CompletionList &);\n\n/// A single parameter of a particular signature.\nstruct ParameterInformation {\n\n  /// The label of this parameter. Ignored when labelOffsets is set.\n  std::string labelString;\n\n  /// Inclusive start and exclusive end offsets withing the containing signature\n  /// label.\n  /// Offsets are computed by lspLength(), which counts UTF-16 code units by\n  /// default but that can be overriden, see its documentation for details.\n  llvm::Optional<std::pair<unsigned, unsigned>> labelOffsets;\n\n  /// The documentation of this parameter. Optional.\n  std::string documentation;\n};\nllvm::json::Value toJSON(const ParameterInformation &);\n\n/// Represents the signature of something callable.\nstruct SignatureInformation {\n\n  /// The label of this signature. Mandatory.\n  std::string label;\n\n  /// The documentation of this signature. Optional.\n  std::string documentation;\n\n  /// The parameters of this signature.\n  std::vector<ParameterInformation> parameters;\n};\nllvm::json::Value toJSON(const SignatureInformation &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &,\n                              const SignatureInformation &);\n\n/// Represents the signature of a callable.\nstruct SignatureHelp {\n\n  /// The resulting signatures.\n  std::vector<SignatureInformation> signatures;\n\n  /// The active signature.\n  int activeSignature = 0;\n\n  /// The active parameter of the active signature.\n  int activeParameter = 0;\n\n  /// Position of the start of the argument list, including opening paren. e.g.\n  /// foo(\"first arg\",   \"second arg\",\n  ///    ^-argListStart   ^-cursor\n  /// This is a clangd-specific extension, it is only available via C++ API and\n  /// not currently serialized for the LSP.\n  Position argListStart;\n};\nllvm::json::Value toJSON(const SignatureHelp &);\n\nstruct RenameParams {\n  /// The document that was opened.\n  TextDocumentIdentifier textDocument;\n\n  /// The position at which this request was sent.\n  Position position;\n\n  /// The new name of the symbol.\n  std::string newName;\n};\nbool fromJSON(const llvm::json::Value &, RenameParams &, llvm::json::Path);\n\nenum class DocumentHighlightKind { Text = 1, Read = 2, Write = 3 };\n\n/// A document highlight is a range inside a text document which deserves\n/// special attention. Usually a document highlight is visualized by changing\n/// the background color of its range.\n\nstruct DocumentHighlight {\n  /// The range this highlight applies to.\n  Range range;\n\n  /// The highlight kind, default is DocumentHighlightKind.Text.\n  DocumentHighlightKind kind = DocumentHighlightKind::Text;\n\n  friend bool operator<(const DocumentHighlight &LHS,\n                        const DocumentHighlight &RHS) {\n    int LHSKind = static_cast<int>(LHS.kind);\n    int RHSKind = static_cast<int>(RHS.kind);\n    return std::tie(LHS.range, LHSKind) < std::tie(RHS.range, RHSKind);\n  }\n\n  friend bool operator==(const DocumentHighlight &LHS,\n                         const DocumentHighlight &RHS) {\n    return LHS.kind == RHS.kind && LHS.range == RHS.range;\n  }\n};\nllvm::json::Value toJSON(const DocumentHighlight &DH);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const DocumentHighlight &);\n\nenum class TypeHierarchyDirection { Children = 0, Parents = 1, Both = 2 };\nbool fromJSON(const llvm::json::Value &E, TypeHierarchyDirection &Out,\n              llvm::json::Path);\n\n/// The type hierarchy params is an extension of the\n/// `TextDocumentPositionsParams` with optional properties which can be used to\n/// eagerly resolve the item when requesting from the server.\nstruct TypeHierarchyParams : public TextDocumentPositionParams {\n  /// The hierarchy levels to resolve. `0` indicates no level.\n  int resolve = 0;\n\n  /// The direction of the hierarchy levels to resolve.\n  TypeHierarchyDirection direction = TypeHierarchyDirection::Parents;\n};\nbool fromJSON(const llvm::json::Value &, TypeHierarchyParams &,\n              llvm::json::Path);\n\nstruct TypeHierarchyItem {\n  /// The human readable name of the hierarchy item.\n  std::string name;\n\n  /// Optional detail for the hierarchy item. It can be, for instance, the\n  /// signature of a function or method.\n  llvm::Optional<std::string> detail;\n\n  /// The kind of the hierarchy item. For instance, class or interface.\n  SymbolKind kind;\n\n  /// `true` if the hierarchy item is deprecated. Otherwise, `false`.\n  bool deprecated = false;\n\n  /// The URI of the text document where this type hierarchy item belongs to.\n  URIForFile uri;\n\n  /// The range enclosing this type hierarchy item not including\n  /// leading/trailing whitespace but everything else like comments. This\n  /// information is typically used to determine if the client's cursor is\n  /// inside the type hierarch item to reveal in the symbol in the UI.\n  Range range;\n\n  /// The range that should be selected and revealed when this type hierarchy\n  /// item is being picked, e.g. the name of a function. Must be contained by\n  /// the `range`.\n  Range selectionRange;\n\n  /// If this type hierarchy item is resolved, it contains the direct parents.\n  /// Could be empty if the item does not have direct parents. If not defined,\n  /// the parents have not been resolved yet.\n  llvm::Optional<std::vector<TypeHierarchyItem>> parents;\n\n  /// If this type hierarchy item is resolved, it contains the direct children\n  /// of the current item. Could be empty if the item does not have any\n  /// descendants. If not defined, the children have not been resolved.\n  llvm::Optional<std::vector<TypeHierarchyItem>> children;\n\n  /// An optional 'data' field, which can be used to identify a type hierarchy\n  /// item in a resolve request.\n  llvm::Optional<std::string> data;\n};\nllvm::json::Value toJSON(const TypeHierarchyItem &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const TypeHierarchyItem &);\nbool fromJSON(const llvm::json::Value &, TypeHierarchyItem &, llvm::json::Path);\n\n/// Parameters for the `typeHierarchy/resolve` request.\nstruct ResolveTypeHierarchyItemParams {\n  /// The item to resolve.\n  TypeHierarchyItem item;\n\n  /// The hierarchy levels to resolve. `0` indicates no level.\n  int resolve;\n\n  /// The direction of the hierarchy levels to resolve.\n  TypeHierarchyDirection direction;\n};\nbool fromJSON(const llvm::json::Value &, ResolveTypeHierarchyItemParams &,\n              llvm::json::Path);\n\nenum class SymbolTag { Deprecated = 1 };\nllvm::json::Value toJSON(SymbolTag);\n\n/// The parameter of a `textDocument/prepareCallHierarchy` request.\nstruct CallHierarchyPrepareParams : public TextDocumentPositionParams {};\n\n/// Represents programming constructs like functions or constructors\n/// in the context of call hierarchy.\nstruct CallHierarchyItem {\n  /// The name of this item.\n  std::string name;\n\n  /// The kind of this item.\n  SymbolKind kind;\n\n  /// Tags for this item.\n  std::vector<SymbolTag> tags;\n\n  /// More detaill for this item, e.g. the signature of a function.\n  std::string detail;\n\n  /// The resource identifier of this item.\n  URIForFile uri;\n\n  /// The range enclosing this symbol not including leading / trailing\n  /// whitespace but everything else, e.g. comments and code.\n  Range range;\n\n  /// The range that should be selected and revealed when this symbol\n  /// is being picked, e.g. the name of a function.\n  /// Must be contained by `Rng`.\n  Range selectionRange;\n\n  /// An optional 'data' field, which can be used to identify a call\n  /// hierarchy item in an incomingCalls or outgoingCalls request.\n  std::string data;\n};\nllvm::json::Value toJSON(const CallHierarchyItem &);\nbool fromJSON(const llvm::json::Value &, CallHierarchyItem &, llvm::json::Path);\n\n/// The parameter of a `callHierarchy/incomingCalls` request.\nstruct CallHierarchyIncomingCallsParams {\n  CallHierarchyItem item;\n};\nbool fromJSON(const llvm::json::Value &, CallHierarchyIncomingCallsParams &,\n              llvm::json::Path);\n\n/// Represents an incoming call, e.g. a caller of a method or constructor.\nstruct CallHierarchyIncomingCall {\n  /// The item that makes the call.\n  CallHierarchyItem from;\n\n  /// The range at which the calls appear.\n  /// This is relative to the caller denoted by `From`.\n  std::vector<Range> fromRanges;\n};\nllvm::json::Value toJSON(const CallHierarchyIncomingCall &);\n\n/// The parameter of a `callHierarchy/outgoingCalls` request.\nstruct CallHierarchyOutgoingCallsParams {\n  CallHierarchyItem item;\n};\nbool fromJSON(const llvm::json::Value &, CallHierarchyOutgoingCallsParams &,\n              llvm::json::Path);\n\n/// Represents an outgoing call, e.g. calling a getter from a method or\n/// a method from a constructor etc.\nstruct CallHierarchyOutgoingCall {\n  /// The item that is called.\n  CallHierarchyItem to;\n\n  /// The range at which this item is called.\n  /// This is the range relative to the caller, and not `To`.\n  std::vector<Range> fromRanges;\n};\nllvm::json::Value toJSON(const CallHierarchyOutgoingCall &);\n\nstruct ReferenceContext {\n  /// Include the declaration of the current symbol.\n  bool includeDeclaration = false;\n};\n\nstruct ReferenceParams : public TextDocumentPositionParams {\n  ReferenceContext context;\n};\nbool fromJSON(const llvm::json::Value &, ReferenceParams &, llvm::json::Path);\n\n/// Clangd extension: indicates the current state of the file in clangd,\n/// sent from server via the `textDocument/clangd.fileStatus` notification.\nstruct FileStatus {\n  /// The text document's URI.\n  URIForFile uri;\n  /// The human-readable string presents the current state of the file, can be\n  /// shown in the UI (e.g. status bar).\n  std::string state;\n  // FIXME: add detail messages.\n};\nllvm::json::Value toJSON(const FileStatus &);\n\n/// Specifies a single semantic token in the document.\n/// This struct is not part of LSP, which just encodes lists of tokens as\n/// arrays of numbers directly.\nstruct SemanticToken {\n  /// token line number, relative to the previous token\n  unsigned deltaLine = 0;\n  /// token start character, relative to the previous token\n  /// (relative to 0 or the previous token's start if they are on the same line)\n  unsigned deltaStart = 0;\n  /// the length of the token. A token cannot be multiline\n  unsigned length = 0;\n  /// will be looked up in `SemanticTokensLegend.tokenTypes`\n  unsigned tokenType = 0;\n  /// each set bit will be looked up in `SemanticTokensLegend.tokenModifiers`\n  unsigned tokenModifiers = 0;\n};\nbool operator==(const SemanticToken &, const SemanticToken &);\n\n/// A versioned set of tokens.\nstruct SemanticTokens {\n  // An optional result id. If provided and clients support delta updating\n  // the client will include the result id in the next semantic token request.\n  // A server can then instead of computing all semantic tokens again simply\n  // send a delta.\n  std::string resultId;\n\n  /// The actual tokens.\n  std::vector<SemanticToken> tokens; // encoded as a flat integer array.\n};\nllvm::json::Value toJSON(const SemanticTokens &);\n\n/// Body of textDocument/semanticTokens/full request.\nstruct SemanticTokensParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, SemanticTokensParams &,\n              llvm::json::Path);\n\n/// Body of textDocument/semanticTokens/full/delta request.\n/// Requests the changes in semantic tokens since a previous response.\nstruct SemanticTokensDeltaParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n  /// The previous result id.\n  std::string previousResultId;\n};\nbool fromJSON(const llvm::json::Value &Params, SemanticTokensDeltaParams &R,\n              llvm::json::Path);\n\n/// Describes a a replacement of a contiguous range of semanticTokens.\nstruct SemanticTokensEdit {\n  // LSP specifies `start` and `deleteCount` which are relative to the array\n  // encoding of the previous tokens.\n  // We use token counts instead, and translate when serializing this struct.\n  unsigned startToken = 0;\n  unsigned deleteTokens = 0;\n  std::vector<SemanticToken> tokens; // encoded as a flat integer array\n};\nllvm::json::Value toJSON(const SemanticTokensEdit &);\n\n/// This models LSP SemanticTokensDelta | SemanticTokens, which is the result of\n/// textDocument/semanticTokens/full/delta.\nstruct SemanticTokensOrDelta {\n  std::string resultId;\n  /// Set if we computed edits relative to a previous set of tokens.\n  llvm::Optional<std::vector<SemanticTokensEdit>> edits;\n  /// Set if we computed a fresh set of tokens.\n  llvm::Optional<std::vector<SemanticToken>> tokens; // encoded as integer array\n};\nllvm::json::Value toJSON(const SemanticTokensOrDelta &);\n\nstruct SelectionRangeParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n\n  /// The positions inside the text document.\n  std::vector<Position> positions;\n};\nbool fromJSON(const llvm::json::Value &, SelectionRangeParams &,\n              llvm::json::Path);\n\nstruct SelectionRange {\n  /**\n   * The range of this selection range.\n   */\n  Range range;\n  /**\n   * The parent selection range containing this range. Therefore `parent.range`\n   * must contain `this.range`.\n   */\n  std::unique_ptr<SelectionRange> parent;\n};\nllvm::json::Value toJSON(const SelectionRange &);\n\n/// Parameters for the document link request.\nstruct DocumentLinkParams {\n  /// The document to provide document links for.\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, DocumentLinkParams &,\n              llvm::json::Path);\n\n/// A range in a text document that links to an internal or external resource,\n/// like another text document or a web site.\nstruct DocumentLink {\n  /// The range this link applies to.\n  Range range;\n\n  /// The uri this link points to. If missing a resolve request is sent later.\n  URIForFile target;\n\n  // TODO(forster): The following optional fields defined by the language\n  // server protocol are unsupported:\n  //\n  // data?: any - A data entry field that is preserved on a document link\n  //              between a DocumentLinkRequest and a\n  //              DocumentLinkResolveRequest.\n\n  friend bool operator==(const DocumentLink &LHS, const DocumentLink &RHS) {\n    return LHS.range == RHS.range && LHS.target == RHS.target;\n  }\n\n  friend bool operator!=(const DocumentLink &LHS, const DocumentLink &RHS) {\n    return !(LHS == RHS);\n  }\n};\nllvm::json::Value toJSON(const DocumentLink &DocumentLink);\n\n// FIXME(kirillbobyrev): Add FoldingRangeClientCapabilities so we can support\n// per-line-folding editors.\nstruct FoldingRangeParams {\n  TextDocumentIdentifier textDocument;\n};\nbool fromJSON(const llvm::json::Value &, FoldingRangeParams &,\n              llvm::json::Path);\n\n/// Stores information about a region of code that can be folded.\nstruct FoldingRange {\n  unsigned startLine = 0;\n  unsigned startCharacter;\n  unsigned endLine = 0;\n  unsigned endCharacter;\n  llvm::Optional<std::string> kind;\n};\nllvm::json::Value toJSON(const FoldingRange &Range);\n\n/// Keys starting with an underscore(_) represent leaves, e.g. _total or _self\n/// for memory usage of whole subtree or only that specific node in bytes. All\n/// other keys represents children. An example:\n///   {\n///     \"_self\": 0,\n///     \"_total\": 8,\n///     \"child1\": {\n///       \"_self\": 4,\n///       \"_total\": 4,\n///     }\n///     \"child2\": {\n///       \"_self\": 2,\n///       \"_total\": 4,\n///       \"child_deep\": {\n///         \"_self\": 2,\n///         \"_total\": 2,\n///       }\n///     }\n///   }\nllvm::json::Value toJSON(const MemoryTree &MT);\n\n/// Payload for textDocument/ast request.\n/// This request is a clangd extension.\nstruct ASTParams {\n  /// The text document.\n  TextDocumentIdentifier textDocument;\n\n  /// The position of the node to be dumped.\n  /// The highest-level node that entirely contains the range will be returned.\n  Range range;\n};\nbool fromJSON(const llvm::json::Value &, ASTParams &, llvm::json::Path);\n\n/// Simplified description of a clang AST node.\n/// This is clangd's internal representation of C++ code.\nstruct ASTNode {\n  /// The general kind of node, such as \"expression\"\n  /// Corresponds to the base AST node type such as Expr.\n  std::string role;\n  /// The specific kind of node this is, such as \"BinaryOperator\".\n  /// This is usually a concrete node class (with Expr etc suffix dropped).\n  /// When there's no hierarchy (e.g. TemplateName), the variant (NameKind).\n  std::string kind;\n  /// Brief additional information, such as \"||\" for the particular operator.\n  /// The information included depends on the node kind, and may be empty.\n  std::string detail;\n  /// A one-line dump of detailed information about the node.\n  /// This includes role/kind/description information, but is rather cryptic.\n  /// It is similar to the output from `clang -Xclang -ast-dump`.\n  /// May be empty for certain types of nodes.\n  std::string arcana;\n  /// The range of the original source file covered by this node.\n  /// May be missing for implicit nodes, or those created by macro expansion.\n  llvm::Optional<Range> range;\n  /// Nodes nested within this one, such as the operands of a BinaryOperator.\n  std::vector<ASTNode> children;\n};\nllvm::json::Value toJSON(const ASTNode &);\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const ASTNode &);\n\n} // namespace clangd\n} // namespace clang\n\nnamespace llvm {\ntemplate <> struct format_provider<clang::clangd::Position> {\n  static void format(const clang::clangd::Position &Pos, raw_ostream &OS,\n                     StringRef Style) {\n    assert(Style.empty() && \"style modifiers for this type are not supported\");\n    OS << Pos;\n  }\n};\n} // namespace llvm\n\n#endif\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "content": "//===--- TUScheduler.cpp -----------------------------------------*-C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// TUScheduler manages a worker per active file. This ASTWorker processes\n// updates (modifications to file contents) and reads (actions performed on\n// preamble/AST) to the file.\n//\n// Each ASTWorker owns a dedicated thread to process updates and reads to the\n// relevant file. Any request gets queued in FIFO order to be processed by that\n// thread.\n//\n// An update request replaces current praser inputs to ensure any subsequent\n// read sees the version of the file they were requested. It will also issue a\n// build for new inputs.\n//\n// ASTWorker processes the file in two parts, a preamble and a main-file\n// section. A preamble can be reused between multiple versions of the file until\n// invalidated by a modification to a header, compile commands or modification\n// to relevant part of the current file. Such a preamble is called compatible.\n// An update is considered dead if no read was issued for that version and\n// diagnostics weren't requested by client or could be generated for a later\n// version of the file. ASTWorker eliminates such requests as they are\n// redundant.\n//\n// In the presence of stale (non-compatible) preambles, ASTWorker won't publish\n// diagnostics for update requests. Read requests will be served with ASTs build\n// with stale preambles, unless the read is picky and requires a compatible\n// preamble. In such cases it will block until new preamble is built.\n//\n// ASTWorker owns a PreambleThread for building preambles. If the preamble gets\n// invalidated by an update request, a new build will be requested on\n// PreambleThread. Since PreambleThread only receives requests for newer\n// versions of the file, in case of multiple requests it will only build the\n// last one and skip requests in between. Unless client force requested\n// diagnostics(WantDiagnostics::Yes).\n//\n// When a new preamble is built, a \"golden\" AST is immediately built from that\n// version of the file. This ensures diagnostics get updated even if the queue\n// is full.\n//\n// Some read requests might just need preamble. Since preambles can be read\n// concurrently, ASTWorker runs these requests on their own thread. These\n// requests will receive latest build preamble, which might possibly be stale.\n\n#include \"TUScheduler.h\"\n#include \"Compiler.h\"\n#include \"Diagnostics.h\"\n#include \"GlobalCompilationDatabase.h\"\n#include \"ParsedAST.h\"\n#include \"Preamble.h\"\n#include \"index/CanonicalIncludes.h\"\n#include \"support/Cancellation.h\"\n#include \"support/Context.h\"\n#include \"support/Logger.h\"\n#include \"support/MemoryTree.h\"\n#include \"support/Path.h\"\n#include \"support/Threading.h\"\n#include \"support/Trace.h\"\n#include \"clang/Frontend/CompilerInvocation.h\"\n#include \"clang/Tooling/CompilationDatabase.h\"\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/ScopeExit.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Errc.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/Threading.h\"\n#include <algorithm>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <functional>\n#include <memory>\n#include <mutex>\n#include <queue>\n#include <string>\n#include <thread>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\nusing std::chrono::steady_clock;\n\nnamespace {\nclass ASTWorker;\n} // namespace\n\nstatic clang::clangd::Key<std::string> kFileBeingProcessed;\n\nllvm::Optional<llvm::StringRef> TUScheduler::getFileBeingProcessedInContext() {\n  if (auto *File = Context::current().get(kFileBeingProcessed))\n    return llvm::StringRef(*File);\n  return None;\n}\n\n/// An LRU cache of idle ASTs.\n/// Because we want to limit the overall number of these we retain, the cache\n/// owns ASTs (and may evict them) while their workers are idle.\n/// Workers borrow ASTs when active, and return them when done.\nclass TUScheduler::ASTCache {\npublic:\n  using Key = const ASTWorker *;\n\n  ASTCache(unsigned MaxRetainedASTs) : MaxRetainedASTs(MaxRetainedASTs) {}\n\n  /// Returns result of getUsedBytes() for the AST cached by \\p K.\n  /// If no AST is cached, 0 is returned.\n  std::size_t getUsedBytes(Key K) {\n    std::lock_guard<std::mutex> Lock(Mut);\n    auto It = findByKey(K);\n    if (It == LRU.end() || !It->second)\n      return 0;\n    return It->second->getUsedBytes();\n  }\n\n  /// Store the value in the pool, possibly removing the last used AST.\n  /// The value should not be in the pool when this function is called.\n  void put(Key K, std::unique_ptr<ParsedAST> V) {\n    std::unique_lock<std::mutex> Lock(Mut);\n    assert(findByKey(K) == LRU.end());\n\n    LRU.insert(LRU.begin(), {K, std::move(V)});\n    if (LRU.size() <= MaxRetainedASTs)\n      return;\n    // We're past the limit, remove the last element.\n    std::unique_ptr<ParsedAST> ForCleanup = std::move(LRU.back().second);\n    LRU.pop_back();\n    // Run the expensive destructor outside the lock.\n    Lock.unlock();\n    ForCleanup.reset();\n  }\n\n  /// Returns the cached value for \\p K, or llvm::None if the value is not in\n  /// the cache anymore. If nullptr was cached for \\p K, this function will\n  /// return a null unique_ptr wrapped into an optional.\n  /// If \\p AccessMetric is set records whether there was a hit or miss.\n  llvm::Optional<std::unique_ptr<ParsedAST>>\n  take(Key K, const trace::Metric *AccessMetric = nullptr) {\n    // Record metric after unlocking the mutex.\n    std::unique_lock<std::mutex> Lock(Mut);\n    auto Existing = findByKey(K);\n    if (Existing == LRU.end()) {\n      if (AccessMetric)\n        AccessMetric->record(1, \"miss\");\n      return None;\n    }\n    if (AccessMetric)\n      AccessMetric->record(1, \"hit\");\n    std::unique_ptr<ParsedAST> V = std::move(Existing->second);\n    LRU.erase(Existing);\n    // GCC 4.8 fails to compile `return V;`, as it tries to call the copy\n    // constructor of unique_ptr, so we call the move ctor explicitly to avoid\n    // this miscompile.\n    return llvm::Optional<std::unique_ptr<ParsedAST>>(std::move(V));\n  }\n\nprivate:\n  using KVPair = std::pair<Key, std::unique_ptr<ParsedAST>>;\n\n  std::vector<KVPair>::iterator findByKey(Key K) {\n    return llvm::find_if(LRU, [K](const KVPair &P) { return P.first == K; });\n  }\n\n  std::mutex Mut;\n  unsigned MaxRetainedASTs;\n  /// Items sorted in LRU order, i.e. first item is the most recently accessed\n  /// one.\n  std::vector<KVPair> LRU; /* GUARDED_BY(Mut) */\n};\n\n/// A map from header files to an opened \"proxy\" file that includes them.\n/// If you open the header, the compile command from the proxy file is used.\n///\n/// This inclusion information could also naturally live in the index, but there\n/// are advantages to using open files instead:\n///  - it's easier to achieve a *stable* choice of proxy, which is important\n///    to avoid invalidating the preamble\n///  - context-sensitive flags for libraries with multiple configurations\n///    (e.g. C++ stdlib sensitivity to -std version)\n///  - predictable behavior, e.g. guarantees that go-to-def landing on a header\n///    will have a suitable command available\n///  - fewer scaling problems to solve (project include graphs are big!)\n///\n/// Implementation details:\n/// - We only record this for mainfiles where the command was trustworthy\n///   (i.e. not inferred). This avoids a bad inference \"infecting\" other files.\n/// - Once we've picked a proxy file for a header, we stick with it until the\n///   proxy file is invalidated *and* a new candidate proxy file is built.\n///   Switching proxies is expensive, as the compile flags will (probably)\n///   change and therefore we'll end up rebuilding the header's preamble.\n/// - We don't capture the actual compile command, but just the filename we\n///   should query to get it. This avoids getting out of sync with the CDB.\n///\n/// All methods are threadsafe. In practice, update() comes from preamble\n/// threads, remove()s mostly from the main thread, and get() from ASTWorker.\n/// Writes are rare and reads are cheap, so we don't expect much contention.\nclass TUScheduler::HeaderIncluderCache {\n  // We should be be a little careful how we store the include graph of open\n  // files, as each can have a large number of transitive headers.\n  // This representation is O(unique transitive source files).\n  llvm::BumpPtrAllocator Arena;\n  struct Association {\n    llvm::StringRef MainFile;\n    // Circular-linked-list of associations with the same mainFile.\n    // Null indicates that the mainfile was removed.\n    Association *Next;\n  };\n  llvm::StringMap<Association, llvm::BumpPtrAllocator &> HeaderToMain;\n  llvm::StringMap<Association *, llvm::BumpPtrAllocator &> MainToFirst;\n  std::atomic<size_t> UsedBytes; // Updated after writes.\n  mutable std::mutex Mu;\n\n  void invalidate(Association *First) {\n    Association *Current = First;\n    do {\n      Association *Next = Current->Next;\n      Current->Next = nullptr;\n      Current = Next;\n    } while (Current != First);\n  }\n\n  // Create the circular list and return the head of it.\n  Association *associate(llvm::StringRef MainFile,\n                         llvm::ArrayRef<std::string> Headers) {\n    Association *First = nullptr, *Prev = nullptr;\n    for (const std::string &Header : Headers) {\n      auto &Assoc = HeaderToMain[Header];\n      if (Assoc.Next)\n        continue; // Already has a valid association.\n\n      Assoc.MainFile = MainFile;\n      Assoc.Next = Prev;\n      Prev = &Assoc;\n      if (!First)\n        First = &Assoc;\n    }\n    if (First)\n      First->Next = Prev;\n    return First;\n  }\n\n  void updateMemoryUsage() {\n    auto StringMapHeap = [](const auto &Map) {\n      // StringMap stores the hashtable on the heap.\n      // It contains pointers to the entries, and a hashcode for each.\n      return Map.getNumBuckets() * (sizeof(void *) + sizeof(unsigned));\n    };\n    size_t Usage = Arena.getTotalMemory() + StringMapHeap(MainToFirst) +\n                   StringMapHeap(HeaderToMain) + sizeof(*this);\n    UsedBytes.store(Usage, std::memory_order_release);\n  }\n\npublic:\n  HeaderIncluderCache() : HeaderToMain(Arena), MainToFirst(Arena) {\n    updateMemoryUsage();\n  }\n\n  // Associate each header with MainFile (unless already associated).\n  // Headers not in the list will have their associations removed.\n  void update(PathRef MainFile, llvm::ArrayRef<std::string> Headers) {\n    std::lock_guard<std::mutex> Lock(Mu);\n    auto It = MainToFirst.try_emplace(MainFile, nullptr);\n    Association *&First = It.first->second;\n    if (First)\n      invalidate(First);\n    First = associate(It.first->first(), Headers);\n    updateMemoryUsage();\n  }\n\n  // Mark MainFile as gone.\n  // This will *not* disassociate headers with MainFile immediately, but they\n  // will be eligible for association with other files that get update()d.\n  void remove(PathRef MainFile) {\n    std::lock_guard<std::mutex> Lock(Mu);\n    Association *&First = MainToFirst[MainFile];\n    if (First)\n      invalidate(First);\n  }\n\n  /// Get the mainfile associated with Header, or the empty string if none.\n  std::string get(PathRef Header) const {\n    std::lock_guard<std::mutex> Lock(Mu);\n    return HeaderToMain.lookup(Header).MainFile.str();\n  }\n\n  size_t getUsedBytes() const {\n    return UsedBytes.load(std::memory_order_acquire);\n  }\n};\n\nnamespace {\n\nbool isReliable(const tooling::CompileCommand &Cmd) {\n  return Cmd.Heuristic.empty();\n}\n\n/// Threadsafe manager for updating a TUStatus and emitting it after each\n/// update.\nclass SynchronizedTUStatus {\npublic:\n  SynchronizedTUStatus(PathRef FileName, ParsingCallbacks &Callbacks)\n      : FileName(FileName), Callbacks(Callbacks) {}\n\n  void update(llvm::function_ref<void(TUStatus &)> Mutator) {\n    std::lock_guard<std::mutex> Lock(StatusMu);\n    Mutator(Status);\n    emitStatusLocked();\n  }\n\n  /// Prevents emitting of further updates.\n  void stop() {\n    std::lock_guard<std::mutex> Lock(StatusMu);\n    CanPublish = false;\n  }\n\nprivate:\n  void emitStatusLocked() {\n    if (CanPublish)\n      Callbacks.onFileUpdated(FileName, Status);\n  }\n\n  const Path FileName;\n\n  std::mutex StatusMu;\n  TUStatus Status;\n  bool CanPublish = true;\n  ParsingCallbacks &Callbacks;\n};\n\n/// Responsible for building preambles. Whenever the thread is idle and the\n/// preamble is outdated, it starts to build a fresh preamble from the latest\n/// inputs. If RunSync is true, preambles are built synchronously in update()\n/// instead.\nclass PreambleThread {\npublic:\n  PreambleThread(llvm::StringRef FileName, ParsingCallbacks &Callbacks,\n                 bool StorePreambleInMemory, bool RunSync,\n                 SynchronizedTUStatus &Status,\n                 TUScheduler::HeaderIncluderCache &HeaderIncluders,\n                 ASTWorker &AW)\n      : FileName(FileName), Callbacks(Callbacks),\n        StoreInMemory(StorePreambleInMemory), RunSync(RunSync), Status(Status),\n        ASTPeer(AW), HeaderIncluders(HeaderIncluders) {}\n\n  /// It isn't guaranteed that each requested version will be built. If there\n  /// are multiple update requests while building a preamble, only the last one\n  /// will be built.\n  void update(std::unique_ptr<CompilerInvocation> CI, ParseInputs PI,\n              std::vector<Diag> CIDiags, WantDiagnostics WantDiags) {\n    Request Req = {std::move(CI), std::move(PI), std::move(CIDiags), WantDiags,\n                   Context::current().clone()};\n    if (RunSync) {\n      build(std::move(Req));\n      Status.update([](TUStatus &Status) {\n        Status.PreambleActivity = PreambleAction::Idle;\n      });\n      return;\n    }\n    {\n      std::unique_lock<std::mutex> Lock(Mutex);\n      // If NextReq was requested with WantDiagnostics::Yes we cannot just drop\n      // that on the floor. Block until we start building it. This won't\n      // dead-lock as we are blocking the caller thread, while builds continue\n      // on preamble thread.\n      ReqCV.wait(Lock, [this] {\n        return !NextReq || NextReq->WantDiags != WantDiagnostics::Yes;\n      });\n      NextReq = std::move(Req);\n    }\n    // Let the worker thread know there's a request, notify_one is safe as there\n    // should be a single worker thread waiting on it.\n    ReqCV.notify_all();\n  }\n\n  void run() {\n    while (true) {\n      {\n        std::unique_lock<std::mutex> Lock(Mutex);\n        assert(!CurrentReq && \"Already processing a request?\");\n        // Wait until stop is called or there is a request.\n        ReqCV.wait(Lock, [this] { return NextReq || Done; });\n        if (Done)\n          break;\n        CurrentReq = std::move(*NextReq);\n        NextReq.reset();\n      }\n\n      {\n        WithContext Guard(std::move(CurrentReq->Ctx));\n        // Note that we don't make use of the ContextProvider here.\n        // Preamble tasks are always scheduled by ASTWorker tasks, and we\n        // reuse the context/config that was created at that level.\n\n        // Build the preamble and let the waiters know about it.\n        build(std::move(*CurrentReq));\n      }\n      bool IsEmpty = false;\n      {\n        std::lock_guard<std::mutex> Lock(Mutex);\n        CurrentReq.reset();\n        IsEmpty = !NextReq.hasValue();\n      }\n      if (IsEmpty) {\n        // We don't perform this above, before waiting for a request to make\n        // tests more deterministic. As there can be a race between this thread\n        // and client thread(clangdserver).\n        Status.update([](TUStatus &Status) {\n          Status.PreambleActivity = PreambleAction::Idle;\n        });\n      }\n      ReqCV.notify_all();\n    }\n    dlog(\"Preamble worker for {0} stopped\", FileName);\n  }\n\n  /// Signals the run loop to exit.\n  void stop() {\n    dlog(\"Preamble worker for {0} received stop\", FileName);\n    {\n      std::lock_guard<std::mutex> Lock(Mutex);\n      Done = true;\n      NextReq.reset();\n    }\n    // Let the worker thread know that it should stop.\n    ReqCV.notify_all();\n  }\n\n  bool blockUntilIdle(Deadline Timeout) const {\n    std::unique_lock<std::mutex> Lock(Mutex);\n    return wait(Lock, ReqCV, Timeout, [&] { return !NextReq && !CurrentReq; });\n  }\n\nprivate:\n  /// Holds inputs required for building a preamble. CI is guaranteed to be\n  /// non-null.\n  struct Request {\n    std::unique_ptr<CompilerInvocation> CI;\n    ParseInputs Inputs;\n    std::vector<Diag> CIDiags;\n    WantDiagnostics WantDiags;\n    Context Ctx;\n  };\n\n  bool isDone() {\n    std::lock_guard<std::mutex> Lock(Mutex);\n    return Done;\n  }\n\n  /// Builds a preamble for \\p Req, might reuse LatestBuild if possible.\n  /// Notifies ASTWorker after build finishes.\n  void build(Request Req);\n\n  mutable std::mutex Mutex;\n  bool Done = false;                  /* GUARDED_BY(Mutex) */\n  llvm::Optional<Request> NextReq;    /* GUARDED_BY(Mutex) */\n  llvm::Optional<Request> CurrentReq; /* GUARDED_BY(Mutex) */\n  // Signaled whenever a thread populates NextReq or worker thread builds a\n  // Preamble.\n  mutable std::condition_variable ReqCV; /* GUARDED_BY(Mutex) */\n  // Accessed only by preamble thread.\n  std::shared_ptr<const PreambleData> LatestBuild;\n\n  const Path FileName;\n  ParsingCallbacks &Callbacks;\n  const bool StoreInMemory;\n  const bool RunSync;\n\n  SynchronizedTUStatus &Status;\n  ASTWorker &ASTPeer;\n  TUScheduler::HeaderIncluderCache &HeaderIncluders;\n};\n\nclass ASTWorkerHandle;\n\n/// Owns one instance of the AST, schedules updates and reads of it.\n/// Also responsible for building and providing access to the preamble.\n/// Each ASTWorker processes the async requests sent to it on a separate\n/// dedicated thread.\n/// The ASTWorker that manages the AST is shared by both the processing thread\n/// and the TUScheduler. The TUScheduler should discard an ASTWorker when\n/// remove() is called, but its thread may be busy and we don't want to block.\n/// So the workers are accessed via an ASTWorkerHandle. Destroying the handle\n/// signals the worker to exit its run loop and gives up shared ownership of the\n/// worker.\nclass ASTWorker {\n  friend class ASTWorkerHandle;\n  ASTWorker(PathRef FileName, const GlobalCompilationDatabase &CDB,\n            TUScheduler::ASTCache &LRUCache,\n            TUScheduler::HeaderIncluderCache &HeaderIncluders,\n            Semaphore &Barrier, bool RunSync, const TUScheduler::Options &Opts,\n            ParsingCallbacks &Callbacks);\n\npublic:\n  /// Create a new ASTWorker and return a handle to it.\n  /// The processing thread is spawned using \\p Tasks. However, when \\p Tasks\n  /// is null, all requests will be processed on the calling thread\n  /// synchronously instead. \\p Barrier is acquired when processing each\n  /// request, it is used to limit the number of actively running threads.\n  static ASTWorkerHandle\n  create(PathRef FileName, const GlobalCompilationDatabase &CDB,\n         TUScheduler::ASTCache &IdleASTs,\n         TUScheduler::HeaderIncluderCache &HeaderIncluders,\n         AsyncTaskRunner *Tasks, Semaphore &Barrier,\n         const TUScheduler::Options &Opts, ParsingCallbacks &Callbacks);\n  ~ASTWorker();\n\n  void update(ParseInputs Inputs, WantDiagnostics, bool ContentChanged);\n  void\n  runWithAST(llvm::StringRef Name,\n             llvm::unique_function<void(llvm::Expected<InputsAndAST>)> Action,\n             TUScheduler::ASTActionInvalidation);\n  bool blockUntilIdle(Deadline Timeout) const;\n\n  std::shared_ptr<const PreambleData> getPossiblyStalePreamble(\n      std::shared_ptr<const ASTSignals> *ASTSignals = nullptr) const;\n\n  /// Used to inform ASTWorker about a new preamble build by PreambleThread.\n  /// Diagnostics are only published through this callback. This ensures they\n  /// are always for newer versions of the file, as the callback gets called in\n  /// the same order as update requests.\n  void updatePreamble(std::unique_ptr<CompilerInvocation> CI, ParseInputs PI,\n                      std::shared_ptr<const PreambleData> Preamble,\n                      std::vector<Diag> CIDiags, WantDiagnostics WantDiags);\n\n  /// Obtain a preamble reflecting all updates so far. Threadsafe.\n  /// It may be delivered immediately, or later on the worker thread.\n  void getCurrentPreamble(\n      llvm::unique_function<void(std::shared_ptr<const PreambleData>)>);\n  /// Returns compile command from the current file inputs.\n  tooling::CompileCommand getCurrentCompileCommand() const;\n\n  /// Wait for the first build of preamble to finish. Preamble itself can be\n  /// accessed via getPossiblyStalePreamble(). Note that this function will\n  /// return after an unsuccessful build of the preamble too, i.e. result of\n  /// getPossiblyStalePreamble() can be null even after this function returns.\n  void waitForFirstPreamble() const;\n\n  TUScheduler::FileStats stats() const;\n  bool isASTCached() const;\n\nprivate:\n  // Details of an update request that are relevant to scheduling.\n  struct UpdateType {\n    // Do we want diagnostics from this version?\n    // If Yes, we must always build this version.\n    // If No, we only need to build this version if it's read.\n    // If Auto, we build if it's read or if the debounce expires.\n    WantDiagnostics Diagnostics;\n    // Did the main-file content of the document change?\n    // If so, we're allowed to cancel certain invalidated preceding reads.\n    bool ContentChanged;\n  };\n\n  /// Publishes diagnostics for \\p Inputs. It will build an AST or reuse the\n  /// cached one if applicable. Assumes LatestPreamble is compatible for \\p\n  /// Inputs.\n  void generateDiagnostics(std::unique_ptr<CompilerInvocation> Invocation,\n                           ParseInputs Inputs, std::vector<Diag> CIDiags);\n\n  void updateASTSignals(ParsedAST &AST);\n\n  // Must be called exactly once on processing thread. Will return after\n  // stop() is called on a separate thread and all pending requests are\n  // processed.\n  void run();\n  /// Signal that run() should finish processing pending requests and exit.\n  void stop();\n\n  /// Adds a new task to the end of the request queue.\n  void startTask(llvm::StringRef Name, llvm::unique_function<void()> Task,\n                 llvm::Optional<UpdateType> Update,\n                 TUScheduler::ASTActionInvalidation);\n\n  /// Determines the next action to perform.\n  /// All actions that should never run are discarded.\n  /// Returns a deadline for the next action. If it's expired, run now.\n  /// scheduleLocked() is called again at the deadline, or if requests arrive.\n  Deadline scheduleLocked();\n  /// Should the first task in the queue be skipped instead of run?\n  bool shouldSkipHeadLocked() const;\n\n  struct Request {\n    llvm::unique_function<void()> Action;\n    std::string Name;\n    steady_clock::time_point AddTime;\n    Context Ctx;\n    llvm::Optional<Context> QueueCtx;\n    llvm::Optional<UpdateType> Update;\n    TUScheduler::ASTActionInvalidation InvalidationPolicy;\n    Canceler Invalidate;\n  };\n\n  /// Handles retention of ASTs.\n  TUScheduler::ASTCache &IdleASTs;\n  TUScheduler::HeaderIncluderCache &HeaderIncluders;\n  const bool RunSync;\n  /// Time to wait after an update to see whether another update obsoletes it.\n  const DebouncePolicy UpdateDebounce;\n  /// File that ASTWorker is responsible for.\n  const Path FileName;\n  /// Callback to create processing contexts for tasks.\n  const std::function<Context(llvm::StringRef)> ContextProvider;\n  const GlobalCompilationDatabase &CDB;\n  /// Callback invoked when preamble or main file AST is built.\n  ParsingCallbacks &Callbacks;\n\n  Semaphore &Barrier;\n  /// Whether the 'onMainAST' callback ran for the current FileInputs.\n  bool RanASTCallback = false;\n  /// Guards members used by both TUScheduler and the worker thread.\n  mutable std::mutex Mutex;\n  /// File inputs, currently being used by the worker.\n  /// Writes and reads from unknown threads are locked. Reads from the worker\n  /// thread are not locked, as it's the only writer.\n  ParseInputs FileInputs; /* GUARDED_BY(Mutex) */\n  /// Times of recent AST rebuilds, used for UpdateDebounce computation.\n  llvm::SmallVector<DebouncePolicy::clock::duration>\n      RebuildTimes; /* GUARDED_BY(Mutex) */\n  /// Set to true to signal run() to finish processing.\n  bool Done;                              /* GUARDED_BY(Mutex) */\n  std::deque<Request> Requests;           /* GUARDED_BY(Mutex) */\n  llvm::Optional<Request> CurrentRequest; /* GUARDED_BY(Mutex) */\n  /// Signalled whenever a new request has been scheduled or processing of a\n  /// request has completed.\n  mutable std::condition_variable RequestsCV;\n  std::shared_ptr<const ASTSignals> LatestASTSignals; /* GUARDED_BY(Mutex) */\n  /// Latest build preamble for current TU.\n  /// None means no builds yet, null means there was an error while building.\n  /// Only written by ASTWorker's thread.\n  llvm::Optional<std::shared_ptr<const PreambleData>> LatestPreamble;\n  std::deque<Request> PreambleRequests; /* GUARDED_BY(Mutex) */\n  /// Signaled whenever LatestPreamble changes state or there's a new\n  /// PreambleRequest.\n  mutable std::condition_variable PreambleCV;\n  /// Guards the callback that publishes results of AST-related computations\n  /// (diagnostics) and file statuses.\n  std::mutex PublishMu;\n  // Used to prevent remove document + add document races that lead to\n  // out-of-order callbacks for publishing results of onMainAST callback.\n  //\n  // The lifetime of the old/new ASTWorkers will overlap, but their handles\n  // don't. When the old handle is destroyed, the old worker will stop reporting\n  // any results to the user.\n  bool CanPublishResults = true; /* GUARDED_BY(PublishMu) */\n  std::atomic<unsigned> ASTBuildCount = {0};\n  std::atomic<unsigned> PreambleBuildCount = {0};\n\n  SynchronizedTUStatus Status;\n  PreambleThread PreamblePeer;\n};\n\n/// A smart-pointer-like class that points to an active ASTWorker.\n/// In destructor, signals to the underlying ASTWorker that no new requests will\n/// be sent and the processing loop may exit (after running all pending\n/// requests).\nclass ASTWorkerHandle {\n  friend class ASTWorker;\n  ASTWorkerHandle(std::shared_ptr<ASTWorker> Worker)\n      : Worker(std::move(Worker)) {\n    assert(this->Worker);\n  }\n\npublic:\n  ASTWorkerHandle(const ASTWorkerHandle &) = delete;\n  ASTWorkerHandle &operator=(const ASTWorkerHandle &) = delete;\n  ASTWorkerHandle(ASTWorkerHandle &&) = default;\n  ASTWorkerHandle &operator=(ASTWorkerHandle &&) = default;\n\n  ~ASTWorkerHandle() {\n    if (Worker)\n      Worker->stop();\n  }\n\n  ASTWorker &operator*() {\n    assert(Worker && \"Handle was moved from\");\n    return *Worker;\n  }\n\n  ASTWorker *operator->() {\n    assert(Worker && \"Handle was moved from\");\n    return Worker.get();\n  }\n\n  /// Returns an owning reference to the underlying ASTWorker that can outlive\n  /// the ASTWorkerHandle. However, no new requests to an active ASTWorker can\n  /// be schedule via the returned reference, i.e. only reads of the preamble\n  /// are possible.\n  std::shared_ptr<const ASTWorker> lock() { return Worker; }\n\nprivate:\n  std::shared_ptr<ASTWorker> Worker;\n};\n\nASTWorkerHandle\nASTWorker::create(PathRef FileName, const GlobalCompilationDatabase &CDB,\n                  TUScheduler::ASTCache &IdleASTs,\n                  TUScheduler::HeaderIncluderCache &HeaderIncluders,\n                  AsyncTaskRunner *Tasks, Semaphore &Barrier,\n                  const TUScheduler::Options &Opts,\n                  ParsingCallbacks &Callbacks) {\n  std::shared_ptr<ASTWorker> Worker(\n      new ASTWorker(FileName, CDB, IdleASTs, HeaderIncluders, Barrier,\n                    /*RunSync=*/!Tasks, Opts, Callbacks));\n  if (Tasks) {\n    Tasks->runAsync(\"ASTWorker:\" + llvm::sys::path::filename(FileName),\n                    [Worker]() { Worker->run(); });\n    Tasks->runAsync(\"PreambleWorker:\" + llvm::sys::path::filename(FileName),\n                    [Worker]() { Worker->PreamblePeer.run(); });\n  }\n\n  return ASTWorkerHandle(std::move(Worker));\n}\n\nASTWorker::ASTWorker(PathRef FileName, const GlobalCompilationDatabase &CDB,\n                     TUScheduler::ASTCache &LRUCache,\n                     TUScheduler::HeaderIncluderCache &HeaderIncluders,\n                     Semaphore &Barrier, bool RunSync,\n                     const TUScheduler::Options &Opts,\n                     ParsingCallbacks &Callbacks)\n    : IdleASTs(LRUCache), HeaderIncluders(HeaderIncluders), RunSync(RunSync),\n      UpdateDebounce(Opts.UpdateDebounce), FileName(FileName),\n      ContextProvider(Opts.ContextProvider), CDB(CDB), Callbacks(Callbacks),\n      Barrier(Barrier), Done(false), Status(FileName, Callbacks),\n      PreamblePeer(FileName, Callbacks, Opts.StorePreamblesInMemory, RunSync,\n                   Status, HeaderIncluders, *this) {\n  // Set a fallback command because compile command can be accessed before\n  // `Inputs` is initialized. Other fields are only used after initialization\n  // from client inputs.\n  FileInputs.CompileCommand = CDB.getFallbackCommand(FileName);\n}\n\nASTWorker::~ASTWorker() {\n  // Make sure we remove the cached AST, if any.\n  IdleASTs.take(this);\n#ifndef NDEBUG\n  std::lock_guard<std::mutex> Lock(Mutex);\n  assert(Done && \"handle was not destroyed\");\n  assert(Requests.empty() && !CurrentRequest &&\n         \"unprocessed requests when destroying ASTWorker\");\n#endif\n}\n\nvoid ASTWorker::update(ParseInputs Inputs, WantDiagnostics WantDiags,\n                       bool ContentChanged) {\n  std::string TaskName = llvm::formatv(\"Update ({0})\", Inputs.Version);\n  auto Task = [=]() mutable {\n    // Get the actual command as `Inputs` does not have a command.\n    // FIXME: some build systems like Bazel will take time to preparing\n    // environment to build the file, it would be nice if we could emit a\n    // \"PreparingBuild\" status to inform users, it is non-trivial given the\n    // current implementation.\n    auto Cmd = CDB.getCompileCommand(FileName);\n    // If we don't have a reliable command for this file, it may be a header.\n    // Try to find a file that includes it, to borrow its command.\n    if (!Cmd || !isReliable(*Cmd)) {\n      std::string ProxyFile = HeaderIncluders.get(FileName);\n      if (!ProxyFile.empty()) {\n        auto ProxyCmd = CDB.getCompileCommand(ProxyFile);\n        if (!ProxyCmd || !isReliable(*ProxyCmd)) {\n          // This command is supposed to be reliable! It's probably gone.\n          HeaderIncluders.remove(ProxyFile);\n        } else {\n          // We have a reliable command for an including file, use it.\n          Cmd = tooling::transferCompileCommand(std::move(*ProxyCmd), FileName);\n        }\n      }\n    }\n    if (Cmd)\n      Inputs.CompileCommand = std::move(*Cmd);\n    else\n      Inputs.CompileCommand = CDB.getFallbackCommand(FileName);\n\n    bool InputsAreTheSame =\n        std::tie(FileInputs.CompileCommand, FileInputs.Contents) ==\n        std::tie(Inputs.CompileCommand, Inputs.Contents);\n    // Cached AST is invalidated.\n    if (!InputsAreTheSame) {\n      IdleASTs.take(this);\n      RanASTCallback = false;\n    }\n\n    // Update current inputs so that subsequent reads can see them.\n    {\n      std::lock_guard<std::mutex> Lock(Mutex);\n      FileInputs = Inputs;\n    }\n\n    log(\"ASTWorker building file {0} version {1} with command {2}\\n[{3}]\\n{4}\",\n        FileName, Inputs.Version, Inputs.CompileCommand.Heuristic,\n        Inputs.CompileCommand.Directory,\n        printArgv(Inputs.CompileCommand.CommandLine));\n\n    StoreDiags CompilerInvocationDiagConsumer;\n    std::vector<std::string> CC1Args;\n    std::unique_ptr<CompilerInvocation> Invocation = buildCompilerInvocation(\n        Inputs, CompilerInvocationDiagConsumer, &CC1Args);\n    // Log cc1 args even (especially!) if creating invocation failed.\n    if (!CC1Args.empty())\n      vlog(\"Driver produced command: cc1 {0}\", printArgv(CC1Args));\n    std::vector<Diag> CompilerInvocationDiags =\n        CompilerInvocationDiagConsumer.take();\n    if (!Invocation) {\n      elog(\"Could not build CompilerInvocation for file {0}\", FileName);\n      // Remove the old AST if it's still in cache.\n      IdleASTs.take(this);\n      RanASTCallback = false;\n      // Report the diagnostics we collected when parsing the command line.\n      Callbacks.onFailedAST(FileName, Inputs.Version,\n                            std::move(CompilerInvocationDiags),\n                            [&](llvm::function_ref<void()> Publish) {\n                              // Ensure we only publish results from the worker\n                              // if the file was not removed, making sure there\n                              // are not race conditions.\n                              std::lock_guard<std::mutex> Lock(PublishMu);\n                              if (CanPublishResults)\n                                Publish();\n                            });\n      // Note that this might throw away a stale preamble that might still be\n      // useful, but this is how we communicate a build error.\n      LatestPreamble.emplace();\n      // Make sure anyone waiting for the preamble gets notified it could not be\n      // built.\n      PreambleCV.notify_all();\n      return;\n    }\n\n    PreamblePeer.update(std::move(Invocation), std::move(Inputs),\n                        std::move(CompilerInvocationDiags), WantDiags);\n    std::unique_lock<std::mutex> Lock(Mutex);\n    PreambleCV.wait(Lock, [this] {\n      // Block until we reiceve a preamble request, unless a preamble already\n      // exists, as patching an empty preamble would imply rebuilding it from\n      // scratch.\n      // We block here instead of the consumer to prevent any deadlocks. Since\n      // LatestPreamble is only populated by ASTWorker thread.\n      return LatestPreamble || !PreambleRequests.empty() || Done;\n    });\n    return;\n  };\n  startTask(TaskName, std::move(Task), UpdateType{WantDiags, ContentChanged},\n            TUScheduler::NoInvalidation);\n}\n\nvoid ASTWorker::runWithAST(\n    llvm::StringRef Name,\n    llvm::unique_function<void(llvm::Expected<InputsAndAST>)> Action,\n    TUScheduler::ASTActionInvalidation Invalidation) {\n  // Tracks ast cache accesses for read operations.\n  static constexpr trace::Metric ASTAccessForRead(\n      \"ast_access_read\", trace::Metric::Counter, \"result\");\n  auto Task = [=, Action = std::move(Action)]() mutable {\n    if (auto Reason = isCancelled())\n      return Action(llvm::make_error<CancelledError>(Reason));\n    llvm::Optional<std::unique_ptr<ParsedAST>> AST =\n        IdleASTs.take(this, &ASTAccessForRead);\n    if (!AST) {\n      StoreDiags CompilerInvocationDiagConsumer;\n      std::unique_ptr<CompilerInvocation> Invocation =\n          buildCompilerInvocation(FileInputs, CompilerInvocationDiagConsumer);\n      // Try rebuilding the AST.\n      vlog(\"ASTWorker rebuilding evicted AST to run {0}: {1} version {2}\", Name,\n           FileName, FileInputs.Version);\n      // FIXME: We might need to build a patched ast once preamble thread starts\n      // running async. Currently getPossiblyStalePreamble below will always\n      // return a compatible preamble as ASTWorker::update blocks.\n      llvm::Optional<ParsedAST> NewAST;\n      if (Invocation) {\n        NewAST = ParsedAST::build(FileName, FileInputs, std::move(Invocation),\n                                  CompilerInvocationDiagConsumer.take(),\n                                  getPossiblyStalePreamble());\n        ++ASTBuildCount;\n      }\n      AST = NewAST ? std::make_unique<ParsedAST>(std::move(*NewAST)) : nullptr;\n    }\n    // Make sure we put the AST back into the LRU cache.\n    auto _ = llvm::make_scope_exit(\n        [&AST, this]() { IdleASTs.put(this, std::move(*AST)); });\n    // Run the user-provided action.\n    if (!*AST)\n      return Action(error(llvm::errc::invalid_argument, \"invalid AST\"));\n    vlog(\"ASTWorker running {0} on version {2} of {1}\", Name, FileName,\n         FileInputs.Version);\n    Action(InputsAndAST{FileInputs, **AST});\n  };\n  startTask(Name, std::move(Task), /*Update=*/None, Invalidation);\n}\n\nvoid PreambleThread::build(Request Req) {\n  assert(Req.CI && \"Got preamble request with null compiler invocation\");\n  const ParseInputs &Inputs = Req.Inputs;\n\n  Status.update([&](TUStatus &Status) {\n    Status.PreambleActivity = PreambleAction::Building;\n  });\n  auto _ = llvm::make_scope_exit([this, &Req] {\n    ASTPeer.updatePreamble(std::move(Req.CI), std::move(Req.Inputs),\n                           LatestBuild, std::move(Req.CIDiags),\n                           std::move(Req.WantDiags));\n  });\n\n  if (!LatestBuild || Inputs.ForceRebuild) {\n    vlog(\"Building first preamble for {0} version {1}\", FileName,\n         Inputs.Version);\n  } else if (isPreambleCompatible(*LatestBuild, Inputs, FileName, *Req.CI)) {\n    vlog(\"Reusing preamble version {0} for version {1} of {2}\",\n         LatestBuild->Version, Inputs.Version, FileName);\n    return;\n  } else {\n    vlog(\"Rebuilding invalidated preamble for {0} version {1} (previous was \"\n         \"version {2})\",\n         FileName, Inputs.Version, LatestBuild->Version);\n  }\n\n  LatestBuild = clang::clangd::buildPreamble(\n      FileName, *Req.CI, Inputs, StoreInMemory,\n      [this, Version(Inputs.Version)](ASTContext &Ctx,\n                                      std::shared_ptr<clang::Preprocessor> PP,\n                                      const CanonicalIncludes &CanonIncludes) {\n        Callbacks.onPreambleAST(FileName, Version, Ctx, std::move(PP),\n                                CanonIncludes);\n      });\n  if (LatestBuild && isReliable(LatestBuild->CompileCommand))\n    HeaderIncluders.update(FileName, LatestBuild->Includes.allHeaders());\n}\n\nvoid ASTWorker::updatePreamble(std::unique_ptr<CompilerInvocation> CI,\n                               ParseInputs PI,\n                               std::shared_ptr<const PreambleData> Preamble,\n                               std::vector<Diag> CIDiags,\n                               WantDiagnostics WantDiags) {\n  std::string TaskName = llvm::formatv(\"Build AST for ({0})\", PI.Version);\n  // Store preamble and build diagnostics with new preamble if requested.\n  auto Task = [this, Preamble = std::move(Preamble), CI = std::move(CI),\n               PI = std::move(PI), CIDiags = std::move(CIDiags),\n               WantDiags = std::move(WantDiags)]() mutable {\n    // Update the preamble inside ASTWorker queue to ensure atomicity. As a task\n    // running inside ASTWorker assumes internals won't change until it\n    // finishes.\n    if (!LatestPreamble || Preamble != *LatestPreamble) {\n      ++PreambleBuildCount;\n      // Cached AST is no longer valid.\n      IdleASTs.take(this);\n      RanASTCallback = false;\n      std::lock_guard<std::mutex> Lock(Mutex);\n      // LatestPreamble might be the last reference to old preamble, do not\n      // trigger destructor while holding the lock.\n      if (LatestPreamble)\n        std::swap(*LatestPreamble, Preamble);\n      else\n        LatestPreamble = std::move(Preamble);\n    }\n    // Notify anyone waiting for a preamble.\n    PreambleCV.notify_all();\n    // Give up our ownership to old preamble before starting expensive AST\n    // build.\n    Preamble.reset();\n    // We only need to build the AST if diagnostics were requested.\n    if (WantDiags == WantDiagnostics::No)\n      return;\n    // Report diagnostics with the new preamble to ensure progress. Otherwise\n    // diagnostics might get stale indefinitely if user keeps invalidating the\n    // preamble.\n    generateDiagnostics(std::move(CI), std::move(PI), std::move(CIDiags));\n  };\n  if (RunSync) {\n    Task();\n    return;\n  }\n  {\n    std::lock_guard<std::mutex> Lock(Mutex);\n    PreambleRequests.push_back({std::move(Task), std::move(TaskName),\n                                steady_clock::now(), Context::current().clone(),\n                                llvm::None, llvm::None,\n                                TUScheduler::NoInvalidation, nullptr});\n  }\n  PreambleCV.notify_all();\n  RequestsCV.notify_all();\n}\n\nvoid ASTWorker::updateASTSignals(ParsedAST &AST) {\n  auto Signals = std::make_shared<const ASTSignals>(ASTSignals::derive(AST));\n  // Existing readers of ASTSignals will have their copy preserved until the\n  // read is completed. The last reader deletes the old ASTSignals.\n  {\n    std::lock_guard<std::mutex> Lock(Mutex);\n    std::swap(LatestASTSignals, Signals);\n  }\n}\n\nvoid ASTWorker::generateDiagnostics(\n    std::unique_ptr<CompilerInvocation> Invocation, ParseInputs Inputs,\n    std::vector<Diag> CIDiags) {\n  // Tracks ast cache accesses for publishing diags.\n  static constexpr trace::Metric ASTAccessForDiag(\n      \"ast_access_diag\", trace::Metric::Counter, \"result\");\n  assert(Invocation);\n  assert(LatestPreamble);\n  // No need to rebuild the AST if we won't send the diagnostics.\n  {\n    std::lock_guard<std::mutex> Lock(PublishMu);\n    if (!CanPublishResults)\n      return;\n  }\n  // Used to check whether we can update AST cache.\n  bool InputsAreLatest =\n      std::tie(FileInputs.CompileCommand, FileInputs.Contents) ==\n      std::tie(Inputs.CompileCommand, Inputs.Contents);\n  // Take a shortcut and don't report the diagnostics, since they should be the\n  // same. All the clients should handle the lack of OnUpdated() call anyway to\n  // handle empty result from buildAST.\n  // FIXME: the AST could actually change if non-preamble includes changed,\n  // but we choose to ignore it.\n  if (InputsAreLatest && RanASTCallback)\n    return;\n\n  // Get the AST for diagnostics, either build it or use the cached one.\n  std::string TaskName = llvm::formatv(\"Build AST ({0})\", Inputs.Version);\n  Status.update([&](TUStatus &Status) {\n    Status.ASTActivity.K = ASTAction::Building;\n    Status.ASTActivity.Name = std::move(TaskName);\n  });\n  // We might be able to reuse the last we've built for a read request.\n  // FIXME: It might be better to not reuse this AST. That way queued AST builds\n  // won't be required for diags.\n  llvm::Optional<std::unique_ptr<ParsedAST>> AST =\n      IdleASTs.take(this, &ASTAccessForDiag);\n  if (!AST || !InputsAreLatest) {\n    auto RebuildStartTime = DebouncePolicy::clock::now();\n    llvm::Optional<ParsedAST> NewAST = ParsedAST::build(\n        FileName, Inputs, std::move(Invocation), CIDiags, *LatestPreamble);\n    auto RebuildDuration = DebouncePolicy::clock::now() - RebuildStartTime;\n    ++ASTBuildCount;\n    // Try to record the AST-build time, to inform future update debouncing.\n    // This is best-effort only: if the lock is held, don't bother.\n    std::unique_lock<std::mutex> Lock(Mutex, std::try_to_lock);\n    if (Lock.owns_lock()) {\n      // Do not let RebuildTimes grow beyond its small-size (i.e.\n      // capacity).\n      if (RebuildTimes.size() == RebuildTimes.capacity())\n        RebuildTimes.erase(RebuildTimes.begin());\n      RebuildTimes.push_back(RebuildDuration);\n      Lock.unlock();\n    }\n    Status.update([&](TUStatus &Status) {\n      Status.Details.ReuseAST = false;\n      Status.Details.BuildFailed = !NewAST.hasValue();\n    });\n    AST = NewAST ? std::make_unique<ParsedAST>(std::move(*NewAST)) : nullptr;\n  } else {\n    log(\"Skipping rebuild of the AST for {0}, inputs are the same.\", FileName);\n    Status.update([](TUStatus &Status) {\n      Status.Details.ReuseAST = true;\n      Status.Details.BuildFailed = false;\n    });\n  }\n\n  // Publish diagnostics.\n  auto RunPublish = [&](llvm::function_ref<void()> Publish) {\n    // Ensure we only publish results from the worker if the file was not\n    // removed, making sure there are not race conditions.\n    std::lock_guard<std::mutex> Lock(PublishMu);\n    if (CanPublishResults)\n      Publish();\n  };\n  if (*AST) {\n    trace::Span Span(\"Running main AST callback\");\n    Callbacks.onMainAST(FileName, **AST, RunPublish);\n    updateASTSignals(**AST);\n  } else {\n    // Failed to build the AST, at least report diagnostics from the\n    // command line if there were any.\n    // FIXME: we might have got more errors while trying to build the\n    // AST, surface them too.\n    Callbacks.onFailedAST(FileName, Inputs.Version, CIDiags, RunPublish);\n  }\n\n  // AST might've been built for an older version of the source, as ASTWorker\n  // queue raced ahead while we were waiting on the preamble. In that case the\n  // queue can't reuse the AST.\n  if (InputsAreLatest) {\n    RanASTCallback = *AST != nullptr;\n    IdleASTs.put(this, std::move(*AST));\n  }\n}\n\nstd::shared_ptr<const PreambleData> ASTWorker::getPossiblyStalePreamble(\n    std::shared_ptr<const ASTSignals> *ASTSignals) const {\n  std::lock_guard<std::mutex> Lock(Mutex);\n  if (ASTSignals)\n    *ASTSignals = LatestASTSignals;\n  return LatestPreamble ? *LatestPreamble : nullptr;\n}\n\nvoid ASTWorker::waitForFirstPreamble() const {\n  std::unique_lock<std::mutex> Lock(Mutex);\n  PreambleCV.wait(Lock, [this] { return LatestPreamble.hasValue() || Done; });\n}\n\ntooling::CompileCommand ASTWorker::getCurrentCompileCommand() const {\n  std::unique_lock<std::mutex> Lock(Mutex);\n  return FileInputs.CompileCommand;\n}\n\nTUScheduler::FileStats ASTWorker::stats() const {\n  TUScheduler::FileStats Result;\n  Result.ASTBuilds = ASTBuildCount;\n  Result.PreambleBuilds = PreambleBuildCount;\n  // Note that we don't report the size of ASTs currently used for processing\n  // the in-flight requests. We used this information for debugging purposes\n  // only, so this should be fine.\n  Result.UsedBytesAST = IdleASTs.getUsedBytes(this);\n  if (auto Preamble = getPossiblyStalePreamble())\n    Result.UsedBytesPreamble = Preamble->Preamble.getSize();\n  return Result;\n}\n\nbool ASTWorker::isASTCached() const { return IdleASTs.getUsedBytes(this) != 0; }\n\nvoid ASTWorker::stop() {\n  {\n    std::lock_guard<std::mutex> Lock(PublishMu);\n    CanPublishResults = false;\n  }\n  {\n    std::lock_guard<std::mutex> Lock(Mutex);\n    assert(!Done && \"stop() called twice\");\n    Done = true;\n  }\n  PreamblePeer.stop();\n  // We are no longer going to build any preambles, let the waiters know that.\n  PreambleCV.notify_all();\n  Status.stop();\n  RequestsCV.notify_all();\n}\n\nvoid ASTWorker::startTask(llvm::StringRef Name,\n                          llvm::unique_function<void()> Task,\n                          llvm::Optional<UpdateType> Update,\n                          TUScheduler::ASTActionInvalidation Invalidation) {\n  if (RunSync) {\n    assert(!Done && \"running a task after stop()\");\n    trace::Span Tracer(Name + \":\" + llvm::sys::path::filename(FileName));\n    WithContext WithProvidedContext(ContextProvider(FileName));\n    Task();\n    return;\n  }\n\n  {\n    std::lock_guard<std::mutex> Lock(Mutex);\n    assert(!Done && \"running a task after stop()\");\n    // Cancel any requests invalidated by this request.\n    if (Update && Update->ContentChanged) {\n      for (auto &R : llvm::reverse(Requests)) {\n        if (R.InvalidationPolicy == TUScheduler::InvalidateOnUpdate)\n          R.Invalidate();\n        if (R.Update && R.Update->ContentChanged)\n          break; // Older requests were already invalidated by the older update.\n      }\n    }\n\n    // Allow this request to be cancelled if invalidated.\n    Context Ctx = Context::current().derive(kFileBeingProcessed, FileName);\n    Canceler Invalidate = nullptr;\n    if (Invalidation) {\n      WithContext WC(std::move(Ctx));\n      std::tie(Ctx, Invalidate) = cancelableTask(\n          /*Reason=*/static_cast<int>(ErrorCode::ContentModified));\n    }\n    // Trace the time the request spends in the queue, and the requests that\n    // it's going to wait for.\n    llvm::Optional<Context> QueueCtx;\n    if (trace::enabled()) {\n      // Tracers that follow threads and need strict nesting will see a tiny\n      // instantaneous event \"we're enqueueing\", and sometime later it runs.\n      WithContext WC(Ctx.clone());\n      trace::Span Tracer(\"Queued:\" + Name);\n      if (Tracer.Args) {\n        if (CurrentRequest)\n          SPAN_ATTACH(Tracer, \"CurrentRequest\", CurrentRequest->Name);\n        llvm::json::Array PreambleRequestsNames;\n        for (const auto &Req : PreambleRequests)\n          PreambleRequestsNames.push_back(Req.Name);\n        SPAN_ATTACH(Tracer, \"PreambleRequestsNames\",\n                    std::move(PreambleRequestsNames));\n        llvm::json::Array RequestsNames;\n        for (const auto &Req : Requests)\n          RequestsNames.push_back(Req.Name);\n        SPAN_ATTACH(Tracer, \"RequestsNames\", std::move(RequestsNames));\n      }\n      // For tracers that follow contexts, keep the trace span's context alive\n      // until we dequeue the request, so they see the full duration.\n      QueueCtx = Context::current().clone();\n    }\n    Requests.push_back({std::move(Task), std::string(Name), steady_clock::now(),\n                        std::move(Ctx), std::move(QueueCtx), Update,\n                        Invalidation, std::move(Invalidate)});\n  }\n  RequestsCV.notify_all();\n}\n\nvoid ASTWorker::run() {\n  while (true) {\n    {\n      std::unique_lock<std::mutex> Lock(Mutex);\n      assert(!CurrentRequest && \"A task is already running, multiple workers?\");\n      for (auto Wait = scheduleLocked(); !Wait.expired();\n           Wait = scheduleLocked()) {\n        assert(PreambleRequests.empty() &&\n               \"Preamble updates should be scheduled immediately\");\n        if (Done) {\n          if (Requests.empty())\n            return;\n          else     // Even though Done is set, finish pending requests.\n            break; // However, skip delays to shutdown fast.\n        }\n\n        // Tracing: we have a next request, attribute this sleep to it.\n        llvm::Optional<WithContext> Ctx;\n        llvm::Optional<trace::Span> Tracer;\n        if (!Requests.empty()) {\n          Ctx.emplace(Requests.front().Ctx.clone());\n          Tracer.emplace(\"Debounce\");\n          SPAN_ATTACH(*Tracer, \"next_request\", Requests.front().Name);\n          if (!(Wait == Deadline::infinity())) {\n            Status.update([&](TUStatus &Status) {\n              Status.ASTActivity.K = ASTAction::Queued;\n              Status.ASTActivity.Name = Requests.front().Name;\n            });\n            SPAN_ATTACH(*Tracer, \"sleep_ms\",\n                        std::chrono::duration_cast<std::chrono::milliseconds>(\n                            Wait.time() - steady_clock::now())\n                            .count());\n          }\n        }\n\n        wait(Lock, RequestsCV, Wait);\n      }\n      // Any request in ReceivedPreambles is at least as old as the\n      // Requests.front(), so prefer them first to preserve LSP order.\n      if (!PreambleRequests.empty()) {\n        CurrentRequest = std::move(PreambleRequests.front());\n        PreambleRequests.pop_front();\n      } else {\n        CurrentRequest = std::move(Requests.front());\n        Requests.pop_front();\n      }\n    } // unlock Mutex\n\n    // Inform tracing that the request was dequeued.\n    CurrentRequest->QueueCtx.reset();\n\n    // It is safe to perform reads to CurrentRequest without holding the lock as\n    // only writer is also this thread.\n    {\n      std::unique_lock<Semaphore> Lock(Barrier, std::try_to_lock);\n      if (!Lock.owns_lock()) {\n        Status.update([&](TUStatus &Status) {\n          Status.ASTActivity.K = ASTAction::Queued;\n          Status.ASTActivity.Name = CurrentRequest->Name;\n        });\n        Lock.lock();\n      }\n      WithContext Guard(std::move(CurrentRequest->Ctx));\n      trace::Span Tracer(CurrentRequest->Name);\n      Status.update([&](TUStatus &Status) {\n        Status.ASTActivity.K = ASTAction::RunningAction;\n        Status.ASTActivity.Name = CurrentRequest->Name;\n      });\n      WithContext WithProvidedContext(ContextProvider(FileName));\n      CurrentRequest->Action();\n    }\n\n    bool IsEmpty = false;\n    {\n      std::lock_guard<std::mutex> Lock(Mutex);\n      CurrentRequest.reset();\n      IsEmpty = Requests.empty() && PreambleRequests.empty();\n    }\n    if (IsEmpty) {\n      Status.update([&](TUStatus &Status) {\n        Status.ASTActivity.K = ASTAction::Idle;\n        Status.ASTActivity.Name = \"\";\n      });\n    }\n    RequestsCV.notify_all();\n  }\n}\n\nDeadline ASTWorker::scheduleLocked() {\n  // Process new preambles immediately.\n  if (!PreambleRequests.empty())\n    return Deadline::zero();\n  if (Requests.empty())\n    return Deadline::infinity(); // Wait for new requests.\n  // Handle cancelled requests first so the rest of the scheduler doesn't.\n  for (auto I = Requests.begin(), E = Requests.end(); I != E; ++I) {\n    if (!isCancelled(I->Ctx)) {\n      // Cancellations after the first read don't affect current scheduling.\n      if (I->Update == None)\n        break;\n      continue;\n    }\n    // Cancelled reads are moved to the front of the queue and run immediately.\n    if (I->Update == None) {\n      Request R = std::move(*I);\n      Requests.erase(I);\n      Requests.push_front(std::move(R));\n      return Deadline::zero();\n    }\n    // Cancelled updates are downgraded to auto-diagnostics, and may be elided.\n    if (I->Update->Diagnostics == WantDiagnostics::Yes)\n      I->Update->Diagnostics = WantDiagnostics::Auto;\n  }\n\n  while (shouldSkipHeadLocked()) {\n    vlog(\"ASTWorker skipping {0} for {1}\", Requests.front().Name, FileName);\n    Requests.pop_front();\n  }\n  assert(!Requests.empty() && \"skipped the whole queue\");\n  // Some updates aren't dead yet, but never end up being used.\n  // e.g. the first keystroke is live until obsoleted by the second.\n  // We debounce \"maybe-unused\" writes, sleeping in case they become dead.\n  // But don't delay reads (including updates where diagnostics are needed).\n  for (const auto &R : Requests)\n    if (R.Update == None || R.Update->Diagnostics == WantDiagnostics::Yes)\n      return Deadline::zero();\n  // Front request needs to be debounced, so determine when we're ready.\n  Deadline D(Requests.front().AddTime + UpdateDebounce.compute(RebuildTimes));\n  return D;\n}\n\n// Returns true if Requests.front() is a dead update that can be skipped.\nbool ASTWorker::shouldSkipHeadLocked() const {\n  assert(!Requests.empty());\n  auto Next = Requests.begin();\n  auto Update = Next->Update;\n  if (!Update) // Only skip updates.\n    return false;\n  ++Next;\n  // An update is live if its AST might still be read.\n  // That is, if it's not immediately followed by another update.\n  if (Next == Requests.end() || !Next->Update)\n    return false;\n  // The other way an update can be live is if its diagnostics might be used.\n  switch (Update->Diagnostics) {\n  case WantDiagnostics::Yes:\n    return false; // Always used.\n  case WantDiagnostics::No:\n    return true; // Always dead.\n  case WantDiagnostics::Auto:\n    // Used unless followed by an update that generates diagnostics.\n    for (; Next != Requests.end(); ++Next)\n      if (Next->Update && Next->Update->Diagnostics != WantDiagnostics::No)\n        return true; // Prefer later diagnostics.\n    return false;\n  }\n  llvm_unreachable(\"Unknown WantDiagnostics\");\n}\n\nbool ASTWorker::blockUntilIdle(Deadline Timeout) const {\n  auto WaitUntilASTWorkerIsIdle = [&] {\n    std::unique_lock<std::mutex> Lock(Mutex);\n    return wait(Lock, RequestsCV, Timeout, [&] {\n      return PreambleRequests.empty() && Requests.empty() && !CurrentRequest;\n    });\n  };\n  // Make sure ASTWorker has processed all requests, which might issue new\n  // updates to PreamblePeer.\n  WaitUntilASTWorkerIsIdle();\n  // Now that ASTWorker processed all requests, ensure PreamblePeer has served\n  // all update requests. This might create new PreambleRequests for the\n  // ASTWorker.\n  PreamblePeer.blockUntilIdle(Timeout);\n  assert(Requests.empty() &&\n         \"No new normal tasks can be scheduled concurrently with \"\n         \"blockUntilIdle(): ASTWorker isn't threadsafe\");\n  // Finally make sure ASTWorker has processed all of the preamble updates.\n  return WaitUntilASTWorkerIsIdle();\n}\n\n// Render a TUAction to a user-facing string representation.\n// TUAction represents clangd-internal states, we don't intend to expose them\n// to users (say C++ programmers) directly to avoid confusion, we use terms that\n// are familiar by C++ programmers.\nstd::string renderTUAction(const PreambleAction PA, const ASTAction &AA) {\n  llvm::SmallVector<std::string, 2> Result;\n  switch (PA) {\n  case PreambleAction::Building:\n    Result.push_back(\"parsing includes\");\n    break;\n  case PreambleAction::Idle:\n    // We handle idle specially below.\n    break;\n  }\n  switch (AA.K) {\n  case ASTAction::Queued:\n    Result.push_back(\"file is queued\");\n    break;\n  case ASTAction::RunningAction:\n    Result.push_back(\"running \" + AA.Name);\n    break;\n  case ASTAction::Building:\n    Result.push_back(\"parsing main file\");\n    break;\n  case ASTAction::Idle:\n    // We handle idle specially below.\n    break;\n  }\n  if (Result.empty())\n    return \"idle\";\n  return llvm::join(Result, \", \");\n}\n\n} // namespace\n\nunsigned getDefaultAsyncThreadsCount() {\n  return llvm::heavyweight_hardware_concurrency().compute_thread_count();\n}\n\nFileStatus TUStatus::render(PathRef File) const {\n  FileStatus FStatus;\n  FStatus.uri = URIForFile::canonicalize(File, /*TUPath=*/File);\n  FStatus.state = renderTUAction(PreambleActivity, ASTActivity);\n  return FStatus;\n}\n\nstruct TUScheduler::FileData {\n  /// Latest inputs, passed to TUScheduler::update().\n  std::string Contents;\n  ASTWorkerHandle Worker;\n};\n\nTUScheduler::TUScheduler(const GlobalCompilationDatabase &CDB,\n                         const Options &Opts,\n                         std::unique_ptr<ParsingCallbacks> Callbacks)\n    : CDB(CDB), Opts(Opts),\n      Callbacks(Callbacks ? move(Callbacks)\n                          : std::make_unique<ParsingCallbacks>()),\n      Barrier(Opts.AsyncThreadsCount), QuickRunBarrier(Opts.AsyncThreadsCount),\n      IdleASTs(\n          std::make_unique<ASTCache>(Opts.RetentionPolicy.MaxRetainedASTs)),\n      HeaderIncluders(std::make_unique<HeaderIncluderCache>()) {\n  // Avoid null checks everywhere.\n  if (!Opts.ContextProvider) {\n    this->Opts.ContextProvider = [](llvm::StringRef) {\n      return Context::current().clone();\n    };\n  }\n  if (0 < Opts.AsyncThreadsCount) {\n    PreambleTasks.emplace();\n    WorkerThreads.emplace();\n  }\n}\n\nTUScheduler::~TUScheduler() {\n  // Notify all workers that they need to stop.\n  Files.clear();\n\n  // Wait for all in-flight tasks to finish.\n  if (PreambleTasks)\n    PreambleTasks->wait();\n  if (WorkerThreads)\n    WorkerThreads->wait();\n}\n\nbool TUScheduler::blockUntilIdle(Deadline D) const {\n  for (auto &File : Files)\n    if (!File.getValue()->Worker->blockUntilIdle(D))\n      return false;\n  if (PreambleTasks)\n    if (!PreambleTasks->wait(D))\n      return false;\n  return true;\n}\n\nbool TUScheduler::update(PathRef File, ParseInputs Inputs,\n                         WantDiagnostics WantDiags) {\n  std::unique_ptr<FileData> &FD = Files[File];\n  bool NewFile = FD == nullptr;\n  bool ContentChanged = false;\n  if (!FD) {\n    // Create a new worker to process the AST-related tasks.\n    ASTWorkerHandle Worker =\n        ASTWorker::create(File, CDB, *IdleASTs, *HeaderIncluders,\n                          WorkerThreads ? WorkerThreads.getPointer() : nullptr,\n                          Barrier, Opts, *Callbacks);\n    FD = std::unique_ptr<FileData>(\n        new FileData{Inputs.Contents, std::move(Worker)});\n    ContentChanged = true;\n  } else if (FD->Contents != Inputs.Contents) {\n    ContentChanged = true;\n    FD->Contents = Inputs.Contents;\n  }\n  FD->Worker->update(std::move(Inputs), WantDiags, ContentChanged);\n  return NewFile;\n}\n\nvoid TUScheduler::remove(PathRef File) {\n  bool Removed = Files.erase(File);\n  if (!Removed)\n    elog(\"Trying to remove file from TUScheduler that is not tracked: {0}\",\n         File);\n  // We don't call HeaderIncluders.remove(File) here.\n  // If we did, we'd avoid potentially stale header/mainfile associations.\n  // However, it would mean that closing a mainfile could invalidate the\n  // preamble of several open headers.\n}\n\nvoid TUScheduler::run(llvm::StringRef Name, llvm::StringRef Path,\n                      llvm::unique_function<void()> Action) {\n  runWithSemaphore(Name, Path, std::move(Action), Barrier);\n}\n\nvoid TUScheduler::runQuick(llvm::StringRef Name, llvm::StringRef Path,\n                           llvm::unique_function<void()> Action) {\n  // Use QuickRunBarrier to serialize quick tasks: we are ignoring\n  // the parallelism level set by the user, don't abuse it\n  runWithSemaphore(Name, Path, std::move(Action), QuickRunBarrier);\n}\n\nvoid TUScheduler::runWithSemaphore(llvm::StringRef Name, llvm::StringRef Path,\n                                   llvm::unique_function<void()> Action,\n                                   Semaphore &Sem) {\n  if (!PreambleTasks) {\n    WithContext WithProvidedContext(Opts.ContextProvider(Path));\n    return Action();\n  }\n  PreambleTasks->runAsync(Name, [this, &Sem, Ctx = Context::current().clone(),\n                                 Path(Path.str()),\n                                 Action = std::move(Action)]() mutable {\n    std::lock_guard<Semaphore> BarrierLock(Sem);\n    WithContext WC(std::move(Ctx));\n    WithContext WithProvidedContext(Opts.ContextProvider(Path));\n    Action();\n  });\n}\n\nvoid TUScheduler::runWithAST(\n    llvm::StringRef Name, PathRef File,\n    llvm::unique_function<void(llvm::Expected<InputsAndAST>)> Action,\n    TUScheduler::ASTActionInvalidation Invalidation) {\n  auto It = Files.find(File);\n  if (It == Files.end()) {\n    Action(llvm::make_error<LSPError>(\n        \"trying to get AST for non-added document\", ErrorCode::InvalidParams));\n    return;\n  }\n\n  It->second->Worker->runWithAST(Name, std::move(Action), Invalidation);\n}\n\nvoid TUScheduler::runWithPreamble(llvm::StringRef Name, PathRef File,\n                                  PreambleConsistency Consistency,\n                                  Callback<InputsAndPreamble> Action) {\n  auto It = Files.find(File);\n  if (It == Files.end()) {\n    Action(llvm::make_error<LSPError>(\n        \"trying to get preamble for non-added document\",\n        ErrorCode::InvalidParams));\n    return;\n  }\n\n  if (!PreambleTasks) {\n    trace::Span Tracer(Name);\n    SPAN_ATTACH(Tracer, \"file\", File);\n    std::shared_ptr<const ASTSignals> Signals;\n    std::shared_ptr<const PreambleData> Preamble =\n        It->second->Worker->getPossiblyStalePreamble(&Signals);\n    WithContext WithProvidedContext(Opts.ContextProvider(File));\n    Action(InputsAndPreamble{It->second->Contents,\n                             It->second->Worker->getCurrentCompileCommand(),\n                             Preamble.get(), Signals.get()});\n    return;\n  }\n\n  std::shared_ptr<const ASTWorker> Worker = It->second->Worker.lock();\n  auto Task = [Worker, Consistency, Name = Name.str(), File = File.str(),\n               Contents = It->second->Contents,\n               Command = Worker->getCurrentCompileCommand(),\n               Ctx = Context::current().derive(kFileBeingProcessed,\n                                               std::string(File)),\n               Action = std::move(Action), this]() mutable {\n    std::shared_ptr<const PreambleData> Preamble;\n    if (Consistency == PreambleConsistency::Stale) {\n      // Wait until the preamble is built for the first time, if preamble\n      // is required. This avoids extra work of processing the preamble\n      // headers in parallel multiple times.\n      Worker->waitForFirstPreamble();\n    }\n    std::shared_ptr<const ASTSignals> Signals;\n    Preamble = Worker->getPossiblyStalePreamble(&Signals);\n\n    std::lock_guard<Semaphore> BarrierLock(Barrier);\n    WithContext Guard(std::move(Ctx));\n    trace::Span Tracer(Name);\n    SPAN_ATTACH(Tracer, \"file\", File);\n    WithContext WithProvidedContext(Opts.ContextProvider(File));\n    Action(InputsAndPreamble{Contents, Command, Preamble.get(), Signals.get()});\n  };\n\n  PreambleTasks->runAsync(\"task:\" + llvm::sys::path::filename(File),\n                          std::move(Task));\n}\n\nllvm::StringMap<TUScheduler::FileStats> TUScheduler::fileStats() const {\n  llvm::StringMap<TUScheduler::FileStats> Result;\n  for (const auto &PathAndFile : Files)\n    Result.try_emplace(PathAndFile.first(),\n                       PathAndFile.second->Worker->stats());\n  return Result;\n}\n\nstd::vector<Path> TUScheduler::getFilesWithCachedAST() const {\n  std::vector<Path> Result;\n  for (auto &&PathAndFile : Files) {\n    if (!PathAndFile.second->Worker->isASTCached())\n      continue;\n    Result.push_back(std::string(PathAndFile.first()));\n  }\n  return Result;\n}\n\nDebouncePolicy::clock::duration\nDebouncePolicy::compute(llvm::ArrayRef<clock::duration> History) const {\n  assert(Min <= Max && \"Invalid policy\");\n  if (History.empty())\n    return Max; // Arbitrary.\n\n  // Base the result on the median rebuild.\n  // nth_element needs a mutable array, take the chance to bound the data size.\n  History = History.take_back(15);\n  llvm::SmallVector<clock::duration, 15> Recent(History.begin(), History.end());\n  auto Median = Recent.begin() + Recent.size() / 2;\n  std::nth_element(Recent.begin(), Median, Recent.end());\n\n  clock::duration Target =\n      std::chrono::duration_cast<clock::duration>(RebuildRatio * *Median);\n  if (Target > Max)\n    return Max;\n  if (Target < Min)\n    return Min;\n  return Target;\n}\n\nDebouncePolicy DebouncePolicy::fixed(clock::duration T) {\n  DebouncePolicy P;\n  P.Min = P.Max = T;\n  return P;\n}\n\nvoid TUScheduler::profile(MemoryTree &MT) const {\n  for (const auto &Elem : fileStats()) {\n    MT.detail(Elem.first())\n        .child(\"preamble\")\n        .addUsage(Opts.StorePreamblesInMemory ? Elem.second.UsedBytesPreamble\n                                              : 0);\n    MT.detail(Elem.first()).child(\"ast\").addUsage(Elem.second.UsedBytesAST);\n    MT.child(\"header_includer_cache\").addUsage(HeaderIncluders->getUsedBytes());\n  }\n}\n} // namespace clangd\n} // namespace clang\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.h", "content": "//===--- TUScheduler.h -------------------------------------------*-C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_TUSCHEDULER_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_TUSCHEDULER_H\n\n#include \"ASTSignals.h\"\n#include \"Compiler.h\"\n#include \"Diagnostics.h\"\n#include \"GlobalCompilationDatabase.h\"\n#include \"index/CanonicalIncludes.h\"\n#include \"support/Function.h\"\n#include \"support/MemoryTree.h\"\n#include \"support/Path.h\"\n#include \"support/Threading.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <chrono>\n\nnamespace clang {\nnamespace clangd {\nclass ParsedAST;\nstruct PreambleData;\n\n/// Returns a number of a default async threads to use for TUScheduler.\n/// Returned value is always >= 1 (i.e. will not cause requests to be processed\n/// synchronously).\nunsigned getDefaultAsyncThreadsCount();\n\nstruct InputsAndAST {\n  const ParseInputs &Inputs;\n  ParsedAST &AST;\n};\n\nstruct InputsAndPreamble {\n  llvm::StringRef Contents;\n  const tooling::CompileCommand &Command;\n  // This can be nullptr if no preamble is available.\n  const PreambleData *Preamble;\n  // This can be nullptr if no ASTSignals are available.\n  const ASTSignals *Signals;\n};\n\n/// Determines whether diagnostics should be generated for a file snapshot.\nenum class WantDiagnostics {\n  Yes,  /// Diagnostics must be generated for this snapshot.\n  No,   /// Diagnostics must not be generated for this snapshot.\n  Auto, /// Diagnostics must be generated for this snapshot or a subsequent one,\n        /// within a bounded amount of time.\n};\n\n/// Configuration of the AST retention policy. This only covers retention of\n/// *idle* ASTs. If queue has operations requiring the AST, they might be\n/// kept in memory.\nstruct ASTRetentionPolicy {\n  /// Maximum number of ASTs to be retained in memory when there are no pending\n  /// requests for them.\n  unsigned MaxRetainedASTs = 3;\n};\n\n/// Clangd may wait after an update to see if another one comes along.\n/// This is so we rebuild once the user stops typing, not when they start.\n/// Debounce may be disabled/interrupted if we must build this version.\n/// The debounce time is responsive to user preferences and rebuild time.\n/// In the future, we could also consider different types of edits.\nstruct DebouncePolicy {\n  using clock = std::chrono::steady_clock;\n\n  /// The minimum time that we always debounce for.\n  clock::duration Min = /*zero*/ {};\n  /// The maximum time we may debounce for.\n  clock::duration Max = /*zero*/ {};\n  /// Target debounce, as a fraction of file rebuild time.\n  /// e.g. RebuildRatio = 2, recent builds took 200ms => debounce for 400ms.\n  float RebuildRatio = 1;\n\n  /// Compute the time to debounce based on this policy and recent build times.\n  clock::duration compute(llvm::ArrayRef<clock::duration> History) const;\n  /// A policy that always returns the same duration, useful for tests.\n  static DebouncePolicy fixed(clock::duration);\n};\n\nenum class PreambleAction {\n  Idle,\n  Building,\n};\n\nstruct ASTAction {\n  enum Kind {\n    Queued,        // The action is pending in the thread task queue to be run.\n    RunningAction, // Started running actions on the TU.\n    Building,      // The AST is being built.\n    Idle, // Indicates the worker thread is idle, and ready to run any upcoming\n          // actions.\n  };\n  ASTAction() = default;\n  ASTAction(Kind K, llvm::StringRef Name) : K(K), Name(Name) {}\n  Kind K = ASTAction::Idle;\n  /// The name of the action currently running, e.g. Update, GoToDef, Hover.\n  /// Empty if we are in the idle state.\n  std::string Name;\n};\n\n// Internal status of the TU in TUScheduler.\nstruct TUStatus {\n  struct BuildDetails {\n    /// Indicates whether clang failed to build the TU.\n    bool BuildFailed = false;\n    /// Indicates whether we reused the prebuilt AST.\n    bool ReuseAST = false;\n  };\n  /// Serialize this to an LSP file status item.\n  FileStatus render(PathRef File) const;\n\n  PreambleAction PreambleActivity = PreambleAction::Idle;\n  ASTAction ASTActivity;\n  /// Stores status of the last build for the translation unit.\n  BuildDetails Details;\n};\n\nclass ParsingCallbacks {\npublic:\n  virtual ~ParsingCallbacks() = default;\n\n  /// Called on the AST that was built for emitting the preamble. The built AST\n  /// contains only AST nodes from the #include directives at the start of the\n  /// file. AST node in the current file should be observed on onMainAST call.\n  virtual void onPreambleAST(PathRef Path, llvm::StringRef Version,\n                             ASTContext &Ctx,\n                             std::shared_ptr<clang::Preprocessor> PP,\n                             const CanonicalIncludes &) {}\n\n  /// The argument function is run under the critical section guarding against\n  /// races when closing the files.\n  using PublishFn = llvm::function_ref<void(llvm::function_ref<void()>)>;\n  /// Called on the AST built for the file itself. Note that preamble AST nodes\n  /// are not deserialized and should be processed in the onPreambleAST call\n  /// instead.\n  /// The \\p AST always contains all AST nodes for the main file itself, and\n  /// only a portion of the AST nodes deserialized from the preamble. Note that\n  /// some nodes from the preamble may have been deserialized and may also be\n  /// accessed from the main file AST, e.g. redecls of functions from preamble,\n  /// etc. Clients are expected to process only the AST nodes from the main file\n  /// in this callback (obtained via ParsedAST::getLocalTopLevelDecls) to obtain\n  /// optimal performance.\n  ///\n  /// When information about the file (e.g. diagnostics) is\n  /// published to clients, this should be wrapped in Publish, e.g.\n  ///   void onMainAST(...) {\n  ///     Diags = renderDiagnostics();\n  ///     Publish([&] { notifyDiagnostics(Path, Diags); });\n  ///   }\n  /// This guarantees that clients will see results in the correct sequence if\n  /// the file is concurrently closed and/or reopened. (The lambda passed to\n  /// Publish() may never run in this case).\n  virtual void onMainAST(PathRef Path, ParsedAST &AST, PublishFn Publish) {}\n\n  /// Called whenever the AST fails to build. \\p Diags will have the diagnostics\n  /// that led to failure.\n  virtual void onFailedAST(PathRef Path, llvm::StringRef Version,\n                           std::vector<Diag> Diags, PublishFn Publish) {}\n\n  /// Called whenever the TU status is updated.\n  virtual void onFileUpdated(PathRef File, const TUStatus &Status) {}\n};\n\n/// Handles running tasks for ClangdServer and managing the resources (e.g.,\n/// preambles and ASTs) for opened files.\n/// TUScheduler is not thread-safe, only one thread should be providing updates\n/// and scheduling tasks.\n/// Callbacks are run on a threadpool and it's appropriate to do slow work in\n/// them. Each task has a name, used for tracing (should be UpperCamelCase).\nclass TUScheduler {\npublic:\n  struct Options {\n    /// Number of concurrent actions.\n    /// Governs per-file worker threads and threads spawned for other tasks.\n    /// (This does not prevent threads being spawned, but rather blocks them).\n    /// If 0, executes actions synchronously on the calling thread.\n    unsigned AsyncThreadsCount = getDefaultAsyncThreadsCount();\n\n    /// Cache (large) preamble data in RAM rather than temporary files on disk.\n    bool StorePreamblesInMemory = false;\n\n    /// Time to wait after an update to see if another one comes along.\n    /// This tries to ensure we rebuild once the user stops typing.\n    DebouncePolicy UpdateDebounce;\n\n    /// Determines when to keep idle ASTs in memory for future use.\n    ASTRetentionPolicy RetentionPolicy;\n\n    /// Used to create a context that wraps each single operation.\n    /// Typically to inject per-file configuration.\n    /// If the path is empty, context sholud be \"generic\".\n    std::function<Context(PathRef)> ContextProvider;\n  };\n\n  TUScheduler(const GlobalCompilationDatabase &CDB, const Options &Opts,\n              std::unique_ptr<ParsingCallbacks> ASTCallbacks = nullptr);\n  ~TUScheduler();\n\n  struct FileStats {\n    std::size_t UsedBytesAST = 0;\n    std::size_t UsedBytesPreamble = 0;\n    unsigned PreambleBuilds = 0;\n    unsigned ASTBuilds = 0;\n  };\n  /// Returns resources used for each of the currently open files.\n  /// Results are inherently racy as they measure activity of other threads.\n  llvm::StringMap<FileStats> fileStats() const;\n\n  /// Returns a list of files with ASTs currently stored in memory. This method\n  /// is not very reliable and is only used for test. E.g., the results will not\n  /// contain files that currently run something over their AST.\n  std::vector<Path> getFilesWithCachedAST() const;\n\n  /// Schedule an update for \\p File.\n  /// The compile command in \\p Inputs is ignored; worker queries CDB to get\n  /// the actual compile command.\n  /// If diagnostics are requested (Yes), and the context is cancelled\n  /// before they are prepared, they may be skipped if eventual-consistency\n  /// permits it (i.e. WantDiagnostics is downgraded to Auto).\n  /// Returns true if the file was not previously tracked.\n  bool update(PathRef File, ParseInputs Inputs, WantDiagnostics WD);\n\n  /// Remove \\p File from the list of tracked files and schedule removal of its\n  /// resources. Pending diagnostics for closed files may not be delivered, even\n  /// if requested with WantDiags::Auto or WantDiags::Yes.\n  void remove(PathRef File);\n\n  /// Schedule an async task with no dependencies.\n  /// Path may be empty (it is used only to set the Context).\n  void run(llvm::StringRef Name, llvm::StringRef Path,\n           llvm::unique_function<void()> Action);\n\n  /// Similar to run, except the task is expected to be quick.\n  /// This function will not honor AsyncThreadsCount (except\n  /// if threading is disabled with AsyncThreadsCount=0)\n  /// It is intended to run quick tasks that need to run ASAP\n  void runQuick(llvm::StringRef Name, llvm::StringRef Path,\n                llvm::unique_function<void()> Action);\n\n  /// Defines how a runWithAST action is implicitly cancelled by other actions.\n  enum ASTActionInvalidation {\n    /// The request will run unless explicitly cancelled.\n    NoInvalidation,\n    /// The request will be implicitly cancelled by a subsequent update().\n    /// (Only if the request was not yet cancelled).\n    /// Useful for requests that are generated by clients, without any explicit\n    /// user action. These can otherwise e.g. force every version to be built.\n    InvalidateOnUpdate,\n  };\n\n  /// Schedule an async read of the AST. \\p Action will be called when AST is\n  /// ready. The AST passed to \\p Action refers to the version of \\p File\n  /// tracked at the time of the call, even if new updates are received before\n  /// \\p Action is executed.\n  /// If an error occurs during processing, it is forwarded to the \\p Action\n  /// callback.\n  /// If the context is cancelled before the AST is ready, or the invalidation\n  /// policy is triggered, the callback will receive a CancelledError.\n  void runWithAST(llvm::StringRef Name, PathRef File,\n                  Callback<InputsAndAST> Action,\n                  ASTActionInvalidation = NoInvalidation);\n\n  /// Controls whether preamble reads wait for the preamble to be up-to-date.\n  enum PreambleConsistency {\n    /// The preamble may be generated from an older version of the file.\n    /// Reading from locations in the preamble may cause files to be re-read.\n    /// This gives callers two options:\n    /// - validate that the preamble is still valid, and only use it if so\n    /// - accept that the preamble contents may be outdated, and try to avoid\n    ///   reading source code from headers.\n    /// This is the fastest option, usually a preamble is available immediately.\n    Stale,\n    /// Besides accepting stale preamble, this also allow preamble to be absent\n    /// (not ready or failed to build).\n    StaleOrAbsent,\n  };\n\n  /// Schedule an async read of the preamble.\n  /// If there's no up-to-date preamble, we follow the PreambleConsistency\n  /// policy.\n  /// If an error occurs, it is forwarded to the \\p Action callback.\n  /// Context cancellation is ignored and should be handled by the Action.\n  /// (In practice, the Action is almost always executed immediately).\n  void runWithPreamble(llvm::StringRef Name, PathRef File,\n                       PreambleConsistency Consistency,\n                       Callback<InputsAndPreamble> Action);\n\n  /// Wait until there are no scheduled or running tasks.\n  /// Mostly useful for synchronizing tests.\n  bool blockUntilIdle(Deadline D) const;\n\nprivate:\n  /// This class stores per-file data in the Files map.\n  struct FileData;\n\npublic:\n  /// Responsible for retaining and rebuilding idle ASTs. An implementation is\n  /// an LRU cache.\n  class ASTCache;\n  /// Tracks headers included by open files, to get known-good compile commands.\n  class HeaderIncluderCache;\n\n  // The file being built/processed in the current thread. This is a hack in\n  // order to get the file name into the index implementations. Do not depend on\n  // this inside clangd.\n  // FIXME: remove this when there is proper index support via build system\n  // integration.\n  // FIXME: move to ClangdServer via createProcessingContext.\n  static llvm::Optional<llvm::StringRef> getFileBeingProcessedInContext();\n\n  void profile(MemoryTree &MT) const;\n\nprivate:\n  void runWithSemaphore(llvm::StringRef Name, llvm::StringRef Path,\n                        llvm::unique_function<void()> Action, Semaphore &Sem);\n\n  const GlobalCompilationDatabase &CDB;\n  Options Opts;\n  std::unique_ptr<ParsingCallbacks> Callbacks; // not nullptr\n  Semaphore Barrier;\n  Semaphore QuickRunBarrier;\n  llvm::StringMap<std::unique_ptr<FileData>> Files;\n  std::unique_ptr<ASTCache> IdleASTs;\n  std::unique_ptr<HeaderIncluderCache> HeaderIncluders;\n  // None when running tasks synchronously and non-None when running tasks\n  // asynchronously.\n  llvm::Optional<AsyncTaskRunner> PreambleTasks;\n  llvm::Optional<AsyncTaskRunner> WorkerThreads;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Threading.h", "content": "//===--- Threading.h - Abstractions for multithreading -----------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_THREADING_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_SUPPORT_THREADING_H\n\n#include \"support/Context.h\"\n#include \"llvm/ADT/FunctionExtras.h\"\n#include \"llvm/ADT/Twine.h\"\n#include <cassert>\n#include <condition_variable>\n#include <future>\n#include <memory>\n#include <mutex>\n#include <thread>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\n/// A threadsafe flag that is initially clear.\nclass Notification {\npublic:\n  // Sets the flag. No-op if already set.\n  void notify();\n  // Blocks until flag is set.\n  void wait() const;\n\nprivate:\n  bool Notified = false;\n  mutable std::condition_variable CV;\n  mutable std::mutex Mu;\n};\n\n/// Limits the number of threads that can acquire the lock at the same time.\nclass Semaphore {\npublic:\n  Semaphore(std::size_t MaxLocks);\n\n  bool try_lock();\n  void lock();\n  void unlock();\n\nprivate:\n  std::mutex Mutex;\n  std::condition_variable SlotsChanged;\n  std::size_t FreeSlots;\n};\n\n/// A point in time we can wait for.\n/// Can be zero (don't wait) or infinity (wait forever).\n/// (Not time_point::max(), because many std::chrono implementations overflow).\nclass Deadline {\npublic:\n  Deadline(std::chrono::steady_clock::time_point Time)\n      : Type(Finite), Time(Time) {}\n  static Deadline zero() { return Deadline(Zero); }\n  static Deadline infinity() { return Deadline(Infinite); }\n\n  std::chrono::steady_clock::time_point time() const {\n    assert(Type == Finite);\n    return Time;\n  }\n  bool expired() const {\n    return (Type == Zero) ||\n           (Type == Finite && Time < std::chrono::steady_clock::now());\n  }\n  bool operator==(const Deadline &Other) const {\n    return (Type == Other.Type) && (Type != Finite || Time == Other.Time);\n  }\n\nprivate:\n  enum Type { Zero, Infinite, Finite };\n\n  Deadline(enum Type Type) : Type(Type) {}\n  enum Type Type;\n  std::chrono::steady_clock::time_point Time;\n};\n\n/// Makes a deadline from a timeout in seconds. None means wait forever.\nDeadline timeoutSeconds(llvm::Optional<double> Seconds);\n/// Wait once on CV for the specified duration.\nvoid wait(std::unique_lock<std::mutex> &Lock, std::condition_variable &CV,\n          Deadline D);\n/// Waits on a condition variable until F() is true or D expires.\ntemplate <typename Func>\nLLVM_NODISCARD bool wait(std::unique_lock<std::mutex> &Lock,\n                         std::condition_variable &CV, Deadline D, Func F) {\n  while (!F()) {\n    if (D.expired())\n      return false;\n    wait(Lock, CV, D);\n  }\n  return true;\n}\n\n/// Runs tasks on separate (detached) threads and wait for all tasks to finish.\n/// Objects that need to spawn threads can own an AsyncTaskRunner to ensure they\n/// all complete on destruction.\nclass AsyncTaskRunner {\npublic:\n  /// Destructor waits for all pending tasks to finish.\n  ~AsyncTaskRunner();\n\n  void wait() const { (void)wait(Deadline::infinity()); }\n  LLVM_NODISCARD bool wait(Deadline D) const;\n  // The name is used for tracing and debugging (e.g. to name a spawned thread).\n  void runAsync(const llvm::Twine &Name, llvm::unique_function<void()> Action);\n\nprivate:\n  mutable std::mutex Mutex;\n  mutable std::condition_variable TasksReachedZero;\n  std::size_t InFlightTasks = 0;\n};\n\n/// Runs \\p Action asynchronously with a new std::thread. The context will be\n/// propagated.\ntemplate <typename T>\nstd::future<T> runAsync(llvm::unique_function<T()> Action) {\n  return std::async(\n      std::launch::async,\n      [](llvm::unique_function<T()> &&Action, Context Ctx) {\n        WithContext WithCtx(std::move(Ctx));\n        return Action();\n      },\n      std::move(Action), Context::current().clone());\n}\n\n/// Memoize is a cache to store and reuse computation results based on a key.\n///\n///   Memoize<DenseMap<int, bool>> PrimeCache;\n///   for (int I : RepetitiveNumbers)\n///     if (PrimeCache.get(I, [&] { return expensiveIsPrime(I); }))\n///       llvm::errs() << \"Prime: \" << I << \"\\n\";\n///\n/// The computation will only be run once for each key.\n/// This class is threadsafe. Concurrent calls for the same key may run the\n/// computation multiple times, but each call will return the same result.\ntemplate <typename Container> class Memoize {\n  mutable Container Cache;\n  std::unique_ptr<std::mutex> Mu;\n\npublic:\n  Memoize() : Mu(std::make_unique<std::mutex>()) {}\n\n  template <typename T, typename Func>\n  typename Container::mapped_type get(T &&Key, Func Compute) const {\n    {\n      std::lock_guard<std::mutex> Lock(*Mu);\n      auto It = Cache.find(Key);\n      if (It != Cache.end())\n        return It->second;\n    }\n    // Don't hold the mutex while computing.\n    auto V = Compute();\n    {\n      std::lock_guard<std::mutex> Lock(*Mu);\n      auto R = Cache.try_emplace(std::forward<T>(Key), V);\n      // Insert into cache may fail if we raced with another thread.\n      if (!R.second)\n        return R.first->second; // Canonical value, from other thread.\n    }\n    return V;\n  }\n};\n\n/// Used to guard an operation that should run at most every N seconds.\n///\n/// Usage:\n///   mutable PeriodicThrottler ShouldLog(std::chrono::seconds(1));\n///   void calledFrequently() {\n///     if (ShouldLog())\n///       log(\"this is not spammy\");\n///   }\n///\n/// This class is threadsafe. If multiple threads are involved, then the guarded\n/// operation still needs to be threadsafe!\nclass PeriodicThrottler {\n  using Stopwatch = std::chrono::steady_clock;\n  using Rep = Stopwatch::duration::rep;\n\n  Rep Period;\n  std::atomic<Rep> Next;\n\npublic:\n  /// If Period is zero, the throttler will return true every time.\n  PeriodicThrottler(Stopwatch::duration Period, Stopwatch::duration Delay = {})\n      : Period(Period.count()),\n        Next((Stopwatch::now() + Delay).time_since_epoch().count()) {}\n\n  /// Returns whether the operation should run at this time.\n  /// operator() is safe to call concurrently.\n  bool operator()();\n};\n\n} // namespace clangd\n} // namespace clang\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 4, "line": 1480}, "message": "default constructor 'FileStatus' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "df93ed9d28a4345beaf8ca1f5a6aa6b2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 4, "line": 1480}, "message": "destructor '~FileStatus' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "979f1bb2c7830cb76891d585b4f56e14", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 4, "line": 1480}, "message": "move constructor 'FileStatus' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/Protocol.h", "reportHash": "3cb9c6de3d87110e475291eaa88f2abe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 5, "line": 256}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "ee2a5024cf1b867a01cf60cc62704922", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 26, "file": 5, "line": 256}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "06bbe09b0b319ba8296e0c222dc78ffe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 5, "line": 312}, "message": "destructor '~SynchronizedTUStatus' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "ed6919a72487f76662ea39cde1f46ce6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 5, "line": 367}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "0b36a348c4f34e244a523a7dfa0e0082", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 5, "line": 420}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "5e22f8364897e650c2533225cee4a7fd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 5, "line": 556}, "message": "destructor '~UpdateType' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "bb6fb682e4cd666762f08dcfd73074a6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 5, "line": 719}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "ddbac15adda80dd0e6057b42a9506e51", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 5, "line": 721}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "6e629651d223cede47a36bc7fffa492c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 5, "line": 759}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "70976bfe392e87e74153edc5785ce44b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 5, "line": 864}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "1c060e1d4782c879b9c95c6da2fc792f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 5, "line": 864}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "8c731991d1356147c6fe49993b09f412", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 5, "line": 890}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "b3a92f280f9f00ef7711f6c8cc6df9aa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 5, "line": 905}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "54ad37ffe12a289c4bba4fe36d95496c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 34, "file": 5, "line": 908}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "0634227c155649e5773891aea7fbf418", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 5, "line": 946}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "9bffb41bd7b400c24f9ded75d362f495", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 5, "line": 946}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "6d33d849a10340460b3d08fff4b795fb", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 5, "line": 1031}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "54ad37ffe12a289c4bba4fe36d95496c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 5, "line": 1057}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "5ef44614b2ff7365ea0dc566273f67a3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 5, "line": 1064}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "e57016442f7487caff204a5f1ccd2d9b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 5, "line": 1071}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "69e7f16d0b582c0d2837cffee4a270c4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 5, "line": 1071}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "485553ab8357db32deefeff35ae427b7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 27, "file": 5, "line": 1238}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "3a611c4916e4e10cf53ed8961e5c3179", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 23, "file": 5, "line": 1270}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "a14aebcbe6fefd740f3cee9c47d9f356", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 5, "line": 1278}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "fa664c44d23c6ca2e7ef7cadbba8b009", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 21, "file": 5, "line": 1293}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "fa664c44d23c6ca2e7ef7cadbba8b009", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 5, "line": 1374}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "9ea2e4f097330eb8b0e94cd6e04d9c12", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 5, "line": 1374}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "4f913710f89d242aeaeaa6f45da3f869", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 34, "file": 5, "line": 1458}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "1b5abb7389905b41e45bb9d64daa8de2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 5, "line": 1590}, "message": "destructor '~' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "aa56f2340de04b753a12501fff1d97d8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 5, "line": 1590}, "message": "move constructor '' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.cpp", "reportHash": "026d710b884f076eecb516478365f7df", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 6, "line": 73}, "message": "default constructor 'DebouncePolicy' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.h", "reportHash": "ef0821cfdab6410cb720d4ea0f0de86b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 6, "line": 95}, "message": "destructor '~ASTAction' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.h", "reportHash": "896bee682dbeabb384bfe1196b1dd736", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 6, "line": 112}, "message": "default constructor 'TUStatus' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.h", "reportHash": "2f96fdacb7c85d23bb957053809ff1ce", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 6, "line": 112}, "message": "destructor '~TUStatus' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.h", "reportHash": "a9d489b939e8ade9a839748cfdacc680", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 6, "line": 113}, "message": "default constructor 'BuildDetails' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.h", "reportHash": "72517c9334ec0f5f78789162ec9a9d0b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 6, "line": 113}, "message": "destructor '~BuildDetails' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.h", "reportHash": "65d01c1743062f8a0673a6fbdcecd043", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 6, "line": 209}, "message": "default constructor 'FileStats' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.h", "reportHash": "268bce214e95d041e782481b8193019c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 6, "line": 209}, "message": "move constructor 'FileStats' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/TUScheduler.h", "reportHash": "5e49ffa45ba5437d02838643e789d972", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 41}, "message": "destructor '~Semaphore' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Threading.h", "reportHash": "0e3414b2cf0241fb29a95e8cb6aa6551", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 58}, "message": "move assignment operator 'operator=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/support/Threading.h", "reportHash": "27eb74499322b6886d8774f1acdafb45", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
