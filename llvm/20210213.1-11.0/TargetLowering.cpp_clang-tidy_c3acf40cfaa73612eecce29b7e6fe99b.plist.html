<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp", "content": "//===-- TargetLowering.cpp - Implement the TargetLowering class -----------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This implements the TargetLowering class.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/CodeGen/TargetLowering.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/CodeGen/CallingConvLower.h\"\n#include \"llvm/CodeGen/MachineFrameInfo.h\"\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/MachineJumpTableInfo.h\"\n#include \"llvm/CodeGen/MachineRegisterInfo.h\"\n#include \"llvm/CodeGen/SelectionDAG.h\"\n#include \"llvm/CodeGen/TargetRegisterInfo.h\"\n#include \"llvm/CodeGen/TargetSubtargetInfo.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/GlobalVariable.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/MC/MCAsmInfo.h\"\n#include \"llvm/MC/MCExpr.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/KnownBits.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Target/TargetLoweringObjectFile.h\"\n#include \"llvm/Target/TargetMachine.h\"\n#include <cctype>\nusing namespace llvm;\n\n/// NOTE: The TargetMachine owns TLOF.\nTargetLowering::TargetLowering(const TargetMachine &tm)\n    : TargetLoweringBase(tm) {}\n\nconst char *TargetLowering::getTargetNodeName(unsigned Opcode) const {\n  return nullptr;\n}\n\nbool TargetLowering::isPositionIndependent() const {\n  return getTargetMachine().isPositionIndependent();\n}\n\n/// Check whether a given call node is in tail position within its function. If\n/// so, it sets Chain to the input chain of the tail call.\nbool TargetLowering::isInTailCallPosition(SelectionDAG &DAG, SDNode *Node,\n                                          SDValue &Chain) const {\n  const Function &F = DAG.getMachineFunction().getFunction();\n\n  // First, check if tail calls have been disabled in this function.\n  if (F.getFnAttribute(\"disable-tail-calls\").getValueAsString() == \"true\")\n    return false;\n\n  // Conservatively require the attributes of the call to match those of\n  // the return. Ignore NoAlias and NonNull because they don't affect the\n  // call sequence.\n  AttributeList CallerAttrs = F.getAttributes();\n  if (AttrBuilder(CallerAttrs, AttributeList::ReturnIndex)\n          .removeAttribute(Attribute::NoAlias)\n          .removeAttribute(Attribute::NonNull)\n          .hasAttributes())\n    return false;\n\n  // It's not safe to eliminate the sign / zero extension of the return value.\n  if (CallerAttrs.hasAttribute(AttributeList::ReturnIndex, Attribute::ZExt) ||\n      CallerAttrs.hasAttribute(AttributeList::ReturnIndex, Attribute::SExt))\n    return false;\n\n  // Check if the only use is a function return node.\n  return isUsedByReturnOnly(Node, Chain);\n}\n\nbool TargetLowering::parametersInCSRMatch(const MachineRegisterInfo &MRI,\n    const uint32_t *CallerPreservedMask,\n    const SmallVectorImpl<CCValAssign> &ArgLocs,\n    const SmallVectorImpl<SDValue> &OutVals) const {\n  for (unsigned I = 0, E = ArgLocs.size(); I != E; ++I) {\n    const CCValAssign &ArgLoc = ArgLocs[I];\n    if (!ArgLoc.isRegLoc())\n      continue;\n    MCRegister Reg = ArgLoc.getLocReg();\n    // Only look at callee saved registers.\n    if (MachineOperand::clobbersPhysReg(CallerPreservedMask, Reg))\n      continue;\n    // Check that we pass the value used for the caller.\n    // (We look for a CopyFromReg reading a virtual register that is used\n    //  for the function live-in value of register Reg)\n    SDValue Value = OutVals[I];\n    if (Value->getOpcode() != ISD::CopyFromReg)\n      return false;\n    Register ArgReg = cast<RegisterSDNode>(Value->getOperand(1))->getReg();\n    if (MRI.getLiveInPhysReg(ArgReg) != Reg)\n      return false;\n  }\n  return true;\n}\n\n/// Set CallLoweringInfo attribute flags based on a call instruction\n/// and called function attributes.\nvoid TargetLoweringBase::ArgListEntry::setAttributes(const CallBase *Call,\n                                                     unsigned ArgIdx) {\n  IsSExt = Call->paramHasAttr(ArgIdx, Attribute::SExt);\n  IsZExt = Call->paramHasAttr(ArgIdx, Attribute::ZExt);\n  IsInReg = Call->paramHasAttr(ArgIdx, Attribute::InReg);\n  IsSRet = Call->paramHasAttr(ArgIdx, Attribute::StructRet);\n  IsNest = Call->paramHasAttr(ArgIdx, Attribute::Nest);\n  IsByVal = Call->paramHasAttr(ArgIdx, Attribute::ByVal);\n  IsPreallocated = Call->paramHasAttr(ArgIdx, Attribute::Preallocated);\n  IsInAlloca = Call->paramHasAttr(ArgIdx, Attribute::InAlloca);\n  IsReturned = Call->paramHasAttr(ArgIdx, Attribute::Returned);\n  IsSwiftSelf = Call->paramHasAttr(ArgIdx, Attribute::SwiftSelf);\n  IsSwiftError = Call->paramHasAttr(ArgIdx, Attribute::SwiftError);\n  Alignment = Call->getParamAlign(ArgIdx);\n  ByValType = nullptr;\n  if (IsByVal)\n    ByValType = Call->getParamByValType(ArgIdx);\n  PreallocatedType = nullptr;\n  if (IsPreallocated)\n    PreallocatedType = Call->getParamPreallocatedType(ArgIdx);\n}\n\n/// Generate a libcall taking the given operands as arguments and returning a\n/// result of type RetVT.\nstd::pair<SDValue, SDValue>\nTargetLowering::makeLibCall(SelectionDAG &DAG, RTLIB::Libcall LC, EVT RetVT,\n                            ArrayRef<SDValue> Ops,\n                            MakeLibCallOptions CallOptions,\n                            const SDLoc &dl,\n                            SDValue InChain) const {\n  if (!InChain)\n    InChain = DAG.getEntryNode();\n\n  TargetLowering::ArgListTy Args;\n  Args.reserve(Ops.size());\n\n  TargetLowering::ArgListEntry Entry;\n  for (unsigned i = 0; i < Ops.size(); ++i) {\n    SDValue NewOp = Ops[i];\n    Entry.Node = NewOp;\n    Entry.Ty = Entry.Node.getValueType().getTypeForEVT(*DAG.getContext());\n    Entry.IsSExt = shouldSignExtendTypeInLibCall(NewOp.getValueType(),\n                                                 CallOptions.IsSExt);\n    Entry.IsZExt = !Entry.IsSExt;\n\n    if (CallOptions.IsSoften &&\n        !shouldExtendTypeInLibCall(CallOptions.OpsVTBeforeSoften[i])) {\n      Entry.IsSExt = Entry.IsZExt = false;\n    }\n    Args.push_back(Entry);\n  }\n\n  if (LC == RTLIB::UNKNOWN_LIBCALL)\n    report_fatal_error(\"Unsupported library call operation!\");\n  SDValue Callee = DAG.getExternalSymbol(getLibcallName(LC),\n                                         getPointerTy(DAG.getDataLayout()));\n\n  Type *RetTy = RetVT.getTypeForEVT(*DAG.getContext());\n  TargetLowering::CallLoweringInfo CLI(DAG);\n  bool signExtend = shouldSignExtendTypeInLibCall(RetVT, CallOptions.IsSExt);\n  bool zeroExtend = !signExtend;\n\n  if (CallOptions.IsSoften &&\n      !shouldExtendTypeInLibCall(CallOptions.RetVTBeforeSoften)) {\n    signExtend = zeroExtend = false;\n  }\n\n  CLI.setDebugLoc(dl)\n      .setChain(InChain)\n      .setLibCallee(getLibcallCallingConv(LC), RetTy, Callee, std::move(Args))\n      .setNoReturn(CallOptions.DoesNotReturn)\n      .setDiscardResult(!CallOptions.IsReturnValueUsed)\n      .setIsPostTypeLegalization(CallOptions.IsPostTypeLegalization)\n      .setSExtResult(signExtend)\n      .setZExtResult(zeroExtend);\n  return LowerCallTo(CLI);\n}\n\nbool TargetLowering::findOptimalMemOpLowering(\n    std::vector<EVT> &MemOps, unsigned Limit, const MemOp &Op, unsigned DstAS,\n    unsigned SrcAS, const AttributeList &FuncAttributes) const {\n  if (Op.isMemcpyWithFixedDstAlign() && Op.getSrcAlign() < Op.getDstAlign())\n    return false;\n\n  EVT VT = getOptimalMemOpType(Op, FuncAttributes);\n\n  if (VT == MVT::Other) {\n    // Use the largest integer type whose alignment constraints are satisfied.\n    // We only need to check DstAlign here as SrcAlign is always greater or\n    // equal to DstAlign (or zero).\n    VT = MVT::i64;\n    if (Op.isFixedDstAlign())\n      while (Op.getDstAlign() < (VT.getSizeInBits() / 8) &&\n             !allowsMisalignedMemoryAccesses(VT, DstAS, Op.getDstAlign()))\n        VT = (MVT::SimpleValueType)(VT.getSimpleVT().SimpleTy - 1);\n    assert(VT.isInteger());\n\n    // Find the largest legal integer type.\n    MVT LVT = MVT::i64;\n    while (!isTypeLegal(LVT))\n      LVT = (MVT::SimpleValueType)(LVT.SimpleTy - 1);\n    assert(LVT.isInteger());\n\n    // If the type we've chosen is larger than the largest legal integer type\n    // then use that instead.\n    if (VT.bitsGT(LVT))\n      VT = LVT;\n  }\n\n  unsigned NumMemOps = 0;\n  uint64_t Size = Op.size();\n  while (Size) {\n    unsigned VTSize = VT.getSizeInBits() / 8;\n    while (VTSize > Size) {\n      // For now, only use non-vector load / store's for the left-over pieces.\n      EVT NewVT = VT;\n      unsigned NewVTSize;\n\n      bool Found = false;\n      if (VT.isVector() || VT.isFloatingPoint()) {\n        NewVT = (VT.getSizeInBits() > 64) ? MVT::i64 : MVT::i32;\n        if (isOperationLegalOrCustom(ISD::STORE, NewVT) &&\n            isSafeMemOpType(NewVT.getSimpleVT()))\n          Found = true;\n        else if (NewVT == MVT::i64 &&\n                 isOperationLegalOrCustom(ISD::STORE, MVT::f64) &&\n                 isSafeMemOpType(MVT::f64)) {\n          // i64 is usually not legal on 32-bit targets, but f64 may be.\n          NewVT = MVT::f64;\n          Found = true;\n        }\n      }\n\n      if (!Found) {\n        do {\n          NewVT = (MVT::SimpleValueType)(NewVT.getSimpleVT().SimpleTy - 1);\n          if (NewVT == MVT::i8)\n            break;\n        } while (!isSafeMemOpType(NewVT.getSimpleVT()));\n      }\n      NewVTSize = NewVT.getSizeInBits() / 8;\n\n      // If the new VT cannot cover all of the remaining bits, then consider\n      // issuing a (or a pair of) unaligned and overlapping load / store.\n      bool Fast;\n      if (NumMemOps && Op.allowOverlap() && NewVTSize < Size &&\n          allowsMisalignedMemoryAccesses(\n              VT, DstAS, Op.isFixedDstAlign() ? Op.getDstAlign() : Align(1),\n              MachineMemOperand::MONone, &Fast) &&\n          Fast)\n        VTSize = Size;\n      else {\n        VT = NewVT;\n        VTSize = NewVTSize;\n      }\n    }\n\n    if (++NumMemOps > Limit)\n      return false;\n\n    MemOps.push_back(VT);\n    Size -= VTSize;\n  }\n\n  return true;\n}\n\n/// Soften the operands of a comparison. This code is shared among BR_CC,\n/// SELECT_CC, and SETCC handlers.\nvoid TargetLowering::softenSetCCOperands(SelectionDAG &DAG, EVT VT,\n                                         SDValue &NewLHS, SDValue &NewRHS,\n                                         ISD::CondCode &CCCode,\n                                         const SDLoc &dl, const SDValue OldLHS,\n                                         const SDValue OldRHS) const {\n  SDValue Chain;\n  return softenSetCCOperands(DAG, VT, NewLHS, NewRHS, CCCode, dl, OldLHS,\n                             OldRHS, Chain);\n}\n\nvoid TargetLowering::softenSetCCOperands(SelectionDAG &DAG, EVT VT,\n                                         SDValue &NewLHS, SDValue &NewRHS,\n                                         ISD::CondCode &CCCode,\n                                         const SDLoc &dl, const SDValue OldLHS,\n                                         const SDValue OldRHS,\n                                         SDValue &Chain,\n                                         bool IsSignaling) const {\n  // FIXME: Currently we cannot really respect all IEEE predicates due to libgcc\n  // not supporting it. We can update this code when libgcc provides such\n  // functions.\n\n  assert((VT == MVT::f32 || VT == MVT::f64 || VT == MVT::f128 || VT == MVT::ppcf128)\n         && \"Unsupported setcc type!\");\n\n  // Expand into one or more soft-fp libcall(s).\n  RTLIB::Libcall LC1 = RTLIB::UNKNOWN_LIBCALL, LC2 = RTLIB::UNKNOWN_LIBCALL;\n  bool ShouldInvertCC = false;\n  switch (CCCode) {\n  case ISD::SETEQ:\n  case ISD::SETOEQ:\n    LC1 = (VT == MVT::f32) ? RTLIB::OEQ_F32 :\n          (VT == MVT::f64) ? RTLIB::OEQ_F64 :\n          (VT == MVT::f128) ? RTLIB::OEQ_F128 : RTLIB::OEQ_PPCF128;\n    break;\n  case ISD::SETNE:\n  case ISD::SETUNE:\n    LC1 = (VT == MVT::f32) ? RTLIB::UNE_F32 :\n          (VT == MVT::f64) ? RTLIB::UNE_F64 :\n          (VT == MVT::f128) ? RTLIB::UNE_F128 : RTLIB::UNE_PPCF128;\n    break;\n  case ISD::SETGE:\n  case ISD::SETOGE:\n    LC1 = (VT == MVT::f32) ? RTLIB::OGE_F32 :\n          (VT == MVT::f64) ? RTLIB::OGE_F64 :\n          (VT == MVT::f128) ? RTLIB::OGE_F128 : RTLIB::OGE_PPCF128;\n    break;\n  case ISD::SETLT:\n  case ISD::SETOLT:\n    LC1 = (VT == MVT::f32) ? RTLIB::OLT_F32 :\n          (VT == MVT::f64) ? RTLIB::OLT_F64 :\n          (VT == MVT::f128) ? RTLIB::OLT_F128 : RTLIB::OLT_PPCF128;\n    break;\n  case ISD::SETLE:\n  case ISD::SETOLE:\n    LC1 = (VT == MVT::f32) ? RTLIB::OLE_F32 :\n          (VT == MVT::f64) ? RTLIB::OLE_F64 :\n          (VT == MVT::f128) ? RTLIB::OLE_F128 : RTLIB::OLE_PPCF128;\n    break;\n  case ISD::SETGT:\n  case ISD::SETOGT:\n    LC1 = (VT == MVT::f32) ? RTLIB::OGT_F32 :\n          (VT == MVT::f64) ? RTLIB::OGT_F64 :\n          (VT == MVT::f128) ? RTLIB::OGT_F128 : RTLIB::OGT_PPCF128;\n    break;\n  case ISD::SETO:\n    ShouldInvertCC = true;\n    LLVM_FALLTHROUGH;\n  case ISD::SETUO:\n    LC1 = (VT == MVT::f32) ? RTLIB::UO_F32 :\n          (VT == MVT::f64) ? RTLIB::UO_F64 :\n          (VT == MVT::f128) ? RTLIB::UO_F128 : RTLIB::UO_PPCF128;\n    break;\n  case ISD::SETONE:\n    // SETONE = O && UNE\n    ShouldInvertCC = true;\n    LLVM_FALLTHROUGH;\n  case ISD::SETUEQ:\n    LC1 = (VT == MVT::f32) ? RTLIB::UO_F32 :\n          (VT == MVT::f64) ? RTLIB::UO_F64 :\n          (VT == MVT::f128) ? RTLIB::UO_F128 : RTLIB::UO_PPCF128;\n    LC2 = (VT == MVT::f32) ? RTLIB::OEQ_F32 :\n          (VT == MVT::f64) ? RTLIB::OEQ_F64 :\n          (VT == MVT::f128) ? RTLIB::OEQ_F128 : RTLIB::OEQ_PPCF128;\n    break;\n  default:\n    // Invert CC for unordered comparisons\n    ShouldInvertCC = true;\n    switch (CCCode) {\n    case ISD::SETULT:\n      LC1 = (VT == MVT::f32) ? RTLIB::OGE_F32 :\n            (VT == MVT::f64) ? RTLIB::OGE_F64 :\n            (VT == MVT::f128) ? RTLIB::OGE_F128 : RTLIB::OGE_PPCF128;\n      break;\n    case ISD::SETULE:\n      LC1 = (VT == MVT::f32) ? RTLIB::OGT_F32 :\n            (VT == MVT::f64) ? RTLIB::OGT_F64 :\n            (VT == MVT::f128) ? RTLIB::OGT_F128 : RTLIB::OGT_PPCF128;\n      break;\n    case ISD::SETUGT:\n      LC1 = (VT == MVT::f32) ? RTLIB::OLE_F32 :\n            (VT == MVT::f64) ? RTLIB::OLE_F64 :\n            (VT == MVT::f128) ? RTLIB::OLE_F128 : RTLIB::OLE_PPCF128;\n      break;\n    case ISD::SETUGE:\n      LC1 = (VT == MVT::f32) ? RTLIB::OLT_F32 :\n            (VT == MVT::f64) ? RTLIB::OLT_F64 :\n            (VT == MVT::f128) ? RTLIB::OLT_F128 : RTLIB::OLT_PPCF128;\n      break;\n    default: llvm_unreachable(\"Do not know how to soften this setcc!\");\n    }\n  }\n\n  // Use the target specific return value for comparions lib calls.\n  EVT RetVT = getCmpLibcallReturnType();\n  SDValue Ops[2] = {NewLHS, NewRHS};\n  TargetLowering::MakeLibCallOptions CallOptions;\n  EVT OpsVT[2] = { OldLHS.getValueType(),\n                   OldRHS.getValueType() };\n  CallOptions.setTypeListBeforeSoften(OpsVT, RetVT, true);\n  auto Call = makeLibCall(DAG, LC1, RetVT, Ops, CallOptions, dl, Chain);\n  NewLHS = Call.first;\n  NewRHS = DAG.getConstant(0, dl, RetVT);\n\n  CCCode = getCmpLibcallCC(LC1);\n  if (ShouldInvertCC) {\n    assert(RetVT.isInteger());\n    CCCode = getSetCCInverse(CCCode, RetVT);\n  }\n\n  if (LC2 == RTLIB::UNKNOWN_LIBCALL) {\n    // Update Chain.\n    Chain = Call.second;\n  } else {\n    EVT SetCCVT =\n        getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), RetVT);\n    SDValue Tmp = DAG.getSetCC(dl, SetCCVT, NewLHS, NewRHS, CCCode);\n    auto Call2 = makeLibCall(DAG, LC2, RetVT, Ops, CallOptions, dl, Chain);\n    CCCode = getCmpLibcallCC(LC2);\n    if (ShouldInvertCC)\n      CCCode = getSetCCInverse(CCCode, RetVT);\n    NewLHS = DAG.getSetCC(dl, SetCCVT, Call2.first, NewRHS, CCCode);\n    if (Chain)\n      Chain = DAG.getNode(ISD::TokenFactor, dl, MVT::Other, Call.second,\n                          Call2.second);\n    NewLHS = DAG.getNode(ShouldInvertCC ? ISD::AND : ISD::OR, dl,\n                         Tmp.getValueType(), Tmp, NewLHS);\n    NewRHS = SDValue();\n  }\n}\n\n/// Return the entry encoding for a jump table in the current function. The\n/// returned value is a member of the MachineJumpTableInfo::JTEntryKind enum.\nunsigned TargetLowering::getJumpTableEncoding() const {\n  // In non-pic modes, just use the address of a block.\n  if (!isPositionIndependent())\n    return MachineJumpTableInfo::EK_BlockAddress;\n\n  // In PIC mode, if the target supports a GPRel32 directive, use it.\n  if (getTargetMachine().getMCAsmInfo()->getGPRel32Directive() != nullptr)\n    return MachineJumpTableInfo::EK_GPRel32BlockAddress;\n\n  // Otherwise, use a label difference.\n  return MachineJumpTableInfo::EK_LabelDifference32;\n}\n\nSDValue TargetLowering::getPICJumpTableRelocBase(SDValue Table,\n                                                 SelectionDAG &DAG) const {\n  // If our PIC model is GP relative, use the global offset table as the base.\n  unsigned JTEncoding = getJumpTableEncoding();\n\n  if ((JTEncoding == MachineJumpTableInfo::EK_GPRel64BlockAddress) ||\n      (JTEncoding == MachineJumpTableInfo::EK_GPRel32BlockAddress))\n    return DAG.getGLOBAL_OFFSET_TABLE(getPointerTy(DAG.getDataLayout()));\n\n  return Table;\n}\n\n/// This returns the relocation base for the given PIC jumptable, the same as\n/// getPICJumpTableRelocBase, but as an MCExpr.\nconst MCExpr *\nTargetLowering::getPICJumpTableRelocBaseExpr(const MachineFunction *MF,\n                                             unsigned JTI,MCContext &Ctx) const{\n  // The normal PIC reloc base is the label at the start of the jump table.\n  return MCSymbolRefExpr::create(MF->getJTISymbol(JTI, Ctx), Ctx);\n}\n\nbool\nTargetLowering::isOffsetFoldingLegal(const GlobalAddressSDNode *GA) const {\n  const TargetMachine &TM = getTargetMachine();\n  const GlobalValue *GV = GA->getGlobal();\n\n  // If the address is not even local to this DSO we will have to load it from\n  // a got and then add the offset.\n  if (!TM.shouldAssumeDSOLocal(*GV->getParent(), GV))\n    return false;\n\n  // If the code is position independent we will have to add a base register.\n  if (isPositionIndependent())\n    return false;\n\n  // Otherwise we can do it.\n  return true;\n}\n\n//===----------------------------------------------------------------------===//\n//  Optimization Methods\n//===----------------------------------------------------------------------===//\n\n/// If the specified instruction has a constant integer operand and there are\n/// bits set in that constant that are not demanded, then clear those bits and\n/// return true.\nbool TargetLowering::ShrinkDemandedConstant(SDValue Op,\n                                            const APInt &DemandedBits,\n                                            const APInt &DemandedElts,\n                                            TargetLoweringOpt &TLO) const {\n  SDLoc DL(Op);\n  unsigned Opcode = Op.getOpcode();\n\n  // Do target-specific constant optimization.\n  if (targetShrinkDemandedConstant(Op, DemandedBits, DemandedElts, TLO))\n    return TLO.New.getNode();\n\n  // FIXME: ISD::SELECT, ISD::SELECT_CC\n  switch (Opcode) {\n  default:\n    break;\n  case ISD::XOR:\n  case ISD::AND:\n  case ISD::OR: {\n    auto *Op1C = dyn_cast<ConstantSDNode>(Op.getOperand(1));\n    if (!Op1C)\n      return false;\n\n    // If this is a 'not' op, don't touch it because that's a canonical form.\n    const APInt &C = Op1C->getAPIntValue();\n    if (Opcode == ISD::XOR && DemandedBits.isSubsetOf(C))\n      return false;\n\n    if (!C.isSubsetOf(DemandedBits)) {\n      EVT VT = Op.getValueType();\n      SDValue NewC = TLO.DAG.getConstant(DemandedBits & C, DL, VT);\n      SDValue NewOp = TLO.DAG.getNode(Opcode, DL, VT, Op.getOperand(0), NewC);\n      return TLO.CombineTo(Op, NewOp);\n    }\n\n    break;\n  }\n  }\n\n  return false;\n}\n\nbool TargetLowering::ShrinkDemandedConstant(SDValue Op,\n                                            const APInt &DemandedBits,\n                                            TargetLoweringOpt &TLO) const {\n  EVT VT = Op.getValueType();\n  APInt DemandedElts = VT.isVector()\n                           ? APInt::getAllOnesValue(VT.getVectorNumElements())\n                           : APInt(1, 1);\n  return ShrinkDemandedConstant(Op, DemandedBits, DemandedElts, TLO);\n}\n\n/// Convert x+y to (VT)((SmallVT)x+(SmallVT)y) if the casts are free.\n/// This uses isZExtFree and ZERO_EXTEND for the widening cast, but it could be\n/// generalized for targets with other types of implicit widening casts.\nbool TargetLowering::ShrinkDemandedOp(SDValue Op, unsigned BitWidth,\n                                      const APInt &Demanded,\n                                      TargetLoweringOpt &TLO) const {\n  assert(Op.getNumOperands() == 2 &&\n         \"ShrinkDemandedOp only supports binary operators!\");\n  assert(Op.getNode()->getNumValues() == 1 &&\n         \"ShrinkDemandedOp only supports nodes with one result!\");\n\n  SelectionDAG &DAG = TLO.DAG;\n  SDLoc dl(Op);\n\n  // Early return, as this function cannot handle vector types.\n  if (Op.getValueType().isVector())\n    return false;\n\n  // Don't do this if the node has another user, which may require the\n  // full value.\n  if (!Op.getNode()->hasOneUse())\n    return false;\n\n  // Search for the smallest integer type with free casts to and from\n  // Op's type. For expedience, just check power-of-2 integer types.\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  unsigned DemandedSize = Demanded.getActiveBits();\n  unsigned SmallVTBits = DemandedSize;\n  if (!isPowerOf2_32(SmallVTBits))\n    SmallVTBits = NextPowerOf2(SmallVTBits);\n  for (; SmallVTBits < BitWidth; SmallVTBits = NextPowerOf2(SmallVTBits)) {\n    EVT SmallVT = EVT::getIntegerVT(*DAG.getContext(), SmallVTBits);\n    if (TLI.isTruncateFree(Op.getValueType(), SmallVT) &&\n        TLI.isZExtFree(SmallVT, Op.getValueType())) {\n      // We found a type with free casts.\n      SDValue X = DAG.getNode(\n          Op.getOpcode(), dl, SmallVT,\n          DAG.getNode(ISD::TRUNCATE, dl, SmallVT, Op.getOperand(0)),\n          DAG.getNode(ISD::TRUNCATE, dl, SmallVT, Op.getOperand(1)));\n      assert(DemandedSize <= SmallVTBits && \"Narrowed below demanded bits?\");\n      SDValue Z = DAG.getNode(ISD::ANY_EXTEND, dl, Op.getValueType(), X);\n      return TLO.CombineTo(Op, Z);\n    }\n  }\n  return false;\n}\n\nbool TargetLowering::SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,\n                                          DAGCombinerInfo &DCI) const {\n  SelectionDAG &DAG = DCI.DAG;\n  TargetLoweringOpt TLO(DAG, !DCI.isBeforeLegalize(),\n                        !DCI.isBeforeLegalizeOps());\n  KnownBits Known;\n\n  bool Simplified = SimplifyDemandedBits(Op, DemandedBits, Known, TLO);\n  if (Simplified) {\n    DCI.AddToWorklist(Op.getNode());\n    DCI.CommitTargetLoweringOpt(TLO);\n  }\n  return Simplified;\n}\n\nbool TargetLowering::SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,\n                                          KnownBits &Known,\n                                          TargetLoweringOpt &TLO,\n                                          unsigned Depth,\n                                          bool AssumeSingleUse) const {\n  EVT VT = Op.getValueType();\n\n  // TODO: We can probably do more work on calculating the known bits and\n  // simplifying the operations for scalable vectors, but for now we just\n  // bail out.\n  if (VT.isScalableVector()) {\n    // Pretend we don't know anything for now.\n    Known = KnownBits(DemandedBits.getBitWidth());\n    return false;\n  }\n\n  APInt DemandedElts = VT.isVector()\n                           ? APInt::getAllOnesValue(VT.getVectorNumElements())\n                           : APInt(1, 1);\n  return SimplifyDemandedBits(Op, DemandedBits, DemandedElts, Known, TLO, Depth,\n                              AssumeSingleUse);\n}\n\n// TODO: Can we merge SelectionDAG::GetDemandedBits into this?\n// TODO: Under what circumstances can we create nodes? Constant folding?\nSDValue TargetLowering::SimplifyMultipleUseDemandedBits(\n    SDValue Op, const APInt &DemandedBits, const APInt &DemandedElts,\n    SelectionDAG &DAG, unsigned Depth) const {\n  // Limit search depth.\n  if (Depth >= SelectionDAG::MaxRecursionDepth)\n    return SDValue();\n\n  // Ignore UNDEFs.\n  if (Op.isUndef())\n    return SDValue();\n\n  // Not demanding any bits/elts from Op.\n  if (DemandedBits == 0 || DemandedElts == 0)\n    return DAG.getUNDEF(Op.getValueType());\n\n  unsigned NumElts = DemandedElts.getBitWidth();\n  unsigned BitWidth = DemandedBits.getBitWidth();\n  KnownBits LHSKnown, RHSKnown;\n  switch (Op.getOpcode()) {\n  case ISD::BITCAST: {\n    SDValue Src = peekThroughBitcasts(Op.getOperand(0));\n    EVT SrcVT = Src.getValueType();\n    EVT DstVT = Op.getValueType();\n    if (SrcVT == DstVT)\n      return Src;\n\n    unsigned NumSrcEltBits = SrcVT.getScalarSizeInBits();\n    unsigned NumDstEltBits = DstVT.getScalarSizeInBits();\n    if (NumSrcEltBits == NumDstEltBits)\n      if (SDValue V = SimplifyMultipleUseDemandedBits(\n              Src, DemandedBits, DemandedElts, DAG, Depth + 1))\n        return DAG.getBitcast(DstVT, V);\n\n    // TODO - bigendian once we have test coverage.\n    if (SrcVT.isVector() && (NumDstEltBits % NumSrcEltBits) == 0 &&\n        DAG.getDataLayout().isLittleEndian()) {\n      unsigned Scale = NumDstEltBits / NumSrcEltBits;\n      unsigned NumSrcElts = SrcVT.getVectorNumElements();\n      APInt DemandedSrcBits = APInt::getNullValue(NumSrcEltBits);\n      APInt DemandedSrcElts = APInt::getNullValue(NumSrcElts);\n      for (unsigned i = 0; i != Scale; ++i) {\n        unsigned Offset = i * NumSrcEltBits;\n        APInt Sub = DemandedBits.extractBits(NumSrcEltBits, Offset);\n        if (!Sub.isNullValue()) {\n          DemandedSrcBits |= Sub;\n          for (unsigned j = 0; j != NumElts; ++j)\n            if (DemandedElts[j])\n              DemandedSrcElts.setBit((j * Scale) + i);\n        }\n      }\n\n      if (SDValue V = SimplifyMultipleUseDemandedBits(\n              Src, DemandedSrcBits, DemandedSrcElts, DAG, Depth + 1))\n        return DAG.getBitcast(DstVT, V);\n    }\n\n    // TODO - bigendian once we have test coverage.\n    if ((NumSrcEltBits % NumDstEltBits) == 0 &&\n        DAG.getDataLayout().isLittleEndian()) {\n      unsigned Scale = NumSrcEltBits / NumDstEltBits;\n      unsigned NumSrcElts = SrcVT.isVector() ? SrcVT.getVectorNumElements() : 1;\n      APInt DemandedSrcBits = APInt::getNullValue(NumSrcEltBits);\n      APInt DemandedSrcElts = APInt::getNullValue(NumSrcElts);\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (DemandedElts[i]) {\n          unsigned Offset = (i % Scale) * NumDstEltBits;\n          DemandedSrcBits.insertBits(DemandedBits, Offset);\n          DemandedSrcElts.setBit(i / Scale);\n        }\n\n      if (SDValue V = SimplifyMultipleUseDemandedBits(\n              Src, DemandedSrcBits, DemandedSrcElts, DAG, Depth + 1))\n        return DAG.getBitcast(DstVT, V);\n    }\n\n    break;\n  }\n  case ISD::AND: {\n    LHSKnown = DAG.computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    RHSKnown = DAG.computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n\n    // If all of the demanded bits are known 1 on one side, return the other.\n    // These bits cannot contribute to the result of the 'and' in this\n    // context.\n    if (DemandedBits.isSubsetOf(LHSKnown.Zero | RHSKnown.One))\n      return Op.getOperand(0);\n    if (DemandedBits.isSubsetOf(RHSKnown.Zero | LHSKnown.One))\n      return Op.getOperand(1);\n    break;\n  }\n  case ISD::OR: {\n    LHSKnown = DAG.computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    RHSKnown = DAG.computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n\n    // If all of the demanded bits are known zero on one side, return the\n    // other.  These bits cannot contribute to the result of the 'or' in this\n    // context.\n    if (DemandedBits.isSubsetOf(LHSKnown.One | RHSKnown.Zero))\n      return Op.getOperand(0);\n    if (DemandedBits.isSubsetOf(RHSKnown.One | LHSKnown.Zero))\n      return Op.getOperand(1);\n    break;\n  }\n  case ISD::XOR: {\n    LHSKnown = DAG.computeKnownBits(Op.getOperand(0), DemandedElts, Depth + 1);\n    RHSKnown = DAG.computeKnownBits(Op.getOperand(1), DemandedElts, Depth + 1);\n\n    // If all of the demanded bits are known zero on one side, return the\n    // other.\n    if (DemandedBits.isSubsetOf(RHSKnown.Zero))\n      return Op.getOperand(0);\n    if (DemandedBits.isSubsetOf(LHSKnown.Zero))\n      return Op.getOperand(1);\n    break;\n  }\n  case ISD::SHL: {\n    // If we are only demanding sign bits then we can use the shift source\n    // directly.\n    if (const APInt *MaxSA =\n            DAG.getValidMaximumShiftAmountConstant(Op, DemandedElts)) {\n      SDValue Op0 = Op.getOperand(0);\n      unsigned ShAmt = MaxSA->getZExtValue();\n      unsigned NumSignBits =\n          DAG.ComputeNumSignBits(Op0, DemandedElts, Depth + 1);\n      unsigned UpperDemandedBits = BitWidth - DemandedBits.countTrailingZeros();\n      if (NumSignBits > ShAmt && (NumSignBits - ShAmt) >= (UpperDemandedBits))\n        return Op0;\n    }\n    break;\n  }\n  case ISD::SETCC: {\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n    ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(2))->get();\n    // If (1) we only need the sign-bit, (2) the setcc operands are the same\n    // width as the setcc result, and (3) the result of a setcc conforms to 0 or\n    // -1, we may be able to bypass the setcc.\n    if (DemandedBits.isSignMask() &&\n        Op0.getScalarValueSizeInBits() == BitWidth &&\n        getBooleanContents(Op0.getValueType()) ==\n            BooleanContent::ZeroOrNegativeOneBooleanContent) {\n      // If we're testing X < 0, then this compare isn't needed - just use X!\n      // FIXME: We're limiting to integer types here, but this should also work\n      // if we don't care about FP signed-zero. The use of SETLT with FP means\n      // that we don't care about NaNs.\n      if (CC == ISD::SETLT && Op1.getValueType().isInteger() &&\n          (isNullConstant(Op1) || ISD::isBuildVectorAllZeros(Op1.getNode())))\n        return Op0;\n    }\n    break;\n  }\n  case ISD::SIGN_EXTEND_INREG: {\n    // If none of the extended bits are demanded, eliminate the sextinreg.\n    SDValue Op0 = Op.getOperand(0);\n    EVT ExVT = cast<VTSDNode>(Op.getOperand(1))->getVT();\n    unsigned ExBits = ExVT.getScalarSizeInBits();\n    if (DemandedBits.getActiveBits() <= ExBits)\n      return Op0;\n    // If the input is already sign extended, just drop the extension.\n    unsigned NumSignBits = DAG.ComputeNumSignBits(Op0, DemandedElts, Depth + 1);\n    if (NumSignBits >= (BitWidth - ExBits + 1))\n      return Op0;\n    break;\n  }\n  case ISD::ANY_EXTEND_VECTOR_INREG:\n  case ISD::SIGN_EXTEND_VECTOR_INREG:\n  case ISD::ZERO_EXTEND_VECTOR_INREG: {\n    // If we only want the lowest element and none of extended bits, then we can\n    // return the bitcasted source vector.\n    SDValue Src = Op.getOperand(0);\n    EVT SrcVT = Src.getValueType();\n    EVT DstVT = Op.getValueType();\n    if (DemandedElts == 1 && DstVT.getSizeInBits() == SrcVT.getSizeInBits() &&\n        DAG.getDataLayout().isLittleEndian() &&\n        DemandedBits.getActiveBits() <= SrcVT.getScalarSizeInBits()) {\n      return DAG.getBitcast(DstVT, Src);\n    }\n    break;\n  }\n  case ISD::INSERT_VECTOR_ELT: {\n    // If we don't demand the inserted element, return the base vector.\n    SDValue Vec = Op.getOperand(0);\n    auto *CIdx = dyn_cast<ConstantSDNode>(Op.getOperand(2));\n    EVT VecVT = Vec.getValueType();\n    if (CIdx && CIdx->getAPIntValue().ult(VecVT.getVectorNumElements()) &&\n        !DemandedElts[CIdx->getZExtValue()])\n      return Vec;\n    break;\n  }\n  case ISD::INSERT_SUBVECTOR: {\n    // If we don't demand the inserted subvector, return the base vector.\n    SDValue Vec = Op.getOperand(0);\n    SDValue Sub = Op.getOperand(1);\n    uint64_t Idx = Op.getConstantOperandVal(2);\n    unsigned NumSubElts = Sub.getValueType().getVectorNumElements();\n    if (DemandedElts.extractBits(NumSubElts, Idx) == 0)\n      return Vec;\n    break;\n  }\n  case ISD::VECTOR_SHUFFLE: {\n    ArrayRef<int> ShuffleMask = cast<ShuffleVectorSDNode>(Op)->getMask();\n\n    // If all the demanded elts are from one operand and are inline,\n    // then we can use the operand directly.\n    bool AllUndef = true, IdentityLHS = true, IdentityRHS = true;\n    for (unsigned i = 0; i != NumElts; ++i) {\n      int M = ShuffleMask[i];\n      if (M < 0 || !DemandedElts[i])\n        continue;\n      AllUndef = false;\n      IdentityLHS &= (M == (int)i);\n      IdentityRHS &= ((M - NumElts) == i);\n    }\n\n    if (AllUndef)\n      return DAG.getUNDEF(Op.getValueType());\n    if (IdentityLHS)\n      return Op.getOperand(0);\n    if (IdentityRHS)\n      return Op.getOperand(1);\n    break;\n  }\n  default:\n    if (Op.getOpcode() >= ISD::BUILTIN_OP_END)\n      if (SDValue V = SimplifyMultipleUseDemandedBitsForTargetNode(\n              Op, DemandedBits, DemandedElts, DAG, Depth))\n        return V;\n    break;\n  }\n  return SDValue();\n}\n\nSDValue TargetLowering::SimplifyMultipleUseDemandedBits(\n    SDValue Op, const APInt &DemandedBits, SelectionDAG &DAG,\n    unsigned Depth) const {\n  EVT VT = Op.getValueType();\n  APInt DemandedElts = VT.isVector()\n                           ? APInt::getAllOnesValue(VT.getVectorNumElements())\n                           : APInt(1, 1);\n  return SimplifyMultipleUseDemandedBits(Op, DemandedBits, DemandedElts, DAG,\n                                         Depth);\n}\n\nSDValue TargetLowering::SimplifyMultipleUseDemandedVectorElts(\n    SDValue Op, const APInt &DemandedElts, SelectionDAG &DAG,\n    unsigned Depth) const {\n  APInt DemandedBits = APInt::getAllOnesValue(Op.getScalarValueSizeInBits());\n  return SimplifyMultipleUseDemandedBits(Op, DemandedBits, DemandedElts, DAG,\n                                         Depth);\n}\n\n/// Look at Op. At this point, we know that only the OriginalDemandedBits of the\n/// result of Op are ever used downstream. If we can use this information to\n/// simplify Op, create a new simplified DAG node and return true, returning the\n/// original and new nodes in Old and New. Otherwise, analyze the expression and\n/// return a mask of Known bits for the expression (used to simplify the\n/// caller).  The Known bits may only be accurate for those bits in the\n/// OriginalDemandedBits and OriginalDemandedElts.\nbool TargetLowering::SimplifyDemandedBits(\n    SDValue Op, const APInt &OriginalDemandedBits,\n    const APInt &OriginalDemandedElts, KnownBits &Known, TargetLoweringOpt &TLO,\n    unsigned Depth, bool AssumeSingleUse) const {\n  unsigned BitWidth = OriginalDemandedBits.getBitWidth();\n  assert(Op.getScalarValueSizeInBits() == BitWidth &&\n         \"Mask size mismatches value type size!\");\n\n  // Don't know anything.\n  Known = KnownBits(BitWidth);\n\n  // TODO: We can probably do more work on calculating the known bits and\n  // simplifying the operations for scalable vectors, but for now we just\n  // bail out.\n  if (Op.getValueType().isScalableVector())\n    return false;\n\n  unsigned NumElts = OriginalDemandedElts.getBitWidth();\n  assert((!Op.getValueType().isVector() ||\n          NumElts == Op.getValueType().getVectorNumElements()) &&\n         \"Unexpected vector size\");\n\n  APInt DemandedBits = OriginalDemandedBits;\n  APInt DemandedElts = OriginalDemandedElts;\n  SDLoc dl(Op);\n  auto &DL = TLO.DAG.getDataLayout();\n\n  // Undef operand.\n  if (Op.isUndef())\n    return false;\n\n  if (Op.getOpcode() == ISD::Constant) {\n    // We know all of the bits for a constant!\n    Known = KnownBits::makeConstant(cast<ConstantSDNode>(Op)->getAPIntValue());\n    return false;\n  }\n\n  if (Op.getOpcode() == ISD::ConstantFP) {\n    // We know all of the bits for a floating point constant!\n    Known = KnownBits::makeConstant(\n        cast<ConstantFPSDNode>(Op)->getValueAPF().bitcastToAPInt());\n    return false;\n  }\n\n  // Other users may use these bits.\n  EVT VT = Op.getValueType();\n  if (!Op.getNode()->hasOneUse() && !AssumeSingleUse) {\n    if (Depth != 0) {\n      // If not at the root, Just compute the Known bits to\n      // simplify things downstream.\n      Known = TLO.DAG.computeKnownBits(Op, DemandedElts, Depth);\n      return false;\n    }\n    // If this is the root being simplified, allow it to have multiple uses,\n    // just set the DemandedBits/Elts to all bits.\n    DemandedBits = APInt::getAllOnesValue(BitWidth);\n    DemandedElts = APInt::getAllOnesValue(NumElts);\n  } else if (OriginalDemandedBits == 0 || OriginalDemandedElts == 0) {\n    // Not demanding any bits/elts from Op.\n    return TLO.CombineTo(Op, TLO.DAG.getUNDEF(VT));\n  } else if (Depth >= SelectionDAG::MaxRecursionDepth) {\n    // Limit search depth.\n    return false;\n  }\n\n  KnownBits Known2;\n  switch (Op.getOpcode()) {\n  case ISD::TargetConstant:\n    llvm_unreachable(\"Can't simplify this node\");\n  case ISD::SCALAR_TO_VECTOR: {\n    if (!DemandedElts[0])\n      return TLO.CombineTo(Op, TLO.DAG.getUNDEF(VT));\n\n    KnownBits SrcKnown;\n    SDValue Src = Op.getOperand(0);\n    unsigned SrcBitWidth = Src.getScalarValueSizeInBits();\n    APInt SrcDemandedBits = DemandedBits.zextOrSelf(SrcBitWidth);\n    if (SimplifyDemandedBits(Src, SrcDemandedBits, SrcKnown, TLO, Depth + 1))\n      return true;\n\n    // Upper elements are undef, so only get the knownbits if we just demand\n    // the bottom element.\n    if (DemandedElts == 1)\n      Known = SrcKnown.anyextOrTrunc(BitWidth);\n    break;\n  }\n  case ISD::BUILD_VECTOR:\n    // Collect the known bits that are shared by every demanded element.\n    // TODO: Call SimplifyDemandedBits for non-constant demanded elements.\n    Known = TLO.DAG.computeKnownBits(Op, DemandedElts, Depth);\n    return false; // Don't fall through, will infinitely loop.\n  case ISD::LOAD: {\n    LoadSDNode *LD = cast<LoadSDNode>(Op);\n    if (getTargetConstantFromLoad(LD)) {\n      Known = TLO.DAG.computeKnownBits(Op, DemandedElts, Depth);\n      return false; // Don't fall through, will infinitely loop.\n    } else if (ISD::isZEXTLoad(Op.getNode()) && Op.getResNo() == 0) {\n      // If this is a ZEXTLoad and we are looking at the loaded value.\n      EVT MemVT = LD->getMemoryVT();\n      unsigned MemBits = MemVT.getScalarSizeInBits();\n      Known.Zero.setBitsFrom(MemBits);\n      return false; // Don't fall through, will infinitely loop.\n    }\n    break;\n  }\n  case ISD::INSERT_VECTOR_ELT: {\n    SDValue Vec = Op.getOperand(0);\n    SDValue Scl = Op.getOperand(1);\n    auto *CIdx = dyn_cast<ConstantSDNode>(Op.getOperand(2));\n    EVT VecVT = Vec.getValueType();\n\n    // If index isn't constant, assume we need all vector elements AND the\n    // inserted element.\n    APInt DemandedVecElts(DemandedElts);\n    if (CIdx && CIdx->getAPIntValue().ult(VecVT.getVectorNumElements())) {\n      unsigned Idx = CIdx->getZExtValue();\n      DemandedVecElts.clearBit(Idx);\n\n      // Inserted element is not required.\n      if (!DemandedElts[Idx])\n        return TLO.CombineTo(Op, Vec);\n    }\n\n    KnownBits KnownScl;\n    unsigned NumSclBits = Scl.getScalarValueSizeInBits();\n    APInt DemandedSclBits = DemandedBits.zextOrTrunc(NumSclBits);\n    if (SimplifyDemandedBits(Scl, DemandedSclBits, KnownScl, TLO, Depth + 1))\n      return true;\n\n    Known = KnownScl.anyextOrTrunc(BitWidth);\n\n    KnownBits KnownVec;\n    if (SimplifyDemandedBits(Vec, DemandedBits, DemandedVecElts, KnownVec, TLO,\n                             Depth + 1))\n      return true;\n\n    if (!!DemandedVecElts)\n      Known = KnownBits::commonBits(Known, KnownVec);\n\n    return false;\n  }\n  case ISD::INSERT_SUBVECTOR: {\n    // Demand any elements from the subvector and the remainder from the src its\n    // inserted into.\n    SDValue Src = Op.getOperand(0);\n    SDValue Sub = Op.getOperand(1);\n    uint64_t Idx = Op.getConstantOperandVal(2);\n    unsigned NumSubElts = Sub.getValueType().getVectorNumElements();\n    APInt DemandedSubElts = DemandedElts.extractBits(NumSubElts, Idx);\n    APInt DemandedSrcElts = DemandedElts;\n    DemandedSrcElts.insertBits(APInt::getNullValue(NumSubElts), Idx);\n\n    KnownBits KnownSub, KnownSrc;\n    if (SimplifyDemandedBits(Sub, DemandedBits, DemandedSubElts, KnownSub, TLO,\n                             Depth + 1))\n      return true;\n    if (SimplifyDemandedBits(Src, DemandedBits, DemandedSrcElts, KnownSrc, TLO,\n                             Depth + 1))\n      return true;\n\n    Known.Zero.setAllBits();\n    Known.One.setAllBits();\n    if (!!DemandedSubElts)\n      Known = KnownBits::commonBits(Known, KnownSub);\n    if (!!DemandedSrcElts)\n      Known = KnownBits::commonBits(Known, KnownSrc);\n\n    // Attempt to avoid multi-use src if we don't need anything from it.\n    if (!DemandedBits.isAllOnesValue() || !DemandedSubElts.isAllOnesValue() ||\n        !DemandedSrcElts.isAllOnesValue()) {\n      SDValue NewSub = SimplifyMultipleUseDemandedBits(\n          Sub, DemandedBits, DemandedSubElts, TLO.DAG, Depth + 1);\n      SDValue NewSrc = SimplifyMultipleUseDemandedBits(\n          Src, DemandedBits, DemandedSrcElts, TLO.DAG, Depth + 1);\n      if (NewSub || NewSrc) {\n        NewSub = NewSub ? NewSub : Sub;\n        NewSrc = NewSrc ? NewSrc : Src;\n        SDValue NewOp = TLO.DAG.getNode(Op.getOpcode(), dl, VT, NewSrc, NewSub,\n                                        Op.getOperand(2));\n        return TLO.CombineTo(Op, NewOp);\n      }\n    }\n    break;\n  }\n  case ISD::EXTRACT_SUBVECTOR: {\n    // Offset the demanded elts by the subvector index.\n    SDValue Src = Op.getOperand(0);\n    if (Src.getValueType().isScalableVector())\n      break;\n    uint64_t Idx = Op.getConstantOperandVal(1);\n    unsigned NumSrcElts = Src.getValueType().getVectorNumElements();\n    APInt DemandedSrcElts = DemandedElts.zextOrSelf(NumSrcElts).shl(Idx);\n\n    if (SimplifyDemandedBits(Src, DemandedBits, DemandedSrcElts, Known, TLO,\n                             Depth + 1))\n      return true;\n\n    // Attempt to avoid multi-use src if we don't need anything from it.\n    if (!DemandedBits.isAllOnesValue() || !DemandedSrcElts.isAllOnesValue()) {\n      SDValue DemandedSrc = SimplifyMultipleUseDemandedBits(\n          Src, DemandedBits, DemandedSrcElts, TLO.DAG, Depth + 1);\n      if (DemandedSrc) {\n        SDValue NewOp = TLO.DAG.getNode(Op.getOpcode(), dl, VT, DemandedSrc,\n                                        Op.getOperand(1));\n        return TLO.CombineTo(Op, NewOp);\n      }\n    }\n    break;\n  }\n  case ISD::CONCAT_VECTORS: {\n    Known.Zero.setAllBits();\n    Known.One.setAllBits();\n    EVT SubVT = Op.getOperand(0).getValueType();\n    unsigned NumSubVecs = Op.getNumOperands();\n    unsigned NumSubElts = SubVT.getVectorNumElements();\n    for (unsigned i = 0; i != NumSubVecs; ++i) {\n      APInt DemandedSubElts =\n          DemandedElts.extractBits(NumSubElts, i * NumSubElts);\n      if (SimplifyDemandedBits(Op.getOperand(i), DemandedBits, DemandedSubElts,\n                               Known2, TLO, Depth + 1))\n        return true;\n      // Known bits are shared by every demanded subvector element.\n      if (!!DemandedSubElts)\n        Known = KnownBits::commonBits(Known, Known2);\n    }\n    break;\n  }\n  case ISD::VECTOR_SHUFFLE: {\n    ArrayRef<int> ShuffleMask = cast<ShuffleVectorSDNode>(Op)->getMask();\n\n    // Collect demanded elements from shuffle operands..\n    APInt DemandedLHS(NumElts, 0);\n    APInt DemandedRHS(NumElts, 0);\n    for (unsigned i = 0; i != NumElts; ++i) {\n      if (!DemandedElts[i])\n        continue;\n      int M = ShuffleMask[i];\n      if (M < 0) {\n        // For UNDEF elements, we don't know anything about the common state of\n        // the shuffle result.\n        DemandedLHS.clearAllBits();\n        DemandedRHS.clearAllBits();\n        break;\n      }\n      assert(0 <= M && M < (int)(2 * NumElts) && \"Shuffle index out of range\");\n      if (M < (int)NumElts)\n        DemandedLHS.setBit(M);\n      else\n        DemandedRHS.setBit(M - NumElts);\n    }\n\n    if (!!DemandedLHS || !!DemandedRHS) {\n      SDValue Op0 = Op.getOperand(0);\n      SDValue Op1 = Op.getOperand(1);\n\n      Known.Zero.setAllBits();\n      Known.One.setAllBits();\n      if (!!DemandedLHS) {\n        if (SimplifyDemandedBits(Op0, DemandedBits, DemandedLHS, Known2, TLO,\n                                 Depth + 1))\n          return true;\n        Known = KnownBits::commonBits(Known, Known2);\n      }\n      if (!!DemandedRHS) {\n        if (SimplifyDemandedBits(Op1, DemandedBits, DemandedRHS, Known2, TLO,\n                                 Depth + 1))\n          return true;\n        Known = KnownBits::commonBits(Known, Known2);\n      }\n\n      // Attempt to avoid multi-use ops if we don't need anything from them.\n      SDValue DemandedOp0 = SimplifyMultipleUseDemandedBits(\n          Op0, DemandedBits, DemandedLHS, TLO.DAG, Depth + 1);\n      SDValue DemandedOp1 = SimplifyMultipleUseDemandedBits(\n          Op1, DemandedBits, DemandedRHS, TLO.DAG, Depth + 1);\n      if (DemandedOp0 || DemandedOp1) {\n        Op0 = DemandedOp0 ? DemandedOp0 : Op0;\n        Op1 = DemandedOp1 ? DemandedOp1 : Op1;\n        SDValue NewOp = TLO.DAG.getVectorShuffle(VT, dl, Op0, Op1, ShuffleMask);\n        return TLO.CombineTo(Op, NewOp);\n      }\n    }\n    break;\n  }\n  case ISD::AND: {\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n\n    // If the RHS is a constant, check to see if the LHS would be zero without\n    // using the bits from the RHS.  Below, we use knowledge about the RHS to\n    // simplify the LHS, here we're using information from the LHS to simplify\n    // the RHS.\n    if (ConstantSDNode *RHSC = isConstOrConstSplat(Op1)) {\n      // Do not increment Depth here; that can cause an infinite loop.\n      KnownBits LHSKnown = TLO.DAG.computeKnownBits(Op0, DemandedElts, Depth);\n      // If the LHS already has zeros where RHSC does, this 'and' is dead.\n      if ((LHSKnown.Zero & DemandedBits) ==\n          (~RHSC->getAPIntValue() & DemandedBits))\n        return TLO.CombineTo(Op, Op0);\n\n      // If any of the set bits in the RHS are known zero on the LHS, shrink\n      // the constant.\n      if (ShrinkDemandedConstant(Op, ~LHSKnown.Zero & DemandedBits,\n                                 DemandedElts, TLO))\n        return true;\n\n      // Bitwise-not (xor X, -1) is a special case: we don't usually shrink its\n      // constant, but if this 'and' is only clearing bits that were just set by\n      // the xor, then this 'and' can be eliminated by shrinking the mask of\n      // the xor. For example, for a 32-bit X:\n      // and (xor (srl X, 31), -1), 1 --> xor (srl X, 31), 1\n      if (isBitwiseNot(Op0) && Op0.hasOneUse() &&\n          LHSKnown.One == ~RHSC->getAPIntValue()) {\n        SDValue Xor = TLO.DAG.getNode(ISD::XOR, dl, VT, Op0.getOperand(0), Op1);\n        return TLO.CombineTo(Op, Xor);\n      }\n    }\n\n    if (SimplifyDemandedBits(Op1, DemandedBits, DemandedElts, Known, TLO,\n                             Depth + 1))\n      return true;\n    assert(!Known.hasConflict() && \"Bits known to be one AND zero?\");\n    if (SimplifyDemandedBits(Op0, ~Known.Zero & DemandedBits, DemandedElts,\n                             Known2, TLO, Depth + 1))\n      return true;\n    assert(!Known2.hasConflict() && \"Bits known to be one AND zero?\");\n\n    // Attempt to avoid multi-use ops if we don't need anything from them.\n    if (!DemandedBits.isAllOnesValue() || !DemandedElts.isAllOnesValue()) {\n      SDValue DemandedOp0 = SimplifyMultipleUseDemandedBits(\n          Op0, DemandedBits, DemandedElts, TLO.DAG, Depth + 1);\n      SDValue DemandedOp1 = SimplifyMultipleUseDemandedBits(\n          Op1, DemandedBits, DemandedElts, TLO.DAG, Depth + 1);\n      if (DemandedOp0 || DemandedOp1) {\n        Op0 = DemandedOp0 ? DemandedOp0 : Op0;\n        Op1 = DemandedOp1 ? DemandedOp1 : Op1;\n        SDValue NewOp = TLO.DAG.getNode(Op.getOpcode(), dl, VT, Op0, Op1);\n        return TLO.CombineTo(Op, NewOp);\n      }\n    }\n\n    // If all of the demanded bits are known one on one side, return the other.\n    // These bits cannot contribute to the result of the 'and'.\n    if (DemandedBits.isSubsetOf(Known2.Zero | Known.One))\n      return TLO.CombineTo(Op, Op0);\n    if (DemandedBits.isSubsetOf(Known.Zero | Known2.One))\n      return TLO.CombineTo(Op, Op1);\n    // If all of the demanded bits in the inputs are known zeros, return zero.\n    if (DemandedBits.isSubsetOf(Known.Zero | Known2.Zero))\n      return TLO.CombineTo(Op, TLO.DAG.getConstant(0, dl, VT));\n    // If the RHS is a constant, see if we can simplify it.\n    if (ShrinkDemandedConstant(Op, ~Known2.Zero & DemandedBits, DemandedElts,\n                               TLO))\n      return true;\n    // If the operation can be done in a smaller type, do so.\n    if (ShrinkDemandedOp(Op, BitWidth, DemandedBits, TLO))\n      return true;\n\n    Known &= Known2;\n    break;\n  }\n  case ISD::OR: {\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n\n    if (SimplifyDemandedBits(Op1, DemandedBits, DemandedElts, Known, TLO,\n                             Depth + 1))\n      return true;\n    assert(!Known.hasConflict() && \"Bits known to be one AND zero?\");\n    if (SimplifyDemandedBits(Op0, ~Known.One & DemandedBits, DemandedElts,\n                             Known2, TLO, Depth + 1))\n      return true;\n    assert(!Known2.hasConflict() && \"Bits known to be one AND zero?\");\n\n    // Attempt to avoid multi-use ops if we don't need anything from them.\n    if (!DemandedBits.isAllOnesValue() || !DemandedElts.isAllOnesValue()) {\n      SDValue DemandedOp0 = SimplifyMultipleUseDemandedBits(\n          Op0, DemandedBits, DemandedElts, TLO.DAG, Depth + 1);\n      SDValue DemandedOp1 = SimplifyMultipleUseDemandedBits(\n          Op1, DemandedBits, DemandedElts, TLO.DAG, Depth + 1);\n      if (DemandedOp0 || DemandedOp1) {\n        Op0 = DemandedOp0 ? DemandedOp0 : Op0;\n        Op1 = DemandedOp1 ? DemandedOp1 : Op1;\n        SDValue NewOp = TLO.DAG.getNode(Op.getOpcode(), dl, VT, Op0, Op1);\n        return TLO.CombineTo(Op, NewOp);\n      }\n    }\n\n    // If all of the demanded bits are known zero on one side, return the other.\n    // These bits cannot contribute to the result of the 'or'.\n    if (DemandedBits.isSubsetOf(Known2.One | Known.Zero))\n      return TLO.CombineTo(Op, Op0);\n    if (DemandedBits.isSubsetOf(Known.One | Known2.Zero))\n      return TLO.CombineTo(Op, Op1);\n    // If the RHS is a constant, see if we can simplify it.\n    if (ShrinkDemandedConstant(Op, DemandedBits, DemandedElts, TLO))\n      return true;\n    // If the operation can be done in a smaller type, do so.\n    if (ShrinkDemandedOp(Op, BitWidth, DemandedBits, TLO))\n      return true;\n\n    Known |= Known2;\n    break;\n  }\n  case ISD::XOR: {\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n\n    if (SimplifyDemandedBits(Op1, DemandedBits, DemandedElts, Known, TLO,\n                             Depth + 1))\n      return true;\n    assert(!Known.hasConflict() && \"Bits known to be one AND zero?\");\n    if (SimplifyDemandedBits(Op0, DemandedBits, DemandedElts, Known2, TLO,\n                             Depth + 1))\n      return true;\n    assert(!Known2.hasConflict() && \"Bits known to be one AND zero?\");\n\n    // Attempt to avoid multi-use ops if we don't need anything from them.\n    if (!DemandedBits.isAllOnesValue() || !DemandedElts.isAllOnesValue()) {\n      SDValue DemandedOp0 = SimplifyMultipleUseDemandedBits(\n          Op0, DemandedBits, DemandedElts, TLO.DAG, Depth + 1);\n      SDValue DemandedOp1 = SimplifyMultipleUseDemandedBits(\n          Op1, DemandedBits, DemandedElts, TLO.DAG, Depth + 1);\n      if (DemandedOp0 || DemandedOp1) {\n        Op0 = DemandedOp0 ? DemandedOp0 : Op0;\n        Op1 = DemandedOp1 ? DemandedOp1 : Op1;\n        SDValue NewOp = TLO.DAG.getNode(Op.getOpcode(), dl, VT, Op0, Op1);\n        return TLO.CombineTo(Op, NewOp);\n      }\n    }\n\n    // If all of the demanded bits are known zero on one side, return the other.\n    // These bits cannot contribute to the result of the 'xor'.\n    if (DemandedBits.isSubsetOf(Known.Zero))\n      return TLO.CombineTo(Op, Op0);\n    if (DemandedBits.isSubsetOf(Known2.Zero))\n      return TLO.CombineTo(Op, Op1);\n    // If the operation can be done in a smaller type, do so.\n    if (ShrinkDemandedOp(Op, BitWidth, DemandedBits, TLO))\n      return true;\n\n    // If all of the unknown bits are known to be zero on one side or the other\n    // turn this into an *inclusive* or.\n    //    e.g. (A & C1)^(B & C2) -> (A & C1)|(B & C2) iff C1&C2 == 0\n    if (DemandedBits.isSubsetOf(Known.Zero | Known2.Zero))\n      return TLO.CombineTo(Op, TLO.DAG.getNode(ISD::OR, dl, VT, Op0, Op1));\n\n    ConstantSDNode* C = isConstOrConstSplat(Op1, DemandedElts);\n    if (C) {\n      // If one side is a constant, and all of the set bits in the constant are\n      // also known set on the other side, turn this into an AND, as we know\n      // the bits will be cleared.\n      //    e.g. (X | C1) ^ C2 --> (X | C1) & ~C2 iff (C1&C2) == C2\n      // NB: it is okay if more bits are known than are requested\n      if (C->getAPIntValue() == Known2.One) {\n        SDValue ANDC =\n            TLO.DAG.getConstant(~C->getAPIntValue() & DemandedBits, dl, VT);\n        return TLO.CombineTo(Op, TLO.DAG.getNode(ISD::AND, dl, VT, Op0, ANDC));\n      }\n\n      // If the RHS is a constant, see if we can change it. Don't alter a -1\n      // constant because that's a 'not' op, and that is better for combining\n      // and codegen.\n      if (!C->isAllOnesValue() &&\n          DemandedBits.isSubsetOf(C->getAPIntValue())) {\n        // We're flipping all demanded bits. Flip the undemanded bits too.\n        SDValue New = TLO.DAG.getNOT(dl, Op0, VT);\n        return TLO.CombineTo(Op, New);\n      }\n    }\n\n    // If we can't turn this into a 'not', try to shrink the constant.\n    if (!C || !C->isAllOnesValue())\n      if (ShrinkDemandedConstant(Op, DemandedBits, DemandedElts, TLO))\n        return true;\n\n    Known ^= Known2;\n    break;\n  }\n  case ISD::SELECT:\n    if (SimplifyDemandedBits(Op.getOperand(2), DemandedBits, Known, TLO,\n                             Depth + 1))\n      return true;\n    if (SimplifyDemandedBits(Op.getOperand(1), DemandedBits, Known2, TLO,\n                             Depth + 1))\n      return true;\n    assert(!Known.hasConflict() && \"Bits known to be one AND zero?\");\n    assert(!Known2.hasConflict() && \"Bits known to be one AND zero?\");\n\n    // If the operands are constants, see if we can simplify them.\n    if (ShrinkDemandedConstant(Op, DemandedBits, DemandedElts, TLO))\n      return true;\n\n    // Only known if known in both the LHS and RHS.\n    Known = KnownBits::commonBits(Known, Known2);\n    break;\n  case ISD::SELECT_CC:\n    if (SimplifyDemandedBits(Op.getOperand(3), DemandedBits, Known, TLO,\n                             Depth + 1))\n      return true;\n    if (SimplifyDemandedBits(Op.getOperand(2), DemandedBits, Known2, TLO,\n                             Depth + 1))\n      return true;\n    assert(!Known.hasConflict() && \"Bits known to be one AND zero?\");\n    assert(!Known2.hasConflict() && \"Bits known to be one AND zero?\");\n\n    // If the operands are constants, see if we can simplify them.\n    if (ShrinkDemandedConstant(Op, DemandedBits, DemandedElts, TLO))\n      return true;\n\n    // Only known if known in both the LHS and RHS.\n    Known = KnownBits::commonBits(Known, Known2);\n    break;\n  case ISD::SETCC: {\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n    ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(2))->get();\n    // If (1) we only need the sign-bit, (2) the setcc operands are the same\n    // width as the setcc result, and (3) the result of a setcc conforms to 0 or\n    // -1, we may be able to bypass the setcc.\n    if (DemandedBits.isSignMask() &&\n        Op0.getScalarValueSizeInBits() == BitWidth &&\n        getBooleanContents(Op0.getValueType()) ==\n            BooleanContent::ZeroOrNegativeOneBooleanContent) {\n      // If we're testing X < 0, then this compare isn't needed - just use X!\n      // FIXME: We're limiting to integer types here, but this should also work\n      // if we don't care about FP signed-zero. The use of SETLT with FP means\n      // that we don't care about NaNs.\n      if (CC == ISD::SETLT && Op1.getValueType().isInteger() &&\n          (isNullConstant(Op1) || ISD::isBuildVectorAllZeros(Op1.getNode())))\n        return TLO.CombineTo(Op, Op0);\n\n      // TODO: Should we check for other forms of sign-bit comparisons?\n      // Examples: X <= -1, X >= 0\n    }\n    if (getBooleanContents(Op0.getValueType()) ==\n            TargetLowering::ZeroOrOneBooleanContent &&\n        BitWidth > 1)\n      Known.Zero.setBitsFrom(1);\n    break;\n  }\n  case ISD::SHL: {\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n    EVT ShiftVT = Op1.getValueType();\n\n    if (const APInt *SA =\n            TLO.DAG.getValidShiftAmountConstant(Op, DemandedElts)) {\n      unsigned ShAmt = SA->getZExtValue();\n      if (ShAmt == 0)\n        return TLO.CombineTo(Op, Op0);\n\n      // If this is ((X >>u C1) << ShAmt), see if we can simplify this into a\n      // single shift.  We can do this if the bottom bits (which are shifted\n      // out) are never demanded.\n      // TODO - support non-uniform vector amounts.\n      if (Op0.getOpcode() == ISD::SRL) {\n        if (!DemandedBits.intersects(APInt::getLowBitsSet(BitWidth, ShAmt))) {\n          if (const APInt *SA2 =\n                  TLO.DAG.getValidShiftAmountConstant(Op0, DemandedElts)) {\n            unsigned C1 = SA2->getZExtValue();\n            unsigned Opc = ISD::SHL;\n            int Diff = ShAmt - C1;\n            if (Diff < 0) {\n              Diff = -Diff;\n              Opc = ISD::SRL;\n            }\n            SDValue NewSA = TLO.DAG.getConstant(Diff, dl, ShiftVT);\n            return TLO.CombineTo(\n                Op, TLO.DAG.getNode(Opc, dl, VT, Op0.getOperand(0), NewSA));\n          }\n        }\n      }\n\n      // Convert (shl (anyext x, c)) to (anyext (shl x, c)) if the high bits\n      // are not demanded. This will likely allow the anyext to be folded away.\n      // TODO - support non-uniform vector amounts.\n      if (Op0.getOpcode() == ISD::ANY_EXTEND) {\n        SDValue InnerOp = Op0.getOperand(0);\n        EVT InnerVT = InnerOp.getValueType();\n        unsigned InnerBits = InnerVT.getScalarSizeInBits();\n        if (ShAmt < InnerBits && DemandedBits.getActiveBits() <= InnerBits &&\n            isTypeDesirableForOp(ISD::SHL, InnerVT)) {\n          EVT ShTy = getShiftAmountTy(InnerVT, DL);\n          if (!APInt(BitWidth, ShAmt).isIntN(ShTy.getSizeInBits()))\n            ShTy = InnerVT;\n          SDValue NarrowShl =\n              TLO.DAG.getNode(ISD::SHL, dl, InnerVT, InnerOp,\n                              TLO.DAG.getConstant(ShAmt, dl, ShTy));\n          return TLO.CombineTo(\n              Op, TLO.DAG.getNode(ISD::ANY_EXTEND, dl, VT, NarrowShl));\n        }\n\n        // Repeat the SHL optimization above in cases where an extension\n        // intervenes: (shl (anyext (shr x, c1)), c2) to\n        // (shl (anyext x), c2-c1).  This requires that the bottom c1 bits\n        // aren't demanded (as above) and that the shifted upper c1 bits of\n        // x aren't demanded.\n        // TODO - support non-uniform vector amounts.\n        if (Op0.hasOneUse() && InnerOp.getOpcode() == ISD::SRL &&\n            InnerOp.hasOneUse()) {\n          if (const APInt *SA2 =\n                  TLO.DAG.getValidShiftAmountConstant(InnerOp, DemandedElts)) {\n            unsigned InnerShAmt = SA2->getZExtValue();\n            if (InnerShAmt < ShAmt && InnerShAmt < InnerBits &&\n                DemandedBits.getActiveBits() <=\n                    (InnerBits - InnerShAmt + ShAmt) &&\n                DemandedBits.countTrailingZeros() >= ShAmt) {\n              SDValue NewSA =\n                  TLO.DAG.getConstant(ShAmt - InnerShAmt, dl, ShiftVT);\n              SDValue NewExt = TLO.DAG.getNode(ISD::ANY_EXTEND, dl, VT,\n                                               InnerOp.getOperand(0));\n              return TLO.CombineTo(\n                  Op, TLO.DAG.getNode(ISD::SHL, dl, VT, NewExt, NewSA));\n            }\n          }\n        }\n      }\n\n      APInt InDemandedMask = DemandedBits.lshr(ShAmt);\n      if (SimplifyDemandedBits(Op0, InDemandedMask, DemandedElts, Known, TLO,\n                               Depth + 1))\n        return true;\n      assert(!Known.hasConflict() && \"Bits known to be one AND zero?\");\n      Known.Zero <<= ShAmt;\n      Known.One <<= ShAmt;\n      // low bits known zero.\n      Known.Zero.setLowBits(ShAmt);\n\n      // Try shrinking the operation as long as the shift amount will still be\n      // in range.\n      if ((ShAmt < DemandedBits.getActiveBits()) &&\n          ShrinkDemandedOp(Op, BitWidth, DemandedBits, TLO))\n        return true;\n    }\n\n    // If we are only demanding sign bits then we can use the shift source\n    // directly.\n    if (const APInt *MaxSA =\n            TLO.DAG.getValidMaximumShiftAmountConstant(Op, DemandedElts)) {\n      unsigned ShAmt = MaxSA->getZExtValue();\n      unsigned NumSignBits =\n          TLO.DAG.ComputeNumSignBits(Op0, DemandedElts, Depth + 1);\n      unsigned UpperDemandedBits = BitWidth - DemandedBits.countTrailingZeros();\n      if (NumSignBits > ShAmt && (NumSignBits - ShAmt) >= (UpperDemandedBits))\n        return TLO.CombineTo(Op, Op0);\n    }\n    break;\n  }\n  case ISD::SRL: {\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n    EVT ShiftVT = Op1.getValueType();\n\n    if (const APInt *SA =\n            TLO.DAG.getValidShiftAmountConstant(Op, DemandedElts)) {\n      unsigned ShAmt = SA->getZExtValue();\n      if (ShAmt == 0)\n        return TLO.CombineTo(Op, Op0);\n\n      // If this is ((X << C1) >>u ShAmt), see if we can simplify this into a\n      // single shift.  We can do this if the top bits (which are shifted out)\n      // are never demanded.\n      // TODO - support non-uniform vector amounts.\n      if (Op0.getOpcode() == ISD::SHL) {\n        if (!DemandedBits.intersects(APInt::getHighBitsSet(BitWidth, ShAmt))) {\n          if (const APInt *SA2 =\n                  TLO.DAG.getValidShiftAmountConstant(Op0, DemandedElts)) {\n            unsigned C1 = SA2->getZExtValue();\n            unsigned Opc = ISD::SRL;\n            int Diff = ShAmt - C1;\n            if (Diff < 0) {\n              Diff = -Diff;\n              Opc = ISD::SHL;\n            }\n            SDValue NewSA = TLO.DAG.getConstant(Diff, dl, ShiftVT);\n            return TLO.CombineTo(\n                Op, TLO.DAG.getNode(Opc, dl, VT, Op0.getOperand(0), NewSA));\n          }\n        }\n      }\n\n      APInt InDemandedMask = (DemandedBits << ShAmt);\n\n      // If the shift is exact, then it does demand the low bits (and knows that\n      // they are zero).\n      if (Op->getFlags().hasExact())\n        InDemandedMask.setLowBits(ShAmt);\n\n      // Compute the new bits that are at the top now.\n      if (SimplifyDemandedBits(Op0, InDemandedMask, DemandedElts, Known, TLO,\n                               Depth + 1))\n        return true;\n      assert(!Known.hasConflict() && \"Bits known to be one AND zero?\");\n      Known.Zero.lshrInPlace(ShAmt);\n      Known.One.lshrInPlace(ShAmt);\n      // High bits known zero.\n      Known.Zero.setHighBits(ShAmt);\n    }\n    break;\n  }\n  case ISD::SRA: {\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n    EVT ShiftVT = Op1.getValueType();\n\n    // If we only want bits that already match the signbit then we don't need\n    // to shift.\n    unsigned NumHiDemandedBits = BitWidth - DemandedBits.countTrailingZeros();\n    if (TLO.DAG.ComputeNumSignBits(Op0, DemandedElts, Depth + 1) >=\n        NumHiDemandedBits)\n      return TLO.CombineTo(Op, Op0);\n\n    // If this is an arithmetic shift right and only the low-bit is set, we can\n    // always convert this into a logical shr, even if the shift amount is\n    // variable.  The low bit of the shift cannot be an input sign bit unless\n    // the shift amount is >= the size of the datatype, which is undefined.\n    if (DemandedBits.isOneValue())\n      return TLO.CombineTo(Op, TLO.DAG.getNode(ISD::SRL, dl, VT, Op0, Op1));\n\n    if (const APInt *SA =\n            TLO.DAG.getValidShiftAmountConstant(Op, DemandedElts)) {\n      unsigned ShAmt = SA->getZExtValue();\n      if (ShAmt == 0)\n        return TLO.CombineTo(Op, Op0);\n\n      APInt InDemandedMask = (DemandedBits << ShAmt);\n\n      // If the shift is exact, then it does demand the low bits (and knows that\n      // they are zero).\n      if (Op->getFlags().hasExact())\n        InDemandedMask.setLowBits(ShAmt);\n\n      // If any of the demanded bits are produced by the sign extension, we also\n      // demand the input sign bit.\n      if (DemandedBits.countLeadingZeros() < ShAmt)\n        InDemandedMask.setSignBit();\n\n      if (SimplifyDemandedBits(Op0, InDemandedMask, DemandedElts, Known, TLO,\n                               Depth + 1))\n        return true;\n      assert(!Known.hasConflict() && \"Bits known to be one AND zero?\");\n      Known.Zero.lshrInPlace(ShAmt);\n      Known.One.lshrInPlace(ShAmt);\n\n      // If the input sign bit is known to be zero, or if none of the top bits\n      // are demanded, turn this into an unsigned shift right.\n      if (Known.Zero[BitWidth - ShAmt - 1] ||\n          DemandedBits.countLeadingZeros() >= ShAmt) {\n        SDNodeFlags Flags;\n        Flags.setExact(Op->getFlags().hasExact());\n        return TLO.CombineTo(\n            Op, TLO.DAG.getNode(ISD::SRL, dl, VT, Op0, Op1, Flags));\n      }\n\n      int Log2 = DemandedBits.exactLogBase2();\n      if (Log2 >= 0) {\n        // The bit must come from the sign.\n        SDValue NewSA = TLO.DAG.getConstant(BitWidth - 1 - Log2, dl, ShiftVT);\n        return TLO.CombineTo(Op, TLO.DAG.getNode(ISD::SRL, dl, VT, Op0, NewSA));\n      }\n\n      if (Known.One[BitWidth - ShAmt - 1])\n        // New bits are known one.\n        Known.One.setHighBits(ShAmt);\n\n      // Attempt to avoid multi-use ops if we don't need anything from them.\n      if (!InDemandedMask.isAllOnesValue() || !DemandedElts.isAllOnesValue()) {\n        SDValue DemandedOp0 = SimplifyMultipleUseDemandedBits(\n            Op0, InDemandedMask, DemandedElts, TLO.DAG, Depth + 1);\n        if (DemandedOp0) {\n          SDValue NewOp = TLO.DAG.getNode(ISD::SRA, dl, VT, DemandedOp0, Op1);\n          return TLO.CombineTo(Op, NewOp);\n        }\n      }\n    }\n    break;\n  }\n  case ISD::FSHL:\n  case ISD::FSHR: {\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n    SDValue Op2 = Op.getOperand(2);\n    bool IsFSHL = (Op.getOpcode() == ISD::FSHL);\n\n    if (ConstantSDNode *SA = isConstOrConstSplat(Op2, DemandedElts)) {\n      unsigned Amt = SA->getAPIntValue().urem(BitWidth);\n\n      // For fshl, 0-shift returns the 1st arg.\n      // For fshr, 0-shift returns the 2nd arg.\n      if (Amt == 0) {\n        if (SimplifyDemandedBits(IsFSHL ? Op0 : Op1, DemandedBits, DemandedElts,\n                                 Known, TLO, Depth + 1))\n          return true;\n        break;\n      }\n\n      // fshl: (Op0 << Amt) | (Op1 >> (BW - Amt))\n      // fshr: (Op0 << (BW - Amt)) | (Op1 >> Amt)\n      APInt Demanded0 = DemandedBits.lshr(IsFSHL ? Amt : (BitWidth - Amt));\n      APInt Demanded1 = DemandedBits << (IsFSHL ? (BitWidth - Amt) : Amt);\n      if (SimplifyDemandedBits(Op0, Demanded0, DemandedElts, Known2, TLO,\n                               Depth + 1))\n        return true;\n      if (SimplifyDemandedBits(Op1, Demanded1, DemandedElts, Known, TLO,\n                               Depth + 1))\n        return true;\n\n      Known2.One <<= (IsFSHL ? Amt : (BitWidth - Amt));\n      Known2.Zero <<= (IsFSHL ? Amt : (BitWidth - Amt));\n      Known.One.lshrInPlace(IsFSHL ? (BitWidth - Amt) : Amt);\n      Known.Zero.lshrInPlace(IsFSHL ? (BitWidth - Amt) : Amt);\n      Known.One |= Known2.One;\n      Known.Zero |= Known2.Zero;\n    }\n\n    // For pow-2 bitwidths we only demand the bottom modulo amt bits.\n    if (isPowerOf2_32(BitWidth)) {\n      APInt DemandedAmtBits(Op2.getScalarValueSizeInBits(), BitWidth - 1);\n      if (SimplifyDemandedBits(Op2, DemandedAmtBits, DemandedElts,\n                               Known2, TLO, Depth + 1))\n        return true;\n    }\n    break;\n  }\n  case ISD::ROTL:\n  case ISD::ROTR: {\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n\n    // If we're rotating an 0/-1 value, then it stays an 0/-1 value.\n    if (BitWidth == TLO.DAG.ComputeNumSignBits(Op0, DemandedElts, Depth + 1))\n      return TLO.CombineTo(Op, Op0);\n\n    // For pow-2 bitwidths we only demand the bottom modulo amt bits.\n    if (isPowerOf2_32(BitWidth)) {\n      APInt DemandedAmtBits(Op1.getScalarValueSizeInBits(), BitWidth - 1);\n      if (SimplifyDemandedBits(Op1, DemandedAmtBits, DemandedElts, Known2, TLO,\n                               Depth + 1))\n        return true;\n    }\n    break;\n  }\n  case ISD::UMIN: {\n    // Check if one arg is always less than (or equal) to the other arg.\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n    KnownBits Known0 = TLO.DAG.computeKnownBits(Op0, DemandedElts, Depth + 1);\n    KnownBits Known1 = TLO.DAG.computeKnownBits(Op1, DemandedElts, Depth + 1);\n    Known = KnownBits::umin(Known0, Known1);\n    if (Optional<bool> IsULE = KnownBits::ule(Known0, Known1))\n      return TLO.CombineTo(Op, IsULE.getValue() ? Op0 : Op1);\n    if (Optional<bool> IsULT = KnownBits::ult(Known0, Known1))\n      return TLO.CombineTo(Op, IsULT.getValue() ? Op0 : Op1);\n    break;\n  }\n  case ISD::UMAX: {\n    // Check if one arg is always greater than (or equal) to the other arg.\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n    KnownBits Known0 = TLO.DAG.computeKnownBits(Op0, DemandedElts, Depth + 1);\n    KnownBits Known1 = TLO.DAG.computeKnownBits(Op1, DemandedElts, Depth + 1);\n    Known = KnownBits::umax(Known0, Known1);\n    if (Optional<bool> IsUGE = KnownBits::uge(Known0, Known1))\n      return TLO.CombineTo(Op, IsUGE.getValue() ? Op0 : Op1);\n    if (Optional<bool> IsUGT = KnownBits::ugt(Known0, Known1))\n      return TLO.CombineTo(Op, IsUGT.getValue() ? Op0 : Op1);\n    break;\n  }\n  case ISD::BITREVERSE: {\n    SDValue Src = Op.getOperand(0);\n    APInt DemandedSrcBits = DemandedBits.reverseBits();\n    if (SimplifyDemandedBits(Src, DemandedSrcBits, DemandedElts, Known2, TLO,\n                             Depth + 1))\n      return true;\n    Known.One = Known2.One.reverseBits();\n    Known.Zero = Known2.Zero.reverseBits();\n    break;\n  }\n  case ISD::BSWAP: {\n    SDValue Src = Op.getOperand(0);\n    APInt DemandedSrcBits = DemandedBits.byteSwap();\n    if (SimplifyDemandedBits(Src, DemandedSrcBits, DemandedElts, Known2, TLO,\n                             Depth + 1))\n      return true;\n    Known.One = Known2.One.byteSwap();\n    Known.Zero = Known2.Zero.byteSwap();\n    break;\n  }\n  case ISD::CTPOP: {\n    // If only 1 bit is demanded, replace with PARITY as long as we're before\n    // op legalization.\n    // FIXME: Limit to scalars for now.\n    if (DemandedBits.isOneValue() && !TLO.LegalOps && !VT.isVector())\n      return TLO.CombineTo(Op, TLO.DAG.getNode(ISD::PARITY, dl, VT,\n                                               Op.getOperand(0)));\n\n    Known = TLO.DAG.computeKnownBits(Op, DemandedElts, Depth);\n    break;\n  }\n  case ISD::SIGN_EXTEND_INREG: {\n    SDValue Op0 = Op.getOperand(0);\n    EVT ExVT = cast<VTSDNode>(Op.getOperand(1))->getVT();\n    unsigned ExVTBits = ExVT.getScalarSizeInBits();\n\n    // If we only care about the highest bit, don't bother shifting right.\n    if (DemandedBits.isSignMask()) {\n      unsigned NumSignBits =\n          TLO.DAG.ComputeNumSignBits(Op0, DemandedElts, Depth + 1);\n      bool AlreadySignExtended = NumSignBits >= BitWidth - ExVTBits + 1;\n      // However if the input is already sign extended we expect the sign\n      // extension to be dropped altogether later and do not simplify.\n      if (!AlreadySignExtended) {\n        // Compute the correct shift amount type, which must be getShiftAmountTy\n        // for scalar types after legalization.\n        EVT ShiftAmtTy = VT;\n        if (TLO.LegalTypes() && !ShiftAmtTy.isVector())\n          ShiftAmtTy = getShiftAmountTy(ShiftAmtTy, DL);\n\n        SDValue ShiftAmt =\n            TLO.DAG.getConstant(BitWidth - ExVTBits, dl, ShiftAmtTy);\n        return TLO.CombineTo(Op,\n                             TLO.DAG.getNode(ISD::SHL, dl, VT, Op0, ShiftAmt));\n      }\n    }\n\n    // If none of the extended bits are demanded, eliminate the sextinreg.\n    if (DemandedBits.getActiveBits() <= ExVTBits)\n      return TLO.CombineTo(Op, Op0);\n\n    APInt InputDemandedBits = DemandedBits.getLoBits(ExVTBits);\n\n    // Since the sign extended bits are demanded, we know that the sign\n    // bit is demanded.\n    InputDemandedBits.setBit(ExVTBits - 1);\n\n    if (SimplifyDemandedBits(Op0, InputDemandedBits, Known, TLO, Depth + 1))\n      return true;\n    assert(!Known.hasConflict() && \"Bits known to be one AND zero?\");\n\n    // If the sign bit of the input is known set or clear, then we know the\n    // top bits of the result.\n\n    // If the input sign bit is known zero, convert this into a zero extension.\n    if (Known.Zero[ExVTBits - 1])\n      return TLO.CombineTo(Op, TLO.DAG.getZeroExtendInReg(Op0, dl, ExVT));\n\n    APInt Mask = APInt::getLowBitsSet(BitWidth, ExVTBits);\n    if (Known.One[ExVTBits - 1]) { // Input sign bit known set\n      Known.One.setBitsFrom(ExVTBits);\n      Known.Zero &= Mask;\n    } else { // Input sign bit unknown\n      Known.Zero &= Mask;\n      Known.One &= Mask;\n    }\n    break;\n  }\n  case ISD::BUILD_PAIR: {\n    EVT HalfVT = Op.getOperand(0).getValueType();\n    unsigned HalfBitWidth = HalfVT.getScalarSizeInBits();\n\n    APInt MaskLo = DemandedBits.getLoBits(HalfBitWidth).trunc(HalfBitWidth);\n    APInt MaskHi = DemandedBits.getHiBits(HalfBitWidth).trunc(HalfBitWidth);\n\n    KnownBits KnownLo, KnownHi;\n\n    if (SimplifyDemandedBits(Op.getOperand(0), MaskLo, KnownLo, TLO, Depth + 1))\n      return true;\n\n    if (SimplifyDemandedBits(Op.getOperand(1), MaskHi, KnownHi, TLO, Depth + 1))\n      return true;\n\n    Known.Zero = KnownLo.Zero.zext(BitWidth) |\n                 KnownHi.Zero.zext(BitWidth).shl(HalfBitWidth);\n\n    Known.One = KnownLo.One.zext(BitWidth) |\n                KnownHi.One.zext(BitWidth).shl(HalfBitWidth);\n    break;\n  }\n  case ISD::ZERO_EXTEND:\n  case ISD::ZERO_EXTEND_VECTOR_INREG: {\n    SDValue Src = Op.getOperand(0);\n    EVT SrcVT = Src.getValueType();\n    unsigned InBits = SrcVT.getScalarSizeInBits();\n    unsigned InElts = SrcVT.isVector() ? SrcVT.getVectorNumElements() : 1;\n    bool IsVecInReg = Op.getOpcode() == ISD::ZERO_EXTEND_VECTOR_INREG;\n\n    // If none of the top bits are demanded, convert this into an any_extend.\n    if (DemandedBits.getActiveBits() <= InBits) {\n      // If we only need the non-extended bits of the bottom element\n      // then we can just bitcast to the result.\n      if (IsVecInReg && DemandedElts == 1 &&\n          VT.getSizeInBits() == SrcVT.getSizeInBits() &&\n          TLO.DAG.getDataLayout().isLittleEndian())\n        return TLO.CombineTo(Op, TLO.DAG.getBitcast(VT, Src));\n\n      unsigned Opc =\n          IsVecInReg ? ISD::ANY_EXTEND_VECTOR_INREG : ISD::ANY_EXTEND;\n      if (!TLO.LegalOperations() || isOperationLegal(Opc, VT))\n        return TLO.CombineTo(Op, TLO.DAG.getNode(Opc, dl, VT, Src));\n    }\n\n    APInt InDemandedBits = DemandedBits.trunc(InBits);\n    APInt InDemandedElts = DemandedElts.zextOrSelf(InElts);\n    if (SimplifyDemandedBits(Src, InDemandedBits, InDemandedElts, Known, TLO,\n                             Depth + 1))\n      return true;\n    assert(!Known.hasConflict() && \"Bits known to be one AND zero?\");\n    assert(Known.getBitWidth() == InBits && \"Src width has changed?\");\n    Known = Known.zext(BitWidth);\n\n    // Attempt to avoid multi-use ops if we don't need anything from them.\n    if (SDValue NewSrc = SimplifyMultipleUseDemandedBits(\n            Src, InDemandedBits, InDemandedElts, TLO.DAG, Depth + 1))\n      return TLO.CombineTo(Op, TLO.DAG.getNode(Op.getOpcode(), dl, VT, NewSrc));\n    break;\n  }\n  case ISD::SIGN_EXTEND:\n  case ISD::SIGN_EXTEND_VECTOR_INREG: {\n    SDValue Src = Op.getOperand(0);\n    EVT SrcVT = Src.getValueType();\n    unsigned InBits = SrcVT.getScalarSizeInBits();\n    unsigned InElts = SrcVT.isVector() ? SrcVT.getVectorNumElements() : 1;\n    bool IsVecInReg = Op.getOpcode() == ISD::SIGN_EXTEND_VECTOR_INREG;\n\n    // If none of the top bits are demanded, convert this into an any_extend.\n    if (DemandedBits.getActiveBits() <= InBits) {\n      // If we only need the non-extended bits of the bottom element\n      // then we can just bitcast to the result.\n      if (IsVecInReg && DemandedElts == 1 &&\n          VT.getSizeInBits() == SrcVT.getSizeInBits() &&\n          TLO.DAG.getDataLayout().isLittleEndian())\n        return TLO.CombineTo(Op, TLO.DAG.getBitcast(VT, Src));\n\n      unsigned Opc =\n          IsVecInReg ? ISD::ANY_EXTEND_VECTOR_INREG : ISD::ANY_EXTEND;\n      if (!TLO.LegalOperations() || isOperationLegal(Opc, VT))\n        return TLO.CombineTo(Op, TLO.DAG.getNode(Opc, dl, VT, Src));\n    }\n\n    APInt InDemandedBits = DemandedBits.trunc(InBits);\n    APInt InDemandedElts = DemandedElts.zextOrSelf(InElts);\n\n    // Since some of the sign extended bits are demanded, we know that the sign\n    // bit is demanded.\n    InDemandedBits.setBit(InBits - 1);\n\n    if (SimplifyDemandedBits(Src, InDemandedBits, InDemandedElts, Known, TLO,\n                             Depth + 1))\n      return true;\n    assert(!Known.hasConflict() && \"Bits known to be one AND zero?\");\n    assert(Known.getBitWidth() == InBits && \"Src width has changed?\");\n\n    // If the sign bit is known one, the top bits match.\n    Known = Known.sext(BitWidth);\n\n    // If the sign bit is known zero, convert this to a zero extend.\n    if (Known.isNonNegative()) {\n      unsigned Opc =\n          IsVecInReg ? ISD::ZERO_EXTEND_VECTOR_INREG : ISD::ZERO_EXTEND;\n      if (!TLO.LegalOperations() || isOperationLegal(Opc, VT))\n        return TLO.CombineTo(Op, TLO.DAG.getNode(Opc, dl, VT, Src));\n    }\n\n    // Attempt to avoid multi-use ops if we don't need anything from them.\n    if (SDValue NewSrc = SimplifyMultipleUseDemandedBits(\n            Src, InDemandedBits, InDemandedElts, TLO.DAG, Depth + 1))\n      return TLO.CombineTo(Op, TLO.DAG.getNode(Op.getOpcode(), dl, VT, NewSrc));\n    break;\n  }\n  case ISD::ANY_EXTEND:\n  case ISD::ANY_EXTEND_VECTOR_INREG: {\n    SDValue Src = Op.getOperand(0);\n    EVT SrcVT = Src.getValueType();\n    unsigned InBits = SrcVT.getScalarSizeInBits();\n    unsigned InElts = SrcVT.isVector() ? SrcVT.getVectorNumElements() : 1;\n    bool IsVecInReg = Op.getOpcode() == ISD::ANY_EXTEND_VECTOR_INREG;\n\n    // If we only need the bottom element then we can just bitcast.\n    // TODO: Handle ANY_EXTEND?\n    if (IsVecInReg && DemandedElts == 1 &&\n        VT.getSizeInBits() == SrcVT.getSizeInBits() &&\n        TLO.DAG.getDataLayout().isLittleEndian())\n      return TLO.CombineTo(Op, TLO.DAG.getBitcast(VT, Src));\n\n    APInt InDemandedBits = DemandedBits.trunc(InBits);\n    APInt InDemandedElts = DemandedElts.zextOrSelf(InElts);\n    if (SimplifyDemandedBits(Src, InDemandedBits, InDemandedElts, Known, TLO,\n                             Depth + 1))\n      return true;\n    assert(!Known.hasConflict() && \"Bits known to be one AND zero?\");\n    assert(Known.getBitWidth() == InBits && \"Src width has changed?\");\n    Known = Known.anyext(BitWidth);\n\n    // Attempt to avoid multi-use ops if we don't need anything from them.\n    if (SDValue NewSrc = SimplifyMultipleUseDemandedBits(\n            Src, InDemandedBits, InDemandedElts, TLO.DAG, Depth + 1))\n      return TLO.CombineTo(Op, TLO.DAG.getNode(Op.getOpcode(), dl, VT, NewSrc));\n    break;\n  }\n  case ISD::TRUNCATE: {\n    SDValue Src = Op.getOperand(0);\n\n    // Simplify the input, using demanded bit information, and compute the known\n    // zero/one bits live out.\n    unsigned OperandBitWidth = Src.getScalarValueSizeInBits();\n    APInt TruncMask = DemandedBits.zext(OperandBitWidth);\n    if (SimplifyDemandedBits(Src, TruncMask, DemandedElts, Known, TLO,\n                             Depth + 1))\n      return true;\n    Known = Known.trunc(BitWidth);\n\n    // Attempt to avoid multi-use ops if we don't need anything from them.\n    if (SDValue NewSrc = SimplifyMultipleUseDemandedBits(\n            Src, TruncMask, DemandedElts, TLO.DAG, Depth + 1))\n      return TLO.CombineTo(Op, TLO.DAG.getNode(ISD::TRUNCATE, dl, VT, NewSrc));\n\n    // If the input is only used by this truncate, see if we can shrink it based\n    // on the known demanded bits.\n    if (Src.getNode()->hasOneUse()) {\n      switch (Src.getOpcode()) {\n      default:\n        break;\n      case ISD::SRL:\n        // Shrink SRL by a constant if none of the high bits shifted in are\n        // demanded.\n        if (TLO.LegalTypes() && !isTypeDesirableForOp(ISD::SRL, VT))\n          // Do not turn (vt1 truncate (vt2 srl)) into (vt1 srl) if vt1 is\n          // undesirable.\n          break;\n\n        const APInt *ShAmtC =\n            TLO.DAG.getValidShiftAmountConstant(Src, DemandedElts);\n        if (!ShAmtC)\n          break;\n        uint64_t ShVal = ShAmtC->getZExtValue();\n\n        APInt HighBits =\n            APInt::getHighBitsSet(OperandBitWidth, OperandBitWidth - BitWidth);\n        HighBits.lshrInPlace(ShVal);\n        HighBits = HighBits.trunc(BitWidth);\n\n        if (!(HighBits & DemandedBits)) {\n          // None of the shifted in bits are needed.  Add a truncate of the\n          // shift input, then shift it.\n          SDValue NewShAmt = TLO.DAG.getConstant(\n              ShVal, dl, getShiftAmountTy(VT, DL, TLO.LegalTypes()));\n          SDValue NewTrunc =\n              TLO.DAG.getNode(ISD::TRUNCATE, dl, VT, Src.getOperand(0));\n          return TLO.CombineTo(\n              Op, TLO.DAG.getNode(ISD::SRL, dl, VT, NewTrunc, NewShAmt));\n        }\n        break;\n      }\n    }\n\n    assert(!Known.hasConflict() && \"Bits known to be one AND zero?\");\n    break;\n  }\n  case ISD::AssertZext: {\n    // AssertZext demands all of the high bits, plus any of the low bits\n    // demanded by its users.\n    EVT ZVT = cast<VTSDNode>(Op.getOperand(1))->getVT();\n    APInt InMask = APInt::getLowBitsSet(BitWidth, ZVT.getSizeInBits());\n    if (SimplifyDemandedBits(Op.getOperand(0), ~InMask | DemandedBits, Known,\n                             TLO, Depth + 1))\n      return true;\n    assert(!Known.hasConflict() && \"Bits known to be one AND zero?\");\n\n    Known.Zero |= ~InMask;\n    break;\n  }\n  case ISD::EXTRACT_VECTOR_ELT: {\n    SDValue Src = Op.getOperand(0);\n    SDValue Idx = Op.getOperand(1);\n    ElementCount SrcEltCnt = Src.getValueType().getVectorElementCount();\n    unsigned EltBitWidth = Src.getScalarValueSizeInBits();\n\n    if (SrcEltCnt.isScalable())\n      return false;\n\n    // Demand the bits from every vector element without a constant index.\n    unsigned NumSrcElts = SrcEltCnt.getFixedValue();\n    APInt DemandedSrcElts = APInt::getAllOnesValue(NumSrcElts);\n    if (auto *CIdx = dyn_cast<ConstantSDNode>(Idx))\n      if (CIdx->getAPIntValue().ult(NumSrcElts))\n        DemandedSrcElts = APInt::getOneBitSet(NumSrcElts, CIdx->getZExtValue());\n\n    // If BitWidth > EltBitWidth the value is anyext:ed. So we do not know\n    // anything about the extended bits.\n    APInt DemandedSrcBits = DemandedBits;\n    if (BitWidth > EltBitWidth)\n      DemandedSrcBits = DemandedSrcBits.trunc(EltBitWidth);\n\n    if (SimplifyDemandedBits(Src, DemandedSrcBits, DemandedSrcElts, Known2, TLO,\n                             Depth + 1))\n      return true;\n\n    // Attempt to avoid multi-use ops if we don't need anything from them.\n    if (!DemandedSrcBits.isAllOnesValue() ||\n        !DemandedSrcElts.isAllOnesValue()) {\n      if (SDValue DemandedSrc = SimplifyMultipleUseDemandedBits(\n              Src, DemandedSrcBits, DemandedSrcElts, TLO.DAG, Depth + 1)) {\n        SDValue NewOp =\n            TLO.DAG.getNode(Op.getOpcode(), dl, VT, DemandedSrc, Idx);\n        return TLO.CombineTo(Op, NewOp);\n      }\n    }\n\n    Known = Known2;\n    if (BitWidth > EltBitWidth)\n      Known = Known.anyext(BitWidth);\n    break;\n  }\n  case ISD::BITCAST: {\n    SDValue Src = Op.getOperand(0);\n    EVT SrcVT = Src.getValueType();\n    unsigned NumSrcEltBits = SrcVT.getScalarSizeInBits();\n\n    // If this is an FP->Int bitcast and if the sign bit is the only\n    // thing demanded, turn this into a FGETSIGN.\n    if (!TLO.LegalOperations() && !VT.isVector() && !SrcVT.isVector() &&\n        DemandedBits == APInt::getSignMask(Op.getValueSizeInBits()) &&\n        SrcVT.isFloatingPoint()) {\n      bool OpVTLegal = isOperationLegalOrCustom(ISD::FGETSIGN, VT);\n      bool i32Legal = isOperationLegalOrCustom(ISD::FGETSIGN, MVT::i32);\n      if ((OpVTLegal || i32Legal) && VT.isSimple() && SrcVT != MVT::f16 &&\n          SrcVT != MVT::f128) {\n        // Cannot eliminate/lower SHL for f128 yet.\n        EVT Ty = OpVTLegal ? VT : MVT::i32;\n        // Make a FGETSIGN + SHL to move the sign bit into the appropriate\n        // place.  We expect the SHL to be eliminated by other optimizations.\n        SDValue Sign = TLO.DAG.getNode(ISD::FGETSIGN, dl, Ty, Src);\n        unsigned OpVTSizeInBits = Op.getValueSizeInBits();\n        if (!OpVTLegal && OpVTSizeInBits > 32)\n          Sign = TLO.DAG.getNode(ISD::ZERO_EXTEND, dl, VT, Sign);\n        unsigned ShVal = Op.getValueSizeInBits() - 1;\n        SDValue ShAmt = TLO.DAG.getConstant(ShVal, dl, VT);\n        return TLO.CombineTo(Op,\n                             TLO.DAG.getNode(ISD::SHL, dl, VT, Sign, ShAmt));\n      }\n    }\n\n    // Bitcast from a vector using SimplifyDemanded Bits/VectorElts.\n    // Demand the elt/bit if any of the original elts/bits are demanded.\n    // TODO - bigendian once we have test coverage.\n    if (SrcVT.isVector() && (BitWidth % NumSrcEltBits) == 0 &&\n        TLO.DAG.getDataLayout().isLittleEndian()) {\n      unsigned Scale = BitWidth / NumSrcEltBits;\n      unsigned NumSrcElts = SrcVT.getVectorNumElements();\n      APInt DemandedSrcBits = APInt::getNullValue(NumSrcEltBits);\n      APInt DemandedSrcElts = APInt::getNullValue(NumSrcElts);\n      for (unsigned i = 0; i != Scale; ++i) {\n        unsigned Offset = i * NumSrcEltBits;\n        APInt Sub = DemandedBits.extractBits(NumSrcEltBits, Offset);\n        if (!Sub.isNullValue()) {\n          DemandedSrcBits |= Sub;\n          for (unsigned j = 0; j != NumElts; ++j)\n            if (DemandedElts[j])\n              DemandedSrcElts.setBit((j * Scale) + i);\n        }\n      }\n\n      APInt KnownSrcUndef, KnownSrcZero;\n      if (SimplifyDemandedVectorElts(Src, DemandedSrcElts, KnownSrcUndef,\n                                     KnownSrcZero, TLO, Depth + 1))\n        return true;\n\n      KnownBits KnownSrcBits;\n      if (SimplifyDemandedBits(Src, DemandedSrcBits, DemandedSrcElts,\n                               KnownSrcBits, TLO, Depth + 1))\n        return true;\n    } else if ((NumSrcEltBits % BitWidth) == 0 &&\n               TLO.DAG.getDataLayout().isLittleEndian()) {\n      unsigned Scale = NumSrcEltBits / BitWidth;\n      unsigned NumSrcElts = SrcVT.isVector() ? SrcVT.getVectorNumElements() : 1;\n      APInt DemandedSrcBits = APInt::getNullValue(NumSrcEltBits);\n      APInt DemandedSrcElts = APInt::getNullValue(NumSrcElts);\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (DemandedElts[i]) {\n          unsigned Offset = (i % Scale) * BitWidth;\n          DemandedSrcBits.insertBits(DemandedBits, Offset);\n          DemandedSrcElts.setBit(i / Scale);\n        }\n\n      if (SrcVT.isVector()) {\n        APInt KnownSrcUndef, KnownSrcZero;\n        if (SimplifyDemandedVectorElts(Src, DemandedSrcElts, KnownSrcUndef,\n                                       KnownSrcZero, TLO, Depth + 1))\n          return true;\n      }\n\n      KnownBits KnownSrcBits;\n      if (SimplifyDemandedBits(Src, DemandedSrcBits, DemandedSrcElts,\n                               KnownSrcBits, TLO, Depth + 1))\n        return true;\n    }\n\n    // If this is a bitcast, let computeKnownBits handle it.  Only do this on a\n    // recursive call where Known may be useful to the caller.\n    if (Depth > 0) {\n      Known = TLO.DAG.computeKnownBits(Op, DemandedElts, Depth);\n      return false;\n    }\n    break;\n  }\n  case ISD::ADD:\n  case ISD::MUL:\n  case ISD::SUB: {\n    // Add, Sub, and Mul don't demand any bits in positions beyond that\n    // of the highest bit demanded of them.\n    SDValue Op0 = Op.getOperand(0), Op1 = Op.getOperand(1);\n    SDNodeFlags Flags = Op.getNode()->getFlags();\n    unsigned DemandedBitsLZ = DemandedBits.countLeadingZeros();\n    APInt LoMask = APInt::getLowBitsSet(BitWidth, BitWidth - DemandedBitsLZ);\n    if (SimplifyDemandedBits(Op0, LoMask, DemandedElts, Known2, TLO,\n                             Depth + 1) ||\n        SimplifyDemandedBits(Op1, LoMask, DemandedElts, Known2, TLO,\n                             Depth + 1) ||\n        // See if the operation should be performed at a smaller bit width.\n        ShrinkDemandedOp(Op, BitWidth, DemandedBits, TLO)) {\n      if (Flags.hasNoSignedWrap() || Flags.hasNoUnsignedWrap()) {\n        // Disable the nsw and nuw flags. We can no longer guarantee that we\n        // won't wrap after simplification.\n        Flags.setNoSignedWrap(false);\n        Flags.setNoUnsignedWrap(false);\n        SDValue NewOp =\n            TLO.DAG.getNode(Op.getOpcode(), dl, VT, Op0, Op1, Flags);\n        return TLO.CombineTo(Op, NewOp);\n      }\n      return true;\n    }\n\n    // Attempt to avoid multi-use ops if we don't need anything from them.\n    if (!LoMask.isAllOnesValue() || !DemandedElts.isAllOnesValue()) {\n      SDValue DemandedOp0 = SimplifyMultipleUseDemandedBits(\n          Op0, LoMask, DemandedElts, TLO.DAG, Depth + 1);\n      SDValue DemandedOp1 = SimplifyMultipleUseDemandedBits(\n          Op1, LoMask, DemandedElts, TLO.DAG, Depth + 1);\n      if (DemandedOp0 || DemandedOp1) {\n        Flags.setNoSignedWrap(false);\n        Flags.setNoUnsignedWrap(false);\n        Op0 = DemandedOp0 ? DemandedOp0 : Op0;\n        Op1 = DemandedOp1 ? DemandedOp1 : Op1;\n        SDValue NewOp =\n            TLO.DAG.getNode(Op.getOpcode(), dl, VT, Op0, Op1, Flags);\n        return TLO.CombineTo(Op, NewOp);\n      }\n    }\n\n    // If we have a constant operand, we may be able to turn it into -1 if we\n    // do not demand the high bits. This can make the constant smaller to\n    // encode, allow more general folding, or match specialized instruction\n    // patterns (eg, 'blsr' on x86). Don't bother changing 1 to -1 because that\n    // is probably not useful (and could be detrimental).\n    ConstantSDNode *C = isConstOrConstSplat(Op1);\n    APInt HighMask = APInt::getHighBitsSet(BitWidth, DemandedBitsLZ);\n    if (C && !C->isAllOnesValue() && !C->isOne() &&\n        (C->getAPIntValue() | HighMask).isAllOnesValue()) {\n      SDValue Neg1 = TLO.DAG.getAllOnesConstant(dl, VT);\n      // Disable the nsw and nuw flags. We can no longer guarantee that we\n      // won't wrap after simplification.\n      Flags.setNoSignedWrap(false);\n      Flags.setNoUnsignedWrap(false);\n      SDValue NewOp = TLO.DAG.getNode(Op.getOpcode(), dl, VT, Op0, Neg1, Flags);\n      return TLO.CombineTo(Op, NewOp);\n    }\n\n    LLVM_FALLTHROUGH;\n  }\n  default:\n    if (Op.getOpcode() >= ISD::BUILTIN_OP_END) {\n      if (SimplifyDemandedBitsForTargetNode(Op, DemandedBits, DemandedElts,\n                                            Known, TLO, Depth))\n        return true;\n      break;\n    }\n\n    // Just use computeKnownBits to compute output bits.\n    Known = TLO.DAG.computeKnownBits(Op, DemandedElts, Depth);\n    break;\n  }\n\n  // If we know the value of all of the demanded bits, return this as a\n  // constant.\n  if (DemandedBits.isSubsetOf(Known.Zero | Known.One)) {\n    // Avoid folding to a constant if any OpaqueConstant is involved.\n    const SDNode *N = Op.getNode();\n    for (SDNodeIterator I = SDNodeIterator::begin(N),\n                        E = SDNodeIterator::end(N);\n         I != E; ++I) {\n      SDNode *Op = *I;\n      if (ConstantSDNode *C = dyn_cast<ConstantSDNode>(Op))\n        if (C->isOpaque())\n          return false;\n    }\n    if (VT.isInteger())\n      return TLO.CombineTo(Op, TLO.DAG.getConstant(Known.One, dl, VT));\n    if (VT.isFloatingPoint())\n      return TLO.CombineTo(\n          Op,\n          TLO.DAG.getConstantFP(\n              APFloat(TLO.DAG.EVTToAPFloatSemantics(VT), Known.One), dl, VT));\n  }\n\n  return false;\n}\n\nbool TargetLowering::SimplifyDemandedVectorElts(SDValue Op,\n                                                const APInt &DemandedElts,\n                                                APInt &KnownUndef,\n                                                APInt &KnownZero,\n                                                DAGCombinerInfo &DCI) const {\n  SelectionDAG &DAG = DCI.DAG;\n  TargetLoweringOpt TLO(DAG, !DCI.isBeforeLegalize(),\n                        !DCI.isBeforeLegalizeOps());\n\n  bool Simplified =\n      SimplifyDemandedVectorElts(Op, DemandedElts, KnownUndef, KnownZero, TLO);\n  if (Simplified) {\n    DCI.AddToWorklist(Op.getNode());\n    DCI.CommitTargetLoweringOpt(TLO);\n  }\n\n  return Simplified;\n}\n\n/// Given a vector binary operation and known undefined elements for each input\n/// operand, compute whether each element of the output is undefined.\nstatic APInt getKnownUndefForVectorBinop(SDValue BO, SelectionDAG &DAG,\n                                         const APInt &UndefOp0,\n                                         const APInt &UndefOp1) {\n  EVT VT = BO.getValueType();\n  assert(DAG.getTargetLoweringInfo().isBinOp(BO.getOpcode()) && VT.isVector() &&\n         \"Vector binop only\");\n\n  EVT EltVT = VT.getVectorElementType();\n  unsigned NumElts = VT.getVectorNumElements();\n  assert(UndefOp0.getBitWidth() == NumElts &&\n         UndefOp1.getBitWidth() == NumElts && \"Bad type for undef analysis\");\n\n  auto getUndefOrConstantElt = [&](SDValue V, unsigned Index,\n                                   const APInt &UndefVals) {\n    if (UndefVals[Index])\n      return DAG.getUNDEF(EltVT);\n\n    if (auto *BV = dyn_cast<BuildVectorSDNode>(V)) {\n      // Try hard to make sure that the getNode() call is not creating temporary\n      // nodes. Ignore opaque integers because they do not constant fold.\n      SDValue Elt = BV->getOperand(Index);\n      auto *C = dyn_cast<ConstantSDNode>(Elt);\n      if (isa<ConstantFPSDNode>(Elt) || Elt.isUndef() || (C && !C->isOpaque()))\n        return Elt;\n    }\n\n    return SDValue();\n  };\n\n  APInt KnownUndef = APInt::getNullValue(NumElts);\n  for (unsigned i = 0; i != NumElts; ++i) {\n    // If both inputs for this element are either constant or undef and match\n    // the element type, compute the constant/undef result for this element of\n    // the vector.\n    // TODO: Ideally we would use FoldConstantArithmetic() here, but that does\n    // not handle FP constants. The code within getNode() should be refactored\n    // to avoid the danger of creating a bogus temporary node here.\n    SDValue C0 = getUndefOrConstantElt(BO.getOperand(0), i, UndefOp0);\n    SDValue C1 = getUndefOrConstantElt(BO.getOperand(1), i, UndefOp1);\n    if (C0 && C1 && C0.getValueType() == EltVT && C1.getValueType() == EltVT)\n      if (DAG.getNode(BO.getOpcode(), SDLoc(BO), EltVT, C0, C1).isUndef())\n        KnownUndef.setBit(i);\n  }\n  return KnownUndef;\n}\n\nbool TargetLowering::SimplifyDemandedVectorElts(\n    SDValue Op, const APInt &OriginalDemandedElts, APInt &KnownUndef,\n    APInt &KnownZero, TargetLoweringOpt &TLO, unsigned Depth,\n    bool AssumeSingleUse) const {\n  EVT VT = Op.getValueType();\n  unsigned Opcode = Op.getOpcode();\n  APInt DemandedElts = OriginalDemandedElts;\n  unsigned NumElts = DemandedElts.getBitWidth();\n  assert(VT.isVector() && \"Expected vector op\");\n\n  KnownUndef = KnownZero = APInt::getNullValue(NumElts);\n\n  // TODO: For now we assume we know nothing about scalable vectors.\n  if (VT.isScalableVector())\n    return false;\n\n  assert(VT.getVectorNumElements() == NumElts &&\n         \"Mask size mismatches value type element count!\");\n\n  // Undef operand.\n  if (Op.isUndef()) {\n    KnownUndef.setAllBits();\n    return false;\n  }\n\n  // If Op has other users, assume that all elements are needed.\n  if (!Op.getNode()->hasOneUse() && !AssumeSingleUse)\n    DemandedElts.setAllBits();\n\n  // Not demanding any elements from Op.\n  if (DemandedElts == 0) {\n    KnownUndef.setAllBits();\n    return TLO.CombineTo(Op, TLO.DAG.getUNDEF(VT));\n  }\n\n  // Limit search depth.\n  if (Depth >= SelectionDAG::MaxRecursionDepth)\n    return false;\n\n  SDLoc DL(Op);\n  unsigned EltSizeInBits = VT.getScalarSizeInBits();\n\n  // Helper for demanding the specified elements and all the bits of both binary\n  // operands.\n  auto SimplifyDemandedVectorEltsBinOp = [&](SDValue Op0, SDValue Op1) {\n    SDValue NewOp0 = SimplifyMultipleUseDemandedVectorElts(Op0, DemandedElts,\n                                                           TLO.DAG, Depth + 1);\n    SDValue NewOp1 = SimplifyMultipleUseDemandedVectorElts(Op1, DemandedElts,\n                                                           TLO.DAG, Depth + 1);\n    if (NewOp0 || NewOp1) {\n      SDValue NewOp = TLO.DAG.getNode(\n          Opcode, SDLoc(Op), VT, NewOp0 ? NewOp0 : Op0, NewOp1 ? NewOp1 : Op1);\n      return TLO.CombineTo(Op, NewOp);\n    }\n    return false;\n  };\n\n  switch (Opcode) {\n  case ISD::SCALAR_TO_VECTOR: {\n    if (!DemandedElts[0]) {\n      KnownUndef.setAllBits();\n      return TLO.CombineTo(Op, TLO.DAG.getUNDEF(VT));\n    }\n    KnownUndef.setHighBits(NumElts - 1);\n    break;\n  }\n  case ISD::BITCAST: {\n    SDValue Src = Op.getOperand(0);\n    EVT SrcVT = Src.getValueType();\n\n    // We only handle vectors here.\n    // TODO - investigate calling SimplifyDemandedBits/ComputeKnownBits?\n    if (!SrcVT.isVector())\n      break;\n\n    // Fast handling of 'identity' bitcasts.\n    unsigned NumSrcElts = SrcVT.getVectorNumElements();\n    if (NumSrcElts == NumElts)\n      return SimplifyDemandedVectorElts(Src, DemandedElts, KnownUndef,\n                                        KnownZero, TLO, Depth + 1);\n\n    APInt SrcZero, SrcUndef;\n    APInt SrcDemandedElts = APInt::getNullValue(NumSrcElts);\n\n    // Bitcast from 'large element' src vector to 'small element' vector, we\n    // must demand a source element if any DemandedElt maps to it.\n    if ((NumElts % NumSrcElts) == 0) {\n      unsigned Scale = NumElts / NumSrcElts;\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (DemandedElts[i])\n          SrcDemandedElts.setBit(i / Scale);\n\n      if (SimplifyDemandedVectorElts(Src, SrcDemandedElts, SrcUndef, SrcZero,\n                                     TLO, Depth + 1))\n        return true;\n\n      // Try calling SimplifyDemandedBits, converting demanded elts to the bits\n      // of the large element.\n      // TODO - bigendian once we have test coverage.\n      if (TLO.DAG.getDataLayout().isLittleEndian()) {\n        unsigned SrcEltSizeInBits = SrcVT.getScalarSizeInBits();\n        APInt SrcDemandedBits = APInt::getNullValue(SrcEltSizeInBits);\n        for (unsigned i = 0; i != NumElts; ++i)\n          if (DemandedElts[i]) {\n            unsigned Ofs = (i % Scale) * EltSizeInBits;\n            SrcDemandedBits.setBits(Ofs, Ofs + EltSizeInBits);\n          }\n\n        KnownBits Known;\n        if (SimplifyDemandedBits(Src, SrcDemandedBits, SrcDemandedElts, Known,\n                                 TLO, Depth + 1))\n          return true;\n      }\n\n      // If the src element is zero/undef then all the output elements will be -\n      // only demanded elements are guaranteed to be correct.\n      for (unsigned i = 0; i != NumSrcElts; ++i) {\n        if (SrcDemandedElts[i]) {\n          if (SrcZero[i])\n            KnownZero.setBits(i * Scale, (i + 1) * Scale);\n          if (SrcUndef[i])\n            KnownUndef.setBits(i * Scale, (i + 1) * Scale);\n        }\n      }\n    }\n\n    // Bitcast from 'small element' src vector to 'large element' vector, we\n    // demand all smaller source elements covered by the larger demanded element\n    // of this vector.\n    if ((NumSrcElts % NumElts) == 0) {\n      unsigned Scale = NumSrcElts / NumElts;\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (DemandedElts[i])\n          SrcDemandedElts.setBits(i * Scale, (i + 1) * Scale);\n\n      if (SimplifyDemandedVectorElts(Src, SrcDemandedElts, SrcUndef, SrcZero,\n                                     TLO, Depth + 1))\n        return true;\n\n      // If all the src elements covering an output element are zero/undef, then\n      // the output element will be as well, assuming it was demanded.\n      for (unsigned i = 0; i != NumElts; ++i) {\n        if (DemandedElts[i]) {\n          if (SrcZero.extractBits(Scale, i * Scale).isAllOnesValue())\n            KnownZero.setBit(i);\n          if (SrcUndef.extractBits(Scale, i * Scale).isAllOnesValue())\n            KnownUndef.setBit(i);\n        }\n      }\n    }\n    break;\n  }\n  case ISD::BUILD_VECTOR: {\n    // Check all elements and simplify any unused elements with UNDEF.\n    if (!DemandedElts.isAllOnesValue()) {\n      // Don't simplify BROADCASTS.\n      if (llvm::any_of(Op->op_values(),\n                       [&](SDValue Elt) { return Op.getOperand(0) != Elt; })) {\n        SmallVector<SDValue, 32> Ops(Op->op_begin(), Op->op_end());\n        bool Updated = false;\n        for (unsigned i = 0; i != NumElts; ++i) {\n          if (!DemandedElts[i] && !Ops[i].isUndef()) {\n            Ops[i] = TLO.DAG.getUNDEF(Ops[0].getValueType());\n            KnownUndef.setBit(i);\n            Updated = true;\n          }\n        }\n        if (Updated)\n          return TLO.CombineTo(Op, TLO.DAG.getBuildVector(VT, DL, Ops));\n      }\n    }\n    for (unsigned i = 0; i != NumElts; ++i) {\n      SDValue SrcOp = Op.getOperand(i);\n      if (SrcOp.isUndef()) {\n        KnownUndef.setBit(i);\n      } else if (EltSizeInBits == SrcOp.getScalarValueSizeInBits() &&\n                 (isNullConstant(SrcOp) || isNullFPConstant(SrcOp))) {\n        KnownZero.setBit(i);\n      }\n    }\n    break;\n  }\n  case ISD::CONCAT_VECTORS: {\n    EVT SubVT = Op.getOperand(0).getValueType();\n    unsigned NumSubVecs = Op.getNumOperands();\n    unsigned NumSubElts = SubVT.getVectorNumElements();\n    for (unsigned i = 0; i != NumSubVecs; ++i) {\n      SDValue SubOp = Op.getOperand(i);\n      APInt SubElts = DemandedElts.extractBits(NumSubElts, i * NumSubElts);\n      APInt SubUndef, SubZero;\n      if (SimplifyDemandedVectorElts(SubOp, SubElts, SubUndef, SubZero, TLO,\n                                     Depth + 1))\n        return true;\n      KnownUndef.insertBits(SubUndef, i * NumSubElts);\n      KnownZero.insertBits(SubZero, i * NumSubElts);\n    }\n    break;\n  }\n  case ISD::INSERT_SUBVECTOR: {\n    // Demand any elements from the subvector and the remainder from the src its\n    // inserted into.\n    SDValue Src = Op.getOperand(0);\n    SDValue Sub = Op.getOperand(1);\n    uint64_t Idx = Op.getConstantOperandVal(2);\n    unsigned NumSubElts = Sub.getValueType().getVectorNumElements();\n    APInt DemandedSubElts = DemandedElts.extractBits(NumSubElts, Idx);\n    APInt DemandedSrcElts = DemandedElts;\n    DemandedSrcElts.insertBits(APInt::getNullValue(NumSubElts), Idx);\n\n    APInt SubUndef, SubZero;\n    if (SimplifyDemandedVectorElts(Sub, DemandedSubElts, SubUndef, SubZero, TLO,\n                                   Depth + 1))\n      return true;\n\n    // If none of the src operand elements are demanded, replace it with undef.\n    if (!DemandedSrcElts && !Src.isUndef())\n      return TLO.CombineTo(Op, TLO.DAG.getNode(ISD::INSERT_SUBVECTOR, DL, VT,\n                                               TLO.DAG.getUNDEF(VT), Sub,\n                                               Op.getOperand(2)));\n\n    if (SimplifyDemandedVectorElts(Src, DemandedSrcElts, KnownUndef, KnownZero,\n                                   TLO, Depth + 1))\n      return true;\n    KnownUndef.insertBits(SubUndef, Idx);\n    KnownZero.insertBits(SubZero, Idx);\n\n    // Attempt to avoid multi-use ops if we don't need anything from them.\n    if (!DemandedSrcElts.isAllOnesValue() ||\n        !DemandedSubElts.isAllOnesValue()) {\n      SDValue NewSrc = SimplifyMultipleUseDemandedVectorElts(\n          Src, DemandedSrcElts, TLO.DAG, Depth + 1);\n      SDValue NewSub = SimplifyMultipleUseDemandedVectorElts(\n          Sub, DemandedSubElts, TLO.DAG, Depth + 1);\n      if (NewSrc || NewSub) {\n        NewSrc = NewSrc ? NewSrc : Src;\n        NewSub = NewSub ? NewSub : Sub;\n        SDValue NewOp = TLO.DAG.getNode(Op.getOpcode(), SDLoc(Op), VT, NewSrc,\n                                        NewSub, Op.getOperand(2));\n        return TLO.CombineTo(Op, NewOp);\n      }\n    }\n    break;\n  }\n  case ISD::EXTRACT_SUBVECTOR: {\n    // Offset the demanded elts by the subvector index.\n    SDValue Src = Op.getOperand(0);\n    if (Src.getValueType().isScalableVector())\n      break;\n    uint64_t Idx = Op.getConstantOperandVal(1);\n    unsigned NumSrcElts = Src.getValueType().getVectorNumElements();\n    APInt DemandedSrcElts = DemandedElts.zextOrSelf(NumSrcElts).shl(Idx);\n\n    APInt SrcUndef, SrcZero;\n    if (SimplifyDemandedVectorElts(Src, DemandedSrcElts, SrcUndef, SrcZero, TLO,\n                                   Depth + 1))\n      return true;\n    KnownUndef = SrcUndef.extractBits(NumElts, Idx);\n    KnownZero = SrcZero.extractBits(NumElts, Idx);\n\n    // Attempt to avoid multi-use ops if we don't need anything from them.\n    if (!DemandedElts.isAllOnesValue()) {\n      SDValue NewSrc = SimplifyMultipleUseDemandedVectorElts(\n          Src, DemandedSrcElts, TLO.DAG, Depth + 1);\n      if (NewSrc) {\n        SDValue NewOp = TLO.DAG.getNode(Op.getOpcode(), SDLoc(Op), VT, NewSrc,\n                                        Op.getOperand(1));\n        return TLO.CombineTo(Op, NewOp);\n      }\n    }\n    break;\n  }\n  case ISD::INSERT_VECTOR_ELT: {\n    SDValue Vec = Op.getOperand(0);\n    SDValue Scl = Op.getOperand(1);\n    auto *CIdx = dyn_cast<ConstantSDNode>(Op.getOperand(2));\n\n    // For a legal, constant insertion index, if we don't need this insertion\n    // then strip it, else remove it from the demanded elts.\n    if (CIdx && CIdx->getAPIntValue().ult(NumElts)) {\n      unsigned Idx = CIdx->getZExtValue();\n      if (!DemandedElts[Idx])\n        return TLO.CombineTo(Op, Vec);\n\n      APInt DemandedVecElts(DemandedElts);\n      DemandedVecElts.clearBit(Idx);\n      if (SimplifyDemandedVectorElts(Vec, DemandedVecElts, KnownUndef,\n                                     KnownZero, TLO, Depth + 1))\n        return true;\n\n      KnownUndef.setBitVal(Idx, Scl.isUndef());\n\n      KnownZero.setBitVal(Idx, isNullConstant(Scl) || isNullFPConstant(Scl));\n      break;\n    }\n\n    APInt VecUndef, VecZero;\n    if (SimplifyDemandedVectorElts(Vec, DemandedElts, VecUndef, VecZero, TLO,\n                                   Depth + 1))\n      return true;\n    // Without knowing the insertion index we can't set KnownUndef/KnownZero.\n    break;\n  }\n  case ISD::VSELECT: {\n    // Try to transform the select condition based on the current demanded\n    // elements.\n    // TODO: If a condition element is undef, we can choose from one arm of the\n    //       select (and if one arm is undef, then we can propagate that to the\n    //       result).\n    // TODO - add support for constant vselect masks (see IR version of this).\n    APInt UnusedUndef, UnusedZero;\n    if (SimplifyDemandedVectorElts(Op.getOperand(0), DemandedElts, UnusedUndef,\n                                   UnusedZero, TLO, Depth + 1))\n      return true;\n\n    // See if we can simplify either vselect operand.\n    APInt DemandedLHS(DemandedElts);\n    APInt DemandedRHS(DemandedElts);\n    APInt UndefLHS, ZeroLHS;\n    APInt UndefRHS, ZeroRHS;\n    if (SimplifyDemandedVectorElts(Op.getOperand(1), DemandedLHS, UndefLHS,\n                                   ZeroLHS, TLO, Depth + 1))\n      return true;\n    if (SimplifyDemandedVectorElts(Op.getOperand(2), DemandedRHS, UndefRHS,\n                                   ZeroRHS, TLO, Depth + 1))\n      return true;\n\n    KnownUndef = UndefLHS & UndefRHS;\n    KnownZero = ZeroLHS & ZeroRHS;\n    break;\n  }\n  case ISD::VECTOR_SHUFFLE: {\n    ArrayRef<int> ShuffleMask = cast<ShuffleVectorSDNode>(Op)->getMask();\n\n    // Collect demanded elements from shuffle operands..\n    APInt DemandedLHS(NumElts, 0);\n    APInt DemandedRHS(NumElts, 0);\n    for (unsigned i = 0; i != NumElts; ++i) {\n      int M = ShuffleMask[i];\n      if (M < 0 || !DemandedElts[i])\n        continue;\n      assert(0 <= M && M < (int)(2 * NumElts) && \"Shuffle index out of range\");\n      if (M < (int)NumElts)\n        DemandedLHS.setBit(M);\n      else\n        DemandedRHS.setBit(M - NumElts);\n    }\n\n    // See if we can simplify either shuffle operand.\n    APInt UndefLHS, ZeroLHS;\n    APInt UndefRHS, ZeroRHS;\n    if (SimplifyDemandedVectorElts(Op.getOperand(0), DemandedLHS, UndefLHS,\n                                   ZeroLHS, TLO, Depth + 1))\n      return true;\n    if (SimplifyDemandedVectorElts(Op.getOperand(1), DemandedRHS, UndefRHS,\n                                   ZeroRHS, TLO, Depth + 1))\n      return true;\n\n    // Simplify mask using undef elements from LHS/RHS.\n    bool Updated = false;\n    bool IdentityLHS = true, IdentityRHS = true;\n    SmallVector<int, 32> NewMask(ShuffleMask.begin(), ShuffleMask.end());\n    for (unsigned i = 0; i != NumElts; ++i) {\n      int &M = NewMask[i];\n      if (M < 0)\n        continue;\n      if (!DemandedElts[i] || (M < (int)NumElts && UndefLHS[M]) ||\n          (M >= (int)NumElts && UndefRHS[M - NumElts])) {\n        Updated = true;\n        M = -1;\n      }\n      IdentityLHS &= (M < 0) || (M == (int)i);\n      IdentityRHS &= (M < 0) || ((M - NumElts) == i);\n    }\n\n    // Update legal shuffle masks based on demanded elements if it won't reduce\n    // to Identity which can cause premature removal of the shuffle mask.\n    if (Updated && !IdentityLHS && !IdentityRHS && !TLO.LegalOps) {\n      SDValue LegalShuffle =\n          buildLegalVectorShuffle(VT, DL, Op.getOperand(0), Op.getOperand(1),\n                                  NewMask, TLO.DAG);\n      if (LegalShuffle)\n        return TLO.CombineTo(Op, LegalShuffle);\n    }\n\n    // Propagate undef/zero elements from LHS/RHS.\n    for (unsigned i = 0; i != NumElts; ++i) {\n      int M = ShuffleMask[i];\n      if (M < 0) {\n        KnownUndef.setBit(i);\n      } else if (M < (int)NumElts) {\n        if (UndefLHS[M])\n          KnownUndef.setBit(i);\n        if (ZeroLHS[M])\n          KnownZero.setBit(i);\n      } else {\n        if (UndefRHS[M - NumElts])\n          KnownUndef.setBit(i);\n        if (ZeroRHS[M - NumElts])\n          KnownZero.setBit(i);\n      }\n    }\n    break;\n  }\n  case ISD::ANY_EXTEND_VECTOR_INREG:\n  case ISD::SIGN_EXTEND_VECTOR_INREG:\n  case ISD::ZERO_EXTEND_VECTOR_INREG: {\n    APInt SrcUndef, SrcZero;\n    SDValue Src = Op.getOperand(0);\n    unsigned NumSrcElts = Src.getValueType().getVectorNumElements();\n    APInt DemandedSrcElts = DemandedElts.zextOrSelf(NumSrcElts);\n    if (SimplifyDemandedVectorElts(Src, DemandedSrcElts, SrcUndef, SrcZero, TLO,\n                                   Depth + 1))\n      return true;\n    KnownZero = SrcZero.zextOrTrunc(NumElts);\n    KnownUndef = SrcUndef.zextOrTrunc(NumElts);\n\n    if (Op.getOpcode() == ISD::ANY_EXTEND_VECTOR_INREG &&\n        Op.getValueSizeInBits() == Src.getValueSizeInBits() &&\n        DemandedSrcElts == 1 && TLO.DAG.getDataLayout().isLittleEndian()) {\n      // aext - if we just need the bottom element then we can bitcast.\n      return TLO.CombineTo(Op, TLO.DAG.getBitcast(VT, Src));\n    }\n\n    if (Op.getOpcode() == ISD::ZERO_EXTEND_VECTOR_INREG) {\n      // zext(undef) upper bits are guaranteed to be zero.\n      if (DemandedElts.isSubsetOf(KnownUndef))\n        return TLO.CombineTo(Op, TLO.DAG.getConstant(0, SDLoc(Op), VT));\n      KnownUndef.clearAllBits();\n    }\n    break;\n  }\n\n  // TODO: There are more binop opcodes that could be handled here - MIN,\n  // MAX, saturated math, etc.\n  case ISD::OR:\n  case ISD::XOR:\n  case ISD::ADD:\n  case ISD::SUB:\n  case ISD::FADD:\n  case ISD::FSUB:\n  case ISD::FMUL:\n  case ISD::FDIV:\n  case ISD::FREM: {\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n\n    APInt UndefRHS, ZeroRHS;\n    if (SimplifyDemandedVectorElts(Op1, DemandedElts, UndefRHS, ZeroRHS, TLO,\n                                   Depth + 1))\n      return true;\n    APInt UndefLHS, ZeroLHS;\n    if (SimplifyDemandedVectorElts(Op0, DemandedElts, UndefLHS, ZeroLHS, TLO,\n                                   Depth + 1))\n      return true;\n\n    KnownZero = ZeroLHS & ZeroRHS;\n    KnownUndef = getKnownUndefForVectorBinop(Op, TLO.DAG, UndefLHS, UndefRHS);\n\n    // Attempt to avoid multi-use ops if we don't need anything from them.\n    // TODO - use KnownUndef to relax the demandedelts?\n    if (!DemandedElts.isAllOnesValue())\n      if (SimplifyDemandedVectorEltsBinOp(Op0, Op1))\n        return true;\n    break;\n  }\n  case ISD::SHL:\n  case ISD::SRL:\n  case ISD::SRA:\n  case ISD::ROTL:\n  case ISD::ROTR: {\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n\n    APInt UndefRHS, ZeroRHS;\n    if (SimplifyDemandedVectorElts(Op1, DemandedElts, UndefRHS, ZeroRHS, TLO,\n                                   Depth + 1))\n      return true;\n    APInt UndefLHS, ZeroLHS;\n    if (SimplifyDemandedVectorElts(Op0, DemandedElts, UndefLHS, ZeroLHS, TLO,\n                                   Depth + 1))\n      return true;\n\n    KnownZero = ZeroLHS;\n    KnownUndef = UndefLHS & UndefRHS; // TODO: use getKnownUndefForVectorBinop?\n\n    // Attempt to avoid multi-use ops if we don't need anything from them.\n    // TODO - use KnownUndef to relax the demandedelts?\n    if (!DemandedElts.isAllOnesValue())\n      if (SimplifyDemandedVectorEltsBinOp(Op0, Op1))\n        return true;\n    break;\n  }\n  case ISD::MUL:\n  case ISD::AND: {\n    SDValue Op0 = Op.getOperand(0);\n    SDValue Op1 = Op.getOperand(1);\n\n    APInt SrcUndef, SrcZero;\n    if (SimplifyDemandedVectorElts(Op1, DemandedElts, SrcUndef, SrcZero, TLO,\n                                   Depth + 1))\n      return true;\n    if (SimplifyDemandedVectorElts(Op0, DemandedElts, KnownUndef, KnownZero,\n                                   TLO, Depth + 1))\n      return true;\n\n    // If either side has a zero element, then the result element is zero, even\n    // if the other is an UNDEF.\n    // TODO: Extend getKnownUndefForVectorBinop to also deal with known zeros\n    // and then handle 'and' nodes with the rest of the binop opcodes.\n    KnownZero |= SrcZero;\n    KnownUndef &= SrcUndef;\n    KnownUndef &= ~KnownZero;\n\n    // Attempt to avoid multi-use ops if we don't need anything from them.\n    // TODO - use KnownUndef to relax the demandedelts?\n    if (!DemandedElts.isAllOnesValue())\n      if (SimplifyDemandedVectorEltsBinOp(Op0, Op1))\n        return true;\n    break;\n  }\n  case ISD::TRUNCATE:\n  case ISD::SIGN_EXTEND:\n  case ISD::ZERO_EXTEND:\n    if (SimplifyDemandedVectorElts(Op.getOperand(0), DemandedElts, KnownUndef,\n                                   KnownZero, TLO, Depth + 1))\n      return true;\n\n    if (Op.getOpcode() == ISD::ZERO_EXTEND) {\n      // zext(undef) upper bits are guaranteed to be zero.\n      if (DemandedElts.isSubsetOf(KnownUndef))\n        return TLO.CombineTo(Op, TLO.DAG.getConstant(0, SDLoc(Op), VT));\n      KnownUndef.clearAllBits();\n    }\n    break;\n  default: {\n    if (Op.getOpcode() >= ISD::BUILTIN_OP_END) {\n      if (SimplifyDemandedVectorEltsForTargetNode(Op, DemandedElts, KnownUndef,\n                                                  KnownZero, TLO, Depth))\n        return true;\n    } else {\n      KnownBits Known;\n      APInt DemandedBits = APInt::getAllOnesValue(EltSizeInBits);\n      if (SimplifyDemandedBits(Op, DemandedBits, OriginalDemandedElts, Known,\n                               TLO, Depth, AssumeSingleUse))\n        return true;\n    }\n    break;\n  }\n  }\n  assert((KnownUndef & KnownZero) == 0 && \"Elements flagged as undef AND zero\");\n\n  // Constant fold all undef cases.\n  // TODO: Handle zero cases as well.\n  if (DemandedElts.isSubsetOf(KnownUndef))\n    return TLO.CombineTo(Op, TLO.DAG.getUNDEF(VT));\n\n  return false;\n}\n\n/// Determine which of the bits specified in Mask are known to be either zero or\n/// one and return them in the Known.\nvoid TargetLowering::computeKnownBitsForTargetNode(const SDValue Op,\n                                                   KnownBits &Known,\n                                                   const APInt &DemandedElts,\n                                                   const SelectionDAG &DAG,\n                                                   unsigned Depth) const {\n  assert((Op.getOpcode() >= ISD::BUILTIN_OP_END ||\n          Op.getOpcode() == ISD::INTRINSIC_WO_CHAIN ||\n          Op.getOpcode() == ISD::INTRINSIC_W_CHAIN ||\n          Op.getOpcode() == ISD::INTRINSIC_VOID) &&\n         \"Should use MaskedValueIsZero if you don't know whether Op\"\n         \" is a target node!\");\n  Known.resetAll();\n}\n\nvoid TargetLowering::computeKnownBitsForTargetInstr(\n    GISelKnownBits &Analysis, Register R, KnownBits &Known,\n    const APInt &DemandedElts, const MachineRegisterInfo &MRI,\n    unsigned Depth) const {\n  Known.resetAll();\n}\n\nvoid TargetLowering::computeKnownBitsForFrameIndex(\n  const int FrameIdx, KnownBits &Known, const MachineFunction &MF) const {\n  // The low bits are known zero if the pointer is aligned.\n  Known.Zero.setLowBits(Log2(MF.getFrameInfo().getObjectAlign(FrameIdx)));\n}\n\nAlign TargetLowering::computeKnownAlignForTargetInstr(\n  GISelKnownBits &Analysis, Register R, const MachineRegisterInfo &MRI,\n  unsigned Depth) const {\n  return Align(1);\n}\n\n/// This method can be implemented by targets that want to expose additional\n/// information about sign bits to the DAG Combiner.\nunsigned TargetLowering::ComputeNumSignBitsForTargetNode(SDValue Op,\n                                                         const APInt &,\n                                                         const SelectionDAG &,\n                                                         unsigned Depth) const {\n  assert((Op.getOpcode() >= ISD::BUILTIN_OP_END ||\n          Op.getOpcode() == ISD::INTRINSIC_WO_CHAIN ||\n          Op.getOpcode() == ISD::INTRINSIC_W_CHAIN ||\n          Op.getOpcode() == ISD::INTRINSIC_VOID) &&\n         \"Should use ComputeNumSignBits if you don't know whether Op\"\n         \" is a target node!\");\n  return 1;\n}\n\nunsigned TargetLowering::computeNumSignBitsForTargetInstr(\n  GISelKnownBits &Analysis, Register R, const APInt &DemandedElts,\n  const MachineRegisterInfo &MRI, unsigned Depth) const {\n  return 1;\n}\n\nbool TargetLowering::SimplifyDemandedVectorEltsForTargetNode(\n    SDValue Op, const APInt &DemandedElts, APInt &KnownUndef, APInt &KnownZero,\n    TargetLoweringOpt &TLO, unsigned Depth) const {\n  assert((Op.getOpcode() >= ISD::BUILTIN_OP_END ||\n          Op.getOpcode() == ISD::INTRINSIC_WO_CHAIN ||\n          Op.getOpcode() == ISD::INTRINSIC_W_CHAIN ||\n          Op.getOpcode() == ISD::INTRINSIC_VOID) &&\n         \"Should use SimplifyDemandedVectorElts if you don't know whether Op\"\n         \" is a target node!\");\n  return false;\n}\n\nbool TargetLowering::SimplifyDemandedBitsForTargetNode(\n    SDValue Op, const APInt &DemandedBits, const APInt &DemandedElts,\n    KnownBits &Known, TargetLoweringOpt &TLO, unsigned Depth) const {\n  assert((Op.getOpcode() >= ISD::BUILTIN_OP_END ||\n          Op.getOpcode() == ISD::INTRINSIC_WO_CHAIN ||\n          Op.getOpcode() == ISD::INTRINSIC_W_CHAIN ||\n          Op.getOpcode() == ISD::INTRINSIC_VOID) &&\n         \"Should use SimplifyDemandedBits if you don't know whether Op\"\n         \" is a target node!\");\n  computeKnownBitsForTargetNode(Op, Known, DemandedElts, TLO.DAG, Depth);\n  return false;\n}\n\nSDValue TargetLowering::SimplifyMultipleUseDemandedBitsForTargetNode(\n    SDValue Op, const APInt &DemandedBits, const APInt &DemandedElts,\n    SelectionDAG &DAG, unsigned Depth) const {\n  assert(\n      (Op.getOpcode() >= ISD::BUILTIN_OP_END ||\n       Op.getOpcode() == ISD::INTRINSIC_WO_CHAIN ||\n       Op.getOpcode() == ISD::INTRINSIC_W_CHAIN ||\n       Op.getOpcode() == ISD::INTRINSIC_VOID) &&\n      \"Should use SimplifyMultipleUseDemandedBits if you don't know whether Op\"\n      \" is a target node!\");\n  return SDValue();\n}\n\nSDValue\nTargetLowering::buildLegalVectorShuffle(EVT VT, const SDLoc &DL, SDValue N0,\n                                        SDValue N1, MutableArrayRef<int> Mask,\n                                        SelectionDAG &DAG) const {\n  bool LegalMask = isShuffleMaskLegal(Mask, VT);\n  if (!LegalMask) {\n    std::swap(N0, N1);\n    ShuffleVectorSDNode::commuteMask(Mask);\n    LegalMask = isShuffleMaskLegal(Mask, VT);\n  }\n\n  if (!LegalMask)\n    return SDValue();\n\n  return DAG.getVectorShuffle(VT, DL, N0, N1, Mask);\n}\n\nconst Constant *TargetLowering::getTargetConstantFromLoad(LoadSDNode*) const {\n  return nullptr;\n}\n\nbool TargetLowering::isKnownNeverNaNForTargetNode(SDValue Op,\n                                                  const SelectionDAG &DAG,\n                                                  bool SNaN,\n                                                  unsigned Depth) const {\n  assert((Op.getOpcode() >= ISD::BUILTIN_OP_END ||\n          Op.getOpcode() == ISD::INTRINSIC_WO_CHAIN ||\n          Op.getOpcode() == ISD::INTRINSIC_W_CHAIN ||\n          Op.getOpcode() == ISD::INTRINSIC_VOID) &&\n         \"Should use isKnownNeverNaN if you don't know whether Op\"\n         \" is a target node!\");\n  return false;\n}\n\n// FIXME: Ideally, this would use ISD::isConstantSplatVector(), but that must\n// work with truncating build vectors and vectors with elements of less than\n// 8 bits.\nbool TargetLowering::isConstTrueVal(const SDNode *N) const {\n  if (!N)\n    return false;\n\n  APInt CVal;\n  if (auto *CN = dyn_cast<ConstantSDNode>(N)) {\n    CVal = CN->getAPIntValue();\n  } else if (auto *BV = dyn_cast<BuildVectorSDNode>(N)) {\n    auto *CN = BV->getConstantSplatNode();\n    if (!CN)\n      return false;\n\n    // If this is a truncating build vector, truncate the splat value.\n    // Otherwise, we may fail to match the expected values below.\n    unsigned BVEltWidth = BV->getValueType(0).getScalarSizeInBits();\n    CVal = CN->getAPIntValue();\n    if (BVEltWidth < CVal.getBitWidth())\n      CVal = CVal.trunc(BVEltWidth);\n  } else {\n    return false;\n  }\n\n  switch (getBooleanContents(N->getValueType(0))) {\n  case UndefinedBooleanContent:\n    return CVal[0];\n  case ZeroOrOneBooleanContent:\n    return CVal.isOneValue();\n  case ZeroOrNegativeOneBooleanContent:\n    return CVal.isAllOnesValue();\n  }\n\n  llvm_unreachable(\"Invalid boolean contents\");\n}\n\nbool TargetLowering::isConstFalseVal(const SDNode *N) const {\n  if (!N)\n    return false;\n\n  const ConstantSDNode *CN = dyn_cast<ConstantSDNode>(N);\n  if (!CN) {\n    const BuildVectorSDNode *BV = dyn_cast<BuildVectorSDNode>(N);\n    if (!BV)\n      return false;\n\n    // Only interested in constant splats, we don't care about undef\n    // elements in identifying boolean constants and getConstantSplatNode\n    // returns NULL if all ops are undef;\n    CN = BV->getConstantSplatNode();\n    if (!CN)\n      return false;\n  }\n\n  if (getBooleanContents(N->getValueType(0)) == UndefinedBooleanContent)\n    return !CN->getAPIntValue()[0];\n\n  return CN->isNullValue();\n}\n\nbool TargetLowering::isExtendedTrueVal(const ConstantSDNode *N, EVT VT,\n                                       bool SExt) const {\n  if (VT == MVT::i1)\n    return N->isOne();\n\n  TargetLowering::BooleanContent Cnt = getBooleanContents(VT);\n  switch (Cnt) {\n  case TargetLowering::ZeroOrOneBooleanContent:\n    // An extended value of 1 is always true, unless its original type is i1,\n    // in which case it will be sign extended to -1.\n    return (N->isOne() && !SExt) || (SExt && (N->getValueType(0) != MVT::i1));\n  case TargetLowering::UndefinedBooleanContent:\n  case TargetLowering::ZeroOrNegativeOneBooleanContent:\n    return N->isAllOnesValue() && SExt;\n  }\n  llvm_unreachable(\"Unexpected enumeration.\");\n}\n\n/// This helper function of SimplifySetCC tries to optimize the comparison when\n/// either operand of the SetCC node is a bitwise-and instruction.\nSDValue TargetLowering::foldSetCCWithAnd(EVT VT, SDValue N0, SDValue N1,\n                                         ISD::CondCode Cond, const SDLoc &DL,\n                                         DAGCombinerInfo &DCI) const {\n  // Match these patterns in any of their permutations:\n  // (X & Y) == Y\n  // (X & Y) != Y\n  if (N1.getOpcode() == ISD::AND && N0.getOpcode() != ISD::AND)\n    std::swap(N0, N1);\n\n  EVT OpVT = N0.getValueType();\n  if (N0.getOpcode() != ISD::AND || !OpVT.isInteger() ||\n      (Cond != ISD::SETEQ && Cond != ISD::SETNE))\n    return SDValue();\n\n  SDValue X, Y;\n  if (N0.getOperand(0) == N1) {\n    X = N0.getOperand(1);\n    Y = N0.getOperand(0);\n  } else if (N0.getOperand(1) == N1) {\n    X = N0.getOperand(0);\n    Y = N0.getOperand(1);\n  } else {\n    return SDValue();\n  }\n\n  SelectionDAG &DAG = DCI.DAG;\n  SDValue Zero = DAG.getConstant(0, DL, OpVT);\n  if (DAG.isKnownToBeAPowerOfTwo(Y)) {\n    // Simplify X & Y == Y to X & Y != 0 if Y has exactly one bit set.\n    // Note that where Y is variable and is known to have at most one bit set\n    // (for example, if it is Z & 1) we cannot do this; the expressions are not\n    // equivalent when Y == 0.\n    assert(OpVT.isInteger());\n    Cond = ISD::getSetCCInverse(Cond, OpVT);\n    if (DCI.isBeforeLegalizeOps() ||\n        isCondCodeLegal(Cond, N0.getSimpleValueType()))\n      return DAG.getSetCC(DL, VT, N0, Zero, Cond);\n  } else if (N0.hasOneUse() && hasAndNotCompare(Y)) {\n    // If the target supports an 'and-not' or 'and-complement' logic operation,\n    // try to use that to make a comparison operation more efficient.\n    // But don't do this transform if the mask is a single bit because there are\n    // more efficient ways to deal with that case (for example, 'bt' on x86 or\n    // 'rlwinm' on PPC).\n\n    // Bail out if the compare operand that we want to turn into a zero is\n    // already a zero (otherwise, infinite loop).\n    auto *YConst = dyn_cast<ConstantSDNode>(Y);\n    if (YConst && YConst->isNullValue())\n      return SDValue();\n\n    // Transform this into: ~X & Y == 0.\n    SDValue NotX = DAG.getNOT(SDLoc(X), X, OpVT);\n    SDValue NewAnd = DAG.getNode(ISD::AND, SDLoc(N0), OpVT, NotX, Y);\n    return DAG.getSetCC(DL, VT, NewAnd, Zero, Cond);\n  }\n\n  return SDValue();\n}\n\n/// There are multiple IR patterns that could be checking whether certain\n/// truncation of a signed number would be lossy or not. The pattern which is\n/// best at IR level, may not lower optimally. Thus, we want to unfold it.\n/// We are looking for the following pattern: (KeptBits is a constant)\n///   (add %x, (1 << (KeptBits-1))) srccond (1 << KeptBits)\n/// KeptBits won't be bitwidth(x), that will be constant-folded to true/false.\n/// KeptBits also can't be 1, that would have been folded to  %x dstcond 0\n/// We will unfold it into the natural trunc+sext pattern:\n///   ((%x << C) a>> C) dstcond %x\n/// Where  C = bitwidth(x) - KeptBits  and  C u< bitwidth(x)\nSDValue TargetLowering::optimizeSetCCOfSignedTruncationCheck(\n    EVT SCCVT, SDValue N0, SDValue N1, ISD::CondCode Cond, DAGCombinerInfo &DCI,\n    const SDLoc &DL) const {\n  // We must be comparing with a constant.\n  ConstantSDNode *C1;\n  if (!(C1 = dyn_cast<ConstantSDNode>(N1)))\n    return SDValue();\n\n  // N0 should be:  add %x, (1 << (KeptBits-1))\n  if (N0->getOpcode() != ISD::ADD)\n    return SDValue();\n\n  // And we must be 'add'ing a constant.\n  ConstantSDNode *C01;\n  if (!(C01 = dyn_cast<ConstantSDNode>(N0->getOperand(1))))\n    return SDValue();\n\n  SDValue X = N0->getOperand(0);\n  EVT XVT = X.getValueType();\n\n  // Validate constants ...\n\n  APInt I1 = C1->getAPIntValue();\n\n  ISD::CondCode NewCond;\n  if (Cond == ISD::CondCode::SETULT) {\n    NewCond = ISD::CondCode::SETEQ;\n  } else if (Cond == ISD::CondCode::SETULE) {\n    NewCond = ISD::CondCode::SETEQ;\n    // But need to 'canonicalize' the constant.\n    I1 += 1;\n  } else if (Cond == ISD::CondCode::SETUGT) {\n    NewCond = ISD::CondCode::SETNE;\n    // But need to 'canonicalize' the constant.\n    I1 += 1;\n  } else if (Cond == ISD::CondCode::SETUGE) {\n    NewCond = ISD::CondCode::SETNE;\n  } else\n    return SDValue();\n\n  APInt I01 = C01->getAPIntValue();\n\n  auto checkConstants = [&I1, &I01]() -> bool {\n    // Both of them must be power-of-two, and the constant from setcc is bigger.\n    return I1.ugt(I01) && I1.isPowerOf2() && I01.isPowerOf2();\n  };\n\n  if (checkConstants()) {\n    // Great, e.g. got  icmp ult i16 (add i16 %x, 128), 256\n  } else {\n    // What if we invert constants? (and the target predicate)\n    I1.negate();\n    I01.negate();\n    assert(XVT.isInteger());\n    NewCond = getSetCCInverse(NewCond, XVT);\n    if (!checkConstants())\n      return SDValue();\n    // Great, e.g. got  icmp uge i16 (add i16 %x, -128), -256\n  }\n\n  // They are power-of-two, so which bit is set?\n  const unsigned KeptBits = I1.logBase2();\n  const unsigned KeptBitsMinusOne = I01.logBase2();\n\n  // Magic!\n  if (KeptBits != (KeptBitsMinusOne + 1))\n    return SDValue();\n  assert(KeptBits > 0 && KeptBits < XVT.getSizeInBits() && \"unreachable\");\n\n  // We don't want to do this in every single case.\n  SelectionDAG &DAG = DCI.DAG;\n  if (!DAG.getTargetLoweringInfo().shouldTransformSignedTruncationCheck(\n          XVT, KeptBits))\n    return SDValue();\n\n  const unsigned MaskedBits = XVT.getSizeInBits() - KeptBits;\n  assert(MaskedBits > 0 && MaskedBits < XVT.getSizeInBits() && \"unreachable\");\n\n  // Unfold into:  ((%x << C) a>> C) cond %x\n  // Where 'cond' will be either 'eq' or 'ne'.\n  SDValue ShiftAmt = DAG.getConstant(MaskedBits, DL, XVT);\n  SDValue T0 = DAG.getNode(ISD::SHL, DL, XVT, X, ShiftAmt);\n  SDValue T1 = DAG.getNode(ISD::SRA, DL, XVT, T0, ShiftAmt);\n  SDValue T2 = DAG.getSetCC(DL, SCCVT, T1, X, NewCond);\n\n  return T2;\n}\n\n// (X & (C l>>/<< Y)) ==/!= 0  -->  ((X <</l>> Y) & C) ==/!= 0\nSDValue TargetLowering::optimizeSetCCByHoistingAndByConstFromLogicalShift(\n    EVT SCCVT, SDValue N0, SDValue N1C, ISD::CondCode Cond,\n    DAGCombinerInfo &DCI, const SDLoc &DL) const {\n  assert(isConstOrConstSplat(N1C) &&\n         isConstOrConstSplat(N1C)->getAPIntValue().isNullValue() &&\n         \"Should be a comparison with 0.\");\n  assert((Cond == ISD::SETEQ || Cond == ISD::SETNE) &&\n         \"Valid only for [in]equality comparisons.\");\n\n  unsigned NewShiftOpcode;\n  SDValue X, C, Y;\n\n  SelectionDAG &DAG = DCI.DAG;\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n\n  // Look for '(C l>>/<< Y)'.\n  auto Match = [&NewShiftOpcode, &X, &C, &Y, &TLI, &DAG](SDValue V) {\n    // The shift should be one-use.\n    if (!V.hasOneUse())\n      return false;\n    unsigned OldShiftOpcode = V.getOpcode();\n    switch (OldShiftOpcode) {\n    case ISD::SHL:\n      NewShiftOpcode = ISD::SRL;\n      break;\n    case ISD::SRL:\n      NewShiftOpcode = ISD::SHL;\n      break;\n    default:\n      return false; // must be a logical shift.\n    }\n    // We should be shifting a constant.\n    // FIXME: best to use isConstantOrConstantVector().\n    C = V.getOperand(0);\n    ConstantSDNode *CC =\n        isConstOrConstSplat(C, /*AllowUndefs=*/true, /*AllowTruncation=*/true);\n    if (!CC)\n      return false;\n    Y = V.getOperand(1);\n\n    ConstantSDNode *XC =\n        isConstOrConstSplat(X, /*AllowUndefs=*/true, /*AllowTruncation=*/true);\n    return TLI.shouldProduceAndByConstByHoistingConstFromShiftsLHSOfAnd(\n        X, XC, CC, Y, OldShiftOpcode, NewShiftOpcode, DAG);\n  };\n\n  // LHS of comparison should be an one-use 'and'.\n  if (N0.getOpcode() != ISD::AND || !N0.hasOneUse())\n    return SDValue();\n\n  X = N0.getOperand(0);\n  SDValue Mask = N0.getOperand(1);\n\n  // 'and' is commutative!\n  if (!Match(Mask)) {\n    std::swap(X, Mask);\n    if (!Match(Mask))\n      return SDValue();\n  }\n\n  EVT VT = X.getValueType();\n\n  // Produce:\n  // ((X 'OppositeShiftOpcode' Y) & C) Cond 0\n  SDValue T0 = DAG.getNode(NewShiftOpcode, DL, VT, X, Y);\n  SDValue T1 = DAG.getNode(ISD::AND, DL, VT, T0, C);\n  SDValue T2 = DAG.getSetCC(DL, SCCVT, T1, N1C, Cond);\n  return T2;\n}\n\n/// Try to fold an equality comparison with a {add/sub/xor} binary operation as\n/// the 1st operand (N0). Callers are expected to swap the N0/N1 parameters to\n/// handle the commuted versions of these patterns.\nSDValue TargetLowering::foldSetCCWithBinOp(EVT VT, SDValue N0, SDValue N1,\n                                           ISD::CondCode Cond, const SDLoc &DL,\n                                           DAGCombinerInfo &DCI) const {\n  unsigned BOpcode = N0.getOpcode();\n  assert((BOpcode == ISD::ADD || BOpcode == ISD::SUB || BOpcode == ISD::XOR) &&\n         \"Unexpected binop\");\n  assert((Cond == ISD::SETEQ || Cond == ISD::SETNE) && \"Unexpected condcode\");\n\n  // (X + Y) == X --> Y == 0\n  // (X - Y) == X --> Y == 0\n  // (X ^ Y) == X --> Y == 0\n  SelectionDAG &DAG = DCI.DAG;\n  EVT OpVT = N0.getValueType();\n  SDValue X = N0.getOperand(0);\n  SDValue Y = N0.getOperand(1);\n  if (X == N1)\n    return DAG.getSetCC(DL, VT, Y, DAG.getConstant(0, DL, OpVT), Cond);\n\n  if (Y != N1)\n    return SDValue();\n\n  // (X + Y) == Y --> X == 0\n  // (X ^ Y) == Y --> X == 0\n  if (BOpcode == ISD::ADD || BOpcode == ISD::XOR)\n    return DAG.getSetCC(DL, VT, X, DAG.getConstant(0, DL, OpVT), Cond);\n\n  // The shift would not be valid if the operands are boolean (i1).\n  if (!N0.hasOneUse() || OpVT.getScalarSizeInBits() == 1)\n    return SDValue();\n\n  // (X - Y) == Y --> X == Y << 1\n  EVT ShiftVT = getShiftAmountTy(OpVT, DAG.getDataLayout(),\n                                 !DCI.isBeforeLegalize());\n  SDValue One = DAG.getConstant(1, DL, ShiftVT);\n  SDValue YShl1 = DAG.getNode(ISD::SHL, DL, N1.getValueType(), Y, One);\n  if (!DCI.isCalledByLegalizer())\n    DCI.AddToWorklist(YShl1.getNode());\n  return DAG.getSetCC(DL, VT, X, YShl1, Cond);\n}\n\nstatic SDValue simplifySetCCWithCTPOP(const TargetLowering &TLI, EVT VT,\n                                      SDValue N0, const APInt &C1,\n                                      ISD::CondCode Cond, const SDLoc &dl,\n                                      SelectionDAG &DAG) {\n  // Look through truncs that don't change the value of a ctpop.\n  // FIXME: Add vector support? Need to be careful with setcc result type below.\n  SDValue CTPOP = N0;\n  if (N0.getOpcode() == ISD::TRUNCATE && N0.hasOneUse() && !VT.isVector() &&\n      N0.getScalarValueSizeInBits() > Log2_32(N0.getOperand(0).getScalarValueSizeInBits()))\n    CTPOP = N0.getOperand(0);\n\n  if (CTPOP.getOpcode() != ISD::CTPOP || !CTPOP.hasOneUse())\n    return SDValue();\n\n  EVT CTVT = CTPOP.getValueType();\n  SDValue CTOp = CTPOP.getOperand(0);\n\n  // If this is a vector CTPOP, keep the CTPOP if it is legal.\n  // TODO: Should we check if CTPOP is legal(or custom) for scalars?\n  if (VT.isVector() && TLI.isOperationLegal(ISD::CTPOP, CTVT))\n    return SDValue();\n\n  // (ctpop x) u< 2 -> (x & x-1) == 0\n  // (ctpop x) u> 1 -> (x & x-1) != 0\n  if (Cond == ISD::SETULT || Cond == ISD::SETUGT) {\n    unsigned CostLimit = TLI.getCustomCtpopCost(CTVT, Cond);\n    if (C1.ugt(CostLimit + (Cond == ISD::SETULT)))\n      return SDValue();\n    if (C1 == 0 && (Cond == ISD::SETULT))\n      return SDValue(); // This is handled elsewhere.\n\n    unsigned Passes = C1.getLimitedValue() - (Cond == ISD::SETULT);\n\n    SDValue NegOne = DAG.getAllOnesConstant(dl, CTVT);\n    SDValue Result = CTOp;\n    for (unsigned i = 0; i < Passes; i++) {\n      SDValue Add = DAG.getNode(ISD::ADD, dl, CTVT, Result, NegOne);\n      Result = DAG.getNode(ISD::AND, dl, CTVT, Result, Add);\n    }\n    ISD::CondCode CC = Cond == ISD::SETULT ? ISD::SETEQ : ISD::SETNE;\n    return DAG.getSetCC(dl, VT, Result, DAG.getConstant(0, dl, CTVT), CC);\n  }\n\n  // If ctpop is not supported, expand a power-of-2 comparison based on it.\n  if ((Cond == ISD::SETEQ || Cond == ISD::SETNE) && C1 == 1) {\n    // For scalars, keep CTPOP if it is legal or custom.\n    if (!VT.isVector() && TLI.isOperationLegalOrCustom(ISD::CTPOP, CTVT))\n      return SDValue();\n    // This is based on X86's custom lowering for CTPOP which produces more\n    // instructions than the expansion here.\n\n    // (ctpop x) == 1 --> (x != 0) && ((x & x-1) == 0)\n    // (ctpop x) != 1 --> (x == 0) || ((x & x-1) != 0)\n    SDValue Zero = DAG.getConstant(0, dl, CTVT);\n    SDValue NegOne = DAG.getAllOnesConstant(dl, CTVT);\n    assert(CTVT.isInteger());\n    ISD::CondCode InvCond = ISD::getSetCCInverse(Cond, CTVT);\n    SDValue Add = DAG.getNode(ISD::ADD, dl, CTVT, CTOp, NegOne);\n    SDValue And = DAG.getNode(ISD::AND, dl, CTVT, CTOp, Add);\n    SDValue LHS = DAG.getSetCC(dl, VT, CTOp, Zero, InvCond);\n    SDValue RHS = DAG.getSetCC(dl, VT, And, Zero, Cond);\n    unsigned LogicOpcode = Cond == ISD::SETEQ ? ISD::AND : ISD::OR;\n    return DAG.getNode(LogicOpcode, dl, VT, LHS, RHS);\n  }\n\n  return SDValue();\n}\n\n/// Try to simplify a setcc built with the specified operands and cc. If it is\n/// unable to simplify it, return a null SDValue.\nSDValue TargetLowering::SimplifySetCC(EVT VT, SDValue N0, SDValue N1,\n                                      ISD::CondCode Cond, bool foldBooleans,\n                                      DAGCombinerInfo &DCI,\n                                      const SDLoc &dl) const {\n  SelectionDAG &DAG = DCI.DAG;\n  const DataLayout &Layout = DAG.getDataLayout();\n  EVT OpVT = N0.getValueType();\n\n  // Constant fold or commute setcc.\n  if (SDValue Fold = DAG.FoldSetCC(VT, N0, N1, Cond, dl))\n    return Fold;\n\n  // Ensure that the constant occurs on the RHS and fold constant comparisons.\n  // TODO: Handle non-splat vector constants. All undef causes trouble.\n  // FIXME: We can't yet fold constant scalable vector splats, so avoid an\n  // infinite loop here when we encounter one.\n  ISD::CondCode SwappedCC = ISD::getSetCCSwappedOperands(Cond);\n  if (isConstOrConstSplat(N0) &&\n      (!OpVT.isScalableVector() || !isConstOrConstSplat(N1)) &&\n      (DCI.isBeforeLegalizeOps() ||\n       isCondCodeLegal(SwappedCC, N0.getSimpleValueType())))\n    return DAG.getSetCC(dl, VT, N1, N0, SwappedCC);\n\n  // If we have a subtract with the same 2 non-constant operands as this setcc\n  // -- but in reverse order -- then try to commute the operands of this setcc\n  // to match. A matching pair of setcc (cmp) and sub may be combined into 1\n  // instruction on some targets.\n  if (!isConstOrConstSplat(N0) && !isConstOrConstSplat(N1) &&\n      (DCI.isBeforeLegalizeOps() ||\n       isCondCodeLegal(SwappedCC, N0.getSimpleValueType())) &&\n      DAG.doesNodeExist(ISD::SUB, DAG.getVTList(OpVT), {N1, N0}) &&\n      !DAG.doesNodeExist(ISD::SUB, DAG.getVTList(OpVT), {N0, N1}))\n    return DAG.getSetCC(dl, VT, N1, N0, SwappedCC);\n\n  if (auto *N1C = isConstOrConstSplat(N1)) {\n    const APInt &C1 = N1C->getAPIntValue();\n\n    // Optimize some CTPOP cases.\n    if (SDValue V = simplifySetCCWithCTPOP(*this, VT, N0, C1, Cond, dl, DAG))\n      return V;\n\n    // If the LHS is '(srl (ctlz x), 5)', the RHS is 0/1, and this is an\n    // equality comparison, then we're just comparing whether X itself is\n    // zero.\n    if (N0.getOpcode() == ISD::SRL && (C1.isNullValue() || C1.isOneValue()) &&\n        N0.getOperand(0).getOpcode() == ISD::CTLZ &&\n        isPowerOf2_32(N0.getScalarValueSizeInBits())) {\n      if (ConstantSDNode *ShAmt = isConstOrConstSplat(N0.getOperand(1))) {\n        if ((Cond == ISD::SETEQ || Cond == ISD::SETNE) &&\n            ShAmt->getAPIntValue() == Log2_32(N0.getScalarValueSizeInBits())) {\n          if ((C1 == 0) == (Cond == ISD::SETEQ)) {\n            // (srl (ctlz x), 5) == 0  -> X != 0\n            // (srl (ctlz x), 5) != 1  -> X != 0\n            Cond = ISD::SETNE;\n          } else {\n            // (srl (ctlz x), 5) != 0  -> X == 0\n            // (srl (ctlz x), 5) == 1  -> X == 0\n            Cond = ISD::SETEQ;\n          }\n          SDValue Zero = DAG.getConstant(0, dl, N0.getValueType());\n          return DAG.getSetCC(dl, VT, N0.getOperand(0).getOperand(0), Zero,\n                              Cond);\n        }\n      }\n    }\n  }\n\n  // FIXME: Support vectors.\n  if (auto *N1C = dyn_cast<ConstantSDNode>(N1.getNode())) {\n    const APInt &C1 = N1C->getAPIntValue();\n\n    // (zext x) == C --> x == (trunc C)\n    // (sext x) == C --> x == (trunc C)\n    if ((Cond == ISD::SETEQ || Cond == ISD::SETNE) &&\n        DCI.isBeforeLegalize() && N0->hasOneUse()) {\n      unsigned MinBits = N0.getValueSizeInBits();\n      SDValue PreExt;\n      bool Signed = false;\n      if (N0->getOpcode() == ISD::ZERO_EXTEND) {\n        // ZExt\n        MinBits = N0->getOperand(0).getValueSizeInBits();\n        PreExt = N0->getOperand(0);\n      } else if (N0->getOpcode() == ISD::AND) {\n        // DAGCombine turns costly ZExts into ANDs\n        if (auto *C = dyn_cast<ConstantSDNode>(N0->getOperand(1)))\n          if ((C->getAPIntValue()+1).isPowerOf2()) {\n            MinBits = C->getAPIntValue().countTrailingOnes();\n            PreExt = N0->getOperand(0);\n          }\n      } else if (N0->getOpcode() == ISD::SIGN_EXTEND) {\n        // SExt\n        MinBits = N0->getOperand(0).getValueSizeInBits();\n        PreExt = N0->getOperand(0);\n        Signed = true;\n      } else if (auto *LN0 = dyn_cast<LoadSDNode>(N0)) {\n        // ZEXTLOAD / SEXTLOAD\n        if (LN0->getExtensionType() == ISD::ZEXTLOAD) {\n          MinBits = LN0->getMemoryVT().getSizeInBits();\n          PreExt = N0;\n        } else if (LN0->getExtensionType() == ISD::SEXTLOAD) {\n          Signed = true;\n          MinBits = LN0->getMemoryVT().getSizeInBits();\n          PreExt = N0;\n        }\n      }\n\n      // Figure out how many bits we need to preserve this constant.\n      unsigned ReqdBits = Signed ?\n        C1.getBitWidth() - C1.getNumSignBits() + 1 :\n        C1.getActiveBits();\n\n      // Make sure we're not losing bits from the constant.\n      if (MinBits > 0 &&\n          MinBits < C1.getBitWidth() &&\n          MinBits >= ReqdBits) {\n        EVT MinVT = EVT::getIntegerVT(*DAG.getContext(), MinBits);\n        if (isTypeDesirableForOp(ISD::SETCC, MinVT)) {\n          // Will get folded away.\n          SDValue Trunc = DAG.getNode(ISD::TRUNCATE, dl, MinVT, PreExt);\n          if (MinBits == 1 && C1 == 1)\n            // Invert the condition.\n            return DAG.getSetCC(dl, VT, Trunc, DAG.getConstant(0, dl, MVT::i1),\n                                Cond == ISD::SETEQ ? ISD::SETNE : ISD::SETEQ);\n          SDValue C = DAG.getConstant(C1.trunc(MinBits), dl, MinVT);\n          return DAG.getSetCC(dl, VT, Trunc, C, Cond);\n        }\n\n        // If truncating the setcc operands is not desirable, we can still\n        // simplify the expression in some cases:\n        // setcc ([sz]ext (setcc x, y, cc)), 0, setne) -> setcc (x, y, cc)\n        // setcc ([sz]ext (setcc x, y, cc)), 0, seteq) -> setcc (x, y, inv(cc))\n        // setcc (zext (setcc x, y, cc)), 1, setne) -> setcc (x, y, inv(cc))\n        // setcc (zext (setcc x, y, cc)), 1, seteq) -> setcc (x, y, cc)\n        // setcc (sext (setcc x, y, cc)), -1, setne) -> setcc (x, y, inv(cc))\n        // setcc (sext (setcc x, y, cc)), -1, seteq) -> setcc (x, y, cc)\n        SDValue TopSetCC = N0->getOperand(0);\n        unsigned N0Opc = N0->getOpcode();\n        bool SExt = (N0Opc == ISD::SIGN_EXTEND);\n        if (TopSetCC.getValueType() == MVT::i1 && VT == MVT::i1 &&\n            TopSetCC.getOpcode() == ISD::SETCC &&\n            (N0Opc == ISD::ZERO_EXTEND || N0Opc == ISD::SIGN_EXTEND) &&\n            (isConstFalseVal(N1C) ||\n             isExtendedTrueVal(N1C, N0->getValueType(0), SExt))) {\n\n          bool Inverse = (N1C->isNullValue() && Cond == ISD::SETEQ) ||\n                         (!N1C->isNullValue() && Cond == ISD::SETNE);\n\n          if (!Inverse)\n            return TopSetCC;\n\n          ISD::CondCode InvCond = ISD::getSetCCInverse(\n              cast<CondCodeSDNode>(TopSetCC.getOperand(2))->get(),\n              TopSetCC.getOperand(0).getValueType());\n          return DAG.getSetCC(dl, VT, TopSetCC.getOperand(0),\n                                      TopSetCC.getOperand(1),\n                                      InvCond);\n        }\n      }\n    }\n\n    // If the LHS is '(and load, const)', the RHS is 0, the test is for\n    // equality or unsigned, and all 1 bits of the const are in the same\n    // partial word, see if we can shorten the load.\n    if (DCI.isBeforeLegalize() &&\n        !ISD::isSignedIntSetCC(Cond) &&\n        N0.getOpcode() == ISD::AND && C1 == 0 &&\n        N0.getNode()->hasOneUse() &&\n        isa<LoadSDNode>(N0.getOperand(0)) &&\n        N0.getOperand(0).getNode()->hasOneUse() &&\n        isa<ConstantSDNode>(N0.getOperand(1))) {\n      LoadSDNode *Lod = cast<LoadSDNode>(N0.getOperand(0));\n      APInt bestMask;\n      unsigned bestWidth = 0, bestOffset = 0;\n      if (Lod->isSimple() && Lod->isUnindexed()) {\n        unsigned origWidth = N0.getValueSizeInBits();\n        unsigned maskWidth = origWidth;\n        // We can narrow (e.g.) 16-bit extending loads on 32-bit target to\n        // 8 bits, but have to be careful...\n        if (Lod->getExtensionType() != ISD::NON_EXTLOAD)\n          origWidth = Lod->getMemoryVT().getSizeInBits();\n        const APInt &Mask = N0.getConstantOperandAPInt(1);\n        for (unsigned width = origWidth / 2; width>=8; width /= 2) {\n          APInt newMask = APInt::getLowBitsSet(maskWidth, width);\n          for (unsigned offset=0; offset<origWidth/width; offset++) {\n            if (Mask.isSubsetOf(newMask)) {\n              if (Layout.isLittleEndian())\n                bestOffset = (uint64_t)offset * (width/8);\n              else\n                bestOffset = (origWidth/width - offset - 1) * (width/8);\n              bestMask = Mask.lshr(offset * (width/8) * 8);\n              bestWidth = width;\n              break;\n            }\n            newMask <<= width;\n          }\n        }\n      }\n      if (bestWidth) {\n        EVT newVT = EVT::getIntegerVT(*DAG.getContext(), bestWidth);\n        if (newVT.isRound() &&\n            shouldReduceLoadWidth(Lod, ISD::NON_EXTLOAD, newVT)) {\n          SDValue Ptr = Lod->getBasePtr();\n          if (bestOffset != 0)\n            Ptr =\n                DAG.getMemBasePlusOffset(Ptr, TypeSize::Fixed(bestOffset), dl);\n          SDValue NewLoad =\n              DAG.getLoad(newVT, dl, Lod->getChain(), Ptr,\n                          Lod->getPointerInfo().getWithOffset(bestOffset),\n                          Lod->getOriginalAlign());\n          return DAG.getSetCC(dl, VT,\n                              DAG.getNode(ISD::AND, dl, newVT, NewLoad,\n                                      DAG.getConstant(bestMask.trunc(bestWidth),\n                                                      dl, newVT)),\n                              DAG.getConstant(0LL, dl, newVT), Cond);\n        }\n      }\n    }\n\n    // If the LHS is a ZERO_EXTEND, perform the comparison on the input.\n    if (N0.getOpcode() == ISD::ZERO_EXTEND) {\n      unsigned InSize = N0.getOperand(0).getValueSizeInBits();\n\n      // If the comparison constant has bits in the upper part, the\n      // zero-extended value could never match.\n      if (C1.intersects(APInt::getHighBitsSet(C1.getBitWidth(),\n                                              C1.getBitWidth() - InSize))) {\n        switch (Cond) {\n        case ISD::SETUGT:\n        case ISD::SETUGE:\n        case ISD::SETEQ:\n          return DAG.getConstant(0, dl, VT);\n        case ISD::SETULT:\n        case ISD::SETULE:\n        case ISD::SETNE:\n          return DAG.getConstant(1, dl, VT);\n        case ISD::SETGT:\n        case ISD::SETGE:\n          // True if the sign bit of C1 is set.\n          return DAG.getConstant(C1.isNegative(), dl, VT);\n        case ISD::SETLT:\n        case ISD::SETLE:\n          // True if the sign bit of C1 isn't set.\n          return DAG.getConstant(C1.isNonNegative(), dl, VT);\n        default:\n          break;\n        }\n      }\n\n      // Otherwise, we can perform the comparison with the low bits.\n      switch (Cond) {\n      case ISD::SETEQ:\n      case ISD::SETNE:\n      case ISD::SETUGT:\n      case ISD::SETUGE:\n      case ISD::SETULT:\n      case ISD::SETULE: {\n        EVT newVT = N0.getOperand(0).getValueType();\n        if (DCI.isBeforeLegalizeOps() ||\n            (isOperationLegal(ISD::SETCC, newVT) &&\n             isCondCodeLegal(Cond, newVT.getSimpleVT()))) {\n          EVT NewSetCCVT = getSetCCResultType(Layout, *DAG.getContext(), newVT);\n          SDValue NewConst = DAG.getConstant(C1.trunc(InSize), dl, newVT);\n\n          SDValue NewSetCC = DAG.getSetCC(dl, NewSetCCVT, N0.getOperand(0),\n                                          NewConst, Cond);\n          return DAG.getBoolExtOrTrunc(NewSetCC, dl, VT, N0.getValueType());\n        }\n        break;\n      }\n      default:\n        break; // todo, be more careful with signed comparisons\n      }\n    } else if (N0.getOpcode() == ISD::SIGN_EXTEND_INREG &&\n               (Cond == ISD::SETEQ || Cond == ISD::SETNE) &&\n               !isSExtCheaperThanZExt(cast<VTSDNode>(N0.getOperand(1))->getVT(),\n                                      OpVT)) {\n      EVT ExtSrcTy = cast<VTSDNode>(N0.getOperand(1))->getVT();\n      unsigned ExtSrcTyBits = ExtSrcTy.getSizeInBits();\n      EVT ExtDstTy = N0.getValueType();\n      unsigned ExtDstTyBits = ExtDstTy.getSizeInBits();\n\n      // If the constant doesn't fit into the number of bits for the source of\n      // the sign extension, it is impossible for both sides to be equal.\n      if (C1.getMinSignedBits() > ExtSrcTyBits)\n        return DAG.getBoolConstant(Cond == ISD::SETNE, dl, VT, OpVT);\n\n      assert(ExtDstTy == N0.getOperand(0).getValueType() &&\n             ExtDstTy != ExtSrcTy && \"Unexpected types!\");\n      APInt Imm = APInt::getLowBitsSet(ExtDstTyBits, ExtSrcTyBits);\n      SDValue ZextOp = DAG.getNode(ISD::AND, dl, ExtDstTy, N0.getOperand(0),\n                                   DAG.getConstant(Imm, dl, ExtDstTy));\n      if (!DCI.isCalledByLegalizer())\n        DCI.AddToWorklist(ZextOp.getNode());\n      // Otherwise, make this a use of a zext.\n      return DAG.getSetCC(dl, VT, ZextOp,\n                          DAG.getConstant(C1 & Imm, dl, ExtDstTy), Cond);\n    } else if ((N1C->isNullValue() || N1C->isOne()) &&\n                (Cond == ISD::SETEQ || Cond == ISD::SETNE)) {\n      // SETCC (SETCC), [0|1], [EQ|NE]  -> SETCC\n      if (N0.getOpcode() == ISD::SETCC &&\n          isTypeLegal(VT) && VT.bitsLE(N0.getValueType()) &&\n          (N0.getValueType() == MVT::i1 ||\n           getBooleanContents(N0.getOperand(0).getValueType()) ==\n                       ZeroOrOneBooleanContent)) {\n        bool TrueWhenTrue = (Cond == ISD::SETEQ) ^ (!N1C->isOne());\n        if (TrueWhenTrue)\n          return DAG.getNode(ISD::TRUNCATE, dl, VT, N0);\n        // Invert the condition.\n        ISD::CondCode CC = cast<CondCodeSDNode>(N0.getOperand(2))->get();\n        CC = ISD::getSetCCInverse(CC, N0.getOperand(0).getValueType());\n        if (DCI.isBeforeLegalizeOps() ||\n            isCondCodeLegal(CC, N0.getOperand(0).getSimpleValueType()))\n          return DAG.getSetCC(dl, VT, N0.getOperand(0), N0.getOperand(1), CC);\n      }\n\n      if ((N0.getOpcode() == ISD::XOR ||\n           (N0.getOpcode() == ISD::AND &&\n            N0.getOperand(0).getOpcode() == ISD::XOR &&\n            N0.getOperand(1) == N0.getOperand(0).getOperand(1))) &&\n          isOneConstant(N0.getOperand(1))) {\n        // If this is (X^1) == 0/1, swap the RHS and eliminate the xor.  We\n        // can only do this if the top bits are known zero.\n        unsigned BitWidth = N0.getValueSizeInBits();\n        if (DAG.MaskedValueIsZero(N0,\n                                  APInt::getHighBitsSet(BitWidth,\n                                                        BitWidth-1))) {\n          // Okay, get the un-inverted input value.\n          SDValue Val;\n          if (N0.getOpcode() == ISD::XOR) {\n            Val = N0.getOperand(0);\n          } else {\n            assert(N0.getOpcode() == ISD::AND &&\n                    N0.getOperand(0).getOpcode() == ISD::XOR);\n            // ((X^1)&1)^1 -> X & 1\n            Val = DAG.getNode(ISD::AND, dl, N0.getValueType(),\n                              N0.getOperand(0).getOperand(0),\n                              N0.getOperand(1));\n          }\n\n          return DAG.getSetCC(dl, VT, Val, N1,\n                              Cond == ISD::SETEQ ? ISD::SETNE : ISD::SETEQ);\n        }\n      } else if (N1C->isOne()) {\n        SDValue Op0 = N0;\n        if (Op0.getOpcode() == ISD::TRUNCATE)\n          Op0 = Op0.getOperand(0);\n\n        if ((Op0.getOpcode() == ISD::XOR) &&\n            Op0.getOperand(0).getOpcode() == ISD::SETCC &&\n            Op0.getOperand(1).getOpcode() == ISD::SETCC) {\n          SDValue XorLHS = Op0.getOperand(0);\n          SDValue XorRHS = Op0.getOperand(1);\n          // Ensure that the input setccs return an i1 type or 0/1 value.\n          if (Op0.getValueType() == MVT::i1 ||\n              (getBooleanContents(XorLHS.getOperand(0).getValueType()) ==\n                      ZeroOrOneBooleanContent &&\n               getBooleanContents(XorRHS.getOperand(0).getValueType()) ==\n                        ZeroOrOneBooleanContent)) {\n            // (xor (setcc), (setcc)) == / != 1 -> (setcc) != / == (setcc)\n            Cond = (Cond == ISD::SETEQ) ? ISD::SETNE : ISD::SETEQ;\n            return DAG.getSetCC(dl, VT, XorLHS, XorRHS, Cond);\n          }\n        }\n        if (Op0.getOpcode() == ISD::AND && isOneConstant(Op0.getOperand(1))) {\n          // If this is (X&1) == / != 1, normalize it to (X&1) != / == 0.\n          if (Op0.getValueType().bitsGT(VT))\n            Op0 = DAG.getNode(ISD::AND, dl, VT,\n                          DAG.getNode(ISD::TRUNCATE, dl, VT, Op0.getOperand(0)),\n                          DAG.getConstant(1, dl, VT));\n          else if (Op0.getValueType().bitsLT(VT))\n            Op0 = DAG.getNode(ISD::AND, dl, VT,\n                        DAG.getNode(ISD::ANY_EXTEND, dl, VT, Op0.getOperand(0)),\n                        DAG.getConstant(1, dl, VT));\n\n          return DAG.getSetCC(dl, VT, Op0,\n                              DAG.getConstant(0, dl, Op0.getValueType()),\n                              Cond == ISD::SETEQ ? ISD::SETNE : ISD::SETEQ);\n        }\n        if (Op0.getOpcode() == ISD::AssertZext &&\n            cast<VTSDNode>(Op0.getOperand(1))->getVT() == MVT::i1)\n          return DAG.getSetCC(dl, VT, Op0,\n                              DAG.getConstant(0, dl, Op0.getValueType()),\n                              Cond == ISD::SETEQ ? ISD::SETNE : ISD::SETEQ);\n      }\n    }\n\n    // Given:\n    //   icmp eq/ne (urem %x, %y), 0\n    // Iff %x has 0 or 1 bits set, and %y has at least 2 bits set, omit 'urem':\n    //   icmp eq/ne %x, 0\n    if (N0.getOpcode() == ISD::UREM && N1C->isNullValue() &&\n        (Cond == ISD::SETEQ || Cond == ISD::SETNE)) {\n      KnownBits XKnown = DAG.computeKnownBits(N0.getOperand(0));\n      KnownBits YKnown = DAG.computeKnownBits(N0.getOperand(1));\n      if (XKnown.countMaxPopulation() == 1 && YKnown.countMinPopulation() >= 2)\n        return DAG.getSetCC(dl, VT, N0.getOperand(0), N1, Cond);\n    }\n\n    if (SDValue V =\n            optimizeSetCCOfSignedTruncationCheck(VT, N0, N1, Cond, DCI, dl))\n      return V;\n  }\n\n  // These simplifications apply to splat vectors as well.\n  // TODO: Handle more splat vector cases.\n  if (auto *N1C = isConstOrConstSplat(N1)) {\n    const APInt &C1 = N1C->getAPIntValue();\n\n    APInt MinVal, MaxVal;\n    unsigned OperandBitSize = N1C->getValueType(0).getScalarSizeInBits();\n    if (ISD::isSignedIntSetCC(Cond)) {\n      MinVal = APInt::getSignedMinValue(OperandBitSize);\n      MaxVal = APInt::getSignedMaxValue(OperandBitSize);\n    } else {\n      MinVal = APInt::getMinValue(OperandBitSize);\n      MaxVal = APInt::getMaxValue(OperandBitSize);\n    }\n\n    // Canonicalize GE/LE comparisons to use GT/LT comparisons.\n    if (Cond == ISD::SETGE || Cond == ISD::SETUGE) {\n      // X >= MIN --> true\n      if (C1 == MinVal)\n        return DAG.getBoolConstant(true, dl, VT, OpVT);\n\n      if (!VT.isVector()) { // TODO: Support this for vectors.\n        // X >= C0 --> X > (C0 - 1)\n        APInt C = C1 - 1;\n        ISD::CondCode NewCC = (Cond == ISD::SETGE) ? ISD::SETGT : ISD::SETUGT;\n        if ((DCI.isBeforeLegalizeOps() ||\n             isCondCodeLegal(NewCC, VT.getSimpleVT())) &&\n            (!N1C->isOpaque() || (C.getBitWidth() <= 64 &&\n                                  isLegalICmpImmediate(C.getSExtValue())))) {\n          return DAG.getSetCC(dl, VT, N0,\n                              DAG.getConstant(C, dl, N1.getValueType()),\n                              NewCC);\n        }\n      }\n    }\n\n    if (Cond == ISD::SETLE || Cond == ISD::SETULE) {\n      // X <= MAX --> true\n      if (C1 == MaxVal)\n        return DAG.getBoolConstant(true, dl, VT, OpVT);\n\n      // X <= C0 --> X < (C0 + 1)\n      if (!VT.isVector()) { // TODO: Support this for vectors.\n        APInt C = C1 + 1;\n        ISD::CondCode NewCC = (Cond == ISD::SETLE) ? ISD::SETLT : ISD::SETULT;\n        if ((DCI.isBeforeLegalizeOps() ||\n             isCondCodeLegal(NewCC, VT.getSimpleVT())) &&\n            (!N1C->isOpaque() || (C.getBitWidth() <= 64 &&\n                                  isLegalICmpImmediate(C.getSExtValue())))) {\n          return DAG.getSetCC(dl, VT, N0,\n                              DAG.getConstant(C, dl, N1.getValueType()),\n                              NewCC);\n        }\n      }\n    }\n\n    if (Cond == ISD::SETLT || Cond == ISD::SETULT) {\n      if (C1 == MinVal)\n        return DAG.getBoolConstant(false, dl, VT, OpVT); // X < MIN --> false\n\n      // TODO: Support this for vectors after legalize ops.\n      if (!VT.isVector() || DCI.isBeforeLegalizeOps()) {\n        // Canonicalize setlt X, Max --> setne X, Max\n        if (C1 == MaxVal)\n          return DAG.getSetCC(dl, VT, N0, N1, ISD::SETNE);\n\n        // If we have setult X, 1, turn it into seteq X, 0\n        if (C1 == MinVal+1)\n          return DAG.getSetCC(dl, VT, N0,\n                              DAG.getConstant(MinVal, dl, N0.getValueType()),\n                              ISD::SETEQ);\n      }\n    }\n\n    if (Cond == ISD::SETGT || Cond == ISD::SETUGT) {\n      if (C1 == MaxVal)\n        return DAG.getBoolConstant(false, dl, VT, OpVT); // X > MAX --> false\n\n      // TODO: Support this for vectors after legalize ops.\n      if (!VT.isVector() || DCI.isBeforeLegalizeOps()) {\n        // Canonicalize setgt X, Min --> setne X, Min\n        if (C1 == MinVal)\n          return DAG.getSetCC(dl, VT, N0, N1, ISD::SETNE);\n\n        // If we have setugt X, Max-1, turn it into seteq X, Max\n        if (C1 == MaxVal-1)\n          return DAG.getSetCC(dl, VT, N0,\n                              DAG.getConstant(MaxVal, dl, N0.getValueType()),\n                              ISD::SETEQ);\n      }\n    }\n\n    if (Cond == ISD::SETEQ || Cond == ISD::SETNE) {\n      // (X & (C l>>/<< Y)) ==/!= 0  -->  ((X <</l>> Y) & C) ==/!= 0\n      if (C1.isNullValue())\n        if (SDValue CC = optimizeSetCCByHoistingAndByConstFromLogicalShift(\n                VT, N0, N1, Cond, DCI, dl))\n          return CC;\n\n      // For all/any comparisons, replace or(x,shl(y,bw/2)) with and/or(x,y).\n      // For example, when high 32-bits of i64 X are known clear:\n      // all bits clear: (X | (Y<<32)) ==  0 --> (X | Y) ==  0\n      // all bits set:   (X | (Y<<32)) == -1 --> (X & Y) == -1\n      bool CmpZero = N1C->getAPIntValue().isNullValue();\n      bool CmpNegOne = N1C->getAPIntValue().isAllOnesValue();\n      if ((CmpZero || CmpNegOne) && N0.hasOneUse()) {\n        // Match or(lo,shl(hi,bw/2)) pattern.\n        auto IsConcat = [&](SDValue V, SDValue &Lo, SDValue &Hi) {\n          unsigned EltBits = V.getScalarValueSizeInBits();\n          if (V.getOpcode() != ISD::OR || (EltBits % 2) != 0)\n            return false;\n          SDValue LHS = V.getOperand(0);\n          SDValue RHS = V.getOperand(1);\n          APInt HiBits = APInt::getHighBitsSet(EltBits, EltBits / 2);\n          // Unshifted element must have zero upperbits.\n          if (RHS.getOpcode() == ISD::SHL &&\n              isa<ConstantSDNode>(RHS.getOperand(1)) &&\n              RHS.getConstantOperandAPInt(1) == (EltBits / 2) &&\n              DAG.MaskedValueIsZero(LHS, HiBits)) {\n            Lo = LHS;\n            Hi = RHS.getOperand(0);\n            return true;\n          }\n          if (LHS.getOpcode() == ISD::SHL &&\n              isa<ConstantSDNode>(LHS.getOperand(1)) &&\n              LHS.getConstantOperandAPInt(1) == (EltBits / 2) &&\n              DAG.MaskedValueIsZero(RHS, HiBits)) {\n            Lo = RHS;\n            Hi = LHS.getOperand(0);\n            return true;\n          }\n          return false;\n        };\n\n        auto MergeConcat = [&](SDValue Lo, SDValue Hi) {\n          unsigned EltBits = N0.getScalarValueSizeInBits();\n          unsigned HalfBits = EltBits / 2;\n          APInt HiBits = APInt::getHighBitsSet(EltBits, HalfBits);\n          SDValue LoBits = DAG.getConstant(~HiBits, dl, OpVT);\n          SDValue HiMask = DAG.getNode(ISD::AND, dl, OpVT, Hi, LoBits);\n          SDValue NewN0 =\n              DAG.getNode(CmpZero ? ISD::OR : ISD::AND, dl, OpVT, Lo, HiMask);\n          SDValue NewN1 = CmpZero ? DAG.getConstant(0, dl, OpVT) : LoBits;\n          return DAG.getSetCC(dl, VT, NewN0, NewN1, Cond);\n        };\n\n        SDValue Lo, Hi;\n        if (IsConcat(N0, Lo, Hi))\n          return MergeConcat(Lo, Hi);\n\n        if (N0.getOpcode() == ISD::AND || N0.getOpcode() == ISD::OR) {\n          SDValue Lo0, Lo1, Hi0, Hi1;\n          if (IsConcat(N0.getOperand(0), Lo0, Hi0) &&\n              IsConcat(N0.getOperand(1), Lo1, Hi1)) {\n            return MergeConcat(DAG.getNode(N0.getOpcode(), dl, OpVT, Lo0, Lo1),\n                               DAG.getNode(N0.getOpcode(), dl, OpVT, Hi0, Hi1));\n          }\n        }\n      }\n    }\n\n    // If we have \"setcc X, C0\", check to see if we can shrink the immediate\n    // by changing cc.\n    // TODO: Support this for vectors after legalize ops.\n    if (!VT.isVector() || DCI.isBeforeLegalizeOps()) {\n      // SETUGT X, SINTMAX  -> SETLT X, 0\n      // SETUGE X, SINTMIN -> SETLT X, 0\n      if ((Cond == ISD::SETUGT && C1.isMaxSignedValue()) ||\n          (Cond == ISD::SETUGE && C1.isMinSignedValue()))\n        return DAG.getSetCC(dl, VT, N0,\n                            DAG.getConstant(0, dl, N1.getValueType()),\n                            ISD::SETLT);\n\n      // SETULT X, SINTMIN  -> SETGT X, -1\n      // SETULE X, SINTMAX  -> SETGT X, -1\n      if ((Cond == ISD::SETULT && C1.isMinSignedValue()) ||\n          (Cond == ISD::SETULE && C1.isMaxSignedValue()))\n        return DAG.getSetCC(dl, VT, N0,\n                            DAG.getAllOnesConstant(dl, N1.getValueType()),\n                            ISD::SETGT);\n    }\n  }\n\n  // Back to non-vector simplifications.\n  // TODO: Can we do these for vector splats?\n  if (auto *N1C = dyn_cast<ConstantSDNode>(N1.getNode())) {\n    const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n    const APInt &C1 = N1C->getAPIntValue();\n    EVT ShValTy = N0.getValueType();\n\n    // Fold bit comparisons when we can. This will result in an\n    // incorrect value when boolean false is negative one, unless\n    // the bitsize is 1 in which case the false value is the same\n    // in practice regardless of the representation.\n    if ((VT.getSizeInBits() == 1 ||\n         getBooleanContents(N0.getValueType()) == ZeroOrOneBooleanContent) &&\n        (Cond == ISD::SETEQ || Cond == ISD::SETNE) &&\n        (VT == ShValTy || (isTypeLegal(VT) && VT.bitsLE(ShValTy))) &&\n        N0.getOpcode() == ISD::AND) {\n      if (auto *AndRHS = dyn_cast<ConstantSDNode>(N0.getOperand(1))) {\n        EVT ShiftTy =\n            getShiftAmountTy(ShValTy, Layout, !DCI.isBeforeLegalize());\n        if (Cond == ISD::SETNE && C1 == 0) {// (X & 8) != 0  -->  (X & 8) >> 3\n          // Perform the xform if the AND RHS is a single bit.\n          unsigned ShCt = AndRHS->getAPIntValue().logBase2();\n          if (AndRHS->getAPIntValue().isPowerOf2() &&\n              !TLI.shouldAvoidTransformToShift(ShValTy, ShCt)) {\n            return DAG.getNode(ISD::TRUNCATE, dl, VT,\n                               DAG.getNode(ISD::SRL, dl, ShValTy, N0,\n                                           DAG.getConstant(ShCt, dl, ShiftTy)));\n          }\n        } else if (Cond == ISD::SETEQ && C1 == AndRHS->getAPIntValue()) {\n          // (X & 8) == 8  -->  (X & 8) >> 3\n          // Perform the xform if C1 is a single bit.\n          unsigned ShCt = C1.logBase2();\n          if (C1.isPowerOf2() &&\n              !TLI.shouldAvoidTransformToShift(ShValTy, ShCt)) {\n            return DAG.getNode(ISD::TRUNCATE, dl, VT,\n                               DAG.getNode(ISD::SRL, dl, ShValTy, N0,\n                                           DAG.getConstant(ShCt, dl, ShiftTy)));\n          }\n        }\n      }\n    }\n\n    if (C1.getMinSignedBits() <= 64 &&\n        !isLegalICmpImmediate(C1.getSExtValue())) {\n      EVT ShiftTy = getShiftAmountTy(ShValTy, Layout, !DCI.isBeforeLegalize());\n      // (X & -256) == 256 -> (X >> 8) == 1\n      if ((Cond == ISD::SETEQ || Cond == ISD::SETNE) &&\n          N0.getOpcode() == ISD::AND && N0.hasOneUse()) {\n        if (auto *AndRHS = dyn_cast<ConstantSDNode>(N0.getOperand(1))) {\n          const APInt &AndRHSC = AndRHS->getAPIntValue();\n          if ((-AndRHSC).isPowerOf2() && (AndRHSC & C1) == C1) {\n            unsigned ShiftBits = AndRHSC.countTrailingZeros();\n            if (!TLI.shouldAvoidTransformToShift(ShValTy, ShiftBits)) {\n              SDValue Shift =\n                DAG.getNode(ISD::SRL, dl, ShValTy, N0.getOperand(0),\n                            DAG.getConstant(ShiftBits, dl, ShiftTy));\n              SDValue CmpRHS = DAG.getConstant(C1.lshr(ShiftBits), dl, ShValTy);\n              return DAG.getSetCC(dl, VT, Shift, CmpRHS, Cond);\n            }\n          }\n        }\n      } else if (Cond == ISD::SETULT || Cond == ISD::SETUGE ||\n                 Cond == ISD::SETULE || Cond == ISD::SETUGT) {\n        bool AdjOne = (Cond == ISD::SETULE || Cond == ISD::SETUGT);\n        // X <  0x100000000 -> (X >> 32) <  1\n        // X >= 0x100000000 -> (X >> 32) >= 1\n        // X <= 0x0ffffffff -> (X >> 32) <  1\n        // X >  0x0ffffffff -> (X >> 32) >= 1\n        unsigned ShiftBits;\n        APInt NewC = C1;\n        ISD::CondCode NewCond = Cond;\n        if (AdjOne) {\n          ShiftBits = C1.countTrailingOnes();\n          NewC = NewC + 1;\n          NewCond = (Cond == ISD::SETULE) ? ISD::SETULT : ISD::SETUGE;\n        } else {\n          ShiftBits = C1.countTrailingZeros();\n        }\n        NewC.lshrInPlace(ShiftBits);\n        if (ShiftBits && NewC.getMinSignedBits() <= 64 &&\n            isLegalICmpImmediate(NewC.getSExtValue()) &&\n            !TLI.shouldAvoidTransformToShift(ShValTy, ShiftBits)) {\n          SDValue Shift = DAG.getNode(ISD::SRL, dl, ShValTy, N0,\n                                      DAG.getConstant(ShiftBits, dl, ShiftTy));\n          SDValue CmpRHS = DAG.getConstant(NewC, dl, ShValTy);\n          return DAG.getSetCC(dl, VT, Shift, CmpRHS, NewCond);\n        }\n      }\n    }\n  }\n\n  if (!isa<ConstantFPSDNode>(N0) && isa<ConstantFPSDNode>(N1)) {\n    auto *CFP = cast<ConstantFPSDNode>(N1);\n    assert(!CFP->getValueAPF().isNaN() && \"Unexpected NaN value\");\n\n    // Otherwise, we know the RHS is not a NaN.  Simplify the node to drop the\n    // constant if knowing that the operand is non-nan is enough.  We prefer to\n    // have SETO(x,x) instead of SETO(x, 0.0) because this avoids having to\n    // materialize 0.0.\n    if (Cond == ISD::SETO || Cond == ISD::SETUO)\n      return DAG.getSetCC(dl, VT, N0, N0, Cond);\n\n    // setcc (fneg x), C -> setcc swap(pred) x, -C\n    if (N0.getOpcode() == ISD::FNEG) {\n      ISD::CondCode SwapCond = ISD::getSetCCSwappedOperands(Cond);\n      if (DCI.isBeforeLegalizeOps() ||\n          isCondCodeLegal(SwapCond, N0.getSimpleValueType())) {\n        SDValue NegN1 = DAG.getNode(ISD::FNEG, dl, N0.getValueType(), N1);\n        return DAG.getSetCC(dl, VT, N0.getOperand(0), NegN1, SwapCond);\n      }\n    }\n\n    // If the condition is not legal, see if we can find an equivalent one\n    // which is legal.\n    if (!isCondCodeLegal(Cond, N0.getSimpleValueType())) {\n      // If the comparison was an awkward floating-point == or != and one of\n      // the comparison operands is infinity or negative infinity, convert the\n      // condition to a less-awkward <= or >=.\n      if (CFP->getValueAPF().isInfinity()) {\n        bool IsNegInf = CFP->getValueAPF().isNegative();\n        ISD::CondCode NewCond = ISD::SETCC_INVALID;\n        switch (Cond) {\n        case ISD::SETOEQ: NewCond = IsNegInf ? ISD::SETOLE : ISD::SETOGE; break;\n        case ISD::SETUEQ: NewCond = IsNegInf ? ISD::SETULE : ISD::SETUGE; break;\n        case ISD::SETUNE: NewCond = IsNegInf ? ISD::SETUGT : ISD::SETULT; break;\n        case ISD::SETONE: NewCond = IsNegInf ? ISD::SETOGT : ISD::SETOLT; break;\n        default: break;\n        }\n        if (NewCond != ISD::SETCC_INVALID &&\n            isCondCodeLegal(NewCond, N0.getSimpleValueType()))\n          return DAG.getSetCC(dl, VT, N0, N1, NewCond);\n      }\n    }\n  }\n\n  if (N0 == N1) {\n    // The sext(setcc()) => setcc() optimization relies on the appropriate\n    // constant being emitted.\n    assert(!N0.getValueType().isInteger() &&\n           \"Integer types should be handled by FoldSetCC\");\n\n    bool EqTrue = ISD::isTrueWhenEqual(Cond);\n    unsigned UOF = ISD::getUnorderedFlavor(Cond);\n    if (UOF == 2) // FP operators that are undefined on NaNs.\n      return DAG.getBoolConstant(EqTrue, dl, VT, OpVT);\n    if (UOF == unsigned(EqTrue))\n      return DAG.getBoolConstant(EqTrue, dl, VT, OpVT);\n    // Otherwise, we can't fold it.  However, we can simplify it to SETUO/SETO\n    // if it is not already.\n    ISD::CondCode NewCond = UOF == 0 ? ISD::SETO : ISD::SETUO;\n    if (NewCond != Cond &&\n        (DCI.isBeforeLegalizeOps() ||\n                            isCondCodeLegal(NewCond, N0.getSimpleValueType())))\n      return DAG.getSetCC(dl, VT, N0, N1, NewCond);\n  }\n\n  if ((Cond == ISD::SETEQ || Cond == ISD::SETNE) &&\n      N0.getValueType().isInteger()) {\n    if (N0.getOpcode() == ISD::ADD || N0.getOpcode() == ISD::SUB ||\n        N0.getOpcode() == ISD::XOR) {\n      // Simplify (X+Y) == (X+Z) -->  Y == Z\n      if (N0.getOpcode() == N1.getOpcode()) {\n        if (N0.getOperand(0) == N1.getOperand(0))\n          return DAG.getSetCC(dl, VT, N0.getOperand(1), N1.getOperand(1), Cond);\n        if (N0.getOperand(1) == N1.getOperand(1))\n          return DAG.getSetCC(dl, VT, N0.getOperand(0), N1.getOperand(0), Cond);\n        if (isCommutativeBinOp(N0.getOpcode())) {\n          // If X op Y == Y op X, try other combinations.\n          if (N0.getOperand(0) == N1.getOperand(1))\n            return DAG.getSetCC(dl, VT, N0.getOperand(1), N1.getOperand(0),\n                                Cond);\n          if (N0.getOperand(1) == N1.getOperand(0))\n            return DAG.getSetCC(dl, VT, N0.getOperand(0), N1.getOperand(1),\n                                Cond);\n        }\n      }\n\n      // If RHS is a legal immediate value for a compare instruction, we need\n      // to be careful about increasing register pressure needlessly.\n      bool LegalRHSImm = false;\n\n      if (auto *RHSC = dyn_cast<ConstantSDNode>(N1)) {\n        if (auto *LHSR = dyn_cast<ConstantSDNode>(N0.getOperand(1))) {\n          // Turn (X+C1) == C2 --> X == C2-C1\n          if (N0.getOpcode() == ISD::ADD && N0.getNode()->hasOneUse()) {\n            return DAG.getSetCC(dl, VT, N0.getOperand(0),\n                                DAG.getConstant(RHSC->getAPIntValue()-\n                                                LHSR->getAPIntValue(),\n                                dl, N0.getValueType()), Cond);\n          }\n\n          // Turn (X^C1) == C2 into X == C1^C2 iff X&~C1 = 0.\n          if (N0.getOpcode() == ISD::XOR)\n            // If we know that all of the inverted bits are zero, don't bother\n            // performing the inversion.\n            if (DAG.MaskedValueIsZero(N0.getOperand(0), ~LHSR->getAPIntValue()))\n              return\n                DAG.getSetCC(dl, VT, N0.getOperand(0),\n                             DAG.getConstant(LHSR->getAPIntValue() ^\n                                               RHSC->getAPIntValue(),\n                                             dl, N0.getValueType()),\n                             Cond);\n        }\n\n        // Turn (C1-X) == C2 --> X == C1-C2\n        if (auto *SUBC = dyn_cast<ConstantSDNode>(N0.getOperand(0))) {\n          if (N0.getOpcode() == ISD::SUB && N0.getNode()->hasOneUse()) {\n            return\n              DAG.getSetCC(dl, VT, N0.getOperand(1),\n                           DAG.getConstant(SUBC->getAPIntValue() -\n                                             RHSC->getAPIntValue(),\n                                           dl, N0.getValueType()),\n                           Cond);\n          }\n        }\n\n        // Could RHSC fold directly into a compare?\n        if (RHSC->getValueType(0).getSizeInBits() <= 64)\n          LegalRHSImm = isLegalICmpImmediate(RHSC->getSExtValue());\n      }\n\n      // (X+Y) == X --> Y == 0 and similar folds.\n      // Don't do this if X is an immediate that can fold into a cmp\n      // instruction and X+Y has other uses. It could be an induction variable\n      // chain, and the transform would increase register pressure.\n      if (!LegalRHSImm || N0.hasOneUse())\n        if (SDValue V = foldSetCCWithBinOp(VT, N0, N1, Cond, dl, DCI))\n          return V;\n    }\n\n    if (N1.getOpcode() == ISD::ADD || N1.getOpcode() == ISD::SUB ||\n        N1.getOpcode() == ISD::XOR)\n      if (SDValue V = foldSetCCWithBinOp(VT, N1, N0, Cond, dl, DCI))\n        return V;\n\n    if (SDValue V = foldSetCCWithAnd(VT, N0, N1, Cond, dl, DCI))\n      return V;\n  }\n\n  // Fold remainder of division by a constant.\n  if ((N0.getOpcode() == ISD::UREM || N0.getOpcode() == ISD::SREM) &&\n      N0.hasOneUse() && (Cond == ISD::SETEQ || Cond == ISD::SETNE)) {\n    AttributeList Attr = DAG.getMachineFunction().getFunction().getAttributes();\n\n    // When division is cheap or optimizing for minimum size,\n    // fall through to DIVREM creation by skipping this fold.\n    if (!isIntDivCheap(VT, Attr) && !Attr.hasFnAttribute(Attribute::MinSize)) {\n      if (N0.getOpcode() == ISD::UREM) {\n        if (SDValue Folded = buildUREMEqFold(VT, N0, N1, Cond, DCI, dl))\n          return Folded;\n      } else if (N0.getOpcode() == ISD::SREM) {\n        if (SDValue Folded = buildSREMEqFold(VT, N0, N1, Cond, DCI, dl))\n          return Folded;\n      }\n    }\n  }\n\n  // Fold away ALL boolean setcc's.\n  if (N0.getValueType().getScalarType() == MVT::i1 && foldBooleans) {\n    SDValue Temp;\n    switch (Cond) {\n    default: llvm_unreachable(\"Unknown integer setcc!\");\n    case ISD::SETEQ:  // X == Y  -> ~(X^Y)\n      Temp = DAG.getNode(ISD::XOR, dl, OpVT, N0, N1);\n      N0 = DAG.getNOT(dl, Temp, OpVT);\n      if (!DCI.isCalledByLegalizer())\n        DCI.AddToWorklist(Temp.getNode());\n      break;\n    case ISD::SETNE:  // X != Y   -->  (X^Y)\n      N0 = DAG.getNode(ISD::XOR, dl, OpVT, N0, N1);\n      break;\n    case ISD::SETGT:  // X >s Y   -->  X == 0 & Y == 1  -->  ~X & Y\n    case ISD::SETULT: // X <u Y   -->  X == 0 & Y == 1  -->  ~X & Y\n      Temp = DAG.getNOT(dl, N0, OpVT);\n      N0 = DAG.getNode(ISD::AND, dl, OpVT, N1, Temp);\n      if (!DCI.isCalledByLegalizer())\n        DCI.AddToWorklist(Temp.getNode());\n      break;\n    case ISD::SETLT:  // X <s Y   --> X == 1 & Y == 0  -->  ~Y & X\n    case ISD::SETUGT: // X >u Y   --> X == 1 & Y == 0  -->  ~Y & X\n      Temp = DAG.getNOT(dl, N1, OpVT);\n      N0 = DAG.getNode(ISD::AND, dl, OpVT, N0, Temp);\n      if (!DCI.isCalledByLegalizer())\n        DCI.AddToWorklist(Temp.getNode());\n      break;\n    case ISD::SETULE: // X <=u Y  --> X == 0 | Y == 1  -->  ~X | Y\n    case ISD::SETGE:  // X >=s Y  --> X == 0 | Y == 1  -->  ~X | Y\n      Temp = DAG.getNOT(dl, N0, OpVT);\n      N0 = DAG.getNode(ISD::OR, dl, OpVT, N1, Temp);\n      if (!DCI.isCalledByLegalizer())\n        DCI.AddToWorklist(Temp.getNode());\n      break;\n    case ISD::SETUGE: // X >=u Y  --> X == 1 | Y == 0  -->  ~Y | X\n    case ISD::SETLE:  // X <=s Y  --> X == 1 | Y == 0  -->  ~Y | X\n      Temp = DAG.getNOT(dl, N1, OpVT);\n      N0 = DAG.getNode(ISD::OR, dl, OpVT, N0, Temp);\n      break;\n    }\n    if (VT.getScalarType() != MVT::i1) {\n      if (!DCI.isCalledByLegalizer())\n        DCI.AddToWorklist(N0.getNode());\n      // FIXME: If running after legalize, we probably can't do this.\n      ISD::NodeType ExtendCode = getExtendForContent(getBooleanContents(OpVT));\n      N0 = DAG.getNode(ExtendCode, dl, VT, N0);\n    }\n    return N0;\n  }\n\n  // Could not fold it.\n  return SDValue();\n}\n\n/// Returns true (and the GlobalValue and the offset) if the node is a\n/// GlobalAddress + offset.\nbool TargetLowering::isGAPlusOffset(SDNode *WN, const GlobalValue *&GA,\n                                    int64_t &Offset) const {\n\n  SDNode *N = unwrapAddress(SDValue(WN, 0)).getNode();\n\n  if (auto *GASD = dyn_cast<GlobalAddressSDNode>(N)) {\n    GA = GASD->getGlobal();\n    Offset += GASD->getOffset();\n    return true;\n  }\n\n  if (N->getOpcode() == ISD::ADD) {\n    SDValue N1 = N->getOperand(0);\n    SDValue N2 = N->getOperand(1);\n    if (isGAPlusOffset(N1.getNode(), GA, Offset)) {\n      if (auto *V = dyn_cast<ConstantSDNode>(N2)) {\n        Offset += V->getSExtValue();\n        return true;\n      }\n    } else if (isGAPlusOffset(N2.getNode(), GA, Offset)) {\n      if (auto *V = dyn_cast<ConstantSDNode>(N1)) {\n        Offset += V->getSExtValue();\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nSDValue TargetLowering::PerformDAGCombine(SDNode *N,\n                                          DAGCombinerInfo &DCI) const {\n  // Default implementation: no optimization.\n  return SDValue();\n}\n\n//===----------------------------------------------------------------------===//\n//  Inline Assembler Implementation Methods\n//===----------------------------------------------------------------------===//\n\nTargetLowering::ConstraintType\nTargetLowering::getConstraintType(StringRef Constraint) const {\n  unsigned S = Constraint.size();\n\n  if (S == 1) {\n    switch (Constraint[0]) {\n    default: break;\n    case 'r':\n      return C_RegisterClass;\n    case 'm': // memory\n    case 'o': // offsetable\n    case 'V': // not offsetable\n      return C_Memory;\n    case 'n': // Simple Integer\n    case 'E': // Floating Point Constant\n    case 'F': // Floating Point Constant\n      return C_Immediate;\n    case 'i': // Simple Integer or Relocatable Constant\n    case 's': // Relocatable Constant\n    case 'p': // Address.\n    case 'X': // Allow ANY value.\n    case 'I': // Target registers.\n    case 'J':\n    case 'K':\n    case 'L':\n    case 'M':\n    case 'N':\n    case 'O':\n    case 'P':\n    case '<':\n    case '>':\n      return C_Other;\n    }\n  }\n\n  if (S > 1 && Constraint[0] == '{' && Constraint[S - 1] == '}') {\n    if (S == 8 && Constraint.substr(1, 6) == \"memory\") // \"{memory}\"\n      return C_Memory;\n    return C_Register;\n  }\n  return C_Unknown;\n}\n\n/// Try to replace an X constraint, which matches anything, with another that\n/// has more specific requirements based on the type of the corresponding\n/// operand.\nconst char *TargetLowering::LowerXConstraint(EVT ConstraintVT) const {\n  if (ConstraintVT.isInteger())\n    return \"r\";\n  if (ConstraintVT.isFloatingPoint())\n    return \"f\"; // works for many targets\n  return nullptr;\n}\n\nSDValue TargetLowering::LowerAsmOutputForConstraint(\n    SDValue &Chain, SDValue &Flag, const SDLoc &DL,\n    const AsmOperandInfo &OpInfo, SelectionDAG &DAG) const {\n  return SDValue();\n}\n\n/// Lower the specified operand into the Ops vector.\n/// If it is invalid, don't add anything to Ops.\nvoid TargetLowering::LowerAsmOperandForConstraint(SDValue Op,\n                                                  std::string &Constraint,\n                                                  std::vector<SDValue> &Ops,\n                                                  SelectionDAG &DAG) const {\n\n  if (Constraint.length() > 1) return;\n\n  char ConstraintLetter = Constraint[0];\n  switch (ConstraintLetter) {\n  default: break;\n  case 'X':     // Allows any operand; labels (basic block) use this.\n    if (Op.getOpcode() == ISD::BasicBlock ||\n        Op.getOpcode() == ISD::TargetBlockAddress) {\n      Ops.push_back(Op);\n      return;\n    }\n    LLVM_FALLTHROUGH;\n  case 'i':    // Simple Integer or Relocatable Constant\n  case 'n':    // Simple Integer\n  case 's': {  // Relocatable Constant\n\n    GlobalAddressSDNode *GA;\n    ConstantSDNode *C;\n    BlockAddressSDNode *BA;\n    uint64_t Offset = 0;\n\n    // Match (GA) or (C) or (GA+C) or (GA-C) or ((GA+C)+C) or (((GA+C)+C)+C),\n    // etc., since getelementpointer is variadic. We can't use\n    // SelectionDAG::FoldSymbolOffset because it expects the GA to be accessible\n    // while in this case the GA may be furthest from the root node which is\n    // likely an ISD::ADD.\n    while (1) {\n      if ((GA = dyn_cast<GlobalAddressSDNode>(Op)) && ConstraintLetter != 'n') {\n        Ops.push_back(DAG.getTargetGlobalAddress(GA->getGlobal(), SDLoc(Op),\n                                                 GA->getValueType(0),\n                                                 Offset + GA->getOffset()));\n        return;\n      } else if ((C = dyn_cast<ConstantSDNode>(Op)) &&\n                 ConstraintLetter != 's') {\n        // gcc prints these as sign extended.  Sign extend value to 64 bits\n        // now; without this it would get ZExt'd later in\n        // ScheduleDAGSDNodes::EmitNode, which is very generic.\n        bool IsBool = C->getConstantIntValue()->getBitWidth() == 1;\n        BooleanContent BCont = getBooleanContents(MVT::i64);\n        ISD::NodeType ExtOpc = IsBool ? getExtendForContent(BCont)\n                                      : ISD::SIGN_EXTEND;\n        int64_t ExtVal = ExtOpc == ISD::ZERO_EXTEND ? C->getZExtValue()\n                                                    : C->getSExtValue();\n        Ops.push_back(DAG.getTargetConstant(Offset + ExtVal,\n                                            SDLoc(C), MVT::i64));\n        return;\n      } else if ((BA = dyn_cast<BlockAddressSDNode>(Op)) &&\n                 ConstraintLetter != 'n') {\n        Ops.push_back(DAG.getTargetBlockAddress(\n            BA->getBlockAddress(), BA->getValueType(0),\n            Offset + BA->getOffset(), BA->getTargetFlags()));\n        return;\n      } else {\n        const unsigned OpCode = Op.getOpcode();\n        if (OpCode == ISD::ADD || OpCode == ISD::SUB) {\n          if ((C = dyn_cast<ConstantSDNode>(Op.getOperand(0))))\n            Op = Op.getOperand(1);\n          // Subtraction is not commutative.\n          else if (OpCode == ISD::ADD &&\n                   (C = dyn_cast<ConstantSDNode>(Op.getOperand(1))))\n            Op = Op.getOperand(0);\n          else\n            return;\n          Offset += (OpCode == ISD::ADD ? 1 : -1) * C->getSExtValue();\n          continue;\n        }\n      }\n      return;\n    }\n    break;\n  }\n  }\n}\n\nstd::pair<unsigned, const TargetRegisterClass *>\nTargetLowering::getRegForInlineAsmConstraint(const TargetRegisterInfo *RI,\n                                             StringRef Constraint,\n                                             MVT VT) const {\n  if (Constraint.empty() || Constraint[0] != '{')\n    return std::make_pair(0u, static_cast<TargetRegisterClass *>(nullptr));\n  assert(*(Constraint.end() - 1) == '}' && \"Not a brace enclosed constraint?\");\n\n  // Remove the braces from around the name.\n  StringRef RegName(Constraint.data() + 1, Constraint.size() - 2);\n\n  std::pair<unsigned, const TargetRegisterClass *> R =\n      std::make_pair(0u, static_cast<const TargetRegisterClass *>(nullptr));\n\n  // Figure out which register class contains this reg.\n  for (const TargetRegisterClass *RC : RI->regclasses()) {\n    // If none of the value types for this register class are valid, we\n    // can't use it.  For example, 64-bit reg classes on 32-bit targets.\n    if (!isLegalRC(*RI, *RC))\n      continue;\n\n    for (TargetRegisterClass::iterator I = RC->begin(), E = RC->end();\n         I != E; ++I) {\n      if (RegName.equals_lower(RI->getRegAsmName(*I))) {\n        std::pair<unsigned, const TargetRegisterClass *> S =\n            std::make_pair(*I, RC);\n\n        // If this register class has the requested value type, return it,\n        // otherwise keep searching and return the first class found\n        // if no other is found which explicitly has the requested type.\n        if (RI->isTypeLegalForClass(*RC, VT))\n          return S;\n        if (!R.second)\n          R = S;\n      }\n    }\n  }\n\n  return R;\n}\n\n//===----------------------------------------------------------------------===//\n// Constraint Selection.\n\n/// Return true of this is an input operand that is a matching constraint like\n/// \"4\".\nbool TargetLowering::AsmOperandInfo::isMatchingInputConstraint() const {\n  assert(!ConstraintCode.empty() && \"No known constraint!\");\n  return isdigit(static_cast<unsigned char>(ConstraintCode[0]));\n}\n\n/// If this is an input matching constraint, this method returns the output\n/// operand it matches.\nunsigned TargetLowering::AsmOperandInfo::getMatchedOperand() const {\n  assert(!ConstraintCode.empty() && \"No known constraint!\");\n  return atoi(ConstraintCode.c_str());\n}\n\n/// Split up the constraint string from the inline assembly value into the\n/// specific constraints and their prefixes, and also tie in the associated\n/// operand values.\n/// If this returns an empty vector, and if the constraint string itself\n/// isn't empty, there was an error parsing.\nTargetLowering::AsmOperandInfoVector\nTargetLowering::ParseConstraints(const DataLayout &DL,\n                                 const TargetRegisterInfo *TRI,\n                                 const CallBase &Call) const {\n  /// Information about all of the constraints.\n  AsmOperandInfoVector ConstraintOperands;\n  const InlineAsm *IA = cast<InlineAsm>(Call.getCalledOperand());\n  unsigned maCount = 0; // Largest number of multiple alternative constraints.\n\n  // Do a prepass over the constraints, canonicalizing them, and building up the\n  // ConstraintOperands list.\n  unsigned ArgNo = 0; // ArgNo - The argument of the CallInst.\n  unsigned ResNo = 0; // ResNo - The result number of the next output.\n\n  for (InlineAsm::ConstraintInfo &CI : IA->ParseConstraints()) {\n    ConstraintOperands.emplace_back(std::move(CI));\n    AsmOperandInfo &OpInfo = ConstraintOperands.back();\n\n    // Update multiple alternative constraint count.\n    if (OpInfo.multipleAlternatives.size() > maCount)\n      maCount = OpInfo.multipleAlternatives.size();\n\n    OpInfo.ConstraintVT = MVT::Other;\n\n    // Compute the value type for each operand.\n    switch (OpInfo.Type) {\n    case InlineAsm::isOutput:\n      // Indirect outputs just consume an argument.\n      if (OpInfo.isIndirect) {\n        OpInfo.CallOperandVal = Call.getArgOperand(ArgNo++);\n        break;\n      }\n\n      // The return value of the call is this value.  As such, there is no\n      // corresponding argument.\n      assert(!Call.getType()->isVoidTy() && \"Bad inline asm!\");\n      if (StructType *STy = dyn_cast<StructType>(Call.getType())) {\n        OpInfo.ConstraintVT =\n            getSimpleValueType(DL, STy->getElementType(ResNo));\n      } else {\n        assert(ResNo == 0 && \"Asm only has one result!\");\n        OpInfo.ConstraintVT = getSimpleValueType(DL, Call.getType());\n      }\n      ++ResNo;\n      break;\n    case InlineAsm::isInput:\n      OpInfo.CallOperandVal = Call.getArgOperand(ArgNo++);\n      break;\n    case InlineAsm::isClobber:\n      // Nothing to do.\n      break;\n    }\n\n    if (OpInfo.CallOperandVal) {\n      llvm::Type *OpTy = OpInfo.CallOperandVal->getType();\n      if (OpInfo.isIndirect) {\n        llvm::PointerType *PtrTy = dyn_cast<PointerType>(OpTy);\n        if (!PtrTy)\n          report_fatal_error(\"Indirect operand for inline asm not a pointer!\");\n        OpTy = PtrTy->getElementType();\n      }\n\n      // Look for vector wrapped in a struct. e.g. { <16 x i8> }.\n      if (StructType *STy = dyn_cast<StructType>(OpTy))\n        if (STy->getNumElements() == 1)\n          OpTy = STy->getElementType(0);\n\n      // If OpTy is not a single value, it may be a struct/union that we\n      // can tile with integers.\n      if (!OpTy->isSingleValueType() && OpTy->isSized()) {\n        unsigned BitSize = DL.getTypeSizeInBits(OpTy);\n        switch (BitSize) {\n        default: break;\n        case 1:\n        case 8:\n        case 16:\n        case 32:\n        case 64:\n        case 128:\n          OpInfo.ConstraintVT =\n              MVT::getVT(IntegerType::get(OpTy->getContext(), BitSize), true);\n          break;\n        }\n      } else if (PointerType *PT = dyn_cast<PointerType>(OpTy)) {\n        unsigned PtrSize = DL.getPointerSizeInBits(PT->getAddressSpace());\n        OpInfo.ConstraintVT = MVT::getIntegerVT(PtrSize);\n      } else {\n        OpInfo.ConstraintVT = MVT::getVT(OpTy, true);\n      }\n    }\n  }\n\n  // If we have multiple alternative constraints, select the best alternative.\n  if (!ConstraintOperands.empty()) {\n    if (maCount) {\n      unsigned bestMAIndex = 0;\n      int bestWeight = -1;\n      // weight:  -1 = invalid match, and 0 = so-so match to 5 = good match.\n      int weight = -1;\n      unsigned maIndex;\n      // Compute the sums of the weights for each alternative, keeping track\n      // of the best (highest weight) one so far.\n      for (maIndex = 0; maIndex < maCount; ++maIndex) {\n        int weightSum = 0;\n        for (unsigned cIndex = 0, eIndex = ConstraintOperands.size();\n             cIndex != eIndex; ++cIndex) {\n          AsmOperandInfo &OpInfo = ConstraintOperands[cIndex];\n          if (OpInfo.Type == InlineAsm::isClobber)\n            continue;\n\n          // If this is an output operand with a matching input operand,\n          // look up the matching input. If their types mismatch, e.g. one\n          // is an integer, the other is floating point, or their sizes are\n          // different, flag it as an maCantMatch.\n          if (OpInfo.hasMatchingInput()) {\n            AsmOperandInfo &Input = ConstraintOperands[OpInfo.MatchingInput];\n            if (OpInfo.ConstraintVT != Input.ConstraintVT) {\n              if ((OpInfo.ConstraintVT.isInteger() !=\n                   Input.ConstraintVT.isInteger()) ||\n                  (OpInfo.ConstraintVT.getSizeInBits() !=\n                   Input.ConstraintVT.getSizeInBits())) {\n                weightSum = -1; // Can't match.\n                break;\n              }\n            }\n          }\n          weight = getMultipleConstraintMatchWeight(OpInfo, maIndex);\n          if (weight == -1) {\n            weightSum = -1;\n            break;\n          }\n          weightSum += weight;\n        }\n        // Update best.\n        if (weightSum > bestWeight) {\n          bestWeight = weightSum;\n          bestMAIndex = maIndex;\n        }\n      }\n\n      // Now select chosen alternative in each constraint.\n      for (unsigned cIndex = 0, eIndex = ConstraintOperands.size();\n           cIndex != eIndex; ++cIndex) {\n        AsmOperandInfo &cInfo = ConstraintOperands[cIndex];\n        if (cInfo.Type == InlineAsm::isClobber)\n          continue;\n        cInfo.selectAlternative(bestMAIndex);\n      }\n    }\n  }\n\n  // Check and hook up tied operands, choose constraint code to use.\n  for (unsigned cIndex = 0, eIndex = ConstraintOperands.size();\n       cIndex != eIndex; ++cIndex) {\n    AsmOperandInfo &OpInfo = ConstraintOperands[cIndex];\n\n    // If this is an output operand with a matching input operand, look up the\n    // matching input. If their types mismatch, e.g. one is an integer, the\n    // other is floating point, or their sizes are different, flag it as an\n    // error.\n    if (OpInfo.hasMatchingInput()) {\n      AsmOperandInfo &Input = ConstraintOperands[OpInfo.MatchingInput];\n\n      if (OpInfo.ConstraintVT != Input.ConstraintVT) {\n        std::pair<unsigned, const TargetRegisterClass *> MatchRC =\n            getRegForInlineAsmConstraint(TRI, OpInfo.ConstraintCode,\n                                         OpInfo.ConstraintVT);\n        std::pair<unsigned, const TargetRegisterClass *> InputRC =\n            getRegForInlineAsmConstraint(TRI, Input.ConstraintCode,\n                                         Input.ConstraintVT);\n        if ((OpInfo.ConstraintVT.isInteger() !=\n             Input.ConstraintVT.isInteger()) ||\n            (MatchRC.second != InputRC.second)) {\n          report_fatal_error(\"Unsupported asm: input constraint\"\n                             \" with a matching output constraint of\"\n                             \" incompatible type!\");\n        }\n      }\n    }\n  }\n\n  return ConstraintOperands;\n}\n\n/// Return an integer indicating how general CT is.\nstatic unsigned getConstraintGenerality(TargetLowering::ConstraintType CT) {\n  switch (CT) {\n  case TargetLowering::C_Immediate:\n  case TargetLowering::C_Other:\n  case TargetLowering::C_Unknown:\n    return 0;\n  case TargetLowering::C_Register:\n    return 1;\n  case TargetLowering::C_RegisterClass:\n    return 2;\n  case TargetLowering::C_Memory:\n    return 3;\n  }\n  llvm_unreachable(\"Invalid constraint type\");\n}\n\n/// Examine constraint type and operand type and determine a weight value.\n/// This object must already have been set up with the operand type\n/// and the current alternative constraint selected.\nTargetLowering::ConstraintWeight\n  TargetLowering::getMultipleConstraintMatchWeight(\n    AsmOperandInfo &info, int maIndex) const {\n  InlineAsm::ConstraintCodeVector *rCodes;\n  if (maIndex >= (int)info.multipleAlternatives.size())\n    rCodes = &info.Codes;\n  else\n    rCodes = &info.multipleAlternatives[maIndex].Codes;\n  ConstraintWeight BestWeight = CW_Invalid;\n\n  // Loop over the options, keeping track of the most general one.\n  for (unsigned i = 0, e = rCodes->size(); i != e; ++i) {\n    ConstraintWeight weight =\n      getSingleConstraintMatchWeight(info, (*rCodes)[i].c_str());\n    if (weight > BestWeight)\n      BestWeight = weight;\n  }\n\n  return BestWeight;\n}\n\n/// Examine constraint type and operand type and determine a weight value.\n/// This object must already have been set up with the operand type\n/// and the current alternative constraint selected.\nTargetLowering::ConstraintWeight\n  TargetLowering::getSingleConstraintMatchWeight(\n    AsmOperandInfo &info, const char *constraint) const {\n  ConstraintWeight weight = CW_Invalid;\n  Value *CallOperandVal = info.CallOperandVal;\n    // If we don't have a value, we can't do a match,\n    // but allow it at the lowest weight.\n  if (!CallOperandVal)\n    return CW_Default;\n  // Look at the constraint type.\n  switch (*constraint) {\n    case 'i': // immediate integer.\n    case 'n': // immediate integer with a known value.\n      if (isa<ConstantInt>(CallOperandVal))\n        weight = CW_Constant;\n      break;\n    case 's': // non-explicit intregal immediate.\n      if (isa<GlobalValue>(CallOperandVal))\n        weight = CW_Constant;\n      break;\n    case 'E': // immediate float if host format.\n    case 'F': // immediate float.\n      if (isa<ConstantFP>(CallOperandVal))\n        weight = CW_Constant;\n      break;\n    case '<': // memory operand with autodecrement.\n    case '>': // memory operand with autoincrement.\n    case 'm': // memory operand.\n    case 'o': // offsettable memory operand\n    case 'V': // non-offsettable memory operand\n      weight = CW_Memory;\n      break;\n    case 'r': // general register.\n    case 'g': // general register, memory operand or immediate integer.\n              // note: Clang converts \"g\" to \"imr\".\n      if (CallOperandVal->getType()->isIntegerTy())\n        weight = CW_Register;\n      break;\n    case 'X': // any operand.\n  default:\n    weight = CW_Default;\n    break;\n  }\n  return weight;\n}\n\n/// If there are multiple different constraints that we could pick for this\n/// operand (e.g. \"imr\") try to pick the 'best' one.\n/// This is somewhat tricky: constraints fall into four classes:\n///    Other         -> immediates and magic values\n///    Register      -> one specific register\n///    RegisterClass -> a group of regs\n///    Memory        -> memory\n/// Ideally, we would pick the most specific constraint possible: if we have\n/// something that fits into a register, we would pick it.  The problem here\n/// is that if we have something that could either be in a register or in\n/// memory that use of the register could cause selection of *other*\n/// operands to fail: they might only succeed if we pick memory.  Because of\n/// this the heuristic we use is:\n///\n///  1) If there is an 'other' constraint, and if the operand is valid for\n///     that constraint, use it.  This makes us take advantage of 'i'\n///     constraints when available.\n///  2) Otherwise, pick the most general constraint present.  This prefers\n///     'm' over 'r', for example.\n///\nstatic void ChooseConstraint(TargetLowering::AsmOperandInfo &OpInfo,\n                             const TargetLowering &TLI,\n                             SDValue Op, SelectionDAG *DAG) {\n  assert(OpInfo.Codes.size() > 1 && \"Doesn't have multiple constraint options\");\n  unsigned BestIdx = 0;\n  TargetLowering::ConstraintType BestType = TargetLowering::C_Unknown;\n  int BestGenerality = -1;\n\n  // Loop over the options, keeping track of the most general one.\n  for (unsigned i = 0, e = OpInfo.Codes.size(); i != e; ++i) {\n    TargetLowering::ConstraintType CType =\n      TLI.getConstraintType(OpInfo.Codes[i]);\n\n    // Indirect 'other' or 'immediate' constraints are not allowed.\n    if (OpInfo.isIndirect && !(CType == TargetLowering::C_Memory ||\n                               CType == TargetLowering::C_Register ||\n                               CType == TargetLowering::C_RegisterClass))\n      continue;\n\n    // If this is an 'other' or 'immediate' constraint, see if the operand is\n    // valid for it. For example, on X86 we might have an 'rI' constraint. If\n    // the operand is an integer in the range [0..31] we want to use I (saving a\n    // load of a register), otherwise we must use 'r'.\n    if ((CType == TargetLowering::C_Other ||\n         CType == TargetLowering::C_Immediate) && Op.getNode()) {\n      assert(OpInfo.Codes[i].size() == 1 &&\n             \"Unhandled multi-letter 'other' constraint\");\n      std::vector<SDValue> ResultOps;\n      TLI.LowerAsmOperandForConstraint(Op, OpInfo.Codes[i],\n                                       ResultOps, *DAG);\n      if (!ResultOps.empty()) {\n        BestType = CType;\n        BestIdx = i;\n        break;\n      }\n    }\n\n    // Things with matching constraints can only be registers, per gcc\n    // documentation.  This mainly affects \"g\" constraints.\n    if (CType == TargetLowering::C_Memory && OpInfo.hasMatchingInput())\n      continue;\n\n    // This constraint letter is more general than the previous one, use it.\n    int Generality = getConstraintGenerality(CType);\n    if (Generality > BestGenerality) {\n      BestType = CType;\n      BestIdx = i;\n      BestGenerality = Generality;\n    }\n  }\n\n  OpInfo.ConstraintCode = OpInfo.Codes[BestIdx];\n  OpInfo.ConstraintType = BestType;\n}\n\n/// Determines the constraint code and constraint type to use for the specific\n/// AsmOperandInfo, setting OpInfo.ConstraintCode and OpInfo.ConstraintType.\nvoid TargetLowering::ComputeConstraintToUse(AsmOperandInfo &OpInfo,\n                                            SDValue Op,\n                                            SelectionDAG *DAG) const {\n  assert(!OpInfo.Codes.empty() && \"Must have at least one constraint\");\n\n  // Single-letter constraints ('r') are very common.\n  if (OpInfo.Codes.size() == 1) {\n    OpInfo.ConstraintCode = OpInfo.Codes[0];\n    OpInfo.ConstraintType = getConstraintType(OpInfo.ConstraintCode);\n  } else {\n    ChooseConstraint(OpInfo, *this, Op, DAG);\n  }\n\n  // 'X' matches anything.\n  if (OpInfo.ConstraintCode == \"X\" && OpInfo.CallOperandVal) {\n    // Labels and constants are handled elsewhere ('X' is the only thing\n    // that matches labels).  For Functions, the type here is the type of\n    // the result, which is not what we want to look at; leave them alone.\n    Value *v = OpInfo.CallOperandVal;\n    if (isa<BasicBlock>(v) || isa<ConstantInt>(v) || isa<Function>(v)) {\n      OpInfo.CallOperandVal = v;\n      return;\n    }\n\n    if (Op.getNode() && Op.getOpcode() == ISD::TargetBlockAddress)\n      return;\n\n    // Otherwise, try to resolve it to something we know about by looking at\n    // the actual operand type.\n    if (const char *Repl = LowerXConstraint(OpInfo.ConstraintVT)) {\n      OpInfo.ConstraintCode = Repl;\n      OpInfo.ConstraintType = getConstraintType(OpInfo.ConstraintCode);\n    }\n  }\n}\n\n/// Given an exact SDIV by a constant, create a multiplication\n/// with the multiplicative inverse of the constant.\nstatic SDValue BuildExactSDIV(const TargetLowering &TLI, SDNode *N,\n                              const SDLoc &dl, SelectionDAG &DAG,\n                              SmallVectorImpl<SDNode *> &Created) {\n  SDValue Op0 = N->getOperand(0);\n  SDValue Op1 = N->getOperand(1);\n  EVT VT = N->getValueType(0);\n  EVT SVT = VT.getScalarType();\n  EVT ShVT = TLI.getShiftAmountTy(VT, DAG.getDataLayout());\n  EVT ShSVT = ShVT.getScalarType();\n\n  bool UseSRA = false;\n  SmallVector<SDValue, 16> Shifts, Factors;\n\n  auto BuildSDIVPattern = [&](ConstantSDNode *C) {\n    if (C->isNullValue())\n      return false;\n    APInt Divisor = C->getAPIntValue();\n    unsigned Shift = Divisor.countTrailingZeros();\n    if (Shift) {\n      Divisor.ashrInPlace(Shift);\n      UseSRA = true;\n    }\n    // Calculate the multiplicative inverse, using Newton's method.\n    APInt t;\n    APInt Factor = Divisor;\n    while ((t = Divisor * Factor) != 1)\n      Factor *= APInt(Divisor.getBitWidth(), 2) - t;\n    Shifts.push_back(DAG.getConstant(Shift, dl, ShSVT));\n    Factors.push_back(DAG.getConstant(Factor, dl, SVT));\n    return true;\n  };\n\n  // Collect all magic values from the build vector.\n  if (!ISD::matchUnaryPredicate(Op1, BuildSDIVPattern))\n    return SDValue();\n\n  SDValue Shift, Factor;\n  if (VT.isFixedLengthVector()) {\n    Shift = DAG.getBuildVector(ShVT, dl, Shifts);\n    Factor = DAG.getBuildVector(VT, dl, Factors);\n  } else if (VT.isScalableVector()) {\n    assert(Shifts.size() == 1 && Factors.size() == 1 &&\n           \"Expected matchUnaryPredicate to return one element for scalable \"\n           \"vectors\");\n    Shift = DAG.getSplatVector(ShVT, dl, Shifts[0]);\n    Factor = DAG.getSplatVector(VT, dl, Factors[0]);\n  } else {\n    Shift = Shifts[0];\n    Factor = Factors[0];\n  }\n\n  SDValue Res = Op0;\n\n  // Shift the value upfront if it is even, so the LSB is one.\n  if (UseSRA) {\n    // TODO: For UDIV use SRL instead of SRA.\n    SDNodeFlags Flags;\n    Flags.setExact(true);\n    Res = DAG.getNode(ISD::SRA, dl, VT, Res, Shift, Flags);\n    Created.push_back(Res.getNode());\n  }\n\n  return DAG.getNode(ISD::MUL, dl, VT, Res, Factor);\n}\n\nSDValue TargetLowering::BuildSDIVPow2(SDNode *N, const APInt &Divisor,\n                              SelectionDAG &DAG,\n                              SmallVectorImpl<SDNode *> &Created) const {\n  AttributeList Attr = DAG.getMachineFunction().getFunction().getAttributes();\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  if (TLI.isIntDivCheap(N->getValueType(0), Attr))\n    return SDValue(N, 0); // Lower SDIV as SDIV\n  return SDValue();\n}\n\n/// Given an ISD::SDIV node expressing a divide by constant,\n/// return a DAG expression to select that will generate the same value by\n/// multiplying by a magic number.\n/// Ref: \"Hacker's Delight\" or \"The PowerPC Compiler Writer's Guide\".\nSDValue TargetLowering::BuildSDIV(SDNode *N, SelectionDAG &DAG,\n                                  bool IsAfterLegalization,\n                                  SmallVectorImpl<SDNode *> &Created) const {\n  SDLoc dl(N);\n  EVT VT = N->getValueType(0);\n  EVT SVT = VT.getScalarType();\n  EVT ShVT = getShiftAmountTy(VT, DAG.getDataLayout());\n  EVT ShSVT = ShVT.getScalarType();\n  unsigned EltBits = VT.getScalarSizeInBits();\n  EVT MulVT;\n\n  // Check to see if we can do this.\n  // FIXME: We should be more aggressive here.\n  if (!isTypeLegal(VT)) {\n    // Limit this to simple scalars for now.\n    if (VT.isVector() || !VT.isSimple())\n      return SDValue();\n\n    // If this type will be promoted to a large enough type with a legal\n    // multiply operation, we can go ahead and do this transform.\n    if (getTypeAction(VT.getSimpleVT()) != TypePromoteInteger)\n      return SDValue();\n\n    MulVT = getTypeToTransformTo(*DAG.getContext(), VT);\n    if (MulVT.getSizeInBits() < (2 * EltBits) ||\n        !isOperationLegal(ISD::MUL, MulVT))\n      return SDValue();\n  }\n\n  // If the sdiv has an 'exact' bit we can use a simpler lowering.\n  if (N->getFlags().hasExact())\n    return BuildExactSDIV(*this, N, dl, DAG, Created);\n\n  SmallVector<SDValue, 16> MagicFactors, Factors, Shifts, ShiftMasks;\n\n  auto BuildSDIVPattern = [&](ConstantSDNode *C) {\n    if (C->isNullValue())\n      return false;\n\n    const APInt &Divisor = C->getAPIntValue();\n    APInt::ms magics = Divisor.magic();\n    int NumeratorFactor = 0;\n    int ShiftMask = -1;\n\n    if (Divisor.isOneValue() || Divisor.isAllOnesValue()) {\n      // If d is +1/-1, we just multiply the numerator by +1/-1.\n      NumeratorFactor = Divisor.getSExtValue();\n      magics.m = 0;\n      magics.s = 0;\n      ShiftMask = 0;\n    } else if (Divisor.isStrictlyPositive() && magics.m.isNegative()) {\n      // If d > 0 and m < 0, add the numerator.\n      NumeratorFactor = 1;\n    } else if (Divisor.isNegative() && magics.m.isStrictlyPositive()) {\n      // If d < 0 and m > 0, subtract the numerator.\n      NumeratorFactor = -1;\n    }\n\n    MagicFactors.push_back(DAG.getConstant(magics.m, dl, SVT));\n    Factors.push_back(DAG.getConstant(NumeratorFactor, dl, SVT));\n    Shifts.push_back(DAG.getConstant(magics.s, dl, ShSVT));\n    ShiftMasks.push_back(DAG.getConstant(ShiftMask, dl, SVT));\n    return true;\n  };\n\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n\n  // Collect the shifts / magic values from each element.\n  if (!ISD::matchUnaryPredicate(N1, BuildSDIVPattern))\n    return SDValue();\n\n  SDValue MagicFactor, Factor, Shift, ShiftMask;\n  if (VT.isFixedLengthVector()) {\n    MagicFactor = DAG.getBuildVector(VT, dl, MagicFactors);\n    Factor = DAG.getBuildVector(VT, dl, Factors);\n    Shift = DAG.getBuildVector(ShVT, dl, Shifts);\n    ShiftMask = DAG.getBuildVector(VT, dl, ShiftMasks);\n  } else if (VT.isScalableVector()) {\n    assert(MagicFactors.size() == 1 && Factors.size() == 1 &&\n           Shifts.size() == 1 && ShiftMasks.size() == 1 &&\n           \"Expected matchUnaryPredicate to return one element for scalable \"\n           \"vectors\");\n    MagicFactor = DAG.getSplatVector(VT, dl, MagicFactors[0]);\n    Factor = DAG.getSplatVector(VT, dl, Factors[0]);\n    Shift = DAG.getSplatVector(ShVT, dl, Shifts[0]);\n    ShiftMask = DAG.getSplatVector(VT, dl, ShiftMasks[0]);\n  } else {\n    MagicFactor = MagicFactors[0];\n    Factor = Factors[0];\n    Shift = Shifts[0];\n    ShiftMask = ShiftMasks[0];\n  }\n\n  // Multiply the numerator (operand 0) by the magic value.\n  // FIXME: We should support doing a MUL in a wider type.\n  auto GetMULHS = [&](SDValue X, SDValue Y) {\n    // If the type isn't legal, use a wider mul of the the type calculated\n    // earlier.\n    if (!isTypeLegal(VT)) {\n      X = DAG.getNode(ISD::SIGN_EXTEND, dl, MulVT, X);\n      Y = DAG.getNode(ISD::SIGN_EXTEND, dl, MulVT, Y);\n      Y = DAG.getNode(ISD::MUL, dl, MulVT, X, Y);\n      Y = DAG.getNode(ISD::SRL, dl, MulVT, Y,\n                      DAG.getShiftAmountConstant(EltBits, MulVT, dl));\n      return DAG.getNode(ISD::TRUNCATE, dl, VT, Y);\n    }\n\n    if (isOperationLegalOrCustom(ISD::MULHS, VT, IsAfterLegalization))\n      return DAG.getNode(ISD::MULHS, dl, VT, X, Y);\n    if (isOperationLegalOrCustom(ISD::SMUL_LOHI, VT, IsAfterLegalization)) {\n      SDValue LoHi =\n          DAG.getNode(ISD::SMUL_LOHI, dl, DAG.getVTList(VT, VT), X, Y);\n      return SDValue(LoHi.getNode(), 1);\n    }\n    return SDValue();\n  };\n\n  SDValue Q = GetMULHS(N0, MagicFactor);\n  if (!Q)\n    return SDValue();\n\n  Created.push_back(Q.getNode());\n\n  // (Optionally) Add/subtract the numerator using Factor.\n  Factor = DAG.getNode(ISD::MUL, dl, VT, N0, Factor);\n  Created.push_back(Factor.getNode());\n  Q = DAG.getNode(ISD::ADD, dl, VT, Q, Factor);\n  Created.push_back(Q.getNode());\n\n  // Shift right algebraic by shift value.\n  Q = DAG.getNode(ISD::SRA, dl, VT, Q, Shift);\n  Created.push_back(Q.getNode());\n\n  // Extract the sign bit, mask it and add it to the quotient.\n  SDValue SignShift = DAG.getConstant(EltBits - 1, dl, ShVT);\n  SDValue T = DAG.getNode(ISD::SRL, dl, VT, Q, SignShift);\n  Created.push_back(T.getNode());\n  T = DAG.getNode(ISD::AND, dl, VT, T, ShiftMask);\n  Created.push_back(T.getNode());\n  return DAG.getNode(ISD::ADD, dl, VT, Q, T);\n}\n\n/// Given an ISD::UDIV node expressing a divide by constant,\n/// return a DAG expression to select that will generate the same value by\n/// multiplying by a magic number.\n/// Ref: \"Hacker's Delight\" or \"The PowerPC Compiler Writer's Guide\".\nSDValue TargetLowering::BuildUDIV(SDNode *N, SelectionDAG &DAG,\n                                  bool IsAfterLegalization,\n                                  SmallVectorImpl<SDNode *> &Created) const {\n  SDLoc dl(N);\n  EVT VT = N->getValueType(0);\n  EVT SVT = VT.getScalarType();\n  EVT ShVT = getShiftAmountTy(VT, DAG.getDataLayout());\n  EVT ShSVT = ShVT.getScalarType();\n  unsigned EltBits = VT.getScalarSizeInBits();\n  EVT MulVT;\n\n  // Check to see if we can do this.\n  // FIXME: We should be more aggressive here.\n  if (!isTypeLegal(VT)) {\n    // Limit this to simple scalars for now.\n    if (VT.isVector() || !VT.isSimple())\n      return SDValue();\n\n    // If this type will be promoted to a large enough type with a legal\n    // multiply operation, we can go ahead and do this transform.\n    if (getTypeAction(VT.getSimpleVT()) != TypePromoteInteger)\n      return SDValue();\n\n    MulVT = getTypeToTransformTo(*DAG.getContext(), VT);\n    if (MulVT.getSizeInBits() < (2 * EltBits) ||\n        !isOperationLegal(ISD::MUL, MulVT))\n      return SDValue();\n  }\n\n  bool UseNPQ = false;\n  SmallVector<SDValue, 16> PreShifts, PostShifts, MagicFactors, NPQFactors;\n\n  auto BuildUDIVPattern = [&](ConstantSDNode *C) {\n    if (C->isNullValue())\n      return false;\n    // FIXME: We should use a narrower constant when the upper\n    // bits are known to be zero.\n    APInt Divisor = C->getAPIntValue();\n    APInt::mu magics = Divisor.magicu();\n    unsigned PreShift = 0, PostShift = 0;\n\n    // If the divisor is even, we can avoid using the expensive fixup by\n    // shifting the divided value upfront.\n    if (magics.a != 0 && !Divisor[0]) {\n      PreShift = Divisor.countTrailingZeros();\n      // Get magic number for the shifted divisor.\n      magics = Divisor.lshr(PreShift).magicu(PreShift);\n      assert(magics.a == 0 && \"Should use cheap fixup now\");\n    }\n\n    APInt Magic = magics.m;\n\n    unsigned SelNPQ;\n    if (magics.a == 0 || Divisor.isOneValue()) {\n      assert(magics.s < Divisor.getBitWidth() &&\n             \"We shouldn't generate an undefined shift!\");\n      PostShift = magics.s;\n      SelNPQ = false;\n    } else {\n      PostShift = magics.s - 1;\n      SelNPQ = true;\n    }\n\n    PreShifts.push_back(DAG.getConstant(PreShift, dl, ShSVT));\n    MagicFactors.push_back(DAG.getConstant(Magic, dl, SVT));\n    NPQFactors.push_back(\n        DAG.getConstant(SelNPQ ? APInt::getOneBitSet(EltBits, EltBits - 1)\n                               : APInt::getNullValue(EltBits),\n                        dl, SVT));\n    PostShifts.push_back(DAG.getConstant(PostShift, dl, ShSVT));\n    UseNPQ |= SelNPQ;\n    return true;\n  };\n\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n\n  // Collect the shifts/magic values from each element.\n  if (!ISD::matchUnaryPredicate(N1, BuildUDIVPattern))\n    return SDValue();\n\n  SDValue PreShift, PostShift, MagicFactor, NPQFactor;\n  if (VT.isFixedLengthVector()) {\n    PreShift = DAG.getBuildVector(ShVT, dl, PreShifts);\n    MagicFactor = DAG.getBuildVector(VT, dl, MagicFactors);\n    NPQFactor = DAG.getBuildVector(VT, dl, NPQFactors);\n    PostShift = DAG.getBuildVector(ShVT, dl, PostShifts);\n  } else if (VT.isScalableVector()) {\n    assert(PreShifts.size() == 1 && MagicFactors.size() == 1 &&\n           NPQFactors.size() == 1 && PostShifts.size() == 1 &&\n           \"Expected matchUnaryPredicate to return one for scalable vectors\");\n    PreShift = DAG.getSplatVector(ShVT, dl, PreShifts[0]);\n    MagicFactor = DAG.getSplatVector(VT, dl, MagicFactors[0]);\n    NPQFactor = DAG.getSplatVector(VT, dl, NPQFactors[0]);\n    PostShift = DAG.getSplatVector(ShVT, dl, PostShifts[0]);\n  } else {\n    PreShift = PreShifts[0];\n    MagicFactor = MagicFactors[0];\n    PostShift = PostShifts[0];\n  }\n\n  SDValue Q = N0;\n  Q = DAG.getNode(ISD::SRL, dl, VT, Q, PreShift);\n  Created.push_back(Q.getNode());\n\n  // FIXME: We should support doing a MUL in a wider type.\n  auto GetMULHU = [&](SDValue X, SDValue Y) {\n    // If the type isn't legal, use a wider mul of the the type calculated\n    // earlier.\n    if (!isTypeLegal(VT)) {\n      X = DAG.getNode(ISD::ZERO_EXTEND, dl, MulVT, X);\n      Y = DAG.getNode(ISD::ZERO_EXTEND, dl, MulVT, Y);\n      Y = DAG.getNode(ISD::MUL, dl, MulVT, X, Y);\n      Y = DAG.getNode(ISD::SRL, dl, MulVT, Y,\n                      DAG.getShiftAmountConstant(EltBits, MulVT, dl));\n      return DAG.getNode(ISD::TRUNCATE, dl, VT, Y);\n    }\n\n    if (isOperationLegalOrCustom(ISD::MULHU, VT, IsAfterLegalization))\n      return DAG.getNode(ISD::MULHU, dl, VT, X, Y);\n    if (isOperationLegalOrCustom(ISD::UMUL_LOHI, VT, IsAfterLegalization)) {\n      SDValue LoHi =\n          DAG.getNode(ISD::UMUL_LOHI, dl, DAG.getVTList(VT, VT), X, Y);\n      return SDValue(LoHi.getNode(), 1);\n    }\n    return SDValue(); // No mulhu or equivalent\n  };\n\n  // Multiply the numerator (operand 0) by the magic value.\n  Q = GetMULHU(Q, MagicFactor);\n  if (!Q)\n    return SDValue();\n\n  Created.push_back(Q.getNode());\n\n  if (UseNPQ) {\n    SDValue NPQ = DAG.getNode(ISD::SUB, dl, VT, N0, Q);\n    Created.push_back(NPQ.getNode());\n\n    // For vectors we might have a mix of non-NPQ/NPQ paths, so use\n    // MULHU to act as a SRL-by-1 for NPQ, else multiply by zero.\n    if (VT.isVector())\n      NPQ = GetMULHU(NPQ, NPQFactor);\n    else\n      NPQ = DAG.getNode(ISD::SRL, dl, VT, NPQ, DAG.getConstant(1, dl, ShVT));\n\n    Created.push_back(NPQ.getNode());\n\n    Q = DAG.getNode(ISD::ADD, dl, VT, NPQ, Q);\n    Created.push_back(Q.getNode());\n  }\n\n  Q = DAG.getNode(ISD::SRL, dl, VT, Q, PostShift);\n  Created.push_back(Q.getNode());\n\n  EVT SetCCVT = getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), VT);\n\n  SDValue One = DAG.getConstant(1, dl, VT);\n  SDValue IsOne = DAG.getSetCC(dl, SetCCVT, N1, One, ISD::SETEQ);\n  return DAG.getSelect(dl, VT, IsOne, N0, Q);\n}\n\n/// If all values in Values that *don't* match the predicate are same 'splat'\n/// value, then replace all values with that splat value.\n/// Else, if AlternativeReplacement was provided, then replace all values that\n/// do match predicate with AlternativeReplacement value.\nstatic void\nturnVectorIntoSplatVector(MutableArrayRef<SDValue> Values,\n                          std::function<bool(SDValue)> Predicate,\n                          SDValue AlternativeReplacement = SDValue()) {\n  SDValue Replacement;\n  // Is there a value for which the Predicate does *NOT* match? What is it?\n  auto SplatValue = llvm::find_if_not(Values, Predicate);\n  if (SplatValue != Values.end()) {\n    // Does Values consist only of SplatValue's and values matching Predicate?\n    if (llvm::all_of(Values, [Predicate, SplatValue](SDValue Value) {\n          return Value == *SplatValue || Predicate(Value);\n        })) // Then we shall replace values matching predicate with SplatValue.\n      Replacement = *SplatValue;\n  }\n  if (!Replacement) {\n    // Oops, we did not find the \"baseline\" splat value.\n    if (!AlternativeReplacement)\n      return; // Nothing to do.\n    // Let's replace with provided value then.\n    Replacement = AlternativeReplacement;\n  }\n  std::replace_if(Values.begin(), Values.end(), Predicate, Replacement);\n}\n\n/// Given an ISD::UREM used only by an ISD::SETEQ or ISD::SETNE\n/// where the divisor is constant and the comparison target is zero,\n/// return a DAG expression that will generate the same comparison result\n/// using only multiplications, additions and shifts/rotations.\n/// Ref: \"Hacker's Delight\" 10-17.\nSDValue TargetLowering::buildUREMEqFold(EVT SETCCVT, SDValue REMNode,\n                                        SDValue CompTargetNode,\n                                        ISD::CondCode Cond,\n                                        DAGCombinerInfo &DCI,\n                                        const SDLoc &DL) const {\n  SmallVector<SDNode *, 5> Built;\n  if (SDValue Folded = prepareUREMEqFold(SETCCVT, REMNode, CompTargetNode, Cond,\n                                         DCI, DL, Built)) {\n    for (SDNode *N : Built)\n      DCI.AddToWorklist(N);\n    return Folded;\n  }\n\n  return SDValue();\n}\n\nSDValue\nTargetLowering::prepareUREMEqFold(EVT SETCCVT, SDValue REMNode,\n                                  SDValue CompTargetNode, ISD::CondCode Cond,\n                                  DAGCombinerInfo &DCI, const SDLoc &DL,\n                                  SmallVectorImpl<SDNode *> &Created) const {\n  // fold (seteq/ne (urem N, D), 0) -> (setule/ugt (rotr (mul N, P), K), Q)\n  // - D must be constant, with D = D0 * 2^K where D0 is odd\n  // - P is the multiplicative inverse of D0 modulo 2^W\n  // - Q = floor(((2^W) - 1) / D)\n  // where W is the width of the common type of N and D.\n  assert((Cond == ISD::SETEQ || Cond == ISD::SETNE) &&\n         \"Only applicable for (in)equality comparisons.\");\n\n  SelectionDAG &DAG = DCI.DAG;\n\n  EVT VT = REMNode.getValueType();\n  EVT SVT = VT.getScalarType();\n  EVT ShVT = getShiftAmountTy(VT, DAG.getDataLayout());\n  EVT ShSVT = ShVT.getScalarType();\n\n  // If MUL is unavailable, we cannot proceed in any case.\n  if (!isOperationLegalOrCustom(ISD::MUL, VT))\n    return SDValue();\n\n  bool ComparingWithAllZeros = true;\n  bool AllComparisonsWithNonZerosAreTautological = true;\n  bool HadTautologicalLanes = false;\n  bool AllLanesAreTautological = true;\n  bool HadEvenDivisor = false;\n  bool AllDivisorsArePowerOfTwo = true;\n  bool HadTautologicalInvertedLanes = false;\n  SmallVector<SDValue, 16> PAmts, KAmts, QAmts, IAmts;\n\n  auto BuildUREMPattern = [&](ConstantSDNode *CDiv, ConstantSDNode *CCmp) {\n    // Division by 0 is UB. Leave it to be constant-folded elsewhere.\n    if (CDiv->isNullValue())\n      return false;\n\n    const APInt &D = CDiv->getAPIntValue();\n    const APInt &Cmp = CCmp->getAPIntValue();\n\n    ComparingWithAllZeros &= Cmp.isNullValue();\n\n    // x u% C1` is *always* less than C1. So given `x u% C1 == C2`,\n    // if C2 is not less than C1, the comparison is always false.\n    // But we will only be able to produce the comparison that will give the\n    // opposive tautological answer. So this lane would need to be fixed up.\n    bool TautologicalInvertedLane = D.ule(Cmp);\n    HadTautologicalInvertedLanes |= TautologicalInvertedLane;\n\n    // If all lanes are tautological (either all divisors are ones, or divisor\n    // is not greater than the constant we are comparing with),\n    // we will prefer to avoid the fold.\n    bool TautologicalLane = D.isOneValue() || TautologicalInvertedLane;\n    HadTautologicalLanes |= TautologicalLane;\n    AllLanesAreTautological &= TautologicalLane;\n\n    // If we are comparing with non-zero, we need'll need  to subtract said\n    // comparison value from the LHS. But there is no point in doing that if\n    // every lane where we are comparing with non-zero is tautological..\n    if (!Cmp.isNullValue())\n      AllComparisonsWithNonZerosAreTautological &= TautologicalLane;\n\n    // Decompose D into D0 * 2^K\n    unsigned K = D.countTrailingZeros();\n    assert((!D.isOneValue() || (K == 0)) && \"For divisor '1' we won't rotate.\");\n    APInt D0 = D.lshr(K);\n\n    // D is even if it has trailing zeros.\n    HadEvenDivisor |= (K != 0);\n    // D is a power-of-two if D0 is one.\n    // If all divisors are power-of-two, we will prefer to avoid the fold.\n    AllDivisorsArePowerOfTwo &= D0.isOneValue();\n\n    // P = inv(D0, 2^W)\n    // 2^W requires W + 1 bits, so we have to extend and then truncate.\n    unsigned W = D.getBitWidth();\n    APInt P = D0.zext(W + 1)\n                  .multiplicativeInverse(APInt::getSignedMinValue(W + 1))\n                  .trunc(W);\n    assert(!P.isNullValue() && \"No multiplicative inverse!\"); // unreachable\n    assert((D0 * P).isOneValue() && \"Multiplicative inverse sanity check.\");\n\n    // Q = floor((2^W - 1) u/ D)\n    // R = ((2^W - 1) u% D)\n    APInt Q, R;\n    APInt::udivrem(APInt::getAllOnesValue(W), D, Q, R);\n\n    // If we are comparing with zero, then that comparison constant is okay,\n    // else it may need to be one less than that.\n    if (Cmp.ugt(R))\n      Q -= 1;\n\n    assert(APInt::getAllOnesValue(ShSVT.getSizeInBits()).ugt(K) &&\n           \"We are expecting that K is always less than all-ones for ShSVT\");\n\n    // If the lane is tautological the result can be constant-folded.\n    if (TautologicalLane) {\n      // Set P and K amount to a bogus values so we can try to splat them.\n      P = 0;\n      K = -1;\n      // And ensure that comparison constant is tautological,\n      // it will always compare true/false.\n      Q = -1;\n    }\n\n    PAmts.push_back(DAG.getConstant(P, DL, SVT));\n    KAmts.push_back(\n        DAG.getConstant(APInt(ShSVT.getSizeInBits(), K), DL, ShSVT));\n    QAmts.push_back(DAG.getConstant(Q, DL, SVT));\n    return true;\n  };\n\n  SDValue N = REMNode.getOperand(0);\n  SDValue D = REMNode.getOperand(1);\n\n  // Collect the values from each element.\n  if (!ISD::matchBinaryPredicate(D, CompTargetNode, BuildUREMPattern))\n    return SDValue();\n\n  // If all lanes are tautological, the result can be constant-folded.\n  if (AllLanesAreTautological)\n    return SDValue();\n\n  // If this is a urem by a powers-of-two, avoid the fold since it can be\n  // best implemented as a bit test.\n  if (AllDivisorsArePowerOfTwo)\n    return SDValue();\n\n  SDValue PVal, KVal, QVal;\n  if (VT.isVector()) {\n    if (HadTautologicalLanes) {\n      // Try to turn PAmts into a splat, since we don't care about the values\n      // that are currently '0'. If we can't, just keep '0'`s.\n      turnVectorIntoSplatVector(PAmts, isNullConstant);\n      // Try to turn KAmts into a splat, since we don't care about the values\n      // that are currently '-1'. If we can't, change them to '0'`s.\n      turnVectorIntoSplatVector(KAmts, isAllOnesConstant,\n                                DAG.getConstant(0, DL, ShSVT));\n    }\n\n    PVal = DAG.getBuildVector(VT, DL, PAmts);\n    KVal = DAG.getBuildVector(ShVT, DL, KAmts);\n    QVal = DAG.getBuildVector(VT, DL, QAmts);\n  } else {\n    PVal = PAmts[0];\n    KVal = KAmts[0];\n    QVal = QAmts[0];\n  }\n\n  if (!ComparingWithAllZeros && !AllComparisonsWithNonZerosAreTautological) {\n    if (!isOperationLegalOrCustom(ISD::SUB, VT))\n      return SDValue(); // FIXME: Could/should use `ISD::ADD`?\n    assert(CompTargetNode.getValueType() == N.getValueType() &&\n           \"Expecting that the types on LHS and RHS of comparisons match.\");\n    N = DAG.getNode(ISD::SUB, DL, VT, N, CompTargetNode);\n  }\n\n  // (mul N, P)\n  SDValue Op0 = DAG.getNode(ISD::MUL, DL, VT, N, PVal);\n  Created.push_back(Op0.getNode());\n\n  // Rotate right only if any divisor was even. We avoid rotates for all-odd\n  // divisors as a performance improvement, since rotating by 0 is a no-op.\n  if (HadEvenDivisor) {\n    // We need ROTR to do this.\n    if (!isOperationLegalOrCustom(ISD::ROTR, VT))\n      return SDValue();\n    SDNodeFlags Flags;\n    Flags.setExact(true);\n    // UREM: (rotr (mul N, P), K)\n    Op0 = DAG.getNode(ISD::ROTR, DL, VT, Op0, KVal, Flags);\n    Created.push_back(Op0.getNode());\n  }\n\n  // UREM: (setule/setugt (rotr (mul N, P), K), Q)\n  SDValue NewCC =\n      DAG.getSetCC(DL, SETCCVT, Op0, QVal,\n                   ((Cond == ISD::SETEQ) ? ISD::SETULE : ISD::SETUGT));\n  if (!HadTautologicalInvertedLanes)\n    return NewCC;\n\n  // If any lanes previously compared always-false, the NewCC will give\n  // always-true result for them, so we need to fixup those lanes.\n  // Or the other way around for inequality predicate.\n  assert(VT.isVector() && \"Can/should only get here for vectors.\");\n  Created.push_back(NewCC.getNode());\n\n  // x u% C1` is *always* less than C1. So given `x u% C1 == C2`,\n  // if C2 is not less than C1, the comparison is always false.\n  // But we have produced the comparison that will give the\n  // opposive tautological answer. So these lanes would need to be fixed up.\n  SDValue TautologicalInvertedChannels =\n      DAG.getSetCC(DL, SETCCVT, D, CompTargetNode, ISD::SETULE);\n  Created.push_back(TautologicalInvertedChannels.getNode());\n\n  if (isOperationLegalOrCustom(ISD::VSELECT, SETCCVT)) {\n    // If we have a vector select, let's replace the comparison results in the\n    // affected lanes with the correct tautological result.\n    SDValue Replacement = DAG.getBoolConstant(Cond == ISD::SETEQ ? false : true,\n                                              DL, SETCCVT, SETCCVT);\n    return DAG.getNode(ISD::VSELECT, DL, SETCCVT, TautologicalInvertedChannels,\n                       Replacement, NewCC);\n  }\n\n  // Else, we can just invert the comparison result in the appropriate lanes.\n  if (isOperationLegalOrCustom(ISD::XOR, SETCCVT))\n    return DAG.getNode(ISD::XOR, DL, SETCCVT, NewCC,\n                       TautologicalInvertedChannels);\n\n  return SDValue(); // Don't know how to lower.\n}\n\n/// Given an ISD::SREM used only by an ISD::SETEQ or ISD::SETNE\n/// where the divisor is constant and the comparison target is zero,\n/// return a DAG expression that will generate the same comparison result\n/// using only multiplications, additions and shifts/rotations.\n/// Ref: \"Hacker's Delight\" 10-17.\nSDValue TargetLowering::buildSREMEqFold(EVT SETCCVT, SDValue REMNode,\n                                        SDValue CompTargetNode,\n                                        ISD::CondCode Cond,\n                                        DAGCombinerInfo &DCI,\n                                        const SDLoc &DL) const {\n  SmallVector<SDNode *, 7> Built;\n  if (SDValue Folded = prepareSREMEqFold(SETCCVT, REMNode, CompTargetNode, Cond,\n                                         DCI, DL, Built)) {\n    assert(Built.size() <= 7 && \"Max size prediction failed.\");\n    for (SDNode *N : Built)\n      DCI.AddToWorklist(N);\n    return Folded;\n  }\n\n  return SDValue();\n}\n\nSDValue\nTargetLowering::prepareSREMEqFold(EVT SETCCVT, SDValue REMNode,\n                                  SDValue CompTargetNode, ISD::CondCode Cond,\n                                  DAGCombinerInfo &DCI, const SDLoc &DL,\n                                  SmallVectorImpl<SDNode *> &Created) const {\n  // Fold:\n  //   (seteq/ne (srem N, D), 0)\n  // To:\n  //   (setule/ugt (rotr (add (mul N, P), A), K), Q)\n  //\n  // - D must be constant, with D = D0 * 2^K where D0 is odd\n  // - P is the multiplicative inverse of D0 modulo 2^W\n  // - A = bitwiseand(floor((2^(W - 1) - 1) / D0), (-(2^k)))\n  // - Q = floor((2 * A) / (2^K))\n  // where W is the width of the common type of N and D.\n  assert((Cond == ISD::SETEQ || Cond == ISD::SETNE) &&\n         \"Only applicable for (in)equality comparisons.\");\n\n  SelectionDAG &DAG = DCI.DAG;\n\n  EVT VT = REMNode.getValueType();\n  EVT SVT = VT.getScalarType();\n  EVT ShVT = getShiftAmountTy(VT, DAG.getDataLayout());\n  EVT ShSVT = ShVT.getScalarType();\n\n  // If MUL is unavailable, we cannot proceed in any case.\n  if (!isOperationLegalOrCustom(ISD::MUL, VT))\n    return SDValue();\n\n  // TODO: Could support comparing with non-zero too.\n  ConstantSDNode *CompTarget = isConstOrConstSplat(CompTargetNode);\n  if (!CompTarget || !CompTarget->isNullValue())\n    return SDValue();\n\n  bool HadIntMinDivisor = false;\n  bool HadOneDivisor = false;\n  bool AllDivisorsAreOnes = true;\n  bool HadEvenDivisor = false;\n  bool NeedToApplyOffset = false;\n  bool AllDivisorsArePowerOfTwo = true;\n  SmallVector<SDValue, 16> PAmts, AAmts, KAmts, QAmts;\n\n  auto BuildSREMPattern = [&](ConstantSDNode *C) {\n    // Division by 0 is UB. Leave it to be constant-folded elsewhere.\n    if (C->isNullValue())\n      return false;\n\n    // FIXME: we don't fold `rem %X, -C` to `rem %X, C` in DAGCombine.\n\n    // WARNING: this fold is only valid for positive divisors!\n    APInt D = C->getAPIntValue();\n    if (D.isNegative())\n      D.negate(); //  `rem %X, -C` is equivalent to `rem %X, C`\n\n    HadIntMinDivisor |= D.isMinSignedValue();\n\n    // If all divisors are ones, we will prefer to avoid the fold.\n    HadOneDivisor |= D.isOneValue();\n    AllDivisorsAreOnes &= D.isOneValue();\n\n    // Decompose D into D0 * 2^K\n    unsigned K = D.countTrailingZeros();\n    assert((!D.isOneValue() || (K == 0)) && \"For divisor '1' we won't rotate.\");\n    APInt D0 = D.lshr(K);\n\n    if (!D.isMinSignedValue()) {\n      // D is even if it has trailing zeros; unless it's INT_MIN, in which case\n      // we don't care about this lane in this fold, we'll special-handle it.\n      HadEvenDivisor |= (K != 0);\n    }\n\n    // D is a power-of-two if D0 is one. This includes INT_MIN.\n    // If all divisors are power-of-two, we will prefer to avoid the fold.\n    AllDivisorsArePowerOfTwo &= D0.isOneValue();\n\n    // P = inv(D0, 2^W)\n    // 2^W requires W + 1 bits, so we have to extend and then truncate.\n    unsigned W = D.getBitWidth();\n    APInt P = D0.zext(W + 1)\n                  .multiplicativeInverse(APInt::getSignedMinValue(W + 1))\n                  .trunc(W);\n    assert(!P.isNullValue() && \"No multiplicative inverse!\"); // unreachable\n    assert((D0 * P).isOneValue() && \"Multiplicative inverse sanity check.\");\n\n    // A = floor((2^(W - 1) - 1) / D0) & -2^K\n    APInt A = APInt::getSignedMaxValue(W).udiv(D0);\n    A.clearLowBits(K);\n\n    if (!D.isMinSignedValue()) {\n      // If divisor INT_MIN, then we don't care about this lane in this fold,\n      // we'll special-handle it.\n      NeedToApplyOffset |= A != 0;\n    }\n\n    // Q = floor((2 * A) / (2^K))\n    APInt Q = (2 * A).udiv(APInt::getOneBitSet(W, K));\n\n    assert(APInt::getAllOnesValue(SVT.getSizeInBits()).ugt(A) &&\n           \"We are expecting that A is always less than all-ones for SVT\");\n    assert(APInt::getAllOnesValue(ShSVT.getSizeInBits()).ugt(K) &&\n           \"We are expecting that K is always less than all-ones for ShSVT\");\n\n    // If the divisor is 1 the result can be constant-folded. Likewise, we\n    // don't care about INT_MIN lanes, those can be set to undef if appropriate.\n    if (D.isOneValue()) {\n      // Set P, A and K to a bogus values so we can try to splat them.\n      P = 0;\n      A = -1;\n      K = -1;\n\n      // x ?% 1 == 0  <-->  true  <-->  x u<= -1\n      Q = -1;\n    }\n\n    PAmts.push_back(DAG.getConstant(P, DL, SVT));\n    AAmts.push_back(DAG.getConstant(A, DL, SVT));\n    KAmts.push_back(\n        DAG.getConstant(APInt(ShSVT.getSizeInBits(), K), DL, ShSVT));\n    QAmts.push_back(DAG.getConstant(Q, DL, SVT));\n    return true;\n  };\n\n  SDValue N = REMNode.getOperand(0);\n  SDValue D = REMNode.getOperand(1);\n\n  // Collect the values from each element.\n  if (!ISD::matchUnaryPredicate(D, BuildSREMPattern))\n    return SDValue();\n\n  // If this is a srem by a one, avoid the fold since it can be constant-folded.\n  if (AllDivisorsAreOnes)\n    return SDValue();\n\n  // If this is a srem by a powers-of-two (including INT_MIN), avoid the fold\n  // since it can be best implemented as a bit test.\n  if (AllDivisorsArePowerOfTwo)\n    return SDValue();\n\n  SDValue PVal, AVal, KVal, QVal;\n  if (VT.isFixedLengthVector()) {\n    if (HadOneDivisor) {\n      // Try to turn PAmts into a splat, since we don't care about the values\n      // that are currently '0'. If we can't, just keep '0'`s.\n      turnVectorIntoSplatVector(PAmts, isNullConstant);\n      // Try to turn AAmts into a splat, since we don't care about the\n      // values that are currently '-1'. If we can't, change them to '0'`s.\n      turnVectorIntoSplatVector(AAmts, isAllOnesConstant,\n                                DAG.getConstant(0, DL, SVT));\n      // Try to turn KAmts into a splat, since we don't care about the values\n      // that are currently '-1'. If we can't, change them to '0'`s.\n      turnVectorIntoSplatVector(KAmts, isAllOnesConstant,\n                                DAG.getConstant(0, DL, ShSVT));\n    }\n\n    PVal = DAG.getBuildVector(VT, DL, PAmts);\n    AVal = DAG.getBuildVector(VT, DL, AAmts);\n    KVal = DAG.getBuildVector(ShVT, DL, KAmts);\n    QVal = DAG.getBuildVector(VT, DL, QAmts);\n  } else if (VT.isScalableVector()) {\n    assert(PAmts.size() == 1 && AAmts.size() == 1 && KAmts.size() == 1 &&\n           QAmts.size() == 1 &&\n           \"Expected matchUnaryPredicate to return one element for scalable \"\n           \"vectors\");\n    PVal = DAG.getSplatVector(VT, DL, PAmts[0]);\n    AVal = DAG.getSplatVector(VT, DL, AAmts[0]);\n    KVal = DAG.getSplatVector(ShVT, DL, KAmts[0]);\n    QVal = DAG.getSplatVector(VT, DL, QAmts[0]);\n  } else {\n    PVal = PAmts[0];\n    AVal = AAmts[0];\n    KVal = KAmts[0];\n    QVal = QAmts[0];\n  }\n\n  // (mul N, P)\n  SDValue Op0 = DAG.getNode(ISD::MUL, DL, VT, N, PVal);\n  Created.push_back(Op0.getNode());\n\n  if (NeedToApplyOffset) {\n    // We need ADD to do this.\n    if (!isOperationLegalOrCustom(ISD::ADD, VT))\n      return SDValue();\n\n    // (add (mul N, P), A)\n    Op0 = DAG.getNode(ISD::ADD, DL, VT, Op0, AVal);\n    Created.push_back(Op0.getNode());\n  }\n\n  // Rotate right only if any divisor was even. We avoid rotates for all-odd\n  // divisors as a performance improvement, since rotating by 0 is a no-op.\n  if (HadEvenDivisor) {\n    // We need ROTR to do this.\n    if (!isOperationLegalOrCustom(ISD::ROTR, VT))\n      return SDValue();\n    SDNodeFlags Flags;\n    Flags.setExact(true);\n    // SREM: (rotr (add (mul N, P), A), K)\n    Op0 = DAG.getNode(ISD::ROTR, DL, VT, Op0, KVal, Flags);\n    Created.push_back(Op0.getNode());\n  }\n\n  // SREM: (setule/setugt (rotr (add (mul N, P), A), K), Q)\n  SDValue Fold =\n      DAG.getSetCC(DL, SETCCVT, Op0, QVal,\n                   ((Cond == ISD::SETEQ) ? ISD::SETULE : ISD::SETUGT));\n\n  // If we didn't have lanes with INT_MIN divisor, then we're done.\n  if (!HadIntMinDivisor)\n    return Fold;\n\n  // That fold is only valid for positive divisors. Which effectively means,\n  // it is invalid for INT_MIN divisors. So if we have such a lane,\n  // we must fix-up results for said lanes.\n  assert(VT.isVector() && \"Can/should only get here for vectors.\");\n\n  if (!isOperationLegalOrCustom(ISD::SETEQ, VT) ||\n      !isOperationLegalOrCustom(ISD::AND, VT) ||\n      !isOperationLegalOrCustom(Cond, VT) ||\n      !isOperationLegalOrCustom(ISD::VSELECT, VT))\n    return SDValue();\n\n  Created.push_back(Fold.getNode());\n\n  SDValue IntMin = DAG.getConstant(\n      APInt::getSignedMinValue(SVT.getScalarSizeInBits()), DL, VT);\n  SDValue IntMax = DAG.getConstant(\n      APInt::getSignedMaxValue(SVT.getScalarSizeInBits()), DL, VT);\n  SDValue Zero =\n      DAG.getConstant(APInt::getNullValue(SVT.getScalarSizeInBits()), DL, VT);\n\n  // Which lanes had INT_MIN divisors? Divisor is constant, so const-folded.\n  SDValue DivisorIsIntMin = DAG.getSetCC(DL, SETCCVT, D, IntMin, ISD::SETEQ);\n  Created.push_back(DivisorIsIntMin.getNode());\n\n  // (N s% INT_MIN) ==/!= 0  <-->  (N & INT_MAX) ==/!= 0\n  SDValue Masked = DAG.getNode(ISD::AND, DL, VT, N, IntMax);\n  Created.push_back(Masked.getNode());\n  SDValue MaskedIsZero = DAG.getSetCC(DL, SETCCVT, Masked, Zero, Cond);\n  Created.push_back(MaskedIsZero.getNode());\n\n  // To produce final result we need to blend 2 vectors: 'SetCC' and\n  // 'MaskedIsZero'. If the divisor for channel was *NOT* INT_MIN, we pick\n  // from 'Fold', else pick from 'MaskedIsZero'. Since 'DivisorIsIntMin' is\n  // constant-folded, select can get lowered to a shuffle with constant mask.\n  SDValue Blended =\n      DAG.getNode(ISD::VSELECT, DL, VT, DivisorIsIntMin, MaskedIsZero, Fold);\n\n  return Blended;\n}\n\nbool TargetLowering::\nverifyReturnAddressArgumentIsConstant(SDValue Op, SelectionDAG &DAG) const {\n  if (!isa<ConstantSDNode>(Op.getOperand(0))) {\n    DAG.getContext()->emitError(\"argument to '__builtin_return_address' must \"\n                                \"be a constant integer\");\n    return true;\n  }\n\n  return false;\n}\n\nSDValue TargetLowering::getSqrtInputTest(SDValue Op, SelectionDAG &DAG,\n                                         const DenormalMode &Mode) const {\n  SDLoc DL(Op);\n  EVT VT = Op.getValueType();\n  EVT CCVT = getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), VT);\n  SDValue FPZero = DAG.getConstantFP(0.0, DL, VT);\n  // Testing it with denormal inputs to avoid wrong estimate.\n  if (Mode.Input == DenormalMode::IEEE) {\n    // This is specifically a check for the handling of denormal inputs,\n    // not the result.\n\n    // Test = fabs(X) < SmallestNormal\n    const fltSemantics &FltSem = DAG.EVTToAPFloatSemantics(VT);\n    APFloat SmallestNorm = APFloat::getSmallestNormalized(FltSem);\n    SDValue NormC = DAG.getConstantFP(SmallestNorm, DL, VT);\n    SDValue Fabs = DAG.getNode(ISD::FABS, DL, VT, Op);\n    return DAG.getSetCC(DL, CCVT, Fabs, NormC, ISD::SETLT);\n  }\n  // Test = X == 0.0\n  return DAG.getSetCC(DL, CCVT, Op, FPZero, ISD::SETEQ);\n}\n\nSDValue TargetLowering::getNegatedExpression(SDValue Op, SelectionDAG &DAG,\n                                             bool LegalOps, bool OptForSize,\n                                             NegatibleCost &Cost,\n                                             unsigned Depth) const {\n  // fneg is removable even if it has multiple uses.\n  if (Op.getOpcode() == ISD::FNEG) {\n    Cost = NegatibleCost::Cheaper;\n    return Op.getOperand(0);\n  }\n\n  // Don't recurse exponentially.\n  if (Depth > SelectionDAG::MaxRecursionDepth)\n    return SDValue();\n\n  // Pre-increment recursion depth for use in recursive calls.\n  ++Depth;\n  const SDNodeFlags Flags = Op->getFlags();\n  const TargetOptions &Options = DAG.getTarget().Options;\n  EVT VT = Op.getValueType();\n  unsigned Opcode = Op.getOpcode();\n\n  // Don't allow anything with multiple uses unless we know it is free.\n  if (!Op.hasOneUse() && Opcode != ISD::ConstantFP) {\n    bool IsFreeExtend = Opcode == ISD::FP_EXTEND &&\n                        isFPExtFree(VT, Op.getOperand(0).getValueType());\n    if (!IsFreeExtend)\n      return SDValue();\n  }\n\n  auto RemoveDeadNode = [&](SDValue N) {\n    if (N && N.getNode()->use_empty())\n      DAG.RemoveDeadNode(N.getNode());\n  };\n\n  SDLoc DL(Op);\n\n  switch (Opcode) {\n  case ISD::ConstantFP: {\n    // Don't invert constant FP values after legalization unless the target says\n    // the negated constant is legal.\n    bool IsOpLegal =\n        isOperationLegal(ISD::ConstantFP, VT) ||\n        isFPImmLegal(neg(cast<ConstantFPSDNode>(Op)->getValueAPF()), VT,\n                     OptForSize);\n\n    if (LegalOps && !IsOpLegal)\n      break;\n\n    APFloat V = cast<ConstantFPSDNode>(Op)->getValueAPF();\n    V.changeSign();\n    SDValue CFP = DAG.getConstantFP(V, DL, VT);\n\n    // If we already have the use of the negated floating constant, it is free\n    // to negate it even it has multiple uses.\n    if (!Op.hasOneUse() && CFP.use_empty())\n      break;\n    Cost = NegatibleCost::Neutral;\n    return CFP;\n  }\n  case ISD::BUILD_VECTOR: {\n    // Only permit BUILD_VECTOR of constants.\n    if (llvm::any_of(Op->op_values(), [&](SDValue N) {\n          return !N.isUndef() && !isa<ConstantFPSDNode>(N);\n        }))\n      break;\n\n    bool IsOpLegal =\n        (isOperationLegal(ISD::ConstantFP, VT) &&\n         isOperationLegal(ISD::BUILD_VECTOR, VT)) ||\n        llvm::all_of(Op->op_values(), [&](SDValue N) {\n          return N.isUndef() ||\n                 isFPImmLegal(neg(cast<ConstantFPSDNode>(N)->getValueAPF()), VT,\n                              OptForSize);\n        });\n\n    if (LegalOps && !IsOpLegal)\n      break;\n\n    SmallVector<SDValue, 4> Ops;\n    for (SDValue C : Op->op_values()) {\n      if (C.isUndef()) {\n        Ops.push_back(C);\n        continue;\n      }\n      APFloat V = cast<ConstantFPSDNode>(C)->getValueAPF();\n      V.changeSign();\n      Ops.push_back(DAG.getConstantFP(V, DL, C.getValueType()));\n    }\n    Cost = NegatibleCost::Neutral;\n    return DAG.getBuildVector(VT, DL, Ops);\n  }\n  case ISD::FADD: {\n    if (!Options.NoSignedZerosFPMath && !Flags.hasNoSignedZeros())\n      break;\n\n    // After operation legalization, it might not be legal to create new FSUBs.\n    if (LegalOps && !isOperationLegalOrCustom(ISD::FSUB, VT))\n      break;\n    SDValue X = Op.getOperand(0), Y = Op.getOperand(1);\n\n    // fold (fneg (fadd X, Y)) -> (fsub (fneg X), Y)\n    NegatibleCost CostX = NegatibleCost::Expensive;\n    SDValue NegX =\n        getNegatedExpression(X, DAG, LegalOps, OptForSize, CostX, Depth);\n    // fold (fneg (fadd X, Y)) -> (fsub (fneg Y), X)\n    NegatibleCost CostY = NegatibleCost::Expensive;\n    SDValue NegY =\n        getNegatedExpression(Y, DAG, LegalOps, OptForSize, CostY, Depth);\n\n    // Negate the X if its cost is less or equal than Y.\n    if (NegX && (CostX <= CostY)) {\n      Cost = CostX;\n      SDValue N = DAG.getNode(ISD::FSUB, DL, VT, NegX, Y, Flags);\n      if (NegY != N)\n        RemoveDeadNode(NegY);\n      return N;\n    }\n\n    // Negate the Y if it is not expensive.\n    if (NegY) {\n      Cost = CostY;\n      SDValue N = DAG.getNode(ISD::FSUB, DL, VT, NegY, X, Flags);\n      if (NegX != N)\n        RemoveDeadNode(NegX);\n      return N;\n    }\n    break;\n  }\n  case ISD::FSUB: {\n    // We can't turn -(A-B) into B-A when we honor signed zeros.\n    if (!Options.NoSignedZerosFPMath && !Flags.hasNoSignedZeros())\n      break;\n\n    SDValue X = Op.getOperand(0), Y = Op.getOperand(1);\n    // fold (fneg (fsub 0, Y)) -> Y\n    if (ConstantFPSDNode *C = isConstOrConstSplatFP(X, /*AllowUndefs*/ true))\n      if (C->isZero()) {\n        Cost = NegatibleCost::Cheaper;\n        return Y;\n      }\n\n    // fold (fneg (fsub X, Y)) -> (fsub Y, X)\n    Cost = NegatibleCost::Neutral;\n    return DAG.getNode(ISD::FSUB, DL, VT, Y, X, Flags);\n  }\n  case ISD::FMUL:\n  case ISD::FDIV: {\n    SDValue X = Op.getOperand(0), Y = Op.getOperand(1);\n\n    // fold (fneg (fmul X, Y)) -> (fmul (fneg X), Y)\n    NegatibleCost CostX = NegatibleCost::Expensive;\n    SDValue NegX =\n        getNegatedExpression(X, DAG, LegalOps, OptForSize, CostX, Depth);\n    // fold (fneg (fmul X, Y)) -> (fmul X, (fneg Y))\n    NegatibleCost CostY = NegatibleCost::Expensive;\n    SDValue NegY =\n        getNegatedExpression(Y, DAG, LegalOps, OptForSize, CostY, Depth);\n\n    // Negate the X if its cost is less or equal than Y.\n    if (NegX && (CostX <= CostY)) {\n      Cost = CostX;\n      SDValue N = DAG.getNode(Opcode, DL, VT, NegX, Y, Flags);\n      if (NegY != N)\n        RemoveDeadNode(NegY);\n      return N;\n    }\n\n    // Ignore X * 2.0 because that is expected to be canonicalized to X + X.\n    if (auto *C = isConstOrConstSplatFP(Op.getOperand(1)))\n      if (C->isExactlyValue(2.0) && Op.getOpcode() == ISD::FMUL)\n        break;\n\n    // Negate the Y if it is not expensive.\n    if (NegY) {\n      Cost = CostY;\n      SDValue N = DAG.getNode(Opcode, DL, VT, X, NegY, Flags);\n      if (NegX != N)\n        RemoveDeadNode(NegX);\n      return N;\n    }\n    break;\n  }\n  case ISD::FMA:\n  case ISD::FMAD: {\n    if (!Options.NoSignedZerosFPMath && !Flags.hasNoSignedZeros())\n      break;\n\n    SDValue X = Op.getOperand(0), Y = Op.getOperand(1), Z = Op.getOperand(2);\n    NegatibleCost CostZ = NegatibleCost::Expensive;\n    SDValue NegZ =\n        getNegatedExpression(Z, DAG, LegalOps, OptForSize, CostZ, Depth);\n    // Give up if fail to negate the Z.\n    if (!NegZ)\n      break;\n\n    // fold (fneg (fma X, Y, Z)) -> (fma (fneg X), Y, (fneg Z))\n    NegatibleCost CostX = NegatibleCost::Expensive;\n    SDValue NegX =\n        getNegatedExpression(X, DAG, LegalOps, OptForSize, CostX, Depth);\n    // fold (fneg (fma X, Y, Z)) -> (fma X, (fneg Y), (fneg Z))\n    NegatibleCost CostY = NegatibleCost::Expensive;\n    SDValue NegY =\n        getNegatedExpression(Y, DAG, LegalOps, OptForSize, CostY, Depth);\n\n    // Negate the X if its cost is less or equal than Y.\n    if (NegX && (CostX <= CostY)) {\n      Cost = std::min(CostX, CostZ);\n      SDValue N = DAG.getNode(Opcode, DL, VT, NegX, Y, NegZ, Flags);\n      if (NegY != N)\n        RemoveDeadNode(NegY);\n      return N;\n    }\n\n    // Negate the Y if it is not expensive.\n    if (NegY) {\n      Cost = std::min(CostY, CostZ);\n      SDValue N = DAG.getNode(Opcode, DL, VT, X, NegY, NegZ, Flags);\n      if (NegX != N)\n        RemoveDeadNode(NegX);\n      return N;\n    }\n    break;\n  }\n\n  case ISD::FP_EXTEND:\n  case ISD::FSIN:\n    if (SDValue NegV = getNegatedExpression(Op.getOperand(0), DAG, LegalOps,\n                                            OptForSize, Cost, Depth))\n      return DAG.getNode(Opcode, DL, VT, NegV);\n    break;\n  case ISD::FP_ROUND:\n    if (SDValue NegV = getNegatedExpression(Op.getOperand(0), DAG, LegalOps,\n                                            OptForSize, Cost, Depth))\n      return DAG.getNode(ISD::FP_ROUND, DL, VT, NegV, Op.getOperand(1));\n    break;\n  }\n\n  return SDValue();\n}\n\n//===----------------------------------------------------------------------===//\n// Legalization Utilities\n//===----------------------------------------------------------------------===//\n\nbool TargetLowering::expandMUL_LOHI(unsigned Opcode, EVT VT, const SDLoc &dl,\n                                    SDValue LHS, SDValue RHS,\n                                    SmallVectorImpl<SDValue> &Result,\n                                    EVT HiLoVT, SelectionDAG &DAG,\n                                    MulExpansionKind Kind, SDValue LL,\n                                    SDValue LH, SDValue RL, SDValue RH) const {\n  assert(Opcode == ISD::MUL || Opcode == ISD::UMUL_LOHI ||\n         Opcode == ISD::SMUL_LOHI);\n\n  bool HasMULHS = (Kind == MulExpansionKind::Always) ||\n                  isOperationLegalOrCustom(ISD::MULHS, HiLoVT);\n  bool HasMULHU = (Kind == MulExpansionKind::Always) ||\n                  isOperationLegalOrCustom(ISD::MULHU, HiLoVT);\n  bool HasSMUL_LOHI = (Kind == MulExpansionKind::Always) ||\n                      isOperationLegalOrCustom(ISD::SMUL_LOHI, HiLoVT);\n  bool HasUMUL_LOHI = (Kind == MulExpansionKind::Always) ||\n                      isOperationLegalOrCustom(ISD::UMUL_LOHI, HiLoVT);\n\n  if (!HasMULHU && !HasMULHS && !HasUMUL_LOHI && !HasSMUL_LOHI)\n    return false;\n\n  unsigned OuterBitSize = VT.getScalarSizeInBits();\n  unsigned InnerBitSize = HiLoVT.getScalarSizeInBits();\n\n  // LL, LH, RL, and RH must be either all NULL or all set to a value.\n  assert((LL.getNode() && LH.getNode() && RL.getNode() && RH.getNode()) ||\n         (!LL.getNode() && !LH.getNode() && !RL.getNode() && !RH.getNode()));\n\n  SDVTList VTs = DAG.getVTList(HiLoVT, HiLoVT);\n  auto MakeMUL_LOHI = [&](SDValue L, SDValue R, SDValue &Lo, SDValue &Hi,\n                          bool Signed) -> bool {\n    if ((Signed && HasSMUL_LOHI) || (!Signed && HasUMUL_LOHI)) {\n      Lo = DAG.getNode(Signed ? ISD::SMUL_LOHI : ISD::UMUL_LOHI, dl, VTs, L, R);\n      Hi = SDValue(Lo.getNode(), 1);\n      return true;\n    }\n    if ((Signed && HasMULHS) || (!Signed && HasMULHU)) {\n      Lo = DAG.getNode(ISD::MUL, dl, HiLoVT, L, R);\n      Hi = DAG.getNode(Signed ? ISD::MULHS : ISD::MULHU, dl, HiLoVT, L, R);\n      return true;\n    }\n    return false;\n  };\n\n  SDValue Lo, Hi;\n\n  if (!LL.getNode() && !RL.getNode() &&\n      isOperationLegalOrCustom(ISD::TRUNCATE, HiLoVT)) {\n    LL = DAG.getNode(ISD::TRUNCATE, dl, HiLoVT, LHS);\n    RL = DAG.getNode(ISD::TRUNCATE, dl, HiLoVT, RHS);\n  }\n\n  if (!LL.getNode())\n    return false;\n\n  APInt HighMask = APInt::getHighBitsSet(OuterBitSize, InnerBitSize);\n  if (DAG.MaskedValueIsZero(LHS, HighMask) &&\n      DAG.MaskedValueIsZero(RHS, HighMask)) {\n    // The inputs are both zero-extended.\n    if (MakeMUL_LOHI(LL, RL, Lo, Hi, false)) {\n      Result.push_back(Lo);\n      Result.push_back(Hi);\n      if (Opcode != ISD::MUL) {\n        SDValue Zero = DAG.getConstant(0, dl, HiLoVT);\n        Result.push_back(Zero);\n        Result.push_back(Zero);\n      }\n      return true;\n    }\n  }\n\n  if (!VT.isVector() && Opcode == ISD::MUL &&\n      DAG.ComputeNumSignBits(LHS) > InnerBitSize &&\n      DAG.ComputeNumSignBits(RHS) > InnerBitSize) {\n    // The input values are both sign-extended.\n    // TODO non-MUL case?\n    if (MakeMUL_LOHI(LL, RL, Lo, Hi, true)) {\n      Result.push_back(Lo);\n      Result.push_back(Hi);\n      return true;\n    }\n  }\n\n  unsigned ShiftAmount = OuterBitSize - InnerBitSize;\n  EVT ShiftAmountTy = getShiftAmountTy(VT, DAG.getDataLayout());\n  if (APInt::getMaxValue(ShiftAmountTy.getSizeInBits()).ult(ShiftAmount)) {\n    // FIXME getShiftAmountTy does not always return a sensible result when VT\n    // is an illegal type, and so the type may be too small to fit the shift\n    // amount. Override it with i32. The shift will have to be legalized.\n    ShiftAmountTy = MVT::i32;\n  }\n  SDValue Shift = DAG.getConstant(ShiftAmount, dl, ShiftAmountTy);\n\n  if (!LH.getNode() && !RH.getNode() &&\n      isOperationLegalOrCustom(ISD::SRL, VT) &&\n      isOperationLegalOrCustom(ISD::TRUNCATE, HiLoVT)) {\n    LH = DAG.getNode(ISD::SRL, dl, VT, LHS, Shift);\n    LH = DAG.getNode(ISD::TRUNCATE, dl, HiLoVT, LH);\n    RH = DAG.getNode(ISD::SRL, dl, VT, RHS, Shift);\n    RH = DAG.getNode(ISD::TRUNCATE, dl, HiLoVT, RH);\n  }\n\n  if (!LH.getNode())\n    return false;\n\n  if (!MakeMUL_LOHI(LL, RL, Lo, Hi, false))\n    return false;\n\n  Result.push_back(Lo);\n\n  if (Opcode == ISD::MUL) {\n    RH = DAG.getNode(ISD::MUL, dl, HiLoVT, LL, RH);\n    LH = DAG.getNode(ISD::MUL, dl, HiLoVT, LH, RL);\n    Hi = DAG.getNode(ISD::ADD, dl, HiLoVT, Hi, RH);\n    Hi = DAG.getNode(ISD::ADD, dl, HiLoVT, Hi, LH);\n    Result.push_back(Hi);\n    return true;\n  }\n\n  // Compute the full width result.\n  auto Merge = [&](SDValue Lo, SDValue Hi) -> SDValue {\n    Lo = DAG.getNode(ISD::ZERO_EXTEND, dl, VT, Lo);\n    Hi = DAG.getNode(ISD::ZERO_EXTEND, dl, VT, Hi);\n    Hi = DAG.getNode(ISD::SHL, dl, VT, Hi, Shift);\n    return DAG.getNode(ISD::OR, dl, VT, Lo, Hi);\n  };\n\n  SDValue Next = DAG.getNode(ISD::ZERO_EXTEND, dl, VT, Hi);\n  if (!MakeMUL_LOHI(LL, RH, Lo, Hi, false))\n    return false;\n\n  // This is effectively the add part of a multiply-add of half-sized operands,\n  // so it cannot overflow.\n  Next = DAG.getNode(ISD::ADD, dl, VT, Next, Merge(Lo, Hi));\n\n  if (!MakeMUL_LOHI(LH, RL, Lo, Hi, false))\n    return false;\n\n  SDValue Zero = DAG.getConstant(0, dl, HiLoVT);\n  EVT BoolType = getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), VT);\n\n  bool UseGlue = (isOperationLegalOrCustom(ISD::ADDC, VT) &&\n                  isOperationLegalOrCustom(ISD::ADDE, VT));\n  if (UseGlue)\n    Next = DAG.getNode(ISD::ADDC, dl, DAG.getVTList(VT, MVT::Glue), Next,\n                       Merge(Lo, Hi));\n  else\n    Next = DAG.getNode(ISD::ADDCARRY, dl, DAG.getVTList(VT, BoolType), Next,\n                       Merge(Lo, Hi), DAG.getConstant(0, dl, BoolType));\n\n  SDValue Carry = Next.getValue(1);\n  Result.push_back(DAG.getNode(ISD::TRUNCATE, dl, HiLoVT, Next));\n  Next = DAG.getNode(ISD::SRL, dl, VT, Next, Shift);\n\n  if (!MakeMUL_LOHI(LH, RH, Lo, Hi, Opcode == ISD::SMUL_LOHI))\n    return false;\n\n  if (UseGlue)\n    Hi = DAG.getNode(ISD::ADDE, dl, DAG.getVTList(HiLoVT, MVT::Glue), Hi, Zero,\n                     Carry);\n  else\n    Hi = DAG.getNode(ISD::ADDCARRY, dl, DAG.getVTList(HiLoVT, BoolType), Hi,\n                     Zero, Carry);\n\n  Next = DAG.getNode(ISD::ADD, dl, VT, Next, Merge(Lo, Hi));\n\n  if (Opcode == ISD::SMUL_LOHI) {\n    SDValue NextSub = DAG.getNode(ISD::SUB, dl, VT, Next,\n                                  DAG.getNode(ISD::ZERO_EXTEND, dl, VT, RL));\n    Next = DAG.getSelectCC(dl, LH, Zero, NextSub, Next, ISD::SETLT);\n\n    NextSub = DAG.getNode(ISD::SUB, dl, VT, Next,\n                          DAG.getNode(ISD::ZERO_EXTEND, dl, VT, LL));\n    Next = DAG.getSelectCC(dl, RH, Zero, NextSub, Next, ISD::SETLT);\n  }\n\n  Result.push_back(DAG.getNode(ISD::TRUNCATE, dl, HiLoVT, Next));\n  Next = DAG.getNode(ISD::SRL, dl, VT, Next, Shift);\n  Result.push_back(DAG.getNode(ISD::TRUNCATE, dl, HiLoVT, Next));\n  return true;\n}\n\nbool TargetLowering::expandMUL(SDNode *N, SDValue &Lo, SDValue &Hi, EVT HiLoVT,\n                               SelectionDAG &DAG, MulExpansionKind Kind,\n                               SDValue LL, SDValue LH, SDValue RL,\n                               SDValue RH) const {\n  SmallVector<SDValue, 2> Result;\n  bool Ok = expandMUL_LOHI(N->getOpcode(), N->getValueType(0), SDLoc(N),\n                           N->getOperand(0), N->getOperand(1), Result, HiLoVT,\n                           DAG, Kind, LL, LH, RL, RH);\n  if (Ok) {\n    assert(Result.size() == 2);\n    Lo = Result[0];\n    Hi = Result[1];\n  }\n  return Ok;\n}\n\n// Check that (every element of) Z is undef or not an exact multiple of BW.\nstatic bool isNonZeroModBitWidthOrUndef(SDValue Z, unsigned BW) {\n  return ISD::matchUnaryPredicate(\n      Z,\n      [=](ConstantSDNode *C) { return !C || C->getAPIntValue().urem(BW) != 0; },\n      true);\n}\n\nbool TargetLowering::expandFunnelShift(SDNode *Node, SDValue &Result,\n                                       SelectionDAG &DAG) const {\n  EVT VT = Node->getValueType(0);\n\n  if (VT.isVector() && (!isOperationLegalOrCustom(ISD::SHL, VT) ||\n                        !isOperationLegalOrCustom(ISD::SRL, VT) ||\n                        !isOperationLegalOrCustom(ISD::SUB, VT) ||\n                        !isOperationLegalOrCustomOrPromote(ISD::OR, VT)))\n    return false;\n\n  SDValue X = Node->getOperand(0);\n  SDValue Y = Node->getOperand(1);\n  SDValue Z = Node->getOperand(2);\n\n  unsigned BW = VT.getScalarSizeInBits();\n  bool IsFSHL = Node->getOpcode() == ISD::FSHL;\n  SDLoc DL(SDValue(Node, 0));\n\n  EVT ShVT = Z.getValueType();\n\n  // If a funnel shift in the other direction is more supported, use it.\n  unsigned RevOpcode = IsFSHL ? ISD::FSHR : ISD::FSHL;\n  if (!isOperationLegalOrCustom(Node->getOpcode(), VT) &&\n      isOperationLegalOrCustom(RevOpcode, VT) && isPowerOf2_32(BW)) {\n    if (isNonZeroModBitWidthOrUndef(Z, BW)) {\n      // fshl X, Y, Z -> fshr X, Y, -Z\n      // fshr X, Y, Z -> fshl X, Y, -Z\n      SDValue Zero = DAG.getConstant(0, DL, ShVT);\n      Z = DAG.getNode(ISD::SUB, DL, VT, Zero, Z);\n    } else {\n      // fshl X, Y, Z -> fshr (srl X, 1), (fshr X, Y, 1), ~Z\n      // fshr X, Y, Z -> fshl (fshl X, Y, 1), (shl Y, 1), ~Z\n      SDValue One = DAG.getConstant(1, DL, ShVT);\n      if (IsFSHL) {\n        Y = DAG.getNode(RevOpcode, DL, VT, X, Y, One);\n        X = DAG.getNode(ISD::SRL, DL, VT, X, One);\n      } else {\n        X = DAG.getNode(RevOpcode, DL, VT, X, Y, One);\n        Y = DAG.getNode(ISD::SHL, DL, VT, Y, One);\n      }\n      Z = DAG.getNOT(DL, Z, ShVT);\n    }\n    Result = DAG.getNode(RevOpcode, DL, VT, X, Y, Z);\n    return true;\n  }\n\n  SDValue ShX, ShY;\n  SDValue ShAmt, InvShAmt;\n  if (isNonZeroModBitWidthOrUndef(Z, BW)) {\n    // fshl: X << C | Y >> (BW - C)\n    // fshr: X << (BW - C) | Y >> C\n    // where C = Z % BW is not zero\n    SDValue BitWidthC = DAG.getConstant(BW, DL, ShVT);\n    ShAmt = DAG.getNode(ISD::UREM, DL, ShVT, Z, BitWidthC);\n    InvShAmt = DAG.getNode(ISD::SUB, DL, ShVT, BitWidthC, ShAmt);\n    ShX = DAG.getNode(ISD::SHL, DL, VT, X, IsFSHL ? ShAmt : InvShAmt);\n    ShY = DAG.getNode(ISD::SRL, DL, VT, Y, IsFSHL ? InvShAmt : ShAmt);\n  } else {\n    // fshl: X << (Z % BW) | Y >> 1 >> (BW - 1 - (Z % BW))\n    // fshr: X << 1 << (BW - 1 - (Z % BW)) | Y >> (Z % BW)\n    SDValue Mask = DAG.getConstant(BW - 1, DL, ShVT);\n    if (isPowerOf2_32(BW)) {\n      // Z % BW -> Z & (BW - 1)\n      ShAmt = DAG.getNode(ISD::AND, DL, ShVT, Z, Mask);\n      // (BW - 1) - (Z % BW) -> ~Z & (BW - 1)\n      InvShAmt = DAG.getNode(ISD::AND, DL, ShVT, DAG.getNOT(DL, Z, ShVT), Mask);\n    } else {\n      SDValue BitWidthC = DAG.getConstant(BW, DL, ShVT);\n      ShAmt = DAG.getNode(ISD::UREM, DL, ShVT, Z, BitWidthC);\n      InvShAmt = DAG.getNode(ISD::SUB, DL, ShVT, Mask, ShAmt);\n    }\n\n    SDValue One = DAG.getConstant(1, DL, ShVT);\n    if (IsFSHL) {\n      ShX = DAG.getNode(ISD::SHL, DL, VT, X, ShAmt);\n      SDValue ShY1 = DAG.getNode(ISD::SRL, DL, VT, Y, One);\n      ShY = DAG.getNode(ISD::SRL, DL, VT, ShY1, InvShAmt);\n    } else {\n      SDValue ShX1 = DAG.getNode(ISD::SHL, DL, VT, X, One);\n      ShX = DAG.getNode(ISD::SHL, DL, VT, ShX1, InvShAmt);\n      ShY = DAG.getNode(ISD::SRL, DL, VT, Y, ShAmt);\n    }\n  }\n  Result = DAG.getNode(ISD::OR, DL, VT, ShX, ShY);\n  return true;\n}\n\n// TODO: Merge with expandFunnelShift.\nbool TargetLowering::expandROT(SDNode *Node, bool AllowVectorOps,\n                               SDValue &Result, SelectionDAG &DAG) const {\n  EVT VT = Node->getValueType(0);\n  unsigned EltSizeInBits = VT.getScalarSizeInBits();\n  bool IsLeft = Node->getOpcode() == ISD::ROTL;\n  SDValue Op0 = Node->getOperand(0);\n  SDValue Op1 = Node->getOperand(1);\n  SDLoc DL(SDValue(Node, 0));\n\n  EVT ShVT = Op1.getValueType();\n  SDValue Zero = DAG.getConstant(0, DL, ShVT);\n\n  // If a rotate in the other direction is supported, use it.\n  unsigned RevRot = IsLeft ? ISD::ROTR : ISD::ROTL;\n  if (isOperationLegalOrCustom(RevRot, VT) && isPowerOf2_32(EltSizeInBits)) {\n    SDValue Sub = DAG.getNode(ISD::SUB, DL, ShVT, Zero, Op1);\n    Result = DAG.getNode(RevRot, DL, VT, Op0, Sub);\n    return true;\n  }\n\n  if (!AllowVectorOps && VT.isVector() &&\n      (!isOperationLegalOrCustom(ISD::SHL, VT) ||\n       !isOperationLegalOrCustom(ISD::SRL, VT) ||\n       !isOperationLegalOrCustom(ISD::SUB, VT) ||\n       !isOperationLegalOrCustomOrPromote(ISD::OR, VT) ||\n       !isOperationLegalOrCustomOrPromote(ISD::AND, VT)))\n    return false;\n\n  unsigned ShOpc = IsLeft ? ISD::SHL : ISD::SRL;\n  unsigned HsOpc = IsLeft ? ISD::SRL : ISD::SHL;\n  SDValue BitWidthMinusOneC = DAG.getConstant(EltSizeInBits - 1, DL, ShVT);\n  SDValue ShVal;\n  SDValue HsVal;\n  if (isPowerOf2_32(EltSizeInBits)) {\n    // (rotl x, c) -> x << (c & (w - 1)) | x >> (-c & (w - 1))\n    // (rotr x, c) -> x >> (c & (w - 1)) | x << (-c & (w - 1))\n    SDValue NegOp1 = DAG.getNode(ISD::SUB, DL, ShVT, Zero, Op1);\n    SDValue ShAmt = DAG.getNode(ISD::AND, DL, ShVT, Op1, BitWidthMinusOneC);\n    ShVal = DAG.getNode(ShOpc, DL, VT, Op0, ShAmt);\n    SDValue HsAmt = DAG.getNode(ISD::AND, DL, ShVT, NegOp1, BitWidthMinusOneC);\n    HsVal = DAG.getNode(HsOpc, DL, VT, Op0, HsAmt);\n  } else {\n    // (rotl x, c) -> x << (c % w) | x >> 1 >> (w - 1 - (c % w))\n    // (rotr x, c) -> x >> (c % w) | x << 1 << (w - 1 - (c % w))\n    SDValue BitWidthC = DAG.getConstant(EltSizeInBits, DL, ShVT);\n    SDValue ShAmt = DAG.getNode(ISD::UREM, DL, ShVT, Op1, BitWidthC);\n    ShVal = DAG.getNode(ShOpc, DL, VT, Op0, ShAmt);\n    SDValue HsAmt = DAG.getNode(ISD::SUB, DL, ShVT, BitWidthMinusOneC, ShAmt);\n    SDValue One = DAG.getConstant(1, DL, ShVT);\n    HsVal =\n        DAG.getNode(HsOpc, DL, VT, DAG.getNode(HsOpc, DL, VT, Op0, One), HsAmt);\n  }\n  Result = DAG.getNode(ISD::OR, DL, VT, ShVal, HsVal);\n  return true;\n}\n\nbool TargetLowering::expandFP_TO_SINT(SDNode *Node, SDValue &Result,\n                                      SelectionDAG &DAG) const {\n  unsigned OpNo = Node->isStrictFPOpcode() ? 1 : 0;\n  SDValue Src = Node->getOperand(OpNo);\n  EVT SrcVT = Src.getValueType();\n  EVT DstVT = Node->getValueType(0);\n  SDLoc dl(SDValue(Node, 0));\n\n  // FIXME: Only f32 to i64 conversions are supported.\n  if (SrcVT != MVT::f32 || DstVT != MVT::i64)\n    return false;\n\n  if (Node->isStrictFPOpcode())\n    // When a NaN is converted to an integer a trap is allowed. We can't\n    // use this expansion here because it would eliminate that trap. Other\n    // traps are also allowed and cannot be eliminated. See\n    // IEEE 754-2008 sec 5.8.\n    return false;\n\n  // Expand f32 -> i64 conversion\n  // This algorithm comes from compiler-rt's implementation of fixsfdi:\n  // https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/builtins/fixsfdi.c\n  unsigned SrcEltBits = SrcVT.getScalarSizeInBits();\n  EVT IntVT = SrcVT.changeTypeToInteger();\n  EVT IntShVT = getShiftAmountTy(IntVT, DAG.getDataLayout());\n\n  SDValue ExponentMask = DAG.getConstant(0x7F800000, dl, IntVT);\n  SDValue ExponentLoBit = DAG.getConstant(23, dl, IntVT);\n  SDValue Bias = DAG.getConstant(127, dl, IntVT);\n  SDValue SignMask = DAG.getConstant(APInt::getSignMask(SrcEltBits), dl, IntVT);\n  SDValue SignLowBit = DAG.getConstant(SrcEltBits - 1, dl, IntVT);\n  SDValue MantissaMask = DAG.getConstant(0x007FFFFF, dl, IntVT);\n\n  SDValue Bits = DAG.getNode(ISD::BITCAST, dl, IntVT, Src);\n\n  SDValue ExponentBits = DAG.getNode(\n      ISD::SRL, dl, IntVT, DAG.getNode(ISD::AND, dl, IntVT, Bits, ExponentMask),\n      DAG.getZExtOrTrunc(ExponentLoBit, dl, IntShVT));\n  SDValue Exponent = DAG.getNode(ISD::SUB, dl, IntVT, ExponentBits, Bias);\n\n  SDValue Sign = DAG.getNode(ISD::SRA, dl, IntVT,\n                             DAG.getNode(ISD::AND, dl, IntVT, Bits, SignMask),\n                             DAG.getZExtOrTrunc(SignLowBit, dl, IntShVT));\n  Sign = DAG.getSExtOrTrunc(Sign, dl, DstVT);\n\n  SDValue R = DAG.getNode(ISD::OR, dl, IntVT,\n                          DAG.getNode(ISD::AND, dl, IntVT, Bits, MantissaMask),\n                          DAG.getConstant(0x00800000, dl, IntVT));\n\n  R = DAG.getZExtOrTrunc(R, dl, DstVT);\n\n  R = DAG.getSelectCC(\n      dl, Exponent, ExponentLoBit,\n      DAG.getNode(ISD::SHL, dl, DstVT, R,\n                  DAG.getZExtOrTrunc(\n                      DAG.getNode(ISD::SUB, dl, IntVT, Exponent, ExponentLoBit),\n                      dl, IntShVT)),\n      DAG.getNode(ISD::SRL, dl, DstVT, R,\n                  DAG.getZExtOrTrunc(\n                      DAG.getNode(ISD::SUB, dl, IntVT, ExponentLoBit, Exponent),\n                      dl, IntShVT)),\n      ISD::SETGT);\n\n  SDValue Ret = DAG.getNode(ISD::SUB, dl, DstVT,\n                            DAG.getNode(ISD::XOR, dl, DstVT, R, Sign), Sign);\n\n  Result = DAG.getSelectCC(dl, Exponent, DAG.getConstant(0, dl, IntVT),\n                           DAG.getConstant(0, dl, DstVT), Ret, ISD::SETLT);\n  return true;\n}\n\nbool TargetLowering::expandFP_TO_UINT(SDNode *Node, SDValue &Result,\n                                      SDValue &Chain,\n                                      SelectionDAG &DAG) const {\n  SDLoc dl(SDValue(Node, 0));\n  unsigned OpNo = Node->isStrictFPOpcode() ? 1 : 0;\n  SDValue Src = Node->getOperand(OpNo);\n\n  EVT SrcVT = Src.getValueType();\n  EVT DstVT = Node->getValueType(0);\n  EVT SetCCVT =\n      getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), SrcVT);\n  EVT DstSetCCVT =\n      getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), DstVT);\n\n  // Only expand vector types if we have the appropriate vector bit operations.\n  unsigned SIntOpcode = Node->isStrictFPOpcode() ? ISD::STRICT_FP_TO_SINT :\n                                                   ISD::FP_TO_SINT;\n  if (DstVT.isVector() && (!isOperationLegalOrCustom(SIntOpcode, DstVT) ||\n                           !isOperationLegalOrCustomOrPromote(ISD::XOR, SrcVT)))\n    return false;\n\n  // If the maximum float value is smaller then the signed integer range,\n  // the destination signmask can't be represented by the float, so we can\n  // just use FP_TO_SINT directly.\n  const fltSemantics &APFSem = DAG.EVTToAPFloatSemantics(SrcVT);\n  APFloat APF(APFSem, APInt::getNullValue(SrcVT.getScalarSizeInBits()));\n  APInt SignMask = APInt::getSignMask(DstVT.getScalarSizeInBits());\n  if (APFloat::opOverflow &\n      APF.convertFromAPInt(SignMask, false, APFloat::rmNearestTiesToEven)) {\n    if (Node->isStrictFPOpcode()) {\n      Result = DAG.getNode(ISD::STRICT_FP_TO_SINT, dl, { DstVT, MVT::Other },\n                           { Node->getOperand(0), Src });\n      Chain = Result.getValue(1);\n    } else\n      Result = DAG.getNode(ISD::FP_TO_SINT, dl, DstVT, Src);\n    return true;\n  }\n\n  // Don't expand it if there isn't cheap fsub instruction.\n  if (!isOperationLegalOrCustom(\n          Node->isStrictFPOpcode() ? ISD::STRICT_FSUB : ISD::FSUB, SrcVT))\n    return false;\n\n  SDValue Cst = DAG.getConstantFP(APF, dl, SrcVT);\n  SDValue Sel;\n\n  if (Node->isStrictFPOpcode()) {\n    Sel = DAG.getSetCC(dl, SetCCVT, Src, Cst, ISD::SETLT,\n                       Node->getOperand(0), /*IsSignaling*/ true);\n    Chain = Sel.getValue(1);\n  } else {\n    Sel = DAG.getSetCC(dl, SetCCVT, Src, Cst, ISD::SETLT);\n  }\n\n  bool Strict = Node->isStrictFPOpcode() ||\n                shouldUseStrictFP_TO_INT(SrcVT, DstVT, /*IsSigned*/ false);\n\n  if (Strict) {\n    // Expand based on maximum range of FP_TO_SINT, if the value exceeds the\n    // signmask then offset (the result of which should be fully representable).\n    // Sel = Src < 0x8000000000000000\n    // FltOfs = select Sel, 0, 0x8000000000000000\n    // IntOfs = select Sel, 0, 0x8000000000000000\n    // Result = fp_to_sint(Src - FltOfs) ^ IntOfs\n\n    // TODO: Should any fast-math-flags be set for the FSUB?\n    SDValue FltOfs = DAG.getSelect(dl, SrcVT, Sel,\n                                   DAG.getConstantFP(0.0, dl, SrcVT), Cst);\n    Sel = DAG.getBoolExtOrTrunc(Sel, dl, DstSetCCVT, DstVT);\n    SDValue IntOfs = DAG.getSelect(dl, DstVT, Sel,\n                                   DAG.getConstant(0, dl, DstVT),\n                                   DAG.getConstant(SignMask, dl, DstVT));\n    SDValue SInt;\n    if (Node->isStrictFPOpcode()) {\n      SDValue Val = DAG.getNode(ISD::STRICT_FSUB, dl, { SrcVT, MVT::Other },\n                                { Chain, Src, FltOfs });\n      SInt = DAG.getNode(ISD::STRICT_FP_TO_SINT, dl, { DstVT, MVT::Other },\n                         { Val.getValue(1), Val });\n      Chain = SInt.getValue(1);\n    } else {\n      SDValue Val = DAG.getNode(ISD::FSUB, dl, SrcVT, Src, FltOfs);\n      SInt = DAG.getNode(ISD::FP_TO_SINT, dl, DstVT, Val);\n    }\n    Result = DAG.getNode(ISD::XOR, dl, DstVT, SInt, IntOfs);\n  } else {\n    // Expand based on maximum range of FP_TO_SINT:\n    // True = fp_to_sint(Src)\n    // False = 0x8000000000000000 + fp_to_sint(Src - 0x8000000000000000)\n    // Result = select (Src < 0x8000000000000000), True, False\n\n    SDValue True = DAG.getNode(ISD::FP_TO_SINT, dl, DstVT, Src);\n    // TODO: Should any fast-math-flags be set for the FSUB?\n    SDValue False = DAG.getNode(ISD::FP_TO_SINT, dl, DstVT,\n                                DAG.getNode(ISD::FSUB, dl, SrcVT, Src, Cst));\n    False = DAG.getNode(ISD::XOR, dl, DstVT, False,\n                        DAG.getConstant(SignMask, dl, DstVT));\n    Sel = DAG.getBoolExtOrTrunc(Sel, dl, DstSetCCVT, DstVT);\n    Result = DAG.getSelect(dl, DstVT, Sel, True, False);\n  }\n  return true;\n}\n\nbool TargetLowering::expandUINT_TO_FP(SDNode *Node, SDValue &Result,\n                                      SDValue &Chain,\n                                      SelectionDAG &DAG) const {\n  // This transform is not correct for converting 0 when rounding mode is set\n  // to round toward negative infinity which will produce -0.0. So disable under\n  // strictfp.\n  if (Node->isStrictFPOpcode())\n    return false;\n\n  SDValue Src = Node->getOperand(0);\n  EVT SrcVT = Src.getValueType();\n  EVT DstVT = Node->getValueType(0);\n\n  if (SrcVT.getScalarType() != MVT::i64 || DstVT.getScalarType() != MVT::f64)\n    return false;\n\n  // Only expand vector types if we have the appropriate vector bit operations.\n  if (SrcVT.isVector() && (!isOperationLegalOrCustom(ISD::SRL, SrcVT) ||\n                           !isOperationLegalOrCustom(ISD::FADD, DstVT) ||\n                           !isOperationLegalOrCustom(ISD::FSUB, DstVT) ||\n                           !isOperationLegalOrCustomOrPromote(ISD::OR, SrcVT) ||\n                           !isOperationLegalOrCustomOrPromote(ISD::AND, SrcVT)))\n    return false;\n\n  SDLoc dl(SDValue(Node, 0));\n  EVT ShiftVT = getShiftAmountTy(SrcVT, DAG.getDataLayout());\n\n  // Implementation of unsigned i64 to f64 following the algorithm in\n  // __floatundidf in compiler_rt.  This implementation performs rounding\n  // correctly in all rounding modes with the exception of converting 0\n  // when rounding toward negative infinity. In that case the fsub will produce\n  // -0.0. This will be added to +0.0 and produce -0.0 which is incorrect.\n  SDValue TwoP52 = DAG.getConstant(UINT64_C(0x4330000000000000), dl, SrcVT);\n  SDValue TwoP84PlusTwoP52 = DAG.getConstantFP(\n      BitsToDouble(UINT64_C(0x4530000000100000)), dl, DstVT);\n  SDValue TwoP84 = DAG.getConstant(UINT64_C(0x4530000000000000), dl, SrcVT);\n  SDValue LoMask = DAG.getConstant(UINT64_C(0x00000000FFFFFFFF), dl, SrcVT);\n  SDValue HiShift = DAG.getConstant(32, dl, ShiftVT);\n\n  SDValue Lo = DAG.getNode(ISD::AND, dl, SrcVT, Src, LoMask);\n  SDValue Hi = DAG.getNode(ISD::SRL, dl, SrcVT, Src, HiShift);\n  SDValue LoOr = DAG.getNode(ISD::OR, dl, SrcVT, Lo, TwoP52);\n  SDValue HiOr = DAG.getNode(ISD::OR, dl, SrcVT, Hi, TwoP84);\n  SDValue LoFlt = DAG.getBitcast(DstVT, LoOr);\n  SDValue HiFlt = DAG.getBitcast(DstVT, HiOr);\n  SDValue HiSub =\n      DAG.getNode(ISD::FSUB, dl, DstVT, HiFlt, TwoP84PlusTwoP52);\n  Result = DAG.getNode(ISD::FADD, dl, DstVT, LoFlt, HiSub);\n  return true;\n}\n\nSDValue TargetLowering::expandFMINNUM_FMAXNUM(SDNode *Node,\n                                              SelectionDAG &DAG) const {\n  SDLoc dl(Node);\n  unsigned NewOp = Node->getOpcode() == ISD::FMINNUM ?\n    ISD::FMINNUM_IEEE : ISD::FMAXNUM_IEEE;\n  EVT VT = Node->getValueType(0);\n\n  if (VT.isScalableVector())\n    report_fatal_error(\n        \"Expanding fminnum/fmaxnum for scalable vectors is undefined.\");\n\n  if (isOperationLegalOrCustom(NewOp, VT)) {\n    SDValue Quiet0 = Node->getOperand(0);\n    SDValue Quiet1 = Node->getOperand(1);\n\n    if (!Node->getFlags().hasNoNaNs()) {\n      // Insert canonicalizes if it's possible we need to quiet to get correct\n      // sNaN behavior.\n      if (!DAG.isKnownNeverSNaN(Quiet0)) {\n        Quiet0 = DAG.getNode(ISD::FCANONICALIZE, dl, VT, Quiet0,\n                             Node->getFlags());\n      }\n      if (!DAG.isKnownNeverSNaN(Quiet1)) {\n        Quiet1 = DAG.getNode(ISD::FCANONICALIZE, dl, VT, Quiet1,\n                             Node->getFlags());\n      }\n    }\n\n    return DAG.getNode(NewOp, dl, VT, Quiet0, Quiet1, Node->getFlags());\n  }\n\n  // If the target has FMINIMUM/FMAXIMUM but not FMINNUM/FMAXNUM use that\n  // instead if there are no NaNs.\n  if (Node->getFlags().hasNoNaNs()) {\n    unsigned IEEE2018Op =\n        Node->getOpcode() == ISD::FMINNUM ? ISD::FMINIMUM : ISD::FMAXIMUM;\n    if (isOperationLegalOrCustom(IEEE2018Op, VT)) {\n      return DAG.getNode(IEEE2018Op, dl, VT, Node->getOperand(0),\n                         Node->getOperand(1), Node->getFlags());\n    }\n  }\n\n  // If none of the above worked, but there are no NaNs, then expand to\n  // a compare/select sequence.  This is required for correctness since\n  // InstCombine might have canonicalized a fcmp+select sequence to a\n  // FMINNUM/FMAXNUM node.  If we were to fall through to the default\n  // expansion to libcall, we might introduce a link-time dependency\n  // on libm into a file that originally did not have one.\n  if (Node->getFlags().hasNoNaNs()) {\n    ISD::CondCode Pred =\n        Node->getOpcode() == ISD::FMINNUM ? ISD::SETLT : ISD::SETGT;\n    SDValue Op1 = Node->getOperand(0);\n    SDValue Op2 = Node->getOperand(1);\n    SDValue SelCC = DAG.getSelectCC(dl, Op1, Op2, Op1, Op2, Pred);\n    // Copy FMF flags, but always set the no-signed-zeros flag\n    // as this is implied by the FMINNUM/FMAXNUM semantics.\n    SDNodeFlags Flags = Node->getFlags();\n    Flags.setNoSignedZeros(true);\n    SelCC->setFlags(Flags);\n    return SelCC;\n  }\n\n  return SDValue();\n}\n\nbool TargetLowering::expandCTPOP(SDNode *Node, SDValue &Result,\n                                 SelectionDAG &DAG) const {\n  SDLoc dl(Node);\n  EVT VT = Node->getValueType(0);\n  EVT ShVT = getShiftAmountTy(VT, DAG.getDataLayout());\n  SDValue Op = Node->getOperand(0);\n  unsigned Len = VT.getScalarSizeInBits();\n  assert(VT.isInteger() && \"CTPOP not implemented for this type.\");\n\n  // TODO: Add support for irregular type lengths.\n  if (!(Len <= 128 && Len % 8 == 0))\n    return false;\n\n  // Only expand vector types if we have the appropriate vector bit operations.\n  if (VT.isVector() && (!isOperationLegalOrCustom(ISD::ADD, VT) ||\n                        !isOperationLegalOrCustom(ISD::SUB, VT) ||\n                        !isOperationLegalOrCustom(ISD::SRL, VT) ||\n                        (Len != 8 && !isOperationLegalOrCustom(ISD::MUL, VT)) ||\n                        !isOperationLegalOrCustomOrPromote(ISD::AND, VT)))\n    return false;\n\n  // This is the \"best\" algorithm from\n  // http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n  SDValue Mask55 =\n      DAG.getConstant(APInt::getSplat(Len, APInt(8, 0x55)), dl, VT);\n  SDValue Mask33 =\n      DAG.getConstant(APInt::getSplat(Len, APInt(8, 0x33)), dl, VT);\n  SDValue Mask0F =\n      DAG.getConstant(APInt::getSplat(Len, APInt(8, 0x0F)), dl, VT);\n  SDValue Mask01 =\n      DAG.getConstant(APInt::getSplat(Len, APInt(8, 0x01)), dl, VT);\n\n  // v = v - ((v >> 1) & 0x55555555...)\n  Op = DAG.getNode(ISD::SUB, dl, VT, Op,\n                   DAG.getNode(ISD::AND, dl, VT,\n                               DAG.getNode(ISD::SRL, dl, VT, Op,\n                                           DAG.getConstant(1, dl, ShVT)),\n                               Mask55));\n  // v = (v & 0x33333333...) + ((v >> 2) & 0x33333333...)\n  Op = DAG.getNode(ISD::ADD, dl, VT, DAG.getNode(ISD::AND, dl, VT, Op, Mask33),\n                   DAG.getNode(ISD::AND, dl, VT,\n                               DAG.getNode(ISD::SRL, dl, VT, Op,\n                                           DAG.getConstant(2, dl, ShVT)),\n                               Mask33));\n  // v = (v + (v >> 4)) & 0x0F0F0F0F...\n  Op = DAG.getNode(ISD::AND, dl, VT,\n                   DAG.getNode(ISD::ADD, dl, VT, Op,\n                               DAG.getNode(ISD::SRL, dl, VT, Op,\n                                           DAG.getConstant(4, dl, ShVT))),\n                   Mask0F);\n  // v = (v * 0x01010101...) >> (Len - 8)\n  if (Len > 8)\n    Op =\n        DAG.getNode(ISD::SRL, dl, VT, DAG.getNode(ISD::MUL, dl, VT, Op, Mask01),\n                    DAG.getConstant(Len - 8, dl, ShVT));\n\n  Result = Op;\n  return true;\n}\n\nbool TargetLowering::expandCTLZ(SDNode *Node, SDValue &Result,\n                                SelectionDAG &DAG) const {\n  SDLoc dl(Node);\n  EVT VT = Node->getValueType(0);\n  EVT ShVT = getShiftAmountTy(VT, DAG.getDataLayout());\n  SDValue Op = Node->getOperand(0);\n  unsigned NumBitsPerElt = VT.getScalarSizeInBits();\n\n  // If the non-ZERO_UNDEF version is supported we can use that instead.\n  if (Node->getOpcode() == ISD::CTLZ_ZERO_UNDEF &&\n      isOperationLegalOrCustom(ISD::CTLZ, VT)) {\n    Result = DAG.getNode(ISD::CTLZ, dl, VT, Op);\n    return true;\n  }\n\n  // If the ZERO_UNDEF version is supported use that and handle the zero case.\n  if (isOperationLegalOrCustom(ISD::CTLZ_ZERO_UNDEF, VT)) {\n    EVT SetCCVT =\n        getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), VT);\n    SDValue CTLZ = DAG.getNode(ISD::CTLZ_ZERO_UNDEF, dl, VT, Op);\n    SDValue Zero = DAG.getConstant(0, dl, VT);\n    SDValue SrcIsZero = DAG.getSetCC(dl, SetCCVT, Op, Zero, ISD::SETEQ);\n    Result = DAG.getNode(ISD::SELECT, dl, VT, SrcIsZero,\n                         DAG.getConstant(NumBitsPerElt, dl, VT), CTLZ);\n    return true;\n  }\n\n  // Only expand vector types if we have the appropriate vector bit operations.\n  if (VT.isVector() && (!isPowerOf2_32(NumBitsPerElt) ||\n                        !isOperationLegalOrCustom(ISD::CTPOP, VT) ||\n                        !isOperationLegalOrCustom(ISD::SRL, VT) ||\n                        !isOperationLegalOrCustomOrPromote(ISD::OR, VT)))\n    return false;\n\n  // for now, we do this:\n  // x = x | (x >> 1);\n  // x = x | (x >> 2);\n  // ...\n  // x = x | (x >>16);\n  // x = x | (x >>32); // for 64-bit input\n  // return popcount(~x);\n  //\n  // Ref: \"Hacker's Delight\" by Henry Warren\n  for (unsigned i = 0; (1U << i) <= (NumBitsPerElt / 2); ++i) {\n    SDValue Tmp = DAG.getConstant(1ULL << i, dl, ShVT);\n    Op = DAG.getNode(ISD::OR, dl, VT, Op,\n                     DAG.getNode(ISD::SRL, dl, VT, Op, Tmp));\n  }\n  Op = DAG.getNOT(dl, Op, VT);\n  Result = DAG.getNode(ISD::CTPOP, dl, VT, Op);\n  return true;\n}\n\nbool TargetLowering::expandCTTZ(SDNode *Node, SDValue &Result,\n                                SelectionDAG &DAG) const {\n  SDLoc dl(Node);\n  EVT VT = Node->getValueType(0);\n  SDValue Op = Node->getOperand(0);\n  unsigned NumBitsPerElt = VT.getScalarSizeInBits();\n\n  // If the non-ZERO_UNDEF version is supported we can use that instead.\n  if (Node->getOpcode() == ISD::CTTZ_ZERO_UNDEF &&\n      isOperationLegalOrCustom(ISD::CTTZ, VT)) {\n    Result = DAG.getNode(ISD::CTTZ, dl, VT, Op);\n    return true;\n  }\n\n  // If the ZERO_UNDEF version is supported use that and handle the zero case.\n  if (isOperationLegalOrCustom(ISD::CTTZ_ZERO_UNDEF, VT)) {\n    EVT SetCCVT =\n        getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), VT);\n    SDValue CTTZ = DAG.getNode(ISD::CTTZ_ZERO_UNDEF, dl, VT, Op);\n    SDValue Zero = DAG.getConstant(0, dl, VT);\n    SDValue SrcIsZero = DAG.getSetCC(dl, SetCCVT, Op, Zero, ISD::SETEQ);\n    Result = DAG.getNode(ISD::SELECT, dl, VT, SrcIsZero,\n                         DAG.getConstant(NumBitsPerElt, dl, VT), CTTZ);\n    return true;\n  }\n\n  // Only expand vector types if we have the appropriate vector bit operations.\n  if (VT.isVector() && (!isPowerOf2_32(NumBitsPerElt) ||\n                        (!isOperationLegalOrCustom(ISD::CTPOP, VT) &&\n                         !isOperationLegalOrCustom(ISD::CTLZ, VT)) ||\n                        !isOperationLegalOrCustom(ISD::SUB, VT) ||\n                        !isOperationLegalOrCustomOrPromote(ISD::AND, VT) ||\n                        !isOperationLegalOrCustomOrPromote(ISD::XOR, VT)))\n    return false;\n\n  // for now, we use: { return popcount(~x & (x - 1)); }\n  // unless the target has ctlz but not ctpop, in which case we use:\n  // { return 32 - nlz(~x & (x-1)); }\n  // Ref: \"Hacker's Delight\" by Henry Warren\n  SDValue Tmp = DAG.getNode(\n      ISD::AND, dl, VT, DAG.getNOT(dl, Op, VT),\n      DAG.getNode(ISD::SUB, dl, VT, Op, DAG.getConstant(1, dl, VT)));\n\n  // If ISD::CTLZ is legal and CTPOP isn't, then do that instead.\n  if (isOperationLegal(ISD::CTLZ, VT) && !isOperationLegal(ISD::CTPOP, VT)) {\n    Result =\n        DAG.getNode(ISD::SUB, dl, VT, DAG.getConstant(NumBitsPerElt, dl, VT),\n                    DAG.getNode(ISD::CTLZ, dl, VT, Tmp));\n    return true;\n  }\n\n  Result = DAG.getNode(ISD::CTPOP, dl, VT, Tmp);\n  return true;\n}\n\nbool TargetLowering::expandABS(SDNode *N, SDValue &Result,\n                               SelectionDAG &DAG, bool IsNegative) const {\n  SDLoc dl(N);\n  EVT VT = N->getValueType(0);\n  EVT ShVT = getShiftAmountTy(VT, DAG.getDataLayout());\n  SDValue Op = N->getOperand(0);\n\n  // abs(x) -> smax(x,sub(0,x))\n  if (!IsNegative && isOperationLegal(ISD::SUB, VT) &&\n      isOperationLegal(ISD::SMAX, VT)) {\n    SDValue Zero = DAG.getConstant(0, dl, VT);\n    Result = DAG.getNode(ISD::SMAX, dl, VT, Op,\n                         DAG.getNode(ISD::SUB, dl, VT, Zero, Op));\n    return true;\n  }\n\n  // abs(x) -> umin(x,sub(0,x))\n  if (!IsNegative && isOperationLegal(ISD::SUB, VT) &&\n      isOperationLegal(ISD::UMIN, VT)) {\n    SDValue Zero = DAG.getConstant(0, dl, VT);\n    Result = DAG.getNode(ISD::UMIN, dl, VT, Op,\n                         DAG.getNode(ISD::SUB, dl, VT, Zero, Op));\n    return true;\n  }\n\n  // 0 - abs(x) -> smin(x, sub(0,x))\n  if (IsNegative && isOperationLegal(ISD::SUB, VT) &&\n      isOperationLegal(ISD::SMIN, VT)) {\n    SDValue Zero = DAG.getConstant(0, dl, VT);\n    Result = DAG.getNode(ISD::SMIN, dl, VT, Op,\n                         DAG.getNode(ISD::SUB, dl, VT, Zero, Op));\n    return true;\n  }\n\n  // Only expand vector types if we have the appropriate vector operations.\n  if (VT.isVector() &&\n      (!isOperationLegalOrCustom(ISD::SRA, VT) ||\n       (!IsNegative && !isOperationLegalOrCustom(ISD::ADD, VT)) ||\n       (IsNegative && !isOperationLegalOrCustom(ISD::SUB, VT)) ||\n       !isOperationLegalOrCustomOrPromote(ISD::XOR, VT)))\n    return false;\n\n  SDValue Shift =\n      DAG.getNode(ISD::SRA, dl, VT, Op,\n                  DAG.getConstant(VT.getScalarSizeInBits() - 1, dl, ShVT));\n  if (!IsNegative) {\n    SDValue Add = DAG.getNode(ISD::ADD, dl, VT, Op, Shift);\n    Result = DAG.getNode(ISD::XOR, dl, VT, Add, Shift);\n  } else {\n    // 0 - abs(x) -> Y = sra (X, size(X)-1); sub (Y, xor (X, Y))\n    SDValue Xor = DAG.getNode(ISD::XOR, dl, VT, Op, Shift);\n    Result = DAG.getNode(ISD::SUB, dl, VT, Shift, Xor);\n  }\n  return true;\n}\n\nSDValue TargetLowering::expandBSWAP(SDNode *N, SelectionDAG &DAG) const {\n  SDLoc dl(N);\n  EVT VT = N->getValueType(0);\n  SDValue Op = N->getOperand(0);\n\n  if (!VT.isSimple())\n    return SDValue();\n\n  EVT SHVT = getShiftAmountTy(VT, DAG.getDataLayout());\n  SDValue Tmp1, Tmp2, Tmp3, Tmp4, Tmp5, Tmp6, Tmp7, Tmp8;\n  switch (VT.getSimpleVT().getScalarType().SimpleTy) {\n  default:\n    return SDValue();\n  case MVT::i16:\n    // Use a rotate by 8. This can be further expanded if necessary.\n    return DAG.getNode(ISD::ROTL, dl, VT, Op, DAG.getConstant(8, dl, SHVT));\n  case MVT::i32:\n    Tmp4 = DAG.getNode(ISD::SHL, dl, VT, Op, DAG.getConstant(24, dl, SHVT));\n    Tmp3 = DAG.getNode(ISD::SHL, dl, VT, Op, DAG.getConstant(8, dl, SHVT));\n    Tmp2 = DAG.getNode(ISD::SRL, dl, VT, Op, DAG.getConstant(8, dl, SHVT));\n    Tmp1 = DAG.getNode(ISD::SRL, dl, VT, Op, DAG.getConstant(24, dl, SHVT));\n    Tmp3 = DAG.getNode(ISD::AND, dl, VT, Tmp3,\n                       DAG.getConstant(0xFF0000, dl, VT));\n    Tmp2 = DAG.getNode(ISD::AND, dl, VT, Tmp2, DAG.getConstant(0xFF00, dl, VT));\n    Tmp4 = DAG.getNode(ISD::OR, dl, VT, Tmp4, Tmp3);\n    Tmp2 = DAG.getNode(ISD::OR, dl, VT, Tmp2, Tmp1);\n    return DAG.getNode(ISD::OR, dl, VT, Tmp4, Tmp2);\n  case MVT::i64:\n    Tmp8 = DAG.getNode(ISD::SHL, dl, VT, Op, DAG.getConstant(56, dl, SHVT));\n    Tmp7 = DAG.getNode(ISD::SHL, dl, VT, Op, DAG.getConstant(40, dl, SHVT));\n    Tmp6 = DAG.getNode(ISD::SHL, dl, VT, Op, DAG.getConstant(24, dl, SHVT));\n    Tmp5 = DAG.getNode(ISD::SHL, dl, VT, Op, DAG.getConstant(8, dl, SHVT));\n    Tmp4 = DAG.getNode(ISD::SRL, dl, VT, Op, DAG.getConstant(8, dl, SHVT));\n    Tmp3 = DAG.getNode(ISD::SRL, dl, VT, Op, DAG.getConstant(24, dl, SHVT));\n    Tmp2 = DAG.getNode(ISD::SRL, dl, VT, Op, DAG.getConstant(40, dl, SHVT));\n    Tmp1 = DAG.getNode(ISD::SRL, dl, VT, Op, DAG.getConstant(56, dl, SHVT));\n    Tmp7 = DAG.getNode(ISD::AND, dl, VT, Tmp7,\n                       DAG.getConstant(255ULL<<48, dl, VT));\n    Tmp6 = DAG.getNode(ISD::AND, dl, VT, Tmp6,\n                       DAG.getConstant(255ULL<<40, dl, VT));\n    Tmp5 = DAG.getNode(ISD::AND, dl, VT, Tmp5,\n                       DAG.getConstant(255ULL<<32, dl, VT));\n    Tmp4 = DAG.getNode(ISD::AND, dl, VT, Tmp4,\n                       DAG.getConstant(255ULL<<24, dl, VT));\n    Tmp3 = DAG.getNode(ISD::AND, dl, VT, Tmp3,\n                       DAG.getConstant(255ULL<<16, dl, VT));\n    Tmp2 = DAG.getNode(ISD::AND, dl, VT, Tmp2,\n                       DAG.getConstant(255ULL<<8 , dl, VT));\n    Tmp8 = DAG.getNode(ISD::OR, dl, VT, Tmp8, Tmp7);\n    Tmp6 = DAG.getNode(ISD::OR, dl, VT, Tmp6, Tmp5);\n    Tmp4 = DAG.getNode(ISD::OR, dl, VT, Tmp4, Tmp3);\n    Tmp2 = DAG.getNode(ISD::OR, dl, VT, Tmp2, Tmp1);\n    Tmp8 = DAG.getNode(ISD::OR, dl, VT, Tmp8, Tmp6);\n    Tmp4 = DAG.getNode(ISD::OR, dl, VT, Tmp4, Tmp2);\n    return DAG.getNode(ISD::OR, dl, VT, Tmp8, Tmp4);\n  }\n}\n\nstd::pair<SDValue, SDValue>\nTargetLowering::scalarizeVectorLoad(LoadSDNode *LD,\n                                    SelectionDAG &DAG) const {\n  SDLoc SL(LD);\n  SDValue Chain = LD->getChain();\n  SDValue BasePTR = LD->getBasePtr();\n  EVT SrcVT = LD->getMemoryVT();\n  EVT DstVT = LD->getValueType(0);\n  ISD::LoadExtType ExtType = LD->getExtensionType();\n\n  if (SrcVT.isScalableVector())\n    report_fatal_error(\"Cannot scalarize scalable vector loads\");\n\n  unsigned NumElem = SrcVT.getVectorNumElements();\n\n  EVT SrcEltVT = SrcVT.getScalarType();\n  EVT DstEltVT = DstVT.getScalarType();\n\n  // A vector must always be stored in memory as-is, i.e. without any padding\n  // between the elements, since various code depend on it, e.g. in the\n  // handling of a bitcast of a vector type to int, which may be done with a\n  // vector store followed by an integer load. A vector that does not have\n  // elements that are byte-sized must therefore be stored as an integer\n  // built out of the extracted vector elements.\n  if (!SrcEltVT.isByteSized()) {\n    unsigned NumLoadBits = SrcVT.getStoreSizeInBits();\n    EVT LoadVT = EVT::getIntegerVT(*DAG.getContext(), NumLoadBits);\n\n    unsigned NumSrcBits = SrcVT.getSizeInBits();\n    EVT SrcIntVT = EVT::getIntegerVT(*DAG.getContext(), NumSrcBits);\n\n    unsigned SrcEltBits = SrcEltVT.getSizeInBits();\n    SDValue SrcEltBitMask = DAG.getConstant(\n        APInt::getLowBitsSet(NumLoadBits, SrcEltBits), SL, LoadVT);\n\n    // Load the whole vector and avoid masking off the top bits as it makes\n    // the codegen worse.\n    SDValue Load =\n        DAG.getExtLoad(ISD::EXTLOAD, SL, LoadVT, Chain, BasePTR,\n                       LD->getPointerInfo(), SrcIntVT, LD->getOriginalAlign(),\n                       LD->getMemOperand()->getFlags(), LD->getAAInfo());\n\n    SmallVector<SDValue, 8> Vals;\n    for (unsigned Idx = 0; Idx < NumElem; ++Idx) {\n      unsigned ShiftIntoIdx =\n          (DAG.getDataLayout().isBigEndian() ? (NumElem - 1) - Idx : Idx);\n      SDValue ShiftAmount =\n          DAG.getShiftAmountConstant(ShiftIntoIdx * SrcEltVT.getSizeInBits(),\n                                     LoadVT, SL, /*LegalTypes=*/false);\n      SDValue ShiftedElt = DAG.getNode(ISD::SRL, SL, LoadVT, Load, ShiftAmount);\n      SDValue Elt =\n          DAG.getNode(ISD::AND, SL, LoadVT, ShiftedElt, SrcEltBitMask);\n      SDValue Scalar = DAG.getNode(ISD::TRUNCATE, SL, SrcEltVT, Elt);\n\n      if (ExtType != ISD::NON_EXTLOAD) {\n        unsigned ExtendOp = ISD::getExtForLoadExtType(false, ExtType);\n        Scalar = DAG.getNode(ExtendOp, SL, DstEltVT, Scalar);\n      }\n\n      Vals.push_back(Scalar);\n    }\n\n    SDValue Value = DAG.getBuildVector(DstVT, SL, Vals);\n    return std::make_pair(Value, Load.getValue(1));\n  }\n\n  unsigned Stride = SrcEltVT.getSizeInBits() / 8;\n  assert(SrcEltVT.isByteSized());\n\n  SmallVector<SDValue, 8> Vals;\n  SmallVector<SDValue, 8> LoadChains;\n\n  for (unsigned Idx = 0; Idx < NumElem; ++Idx) {\n    SDValue ScalarLoad =\n        DAG.getExtLoad(ExtType, SL, DstEltVT, Chain, BasePTR,\n                       LD->getPointerInfo().getWithOffset(Idx * Stride),\n                       SrcEltVT, LD->getOriginalAlign(),\n                       LD->getMemOperand()->getFlags(), LD->getAAInfo());\n\n    BasePTR = DAG.getObjectPtrOffset(SL, BasePTR, TypeSize::Fixed(Stride));\n\n    Vals.push_back(ScalarLoad.getValue(0));\n    LoadChains.push_back(ScalarLoad.getValue(1));\n  }\n\n  SDValue NewChain = DAG.getNode(ISD::TokenFactor, SL, MVT::Other, LoadChains);\n  SDValue Value = DAG.getBuildVector(DstVT, SL, Vals);\n\n  return std::make_pair(Value, NewChain);\n}\n\nSDValue TargetLowering::scalarizeVectorStore(StoreSDNode *ST,\n                                             SelectionDAG &DAG) const {\n  SDLoc SL(ST);\n\n  SDValue Chain = ST->getChain();\n  SDValue BasePtr = ST->getBasePtr();\n  SDValue Value = ST->getValue();\n  EVT StVT = ST->getMemoryVT();\n\n  if (StVT.isScalableVector())\n    report_fatal_error(\"Cannot scalarize scalable vector stores\");\n\n  // The type of the data we want to save\n  EVT RegVT = Value.getValueType();\n  EVT RegSclVT = RegVT.getScalarType();\n\n  // The type of data as saved in memory.\n  EVT MemSclVT = StVT.getScalarType();\n\n  unsigned NumElem = StVT.getVectorNumElements();\n\n  // A vector must always be stored in memory as-is, i.e. without any padding\n  // between the elements, since various code depend on it, e.g. in the\n  // handling of a bitcast of a vector type to int, which may be done with a\n  // vector store followed by an integer load. A vector that does not have\n  // elements that are byte-sized must therefore be stored as an integer\n  // built out of the extracted vector elements.\n  if (!MemSclVT.isByteSized()) {\n    unsigned NumBits = StVT.getSizeInBits();\n    EVT IntVT = EVT::getIntegerVT(*DAG.getContext(), NumBits);\n\n    SDValue CurrVal = DAG.getConstant(0, SL, IntVT);\n\n    for (unsigned Idx = 0; Idx < NumElem; ++Idx) {\n      SDValue Elt = DAG.getNode(ISD::EXTRACT_VECTOR_ELT, SL, RegSclVT, Value,\n                                DAG.getVectorIdxConstant(Idx, SL));\n      SDValue Trunc = DAG.getNode(ISD::TRUNCATE, SL, MemSclVT, Elt);\n      SDValue ExtElt = DAG.getNode(ISD::ZERO_EXTEND, SL, IntVT, Trunc);\n      unsigned ShiftIntoIdx =\n          (DAG.getDataLayout().isBigEndian() ? (NumElem - 1) - Idx : Idx);\n      SDValue ShiftAmount =\n          DAG.getConstant(ShiftIntoIdx * MemSclVT.getSizeInBits(), SL, IntVT);\n      SDValue ShiftedElt =\n          DAG.getNode(ISD::SHL, SL, IntVT, ExtElt, ShiftAmount);\n      CurrVal = DAG.getNode(ISD::OR, SL, IntVT, CurrVal, ShiftedElt);\n    }\n\n    return DAG.getStore(Chain, SL, CurrVal, BasePtr, ST->getPointerInfo(),\n                        ST->getOriginalAlign(), ST->getMemOperand()->getFlags(),\n                        ST->getAAInfo());\n  }\n\n  // Store Stride in bytes\n  unsigned Stride = MemSclVT.getSizeInBits() / 8;\n  assert(Stride && \"Zero stride!\");\n  // Extract each of the elements from the original vector and save them into\n  // memory individually.\n  SmallVector<SDValue, 8> Stores;\n  for (unsigned Idx = 0; Idx < NumElem; ++Idx) {\n    SDValue Elt = DAG.getNode(ISD::EXTRACT_VECTOR_ELT, SL, RegSclVT, Value,\n                              DAG.getVectorIdxConstant(Idx, SL));\n\n    SDValue Ptr =\n        DAG.getObjectPtrOffset(SL, BasePtr, TypeSize::Fixed(Idx * Stride));\n\n    // This scalar TruncStore may be illegal, but we legalize it later.\n    SDValue Store = DAG.getTruncStore(\n        Chain, SL, Elt, Ptr, ST->getPointerInfo().getWithOffset(Idx * Stride),\n        MemSclVT, ST->getOriginalAlign(), ST->getMemOperand()->getFlags(),\n        ST->getAAInfo());\n\n    Stores.push_back(Store);\n  }\n\n  return DAG.getNode(ISD::TokenFactor, SL, MVT::Other, Stores);\n}\n\nstd::pair<SDValue, SDValue>\nTargetLowering::expandUnalignedLoad(LoadSDNode *LD, SelectionDAG &DAG) const {\n  assert(LD->getAddressingMode() == ISD::UNINDEXED &&\n         \"unaligned indexed loads not implemented!\");\n  SDValue Chain = LD->getChain();\n  SDValue Ptr = LD->getBasePtr();\n  EVT VT = LD->getValueType(0);\n  EVT LoadedVT = LD->getMemoryVT();\n  SDLoc dl(LD);\n  auto &MF = DAG.getMachineFunction();\n\n  if (VT.isFloatingPoint() || VT.isVector()) {\n    EVT intVT = EVT::getIntegerVT(*DAG.getContext(), LoadedVT.getSizeInBits());\n    if (isTypeLegal(intVT) && isTypeLegal(LoadedVT)) {\n      if (!isOperationLegalOrCustom(ISD::LOAD, intVT) &&\n          LoadedVT.isVector()) {\n        // Scalarize the load and let the individual components be handled.\n        return scalarizeVectorLoad(LD, DAG);\n      }\n\n      // Expand to a (misaligned) integer load of the same size,\n      // then bitconvert to floating point or vector.\n      SDValue newLoad = DAG.getLoad(intVT, dl, Chain, Ptr,\n                                    LD->getMemOperand());\n      SDValue Result = DAG.getNode(ISD::BITCAST, dl, LoadedVT, newLoad);\n      if (LoadedVT != VT)\n        Result = DAG.getNode(VT.isFloatingPoint() ? ISD::FP_EXTEND :\n                             ISD::ANY_EXTEND, dl, VT, Result);\n\n      return std::make_pair(Result, newLoad.getValue(1));\n    }\n\n    // Copy the value to a (aligned) stack slot using (unaligned) integer\n    // loads and stores, then do a (aligned) load from the stack slot.\n    MVT RegVT = getRegisterType(*DAG.getContext(), intVT);\n    unsigned LoadedBytes = LoadedVT.getStoreSize();\n    unsigned RegBytes = RegVT.getSizeInBits() / 8;\n    unsigned NumRegs = (LoadedBytes + RegBytes - 1) / RegBytes;\n\n    // Make sure the stack slot is also aligned for the register type.\n    SDValue StackBase = DAG.CreateStackTemporary(LoadedVT, RegVT);\n    auto FrameIndex = cast<FrameIndexSDNode>(StackBase.getNode())->getIndex();\n    SmallVector<SDValue, 8> Stores;\n    SDValue StackPtr = StackBase;\n    unsigned Offset = 0;\n\n    EVT PtrVT = Ptr.getValueType();\n    EVT StackPtrVT = StackPtr.getValueType();\n\n    SDValue PtrIncrement = DAG.getConstant(RegBytes, dl, PtrVT);\n    SDValue StackPtrIncrement = DAG.getConstant(RegBytes, dl, StackPtrVT);\n\n    // Do all but one copies using the full register width.\n    for (unsigned i = 1; i < NumRegs; i++) {\n      // Load one integer register's worth from the original location.\n      SDValue Load = DAG.getLoad(\n          RegVT, dl, Chain, Ptr, LD->getPointerInfo().getWithOffset(Offset),\n          LD->getOriginalAlign(), LD->getMemOperand()->getFlags(),\n          LD->getAAInfo());\n      // Follow the load with a store to the stack slot.  Remember the store.\n      Stores.push_back(DAG.getStore(\n          Load.getValue(1), dl, Load, StackPtr,\n          MachinePointerInfo::getFixedStack(MF, FrameIndex, Offset)));\n      // Increment the pointers.\n      Offset += RegBytes;\n\n      Ptr = DAG.getObjectPtrOffset(dl, Ptr, PtrIncrement);\n      StackPtr = DAG.getObjectPtrOffset(dl, StackPtr, StackPtrIncrement);\n    }\n\n    // The last copy may be partial.  Do an extending load.\n    EVT MemVT = EVT::getIntegerVT(*DAG.getContext(),\n                                  8 * (LoadedBytes - Offset));\n    SDValue Load =\n        DAG.getExtLoad(ISD::EXTLOAD, dl, RegVT, Chain, Ptr,\n                       LD->getPointerInfo().getWithOffset(Offset), MemVT,\n                       LD->getOriginalAlign(), LD->getMemOperand()->getFlags(),\n                       LD->getAAInfo());\n    // Follow the load with a store to the stack slot.  Remember the store.\n    // On big-endian machines this requires a truncating store to ensure\n    // that the bits end up in the right place.\n    Stores.push_back(DAG.getTruncStore(\n        Load.getValue(1), dl, Load, StackPtr,\n        MachinePointerInfo::getFixedStack(MF, FrameIndex, Offset), MemVT));\n\n    // The order of the stores doesn't matter - say it with a TokenFactor.\n    SDValue TF = DAG.getNode(ISD::TokenFactor, dl, MVT::Other, Stores);\n\n    // Finally, perform the original load only redirected to the stack slot.\n    Load = DAG.getExtLoad(LD->getExtensionType(), dl, VT, TF, StackBase,\n                          MachinePointerInfo::getFixedStack(MF, FrameIndex, 0),\n                          LoadedVT);\n\n    // Callers expect a MERGE_VALUES node.\n    return std::make_pair(Load, TF);\n  }\n\n  assert(LoadedVT.isInteger() && !LoadedVT.isVector() &&\n         \"Unaligned load of unsupported type.\");\n\n  // Compute the new VT that is half the size of the old one.  This is an\n  // integer MVT.\n  unsigned NumBits = LoadedVT.getSizeInBits();\n  EVT NewLoadedVT;\n  NewLoadedVT = EVT::getIntegerVT(*DAG.getContext(), NumBits/2);\n  NumBits >>= 1;\n\n  Align Alignment = LD->getOriginalAlign();\n  unsigned IncrementSize = NumBits / 8;\n  ISD::LoadExtType HiExtType = LD->getExtensionType();\n\n  // If the original load is NON_EXTLOAD, the hi part load must be ZEXTLOAD.\n  if (HiExtType == ISD::NON_EXTLOAD)\n    HiExtType = ISD::ZEXTLOAD;\n\n  // Load the value in two parts\n  SDValue Lo, Hi;\n  if (DAG.getDataLayout().isLittleEndian()) {\n    Lo = DAG.getExtLoad(ISD::ZEXTLOAD, dl, VT, Chain, Ptr, LD->getPointerInfo(),\n                        NewLoadedVT, Alignment, LD->getMemOperand()->getFlags(),\n                        LD->getAAInfo());\n\n    Ptr = DAG.getObjectPtrOffset(dl, Ptr, TypeSize::Fixed(IncrementSize));\n    Hi = DAG.getExtLoad(HiExtType, dl, VT, Chain, Ptr,\n                        LD->getPointerInfo().getWithOffset(IncrementSize),\n                        NewLoadedVT, Alignment, LD->getMemOperand()->getFlags(),\n                        LD->getAAInfo());\n  } else {\n    Hi = DAG.getExtLoad(HiExtType, dl, VT, Chain, Ptr, LD->getPointerInfo(),\n                        NewLoadedVT, Alignment, LD->getMemOperand()->getFlags(),\n                        LD->getAAInfo());\n\n    Ptr = DAG.getObjectPtrOffset(dl, Ptr, TypeSize::Fixed(IncrementSize));\n    Lo = DAG.getExtLoad(ISD::ZEXTLOAD, dl, VT, Chain, Ptr,\n                        LD->getPointerInfo().getWithOffset(IncrementSize),\n                        NewLoadedVT, Alignment, LD->getMemOperand()->getFlags(),\n                        LD->getAAInfo());\n  }\n\n  // aggregate the two parts\n  SDValue ShiftAmount =\n      DAG.getConstant(NumBits, dl, getShiftAmountTy(Hi.getValueType(),\n                                                    DAG.getDataLayout()));\n  SDValue Result = DAG.getNode(ISD::SHL, dl, VT, Hi, ShiftAmount);\n  Result = DAG.getNode(ISD::OR, dl, VT, Result, Lo);\n\n  SDValue TF = DAG.getNode(ISD::TokenFactor, dl, MVT::Other, Lo.getValue(1),\n                             Hi.getValue(1));\n\n  return std::make_pair(Result, TF);\n}\n\nSDValue TargetLowering::expandUnalignedStore(StoreSDNode *ST,\n                                             SelectionDAG &DAG) const {\n  assert(ST->getAddressingMode() == ISD::UNINDEXED &&\n         \"unaligned indexed stores not implemented!\");\n  SDValue Chain = ST->getChain();\n  SDValue Ptr = ST->getBasePtr();\n  SDValue Val = ST->getValue();\n  EVT VT = Val.getValueType();\n  Align Alignment = ST->getOriginalAlign();\n  auto &MF = DAG.getMachineFunction();\n  EVT StoreMemVT = ST->getMemoryVT();\n\n  SDLoc dl(ST);\n  if (StoreMemVT.isFloatingPoint() || StoreMemVT.isVector()) {\n    EVT intVT = EVT::getIntegerVT(*DAG.getContext(), VT.getSizeInBits());\n    if (isTypeLegal(intVT)) {\n      if (!isOperationLegalOrCustom(ISD::STORE, intVT) &&\n          StoreMemVT.isVector()) {\n        // Scalarize the store and let the individual components be handled.\n        SDValue Result = scalarizeVectorStore(ST, DAG);\n        return Result;\n      }\n      // Expand to a bitconvert of the value to the integer type of the\n      // same size, then a (misaligned) int store.\n      // FIXME: Does not handle truncating floating point stores!\n      SDValue Result = DAG.getNode(ISD::BITCAST, dl, intVT, Val);\n      Result = DAG.getStore(Chain, dl, Result, Ptr, ST->getPointerInfo(),\n                            Alignment, ST->getMemOperand()->getFlags());\n      return Result;\n    }\n    // Do a (aligned) store to a stack slot, then copy from the stack slot\n    // to the final destination using (unaligned) integer loads and stores.\n    MVT RegVT = getRegisterType(\n        *DAG.getContext(),\n        EVT::getIntegerVT(*DAG.getContext(), StoreMemVT.getSizeInBits()));\n    EVT PtrVT = Ptr.getValueType();\n    unsigned StoredBytes = StoreMemVT.getStoreSize();\n    unsigned RegBytes = RegVT.getSizeInBits() / 8;\n    unsigned NumRegs = (StoredBytes + RegBytes - 1) / RegBytes;\n\n    // Make sure the stack slot is also aligned for the register type.\n    SDValue StackPtr = DAG.CreateStackTemporary(StoreMemVT, RegVT);\n    auto FrameIndex = cast<FrameIndexSDNode>(StackPtr.getNode())->getIndex();\n\n    // Perform the original store, only redirected to the stack slot.\n    SDValue Store = DAG.getTruncStore(\n        Chain, dl, Val, StackPtr,\n        MachinePointerInfo::getFixedStack(MF, FrameIndex, 0), StoreMemVT);\n\n    EVT StackPtrVT = StackPtr.getValueType();\n\n    SDValue PtrIncrement = DAG.getConstant(RegBytes, dl, PtrVT);\n    SDValue StackPtrIncrement = DAG.getConstant(RegBytes, dl, StackPtrVT);\n    SmallVector<SDValue, 8> Stores;\n    unsigned Offset = 0;\n\n    // Do all but one copies using the full register width.\n    for (unsigned i = 1; i < NumRegs; i++) {\n      // Load one integer register's worth from the stack slot.\n      SDValue Load = DAG.getLoad(\n          RegVT, dl, Store, StackPtr,\n          MachinePointerInfo::getFixedStack(MF, FrameIndex, Offset));\n      // Store it to the final location.  Remember the store.\n      Stores.push_back(DAG.getStore(Load.getValue(1), dl, Load, Ptr,\n                                    ST->getPointerInfo().getWithOffset(Offset),\n                                    ST->getOriginalAlign(),\n                                    ST->getMemOperand()->getFlags()));\n      // Increment the pointers.\n      Offset += RegBytes;\n      StackPtr = DAG.getObjectPtrOffset(dl, StackPtr, StackPtrIncrement);\n      Ptr = DAG.getObjectPtrOffset(dl, Ptr, PtrIncrement);\n    }\n\n    // The last store may be partial.  Do a truncating store.  On big-endian\n    // machines this requires an extending load from the stack slot to ensure\n    // that the bits are in the right place.\n    EVT LoadMemVT =\n        EVT::getIntegerVT(*DAG.getContext(), 8 * (StoredBytes - Offset));\n\n    // Load from the stack slot.\n    SDValue Load = DAG.getExtLoad(\n        ISD::EXTLOAD, dl, RegVT, Store, StackPtr,\n        MachinePointerInfo::getFixedStack(MF, FrameIndex, Offset), LoadMemVT);\n\n    Stores.push_back(\n        DAG.getTruncStore(Load.getValue(1), dl, Load, Ptr,\n                          ST->getPointerInfo().getWithOffset(Offset), LoadMemVT,\n                          ST->getOriginalAlign(),\n                          ST->getMemOperand()->getFlags(), ST->getAAInfo()));\n    // The order of the stores doesn't matter - say it with a TokenFactor.\n    SDValue Result = DAG.getNode(ISD::TokenFactor, dl, MVT::Other, Stores);\n    return Result;\n  }\n\n  assert(StoreMemVT.isInteger() && !StoreMemVT.isVector() &&\n         \"Unaligned store of unknown type.\");\n  // Get the half-size VT\n  EVT NewStoredVT = StoreMemVT.getHalfSizedIntegerVT(*DAG.getContext());\n  unsigned NumBits = NewStoredVT.getFixedSizeInBits();\n  unsigned IncrementSize = NumBits / 8;\n\n  // Divide the stored value in two parts.\n  SDValue ShiftAmount = DAG.getConstant(\n      NumBits, dl, getShiftAmountTy(Val.getValueType(), DAG.getDataLayout()));\n  SDValue Lo = Val;\n  SDValue Hi = DAG.getNode(ISD::SRL, dl, VT, Val, ShiftAmount);\n\n  // Store the two parts\n  SDValue Store1, Store2;\n  Store1 = DAG.getTruncStore(Chain, dl,\n                             DAG.getDataLayout().isLittleEndian() ? Lo : Hi,\n                             Ptr, ST->getPointerInfo(), NewStoredVT, Alignment,\n                             ST->getMemOperand()->getFlags());\n\n  Ptr = DAG.getObjectPtrOffset(dl, Ptr, TypeSize::Fixed(IncrementSize));\n  Store2 = DAG.getTruncStore(\n      Chain, dl, DAG.getDataLayout().isLittleEndian() ? Hi : Lo, Ptr,\n      ST->getPointerInfo().getWithOffset(IncrementSize), NewStoredVT, Alignment,\n      ST->getMemOperand()->getFlags(), ST->getAAInfo());\n\n  SDValue Result =\n      DAG.getNode(ISD::TokenFactor, dl, MVT::Other, Store1, Store2);\n  return Result;\n}\n\nSDValue\nTargetLowering::IncrementMemoryAddress(SDValue Addr, SDValue Mask,\n                                       const SDLoc &DL, EVT DataVT,\n                                       SelectionDAG &DAG,\n                                       bool IsCompressedMemory) const {\n  SDValue Increment;\n  EVT AddrVT = Addr.getValueType();\n  EVT MaskVT = Mask.getValueType();\n  assert(DataVT.getVectorElementCount() == MaskVT.getVectorElementCount() &&\n         \"Incompatible types of Data and Mask\");\n  if (IsCompressedMemory) {\n    if (DataVT.isScalableVector())\n      report_fatal_error(\n          \"Cannot currently handle compressed memory with scalable vectors\");\n    // Incrementing the pointer according to number of '1's in the mask.\n    EVT MaskIntVT = EVT::getIntegerVT(*DAG.getContext(), MaskVT.getSizeInBits());\n    SDValue MaskInIntReg = DAG.getBitcast(MaskIntVT, Mask);\n    if (MaskIntVT.getSizeInBits() < 32) {\n      MaskInIntReg = DAG.getNode(ISD::ZERO_EXTEND, DL, MVT::i32, MaskInIntReg);\n      MaskIntVT = MVT::i32;\n    }\n\n    // Count '1's with POPCNT.\n    Increment = DAG.getNode(ISD::CTPOP, DL, MaskIntVT, MaskInIntReg);\n    Increment = DAG.getZExtOrTrunc(Increment, DL, AddrVT);\n    // Scale is an element size in bytes.\n    SDValue Scale = DAG.getConstant(DataVT.getScalarSizeInBits() / 8, DL,\n                                    AddrVT);\n    Increment = DAG.getNode(ISD::MUL, DL, AddrVT, Increment, Scale);\n  } else if (DataVT.isScalableVector()) {\n    Increment = DAG.getVScale(DL, AddrVT,\n                              APInt(AddrVT.getFixedSizeInBits(),\n                                    DataVT.getStoreSize().getKnownMinSize()));\n  } else\n    Increment = DAG.getConstant(DataVT.getStoreSize(), DL, AddrVT);\n\n  return DAG.getNode(ISD::ADD, DL, AddrVT, Addr, Increment);\n}\n\nstatic SDValue clampDynamicVectorIndex(SelectionDAG &DAG,\n                                       SDValue Idx,\n                                       EVT VecVT,\n                                       const SDLoc &dl) {\n  if (!VecVT.isScalableVector() && isa<ConstantSDNode>(Idx))\n    return Idx;\n\n  EVT IdxVT = Idx.getValueType();\n  unsigned NElts = VecVT.getVectorMinNumElements();\n  if (VecVT.isScalableVector()) {\n    SDValue VS = DAG.getVScale(dl, IdxVT,\n                               APInt(IdxVT.getFixedSizeInBits(),\n                                     NElts));\n    SDValue Sub = DAG.getNode(ISD::SUB, dl, IdxVT, VS,\n                              DAG.getConstant(1, dl, IdxVT));\n\n    return DAG.getNode(ISD::UMIN, dl, IdxVT, Idx, Sub);\n  } else {\n    if (isPowerOf2_32(NElts)) {\n      APInt Imm = APInt::getLowBitsSet(IdxVT.getSizeInBits(),\n                                       Log2_32(NElts));\n      return DAG.getNode(ISD::AND, dl, IdxVT, Idx,\n                         DAG.getConstant(Imm, dl, IdxVT));\n    }\n  }\n\n  return DAG.getNode(ISD::UMIN, dl, IdxVT, Idx,\n                     DAG.getConstant(NElts - 1, dl, IdxVT));\n}\n\nSDValue TargetLowering::getVectorElementPointer(SelectionDAG &DAG,\n                                                SDValue VecPtr, EVT VecVT,\n                                                SDValue Index) const {\n  SDLoc dl(Index);\n  // Make sure the index type is big enough to compute in.\n  Index = DAG.getZExtOrTrunc(Index, dl, VecPtr.getValueType());\n\n  EVT EltVT = VecVT.getVectorElementType();\n\n  // Calculate the element offset and add it to the pointer.\n  unsigned EltSize = EltVT.getFixedSizeInBits() / 8; // FIXME: should be ABI size.\n  assert(EltSize * 8 == EltVT.getFixedSizeInBits() &&\n         \"Converting bits to bytes lost precision\");\n\n  Index = clampDynamicVectorIndex(DAG, Index, VecVT, dl);\n\n  EVT IdxVT = Index.getValueType();\n\n  Index = DAG.getNode(ISD::MUL, dl, IdxVT, Index,\n                      DAG.getConstant(EltSize, dl, IdxVT));\n  return DAG.getMemBasePlusOffset(VecPtr, Index, dl);\n}\n\n//===----------------------------------------------------------------------===//\n// Implementation of Emulated TLS Model\n//===----------------------------------------------------------------------===//\n\nSDValue TargetLowering::LowerToTLSEmulatedModel(const GlobalAddressSDNode *GA,\n                                                SelectionDAG &DAG) const {\n  // Access to address of TLS varialbe xyz is lowered to a function call:\n  //   __emutls_get_address( address of global variable named \"__emutls_v.xyz\" )\n  EVT PtrVT = getPointerTy(DAG.getDataLayout());\n  PointerType *VoidPtrType = Type::getInt8PtrTy(*DAG.getContext());\n  SDLoc dl(GA);\n\n  ArgListTy Args;\n  ArgListEntry Entry;\n  std::string NameString = (\"__emutls_v.\" + GA->getGlobal()->getName()).str();\n  Module *VariableModule = const_cast<Module*>(GA->getGlobal()->getParent());\n  StringRef EmuTlsVarName(NameString);\n  GlobalVariable *EmuTlsVar = VariableModule->getNamedGlobal(EmuTlsVarName);\n  assert(EmuTlsVar && \"Cannot find EmuTlsVar \");\n  Entry.Node = DAG.getGlobalAddress(EmuTlsVar, dl, PtrVT);\n  Entry.Ty = VoidPtrType;\n  Args.push_back(Entry);\n\n  SDValue EmuTlsGetAddr = DAG.getExternalSymbol(\"__emutls_get_address\", PtrVT);\n\n  TargetLowering::CallLoweringInfo CLI(DAG);\n  CLI.setDebugLoc(dl).setChain(DAG.getEntryNode());\n  CLI.setLibCallee(CallingConv::C, VoidPtrType, EmuTlsGetAddr, std::move(Args));\n  std::pair<SDValue, SDValue> CallResult = LowerCallTo(CLI);\n\n  // TLSADDR will be codegen'ed as call. Inform MFI that function has calls.\n  // At last for X86 targets, maybe good for other targets too?\n  MachineFrameInfo &MFI = DAG.getMachineFunction().getFrameInfo();\n  MFI.setAdjustsStack(true); // Is this only for X86 target?\n  MFI.setHasCalls(true);\n\n  assert((GA->getOffset() == 0) &&\n         \"Emulated TLS must have zero offset in GlobalAddressSDNode\");\n  return CallResult.first;\n}\n\nSDValue TargetLowering::lowerCmpEqZeroToCtlzSrl(SDValue Op,\n                                                SelectionDAG &DAG) const {\n  assert((Op->getOpcode() == ISD::SETCC) && \"Input has to be a SETCC node.\");\n  if (!isCtlzFast())\n    return SDValue();\n  ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(2))->get();\n  SDLoc dl(Op);\n  if (ConstantSDNode *C = dyn_cast<ConstantSDNode>(Op.getOperand(1))) {\n    if (C->isNullValue() && CC == ISD::SETEQ) {\n      EVT VT = Op.getOperand(0).getValueType();\n      SDValue Zext = Op.getOperand(0);\n      if (VT.bitsLT(MVT::i32)) {\n        VT = MVT::i32;\n        Zext = DAG.getNode(ISD::ZERO_EXTEND, dl, VT, Op.getOperand(0));\n      }\n      unsigned Log2b = Log2_32(VT.getSizeInBits());\n      SDValue Clz = DAG.getNode(ISD::CTLZ, dl, VT, Zext);\n      SDValue Scc = DAG.getNode(ISD::SRL, dl, VT, Clz,\n                                DAG.getConstant(Log2b, dl, MVT::i32));\n      return DAG.getNode(ISD::TRUNCATE, dl, MVT::i32, Scc);\n    }\n  }\n  return SDValue();\n}\n\n// Convert redundant addressing modes (e.g. scaling is redundant\n// when accessing bytes).\nISD::MemIndexType\nTargetLowering::getCanonicalIndexType(ISD::MemIndexType IndexType, EVT MemVT,\n                                      SDValue Offsets) const {\n  bool IsScaledIndex =\n      (IndexType == ISD::SIGNED_SCALED) || (IndexType == ISD::UNSIGNED_SCALED);\n  bool IsSignedIndex =\n      (IndexType == ISD::SIGNED_SCALED) || (IndexType == ISD::SIGNED_UNSCALED);\n\n  // Scaling is unimportant for bytes, canonicalize to unscaled.\n  if (IsScaledIndex && MemVT.getScalarType() == MVT::i8) {\n    IsScaledIndex = false;\n    IndexType = IsSignedIndex ? ISD::SIGNED_UNSCALED : ISD::UNSIGNED_UNSCALED;\n  }\n\n  return IndexType;\n}\n\nSDValue TargetLowering::expandIntMINMAX(SDNode *Node, SelectionDAG &DAG) const {\n  SDValue Op0 = Node->getOperand(0);\n  SDValue Op1 = Node->getOperand(1);\n  EVT VT = Op0.getValueType();\n  unsigned Opcode = Node->getOpcode();\n  SDLoc DL(Node);\n\n  // umin(x,y) -> sub(x,usubsat(x,y))\n  if (Opcode == ISD::UMIN && isOperationLegal(ISD::SUB, VT) &&\n      isOperationLegal(ISD::USUBSAT, VT)) {\n    return DAG.getNode(ISD::SUB, DL, VT, Op0,\n                       DAG.getNode(ISD::USUBSAT, DL, VT, Op0, Op1));\n  }\n\n  // umax(x,y) -> add(x,usubsat(y,x))\n  if (Opcode == ISD::UMAX && isOperationLegal(ISD::ADD, VT) &&\n      isOperationLegal(ISD::USUBSAT, VT)) {\n    return DAG.getNode(ISD::ADD, DL, VT, Op0,\n                       DAG.getNode(ISD::USUBSAT, DL, VT, Op1, Op0));\n  }\n\n  // Expand Y = MAX(A, B) -> Y = (A > B) ? A : B\n  ISD::CondCode CC;\n  switch (Opcode) {\n  default: llvm_unreachable(\"How did we get here?\");\n  case ISD::SMAX: CC = ISD::SETGT; break;\n  case ISD::SMIN: CC = ISD::SETLT; break;\n  case ISD::UMAX: CC = ISD::SETUGT; break;\n  case ISD::UMIN: CC = ISD::SETULT; break;\n  }\n\n  // FIXME: Should really try to split the vector in case it's legal on a\n  // subvector.\n  if (VT.isVector() && !isOperationLegalOrCustom(ISD::VSELECT, VT))\n    return DAG.UnrollVectorOp(Node);\n\n  SDValue Cond = DAG.getSetCC(DL, VT, Op0, Op1, CC);\n  return DAG.getSelect(DL, VT, Cond, Op0, Op1);\n}\n\nSDValue TargetLowering::expandAddSubSat(SDNode *Node, SelectionDAG &DAG) const {\n  unsigned Opcode = Node->getOpcode();\n  SDValue LHS = Node->getOperand(0);\n  SDValue RHS = Node->getOperand(1);\n  EVT VT = LHS.getValueType();\n  SDLoc dl(Node);\n\n  assert(VT == RHS.getValueType() && \"Expected operands to be the same type\");\n  assert(VT.isInteger() && \"Expected operands to be integers\");\n\n  // usub.sat(a, b) -> umax(a, b) - b\n  if (Opcode == ISD::USUBSAT && isOperationLegal(ISD::UMAX, VT)) {\n    SDValue Max = DAG.getNode(ISD::UMAX, dl, VT, LHS, RHS);\n    return DAG.getNode(ISD::SUB, dl, VT, Max, RHS);\n  }\n\n  // uadd.sat(a, b) -> umin(a, ~b) + b\n  if (Opcode == ISD::UADDSAT && isOperationLegal(ISD::UMIN, VT)) {\n    SDValue InvRHS = DAG.getNOT(dl, RHS, VT);\n    SDValue Min = DAG.getNode(ISD::UMIN, dl, VT, LHS, InvRHS);\n    return DAG.getNode(ISD::ADD, dl, VT, Min, RHS);\n  }\n\n  unsigned OverflowOp;\n  switch (Opcode) {\n  case ISD::SADDSAT:\n    OverflowOp = ISD::SADDO;\n    break;\n  case ISD::UADDSAT:\n    OverflowOp = ISD::UADDO;\n    break;\n  case ISD::SSUBSAT:\n    OverflowOp = ISD::SSUBO;\n    break;\n  case ISD::USUBSAT:\n    OverflowOp = ISD::USUBO;\n    break;\n  default:\n    llvm_unreachable(\"Expected method to receive signed or unsigned saturation \"\n                     \"addition or subtraction node.\");\n  }\n\n  // FIXME: Should really try to split the vector in case it's legal on a\n  // subvector.\n  if (VT.isVector() && !isOperationLegalOrCustom(ISD::VSELECT, VT))\n    return DAG.UnrollVectorOp(Node);\n\n  unsigned BitWidth = LHS.getScalarValueSizeInBits();\n  EVT BoolVT = getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), VT);\n  SDValue Result = DAG.getNode(OverflowOp, dl, DAG.getVTList(VT, BoolVT),\n                               LHS, RHS);\n  SDValue SumDiff = Result.getValue(0);\n  SDValue Overflow = Result.getValue(1);\n  SDValue Zero = DAG.getConstant(0, dl, VT);\n  SDValue AllOnes = DAG.getAllOnesConstant(dl, VT);\n\n  if (Opcode == ISD::UADDSAT) {\n    if (getBooleanContents(VT) == ZeroOrNegativeOneBooleanContent) {\n      // (LHS + RHS) | OverflowMask\n      SDValue OverflowMask = DAG.getSExtOrTrunc(Overflow, dl, VT);\n      return DAG.getNode(ISD::OR, dl, VT, SumDiff, OverflowMask);\n    }\n    // Overflow ? 0xffff.... : (LHS + RHS)\n    return DAG.getSelect(dl, VT, Overflow, AllOnes, SumDiff);\n  } else if (Opcode == ISD::USUBSAT) {\n    if (getBooleanContents(VT) == ZeroOrNegativeOneBooleanContent) {\n      // (LHS - RHS) & ~OverflowMask\n      SDValue OverflowMask = DAG.getSExtOrTrunc(Overflow, dl, VT);\n      SDValue Not = DAG.getNOT(dl, OverflowMask, VT);\n      return DAG.getNode(ISD::AND, dl, VT, SumDiff, Not);\n    }\n    // Overflow ? 0 : (LHS - RHS)\n    return DAG.getSelect(dl, VT, Overflow, Zero, SumDiff);\n  } else {\n    // SatMax -> Overflow && SumDiff < 0\n    // SatMin -> Overflow && SumDiff >= 0\n    APInt MinVal = APInt::getSignedMinValue(BitWidth);\n    APInt MaxVal = APInt::getSignedMaxValue(BitWidth);\n    SDValue SatMin = DAG.getConstant(MinVal, dl, VT);\n    SDValue SatMax = DAG.getConstant(MaxVal, dl, VT);\n    SDValue SumNeg = DAG.getSetCC(dl, BoolVT, SumDiff, Zero, ISD::SETLT);\n    Result = DAG.getSelect(dl, VT, SumNeg, SatMax, SatMin);\n    return DAG.getSelect(dl, VT, Overflow, Result, SumDiff);\n  }\n}\n\nSDValue TargetLowering::expandShlSat(SDNode *Node, SelectionDAG &DAG) const {\n  unsigned Opcode = Node->getOpcode();\n  bool IsSigned = Opcode == ISD::SSHLSAT;\n  SDValue LHS = Node->getOperand(0);\n  SDValue RHS = Node->getOperand(1);\n  EVT VT = LHS.getValueType();\n  SDLoc dl(Node);\n\n  assert((Node->getOpcode() == ISD::SSHLSAT ||\n          Node->getOpcode() == ISD::USHLSAT) &&\n          \"Expected a SHLSAT opcode\");\n  assert(VT == RHS.getValueType() && \"Expected operands to be the same type\");\n  assert(VT.isInteger() && \"Expected operands to be integers\");\n\n  // If LHS != (LHS << RHS) >> RHS, we have overflow and must saturate.\n\n  unsigned BW = VT.getScalarSizeInBits();\n  SDValue Result = DAG.getNode(ISD::SHL, dl, VT, LHS, RHS);\n  SDValue Orig =\n      DAG.getNode(IsSigned ? ISD::SRA : ISD::SRL, dl, VT, Result, RHS);\n\n  SDValue SatVal;\n  if (IsSigned) {\n    SDValue SatMin = DAG.getConstant(APInt::getSignedMinValue(BW), dl, VT);\n    SDValue SatMax = DAG.getConstant(APInt::getSignedMaxValue(BW), dl, VT);\n    SatVal = DAG.getSelectCC(dl, LHS, DAG.getConstant(0, dl, VT),\n                             SatMin, SatMax, ISD::SETLT);\n  } else {\n    SatVal = DAG.getConstant(APInt::getMaxValue(BW), dl, VT);\n  }\n  Result = DAG.getSelectCC(dl, LHS, Orig, SatVal, Result, ISD::SETNE);\n\n  return Result;\n}\n\nSDValue\nTargetLowering::expandFixedPointMul(SDNode *Node, SelectionDAG &DAG) const {\n  assert((Node->getOpcode() == ISD::SMULFIX ||\n          Node->getOpcode() == ISD::UMULFIX ||\n          Node->getOpcode() == ISD::SMULFIXSAT ||\n          Node->getOpcode() == ISD::UMULFIXSAT) &&\n         \"Expected a fixed point multiplication opcode\");\n\n  SDLoc dl(Node);\n  SDValue LHS = Node->getOperand(0);\n  SDValue RHS = Node->getOperand(1);\n  EVT VT = LHS.getValueType();\n  unsigned Scale = Node->getConstantOperandVal(2);\n  bool Saturating = (Node->getOpcode() == ISD::SMULFIXSAT ||\n                     Node->getOpcode() == ISD::UMULFIXSAT);\n  bool Signed = (Node->getOpcode() == ISD::SMULFIX ||\n                 Node->getOpcode() == ISD::SMULFIXSAT);\n  EVT BoolVT = getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), VT);\n  unsigned VTSize = VT.getScalarSizeInBits();\n\n  if (!Scale) {\n    // [us]mul.fix(a, b, 0) -> mul(a, b)\n    if (!Saturating) {\n      if (isOperationLegalOrCustom(ISD::MUL, VT))\n        return DAG.getNode(ISD::MUL, dl, VT, LHS, RHS);\n    } else if (Signed && isOperationLegalOrCustom(ISD::SMULO, VT)) {\n      SDValue Result =\n          DAG.getNode(ISD::SMULO, dl, DAG.getVTList(VT, BoolVT), LHS, RHS);\n      SDValue Product = Result.getValue(0);\n      SDValue Overflow = Result.getValue(1);\n      SDValue Zero = DAG.getConstant(0, dl, VT);\n\n      APInt MinVal = APInt::getSignedMinValue(VTSize);\n      APInt MaxVal = APInt::getSignedMaxValue(VTSize);\n      SDValue SatMin = DAG.getConstant(MinVal, dl, VT);\n      SDValue SatMax = DAG.getConstant(MaxVal, dl, VT);\n      SDValue ProdNeg = DAG.getSetCC(dl, BoolVT, Product, Zero, ISD::SETLT);\n      Result = DAG.getSelect(dl, VT, ProdNeg, SatMax, SatMin);\n      return DAG.getSelect(dl, VT, Overflow, Result, Product);\n    } else if (!Signed && isOperationLegalOrCustom(ISD::UMULO, VT)) {\n      SDValue Result =\n          DAG.getNode(ISD::UMULO, dl, DAG.getVTList(VT, BoolVT), LHS, RHS);\n      SDValue Product = Result.getValue(0);\n      SDValue Overflow = Result.getValue(1);\n\n      APInt MaxVal = APInt::getMaxValue(VTSize);\n      SDValue SatMax = DAG.getConstant(MaxVal, dl, VT);\n      return DAG.getSelect(dl, VT, Overflow, SatMax, Product);\n    }\n  }\n\n  assert(((Signed && Scale < VTSize) || (!Signed && Scale <= VTSize)) &&\n         \"Expected scale to be less than the number of bits if signed or at \"\n         \"most the number of bits if unsigned.\");\n  assert(LHS.getValueType() == RHS.getValueType() &&\n         \"Expected both operands to be the same type\");\n\n  // Get the upper and lower bits of the result.\n  SDValue Lo, Hi;\n  unsigned LoHiOp = Signed ? ISD::SMUL_LOHI : ISD::UMUL_LOHI;\n  unsigned HiOp = Signed ? ISD::MULHS : ISD::MULHU;\n  if (isOperationLegalOrCustom(LoHiOp, VT)) {\n    SDValue Result = DAG.getNode(LoHiOp, dl, DAG.getVTList(VT, VT), LHS, RHS);\n    Lo = Result.getValue(0);\n    Hi = Result.getValue(1);\n  } else if (isOperationLegalOrCustom(HiOp, VT)) {\n    Lo = DAG.getNode(ISD::MUL, dl, VT, LHS, RHS);\n    Hi = DAG.getNode(HiOp, dl, VT, LHS, RHS);\n  } else if (VT.isVector()) {\n    return SDValue();\n  } else {\n    report_fatal_error(\"Unable to expand fixed point multiplication.\");\n  }\n\n  if (Scale == VTSize)\n    // Result is just the top half since we'd be shifting by the width of the\n    // operand. Overflow impossible so this works for both UMULFIX and\n    // UMULFIXSAT.\n    return Hi;\n\n  // The result will need to be shifted right by the scale since both operands\n  // are scaled. The result is given to us in 2 halves, so we only want part of\n  // both in the result.\n  EVT ShiftTy = getShiftAmountTy(VT, DAG.getDataLayout());\n  SDValue Result = DAG.getNode(ISD::FSHR, dl, VT, Hi, Lo,\n                               DAG.getConstant(Scale, dl, ShiftTy));\n  if (!Saturating)\n    return Result;\n\n  if (!Signed) {\n    // Unsigned overflow happened if the upper (VTSize - Scale) bits (of the\n    // widened multiplication) aren't all zeroes.\n\n    // Saturate to max if ((Hi >> Scale) != 0),\n    // which is the same as if (Hi > ((1 << Scale) - 1))\n    APInt MaxVal = APInt::getMaxValue(VTSize);\n    SDValue LowMask = DAG.getConstant(APInt::getLowBitsSet(VTSize, Scale),\n                                      dl, VT);\n    Result = DAG.getSelectCC(dl, Hi, LowMask,\n                             DAG.getConstant(MaxVal, dl, VT), Result,\n                             ISD::SETUGT);\n\n    return Result;\n  }\n\n  // Signed overflow happened if the upper (VTSize - Scale + 1) bits (of the\n  // widened multiplication) aren't all ones or all zeroes.\n\n  SDValue SatMin = DAG.getConstant(APInt::getSignedMinValue(VTSize), dl, VT);\n  SDValue SatMax = DAG.getConstant(APInt::getSignedMaxValue(VTSize), dl, VT);\n\n  if (Scale == 0) {\n    SDValue Sign = DAG.getNode(ISD::SRA, dl, VT, Lo,\n                               DAG.getConstant(VTSize - 1, dl, ShiftTy));\n    SDValue Overflow = DAG.getSetCC(dl, BoolVT, Hi, Sign, ISD::SETNE);\n    // Saturated to SatMin if wide product is negative, and SatMax if wide\n    // product is positive ...\n    SDValue Zero = DAG.getConstant(0, dl, VT);\n    SDValue ResultIfOverflow = DAG.getSelectCC(dl, Hi, Zero, SatMin, SatMax,\n                                               ISD::SETLT);\n    // ... but only if we overflowed.\n    return DAG.getSelect(dl, VT, Overflow, ResultIfOverflow, Result);\n  }\n\n  //  We handled Scale==0 above so all the bits to examine is in Hi.\n\n  // Saturate to max if ((Hi >> (Scale - 1)) > 0),\n  // which is the same as if (Hi > (1 << (Scale - 1)) - 1)\n  SDValue LowMask = DAG.getConstant(APInt::getLowBitsSet(VTSize, Scale - 1),\n                                    dl, VT);\n  Result = DAG.getSelectCC(dl, Hi, LowMask, SatMax, Result, ISD::SETGT);\n  // Saturate to min if (Hi >> (Scale - 1)) < -1),\n  // which is the same as if (HI < (-1 << (Scale - 1))\n  SDValue HighMask =\n      DAG.getConstant(APInt::getHighBitsSet(VTSize, VTSize - Scale + 1),\n                      dl, VT);\n  Result = DAG.getSelectCC(dl, Hi, HighMask, SatMin, Result, ISD::SETLT);\n  return Result;\n}\n\nSDValue\nTargetLowering::expandFixedPointDiv(unsigned Opcode, const SDLoc &dl,\n                                    SDValue LHS, SDValue RHS,\n                                    unsigned Scale, SelectionDAG &DAG) const {\n  assert((Opcode == ISD::SDIVFIX || Opcode == ISD::SDIVFIXSAT ||\n          Opcode == ISD::UDIVFIX || Opcode == ISD::UDIVFIXSAT) &&\n         \"Expected a fixed point division opcode\");\n\n  EVT VT = LHS.getValueType();\n  bool Signed = Opcode == ISD::SDIVFIX || Opcode == ISD::SDIVFIXSAT;\n  bool Saturating = Opcode == ISD::SDIVFIXSAT || Opcode == ISD::UDIVFIXSAT;\n  EVT BoolVT = getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), VT);\n\n  // If there is enough room in the type to upscale the LHS or downscale the\n  // RHS before the division, we can perform it in this type without having to\n  // resize. For signed operations, the LHS headroom is the number of\n  // redundant sign bits, and for unsigned ones it is the number of zeroes.\n  // The headroom for the RHS is the number of trailing zeroes.\n  unsigned LHSLead = Signed ? DAG.ComputeNumSignBits(LHS) - 1\n                            : DAG.computeKnownBits(LHS).countMinLeadingZeros();\n  unsigned RHSTrail = DAG.computeKnownBits(RHS).countMinTrailingZeros();\n\n  // For signed saturating operations, we need to be able to detect true integer\n  // division overflow; that is, when you have MIN / -EPS. However, this\n  // is undefined behavior and if we emit divisions that could take such\n  // values it may cause undesired behavior (arithmetic exceptions on x86, for\n  // example).\n  // Avoid this by requiring an extra bit so that we never get this case.\n  // FIXME: This is a bit unfortunate as it means that for an 8-bit 7-scale\n  // signed saturating division, we need to emit a whopping 32-bit division.\n  if (LHSLead + RHSTrail < Scale + (unsigned)(Saturating && Signed))\n    return SDValue();\n\n  unsigned LHSShift = std::min(LHSLead, Scale);\n  unsigned RHSShift = Scale - LHSShift;\n\n  // At this point, we know that if we shift the LHS up by LHSShift and the\n  // RHS down by RHSShift, we can emit a regular division with a final scaling\n  // factor of Scale.\n\n  EVT ShiftTy = getShiftAmountTy(VT, DAG.getDataLayout());\n  if (LHSShift)\n    LHS = DAG.getNode(ISD::SHL, dl, VT, LHS,\n                      DAG.getConstant(LHSShift, dl, ShiftTy));\n  if (RHSShift)\n    RHS = DAG.getNode(Signed ? ISD::SRA : ISD::SRL, dl, VT, RHS,\n                      DAG.getConstant(RHSShift, dl, ShiftTy));\n\n  SDValue Quot;\n  if (Signed) {\n    // For signed operations, if the resulting quotient is negative and the\n    // remainder is nonzero, subtract 1 from the quotient to round towards\n    // negative infinity.\n    SDValue Rem;\n    // FIXME: Ideally we would always produce an SDIVREM here, but if the\n    // type isn't legal, SDIVREM cannot be expanded. There is no reason why\n    // we couldn't just form a libcall, but the type legalizer doesn't do it.\n    if (isTypeLegal(VT) &&\n        isOperationLegalOrCustom(ISD::SDIVREM, VT)) {\n      Quot = DAG.getNode(ISD::SDIVREM, dl,\n                         DAG.getVTList(VT, VT),\n                         LHS, RHS);\n      Rem = Quot.getValue(1);\n      Quot = Quot.getValue(0);\n    } else {\n      Quot = DAG.getNode(ISD::SDIV, dl, VT,\n                         LHS, RHS);\n      Rem = DAG.getNode(ISD::SREM, dl, VT,\n                        LHS, RHS);\n    }\n    SDValue Zero = DAG.getConstant(0, dl, VT);\n    SDValue RemNonZero = DAG.getSetCC(dl, BoolVT, Rem, Zero, ISD::SETNE);\n    SDValue LHSNeg = DAG.getSetCC(dl, BoolVT, LHS, Zero, ISD::SETLT);\n    SDValue RHSNeg = DAG.getSetCC(dl, BoolVT, RHS, Zero, ISD::SETLT);\n    SDValue QuotNeg = DAG.getNode(ISD::XOR, dl, BoolVT, LHSNeg, RHSNeg);\n    SDValue Sub1 = DAG.getNode(ISD::SUB, dl, VT, Quot,\n                               DAG.getConstant(1, dl, VT));\n    Quot = DAG.getSelect(dl, VT,\n                         DAG.getNode(ISD::AND, dl, BoolVT, RemNonZero, QuotNeg),\n                         Sub1, Quot);\n  } else\n    Quot = DAG.getNode(ISD::UDIV, dl, VT,\n                       LHS, RHS);\n\n  return Quot;\n}\n\nvoid TargetLowering::expandUADDSUBO(\n    SDNode *Node, SDValue &Result, SDValue &Overflow, SelectionDAG &DAG) const {\n  SDLoc dl(Node);\n  SDValue LHS = Node->getOperand(0);\n  SDValue RHS = Node->getOperand(1);\n  bool IsAdd = Node->getOpcode() == ISD::UADDO;\n\n  // If ADD/SUBCARRY is legal, use that instead.\n  unsigned OpcCarry = IsAdd ? ISD::ADDCARRY : ISD::SUBCARRY;\n  if (isOperationLegalOrCustom(OpcCarry, Node->getValueType(0))) {\n    SDValue CarryIn = DAG.getConstant(0, dl, Node->getValueType(1));\n    SDValue NodeCarry = DAG.getNode(OpcCarry, dl, Node->getVTList(),\n                                    { LHS, RHS, CarryIn });\n    Result = SDValue(NodeCarry.getNode(), 0);\n    Overflow = SDValue(NodeCarry.getNode(), 1);\n    return;\n  }\n\n  Result = DAG.getNode(IsAdd ? ISD::ADD : ISD::SUB, dl,\n                            LHS.getValueType(), LHS, RHS);\n\n  EVT ResultType = Node->getValueType(1);\n  EVT SetCCType = getSetCCResultType(\n      DAG.getDataLayout(), *DAG.getContext(), Node->getValueType(0));\n  ISD::CondCode CC = IsAdd ? ISD::SETULT : ISD::SETUGT;\n  SDValue SetCC = DAG.getSetCC(dl, SetCCType, Result, LHS, CC);\n  Overflow = DAG.getBoolExtOrTrunc(SetCC, dl, ResultType, ResultType);\n}\n\nvoid TargetLowering::expandSADDSUBO(\n    SDNode *Node, SDValue &Result, SDValue &Overflow, SelectionDAG &DAG) const {\n  SDLoc dl(Node);\n  SDValue LHS = Node->getOperand(0);\n  SDValue RHS = Node->getOperand(1);\n  bool IsAdd = Node->getOpcode() == ISD::SADDO;\n\n  Result = DAG.getNode(IsAdd ? ISD::ADD : ISD::SUB, dl,\n                            LHS.getValueType(), LHS, RHS);\n\n  EVT ResultType = Node->getValueType(1);\n  EVT OType = getSetCCResultType(\n      DAG.getDataLayout(), *DAG.getContext(), Node->getValueType(0));\n\n  // If SADDSAT/SSUBSAT is legal, compare results to detect overflow.\n  unsigned OpcSat = IsAdd ? ISD::SADDSAT : ISD::SSUBSAT;\n  if (isOperationLegalOrCustom(OpcSat, LHS.getValueType())) {\n    SDValue Sat = DAG.getNode(OpcSat, dl, LHS.getValueType(), LHS, RHS);\n    SDValue SetCC = DAG.getSetCC(dl, OType, Result, Sat, ISD::SETNE);\n    Overflow = DAG.getBoolExtOrTrunc(SetCC, dl, ResultType, ResultType);\n    return;\n  }\n\n  SDValue Zero = DAG.getConstant(0, dl, LHS.getValueType());\n\n  // For an addition, the result should be less than one of the operands (LHS)\n  // if and only if the other operand (RHS) is negative, otherwise there will\n  // be overflow.\n  // For a subtraction, the result should be less than one of the operands\n  // (LHS) if and only if the other operand (RHS) is (non-zero) positive,\n  // otherwise there will be overflow.\n  SDValue ResultLowerThanLHS = DAG.getSetCC(dl, OType, Result, LHS, ISD::SETLT);\n  SDValue ConditionRHS =\n      DAG.getSetCC(dl, OType, RHS, Zero, IsAdd ? ISD::SETLT : ISD::SETGT);\n\n  Overflow = DAG.getBoolExtOrTrunc(\n      DAG.getNode(ISD::XOR, dl, OType, ConditionRHS, ResultLowerThanLHS), dl,\n      ResultType, ResultType);\n}\n\nbool TargetLowering::expandMULO(SDNode *Node, SDValue &Result,\n                                SDValue &Overflow, SelectionDAG &DAG) const {\n  SDLoc dl(Node);\n  EVT VT = Node->getValueType(0);\n  EVT SetCCVT = getSetCCResultType(DAG.getDataLayout(), *DAG.getContext(), VT);\n  SDValue LHS = Node->getOperand(0);\n  SDValue RHS = Node->getOperand(1);\n  bool isSigned = Node->getOpcode() == ISD::SMULO;\n\n  // For power-of-two multiplications we can use a simpler shift expansion.\n  if (ConstantSDNode *RHSC = isConstOrConstSplat(RHS)) {\n    const APInt &C = RHSC->getAPIntValue();\n    // mulo(X, 1 << S) -> { X << S, (X << S) >> S != X }\n    if (C.isPowerOf2()) {\n      // smulo(x, signed_min) is same as umulo(x, signed_min).\n      bool UseArithShift = isSigned && !C.isMinSignedValue();\n      EVT ShiftAmtTy = getShiftAmountTy(VT, DAG.getDataLayout());\n      SDValue ShiftAmt = DAG.getConstant(C.logBase2(), dl, ShiftAmtTy);\n      Result = DAG.getNode(ISD::SHL, dl, VT, LHS, ShiftAmt);\n      Overflow = DAG.getSetCC(dl, SetCCVT,\n          DAG.getNode(UseArithShift ? ISD::SRA : ISD::SRL,\n                      dl, VT, Result, ShiftAmt),\n          LHS, ISD::SETNE);\n      return true;\n    }\n  }\n\n  EVT WideVT = EVT::getIntegerVT(*DAG.getContext(), VT.getScalarSizeInBits() * 2);\n  if (VT.isVector())\n    WideVT = EVT::getVectorVT(*DAG.getContext(), WideVT,\n                              VT.getVectorNumElements());\n\n  SDValue BottomHalf;\n  SDValue TopHalf;\n  static const unsigned Ops[2][3] =\n      { { ISD::MULHU, ISD::UMUL_LOHI, ISD::ZERO_EXTEND },\n        { ISD::MULHS, ISD::SMUL_LOHI, ISD::SIGN_EXTEND }};\n  if (isOperationLegalOrCustom(Ops[isSigned][0], VT)) {\n    BottomHalf = DAG.getNode(ISD::MUL, dl, VT, LHS, RHS);\n    TopHalf = DAG.getNode(Ops[isSigned][0], dl, VT, LHS, RHS);\n  } else if (isOperationLegalOrCustom(Ops[isSigned][1], VT)) {\n    BottomHalf = DAG.getNode(Ops[isSigned][1], dl, DAG.getVTList(VT, VT), LHS,\n                             RHS);\n    TopHalf = BottomHalf.getValue(1);\n  } else if (isTypeLegal(WideVT)) {\n    LHS = DAG.getNode(Ops[isSigned][2], dl, WideVT, LHS);\n    RHS = DAG.getNode(Ops[isSigned][2], dl, WideVT, RHS);\n    SDValue Mul = DAG.getNode(ISD::MUL, dl, WideVT, LHS, RHS);\n    BottomHalf = DAG.getNode(ISD::TRUNCATE, dl, VT, Mul);\n    SDValue ShiftAmt = DAG.getConstant(VT.getScalarSizeInBits(), dl,\n        getShiftAmountTy(WideVT, DAG.getDataLayout()));\n    TopHalf = DAG.getNode(ISD::TRUNCATE, dl, VT,\n                          DAG.getNode(ISD::SRL, dl, WideVT, Mul, ShiftAmt));\n  } else {\n    if (VT.isVector())\n      return false;\n\n    // We can fall back to a libcall with an illegal type for the MUL if we\n    // have a libcall big enough.\n    // Also, we can fall back to a division in some cases, but that's a big\n    // performance hit in the general case.\n    RTLIB::Libcall LC = RTLIB::UNKNOWN_LIBCALL;\n    if (WideVT == MVT::i16)\n      LC = RTLIB::MUL_I16;\n    else if (WideVT == MVT::i32)\n      LC = RTLIB::MUL_I32;\n    else if (WideVT == MVT::i64)\n      LC = RTLIB::MUL_I64;\n    else if (WideVT == MVT::i128)\n      LC = RTLIB::MUL_I128;\n    assert(LC != RTLIB::UNKNOWN_LIBCALL && \"Cannot expand this operation!\");\n\n    SDValue HiLHS;\n    SDValue HiRHS;\n    if (isSigned) {\n      // The high part is obtained by SRA'ing all but one of the bits of low\n      // part.\n      unsigned LoSize = VT.getFixedSizeInBits();\n      HiLHS =\n          DAG.getNode(ISD::SRA, dl, VT, LHS,\n                      DAG.getConstant(LoSize - 1, dl,\n                                      getPointerTy(DAG.getDataLayout())));\n      HiRHS =\n          DAG.getNode(ISD::SRA, dl, VT, RHS,\n                      DAG.getConstant(LoSize - 1, dl,\n                                      getPointerTy(DAG.getDataLayout())));\n    } else {\n        HiLHS = DAG.getConstant(0, dl, VT);\n        HiRHS = DAG.getConstant(0, dl, VT);\n    }\n\n    // Here we're passing the 2 arguments explicitly as 4 arguments that are\n    // pre-lowered to the correct types. This all depends upon WideVT not\n    // being a legal type for the architecture and thus has to be split to\n    // two arguments.\n    SDValue Ret;\n    TargetLowering::MakeLibCallOptions CallOptions;\n    CallOptions.setSExt(isSigned);\n    CallOptions.setIsPostTypeLegalization(true);\n    if (shouldSplitFunctionArgumentsAsLittleEndian(DAG.getDataLayout())) {\n      // Halves of WideVT are packed into registers in different order\n      // depending on platform endianness. This is usually handled by\n      // the C calling convention, but we can't defer to it in\n      // the legalizer.\n      SDValue Args[] = { LHS, HiLHS, RHS, HiRHS };\n      Ret = makeLibCall(DAG, LC, WideVT, Args, CallOptions, dl).first;\n    } else {\n      SDValue Args[] = { HiLHS, LHS, HiRHS, RHS };\n      Ret = makeLibCall(DAG, LC, WideVT, Args, CallOptions, dl).first;\n    }\n    assert(Ret.getOpcode() == ISD::MERGE_VALUES &&\n           \"Ret value is a collection of constituent nodes holding result.\");\n    if (DAG.getDataLayout().isLittleEndian()) {\n      // Same as above.\n      BottomHalf = Ret.getOperand(0);\n      TopHalf = Ret.getOperand(1);\n    } else {\n      BottomHalf = Ret.getOperand(1);\n      TopHalf = Ret.getOperand(0);\n    }\n  }\n\n  Result = BottomHalf;\n  if (isSigned) {\n    SDValue ShiftAmt = DAG.getConstant(\n        VT.getScalarSizeInBits() - 1, dl,\n        getShiftAmountTy(BottomHalf.getValueType(), DAG.getDataLayout()));\n    SDValue Sign = DAG.getNode(ISD::SRA, dl, VT, BottomHalf, ShiftAmt);\n    Overflow = DAG.getSetCC(dl, SetCCVT, TopHalf, Sign, ISD::SETNE);\n  } else {\n    Overflow = DAG.getSetCC(dl, SetCCVT, TopHalf,\n                            DAG.getConstant(0, dl, VT), ISD::SETNE);\n  }\n\n  // Truncate the result if SetCC returns a larger type than needed.\n  EVT RType = Node->getValueType(1);\n  if (RType.bitsLT(Overflow.getValueType()))\n    Overflow = DAG.getNode(ISD::TRUNCATE, dl, RType, Overflow);\n\n  assert(RType.getSizeInBits() == Overflow.getValueSizeInBits() &&\n         \"Unexpected result type for S/UMULO legalization\");\n  return true;\n}\n\nSDValue TargetLowering::expandVecReduce(SDNode *Node, SelectionDAG &DAG) const {\n  SDLoc dl(Node);\n  unsigned BaseOpcode = ISD::getVecReduceBaseOpcode(Node->getOpcode());\n  SDValue Op = Node->getOperand(0);\n  EVT VT = Op.getValueType();\n\n  if (VT.isScalableVector())\n    report_fatal_error(\n        \"Expanding reductions for scalable vectors is undefined.\");\n\n  // Try to use a shuffle reduction for power of two vectors.\n  if (VT.isPow2VectorType()) {\n    while (VT.getVectorNumElements() > 1) {\n      EVT HalfVT = VT.getHalfNumVectorElementsVT(*DAG.getContext());\n      if (!isOperationLegalOrCustom(BaseOpcode, HalfVT))\n        break;\n\n      SDValue Lo, Hi;\n      std::tie(Lo, Hi) = DAG.SplitVector(Op, dl);\n      Op = DAG.getNode(BaseOpcode, dl, HalfVT, Lo, Hi);\n      VT = HalfVT;\n    }\n  }\n\n  EVT EltVT = VT.getVectorElementType();\n  unsigned NumElts = VT.getVectorNumElements();\n\n  SmallVector<SDValue, 8> Ops;\n  DAG.ExtractVectorElements(Op, Ops, 0, NumElts);\n\n  SDValue Res = Ops[0];\n  for (unsigned i = 1; i < NumElts; i++)\n    Res = DAG.getNode(BaseOpcode, dl, EltVT, Res, Ops[i], Node->getFlags());\n\n  // Result type may be wider than element type.\n  if (EltVT != Node->getValueType(0))\n    Res = DAG.getNode(ISD::ANY_EXTEND, dl, Node->getValueType(0), Res);\n  return Res;\n}\n\nSDValue TargetLowering::expandVecReduceSeq(SDNode *Node, SelectionDAG &DAG) const {\n  SDLoc dl(Node);\n  SDValue AccOp = Node->getOperand(0);\n  SDValue VecOp = Node->getOperand(1);\n  SDNodeFlags Flags = Node->getFlags();\n\n  EVT VT = VecOp.getValueType();\n  EVT EltVT = VT.getVectorElementType();\n\n  if (VT.isScalableVector())\n    report_fatal_error(\n        \"Expanding reductions for scalable vectors is undefined.\");\n\n  unsigned NumElts = VT.getVectorNumElements();\n\n  SmallVector<SDValue, 8> Ops;\n  DAG.ExtractVectorElements(VecOp, Ops, 0, NumElts);\n\n  unsigned BaseOpcode = ISD::getVecReduceBaseOpcode(Node->getOpcode());\n\n  SDValue Res = AccOp;\n  for (unsigned i = 0; i < NumElts; i++)\n    Res = DAG.getNode(BaseOpcode, dl, EltVT, Res, Ops[i], Flags);\n\n  return Res;\n}\n\nbool TargetLowering::expandREM(SDNode *Node, SDValue &Result,\n                               SelectionDAG &DAG) const {\n  EVT VT = Node->getValueType(0);\n  SDLoc dl(Node);\n  bool isSigned = Node->getOpcode() == ISD::SREM;\n  unsigned DivOpc = isSigned ? ISD::SDIV : ISD::UDIV;\n  unsigned DivRemOpc = isSigned ? ISD::SDIVREM : ISD::UDIVREM;\n  SDValue Dividend = Node->getOperand(0);\n  SDValue Divisor = Node->getOperand(1);\n  if (isOperationLegalOrCustom(DivRemOpc, VT)) {\n    SDVTList VTs = DAG.getVTList(VT, VT);\n    Result = DAG.getNode(DivRemOpc, dl, VTs, Dividend, Divisor).getValue(1);\n    return true;\n  } else if (isOperationLegalOrCustom(DivOpc, VT)) {\n    // X % Y -> X-X/Y*Y\n    SDValue Divide = DAG.getNode(DivOpc, dl, VT, Dividend, Divisor);\n    SDValue Mul = DAG.getNode(ISD::MUL, dl, VT, Divide, Divisor);\n    Result = DAG.getNode(ISD::SUB, dl, VT, Dividend, Mul);\n    return true;\n  }\n  return false;\n}\n\nSDValue TargetLowering::expandFP_TO_INT_SAT(SDNode *Node,\n                                            SelectionDAG &DAG) const {\n  bool IsSigned = Node->getOpcode() == ISD::FP_TO_SINT_SAT;\n  SDLoc dl(SDValue(Node, 0));\n  SDValue Src = Node->getOperand(0);\n\n  // DstVT is the result type, while SatVT is the size to which we saturate\n  EVT SrcVT = Src.getValueType();\n  EVT DstVT = Node->getValueType(0);\n\n  unsigned SatWidth = Node->getConstantOperandVal(1);\n  unsigned DstWidth = DstVT.getScalarSizeInBits();\n  assert(SatWidth <= DstWidth &&\n         \"Expected saturation width smaller than result width\");\n\n  // Determine minimum and maximum integer values and their corresponding\n  // floating-point values.\n  APInt MinInt, MaxInt;\n  if (IsSigned) {\n    MinInt = APInt::getSignedMinValue(SatWidth).sextOrSelf(DstWidth);\n    MaxInt = APInt::getSignedMaxValue(SatWidth).sextOrSelf(DstWidth);\n  } else {\n    MinInt = APInt::getMinValue(SatWidth).zextOrSelf(DstWidth);\n    MaxInt = APInt::getMaxValue(SatWidth).zextOrSelf(DstWidth);\n  }\n\n  // We cannot risk emitting FP_TO_XINT nodes with a source VT of f16, as\n  // libcall emission cannot handle this. Large result types will fail.\n  if (SrcVT == MVT::f16) {\n    Src = DAG.getNode(ISD::FP_EXTEND, dl, MVT::f32, Src);\n    SrcVT = Src.getValueType();\n  }\n\n  APFloat MinFloat(DAG.EVTToAPFloatSemantics(SrcVT));\n  APFloat MaxFloat(DAG.EVTToAPFloatSemantics(SrcVT));\n\n  APFloat::opStatus MinStatus =\n      MinFloat.convertFromAPInt(MinInt, IsSigned, APFloat::rmTowardZero);\n  APFloat::opStatus MaxStatus =\n      MaxFloat.convertFromAPInt(MaxInt, IsSigned, APFloat::rmTowardZero);\n  bool AreExactFloatBounds = !(MinStatus & APFloat::opStatus::opInexact) &&\n                             !(MaxStatus & APFloat::opStatus::opInexact);\n\n  SDValue MinFloatNode = DAG.getConstantFP(MinFloat, dl, SrcVT);\n  SDValue MaxFloatNode = DAG.getConstantFP(MaxFloat, dl, SrcVT);\n\n  // If the integer bounds are exactly representable as floats and min/max are\n  // legal, emit a min+max+fptoi sequence. Otherwise we have to use a sequence\n  // of comparisons and selects.\n  bool MinMaxLegal = isOperationLegal(ISD::FMINNUM, SrcVT) &&\n                     isOperationLegal(ISD::FMAXNUM, SrcVT);\n  if (AreExactFloatBounds && MinMaxLegal) {\n    SDValue Clamped = Src;\n\n    // Clamp Src by MinFloat from below. If Src is NaN the result is MinFloat.\n    Clamped = DAG.getNode(ISD::FMAXNUM, dl, SrcVT, Clamped, MinFloatNode);\n    // Clamp by MaxFloat from above. NaN cannot occur.\n    Clamped = DAG.getNode(ISD::FMINNUM, dl, SrcVT, Clamped, MaxFloatNode);\n    // Convert clamped value to integer.\n    SDValue FpToInt = DAG.getNode(IsSigned ? ISD::FP_TO_SINT : ISD::FP_TO_UINT,\n                                  dl, DstVT, Clamped);\n\n    // In the unsigned case we're done, because we mapped NaN to MinFloat,\n    // which will cast to zero.\n    if (!IsSigned)\n      return FpToInt;\n\n    // Otherwise, select 0 if Src is NaN.\n    SDValue ZeroInt = DAG.getConstant(0, dl, DstVT);\n    return DAG.getSelectCC(dl, Src, Src, ZeroInt, FpToInt,\n                           ISD::CondCode::SETUO);\n  }\n\n  SDValue MinIntNode = DAG.getConstant(MinInt, dl, DstVT);\n  SDValue MaxIntNode = DAG.getConstant(MaxInt, dl, DstVT);\n\n  // Result of direct conversion. The assumption here is that the operation is\n  // non-trapping and it's fine to apply it to an out-of-range value if we\n  // select it away later.\n  SDValue FpToInt =\n      DAG.getNode(IsSigned ? ISD::FP_TO_SINT : ISD::FP_TO_UINT, dl, DstVT, Src);\n\n  SDValue Select = FpToInt;\n\n  // If Src ULT MinFloat, select MinInt. In particular, this also selects\n  // MinInt if Src is NaN.\n  Select = DAG.getSelectCC(dl, Src, MinFloatNode, MinIntNode, Select,\n                           ISD::CondCode::SETULT);\n  // If Src OGT MaxFloat, select MaxInt.\n  Select = DAG.getSelectCC(dl, Src, MaxFloatNode, MaxIntNode, Select,\n                           ISD::CondCode::SETOGT);\n\n  // In the unsigned case we are done, because we mapped NaN to MinInt, which\n  // is already zero.\n  if (!IsSigned)\n    return Select;\n\n  // Otherwise, select 0 if Src is NaN.\n  SDValue ZeroInt = DAG.getConstant(0, dl, DstVT);\n  return DAG.getSelectCC(dl, Src, Src, ZeroInt, Select, ISD::CondCode::SETUO);\n}\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h", "content": "//===- llvm/CodeGen/TargetLowering.h - Target Lowering Info -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file describes how to lower LLVM code to machine code.  This has two\n/// main components:\n///\n///  1. Which ValueTypes are natively supported by the target.\n///  2. Which operations are supported for supported ValueTypes.\n///  3. Cost thresholds for alternative implementations of certain operations.\n///\n/// In addition it has a few other components, like information about FP\n/// immediates.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_TARGETLOWERING_H\n#define LLVM_CODEGEN_TARGETLOWERING_H\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/CodeGen/DAGCombine.h\"\n#include \"llvm/CodeGen/ISDOpcodes.h\"\n#include \"llvm/CodeGen/RuntimeLibcalls.h\"\n#include \"llvm/CodeGen/SelectionDAG.h\"\n#include \"llvm/CodeGen/SelectionDAGNodes.h\"\n#include \"llvm/CodeGen/TargetCallingConv.h\"\n#include \"llvm/CodeGen/ValueTypes.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/CallingConv.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/InlineAsm.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MachineValueType.h\"\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cstdint>\n#include <iterator>\n#include <map>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass BranchProbability;\nclass CCState;\nclass CCValAssign;\nclass Constant;\nclass FastISel;\nclass FunctionLoweringInfo;\nclass GlobalValue;\nclass GISelKnownBits;\nclass IntrinsicInst;\nstruct KnownBits;\nclass LegacyDivergenceAnalysis;\nclass LLVMContext;\nclass MachineBasicBlock;\nclass MachineFunction;\nclass MachineInstr;\nclass MachineJumpTableInfo;\nclass MachineLoop;\nclass MachineRegisterInfo;\nclass MCContext;\nclass MCExpr;\nclass Module;\nclass ProfileSummaryInfo;\nclass TargetLibraryInfo;\nclass TargetMachine;\nclass TargetRegisterClass;\nclass TargetRegisterInfo;\nclass TargetTransformInfo;\nclass Value;\n\nnamespace Sched {\n\n  enum Preference {\n    None,             // No preference\n    Source,           // Follow source order.\n    RegPressure,      // Scheduling for lowest register pressure.\n    Hybrid,           // Scheduling for both latency and register pressure.\n    ILP,              // Scheduling for ILP in low register pressure mode.\n    VLIW              // Scheduling for VLIW targets.\n  };\n\n} // end namespace Sched\n\n// MemOp models a memory operation, either memset or memcpy/memmove.\nstruct MemOp {\nprivate:\n  // Shared\n  uint64_t Size;\n  bool DstAlignCanChange; // true if destination alignment can satisfy any\n                          // constraint.\n  Align DstAlign;         // Specified alignment of the memory operation.\n\n  bool AllowOverlap;\n  // memset only\n  bool IsMemset;   // If setthis memory operation is a memset.\n  bool ZeroMemset; // If set clears out memory with zeros.\n  // memcpy only\n  bool MemcpyStrSrc; // Indicates whether the memcpy source is an in-register\n                     // constant so it does not need to be loaded.\n  Align SrcAlign;    // Inferred alignment of the source or default value if the\n                     // memory operation does not need to load the value.\npublic:\n  static MemOp Copy(uint64_t Size, bool DstAlignCanChange, Align DstAlign,\n                    Align SrcAlign, bool IsVolatile,\n                    bool MemcpyStrSrc = false) {\n    MemOp Op;\n    Op.Size = Size;\n    Op.DstAlignCanChange = DstAlignCanChange;\n    Op.DstAlign = DstAlign;\n    Op.AllowOverlap = !IsVolatile;\n    Op.IsMemset = false;\n    Op.ZeroMemset = false;\n    Op.MemcpyStrSrc = MemcpyStrSrc;\n    Op.SrcAlign = SrcAlign;\n    return Op;\n  }\n\n  static MemOp Set(uint64_t Size, bool DstAlignCanChange, Align DstAlign,\n                   bool IsZeroMemset, bool IsVolatile) {\n    MemOp Op;\n    Op.Size = Size;\n    Op.DstAlignCanChange = DstAlignCanChange;\n    Op.DstAlign = DstAlign;\n    Op.AllowOverlap = !IsVolatile;\n    Op.IsMemset = true;\n    Op.ZeroMemset = IsZeroMemset;\n    Op.MemcpyStrSrc = false;\n    return Op;\n  }\n\n  uint64_t size() const { return Size; }\n  Align getDstAlign() const {\n    assert(!DstAlignCanChange);\n    return DstAlign;\n  }\n  bool isFixedDstAlign() const { return !DstAlignCanChange; }\n  bool allowOverlap() const { return AllowOverlap; }\n  bool isMemset() const { return IsMemset; }\n  bool isMemcpy() const { return !IsMemset; }\n  bool isMemcpyWithFixedDstAlign() const {\n    return isMemcpy() && !DstAlignCanChange;\n  }\n  bool isZeroMemset() const { return isMemset() && ZeroMemset; }\n  bool isMemcpyStrSrc() const {\n    assert(isMemcpy() && \"Must be a memcpy\");\n    return MemcpyStrSrc;\n  }\n  Align getSrcAlign() const {\n    assert(isMemcpy() && \"Must be a memcpy\");\n    return SrcAlign;\n  }\n  bool isSrcAligned(Align AlignCheck) const {\n    return isMemset() || llvm::isAligned(AlignCheck, SrcAlign.value());\n  }\n  bool isDstAligned(Align AlignCheck) const {\n    return DstAlignCanChange || llvm::isAligned(AlignCheck, DstAlign.value());\n  }\n  bool isAligned(Align AlignCheck) const {\n    return isSrcAligned(AlignCheck) && isDstAligned(AlignCheck);\n  }\n};\n\n/// This base class for TargetLowering contains the SelectionDAG-independent\n/// parts that can be used from the rest of CodeGen.\nclass TargetLoweringBase {\npublic:\n  /// This enum indicates whether operations are valid for a target, and if not,\n  /// what action should be used to make them valid.\n  enum LegalizeAction : uint8_t {\n    Legal,      // The target natively supports this operation.\n    Promote,    // This operation should be executed in a larger type.\n    Expand,     // Try to expand this to other ops, otherwise use a libcall.\n    LibCall,    // Don't try to expand this to other ops, always use a libcall.\n    Custom      // Use the LowerOperation hook to implement custom lowering.\n  };\n\n  /// This enum indicates whether a types are legal for a target, and if not,\n  /// what action should be used to make them valid.\n  enum LegalizeTypeAction : uint8_t {\n    TypeLegal,           // The target natively supports this type.\n    TypePromoteInteger,  // Replace this integer with a larger one.\n    TypeExpandInteger,   // Split this integer into two of half the size.\n    TypeSoftenFloat,     // Convert this float to a same size integer type.\n    TypeExpandFloat,     // Split this float into two of half the size.\n    TypeScalarizeVector, // Replace this one-element vector with its element.\n    TypeSplitVector,     // Split this vector into two of half the size.\n    TypeWidenVector,     // This vector should be widened into a larger vector.\n    TypePromoteFloat,    // Replace this float with a larger one.\n    TypeSoftPromoteHalf, // Soften half to i16 and use float to do arithmetic.\n    TypeScalarizeScalableVector, // This action is explicitly left unimplemented.\n                                 // While it is theoretically possible to\n                                 // legalize operations on scalable types with a\n                                 // loop that handles the vscale * #lanes of the\n                                 // vector, this is non-trivial at SelectionDAG\n                                 // level and these types are better to be\n                                 // widened or promoted.\n  };\n\n  /// LegalizeKind holds the legalization kind that needs to happen to EVT\n  /// in order to type-legalize it.\n  using LegalizeKind = std::pair<LegalizeTypeAction, EVT>;\n\n  /// Enum that describes how the target represents true/false values.\n  enum BooleanContent {\n    UndefinedBooleanContent,    // Only bit 0 counts, the rest can hold garbage.\n    ZeroOrOneBooleanContent,        // All bits zero except for bit 0.\n    ZeroOrNegativeOneBooleanContent // All bits equal to bit 0.\n  };\n\n  /// Enum that describes what type of support for selects the target has.\n  enum SelectSupportKind {\n    ScalarValSelect,      // The target supports scalar selects (ex: cmov).\n    ScalarCondVectorVal,  // The target supports selects with a scalar condition\n                          // and vector values (ex: cmov).\n    VectorMaskSelect      // The target supports vector selects with a vector\n                          // mask (ex: x86 blends).\n  };\n\n  /// Enum that specifies what an atomic load/AtomicRMWInst is expanded\n  /// to, if at all. Exists because different targets have different levels of\n  /// support for these atomic instructions, and also have different options\n  /// w.r.t. what they should expand to.\n  enum class AtomicExpansionKind {\n    None,    // Don't expand the instruction.\n    LLSC,    // Expand the instruction into loadlinked/storeconditional; used\n             // by ARM/AArch64.\n    LLOnly,  // Expand the (load) instruction into just a load-linked, which has\n             // greater atomic guarantees than a normal load.\n    CmpXChg, // Expand the instruction into cmpxchg; used by at least X86.\n    MaskedIntrinsic, // Use a target-specific intrinsic for the LL/SC loop.\n  };\n\n  /// Enum that specifies when a multiplication should be expanded.\n  enum class MulExpansionKind {\n    Always,            // Always expand the instruction.\n    OnlyLegalOrCustom, // Only expand when the resulting instructions are legal\n                       // or custom.\n  };\n\n  /// Enum that specifies when a float negation is beneficial.\n  enum class NegatibleCost {\n    Cheaper = 0,    // Negated expression is cheaper.\n    Neutral = 1,    // Negated expression has the same cost.\n    Expensive = 2   // Negated expression is more expensive.\n  };\n\n  class ArgListEntry {\n  public:\n    Value *Val = nullptr;\n    SDValue Node = SDValue();\n    Type *Ty = nullptr;\n    bool IsSExt : 1;\n    bool IsZExt : 1;\n    bool IsInReg : 1;\n    bool IsSRet : 1;\n    bool IsNest : 1;\n    bool IsByVal : 1;\n    bool IsByRef : 1;\n    bool IsInAlloca : 1;\n    bool IsPreallocated : 1;\n    bool IsReturned : 1;\n    bool IsSwiftSelf : 1;\n    bool IsSwiftError : 1;\n    bool IsCFGuardTarget : 1;\n    MaybeAlign Alignment = None;\n    Type *ByValType = nullptr;\n    Type *PreallocatedType = nullptr;\n\n    ArgListEntry()\n        : IsSExt(false), IsZExt(false), IsInReg(false), IsSRet(false),\n          IsNest(false), IsByVal(false), IsByRef(false), IsInAlloca(false),\n          IsPreallocated(false), IsReturned(false), IsSwiftSelf(false),\n          IsSwiftError(false), IsCFGuardTarget(false) {}\n\n    void setAttributes(const CallBase *Call, unsigned ArgIdx);\n  };\n  using ArgListTy = std::vector<ArgListEntry>;\n\n  virtual void markLibCallAttributes(MachineFunction *MF, unsigned CC,\n                                     ArgListTy &Args) const {};\n\n  static ISD::NodeType getExtendForContent(BooleanContent Content) {\n    switch (Content) {\n    case UndefinedBooleanContent:\n      // Extend by adding rubbish bits.\n      return ISD::ANY_EXTEND;\n    case ZeroOrOneBooleanContent:\n      // Extend by adding zero bits.\n      return ISD::ZERO_EXTEND;\n    case ZeroOrNegativeOneBooleanContent:\n      // Extend by copying the sign bit.\n      return ISD::SIGN_EXTEND;\n    }\n    llvm_unreachable(\"Invalid content kind\");\n  }\n\n  explicit TargetLoweringBase(const TargetMachine &TM);\n  TargetLoweringBase(const TargetLoweringBase &) = delete;\n  TargetLoweringBase &operator=(const TargetLoweringBase &) = delete;\n  virtual ~TargetLoweringBase() = default;\n\n  /// Return true if the target support strict float operation\n  bool isStrictFPEnabled() const {\n    return IsStrictFPEnabled;\n  }\n\nprotected:\n  /// Initialize all of the actions to default values.\n  void initActions();\n\npublic:\n  const TargetMachine &getTargetMachine() const { return TM; }\n\n  virtual bool useSoftFloat() const { return false; }\n\n  /// Return the pointer type for the given address space, defaults to\n  /// the pointer type from the data layout.\n  /// FIXME: The default needs to be removed once all the code is updated.\n  virtual MVT getPointerTy(const DataLayout &DL, uint32_t AS = 0) const {\n    return MVT::getIntegerVT(DL.getPointerSizeInBits(AS));\n  }\n\n  /// Return the in-memory pointer type for the given address space, defaults to\n  /// the pointer type from the data layout.  FIXME: The default needs to be\n  /// removed once all the code is updated.\n  MVT getPointerMemTy(const DataLayout &DL, uint32_t AS = 0) const {\n    return MVT::getIntegerVT(DL.getPointerSizeInBits(AS));\n  }\n\n  /// Return the type for frame index, which is determined by\n  /// the alloca address space specified through the data layout.\n  MVT getFrameIndexTy(const DataLayout &DL) const {\n    return getPointerTy(DL, DL.getAllocaAddrSpace());\n  }\n\n  /// Return the type for code pointers, which is determined by the program\n  /// address space specified through the data layout.\n  MVT getProgramPointerTy(const DataLayout &DL) const {\n    return getPointerTy(DL, DL.getProgramAddressSpace());\n  }\n\n  /// Return the type for operands of fence.\n  /// TODO: Let fence operands be of i32 type and remove this.\n  virtual MVT getFenceOperandTy(const DataLayout &DL) const {\n    return getPointerTy(DL);\n  }\n\n  /// EVT is not used in-tree, but is used by out-of-tree target.\n  /// A documentation for this function would be nice...\n  virtual MVT getScalarShiftAmountTy(const DataLayout &, EVT) const;\n\n  EVT getShiftAmountTy(EVT LHSTy, const DataLayout &DL,\n                       bool LegalTypes = true) const;\n\n  /// Return the preferred type to use for a shift opcode, given the shifted\n  /// amount type is \\p ShiftValueTy.\n  LLVM_READONLY\n  virtual LLT getPreferredShiftAmountTy(LLT ShiftValueTy) const {\n    return ShiftValueTy;\n  }\n\n  /// Returns the type to be used for the index operand of:\n  /// ISD::INSERT_VECTOR_ELT, ISD::EXTRACT_VECTOR_ELT,\n  /// ISD::INSERT_SUBVECTOR, and ISD::EXTRACT_SUBVECTOR\n  virtual MVT getVectorIdxTy(const DataLayout &DL) const {\n    return getPointerTy(DL);\n  }\n\n  /// This callback is used to inspect load/store instructions and add\n  /// target-specific MachineMemOperand flags to them.  The default\n  /// implementation does nothing.\n  virtual MachineMemOperand::Flags getTargetMMOFlags(const Instruction &I) const {\n    return MachineMemOperand::MONone;\n  }\n\n  MachineMemOperand::Flags getLoadMemOperandFlags(const LoadInst &LI,\n                                                  const DataLayout &DL) const;\n  MachineMemOperand::Flags getStoreMemOperandFlags(const StoreInst &SI,\n                                                   const DataLayout &DL) const;\n  MachineMemOperand::Flags getAtomicMemOperandFlags(const Instruction &AI,\n                                                    const DataLayout &DL) const;\n\n  virtual bool isSelectSupported(SelectSupportKind /*kind*/) const {\n    return true;\n  }\n\n  /// Return true if it is profitable to convert a select of FP constants into\n  /// a constant pool load whose address depends on the select condition. The\n  /// parameter may be used to differentiate a select with FP compare from\n  /// integer compare.\n  virtual bool reduceSelectOfFPConstantLoads(EVT CmpOpVT) const {\n    return true;\n  }\n\n  /// Return true if multiple condition registers are available.\n  bool hasMultipleConditionRegisters() const {\n    return HasMultipleConditionRegisters;\n  }\n\n  /// Return true if the target has BitExtract instructions.\n  bool hasExtractBitsInsn() const { return HasExtractBitsInsn; }\n\n  /// Return the preferred vector type legalization action.\n  virtual TargetLoweringBase::LegalizeTypeAction\n  getPreferredVectorAction(MVT VT) const {\n    // The default action for one element vectors is to scalarize\n    if (VT.getVectorElementCount().isScalar())\n      return TypeScalarizeVector;\n    // The default action for an odd-width vector is to widen.\n    if (!VT.isPow2VectorType())\n      return TypeWidenVector;\n    // The default action for other vectors is to promote\n    return TypePromoteInteger;\n  }\n\n  // Return true if the half type should be passed around as i16, but promoted\n  // to float around arithmetic. The default behavior is to pass around as\n  // float and convert around loads/stores/bitcasts and other places where\n  // the size matters.\n  virtual bool softPromoteHalfType() const { return false; }\n\n  // There are two general methods for expanding a BUILD_VECTOR node:\n  //  1. Use SCALAR_TO_VECTOR on the defined scalar values and then shuffle\n  //     them together.\n  //  2. Build the vector on the stack and then load it.\n  // If this function returns true, then method (1) will be used, subject to\n  // the constraint that all of the necessary shuffles are legal (as determined\n  // by isShuffleMaskLegal). If this function returns false, then method (2) is\n  // always used. The vector type, and the number of defined values, are\n  // provided.\n  virtual bool\n  shouldExpandBuildVectorWithShuffles(EVT /* VT */,\n                                      unsigned DefinedValues) const {\n    return DefinedValues < 3;\n  }\n\n  /// Return true if integer divide is usually cheaper than a sequence of\n  /// several shifts, adds, and multiplies for this target.\n  /// The definition of \"cheaper\" may depend on whether we're optimizing\n  /// for speed or for size.\n  virtual bool isIntDivCheap(EVT VT, AttributeList Attr) const { return false; }\n\n  /// Return true if the target can handle a standalone remainder operation.\n  virtual bool hasStandaloneRem(EVT VT) const {\n    return true;\n  }\n\n  /// Return true if SQRT(X) shouldn't be replaced with X*RSQRT(X).\n  virtual bool isFsqrtCheap(SDValue X, SelectionDAG &DAG) const {\n    // Default behavior is to replace SQRT(X) with X*RSQRT(X).\n    return false;\n  }\n\n  /// Reciprocal estimate status values used by the functions below.\n  enum ReciprocalEstimate : int {\n    Unspecified = -1,\n    Disabled = 0,\n    Enabled = 1\n  };\n\n  /// Return a ReciprocalEstimate enum value for a square root of the given type\n  /// based on the function's attributes. If the operation is not overridden by\n  /// the function's attributes, \"Unspecified\" is returned and target defaults\n  /// are expected to be used for instruction selection.\n  int getRecipEstimateSqrtEnabled(EVT VT, MachineFunction &MF) const;\n\n  /// Return a ReciprocalEstimate enum value for a division of the given type\n  /// based on the function's attributes. If the operation is not overridden by\n  /// the function's attributes, \"Unspecified\" is returned and target defaults\n  /// are expected to be used for instruction selection.\n  int getRecipEstimateDivEnabled(EVT VT, MachineFunction &MF) const;\n\n  /// Return the refinement step count for a square root of the given type based\n  /// on the function's attributes. If the operation is not overridden by\n  /// the function's attributes, \"Unspecified\" is returned and target defaults\n  /// are expected to be used for instruction selection.\n  int getSqrtRefinementSteps(EVT VT, MachineFunction &MF) const;\n\n  /// Return the refinement step count for a division of the given type based\n  /// on the function's attributes. If the operation is not overridden by\n  /// the function's attributes, \"Unspecified\" is returned and target defaults\n  /// are expected to be used for instruction selection.\n  int getDivRefinementSteps(EVT VT, MachineFunction &MF) const;\n\n  /// Returns true if target has indicated at least one type should be bypassed.\n  bool isSlowDivBypassed() const { return !BypassSlowDivWidths.empty(); }\n\n  /// Returns map of slow types for division or remainder with corresponding\n  /// fast types\n  const DenseMap<unsigned int, unsigned int> &getBypassSlowDivWidths() const {\n    return BypassSlowDivWidths;\n  }\n\n  /// Return true if Flow Control is an expensive operation that should be\n  /// avoided.\n  bool isJumpExpensive() const { return JumpIsExpensive; }\n\n  /// Return true if selects are only cheaper than branches if the branch is\n  /// unlikely to be predicted right.\n  bool isPredictableSelectExpensive() const {\n    return PredictableSelectIsExpensive;\n  }\n\n  virtual bool fallBackToDAGISel(const Instruction &Inst) const {\n    return false;\n  }\n\n  /// If a branch or a select condition is skewed in one direction by more than\n  /// this factor, it is very likely to be predicted correctly.\n  virtual BranchProbability getPredictableBranchThreshold() const;\n\n  /// Return true if the following transform is beneficial:\n  /// fold (conv (load x)) -> (load (conv*)x)\n  /// On architectures that don't natively support some vector loads\n  /// efficiently, casting the load to a smaller vector of larger types and\n  /// loading is more efficient, however, this can be undone by optimizations in\n  /// dag combiner.\n  virtual bool isLoadBitCastBeneficial(EVT LoadVT, EVT BitcastVT,\n                                       const SelectionDAG &DAG,\n                                       const MachineMemOperand &MMO) const {\n    // Don't do if we could do an indexed load on the original type, but not on\n    // the new one.\n    if (!LoadVT.isSimple() || !BitcastVT.isSimple())\n      return true;\n\n    MVT LoadMVT = LoadVT.getSimpleVT();\n\n    // Don't bother doing this if it's just going to be promoted again later, as\n    // doing so might interfere with other combines.\n    if (getOperationAction(ISD::LOAD, LoadMVT) == Promote &&\n        getTypeToPromoteTo(ISD::LOAD, LoadMVT) == BitcastVT.getSimpleVT())\n      return false;\n\n    bool Fast = false;\n    return allowsMemoryAccess(*DAG.getContext(), DAG.getDataLayout(), BitcastVT,\n                              MMO, &Fast) && Fast;\n  }\n\n  /// Return true if the following transform is beneficial:\n  /// (store (y (conv x)), y*)) -> (store x, (x*))\n  virtual bool isStoreBitCastBeneficial(EVT StoreVT, EVT BitcastVT,\n                                        const SelectionDAG &DAG,\n                                        const MachineMemOperand &MMO) const {\n    // Default to the same logic as loads.\n    return isLoadBitCastBeneficial(StoreVT, BitcastVT, DAG, MMO);\n  }\n\n  /// Return true if it is expected to be cheaper to do a store of a non-zero\n  /// vector constant with the given size and type for the address space than to\n  /// store the individual scalar element constants.\n  virtual bool storeOfVectorConstantIsCheap(EVT MemVT,\n                                            unsigned NumElem,\n                                            unsigned AddrSpace) const {\n    return false;\n  }\n\n  /// Allow store merging for the specified type after legalization in addition\n  /// to before legalization. This may transform stores that do not exist\n  /// earlier (for example, stores created from intrinsics).\n  virtual bool mergeStoresAfterLegalization(EVT MemVT) const {\n    return true;\n  }\n\n  /// Returns if it's reasonable to merge stores to MemVT size.\n  virtual bool canMergeStoresTo(unsigned AS, EVT MemVT,\n                                const SelectionDAG &DAG) const {\n    return true;\n  }\n\n  /// Return true if it is cheap to speculate a call to intrinsic cttz.\n  virtual bool isCheapToSpeculateCttz() const {\n    return false;\n  }\n\n  /// Return true if it is cheap to speculate a call to intrinsic ctlz.\n  virtual bool isCheapToSpeculateCtlz() const {\n    return false;\n  }\n\n  /// Return true if ctlz instruction is fast.\n  virtual bool isCtlzFast() const {\n    return false;\n  }\n\n  /// Return the maximum number of \"x & (x - 1)\" operations that can be done\n  /// instead of deferring to a custom CTPOP.\n  virtual unsigned getCustomCtpopCost(EVT VT, ISD::CondCode Cond) const {\n    return 1;\n  }\n\n  /// Return true if instruction generated for equality comparison is folded\n  /// with instruction generated for signed comparison.\n  virtual bool isEqualityCmpFoldedWithSignedCmp() const { return true; }\n\n  /// Return true if it is safe to transform an integer-domain bitwise operation\n  /// into the equivalent floating-point operation. This should be set to true\n  /// if the target has IEEE-754-compliant fabs/fneg operations for the input\n  /// type.\n  virtual bool hasBitPreservingFPLogic(EVT VT) const {\n    return false;\n  }\n\n  /// Return true if it is cheaper to split the store of a merged int val\n  /// from a pair of smaller values into multiple stores.\n  virtual bool isMultiStoresCheaperThanBitsMerge(EVT LTy, EVT HTy) const {\n    return false;\n  }\n\n  /// Return if the target supports combining a\n  /// chain like:\n  /// \\code\n  ///   %andResult = and %val1, #mask\n  ///   %icmpResult = icmp %andResult, 0\n  /// \\endcode\n  /// into a single machine instruction of a form like:\n  /// \\code\n  ///   cc = test %register, #mask\n  /// \\endcode\n  virtual bool isMaskAndCmp0FoldingBeneficial(const Instruction &AndI) const {\n    return false;\n  }\n\n  /// Use bitwise logic to make pairs of compares more efficient. For example:\n  /// and (seteq A, B), (seteq C, D) --> seteq (or (xor A, B), (xor C, D)), 0\n  /// This should be true when it takes more than one instruction to lower\n  /// setcc (cmp+set on x86 scalar), when bitwise ops are faster than logic on\n  /// condition bits (crand on PowerPC), and/or when reducing cmp+br is a win.\n  virtual bool convertSetCCLogicToBitwiseLogic(EVT VT) const {\n    return false;\n  }\n\n  /// Return the preferred operand type if the target has a quick way to compare\n  /// integer values of the given size. Assume that any legal integer type can\n  /// be compared efficiently. Targets may override this to allow illegal wide\n  /// types to return a vector type if there is support to compare that type.\n  virtual MVT hasFastEqualityCompare(unsigned NumBits) const {\n    MVT VT = MVT::getIntegerVT(NumBits);\n    return isTypeLegal(VT) ? VT : MVT::INVALID_SIMPLE_VALUE_TYPE;\n  }\n\n  /// Return true if the target should transform:\n  /// (X & Y) == Y ---> (~X & Y) == 0\n  /// (X & Y) != Y ---> (~X & Y) != 0\n  ///\n  /// This may be profitable if the target has a bitwise and-not operation that\n  /// sets comparison flags. A target may want to limit the transformation based\n  /// on the type of Y or if Y is a constant.\n  ///\n  /// Note that the transform will not occur if Y is known to be a power-of-2\n  /// because a mask and compare of a single bit can be handled by inverting the\n  /// predicate, for example:\n  /// (X & 8) == 8 ---> (X & 8) != 0\n  virtual bool hasAndNotCompare(SDValue Y) const {\n    return false;\n  }\n\n  /// Return true if the target has a bitwise and-not operation:\n  /// X = ~A & B\n  /// This can be used to simplify select or other instructions.\n  virtual bool hasAndNot(SDValue X) const {\n    // If the target has the more complex version of this operation, assume that\n    // it has this operation too.\n    return hasAndNotCompare(X);\n  }\n\n  /// Return true if the target has a bit-test instruction:\n  ///   (X & (1 << Y)) ==/!= 0\n  /// This knowledge can be used to prevent breaking the pattern,\n  /// or creating it if it could be recognized.\n  virtual bool hasBitTest(SDValue X, SDValue Y) const { return false; }\n\n  /// There are two ways to clear extreme bits (either low or high):\n  /// Mask:    x &  (-1 << y)  (the instcombine canonical form)\n  /// Shifts:  x >> y << y\n  /// Return true if the variant with 2 variable shifts is preferred.\n  /// Return false if there is no preference.\n  virtual bool shouldFoldMaskToVariableShiftPair(SDValue X) const {\n    // By default, let's assume that no one prefers shifts.\n    return false;\n  }\n\n  /// Return true if it is profitable to fold a pair of shifts into a mask.\n  /// This is usually true on most targets. But some targets, like Thumb1,\n  /// have immediate shift instructions, but no immediate \"and\" instruction;\n  /// this makes the fold unprofitable.\n  virtual bool shouldFoldConstantShiftPairToMask(const SDNode *N,\n                                                 CombineLevel Level) const {\n    return true;\n  }\n\n  /// Should we tranform the IR-optimal check for whether given truncation\n  /// down into KeptBits would be truncating or not:\n  ///   (add %x, (1 << (KeptBits-1))) srccond (1 << KeptBits)\n  /// Into it's more traditional form:\n  ///   ((%x << C) a>> C) dstcond %x\n  /// Return true if we should transform.\n  /// Return false if there is no preference.\n  virtual bool shouldTransformSignedTruncationCheck(EVT XVT,\n                                                    unsigned KeptBits) const {\n    // By default, let's assume that no one prefers shifts.\n    return false;\n  }\n\n  /// Given the pattern\n  ///   (X & (C l>>/<< Y)) ==/!= 0\n  /// return true if it should be transformed into:\n  ///   ((X <</l>> Y) & C) ==/!= 0\n  /// WARNING: if 'X' is a constant, the fold may deadlock!\n  /// FIXME: we could avoid passing XC, but we can't use isConstOrConstSplat()\n  ///        here because it can end up being not linked in.\n  virtual bool shouldProduceAndByConstByHoistingConstFromShiftsLHSOfAnd(\n      SDValue X, ConstantSDNode *XC, ConstantSDNode *CC, SDValue Y,\n      unsigned OldShiftOpcode, unsigned NewShiftOpcode,\n      SelectionDAG &DAG) const {\n    if (hasBitTest(X, Y)) {\n      // One interesting pattern that we'd want to form is 'bit test':\n      //   ((1 << Y) & C) ==/!= 0\n      // But we also need to be careful not to try to reverse that fold.\n\n      // Is this '1 << Y' ?\n      if (OldShiftOpcode == ISD::SHL && CC->isOne())\n        return false; // Keep the 'bit test' pattern.\n\n      // Will it be '1 << Y' after the transform ?\n      if (XC && NewShiftOpcode == ISD::SHL && XC->isOne())\n        return true; // Do form the 'bit test' pattern.\n    }\n\n    // If 'X' is a constant, and we transform, then we will immediately\n    // try to undo the fold, thus causing endless combine loop.\n    // So by default, let's assume everyone prefers the fold\n    // iff 'X' is not a constant.\n    return !XC;\n  }\n\n  /// These two forms are equivalent:\n  ///   sub %y, (xor %x, -1)\n  ///   add (add %x, 1), %y\n  /// The variant with two add's is IR-canonical.\n  /// Some targets may prefer one to the other.\n  virtual bool preferIncOfAddToSubOfNot(EVT VT) const {\n    // By default, let's assume that everyone prefers the form with two add's.\n    return true;\n  }\n\n  /// Return true if the target wants to use the optimization that\n  /// turns ext(promotableInst1(...(promotableInstN(load)))) into\n  /// promotedInst1(...(promotedInstN(ext(load)))).\n  bool enableExtLdPromotion() const { return EnableExtLdPromotion; }\n\n  /// Return true if the target can combine store(extractelement VectorTy,\n  /// Idx).\n  /// \\p Cost[out] gives the cost of that transformation when this is true.\n  virtual bool canCombineStoreAndExtract(Type *VectorTy, Value *Idx,\n                                         unsigned &Cost) const {\n    return false;\n  }\n\n  /// Return true if inserting a scalar into a variable element of an undef\n  /// vector is more efficiently handled by splatting the scalar instead.\n  virtual bool shouldSplatInsEltVarIndex(EVT) const {\n    return false;\n  }\n\n  /// Return true if target always beneficiates from combining into FMA for a\n  /// given value type. This must typically return false on targets where FMA\n  /// takes more cycles to execute than FADD.\n  virtual bool enableAggressiveFMAFusion(EVT VT) const {\n    return false;\n  }\n\n  /// Return the ValueType of the result of SETCC operations.\n  virtual EVT getSetCCResultType(const DataLayout &DL, LLVMContext &Context,\n                                 EVT VT) const;\n\n  /// Return the ValueType for comparison libcalls. Comparions libcalls include\n  /// floating point comparion calls, and Ordered/Unordered check calls on\n  /// floating point numbers.\n  virtual\n  MVT::SimpleValueType getCmpLibcallReturnType() const;\n\n  /// For targets without i1 registers, this gives the nature of the high-bits\n  /// of boolean values held in types wider than i1.\n  ///\n  /// \"Boolean values\" are special true/false values produced by nodes like\n  /// SETCC and consumed (as the condition) by nodes like SELECT and BRCOND.\n  /// Not to be confused with general values promoted from i1.  Some cpus\n  /// distinguish between vectors of boolean and scalars; the isVec parameter\n  /// selects between the two kinds.  For example on X86 a scalar boolean should\n  /// be zero extended from i1, while the elements of a vector of booleans\n  /// should be sign extended from i1.\n  ///\n  /// Some cpus also treat floating point types the same way as they treat\n  /// vectors instead of the way they treat scalars.\n  BooleanContent getBooleanContents(bool isVec, bool isFloat) const {\n    if (isVec)\n      return BooleanVectorContents;\n    return isFloat ? BooleanFloatContents : BooleanContents;\n  }\n\n  BooleanContent getBooleanContents(EVT Type) const {\n    return getBooleanContents(Type.isVector(), Type.isFloatingPoint());\n  }\n\n  /// Return target scheduling preference.\n  Sched::Preference getSchedulingPreference() const {\n    return SchedPreferenceInfo;\n  }\n\n  /// Some scheduler, e.g. hybrid, can switch to different scheduling heuristics\n  /// for different nodes. This function returns the preference (or none) for\n  /// the given node.\n  virtual Sched::Preference getSchedulingPreference(SDNode *) const {\n    return Sched::None;\n  }\n\n  /// Return the register class that should be used for the specified value\n  /// type.\n  virtual const TargetRegisterClass *getRegClassFor(MVT VT, bool isDivergent = false) const {\n    (void)isDivergent;\n    const TargetRegisterClass *RC = RegClassForVT[VT.SimpleTy];\n    assert(RC && \"This value type is not natively supported!\");\n    return RC;\n  }\n\n  /// Allows target to decide about the register class of the\n  /// specific value that is live outside the defining block.\n  /// Returns true if the value needs uniform register class.\n  virtual bool requiresUniformRegister(MachineFunction &MF,\n                                       const Value *) const {\n    return false;\n  }\n\n  /// Return the 'representative' register class for the specified value\n  /// type.\n  ///\n  /// The 'representative' register class is the largest legal super-reg\n  /// register class for the register class of the value type.  For example, on\n  /// i386 the rep register class for i8, i16, and i32 are GR32; while the rep\n  /// register class is GR64 on x86_64.\n  virtual const TargetRegisterClass *getRepRegClassFor(MVT VT) const {\n    const TargetRegisterClass *RC = RepRegClassForVT[VT.SimpleTy];\n    return RC;\n  }\n\n  /// Return the cost of the 'representative' register class for the specified\n  /// value type.\n  virtual uint8_t getRepRegClassCostFor(MVT VT) const {\n    return RepRegClassCostForVT[VT.SimpleTy];\n  }\n\n  /// Return true if SHIFT instructions should be expanded to SHIFT_PARTS\n  /// instructions, and false if a library call is preferred (e.g for code-size\n  /// reasons).\n  virtual bool shouldExpandShift(SelectionDAG &DAG, SDNode *N) const {\n    return true;\n  }\n\n  /// Return true if the target has native support for the specified value type.\n  /// This means that it has a register that directly holds it without\n  /// promotions or expansions.\n  bool isTypeLegal(EVT VT) const {\n    assert(!VT.isSimple() ||\n           (unsigned)VT.getSimpleVT().SimpleTy < array_lengthof(RegClassForVT));\n    return VT.isSimple() && RegClassForVT[VT.getSimpleVT().SimpleTy] != nullptr;\n  }\n\n  class ValueTypeActionImpl {\n    /// ValueTypeActions - For each value type, keep a LegalizeTypeAction enum\n    /// that indicates how instruction selection should deal with the type.\n    LegalizeTypeAction ValueTypeActions[MVT::LAST_VALUETYPE];\n\n  public:\n    ValueTypeActionImpl() {\n      std::fill(std::begin(ValueTypeActions), std::end(ValueTypeActions),\n                TypeLegal);\n    }\n\n    LegalizeTypeAction getTypeAction(MVT VT) const {\n      return ValueTypeActions[VT.SimpleTy];\n    }\n\n    void setTypeAction(MVT VT, LegalizeTypeAction Action) {\n      ValueTypeActions[VT.SimpleTy] = Action;\n    }\n  };\n\n  const ValueTypeActionImpl &getValueTypeActions() const {\n    return ValueTypeActions;\n  }\n\n  /// Return how we should legalize values of this type, either it is already\n  /// legal (return 'Legal') or we need to promote it to a larger type (return\n  /// 'Promote'), or we need to expand it into multiple registers of smaller\n  /// integer type (return 'Expand').  'Custom' is not an option.\n  LegalizeTypeAction getTypeAction(LLVMContext &Context, EVT VT) const {\n    return getTypeConversion(Context, VT).first;\n  }\n  LegalizeTypeAction getTypeAction(MVT VT) const {\n    return ValueTypeActions.getTypeAction(VT);\n  }\n\n  /// For types supported by the target, this is an identity function.  For\n  /// types that must be promoted to larger types, this returns the larger type\n  /// to promote to.  For integer types that are larger than the largest integer\n  /// register, this contains one step in the expansion to get to the smaller\n  /// register. For illegal floating point types, this returns the integer type\n  /// to transform to.\n  EVT getTypeToTransformTo(LLVMContext &Context, EVT VT) const {\n    return getTypeConversion(Context, VT).second;\n  }\n\n  /// For types supported by the target, this is an identity function.  For\n  /// types that must be expanded (i.e. integer types that are larger than the\n  /// largest integer register or illegal floating point types), this returns\n  /// the largest legal type it will be expanded to.\n  EVT getTypeToExpandTo(LLVMContext &Context, EVT VT) const {\n    assert(!VT.isVector());\n    while (true) {\n      switch (getTypeAction(Context, VT)) {\n      case TypeLegal:\n        return VT;\n      case TypeExpandInteger:\n        VT = getTypeToTransformTo(Context, VT);\n        break;\n      default:\n        llvm_unreachable(\"Type is not legal nor is it to be expanded!\");\n      }\n    }\n  }\n\n  /// Vector types are broken down into some number of legal first class types.\n  /// For example, EVT::v8f32 maps to 2 EVT::v4f32 with Altivec or SSE1, or 8\n  /// promoted EVT::f64 values with the X86 FP stack.  Similarly, EVT::v2i64\n  /// turns into 4 EVT::i32 values with both PPC and X86.\n  ///\n  /// This method returns the number of registers needed, and the VT for each\n  /// register.  It also returns the VT and quantity of the intermediate values\n  /// before they are promoted/expanded.\n  unsigned getVectorTypeBreakdown(LLVMContext &Context, EVT VT,\n                                  EVT &IntermediateVT,\n                                  unsigned &NumIntermediates,\n                                  MVT &RegisterVT) const;\n\n  /// Certain targets such as MIPS require that some types such as vectors are\n  /// always broken down into scalars in some contexts. This occurs even if the\n  /// vector type is legal.\n  virtual unsigned getVectorTypeBreakdownForCallingConv(\n      LLVMContext &Context, CallingConv::ID CC, EVT VT, EVT &IntermediateVT,\n      unsigned &NumIntermediates, MVT &RegisterVT) const {\n    return getVectorTypeBreakdown(Context, VT, IntermediateVT, NumIntermediates,\n                                  RegisterVT);\n  }\n\n  struct IntrinsicInfo {\n    unsigned     opc = 0;          // target opcode\n    EVT          memVT;            // memory VT\n\n    // value representing memory location\n    PointerUnion<const Value *, const PseudoSourceValue *> ptrVal;\n\n    int          offset = 0;       // offset off of ptrVal\n    uint64_t     size = 0;         // the size of the memory location\n                                   // (taken from memVT if zero)\n    MaybeAlign align = Align(1);   // alignment\n\n    MachineMemOperand::Flags flags = MachineMemOperand::MONone;\n    IntrinsicInfo() = default;\n  };\n\n  /// Given an intrinsic, checks if on the target the intrinsic will need to map\n  /// to a MemIntrinsicNode (touches memory). If this is the case, it returns\n  /// true and store the intrinsic information into the IntrinsicInfo that was\n  /// passed to the function.\n  virtual bool getTgtMemIntrinsic(IntrinsicInfo &, const CallInst &,\n                                  MachineFunction &,\n                                  unsigned /*Intrinsic*/) const {\n    return false;\n  }\n\n  /// Returns true if the target can instruction select the specified FP\n  /// immediate natively. If false, the legalizer will materialize the FP\n  /// immediate as a load from a constant pool.\n  virtual bool isFPImmLegal(const APFloat & /*Imm*/, EVT /*VT*/,\n                            bool ForCodeSize = false) const {\n    return false;\n  }\n\n  /// Targets can use this to indicate that they only support *some*\n  /// VECTOR_SHUFFLE operations, those with specific masks.  By default, if a\n  /// target supports the VECTOR_SHUFFLE node, all mask values are assumed to be\n  /// legal.\n  virtual bool isShuffleMaskLegal(ArrayRef<int> /*Mask*/, EVT /*VT*/) const {\n    return true;\n  }\n\n  /// Returns true if the operation can trap for the value type.\n  ///\n  /// VT must be a legal type. By default, we optimistically assume most\n  /// operations don't trap except for integer divide and remainder.\n  virtual bool canOpTrap(unsigned Op, EVT VT) const;\n\n  /// Similar to isShuffleMaskLegal. Targets can use this to indicate if there\n  /// is a suitable VECTOR_SHUFFLE that can be used to replace a VAND with a\n  /// constant pool entry.\n  virtual bool isVectorClearMaskLegal(ArrayRef<int> /*Mask*/,\n                                      EVT /*VT*/) const {\n    return false;\n  }\n\n  /// Return how this operation should be treated: either it is legal, needs to\n  /// be promoted to a larger size, needs to be expanded to some other code\n  /// sequence, or the target has a custom expander for it.\n  LegalizeAction getOperationAction(unsigned Op, EVT VT) const {\n    if (VT.isExtended()) return Expand;\n    // If a target-specific SDNode requires legalization, require the target\n    // to provide custom legalization for it.\n    if (Op >= array_lengthof(OpActions[0])) return Custom;\n    return OpActions[(unsigned)VT.getSimpleVT().SimpleTy][Op];\n  }\n\n  /// Custom method defined by each target to indicate if an operation which\n  /// may require a scale is supported natively by the target.\n  /// If not, the operation is illegal.\n  virtual bool isSupportedFixedPointOperation(unsigned Op, EVT VT,\n                                              unsigned Scale) const {\n    return false;\n  }\n\n  /// Some fixed point operations may be natively supported by the target but\n  /// only for specific scales. This method allows for checking\n  /// if the width is supported by the target for a given operation that may\n  /// depend on scale.\n  LegalizeAction getFixedPointOperationAction(unsigned Op, EVT VT,\n                                              unsigned Scale) const {\n    auto Action = getOperationAction(Op, VT);\n    if (Action != Legal)\n      return Action;\n\n    // This operation is supported in this type but may only work on specific\n    // scales.\n    bool Supported;\n    switch (Op) {\n    default:\n      llvm_unreachable(\"Unexpected fixed point operation.\");\n    case ISD::SMULFIX:\n    case ISD::SMULFIXSAT:\n    case ISD::UMULFIX:\n    case ISD::UMULFIXSAT:\n    case ISD::SDIVFIX:\n    case ISD::SDIVFIXSAT:\n    case ISD::UDIVFIX:\n    case ISD::UDIVFIXSAT:\n      Supported = isSupportedFixedPointOperation(Op, VT, Scale);\n      break;\n    }\n\n    return Supported ? Action : Expand;\n  }\n\n  // If Op is a strict floating-point operation, return the result\n  // of getOperationAction for the equivalent non-strict operation.\n  LegalizeAction getStrictFPOperationAction(unsigned Op, EVT VT) const {\n    unsigned EqOpc;\n    switch (Op) {\n      default: llvm_unreachable(\"Unexpected FP pseudo-opcode\");\n#define DAG_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \\\n      case ISD::STRICT_##DAGN: EqOpc = ISD::DAGN; break;\n#define CMP_INSTRUCTION(NAME, NARG, ROUND_MODE, INTRINSIC, DAGN)               \\\n      case ISD::STRICT_##DAGN: EqOpc = ISD::SETCC; break;\n#include \"llvm/IR/ConstrainedOps.def\"\n    }\n\n    return getOperationAction(EqOpc, VT);\n  }\n\n  /// Return true if the specified operation is legal on this target or can be\n  /// made legal with custom lowering. This is used to help guide high-level\n  /// lowering decisions. LegalOnly is an optional convenience for code paths\n  /// traversed pre and post legalisation.\n  bool isOperationLegalOrCustom(unsigned Op, EVT VT,\n                                bool LegalOnly = false) const {\n    if (LegalOnly)\n      return isOperationLegal(Op, VT);\n\n    return (VT == MVT::Other || isTypeLegal(VT)) &&\n      (getOperationAction(Op, VT) == Legal ||\n       getOperationAction(Op, VT) == Custom);\n  }\n\n  /// Return true if the specified operation is legal on this target or can be\n  /// made legal using promotion. This is used to help guide high-level lowering\n  /// decisions. LegalOnly is an optional convenience for code paths traversed\n  /// pre and post legalisation.\n  bool isOperationLegalOrPromote(unsigned Op, EVT VT,\n                                 bool LegalOnly = false) const {\n    if (LegalOnly)\n      return isOperationLegal(Op, VT);\n\n    return (VT == MVT::Other || isTypeLegal(VT)) &&\n      (getOperationAction(Op, VT) == Legal ||\n       getOperationAction(Op, VT) == Promote);\n  }\n\n  /// Return true if the specified operation is legal on this target or can be\n  /// made legal with custom lowering or using promotion. This is used to help\n  /// guide high-level lowering decisions. LegalOnly is an optional convenience\n  /// for code paths traversed pre and post legalisation.\n  bool isOperationLegalOrCustomOrPromote(unsigned Op, EVT VT,\n                                         bool LegalOnly = false) const {\n    if (LegalOnly)\n      return isOperationLegal(Op, VT);\n\n    return (VT == MVT::Other || isTypeLegal(VT)) &&\n      (getOperationAction(Op, VT) == Legal ||\n       getOperationAction(Op, VT) == Custom ||\n       getOperationAction(Op, VT) == Promote);\n  }\n\n  /// Return true if the operation uses custom lowering, regardless of whether\n  /// the type is legal or not.\n  bool isOperationCustom(unsigned Op, EVT VT) const {\n    return getOperationAction(Op, VT) == Custom;\n  }\n\n  /// Return true if lowering to a jump table is allowed.\n  virtual bool areJTsAllowed(const Function *Fn) const {\n    if (Fn->getFnAttribute(\"no-jump-tables\").getValueAsString() == \"true\")\n      return false;\n\n    return isOperationLegalOrCustom(ISD::BR_JT, MVT::Other) ||\n           isOperationLegalOrCustom(ISD::BRIND, MVT::Other);\n  }\n\n  /// Check whether the range [Low,High] fits in a machine word.\n  bool rangeFitsInWord(const APInt &Low, const APInt &High,\n                       const DataLayout &DL) const {\n    // FIXME: Using the pointer type doesn't seem ideal.\n    uint64_t BW = DL.getIndexSizeInBits(0u);\n    uint64_t Range = (High - Low).getLimitedValue(UINT64_MAX - 1) + 1;\n    return Range <= BW;\n  }\n\n  /// Return true if lowering to a jump table is suitable for a set of case\n  /// clusters which may contain \\p NumCases cases, \\p Range range of values.\n  virtual bool isSuitableForJumpTable(const SwitchInst *SI, uint64_t NumCases,\n                                      uint64_t Range, ProfileSummaryInfo *PSI,\n                                      BlockFrequencyInfo *BFI) const;\n\n  /// Return true if lowering to a bit test is suitable for a set of case\n  /// clusters which contains \\p NumDests unique destinations, \\p Low and\n  /// \\p High as its lowest and highest case values, and expects \\p NumCmps\n  /// case value comparisons. Check if the number of destinations, comparison\n  /// metric, and range are all suitable.\n  bool isSuitableForBitTests(unsigned NumDests, unsigned NumCmps,\n                             const APInt &Low, const APInt &High,\n                             const DataLayout &DL) const {\n    // FIXME: I don't think NumCmps is the correct metric: a single case and a\n    // range of cases both require only one branch to lower. Just looking at the\n    // number of clusters and destinations should be enough to decide whether to\n    // build bit tests.\n\n    // To lower a range with bit tests, the range must fit the bitwidth of a\n    // machine word.\n    if (!rangeFitsInWord(Low, High, DL))\n      return false;\n\n    // Decide whether it's profitable to lower this range with bit tests. Each\n    // destination requires a bit test and branch, and there is an overall range\n    // check branch. For a small number of clusters, separate comparisons might\n    // be cheaper, and for many destinations, splitting the range might be\n    // better.\n    return (NumDests == 1 && NumCmps >= 3) || (NumDests == 2 && NumCmps >= 5) ||\n           (NumDests == 3 && NumCmps >= 6);\n  }\n\n  /// Return true if the specified operation is illegal on this target or\n  /// unlikely to be made legal with custom lowering. This is used to help guide\n  /// high-level lowering decisions.\n  bool isOperationExpand(unsigned Op, EVT VT) const {\n    return (!isTypeLegal(VT) || getOperationAction(Op, VT) == Expand);\n  }\n\n  /// Return true if the specified operation is legal on this target.\n  bool isOperationLegal(unsigned Op, EVT VT) const {\n    return (VT == MVT::Other || isTypeLegal(VT)) &&\n           getOperationAction(Op, VT) == Legal;\n  }\n\n  /// Return how this load with extension should be treated: either it is legal,\n  /// needs to be promoted to a larger size, needs to be expanded to some other\n  /// code sequence, or the target has a custom expander for it.\n  LegalizeAction getLoadExtAction(unsigned ExtType, EVT ValVT,\n                                  EVT MemVT) const {\n    if (ValVT.isExtended() || MemVT.isExtended()) return Expand;\n    unsigned ValI = (unsigned) ValVT.getSimpleVT().SimpleTy;\n    unsigned MemI = (unsigned) MemVT.getSimpleVT().SimpleTy;\n    assert(ExtType < ISD::LAST_LOADEXT_TYPE && ValI < MVT::LAST_VALUETYPE &&\n           MemI < MVT::LAST_VALUETYPE && \"Table isn't big enough!\");\n    unsigned Shift = 4 * ExtType;\n    return (LegalizeAction)((LoadExtActions[ValI][MemI] >> Shift) & 0xf);\n  }\n\n  /// Return true if the specified load with extension is legal on this target.\n  bool isLoadExtLegal(unsigned ExtType, EVT ValVT, EVT MemVT) const {\n    return getLoadExtAction(ExtType, ValVT, MemVT) == Legal;\n  }\n\n  /// Return true if the specified load with extension is legal or custom\n  /// on this target.\n  bool isLoadExtLegalOrCustom(unsigned ExtType, EVT ValVT, EVT MemVT) const {\n    return getLoadExtAction(ExtType, ValVT, MemVT) == Legal ||\n           getLoadExtAction(ExtType, ValVT, MemVT) == Custom;\n  }\n\n  /// Return how this store with truncation should be treated: either it is\n  /// legal, needs to be promoted to a larger size, needs to be expanded to some\n  /// other code sequence, or the target has a custom expander for it.\n  LegalizeAction getTruncStoreAction(EVT ValVT, EVT MemVT) const {\n    if (ValVT.isExtended() || MemVT.isExtended()) return Expand;\n    unsigned ValI = (unsigned) ValVT.getSimpleVT().SimpleTy;\n    unsigned MemI = (unsigned) MemVT.getSimpleVT().SimpleTy;\n    assert(ValI < MVT::LAST_VALUETYPE && MemI < MVT::LAST_VALUETYPE &&\n           \"Table isn't big enough!\");\n    return TruncStoreActions[ValI][MemI];\n  }\n\n  /// Return true if the specified store with truncation is legal on this\n  /// target.\n  bool isTruncStoreLegal(EVT ValVT, EVT MemVT) const {\n    return isTypeLegal(ValVT) && getTruncStoreAction(ValVT, MemVT) == Legal;\n  }\n\n  /// Return true if the specified store with truncation has solution on this\n  /// target.\n  bool isTruncStoreLegalOrCustom(EVT ValVT, EVT MemVT) const {\n    return isTypeLegal(ValVT) &&\n      (getTruncStoreAction(ValVT, MemVT) == Legal ||\n       getTruncStoreAction(ValVT, MemVT) == Custom);\n  }\n\n  /// Return how the indexed load should be treated: either it is legal, needs\n  /// to be promoted to a larger size, needs to be expanded to some other code\n  /// sequence, or the target has a custom expander for it.\n  LegalizeAction getIndexedLoadAction(unsigned IdxMode, MVT VT) const {\n    return getIndexedModeAction(IdxMode, VT, IMAB_Load);\n  }\n\n  /// Return true if the specified indexed load is legal on this target.\n  bool isIndexedLoadLegal(unsigned IdxMode, EVT VT) const {\n    return VT.isSimple() &&\n      (getIndexedLoadAction(IdxMode, VT.getSimpleVT()) == Legal ||\n       getIndexedLoadAction(IdxMode, VT.getSimpleVT()) == Custom);\n  }\n\n  /// Return how the indexed store should be treated: either it is legal, needs\n  /// to be promoted to a larger size, needs to be expanded to some other code\n  /// sequence, or the target has a custom expander for it.\n  LegalizeAction getIndexedStoreAction(unsigned IdxMode, MVT VT) const {\n    return getIndexedModeAction(IdxMode, VT, IMAB_Store);\n  }\n\n  /// Return true if the specified indexed load is legal on this target.\n  bool isIndexedStoreLegal(unsigned IdxMode, EVT VT) const {\n    return VT.isSimple() &&\n      (getIndexedStoreAction(IdxMode, VT.getSimpleVT()) == Legal ||\n       getIndexedStoreAction(IdxMode, VT.getSimpleVT()) == Custom);\n  }\n\n  /// Return how the indexed load should be treated: either it is legal, needs\n  /// to be promoted to a larger size, needs to be expanded to some other code\n  /// sequence, or the target has a custom expander for it.\n  LegalizeAction getIndexedMaskedLoadAction(unsigned IdxMode, MVT VT) const {\n    return getIndexedModeAction(IdxMode, VT, IMAB_MaskedLoad);\n  }\n\n  /// Return true if the specified indexed load is legal on this target.\n  bool isIndexedMaskedLoadLegal(unsigned IdxMode, EVT VT) const {\n    return VT.isSimple() &&\n           (getIndexedMaskedLoadAction(IdxMode, VT.getSimpleVT()) == Legal ||\n            getIndexedMaskedLoadAction(IdxMode, VT.getSimpleVT()) == Custom);\n  }\n\n  /// Return how the indexed store should be treated: either it is legal, needs\n  /// to be promoted to a larger size, needs to be expanded to some other code\n  /// sequence, or the target has a custom expander for it.\n  LegalizeAction getIndexedMaskedStoreAction(unsigned IdxMode, MVT VT) const {\n    return getIndexedModeAction(IdxMode, VT, IMAB_MaskedStore);\n  }\n\n  /// Return true if the specified indexed load is legal on this target.\n  bool isIndexedMaskedStoreLegal(unsigned IdxMode, EVT VT) const {\n    return VT.isSimple() &&\n           (getIndexedMaskedStoreAction(IdxMode, VT.getSimpleVT()) == Legal ||\n            getIndexedMaskedStoreAction(IdxMode, VT.getSimpleVT()) == Custom);\n  }\n\n  /// Returns true if the index type for a masked gather/scatter requires\n  /// extending\n  virtual bool shouldExtendGSIndex(EVT VT, EVT &EltTy) const { return false; }\n\n  // Returns true if VT is a legal index type for masked gathers/scatters\n  // on this target\n  virtual bool shouldRemoveExtendFromGSIndex(EVT VT) const { return false; }\n\n  /// Return how the condition code should be treated: either it is legal, needs\n  /// to be expanded to some other code sequence, or the target has a custom\n  /// expander for it.\n  LegalizeAction\n  getCondCodeAction(ISD::CondCode CC, MVT VT) const {\n    assert((unsigned)CC < array_lengthof(CondCodeActions) &&\n           ((unsigned)VT.SimpleTy >> 3) < array_lengthof(CondCodeActions[0]) &&\n           \"Table isn't big enough!\");\n    // See setCondCodeAction for how this is encoded.\n    uint32_t Shift = 4 * (VT.SimpleTy & 0x7);\n    uint32_t Value = CondCodeActions[CC][VT.SimpleTy >> 3];\n    LegalizeAction Action = (LegalizeAction) ((Value >> Shift) & 0xF);\n    assert(Action != Promote && \"Can't promote condition code!\");\n    return Action;\n  }\n\n  /// Return true if the specified condition code is legal on this target.\n  bool isCondCodeLegal(ISD::CondCode CC, MVT VT) const {\n    return getCondCodeAction(CC, VT) == Legal;\n  }\n\n  /// Return true if the specified condition code is legal or custom on this\n  /// target.\n  bool isCondCodeLegalOrCustom(ISD::CondCode CC, MVT VT) const {\n    return getCondCodeAction(CC, VT) == Legal ||\n           getCondCodeAction(CC, VT) == Custom;\n  }\n\n  /// If the action for this operation is to promote, this method returns the\n  /// ValueType to promote to.\n  MVT getTypeToPromoteTo(unsigned Op, MVT VT) const {\n    assert(getOperationAction(Op, VT) == Promote &&\n           \"This operation isn't promoted!\");\n\n    // See if this has an explicit type specified.\n    std::map<std::pair<unsigned, MVT::SimpleValueType>,\n             MVT::SimpleValueType>::const_iterator PTTI =\n      PromoteToType.find(std::make_pair(Op, VT.SimpleTy));\n    if (PTTI != PromoteToType.end()) return PTTI->second;\n\n    assert((VT.isInteger() || VT.isFloatingPoint()) &&\n           \"Cannot autopromote this type, add it with AddPromotedToType.\");\n\n    MVT NVT = VT;\n    do {\n      NVT = (MVT::SimpleValueType)(NVT.SimpleTy+1);\n      assert(NVT.isInteger() == VT.isInteger() && NVT != MVT::isVoid &&\n             \"Didn't find type to promote to!\");\n    } while (!isTypeLegal(NVT) ||\n              getOperationAction(Op, NVT) == Promote);\n    return NVT;\n  }\n\n  /// Return the EVT corresponding to this LLVM type.  This is fixed by the LLVM\n  /// operations except for the pointer size.  If AllowUnknown is true, this\n  /// will return MVT::Other for types with no EVT counterpart (e.g. structs),\n  /// otherwise it will assert.\n  EVT getValueType(const DataLayout &DL, Type *Ty,\n                   bool AllowUnknown = false) const {\n    // Lower scalar pointers to native pointer types.\n    if (auto *PTy = dyn_cast<PointerType>(Ty))\n      return getPointerTy(DL, PTy->getAddressSpace());\n\n    if (auto *VTy = dyn_cast<VectorType>(Ty)) {\n      Type *EltTy = VTy->getElementType();\n      // Lower vectors of pointers to native pointer types.\n      if (auto *PTy = dyn_cast<PointerType>(EltTy)) {\n        EVT PointerTy(getPointerTy(DL, PTy->getAddressSpace()));\n        EltTy = PointerTy.getTypeForEVT(Ty->getContext());\n      }\n      return EVT::getVectorVT(Ty->getContext(), EVT::getEVT(EltTy, false),\n                              VTy->getElementCount());\n    }\n\n    return EVT::getEVT(Ty, AllowUnknown);\n  }\n\n  EVT getMemValueType(const DataLayout &DL, Type *Ty,\n                      bool AllowUnknown = false) const {\n    // Lower scalar pointers to native pointer types.\n    if (PointerType *PTy = dyn_cast<PointerType>(Ty))\n      return getPointerMemTy(DL, PTy->getAddressSpace());\n    else if (VectorType *VTy = dyn_cast<VectorType>(Ty)) {\n      Type *Elm = VTy->getElementType();\n      if (PointerType *PT = dyn_cast<PointerType>(Elm)) {\n        EVT PointerTy(getPointerMemTy(DL, PT->getAddressSpace()));\n        Elm = PointerTy.getTypeForEVT(Ty->getContext());\n      }\n      return EVT::getVectorVT(Ty->getContext(), EVT::getEVT(Elm, false),\n                              VTy->getElementCount());\n    }\n\n    return getValueType(DL, Ty, AllowUnknown);\n  }\n\n\n  /// Return the MVT corresponding to this LLVM type. See getValueType.\n  MVT getSimpleValueType(const DataLayout &DL, Type *Ty,\n                         bool AllowUnknown = false) const {\n    return getValueType(DL, Ty, AllowUnknown).getSimpleVT();\n  }\n\n  /// Return the desired alignment for ByVal or InAlloca aggregate function\n  /// arguments in the caller parameter area.  This is the actual alignment, not\n  /// its logarithm.\n  virtual unsigned getByValTypeAlignment(Type *Ty, const DataLayout &DL) const;\n\n  /// Return the type of registers that this ValueType will eventually require.\n  MVT getRegisterType(MVT VT) const {\n    assert((unsigned)VT.SimpleTy < array_lengthof(RegisterTypeForVT));\n    return RegisterTypeForVT[VT.SimpleTy];\n  }\n\n  /// Return the type of registers that this ValueType will eventually require.\n  MVT getRegisterType(LLVMContext &Context, EVT VT) const {\n    if (VT.isSimple()) {\n      assert((unsigned)VT.getSimpleVT().SimpleTy <\n                array_lengthof(RegisterTypeForVT));\n      return RegisterTypeForVT[VT.getSimpleVT().SimpleTy];\n    }\n    if (VT.isVector()) {\n      EVT VT1;\n      MVT RegisterVT;\n      unsigned NumIntermediates;\n      (void)getVectorTypeBreakdown(Context, VT, VT1,\n                                   NumIntermediates, RegisterVT);\n      return RegisterVT;\n    }\n    if (VT.isInteger()) {\n      return getRegisterType(Context, getTypeToTransformTo(Context, VT));\n    }\n    llvm_unreachable(\"Unsupported extended type!\");\n  }\n\n  /// Return the number of registers that this ValueType will eventually\n  /// require.\n  ///\n  /// This is one for any types promoted to live in larger registers, but may be\n  /// more than one for types (like i64) that are split into pieces.  For types\n  /// like i140, which are first promoted then expanded, it is the number of\n  /// registers needed to hold all the bits of the original type.  For an i140\n  /// on a 32 bit machine this means 5 registers.\n  unsigned getNumRegisters(LLVMContext &Context, EVT VT) const {\n    if (VT.isSimple()) {\n      assert((unsigned)VT.getSimpleVT().SimpleTy <\n                array_lengthof(NumRegistersForVT));\n      return NumRegistersForVT[VT.getSimpleVT().SimpleTy];\n    }\n    if (VT.isVector()) {\n      EVT VT1;\n      MVT VT2;\n      unsigned NumIntermediates;\n      return getVectorTypeBreakdown(Context, VT, VT1, NumIntermediates, VT2);\n    }\n    if (VT.isInteger()) {\n      unsigned BitWidth = VT.getSizeInBits();\n      unsigned RegWidth = getRegisterType(Context, VT).getSizeInBits();\n      return (BitWidth + RegWidth - 1) / RegWidth;\n    }\n    llvm_unreachable(\"Unsupported extended type!\");\n  }\n\n  /// Certain combinations of ABIs, Targets and features require that types\n  /// are legal for some operations and not for other operations.\n  /// For MIPS all vector types must be passed through the integer register set.\n  virtual MVT getRegisterTypeForCallingConv(LLVMContext &Context,\n                                            CallingConv::ID CC, EVT VT) const {\n    return getRegisterType(Context, VT);\n  }\n\n  /// Certain targets require unusual breakdowns of certain types. For MIPS,\n  /// this occurs when a vector type is used, as vector are passed through the\n  /// integer register set.\n  virtual unsigned getNumRegistersForCallingConv(LLVMContext &Context,\n                                                 CallingConv::ID CC,\n                                                 EVT VT) const {\n    return getNumRegisters(Context, VT);\n  }\n\n  /// Certain targets have context senstive alignment requirements, where one\n  /// type has the alignment requirement of another type.\n  virtual Align getABIAlignmentForCallingConv(Type *ArgTy,\n                                              DataLayout DL) const {\n    return DL.getABITypeAlign(ArgTy);\n  }\n\n  /// If true, then instruction selection should seek to shrink the FP constant\n  /// of the specified type to a smaller type in order to save space and / or\n  /// reduce runtime.\n  virtual bool ShouldShrinkFPConstant(EVT) const { return true; }\n\n  /// Return true if it is profitable to reduce a load to a smaller type.\n  /// Example: (i16 (trunc (i32 (load x))) -> i16 load x\n  virtual bool shouldReduceLoadWidth(SDNode *Load, ISD::LoadExtType ExtTy,\n                                     EVT NewVT) const {\n    // By default, assume that it is cheaper to extract a subvector from a wide\n    // vector load rather than creating multiple narrow vector loads.\n    if (NewVT.isVector() && !Load->hasOneUse())\n      return false;\n\n    return true;\n  }\n\n  /// When splitting a value of the specified type into parts, does the Lo\n  /// or Hi part come first?  This usually follows the endianness, except\n  /// for ppcf128, where the Hi part always comes first.\n  bool hasBigEndianPartOrdering(EVT VT, const DataLayout &DL) const {\n    return DL.isBigEndian() || VT == MVT::ppcf128;\n  }\n\n  /// If true, the target has custom DAG combine transformations that it can\n  /// perform for the specified node.\n  bool hasTargetDAGCombine(ISD::NodeType NT) const {\n    assert(unsigned(NT >> 3) < array_lengthof(TargetDAGCombineArray));\n    return TargetDAGCombineArray[NT >> 3] & (1 << (NT&7));\n  }\n\n  unsigned getGatherAllAliasesMaxDepth() const {\n    return GatherAllAliasesMaxDepth;\n  }\n\n  /// Returns the size of the platform's va_list object.\n  virtual unsigned getVaListSizeInBits(const DataLayout &DL) const {\n    return getPointerTy(DL).getSizeInBits();\n  }\n\n  /// Get maximum # of store operations permitted for llvm.memset\n  ///\n  /// This function returns the maximum number of store operations permitted\n  /// to replace a call to llvm.memset. The value is set by the target at the\n  /// performance threshold for such a replacement. If OptSize is true,\n  /// return the limit for functions that have OptSize attribute.\n  unsigned getMaxStoresPerMemset(bool OptSize) const {\n    return OptSize ? MaxStoresPerMemsetOptSize : MaxStoresPerMemset;\n  }\n\n  /// Get maximum # of store operations permitted for llvm.memcpy\n  ///\n  /// This function returns the maximum number of store operations permitted\n  /// to replace a call to llvm.memcpy. The value is set by the target at the\n  /// performance threshold for such a replacement. If OptSize is true,\n  /// return the limit for functions that have OptSize attribute.\n  unsigned getMaxStoresPerMemcpy(bool OptSize) const {\n    return OptSize ? MaxStoresPerMemcpyOptSize : MaxStoresPerMemcpy;\n  }\n\n  /// \\brief Get maximum # of store operations to be glued together\n  ///\n  /// This function returns the maximum number of store operations permitted\n  /// to glue together during lowering of llvm.memcpy. The value is set by\n  //  the target at the performance threshold for such a replacement.\n  virtual unsigned getMaxGluedStoresPerMemcpy() const {\n    return MaxGluedStoresPerMemcpy;\n  }\n\n  /// Get maximum # of load operations permitted for memcmp\n  ///\n  /// This function returns the maximum number of load operations permitted\n  /// to replace a call to memcmp. The value is set by the target at the\n  /// performance threshold for such a replacement. If OptSize is true,\n  /// return the limit for functions that have OptSize attribute.\n  unsigned getMaxExpandSizeMemcmp(bool OptSize) const {\n    return OptSize ? MaxLoadsPerMemcmpOptSize : MaxLoadsPerMemcmp;\n  }\n\n  /// Get maximum # of store operations permitted for llvm.memmove\n  ///\n  /// This function returns the maximum number of store operations permitted\n  /// to replace a call to llvm.memmove. The value is set by the target at the\n  /// performance threshold for such a replacement. If OptSize is true,\n  /// return the limit for functions that have OptSize attribute.\n  unsigned getMaxStoresPerMemmove(bool OptSize) const {\n    return OptSize ? MaxStoresPerMemmoveOptSize : MaxStoresPerMemmove;\n  }\n\n  /// Determine if the target supports unaligned memory accesses.\n  ///\n  /// This function returns true if the target allows unaligned memory accesses\n  /// of the specified type in the given address space. If true, it also returns\n  /// whether the unaligned memory access is \"fast\" in the last argument by\n  /// reference. This is used, for example, in situations where an array\n  /// copy/move/set is converted to a sequence of store operations. Its use\n  /// helps to ensure that such replacements don't generate code that causes an\n  /// alignment error (trap) on the target machine.\n  virtual bool allowsMisalignedMemoryAccesses(\n      EVT, unsigned AddrSpace = 0, Align Alignment = Align(1),\n      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,\n      bool * /*Fast*/ = nullptr) const {\n    return false;\n  }\n\n  /// LLT handling variant.\n  virtual bool allowsMisalignedMemoryAccesses(\n      LLT, unsigned AddrSpace = 0, Align Alignment = Align(1),\n      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,\n      bool * /*Fast*/ = nullptr) const {\n    return false;\n  }\n\n  /// This function returns true if the memory access is aligned or if the\n  /// target allows this specific unaligned memory access. If the access is\n  /// allowed, the optional final parameter returns if the access is also fast\n  /// (as defined by the target).\n  bool allowsMemoryAccessForAlignment(\n      LLVMContext &Context, const DataLayout &DL, EVT VT,\n      unsigned AddrSpace = 0, Align Alignment = Align(1),\n      MachineMemOperand::Flags Flags = MachineMemOperand::MONone,\n      bool *Fast = nullptr) const;\n\n  /// Return true if the memory access of this type is aligned or if the target\n  /// allows this specific unaligned access for the given MachineMemOperand.\n  /// If the access is allowed, the optional final parameter returns if the\n  /// access is also fast (as defined by the target).\n  bool allowsMemoryAccessForAlignment(LLVMContext &Context,\n                                      const DataLayout &DL, EVT VT,\n                                      const MachineMemOperand &MMO,\n                                      bool *Fast = nullptr) const;\n\n  /// Return true if the target supports a memory access of this type for the\n  /// given address space and alignment. If the access is allowed, the optional\n  /// final parameter returns if the access is also fast (as defined by the\n  /// target).\n  virtual bool\n  allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, EVT VT,\n                     unsigned AddrSpace = 0, Align Alignment = Align(1),\n                     MachineMemOperand::Flags Flags = MachineMemOperand::MONone,\n                     bool *Fast = nullptr) const;\n\n  /// Return true if the target supports a memory access of this type for the\n  /// given MachineMemOperand. If the access is allowed, the optional\n  /// final parameter returns if the access is also fast (as defined by the\n  /// target).\n  bool allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, EVT VT,\n                          const MachineMemOperand &MMO,\n                          bool *Fast = nullptr) const;\n\n  /// LLT handling variant.\n  bool allowsMemoryAccess(LLVMContext &Context, const DataLayout &DL, LLT Ty,\n                          const MachineMemOperand &MMO,\n                          bool *Fast = nullptr) const;\n\n  /// Returns the target specific optimal type for load and store operations as\n  /// a result of memset, memcpy, and memmove lowering.\n  /// It returns EVT::Other if the type should be determined using generic\n  /// target-independent logic.\n  virtual EVT\n  getOptimalMemOpType(const MemOp &Op,\n                      const AttributeList & /*FuncAttributes*/) const {\n    return MVT::Other;\n  }\n\n  /// LLT returning variant.\n  virtual LLT\n  getOptimalMemOpLLT(const MemOp &Op,\n                     const AttributeList & /*FuncAttributes*/) const {\n    return LLT();\n  }\n\n  /// Returns true if it's safe to use load / store of the specified type to\n  /// expand memcpy / memset inline.\n  ///\n  /// This is mostly true for all types except for some special cases. For\n  /// example, on X86 targets without SSE2 f64 load / store are done with fldl /\n  /// fstpl which also does type conversion. Note the specified type doesn't\n  /// have to be legal as the hook is used before type legalization.\n  virtual bool isSafeMemOpType(MVT /*VT*/) const { return true; }\n\n  /// Return lower limit for number of blocks in a jump table.\n  virtual unsigned getMinimumJumpTableEntries() const;\n\n  /// Return lower limit of the density in a jump table.\n  unsigned getMinimumJumpTableDensity(bool OptForSize) const;\n\n  /// Return upper limit for number of entries in a jump table.\n  /// Zero if no limit.\n  unsigned getMaximumJumpTableSize() const;\n\n  virtual bool isJumpTableRelative() const;\n\n  /// If a physical register, this specifies the register that\n  /// llvm.savestack/llvm.restorestack should save and restore.\n  Register getStackPointerRegisterToSaveRestore() const {\n    return StackPointerRegisterToSaveRestore;\n  }\n\n  /// If a physical register, this returns the register that receives the\n  /// exception address on entry to an EH pad.\n  virtual Register\n  getExceptionPointerRegister(const Constant *PersonalityFn) const {\n    return Register();\n  }\n\n  /// If a physical register, this returns the register that receives the\n  /// exception typeid on entry to a landing pad.\n  virtual Register\n  getExceptionSelectorRegister(const Constant *PersonalityFn) const {\n    return Register();\n  }\n\n  virtual bool needsFixedCatchObjects() const {\n    report_fatal_error(\"Funclet EH is not implemented for this target\");\n  }\n\n  /// Return the minimum stack alignment of an argument.\n  Align getMinStackArgumentAlignment() const {\n    return MinStackArgumentAlignment;\n  }\n\n  /// Return the minimum function alignment.\n  Align getMinFunctionAlignment() const { return MinFunctionAlignment; }\n\n  /// Return the preferred function alignment.\n  Align getPrefFunctionAlignment() const { return PrefFunctionAlignment; }\n\n  /// Return the preferred loop alignment.\n  virtual Align getPrefLoopAlignment(MachineLoop *ML = nullptr) const {\n    return PrefLoopAlignment;\n  }\n\n  /// Should loops be aligned even when the function is marked OptSize (but not\n  /// MinSize).\n  virtual bool alignLoopsWithOptSize() const {\n    return false;\n  }\n\n  /// If the target has a standard location for the stack protector guard,\n  /// returns the address of that location. Otherwise, returns nullptr.\n  /// DEPRECATED: please override useLoadStackGuardNode and customize\n  ///             LOAD_STACK_GUARD, or customize \\@llvm.stackguard().\n  virtual Value *getIRStackGuard(IRBuilder<> &IRB) const;\n\n  /// Inserts necessary declarations for SSP (stack protection) purpose.\n  /// Should be used only when getIRStackGuard returns nullptr.\n  virtual void insertSSPDeclarations(Module &M) const;\n\n  /// Return the variable that's previously inserted by insertSSPDeclarations,\n  /// if any, otherwise return nullptr. Should be used only when\n  /// getIRStackGuard returns nullptr.\n  virtual Value *getSDagStackGuard(const Module &M) const;\n\n  /// If this function returns true, stack protection checks should XOR the\n  /// frame pointer (or whichever pointer is used to address locals) into the\n  /// stack guard value before checking it. getIRStackGuard must return nullptr\n  /// if this returns true.\n  virtual bool useStackGuardXorFP() const { return false; }\n\n  /// If the target has a standard stack protection check function that\n  /// performs validation and error handling, returns the function. Otherwise,\n  /// returns nullptr. Must be previously inserted by insertSSPDeclarations.\n  /// Should be used only when getIRStackGuard returns nullptr.\n  virtual Function *getSSPStackGuardCheck(const Module &M) const;\n\nprotected:\n  Value *getDefaultSafeStackPointerLocation(IRBuilder<> &IRB,\n                                            bool UseTLS) const;\n\npublic:\n  /// Returns the target-specific address of the unsafe stack pointer.\n  virtual Value *getSafeStackPointerLocation(IRBuilder<> &IRB) const;\n\n  /// Returns the name of the symbol used to emit stack probes or the empty\n  /// string if not applicable.\n  virtual bool hasStackProbeSymbol(MachineFunction &MF) const { return false; }\n\n  virtual bool hasInlineStackProbe(MachineFunction &MF) const { return false; }\n\n  virtual StringRef getStackProbeSymbolName(MachineFunction &MF) const {\n    return \"\";\n  }\n\n  /// Returns true if a cast from SrcAS to DestAS is \"cheap\", such that e.g. we\n  /// are happy to sink it into basic blocks. A cast may be free, but not\n  /// necessarily a no-op. e.g. a free truncate from a 64-bit to 32-bit pointer.\n  virtual bool isFreeAddrSpaceCast(unsigned SrcAS, unsigned DestAS) const;\n\n  /// Return true if the pointer arguments to CI should be aligned by aligning\n  /// the object whose address is being passed. If so then MinSize is set to the\n  /// minimum size the object must be to be aligned and PrefAlign is set to the\n  /// preferred alignment.\n  virtual bool shouldAlignPointerArgs(CallInst * /*CI*/, unsigned & /*MinSize*/,\n                                      unsigned & /*PrefAlign*/) const {\n    return false;\n  }\n\n  //===--------------------------------------------------------------------===//\n  /// \\name Helpers for TargetTransformInfo implementations\n  /// @{\n\n  /// Get the ISD node that corresponds to the Instruction class opcode.\n  int InstructionOpcodeToISD(unsigned Opcode) const;\n\n  /// Estimate the cost of type-legalization and the legalized type.\n  std::pair<int, MVT> getTypeLegalizationCost(const DataLayout &DL,\n                                              Type *Ty) const;\n\n  /// @}\n\n  //===--------------------------------------------------------------------===//\n  /// \\name Helpers for atomic expansion.\n  /// @{\n\n  /// Returns the maximum atomic operation size (in bits) supported by\n  /// the backend. Atomic operations greater than this size (as well\n  /// as ones that are not naturally aligned), will be expanded by\n  /// AtomicExpandPass into an __atomic_* library call.\n  unsigned getMaxAtomicSizeInBitsSupported() const {\n    return MaxAtomicSizeInBitsSupported;\n  }\n\n  /// Returns the size of the smallest cmpxchg or ll/sc instruction\n  /// the backend supports.  Any smaller operations are widened in\n  /// AtomicExpandPass.\n  ///\n  /// Note that *unlike* operations above the maximum size, atomic ops\n  /// are still natively supported below the minimum; they just\n  /// require a more complex expansion.\n  unsigned getMinCmpXchgSizeInBits() const { return MinCmpXchgSizeInBits; }\n\n  /// Whether the target supports unaligned atomic operations.\n  bool supportsUnalignedAtomics() const { return SupportsUnalignedAtomics; }\n\n  /// Whether AtomicExpandPass should automatically insert fences and reduce\n  /// ordering for this atomic. This should be true for most architectures with\n  /// weak memory ordering. Defaults to false.\n  virtual bool shouldInsertFencesForAtomic(const Instruction *I) const {\n    return false;\n  }\n\n  /// Perform a load-linked operation on Addr, returning a \"Value *\" with the\n  /// corresponding pointee type. This may entail some non-trivial operations to\n  /// truncate or reconstruct types that will be illegal in the backend. See\n  /// ARMISelLowering for an example implementation.\n  virtual Value *emitLoadLinked(IRBuilder<> &Builder, Value *Addr,\n                                AtomicOrdering Ord) const {\n    llvm_unreachable(\"Load linked unimplemented on this target\");\n  }\n\n  /// Perform a store-conditional operation to Addr. Return the status of the\n  /// store. This should be 0 if the store succeeded, non-zero otherwise.\n  virtual Value *emitStoreConditional(IRBuilder<> &Builder, Value *Val,\n                                      Value *Addr, AtomicOrdering Ord) const {\n    llvm_unreachable(\"Store conditional unimplemented on this target\");\n  }\n\n  /// Perform a masked atomicrmw using a target-specific intrinsic. This\n  /// represents the core LL/SC loop which will be lowered at a late stage by\n  /// the backend.\n  virtual Value *emitMaskedAtomicRMWIntrinsic(IRBuilder<> &Builder,\n                                              AtomicRMWInst *AI,\n                                              Value *AlignedAddr, Value *Incr,\n                                              Value *Mask, Value *ShiftAmt,\n                                              AtomicOrdering Ord) const {\n    llvm_unreachable(\"Masked atomicrmw expansion unimplemented on this target\");\n  }\n\n  /// Perform a masked cmpxchg using a target-specific intrinsic. This\n  /// represents the core LL/SC loop which will be lowered at a late stage by\n  /// the backend.\n  virtual Value *emitMaskedAtomicCmpXchgIntrinsic(\n      IRBuilder<> &Builder, AtomicCmpXchgInst *CI, Value *AlignedAddr,\n      Value *CmpVal, Value *NewVal, Value *Mask, AtomicOrdering Ord) const {\n    llvm_unreachable(\"Masked cmpxchg expansion unimplemented on this target\");\n  }\n\n  /// Inserts in the IR a target-specific intrinsic specifying a fence.\n  /// It is called by AtomicExpandPass before expanding an\n  ///   AtomicRMW/AtomicCmpXchg/AtomicStore/AtomicLoad\n  ///   if shouldInsertFencesForAtomic returns true.\n  ///\n  /// Inst is the original atomic instruction, prior to other expansions that\n  /// may be performed.\n  ///\n  /// This function should either return a nullptr, or a pointer to an IR-level\n  ///   Instruction*. Even complex fence sequences can be represented by a\n  ///   single Instruction* through an intrinsic to be lowered later.\n  /// Backends should override this method to produce target-specific intrinsic\n  ///   for their fences.\n  /// FIXME: Please note that the default implementation here in terms of\n  ///   IR-level fences exists for historical/compatibility reasons and is\n  ///   *unsound* ! Fences cannot, in general, be used to restore sequential\n  ///   consistency. For example, consider the following example:\n  /// atomic<int> x = y = 0;\n  /// int r1, r2, r3, r4;\n  /// Thread 0:\n  ///   x.store(1);\n  /// Thread 1:\n  ///   y.store(1);\n  /// Thread 2:\n  ///   r1 = x.load();\n  ///   r2 = y.load();\n  /// Thread 3:\n  ///   r3 = y.load();\n  ///   r4 = x.load();\n  ///  r1 = r3 = 1 and r2 = r4 = 0 is impossible as long as the accesses are all\n  ///  seq_cst. But if they are lowered to monotonic accesses, no amount of\n  ///  IR-level fences can prevent it.\n  /// @{\n  virtual Instruction *emitLeadingFence(IRBuilder<> &Builder, Instruction *Inst,\n                                        AtomicOrdering Ord) const {\n    if (isReleaseOrStronger(Ord) && Inst->hasAtomicStore())\n      return Builder.CreateFence(Ord);\n    else\n      return nullptr;\n  }\n\n  virtual Instruction *emitTrailingFence(IRBuilder<> &Builder,\n                                         Instruction *Inst,\n                                         AtomicOrdering Ord) const {\n    if (isAcquireOrStronger(Ord))\n      return Builder.CreateFence(Ord);\n    else\n      return nullptr;\n  }\n  /// @}\n\n  // Emits code that executes when the comparison result in the ll/sc\n  // expansion of a cmpxchg instruction is such that the store-conditional will\n  // not execute.  This makes it possible to balance out the load-linked with\n  // a dedicated instruction, if desired.\n  // E.g., on ARM, if ldrex isn't followed by strex, the exclusive monitor would\n  // be unnecessarily held, except if clrex, inserted by this hook, is executed.\n  virtual void emitAtomicCmpXchgNoStoreLLBalance(IRBuilder<> &Builder) const {}\n\n  /// Returns true if the given (atomic) store should be expanded by the\n  /// IR-level AtomicExpand pass into an \"atomic xchg\" which ignores its input.\n  virtual bool shouldExpandAtomicStoreInIR(StoreInst *SI) const {\n    return false;\n  }\n\n  /// Returns true if arguments should be sign-extended in lib calls.\n  virtual bool shouldSignExtendTypeInLibCall(EVT Type, bool IsSigned) const {\n    return IsSigned;\n  }\n\n  /// Returns true if arguments should be extended in lib calls.\n  virtual bool shouldExtendTypeInLibCall(EVT Type) const {\n    return true;\n  }\n\n  /// Returns how the given (atomic) load should be expanded by the\n  /// IR-level AtomicExpand pass.\n  virtual AtomicExpansionKind shouldExpandAtomicLoadInIR(LoadInst *LI) const {\n    return AtomicExpansionKind::None;\n  }\n\n  /// Returns how the given atomic cmpxchg should be expanded by the IR-level\n  /// AtomicExpand pass.\n  virtual AtomicExpansionKind\n  shouldExpandAtomicCmpXchgInIR(AtomicCmpXchgInst *AI) const {\n    return AtomicExpansionKind::None;\n  }\n\n  /// Returns how the IR-level AtomicExpand pass should expand the given\n  /// AtomicRMW, if at all. Default is to never expand.\n  virtual AtomicExpansionKind shouldExpandAtomicRMWInIR(AtomicRMWInst *RMW) const {\n    return RMW->isFloatingPointOperation() ?\n      AtomicExpansionKind::CmpXChg : AtomicExpansionKind::None;\n  }\n\n  /// On some platforms, an AtomicRMW that never actually modifies the value\n  /// (such as fetch_add of 0) can be turned into a fence followed by an\n  /// atomic load. This may sound useless, but it makes it possible for the\n  /// processor to keep the cacheline shared, dramatically improving\n  /// performance. And such idempotent RMWs are useful for implementing some\n  /// kinds of locks, see for example (justification + benchmarks):\n  /// http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf\n  /// This method tries doing that transformation, returning the atomic load if\n  /// it succeeds, and nullptr otherwise.\n  /// If shouldExpandAtomicLoadInIR returns true on that load, it will undergo\n  /// another round of expansion.\n  virtual LoadInst *\n  lowerIdempotentRMWIntoFencedLoad(AtomicRMWInst *RMWI) const {\n    return nullptr;\n  }\n\n  /// Returns how the platform's atomic operations are extended (ZERO_EXTEND,\n  /// SIGN_EXTEND, or ANY_EXTEND).\n  virtual ISD::NodeType getExtendForAtomicOps() const {\n    return ISD::ZERO_EXTEND;\n  }\n\n  /// Returns how the platform's atomic compare and swap expects its comparison\n  /// value to be extended (ZERO_EXTEND, SIGN_EXTEND, or ANY_EXTEND). This is\n  /// separate from getExtendForAtomicOps, which is concerned with the\n  /// sign-extension of the instruction's output, whereas here we are concerned\n  /// with the sign-extension of the input. For targets with compare-and-swap\n  /// instructions (or sub-word comparisons in their LL/SC loop expansions),\n  /// the input can be ANY_EXTEND, but the output will still have a specific\n  /// extension.\n  virtual ISD::NodeType getExtendForAtomicCmpSwapArg() const {\n    return ISD::ANY_EXTEND;\n  }\n\n  /// @}\n\n  /// Returns true if we should normalize\n  /// select(N0&N1, X, Y) => select(N0, select(N1, X, Y), Y) and\n  /// select(N0|N1, X, Y) => select(N0, select(N1, X, Y, Y)) if it is likely\n  /// that it saves us from materializing N0 and N1 in an integer register.\n  /// Targets that are able to perform and/or on flags should return false here.\n  virtual bool shouldNormalizeToSelectSequence(LLVMContext &Context,\n                                               EVT VT) const {\n    // If a target has multiple condition registers, then it likely has logical\n    // operations on those registers.\n    if (hasMultipleConditionRegisters())\n      return false;\n    // Only do the transform if the value won't be split into multiple\n    // registers.\n    LegalizeTypeAction Action = getTypeAction(Context, VT);\n    return Action != TypeExpandInteger && Action != TypeExpandFloat &&\n      Action != TypeSplitVector;\n  }\n\n  virtual bool isProfitableToCombineMinNumMaxNum(EVT VT) const { return true; }\n\n  /// Return true if a select of constants (select Cond, C1, C2) should be\n  /// transformed into simple math ops with the condition value. For example:\n  /// select Cond, C1, C1-1 --> add (zext Cond), C1-1\n  virtual bool convertSelectOfConstantsToMath(EVT VT) const {\n    return false;\n  }\n\n  /// Return true if it is profitable to transform an integer\n  /// multiplication-by-constant into simpler operations like shifts and adds.\n  /// This may be true if the target does not directly support the\n  /// multiplication operation for the specified type or the sequence of simpler\n  /// ops is faster than the multiply.\n  virtual bool decomposeMulByConstant(LLVMContext &Context,\n                                      EVT VT, SDValue C) const {\n    return false;\n  }\n\n  /// Return true if it is more correct/profitable to use strict FP_TO_INT\n  /// conversion operations - canonicalizing the FP source value instead of\n  /// converting all cases and then selecting based on value.\n  /// This may be true if the target throws exceptions for out of bounds\n  /// conversions or has fast FP CMOV.\n  virtual bool shouldUseStrictFP_TO_INT(EVT FpVT, EVT IntVT,\n                                        bool IsSigned) const {\n    return false;\n  }\n\n  //===--------------------------------------------------------------------===//\n  // TargetLowering Configuration Methods - These methods should be invoked by\n  // the derived class constructor to configure this object for the target.\n  //\nprotected:\n  /// Specify how the target extends the result of integer and floating point\n  /// boolean values from i1 to a wider type.  See getBooleanContents.\n  void setBooleanContents(BooleanContent Ty) {\n    BooleanContents = Ty;\n    BooleanFloatContents = Ty;\n  }\n\n  /// Specify how the target extends the result of integer and floating point\n  /// boolean values from i1 to a wider type.  See getBooleanContents.\n  void setBooleanContents(BooleanContent IntTy, BooleanContent FloatTy) {\n    BooleanContents = IntTy;\n    BooleanFloatContents = FloatTy;\n  }\n\n  /// Specify how the target extends the result of a vector boolean value from a\n  /// vector of i1 to a wider type.  See getBooleanContents.\n  void setBooleanVectorContents(BooleanContent Ty) {\n    BooleanVectorContents = Ty;\n  }\n\n  /// Specify the target scheduling preference.\n  void setSchedulingPreference(Sched::Preference Pref) {\n    SchedPreferenceInfo = Pref;\n  }\n\n  /// Indicate the minimum number of blocks to generate jump tables.\n  void setMinimumJumpTableEntries(unsigned Val);\n\n  /// Indicate the maximum number of entries in jump tables.\n  /// Set to zero to generate unlimited jump tables.\n  void setMaximumJumpTableSize(unsigned);\n\n  /// If set to a physical register, this specifies the register that\n  /// llvm.savestack/llvm.restorestack should save and restore.\n  void setStackPointerRegisterToSaveRestore(Register R) {\n    StackPointerRegisterToSaveRestore = R;\n  }\n\n  /// Tells the code generator that the target has multiple (allocatable)\n  /// condition registers that can be used to store the results of comparisons\n  /// for use by selects and conditional branches. With multiple condition\n  /// registers, the code generator will not aggressively sink comparisons into\n  /// the blocks of their users.\n  void setHasMultipleConditionRegisters(bool hasManyRegs = true) {\n    HasMultipleConditionRegisters = hasManyRegs;\n  }\n\n  /// Tells the code generator that the target has BitExtract instructions.\n  /// The code generator will aggressively sink \"shift\"s into the blocks of\n  /// their users if the users will generate \"and\" instructions which can be\n  /// combined with \"shift\" to BitExtract instructions.\n  void setHasExtractBitsInsn(bool hasExtractInsn = true) {\n    HasExtractBitsInsn = hasExtractInsn;\n  }\n\n  /// Tells the code generator not to expand logic operations on comparison\n  /// predicates into separate sequences that increase the amount of flow\n  /// control.\n  void setJumpIsExpensive(bool isExpensive = true);\n\n  /// Tells the code generator which bitwidths to bypass.\n  void addBypassSlowDiv(unsigned int SlowBitWidth, unsigned int FastBitWidth) {\n    BypassSlowDivWidths[SlowBitWidth] = FastBitWidth;\n  }\n\n  /// Add the specified register class as an available regclass for the\n  /// specified value type. This indicates the selector can handle values of\n  /// that class natively.\n  void addRegisterClass(MVT VT, const TargetRegisterClass *RC) {\n    assert((unsigned)VT.SimpleTy < array_lengthof(RegClassForVT));\n    RegClassForVT[VT.SimpleTy] = RC;\n  }\n\n  /// Return the largest legal super-reg register class of the register class\n  /// for the specified type and its associated \"cost\".\n  virtual std::pair<const TargetRegisterClass *, uint8_t>\n  findRepresentativeClass(const TargetRegisterInfo *TRI, MVT VT) const;\n\n  /// Once all of the register classes are added, this allows us to compute\n  /// derived properties we expose.\n  void computeRegisterProperties(const TargetRegisterInfo *TRI);\n\n  /// Indicate that the specified operation does not work with the specified\n  /// type and indicate what to do about it. Note that VT may refer to either\n  /// the type of a result or that of an operand of Op.\n  void setOperationAction(unsigned Op, MVT VT,\n                          LegalizeAction Action) {\n    assert(Op < array_lengthof(OpActions[0]) && \"Table isn't big enough!\");\n    OpActions[(unsigned)VT.SimpleTy][Op] = Action;\n  }\n\n  /// Indicate that the specified load with extension does not work with the\n  /// specified type and indicate what to do about it.\n  void setLoadExtAction(unsigned ExtType, MVT ValVT, MVT MemVT,\n                        LegalizeAction Action) {\n    assert(ExtType < ISD::LAST_LOADEXT_TYPE && ValVT.isValid() &&\n           MemVT.isValid() && \"Table isn't big enough!\");\n    assert((unsigned)Action < 0x10 && \"too many bits for bitfield array\");\n    unsigned Shift = 4 * ExtType;\n    LoadExtActions[ValVT.SimpleTy][MemVT.SimpleTy] &= ~((uint16_t)0xF << Shift);\n    LoadExtActions[ValVT.SimpleTy][MemVT.SimpleTy] |= (uint16_t)Action << Shift;\n  }\n\n  /// Indicate that the specified truncating store does not work with the\n  /// specified type and indicate what to do about it.\n  void setTruncStoreAction(MVT ValVT, MVT MemVT,\n                           LegalizeAction Action) {\n    assert(ValVT.isValid() && MemVT.isValid() && \"Table isn't big enough!\");\n    TruncStoreActions[(unsigned)ValVT.SimpleTy][MemVT.SimpleTy] = Action;\n  }\n\n  /// Indicate that the specified indexed load does or does not work with the\n  /// specified type and indicate what to do abort it.\n  ///\n  /// NOTE: All indexed mode loads are initialized to Expand in\n  /// TargetLowering.cpp\n  void setIndexedLoadAction(unsigned IdxMode, MVT VT, LegalizeAction Action) {\n    setIndexedModeAction(IdxMode, VT, IMAB_Load, Action);\n  }\n\n  /// Indicate that the specified indexed store does or does not work with the\n  /// specified type and indicate what to do about it.\n  ///\n  /// NOTE: All indexed mode stores are initialized to Expand in\n  /// TargetLowering.cpp\n  void setIndexedStoreAction(unsigned IdxMode, MVT VT, LegalizeAction Action) {\n    setIndexedModeAction(IdxMode, VT, IMAB_Store, Action);\n  }\n\n  /// Indicate that the specified indexed masked load does or does not work with\n  /// the specified type and indicate what to do about it.\n  ///\n  /// NOTE: All indexed mode masked loads are initialized to Expand in\n  /// TargetLowering.cpp\n  void setIndexedMaskedLoadAction(unsigned IdxMode, MVT VT,\n                                  LegalizeAction Action) {\n    setIndexedModeAction(IdxMode, VT, IMAB_MaskedLoad, Action);\n  }\n\n  /// Indicate that the specified indexed masked store does or does not work\n  /// with the specified type and indicate what to do about it.\n  ///\n  /// NOTE: All indexed mode masked stores are initialized to Expand in\n  /// TargetLowering.cpp\n  void setIndexedMaskedStoreAction(unsigned IdxMode, MVT VT,\n                                   LegalizeAction Action) {\n    setIndexedModeAction(IdxMode, VT, IMAB_MaskedStore, Action);\n  }\n\n  /// Indicate that the specified condition code is or isn't supported on the\n  /// target and indicate what to do about it.\n  void setCondCodeAction(ISD::CondCode CC, MVT VT,\n                         LegalizeAction Action) {\n    assert(VT.isValid() && (unsigned)CC < array_lengthof(CondCodeActions) &&\n           \"Table isn't big enough!\");\n    assert((unsigned)Action < 0x10 && \"too many bits for bitfield array\");\n    /// The lower 3 bits of the SimpleTy index into Nth 4bit set from the 32-bit\n    /// value and the upper 29 bits index into the second dimension of the array\n    /// to select what 32-bit value to use.\n    uint32_t Shift = 4 * (VT.SimpleTy & 0x7);\n    CondCodeActions[CC][VT.SimpleTy >> 3] &= ~((uint32_t)0xF << Shift);\n    CondCodeActions[CC][VT.SimpleTy >> 3] |= (uint32_t)Action << Shift;\n  }\n\n  /// If Opc/OrigVT is specified as being promoted, the promotion code defaults\n  /// to trying a larger integer/fp until it can find one that works. If that\n  /// default is insufficient, this method can be used by the target to override\n  /// the default.\n  void AddPromotedToType(unsigned Opc, MVT OrigVT, MVT DestVT) {\n    PromoteToType[std::make_pair(Opc, OrigVT.SimpleTy)] = DestVT.SimpleTy;\n  }\n\n  /// Convenience method to set an operation to Promote and specify the type\n  /// in a single call.\n  void setOperationPromotedToType(unsigned Opc, MVT OrigVT, MVT DestVT) {\n    setOperationAction(Opc, OrigVT, Promote);\n    AddPromotedToType(Opc, OrigVT, DestVT);\n  }\n\n  /// Targets should invoke this method for each target independent node that\n  /// they want to provide a custom DAG combiner for by implementing the\n  /// PerformDAGCombine virtual method.\n  void setTargetDAGCombine(ISD::NodeType NT) {\n    assert(unsigned(NT >> 3) < array_lengthof(TargetDAGCombineArray));\n    TargetDAGCombineArray[NT >> 3] |= 1 << (NT&7);\n  }\n\n  /// Set the target's minimum function alignment.\n  void setMinFunctionAlignment(Align Alignment) {\n    MinFunctionAlignment = Alignment;\n  }\n\n  /// Set the target's preferred function alignment.  This should be set if\n  /// there is a performance benefit to higher-than-minimum alignment\n  void setPrefFunctionAlignment(Align Alignment) {\n    PrefFunctionAlignment = Alignment;\n  }\n\n  /// Set the target's preferred loop alignment. Default alignment is one, it\n  /// means the target does not care about loop alignment. The target may also\n  /// override getPrefLoopAlignment to provide per-loop values.\n  void setPrefLoopAlignment(Align Alignment) { PrefLoopAlignment = Alignment; }\n\n  /// Set the minimum stack alignment of an argument.\n  void setMinStackArgumentAlignment(Align Alignment) {\n    MinStackArgumentAlignment = Alignment;\n  }\n\n  /// Set the maximum atomic operation size supported by the\n  /// backend. Atomic operations greater than this size (as well as\n  /// ones that are not naturally aligned), will be expanded by\n  /// AtomicExpandPass into an __atomic_* library call.\n  void setMaxAtomicSizeInBitsSupported(unsigned SizeInBits) {\n    MaxAtomicSizeInBitsSupported = SizeInBits;\n  }\n\n  /// Sets the minimum cmpxchg or ll/sc size supported by the backend.\n  void setMinCmpXchgSizeInBits(unsigned SizeInBits) {\n    MinCmpXchgSizeInBits = SizeInBits;\n  }\n\n  /// Sets whether unaligned atomic operations are supported.\n  void setSupportsUnalignedAtomics(bool UnalignedSupported) {\n    SupportsUnalignedAtomics = UnalignedSupported;\n  }\n\npublic:\n  //===--------------------------------------------------------------------===//\n  // Addressing mode description hooks (used by LSR etc).\n  //\n\n  /// CodeGenPrepare sinks address calculations into the same BB as Load/Store\n  /// instructions reading the address. This allows as much computation as\n  /// possible to be done in the address mode for that operand. This hook lets\n  /// targets also pass back when this should be done on intrinsics which\n  /// load/store.\n  virtual bool getAddrModeArguments(IntrinsicInst * /*I*/,\n                                    SmallVectorImpl<Value*> &/*Ops*/,\n                                    Type *&/*AccessTy*/) const {\n    return false;\n  }\n\n  /// This represents an addressing mode of:\n  ///    BaseGV + BaseOffs + BaseReg + Scale*ScaleReg\n  /// If BaseGV is null,  there is no BaseGV.\n  /// If BaseOffs is zero, there is no base offset.\n  /// If HasBaseReg is false, there is no base register.\n  /// If Scale is zero, there is no ScaleReg.  Scale of 1 indicates a reg with\n  /// no scale.\n  struct AddrMode {\n    GlobalValue *BaseGV = nullptr;\n    int64_t      BaseOffs = 0;\n    bool         HasBaseReg = false;\n    int64_t      Scale = 0;\n    AddrMode() = default;\n  };\n\n  /// Return true if the addressing mode represented by AM is legal for this\n  /// target, for a load/store of the specified type.\n  ///\n  /// The type may be VoidTy, in which case only return true if the addressing\n  /// mode is legal for a load/store of any legal type.  TODO: Handle\n  /// pre/postinc as well.\n  ///\n  /// If the address space cannot be determined, it will be -1.\n  ///\n  /// TODO: Remove default argument\n  virtual bool isLegalAddressingMode(const DataLayout &DL, const AddrMode &AM,\n                                     Type *Ty, unsigned AddrSpace,\n                                     Instruction *I = nullptr) const;\n\n  /// Return the cost of the scaling factor used in the addressing mode\n  /// represented by AM for this target, for a load/store of the specified type.\n  ///\n  /// If the AM is supported, the return value must be >= 0.\n  /// If the AM is not supported, it returns a negative value.\n  /// TODO: Handle pre/postinc as well.\n  /// TODO: Remove default argument\n  virtual int getScalingFactorCost(const DataLayout &DL, const AddrMode &AM,\n                                   Type *Ty, unsigned AS = 0) const {\n    // Default: assume that any scaling factor used in a legal AM is free.\n    if (isLegalAddressingMode(DL, AM, Ty, AS))\n      return 0;\n    return -1;\n  }\n\n  /// Return true if the specified immediate is legal icmp immediate, that is\n  /// the target has icmp instructions which can compare a register against the\n  /// immediate without having to materialize the immediate into a register.\n  virtual bool isLegalICmpImmediate(int64_t) const {\n    return true;\n  }\n\n  /// Return true if the specified immediate is legal add immediate, that is the\n  /// target has add instructions which can add a register with the immediate\n  /// without having to materialize the immediate into a register.\n  virtual bool isLegalAddImmediate(int64_t) const {\n    return true;\n  }\n\n  /// Return true if the specified immediate is legal for the value input of a\n  /// store instruction.\n  virtual bool isLegalStoreImmediate(int64_t Value) const {\n    // Default implementation assumes that at least 0 works since it is likely\n    // that a zero register exists or a zero immediate is allowed.\n    return Value == 0;\n  }\n\n  /// Return true if it's significantly cheaper to shift a vector by a uniform\n  /// scalar than by an amount which will vary across each lane. On x86 before\n  /// AVX2 for example, there is a \"psllw\" instruction for the former case, but\n  /// no simple instruction for a general \"a << b\" operation on vectors.\n  /// This should also apply to lowering for vector funnel shifts (rotates).\n  virtual bool isVectorShiftByScalarCheap(Type *Ty) const {\n    return false;\n  }\n\n  /// Given a shuffle vector SVI representing a vector splat, return a new\n  /// scalar type of size equal to SVI's scalar type if the new type is more\n  /// profitable. Returns nullptr otherwise. For example under MVE float splats\n  /// are converted to integer to prevent the need to move from SPR to GPR\n  /// registers.\n  virtual Type* shouldConvertSplatType(ShuffleVectorInst* SVI) const {\n    return nullptr;\n  }\n\n  /// Given a set in interconnected phis of type 'From' that are loaded/stored\n  /// or bitcast to type 'To', return true if the set should be converted to\n  /// 'To'.\n  virtual bool shouldConvertPhiType(Type *From, Type *To) const {\n    return (From->isIntegerTy() || From->isFloatingPointTy()) &&\n           (To->isIntegerTy() || To->isFloatingPointTy());\n  }\n\n  /// Returns true if the opcode is a commutative binary operation.\n  virtual bool isCommutativeBinOp(unsigned Opcode) const {\n    // FIXME: This should get its info from the td file.\n    switch (Opcode) {\n    case ISD::ADD:\n    case ISD::SMIN:\n    case ISD::SMAX:\n    case ISD::UMIN:\n    case ISD::UMAX:\n    case ISD::MUL:\n    case ISD::MULHU:\n    case ISD::MULHS:\n    case ISD::SMUL_LOHI:\n    case ISD::UMUL_LOHI:\n    case ISD::FADD:\n    case ISD::FMUL:\n    case ISD::AND:\n    case ISD::OR:\n    case ISD::XOR:\n    case ISD::SADDO:\n    case ISD::UADDO:\n    case ISD::ADDC:\n    case ISD::ADDE:\n    case ISD::SADDSAT:\n    case ISD::UADDSAT:\n    case ISD::FMINNUM:\n    case ISD::FMAXNUM:\n    case ISD::FMINNUM_IEEE:\n    case ISD::FMAXNUM_IEEE:\n    case ISD::FMINIMUM:\n    case ISD::FMAXIMUM:\n      return true;\n    default: return false;\n    }\n  }\n\n  /// Return true if the node is a math/logic binary operator.\n  virtual bool isBinOp(unsigned Opcode) const {\n    // A commutative binop must be a binop.\n    if (isCommutativeBinOp(Opcode))\n      return true;\n    // These are non-commutative binops.\n    switch (Opcode) {\n    case ISD::SUB:\n    case ISD::SHL:\n    case ISD::SRL:\n    case ISD::SRA:\n    case ISD::SDIV:\n    case ISD::UDIV:\n    case ISD::SREM:\n    case ISD::UREM:\n    case ISD::FSUB:\n    case ISD::FDIV:\n    case ISD::FREM:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  /// Return true if it's free to truncate a value of type FromTy to type\n  /// ToTy. e.g. On x86 it's free to truncate a i32 value in register EAX to i16\n  /// by referencing its sub-register AX.\n  /// Targets must return false when FromTy <= ToTy.\n  virtual bool isTruncateFree(Type *FromTy, Type *ToTy) const {\n    return false;\n  }\n\n  /// Return true if a truncation from FromTy to ToTy is permitted when deciding\n  /// whether a call is in tail position. Typically this means that both results\n  /// would be assigned to the same register or stack slot, but it could mean\n  /// the target performs adequate checks of its own before proceeding with the\n  /// tail call.  Targets must return false when FromTy <= ToTy.\n  virtual bool allowTruncateForTailCall(Type *FromTy, Type *ToTy) const {\n    return false;\n  }\n\n  virtual bool isTruncateFree(EVT FromVT, EVT ToVT) const {\n    return false;\n  }\n\n  virtual bool isProfitableToHoist(Instruction *I) const { return true; }\n\n  /// Return true if the extension represented by \\p I is free.\n  /// Unlikely the is[Z|FP]ExtFree family which is based on types,\n  /// this method can use the context provided by \\p I to decide\n  /// whether or not \\p I is free.\n  /// This method extends the behavior of the is[Z|FP]ExtFree family.\n  /// In other words, if is[Z|FP]Free returns true, then this method\n  /// returns true as well. The converse is not true.\n  /// The target can perform the adequate checks by overriding isExtFreeImpl.\n  /// \\pre \\p I must be a sign, zero, or fp extension.\n  bool isExtFree(const Instruction *I) const {\n    switch (I->getOpcode()) {\n    case Instruction::FPExt:\n      if (isFPExtFree(EVT::getEVT(I->getType()),\n                      EVT::getEVT(I->getOperand(0)->getType())))\n        return true;\n      break;\n    case Instruction::ZExt:\n      if (isZExtFree(I->getOperand(0)->getType(), I->getType()))\n        return true;\n      break;\n    case Instruction::SExt:\n      break;\n    default:\n      llvm_unreachable(\"Instruction is not an extension\");\n    }\n    return isExtFreeImpl(I);\n  }\n\n  /// Return true if \\p Load and \\p Ext can form an ExtLoad.\n  /// For example, in AArch64\n  ///   %L = load i8, i8* %ptr\n  ///   %E = zext i8 %L to i32\n  /// can be lowered into one load instruction\n  ///   ldrb w0, [x0]\n  bool isExtLoad(const LoadInst *Load, const Instruction *Ext,\n                 const DataLayout &DL) const {\n    EVT VT = getValueType(DL, Ext->getType());\n    EVT LoadVT = getValueType(DL, Load->getType());\n\n    // If the load has other users and the truncate is not free, the ext\n    // probably isn't free.\n    if (!Load->hasOneUse() && (isTypeLegal(LoadVT) || !isTypeLegal(VT)) &&\n        !isTruncateFree(Ext->getType(), Load->getType()))\n      return false;\n\n    // Check whether the target supports casts folded into loads.\n    unsigned LType;\n    if (isa<ZExtInst>(Ext))\n      LType = ISD::ZEXTLOAD;\n    else {\n      assert(isa<SExtInst>(Ext) && \"Unexpected ext type!\");\n      LType = ISD::SEXTLOAD;\n    }\n\n    return isLoadExtLegal(LType, VT, LoadVT);\n  }\n\n  /// Return true if any actual instruction that defines a value of type FromTy\n  /// implicitly zero-extends the value to ToTy in the result register.\n  ///\n  /// The function should return true when it is likely that the truncate can\n  /// be freely folded with an instruction defining a value of FromTy. If\n  /// the defining instruction is unknown (because you're looking at a\n  /// function argument, PHI, etc.) then the target may require an\n  /// explicit truncate, which is not necessarily free, but this function\n  /// does not deal with those cases.\n  /// Targets must return false when FromTy >= ToTy.\n  virtual bool isZExtFree(Type *FromTy, Type *ToTy) const {\n    return false;\n  }\n\n  virtual bool isZExtFree(EVT FromTy, EVT ToTy) const {\n    return false;\n  }\n\n  /// Return true if sign-extension from FromTy to ToTy is cheaper than\n  /// zero-extension.\n  virtual bool isSExtCheaperThanZExt(EVT FromTy, EVT ToTy) const {\n    return false;\n  }\n\n  /// Return true if sinking I's operands to the same basic block as I is\n  /// profitable, e.g. because the operands can be folded into a target\n  /// instruction during instruction selection. After calling the function\n  /// \\p Ops contains the Uses to sink ordered by dominance (dominating users\n  /// come first).\n  virtual bool shouldSinkOperands(Instruction *I,\n                                  SmallVectorImpl<Use *> &Ops) const {\n    return false;\n  }\n\n  /// Return true if the target supplies and combines to a paired load\n  /// two loaded values of type LoadedType next to each other in memory.\n  /// RequiredAlignment gives the minimal alignment constraints that must be met\n  /// to be able to select this paired load.\n  ///\n  /// This information is *not* used to generate actual paired loads, but it is\n  /// used to generate a sequence of loads that is easier to combine into a\n  /// paired load.\n  /// For instance, something like this:\n  /// a = load i64* addr\n  /// b = trunc i64 a to i32\n  /// c = lshr i64 a, 32\n  /// d = trunc i64 c to i32\n  /// will be optimized into:\n  /// b = load i32* addr1\n  /// d = load i32* addr2\n  /// Where addr1 = addr2 +/- sizeof(i32).\n  ///\n  /// In other words, unless the target performs a post-isel load combining,\n  /// this information should not be provided because it will generate more\n  /// loads.\n  virtual bool hasPairedLoad(EVT /*LoadedType*/,\n                             Align & /*RequiredAlignment*/) const {\n    return false;\n  }\n\n  /// Return true if the target has a vector blend instruction.\n  virtual bool hasVectorBlend() const { return false; }\n\n  /// Get the maximum supported factor for interleaved memory accesses.\n  /// Default to be the minimum interleave factor: 2.\n  virtual unsigned getMaxSupportedInterleaveFactor() const { return 2; }\n\n  /// Lower an interleaved load to target specific intrinsics. Return\n  /// true on success.\n  ///\n  /// \\p LI is the vector load instruction.\n  /// \\p Shuffles is the shufflevector list to DE-interleave the loaded vector.\n  /// \\p Indices is the corresponding indices for each shufflevector.\n  /// \\p Factor is the interleave factor.\n  virtual bool lowerInterleavedLoad(LoadInst *LI,\n                                    ArrayRef<ShuffleVectorInst *> Shuffles,\n                                    ArrayRef<unsigned> Indices,\n                                    unsigned Factor) const {\n    return false;\n  }\n\n  /// Lower an interleaved store to target specific intrinsics. Return\n  /// true on success.\n  ///\n  /// \\p SI is the vector store instruction.\n  /// \\p SVI is the shufflevector to RE-interleave the stored vector.\n  /// \\p Factor is the interleave factor.\n  virtual bool lowerInterleavedStore(StoreInst *SI, ShuffleVectorInst *SVI,\n                                     unsigned Factor) const {\n    return false;\n  }\n\n  /// Return true if zero-extending the specific node Val to type VT2 is free\n  /// (either because it's implicitly zero-extended such as ARM ldrb / ldrh or\n  /// because it's folded such as X86 zero-extending loads).\n  virtual bool isZExtFree(SDValue Val, EVT VT2) const {\n    return isZExtFree(Val.getValueType(), VT2);\n  }\n\n  /// Return true if an fpext operation is free (for instance, because\n  /// single-precision floating-point numbers are implicitly extended to\n  /// double-precision).\n  virtual bool isFPExtFree(EVT DestVT, EVT SrcVT) const {\n    assert(SrcVT.isFloatingPoint() && DestVT.isFloatingPoint() &&\n           \"invalid fpext types\");\n    return false;\n  }\n\n  /// Return true if an fpext operation input to an \\p Opcode operation is free\n  /// (for instance, because half-precision floating-point numbers are\n  /// implicitly extended to float-precision) for an FMA instruction.\n  virtual bool isFPExtFoldable(const SelectionDAG &DAG, unsigned Opcode,\n                               EVT DestVT, EVT SrcVT) const {\n    assert(DestVT.isFloatingPoint() && SrcVT.isFloatingPoint() &&\n           \"invalid fpext types\");\n    return isFPExtFree(DestVT, SrcVT);\n  }\n\n  /// Return true if folding a vector load into ExtVal (a sign, zero, or any\n  /// extend node) is profitable.\n  virtual bool isVectorLoadExtDesirable(SDValue ExtVal) const { return false; }\n\n  /// Return true if an fneg operation is free to the point where it is never\n  /// worthwhile to replace it with a bitwise operation.\n  virtual bool isFNegFree(EVT VT) const {\n    assert(VT.isFloatingPoint());\n    return false;\n  }\n\n  /// Return true if an fabs operation is free to the point where it is never\n  /// worthwhile to replace it with a bitwise operation.\n  virtual bool isFAbsFree(EVT VT) const {\n    assert(VT.isFloatingPoint());\n    return false;\n  }\n\n  /// Return true if an FMA operation is faster than a pair of fmul and fadd\n  /// instructions. fmuladd intrinsics will be expanded to FMAs when this method\n  /// returns true, otherwise fmuladd is expanded to fmul + fadd.\n  ///\n  /// NOTE: This may be called before legalization on types for which FMAs are\n  /// not legal, but should return true if those types will eventually legalize\n  /// to types that support FMAs. After legalization, it will only be called on\n  /// types that support FMAs (via Legal or Custom actions)\n  virtual bool isFMAFasterThanFMulAndFAdd(const MachineFunction &MF,\n                                          EVT) const {\n    return false;\n  }\n\n  /// IR version\n  virtual bool isFMAFasterThanFMulAndFAdd(const Function &F, Type *) const {\n    return false;\n  }\n\n  /// Returns true if be combined with to form an ISD::FMAD. \\p N may be an\n  /// ISD::FADD, ISD::FSUB, or an ISD::FMUL which will be distributed into an\n  /// fadd/fsub.\n  virtual bool isFMADLegal(const SelectionDAG &DAG, const SDNode *N) const {\n    assert((N->getOpcode() == ISD::FADD || N->getOpcode() == ISD::FSUB ||\n            N->getOpcode() == ISD::FMUL) &&\n           \"unexpected node in FMAD forming combine\");\n    return isOperationLegal(ISD::FMAD, N->getValueType(0));\n  }\n\n  /// Return true if it's profitable to narrow operations of type VT1 to\n  /// VT2. e.g. on x86, it's profitable to narrow from i32 to i8 but not from\n  /// i32 to i16.\n  virtual bool isNarrowingProfitable(EVT /*VT1*/, EVT /*VT2*/) const {\n    return false;\n  }\n\n  /// Return true if it is beneficial to convert a load of a constant to\n  /// just the constant itself.\n  /// On some targets it might be more efficient to use a combination of\n  /// arithmetic instructions to materialize the constant instead of loading it\n  /// from a constant pool.\n  virtual bool shouldConvertConstantLoadToIntImm(const APInt &Imm,\n                                                 Type *Ty) const {\n    return false;\n  }\n\n  /// Return true if EXTRACT_SUBVECTOR is cheap for extracting this result type\n  /// from this source type with this index. This is needed because\n  /// EXTRACT_SUBVECTOR usually has custom lowering that depends on the index of\n  /// the first element, and only the target knows which lowering is cheap.\n  virtual bool isExtractSubvectorCheap(EVT ResVT, EVT SrcVT,\n                                       unsigned Index) const {\n    return false;\n  }\n\n  /// Try to convert an extract element of a vector binary operation into an\n  /// extract element followed by a scalar operation.\n  virtual bool shouldScalarizeBinop(SDValue VecOp) const {\n    return false;\n  }\n\n  /// Return true if extraction of a scalar element from the given vector type\n  /// at the given index is cheap. For example, if scalar operations occur on\n  /// the same register file as vector operations, then an extract element may\n  /// be a sub-register rename rather than an actual instruction.\n  virtual bool isExtractVecEltCheap(EVT VT, unsigned Index) const {\n    return false;\n  }\n\n  /// Try to convert math with an overflow comparison into the corresponding DAG\n  /// node operation. Targets may want to override this independently of whether\n  /// the operation is legal/custom for the given type because it may obscure\n  /// matching of other patterns.\n  virtual bool shouldFormOverflowOp(unsigned Opcode, EVT VT,\n                                    bool MathUsed) const {\n    // TODO: The default logic is inherited from code in CodeGenPrepare.\n    // The opcode should not make a difference by default?\n    if (Opcode != ISD::UADDO)\n      return false;\n\n    // Allow the transform as long as we have an integer type that is not\n    // obviously illegal and unsupported and if the math result is used\n    // besides the overflow check. On some targets (e.g. SPARC), it is\n    // not profitable to form on overflow op if the math result has no\n    // concrete users.\n    if (VT.isVector())\n      return false;\n    return MathUsed && (VT.isSimple() || !isOperationExpand(Opcode, VT));\n  }\n\n  // Return true if it is profitable to use a scalar input to a BUILD_VECTOR\n  // even if the vector itself has multiple uses.\n  virtual bool aggressivelyPreferBuildVectorSources(EVT VecVT) const {\n    return false;\n  }\n\n  // Return true if CodeGenPrepare should consider splitting large offset of a\n  // GEP to make the GEP fit into the addressing mode and can be sunk into the\n  // same blocks of its users.\n  virtual bool shouldConsiderGEPOffsetSplit() const { return false; }\n\n  /// Return true if creating a shift of the type by the given\n  /// amount is not profitable.\n  virtual bool shouldAvoidTransformToShift(EVT VT, unsigned Amount) const {\n    return false;\n  }\n\n  /// Does this target require the clearing of high-order bits in a register\n  /// passed to the fp16 to fp conversion library function.\n  virtual bool shouldKeepZExtForFP16Conv() const { return false; }\n\n  //===--------------------------------------------------------------------===//\n  // Runtime Library hooks\n  //\n\n  /// Rename the default libcall routine name for the specified libcall.\n  void setLibcallName(RTLIB::Libcall Call, const char *Name) {\n    LibcallRoutineNames[Call] = Name;\n  }\n\n  /// Get the libcall routine name for the specified libcall.\n  const char *getLibcallName(RTLIB::Libcall Call) const {\n    return LibcallRoutineNames[Call];\n  }\n\n  /// Override the default CondCode to be used to test the result of the\n  /// comparison libcall against zero.\n  void setCmpLibcallCC(RTLIB::Libcall Call, ISD::CondCode CC) {\n    CmpLibcallCCs[Call] = CC;\n  }\n\n  /// Get the CondCode that's to be used to test the result of the comparison\n  /// libcall against zero.\n  ISD::CondCode getCmpLibcallCC(RTLIB::Libcall Call) const {\n    return CmpLibcallCCs[Call];\n  }\n\n  /// Set the CallingConv that should be used for the specified libcall.\n  void setLibcallCallingConv(RTLIB::Libcall Call, CallingConv::ID CC) {\n    LibcallCallingConvs[Call] = CC;\n  }\n\n  /// Get the CallingConv that should be used for the specified libcall.\n  CallingConv::ID getLibcallCallingConv(RTLIB::Libcall Call) const {\n    return LibcallCallingConvs[Call];\n  }\n\n  /// Execute target specific actions to finalize target lowering.\n  /// This is used to set extra flags in MachineFrameInformation and freezing\n  /// the set of reserved registers.\n  /// The default implementation just freezes the set of reserved registers.\n  virtual void finalizeLowering(MachineFunction &MF) const;\n\n  //===----------------------------------------------------------------------===//\n  //  GlobalISel Hooks\n  //===----------------------------------------------------------------------===//\n  /// Check whether or not \\p MI needs to be moved close to its uses.\n  virtual bool shouldLocalize(const MachineInstr &MI, const TargetTransformInfo *TTI) const;\n\n\nprivate:\n  const TargetMachine &TM;\n\n  /// Tells the code generator that the target has multiple (allocatable)\n  /// condition registers that can be used to store the results of comparisons\n  /// for use by selects and conditional branches. With multiple condition\n  /// registers, the code generator will not aggressively sink comparisons into\n  /// the blocks of their users.\n  bool HasMultipleConditionRegisters;\n\n  /// Tells the code generator that the target has BitExtract instructions.\n  /// The code generator will aggressively sink \"shift\"s into the blocks of\n  /// their users if the users will generate \"and\" instructions which can be\n  /// combined with \"shift\" to BitExtract instructions.\n  bool HasExtractBitsInsn;\n\n  /// Tells the code generator to bypass slow divide or remainder\n  /// instructions. For example, BypassSlowDivWidths[32,8] tells the code\n  /// generator to bypass 32-bit integer div/rem with an 8-bit unsigned integer\n  /// div/rem when the operands are positive and less than 256.\n  DenseMap <unsigned int, unsigned int> BypassSlowDivWidths;\n\n  /// Tells the code generator that it shouldn't generate extra flow control\n  /// instructions and should attempt to combine flow control instructions via\n  /// predication.\n  bool JumpIsExpensive;\n\n  /// Information about the contents of the high-bits in boolean values held in\n  /// a type wider than i1. See getBooleanContents.\n  BooleanContent BooleanContents;\n\n  /// Information about the contents of the high-bits in boolean values held in\n  /// a type wider than i1. See getBooleanContents.\n  BooleanContent BooleanFloatContents;\n\n  /// Information about the contents of the high-bits in boolean vector values\n  /// when the element type is wider than i1. See getBooleanContents.\n  BooleanContent BooleanVectorContents;\n\n  /// The target scheduling preference: shortest possible total cycles or lowest\n  /// register usage.\n  Sched::Preference SchedPreferenceInfo;\n\n  /// The minimum alignment that any argument on the stack needs to have.\n  Align MinStackArgumentAlignment;\n\n  /// The minimum function alignment (used when optimizing for size, and to\n  /// prevent explicitly provided alignment from leading to incorrect code).\n  Align MinFunctionAlignment;\n\n  /// The preferred function alignment (used when alignment unspecified and\n  /// optimizing for speed).\n  Align PrefFunctionAlignment;\n\n  /// The preferred loop alignment (in log2 bot in bytes).\n  Align PrefLoopAlignment;\n\n  /// Size in bits of the maximum atomics size the backend supports.\n  /// Accesses larger than this will be expanded by AtomicExpandPass.\n  unsigned MaxAtomicSizeInBitsSupported;\n\n  /// Size in bits of the minimum cmpxchg or ll/sc operation the\n  /// backend supports.\n  unsigned MinCmpXchgSizeInBits;\n\n  /// This indicates if the target supports unaligned atomic operations.\n  bool SupportsUnalignedAtomics;\n\n  /// If set to a physical register, this specifies the register that\n  /// llvm.savestack/llvm.restorestack should save and restore.\n  Register StackPointerRegisterToSaveRestore;\n\n  /// This indicates the default register class to use for each ValueType the\n  /// target supports natively.\n  const TargetRegisterClass *RegClassForVT[MVT::LAST_VALUETYPE];\n  uint16_t NumRegistersForVT[MVT::LAST_VALUETYPE];\n  MVT RegisterTypeForVT[MVT::LAST_VALUETYPE];\n\n  /// This indicates the \"representative\" register class to use for each\n  /// ValueType the target supports natively. This information is used by the\n  /// scheduler to track register pressure. By default, the representative\n  /// register class is the largest legal super-reg register class of the\n  /// register class of the specified type. e.g. On x86, i8, i16, and i32's\n  /// representative class would be GR32.\n  const TargetRegisterClass *RepRegClassForVT[MVT::LAST_VALUETYPE];\n\n  /// This indicates the \"cost\" of the \"representative\" register class for each\n  /// ValueType. The cost is used by the scheduler to approximate register\n  /// pressure.\n  uint8_t RepRegClassCostForVT[MVT::LAST_VALUETYPE];\n\n  /// For any value types we are promoting or expanding, this contains the value\n  /// type that we are changing to.  For Expanded types, this contains one step\n  /// of the expand (e.g. i64 -> i32), even if there are multiple steps required\n  /// (e.g. i64 -> i16).  For types natively supported by the system, this holds\n  /// the same type (e.g. i32 -> i32).\n  MVT TransformToType[MVT::LAST_VALUETYPE];\n\n  /// For each operation and each value type, keep a LegalizeAction that\n  /// indicates how instruction selection should deal with the operation.  Most\n  /// operations are Legal (aka, supported natively by the target), but\n  /// operations that are not should be described.  Note that operations on\n  /// non-legal value types are not described here.\n  LegalizeAction OpActions[MVT::LAST_VALUETYPE][ISD::BUILTIN_OP_END];\n\n  /// For each load extension type and each value type, keep a LegalizeAction\n  /// that indicates how instruction selection should deal with a load of a\n  /// specific value type and extension type. Uses 4-bits to store the action\n  /// for each of the 4 load ext types.\n  uint16_t LoadExtActions[MVT::LAST_VALUETYPE][MVT::LAST_VALUETYPE];\n\n  /// For each value type pair keep a LegalizeAction that indicates whether a\n  /// truncating store of a specific value type and truncating type is legal.\n  LegalizeAction TruncStoreActions[MVT::LAST_VALUETYPE][MVT::LAST_VALUETYPE];\n\n  /// For each indexed mode and each value type, keep a quad of LegalizeAction\n  /// that indicates how instruction selection should deal with the load /\n  /// store / maskedload / maskedstore.\n  ///\n  /// The first dimension is the value_type for the reference. The second\n  /// dimension represents the various modes for load store.\n  uint16_t IndexedModeActions[MVT::LAST_VALUETYPE][ISD::LAST_INDEXED_MODE];\n\n  /// For each condition code (ISD::CondCode) keep a LegalizeAction that\n  /// indicates how instruction selection should deal with the condition code.\n  ///\n  /// Because each CC action takes up 4 bits, we need to have the array size be\n  /// large enough to fit all of the value types. This can be done by rounding\n  /// up the MVT::LAST_VALUETYPE value to the next multiple of 8.\n  uint32_t CondCodeActions[ISD::SETCC_INVALID][(MVT::LAST_VALUETYPE + 7) / 8];\n\n  ValueTypeActionImpl ValueTypeActions;\n\nprivate:\n  LegalizeKind getTypeConversion(LLVMContext &Context, EVT VT) const;\n\n  /// Targets can specify ISD nodes that they would like PerformDAGCombine\n  /// callbacks for by calling setTargetDAGCombine(), which sets a bit in this\n  /// array.\n  unsigned char\n  TargetDAGCombineArray[(ISD::BUILTIN_OP_END+CHAR_BIT-1)/CHAR_BIT];\n\n  /// For operations that must be promoted to a specific type, this holds the\n  /// destination type.  This map should be sparse, so don't hold it as an\n  /// array.\n  ///\n  /// Targets add entries to this map with AddPromotedToType(..), clients access\n  /// this with getTypeToPromoteTo(..).\n  std::map<std::pair<unsigned, MVT::SimpleValueType>, MVT::SimpleValueType>\n    PromoteToType;\n\n  /// Stores the name each libcall.\n  const char *LibcallRoutineNames[RTLIB::UNKNOWN_LIBCALL + 1];\n\n  /// The ISD::CondCode that should be used to test the result of each of the\n  /// comparison libcall against zero.\n  ISD::CondCode CmpLibcallCCs[RTLIB::UNKNOWN_LIBCALL];\n\n  /// Stores the CallingConv that should be used for each libcall.\n  CallingConv::ID LibcallCallingConvs[RTLIB::UNKNOWN_LIBCALL];\n\n  /// Set default libcall names and calling conventions.\n  void InitLibcalls(const Triple &TT);\n\n  /// The bits of IndexedModeActions used to store the legalisation actions\n  /// We store the data as   | ML | MS |  L |  S | each taking 4 bits.\n  enum IndexedModeActionsBits {\n    IMAB_Store = 0,\n    IMAB_Load = 4,\n    IMAB_MaskedStore = 8,\n    IMAB_MaskedLoad = 12\n  };\n\n  void setIndexedModeAction(unsigned IdxMode, MVT VT, unsigned Shift,\n                            LegalizeAction Action) {\n    assert(VT.isValid() && IdxMode < ISD::LAST_INDEXED_MODE &&\n           (unsigned)Action < 0xf && \"Table isn't big enough!\");\n    unsigned Ty = (unsigned)VT.SimpleTy;\n    IndexedModeActions[Ty][IdxMode] &= ~(0xf << Shift);\n    IndexedModeActions[Ty][IdxMode] |= ((uint16_t)Action) << Shift;\n  }\n\n  LegalizeAction getIndexedModeAction(unsigned IdxMode, MVT VT,\n                                      unsigned Shift) const {\n    assert(IdxMode < ISD::LAST_INDEXED_MODE && VT.isValid() &&\n           \"Table isn't big enough!\");\n    unsigned Ty = (unsigned)VT.SimpleTy;\n    return (LegalizeAction)((IndexedModeActions[Ty][IdxMode] >> Shift) & 0xf);\n  }\n\nprotected:\n  /// Return true if the extension represented by \\p I is free.\n  /// \\pre \\p I is a sign, zero, or fp extension and\n  ///      is[Z|FP]ExtFree of the related types is not true.\n  virtual bool isExtFreeImpl(const Instruction *I) const { return false; }\n\n  /// Depth that GatherAllAliases should should continue looking for chain\n  /// dependencies when trying to find a more preferable chain. As an\n  /// approximation, this should be more than the number of consecutive stores\n  /// expected to be merged.\n  unsigned GatherAllAliasesMaxDepth;\n\n  /// \\brief Specify maximum number of store instructions per memset call.\n  ///\n  /// When lowering \\@llvm.memset this field specifies the maximum number of\n  /// store operations that may be substituted for the call to memset. Targets\n  /// must set this value based on the cost threshold for that target. Targets\n  /// should assume that the memset will be done using as many of the largest\n  /// store operations first, followed by smaller ones, if necessary, per\n  /// alignment restrictions. For example, storing 9 bytes on a 32-bit machine\n  /// with 16-bit alignment would result in four 2-byte stores and one 1-byte\n  /// store.  This only applies to setting a constant array of a constant size.\n  unsigned MaxStoresPerMemset;\n  /// Likewise for functions with the OptSize attribute.\n  unsigned MaxStoresPerMemsetOptSize;\n\n  /// \\brief Specify maximum number of store instructions per memcpy call.\n  ///\n  /// When lowering \\@llvm.memcpy this field specifies the maximum number of\n  /// store operations that may be substituted for a call to memcpy. Targets\n  /// must set this value based on the cost threshold for that target. Targets\n  /// should assume that the memcpy will be done using as many of the largest\n  /// store operations first, followed by smaller ones, if necessary, per\n  /// alignment restrictions. For example, storing 7 bytes on a 32-bit machine\n  /// with 32-bit alignment would result in one 4-byte store, a one 2-byte store\n  /// and one 1-byte store. This only applies to copying a constant array of\n  /// constant size.\n  unsigned MaxStoresPerMemcpy;\n  /// Likewise for functions with the OptSize attribute.\n  unsigned MaxStoresPerMemcpyOptSize;\n  /// \\brief Specify max number of store instructions to glue in inlined memcpy.\n  ///\n  /// When memcpy is inlined based on MaxStoresPerMemcpy, specify maximum number\n  /// of store instructions to keep together. This helps in pairing and\n  //  vectorization later on.\n  unsigned MaxGluedStoresPerMemcpy = 0;\n\n  /// \\brief Specify maximum number of load instructions per memcmp call.\n  ///\n  /// When lowering \\@llvm.memcmp this field specifies the maximum number of\n  /// pairs of load operations that may be substituted for a call to memcmp.\n  /// Targets must set this value based on the cost threshold for that target.\n  /// Targets should assume that the memcmp will be done using as many of the\n  /// largest load operations first, followed by smaller ones, if necessary, per\n  /// alignment restrictions. For example, loading 7 bytes on a 32-bit machine\n  /// with 32-bit alignment would result in one 4-byte load, a one 2-byte load\n  /// and one 1-byte load. This only applies to copying a constant array of\n  /// constant size.\n  unsigned MaxLoadsPerMemcmp;\n  /// Likewise for functions with the OptSize attribute.\n  unsigned MaxLoadsPerMemcmpOptSize;\n\n  /// \\brief Specify maximum number of store instructions per memmove call.\n  ///\n  /// When lowering \\@llvm.memmove this field specifies the maximum number of\n  /// store instructions that may be substituted for a call to memmove. Targets\n  /// must set this value based on the cost threshold for that target. Targets\n  /// should assume that the memmove will be done using as many of the largest\n  /// store operations first, followed by smaller ones, if necessary, per\n  /// alignment restrictions. For example, moving 9 bytes on a 32-bit machine\n  /// with 8-bit alignment would result in nine 1-byte stores.  This only\n  /// applies to copying a constant array of constant size.\n  unsigned MaxStoresPerMemmove;\n  /// Likewise for functions with the OptSize attribute.\n  unsigned MaxStoresPerMemmoveOptSize;\n\n  /// Tells the code generator that select is more expensive than a branch if\n  /// the branch is usually predicted right.\n  bool PredictableSelectIsExpensive;\n\n  /// \\see enableExtLdPromotion.\n  bool EnableExtLdPromotion;\n\n  /// Return true if the value types that can be represented by the specified\n  /// register class are all legal.\n  bool isLegalRC(const TargetRegisterInfo &TRI,\n                 const TargetRegisterClass &RC) const;\n\n  /// Replace/modify any TargetFrameIndex operands with a targte-dependent\n  /// sequence of memory operands that is recognized by PrologEpilogInserter.\n  MachineBasicBlock *emitPatchPoint(MachineInstr &MI,\n                                    MachineBasicBlock *MBB) const;\n\n  bool IsStrictFPEnabled;\n};\n\n/// This class defines information used to lower LLVM code to legal SelectionDAG\n/// operators that the target instruction selector can accept natively.\n///\n/// This class also defines callbacks that targets must implement to lower\n/// target-specific constructs to SelectionDAG operators.\nclass TargetLowering : public TargetLoweringBase {\npublic:\n  struct DAGCombinerInfo;\n  struct MakeLibCallOptions;\n\n  TargetLowering(const TargetLowering &) = delete;\n  TargetLowering &operator=(const TargetLowering &) = delete;\n\n  explicit TargetLowering(const TargetMachine &TM);\n\n  bool isPositionIndependent() const;\n\n  virtual bool isSDNodeSourceOfDivergence(const SDNode *N,\n                                          FunctionLoweringInfo *FLI,\n                                          LegacyDivergenceAnalysis *DA) const {\n    return false;\n  }\n\n  virtual bool isSDNodeAlwaysUniform(const SDNode * N) const {\n    return false;\n  }\n\n  /// Returns true by value, base pointer and offset pointer and addressing mode\n  /// by reference if the node's address can be legally represented as\n  /// pre-indexed load / store address.\n  virtual bool getPreIndexedAddressParts(SDNode * /*N*/, SDValue &/*Base*/,\n                                         SDValue &/*Offset*/,\n                                         ISD::MemIndexedMode &/*AM*/,\n                                         SelectionDAG &/*DAG*/) const {\n    return false;\n  }\n\n  /// Returns true by value, base pointer and offset pointer and addressing mode\n  /// by reference if this node can be combined with a load / store to form a\n  /// post-indexed load / store.\n  virtual bool getPostIndexedAddressParts(SDNode * /*N*/, SDNode * /*Op*/,\n                                          SDValue &/*Base*/,\n                                          SDValue &/*Offset*/,\n                                          ISD::MemIndexedMode &/*AM*/,\n                                          SelectionDAG &/*DAG*/) const {\n    return false;\n  }\n\n  /// Returns true if the specified base+offset is a legal indexed addressing\n  /// mode for this target. \\p MI is the load or store instruction that is being\n  /// considered for transformation.\n  virtual bool isIndexingLegal(MachineInstr &MI, Register Base, Register Offset,\n                               bool IsPre, MachineRegisterInfo &MRI) const {\n    return false;\n  }\n\n  /// Return the entry encoding for a jump table in the current function.  The\n  /// returned value is a member of the MachineJumpTableInfo::JTEntryKind enum.\n  virtual unsigned getJumpTableEncoding() const;\n\n  virtual const MCExpr *\n  LowerCustomJumpTableEntry(const MachineJumpTableInfo * /*MJTI*/,\n                            const MachineBasicBlock * /*MBB*/, unsigned /*uid*/,\n                            MCContext &/*Ctx*/) const {\n    llvm_unreachable(\"Need to implement this hook if target has custom JTIs\");\n  }\n\n  /// Returns relocation base for the given PIC jumptable.\n  virtual SDValue getPICJumpTableRelocBase(SDValue Table,\n                                           SelectionDAG &DAG) const;\n\n  /// This returns the relocation base for the given PIC jumptable, the same as\n  /// getPICJumpTableRelocBase, but as an MCExpr.\n  virtual const MCExpr *\n  getPICJumpTableRelocBaseExpr(const MachineFunction *MF,\n                               unsigned JTI, MCContext &Ctx) const;\n\n  /// Return true if folding a constant offset with the given GlobalAddress is\n  /// legal.  It is frequently not legal in PIC relocation models.\n  virtual bool isOffsetFoldingLegal(const GlobalAddressSDNode *GA) const;\n\n  bool isInTailCallPosition(SelectionDAG &DAG, SDNode *Node,\n                            SDValue &Chain) const;\n\n  void softenSetCCOperands(SelectionDAG &DAG, EVT VT, SDValue &NewLHS,\n                           SDValue &NewRHS, ISD::CondCode &CCCode,\n                           const SDLoc &DL, const SDValue OldLHS,\n                           const SDValue OldRHS) const;\n\n  void softenSetCCOperands(SelectionDAG &DAG, EVT VT, SDValue &NewLHS,\n                           SDValue &NewRHS, ISD::CondCode &CCCode,\n                           const SDLoc &DL, const SDValue OldLHS,\n                           const SDValue OldRHS, SDValue &Chain,\n                           bool IsSignaling = false) const;\n\n  /// Returns a pair of (return value, chain).\n  /// It is an error to pass RTLIB::UNKNOWN_LIBCALL as \\p LC.\n  std::pair<SDValue, SDValue> makeLibCall(SelectionDAG &DAG, RTLIB::Libcall LC,\n                                          EVT RetVT, ArrayRef<SDValue> Ops,\n                                          MakeLibCallOptions CallOptions,\n                                          const SDLoc &dl,\n                                          SDValue Chain = SDValue()) const;\n\n  /// Check whether parameters to a call that are passed in callee saved\n  /// registers are the same as from the calling function.  This needs to be\n  /// checked for tail call eligibility.\n  bool parametersInCSRMatch(const MachineRegisterInfo &MRI,\n      const uint32_t *CallerPreservedMask,\n      const SmallVectorImpl<CCValAssign> &ArgLocs,\n      const SmallVectorImpl<SDValue> &OutVals) const;\n\n  //===--------------------------------------------------------------------===//\n  // TargetLowering Optimization Methods\n  //\n\n  /// A convenience struct that encapsulates a DAG, and two SDValues for\n  /// returning information from TargetLowering to its clients that want to\n  /// combine.\n  struct TargetLoweringOpt {\n    SelectionDAG &DAG;\n    bool LegalTys;\n    bool LegalOps;\n    SDValue Old;\n    SDValue New;\n\n    explicit TargetLoweringOpt(SelectionDAG &InDAG,\n                               bool LT, bool LO) :\n      DAG(InDAG), LegalTys(LT), LegalOps(LO) {}\n\n    bool LegalTypes() const { return LegalTys; }\n    bool LegalOperations() const { return LegalOps; }\n\n    bool CombineTo(SDValue O, SDValue N) {\n      Old = O;\n      New = N;\n      return true;\n    }\n  };\n\n  /// Determines the optimal series of memory ops to replace the memset / memcpy.\n  /// Return true if the number of memory ops is below the threshold (Limit).\n  /// It returns the types of the sequence of memory ops to perform\n  /// memset / memcpy by reference.\n  bool findOptimalMemOpLowering(std::vector<EVT> &MemOps, unsigned Limit,\n                                const MemOp &Op, unsigned DstAS, unsigned SrcAS,\n                                const AttributeList &FuncAttributes) const;\n\n  /// Check to see if the specified operand of the specified instruction is a\n  /// constant integer.  If so, check to see if there are any bits set in the\n  /// constant that are not demanded.  If so, shrink the constant and return\n  /// true.\n  bool ShrinkDemandedConstant(SDValue Op, const APInt &DemandedBits,\n                              const APInt &DemandedElts,\n                              TargetLoweringOpt &TLO) const;\n\n  /// Helper wrapper around ShrinkDemandedConstant, demanding all elements.\n  bool ShrinkDemandedConstant(SDValue Op, const APInt &DemandedBits,\n                              TargetLoweringOpt &TLO) const;\n\n  // Target hook to do target-specific const optimization, which is called by\n  // ShrinkDemandedConstant. This function should return true if the target\n  // doesn't want ShrinkDemandedConstant to further optimize the constant.\n  virtual bool targetShrinkDemandedConstant(SDValue Op,\n                                            const APInt &DemandedBits,\n                                            const APInt &DemandedElts,\n                                            TargetLoweringOpt &TLO) const {\n    return false;\n  }\n\n  /// Convert x+y to (VT)((SmallVT)x+(SmallVT)y) if the casts are free.  This\n  /// uses isZExtFree and ZERO_EXTEND for the widening cast, but it could be\n  /// generalized for targets with other types of implicit widening casts.\n  bool ShrinkDemandedOp(SDValue Op, unsigned BitWidth, const APInt &Demanded,\n                        TargetLoweringOpt &TLO) const;\n\n  /// Look at Op.  At this point, we know that only the DemandedBits bits of the\n  /// result of Op are ever used downstream.  If we can use this information to\n  /// simplify Op, create a new simplified DAG node and return true, returning\n  /// the original and new nodes in Old and New.  Otherwise, analyze the\n  /// expression and return a mask of KnownOne and KnownZero bits for the\n  /// expression (used to simplify the caller).  The KnownZero/One bits may only\n  /// be accurate for those bits in the Demanded masks.\n  /// \\p AssumeSingleUse When this parameter is true, this function will\n  ///    attempt to simplify \\p Op even if there are multiple uses.\n  ///    Callers are responsible for correctly updating the DAG based on the\n  ///    results of this function, because simply replacing replacing TLO.Old\n  ///    with TLO.New will be incorrect when this parameter is true and TLO.Old\n  ///    has multiple uses.\n  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,\n                            const APInt &DemandedElts, KnownBits &Known,\n                            TargetLoweringOpt &TLO, unsigned Depth = 0,\n                            bool AssumeSingleUse = false) const;\n\n  /// Helper wrapper around SimplifyDemandedBits, demanding all elements.\n  /// Adds Op back to the worklist upon success.\n  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,\n                            KnownBits &Known, TargetLoweringOpt &TLO,\n                            unsigned Depth = 0,\n                            bool AssumeSingleUse = false) const;\n\n  /// Helper wrapper around SimplifyDemandedBits.\n  /// Adds Op back to the worklist upon success.\n  bool SimplifyDemandedBits(SDValue Op, const APInt &DemandedBits,\n                            DAGCombinerInfo &DCI) const;\n\n  /// More limited version of SimplifyDemandedBits that can be used to \"look\n  /// through\" ops that don't contribute to the DemandedBits/DemandedElts -\n  /// bitwise ops etc.\n  SDValue SimplifyMultipleUseDemandedBits(SDValue Op, const APInt &DemandedBits,\n                                          const APInt &DemandedElts,\n                                          SelectionDAG &DAG,\n                                          unsigned Depth) const;\n\n  /// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all\n  /// elements.\n  SDValue SimplifyMultipleUseDemandedBits(SDValue Op, const APInt &DemandedBits,\n                                          SelectionDAG &DAG,\n                                          unsigned Depth = 0) const;\n\n  /// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all\n  /// bits from only some vector elements.\n  SDValue SimplifyMultipleUseDemandedVectorElts(SDValue Op,\n                                                const APInt &DemandedElts,\n                                                SelectionDAG &DAG,\n                                                unsigned Depth = 0) const;\n\n  /// Look at Vector Op. At this point, we know that only the DemandedElts\n  /// elements of the result of Op are ever used downstream.  If we can use\n  /// this information to simplify Op, create a new simplified DAG node and\n  /// return true, storing the original and new nodes in TLO.\n  /// Otherwise, analyze the expression and return a mask of KnownUndef and\n  /// KnownZero elements for the expression (used to simplify the caller).\n  /// The KnownUndef/Zero elements may only be accurate for those bits\n  /// in the DemandedMask.\n  /// \\p AssumeSingleUse When this parameter is true, this function will\n  ///    attempt to simplify \\p Op even if there are multiple uses.\n  ///    Callers are responsible for correctly updating the DAG based on the\n  ///    results of this function, because simply replacing replacing TLO.Old\n  ///    with TLO.New will be incorrect when this parameter is true and TLO.Old\n  ///    has multiple uses.\n  bool SimplifyDemandedVectorElts(SDValue Op, const APInt &DemandedEltMask,\n                                  APInt &KnownUndef, APInt &KnownZero,\n                                  TargetLoweringOpt &TLO, unsigned Depth = 0,\n                                  bool AssumeSingleUse = false) const;\n\n  /// Helper wrapper around SimplifyDemandedVectorElts.\n  /// Adds Op back to the worklist upon success.\n  bool SimplifyDemandedVectorElts(SDValue Op, const APInt &DemandedElts,\n                                  APInt &KnownUndef, APInt &KnownZero,\n                                  DAGCombinerInfo &DCI) const;\n\n  /// Determine which of the bits specified in Mask are known to be either zero\n  /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts\n  /// argument allows us to only collect the known bits that are shared by the\n  /// requested vector elements.\n  virtual void computeKnownBitsForTargetNode(const SDValue Op,\n                                             KnownBits &Known,\n                                             const APInt &DemandedElts,\n                                             const SelectionDAG &DAG,\n                                             unsigned Depth = 0) const;\n\n  /// Determine which of the bits specified in Mask are known to be either zero\n  /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts\n  /// argument allows us to only collect the known bits that are shared by the\n  /// requested vector elements. This is for GISel.\n  virtual void computeKnownBitsForTargetInstr(GISelKnownBits &Analysis,\n                                              Register R, KnownBits &Known,\n                                              const APInt &DemandedElts,\n                                              const MachineRegisterInfo &MRI,\n                                              unsigned Depth = 0) const;\n\n  /// Determine the known alignment for the pointer value \\p R. This is can\n  /// typically be inferred from the number of low known 0 bits. However, for a\n  /// pointer with a non-integral address space, the alignment value may be\n  /// independent from the known low bits.\n  virtual Align computeKnownAlignForTargetInstr(GISelKnownBits &Analysis,\n                                                Register R,\n                                                const MachineRegisterInfo &MRI,\n                                                unsigned Depth = 0) const;\n\n  /// Determine which of the bits of FrameIndex \\p FIOp are known to be 0.\n  /// Default implementation computes low bits based on alignment\n  /// information. This should preserve known bits passed into it.\n  virtual void computeKnownBitsForFrameIndex(int FIOp,\n                                             KnownBits &Known,\n                                             const MachineFunction &MF) const;\n\n  /// This method can be implemented by targets that want to expose additional\n  /// information about sign bits to the DAG Combiner. The DemandedElts\n  /// argument allows us to only collect the minimum sign bits that are shared\n  /// by the requested vector elements.\n  virtual unsigned ComputeNumSignBitsForTargetNode(SDValue Op,\n                                                   const APInt &DemandedElts,\n                                                   const SelectionDAG &DAG,\n                                                   unsigned Depth = 0) const;\n\n  /// This method can be implemented by targets that want to expose additional\n  /// information about sign bits to GlobalISel combiners. The DemandedElts\n  /// argument allows us to only collect the minimum sign bits that are shared\n  /// by the requested vector elements.\n  virtual unsigned computeNumSignBitsForTargetInstr(GISelKnownBits &Analysis,\n                                                    Register R,\n                                                    const APInt &DemandedElts,\n                                                    const MachineRegisterInfo &MRI,\n                                                    unsigned Depth = 0) const;\n\n  /// Attempt to simplify any target nodes based on the demanded vector\n  /// elements, returning true on success. Otherwise, analyze the expression and\n  /// return a mask of KnownUndef and KnownZero elements for the expression\n  /// (used to simplify the caller). The KnownUndef/Zero elements may only be\n  /// accurate for those bits in the DemandedMask.\n  virtual bool SimplifyDemandedVectorEltsForTargetNode(\n      SDValue Op, const APInt &DemandedElts, APInt &KnownUndef,\n      APInt &KnownZero, TargetLoweringOpt &TLO, unsigned Depth = 0) const;\n\n  /// Attempt to simplify any target nodes based on the demanded bits/elts,\n  /// returning true on success. Otherwise, analyze the\n  /// expression and return a mask of KnownOne and KnownZero bits for the\n  /// expression (used to simplify the caller).  The KnownZero/One bits may only\n  /// be accurate for those bits in the Demanded masks.\n  virtual bool SimplifyDemandedBitsForTargetNode(SDValue Op,\n                                                 const APInt &DemandedBits,\n                                                 const APInt &DemandedElts,\n                                                 KnownBits &Known,\n                                                 TargetLoweringOpt &TLO,\n                                                 unsigned Depth = 0) const;\n\n  /// More limited version of SimplifyDemandedBits that can be used to \"look\n  /// through\" ops that don't contribute to the DemandedBits/DemandedElts -\n  /// bitwise ops etc.\n  virtual SDValue SimplifyMultipleUseDemandedBitsForTargetNode(\n      SDValue Op, const APInt &DemandedBits, const APInt &DemandedElts,\n      SelectionDAG &DAG, unsigned Depth) const;\n\n  /// Tries to build a legal vector shuffle using the provided parameters\n  /// or equivalent variations. The Mask argument maybe be modified as the\n  /// function tries different variations.\n  /// Returns an empty SDValue if the operation fails.\n  SDValue buildLegalVectorShuffle(EVT VT, const SDLoc &DL, SDValue N0,\n                                  SDValue N1, MutableArrayRef<int> Mask,\n                                  SelectionDAG &DAG) const;\n\n  /// This method returns the constant pool value that will be loaded by LD.\n  /// NOTE: You must check for implicit extensions of the constant by LD.\n  virtual const Constant *getTargetConstantFromLoad(LoadSDNode *LD) const;\n\n  /// If \\p SNaN is false, \\returns true if \\p Op is known to never be any\n  /// NaN. If \\p sNaN is true, returns if \\p Op is known to never be a signaling\n  /// NaN.\n  virtual bool isKnownNeverNaNForTargetNode(SDValue Op,\n                                            const SelectionDAG &DAG,\n                                            bool SNaN = false,\n                                            unsigned Depth = 0) const;\n  struct DAGCombinerInfo {\n    void *DC;  // The DAG Combiner object.\n    CombineLevel Level;\n    bool CalledByLegalizer;\n\n  public:\n    SelectionDAG &DAG;\n\n    DAGCombinerInfo(SelectionDAG &dag, CombineLevel level,  bool cl, void *dc)\n      : DC(dc), Level(level), CalledByLegalizer(cl), DAG(dag) {}\n\n    bool isBeforeLegalize() const { return Level == BeforeLegalizeTypes; }\n    bool isBeforeLegalizeOps() const { return Level < AfterLegalizeVectorOps; }\n    bool isAfterLegalizeDAG() const { return Level >= AfterLegalizeDAG; }\n    CombineLevel getDAGCombineLevel() { return Level; }\n    bool isCalledByLegalizer() const { return CalledByLegalizer; }\n\n    void AddToWorklist(SDNode *N);\n    SDValue CombineTo(SDNode *N, ArrayRef<SDValue> To, bool AddTo = true);\n    SDValue CombineTo(SDNode *N, SDValue Res, bool AddTo = true);\n    SDValue CombineTo(SDNode *N, SDValue Res0, SDValue Res1, bool AddTo = true);\n\n    bool recursivelyDeleteUnusedNodes(SDNode *N);\n\n    void CommitTargetLoweringOpt(const TargetLoweringOpt &TLO);\n  };\n\n  /// Return if the N is a constant or constant vector equal to the true value\n  /// from getBooleanContents().\n  bool isConstTrueVal(const SDNode *N) const;\n\n  /// Return if the N is a constant or constant vector equal to the false value\n  /// from getBooleanContents().\n  bool isConstFalseVal(const SDNode *N) const;\n\n  /// Return if \\p N is a True value when extended to \\p VT.\n  bool isExtendedTrueVal(const ConstantSDNode *N, EVT VT, bool SExt) const;\n\n  /// Try to simplify a setcc built with the specified operands and cc. If it is\n  /// unable to simplify it, return a null SDValue.\n  SDValue SimplifySetCC(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,\n                        bool foldBooleans, DAGCombinerInfo &DCI,\n                        const SDLoc &dl) const;\n\n  // For targets which wrap address, unwrap for analysis.\n  virtual SDValue unwrapAddress(SDValue N) const { return N; }\n\n  /// Returns true (and the GlobalValue and the offset) if the node is a\n  /// GlobalAddress + offset.\n  virtual bool\n  isGAPlusOffset(SDNode *N, const GlobalValue* &GA, int64_t &Offset) const;\n\n  /// This method will be invoked for all target nodes and for any\n  /// target-independent nodes that the target has registered with invoke it\n  /// for.\n  ///\n  /// The semantics are as follows:\n  /// Return Value:\n  ///   SDValue.Val == 0   - No change was made\n  ///   SDValue.Val == N   - N was replaced, is dead, and is already handled.\n  ///   otherwise          - N should be replaced by the returned Operand.\n  ///\n  /// In addition, methods provided by DAGCombinerInfo may be used to perform\n  /// more complex transformations.\n  ///\n  virtual SDValue PerformDAGCombine(SDNode *N, DAGCombinerInfo &DCI) const;\n\n  /// Return true if it is profitable to move this shift by a constant amount\n  /// though its operand, adjusting any immediate operands as necessary to\n  /// preserve semantics. This transformation may not be desirable if it\n  /// disrupts a particularly auspicious target-specific tree (e.g. bitfield\n  /// extraction in AArch64). By default, it returns true.\n  ///\n  /// @param N the shift node\n  /// @param Level the current DAGCombine legalization level.\n  virtual bool isDesirableToCommuteWithShift(const SDNode *N,\n                                             CombineLevel Level) const {\n    return true;\n  }\n\n  /// Return true if the target has native support for the specified value type\n  /// and it is 'desirable' to use the type for the given node type. e.g. On x86\n  /// i16 is legal, but undesirable since i16 instruction encodings are longer\n  /// and some i16 instructions are slow.\n  virtual bool isTypeDesirableForOp(unsigned /*Opc*/, EVT VT) const {\n    // By default, assume all legal types are desirable.\n    return isTypeLegal(VT);\n  }\n\n  /// Return true if it is profitable for dag combiner to transform a floating\n  /// point op of specified opcode to a equivalent op of an integer\n  /// type. e.g. f32 load -> i32 load can be profitable on ARM.\n  virtual bool isDesirableToTransformToIntegerOp(unsigned /*Opc*/,\n                                                 EVT /*VT*/) const {\n    return false;\n  }\n\n  /// This method query the target whether it is beneficial for dag combiner to\n  /// promote the specified node. If true, it should return the desired\n  /// promotion type by reference.\n  virtual bool IsDesirableToPromoteOp(SDValue /*Op*/, EVT &/*PVT*/) const {\n    return false;\n  }\n\n  /// Return true if the target supports swifterror attribute. It optimizes\n  /// loads and stores to reading and writing a specific register.\n  virtual bool supportSwiftError() const {\n    return false;\n  }\n\n  /// Return true if the target supports that a subset of CSRs for the given\n  /// machine function is handled explicitly via copies.\n  virtual bool supportSplitCSR(MachineFunction *MF) const {\n    return false;\n  }\n\n  /// Perform necessary initialization to handle a subset of CSRs explicitly\n  /// via copies. This function is called at the beginning of instruction\n  /// selection.\n  virtual void initializeSplitCSR(MachineBasicBlock *Entry) const {\n    llvm_unreachable(\"Not Implemented\");\n  }\n\n  /// Insert explicit copies in entry and exit blocks. We copy a subset of\n  /// CSRs to virtual registers in the entry block, and copy them back to\n  /// physical registers in the exit blocks. This function is called at the end\n  /// of instruction selection.\n  virtual void insertCopiesSplitCSR(\n      MachineBasicBlock *Entry,\n      const SmallVectorImpl<MachineBasicBlock *> &Exits) const {\n    llvm_unreachable(\"Not Implemented\");\n  }\n\n  /// Return the newly negated expression if the cost is not expensive and\n  /// set the cost in \\p Cost to indicate that if it is cheaper or neutral to\n  /// do the negation.\n  virtual SDValue getNegatedExpression(SDValue Op, SelectionDAG &DAG,\n                                       bool LegalOps, bool OptForSize,\n                                       NegatibleCost &Cost,\n                                       unsigned Depth = 0) const;\n\n  /// This is the helper function to return the newly negated expression only\n  /// when the cost is cheaper.\n  SDValue getCheaperNegatedExpression(SDValue Op, SelectionDAG &DAG,\n                                      bool LegalOps, bool OptForSize,\n                                      unsigned Depth = 0) const {\n    NegatibleCost Cost = NegatibleCost::Expensive;\n    SDValue Neg =\n        getNegatedExpression(Op, DAG, LegalOps, OptForSize, Cost, Depth);\n    if (Neg && Cost == NegatibleCost::Cheaper)\n      return Neg;\n    // Remove the new created node to avoid the side effect to the DAG.\n    if (Neg && Neg.getNode()->use_empty())\n      DAG.RemoveDeadNode(Neg.getNode());\n    return SDValue();\n  }\n\n  /// This is the helper function to return the newly negated expression if\n  /// the cost is not expensive.\n  SDValue getNegatedExpression(SDValue Op, SelectionDAG &DAG, bool LegalOps,\n                               bool OptForSize, unsigned Depth = 0) const {\n    NegatibleCost Cost = NegatibleCost::Expensive;\n    return getNegatedExpression(Op, DAG, LegalOps, OptForSize, Cost, Depth);\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Lowering methods - These methods must be implemented by targets so that\n  // the SelectionDAGBuilder code knows how to lower these.\n  //\n\n  /// Target-specific splitting of values into parts that fit a register\n  /// storing a legal type\n  virtual bool splitValueIntoRegisterParts(SelectionDAG &DAG, const SDLoc &DL,\n                                           SDValue Val, SDValue *Parts,\n                                           unsigned NumParts, MVT PartVT,\n                                           Optional<CallingConv::ID> CC) const {\n    return false;\n  }\n\n  /// Target-specific combining of register parts into its original value\n  virtual SDValue\n  joinRegisterPartsIntoValue(SelectionDAG &DAG, const SDLoc &DL,\n                             const SDValue *Parts, unsigned NumParts,\n                             MVT PartVT, EVT ValueVT,\n                             Optional<CallingConv::ID> CC) const {\n    return SDValue();\n  }\n\n  /// This hook must be implemented to lower the incoming (formal) arguments,\n  /// described by the Ins array, into the specified DAG. The implementation\n  /// should fill in the InVals array with legal-type argument values, and\n  /// return the resulting token chain value.\n  virtual SDValue LowerFormalArguments(\n      SDValue /*Chain*/, CallingConv::ID /*CallConv*/, bool /*isVarArg*/,\n      const SmallVectorImpl<ISD::InputArg> & /*Ins*/, const SDLoc & /*dl*/,\n      SelectionDAG & /*DAG*/, SmallVectorImpl<SDValue> & /*InVals*/) const {\n    llvm_unreachable(\"Not Implemented\");\n  }\n\n  /// This structure contains all information that is necessary for lowering\n  /// calls. It is passed to TLI::LowerCallTo when the SelectionDAG builder\n  /// needs to lower a call, and targets will see this struct in their LowerCall\n  /// implementation.\n  struct CallLoweringInfo {\n    SDValue Chain;\n    Type *RetTy = nullptr;\n    bool RetSExt           : 1;\n    bool RetZExt           : 1;\n    bool IsVarArg          : 1;\n    bool IsInReg           : 1;\n    bool DoesNotReturn     : 1;\n    bool IsReturnValueUsed : 1;\n    bool IsConvergent      : 1;\n    bool IsPatchPoint      : 1;\n    bool IsPreallocated : 1;\n    bool NoMerge           : 1;\n\n    // IsTailCall should be modified by implementations of\n    // TargetLowering::LowerCall that perform tail call conversions.\n    bool IsTailCall = false;\n\n    // Is Call lowering done post SelectionDAG type legalization.\n    bool IsPostTypeLegalization = false;\n\n    unsigned NumFixedArgs = -1;\n    CallingConv::ID CallConv = CallingConv::C;\n    SDValue Callee;\n    ArgListTy Args;\n    SelectionDAG &DAG;\n    SDLoc DL;\n    const CallBase *CB = nullptr;\n    SmallVector<ISD::OutputArg, 32> Outs;\n    SmallVector<SDValue, 32> OutVals;\n    SmallVector<ISD::InputArg, 32> Ins;\n    SmallVector<SDValue, 4> InVals;\n\n    CallLoweringInfo(SelectionDAG &DAG)\n        : RetSExt(false), RetZExt(false), IsVarArg(false), IsInReg(false),\n          DoesNotReturn(false), IsReturnValueUsed(true), IsConvergent(false),\n          IsPatchPoint(false), IsPreallocated(false), NoMerge(false),\n          DAG(DAG) {}\n\n    CallLoweringInfo &setDebugLoc(const SDLoc &dl) {\n      DL = dl;\n      return *this;\n    }\n\n    CallLoweringInfo &setChain(SDValue InChain) {\n      Chain = InChain;\n      return *this;\n    }\n\n    // setCallee with target/module-specific attributes\n    CallLoweringInfo &setLibCallee(CallingConv::ID CC, Type *ResultType,\n                                   SDValue Target, ArgListTy &&ArgsList) {\n      RetTy = ResultType;\n      Callee = Target;\n      CallConv = CC;\n      NumFixedArgs = ArgsList.size();\n      Args = std::move(ArgsList);\n\n      DAG.getTargetLoweringInfo().markLibCallAttributes(\n          &(DAG.getMachineFunction()), CC, Args);\n      return *this;\n    }\n\n    CallLoweringInfo &setCallee(CallingConv::ID CC, Type *ResultType,\n                                SDValue Target, ArgListTy &&ArgsList) {\n      RetTy = ResultType;\n      Callee = Target;\n      CallConv = CC;\n      NumFixedArgs = ArgsList.size();\n      Args = std::move(ArgsList);\n      return *this;\n    }\n\n    CallLoweringInfo &setCallee(Type *ResultType, FunctionType *FTy,\n                                SDValue Target, ArgListTy &&ArgsList,\n                                const CallBase &Call) {\n      RetTy = ResultType;\n\n      IsInReg = Call.hasRetAttr(Attribute::InReg);\n      DoesNotReturn =\n          Call.doesNotReturn() ||\n          (!isa<InvokeInst>(Call) && isa<UnreachableInst>(Call.getNextNode()));\n      IsVarArg = FTy->isVarArg();\n      IsReturnValueUsed = !Call.use_empty();\n      RetSExt = Call.hasRetAttr(Attribute::SExt);\n      RetZExt = Call.hasRetAttr(Attribute::ZExt);\n      NoMerge = Call.hasFnAttr(Attribute::NoMerge);\n      \n      Callee = Target;\n\n      CallConv = Call.getCallingConv();\n      NumFixedArgs = FTy->getNumParams();\n      Args = std::move(ArgsList);\n\n      CB = &Call;\n\n      return *this;\n    }\n\n    CallLoweringInfo &setInRegister(bool Value = true) {\n      IsInReg = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setNoReturn(bool Value = true) {\n      DoesNotReturn = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setVarArg(bool Value = true) {\n      IsVarArg = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setTailCall(bool Value = true) {\n      IsTailCall = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setDiscardResult(bool Value = true) {\n      IsReturnValueUsed = !Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setConvergent(bool Value = true) {\n      IsConvergent = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setSExtResult(bool Value = true) {\n      RetSExt = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setZExtResult(bool Value = true) {\n      RetZExt = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setIsPatchPoint(bool Value = true) {\n      IsPatchPoint = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setIsPreallocated(bool Value = true) {\n      IsPreallocated = Value;\n      return *this;\n    }\n\n    CallLoweringInfo &setIsPostTypeLegalization(bool Value=true) {\n      IsPostTypeLegalization = Value;\n      return *this;\n    }\n\n    ArgListTy &getArgs() {\n      return Args;\n    }\n  };\n\n  /// This structure is used to pass arguments to makeLibCall function.\n  struct MakeLibCallOptions {\n    // By passing type list before soften to makeLibCall, the target hook\n    // shouldExtendTypeInLibCall can get the original type before soften.\n    ArrayRef<EVT> OpsVTBeforeSoften;\n    EVT RetVTBeforeSoften;\n    bool IsSExt : 1;\n    bool DoesNotReturn : 1;\n    bool IsReturnValueUsed : 1;\n    bool IsPostTypeLegalization : 1;\n    bool IsSoften : 1;\n\n    MakeLibCallOptions()\n        : IsSExt(false), DoesNotReturn(false), IsReturnValueUsed(true),\n          IsPostTypeLegalization(false), IsSoften(false) {}\n\n    MakeLibCallOptions &setSExt(bool Value = true) {\n      IsSExt = Value;\n      return *this;\n    }\n\n    MakeLibCallOptions &setNoReturn(bool Value = true) {\n      DoesNotReturn = Value;\n      return *this;\n    }\n\n    MakeLibCallOptions &setDiscardResult(bool Value = true) {\n      IsReturnValueUsed = !Value;\n      return *this;\n    }\n\n    MakeLibCallOptions &setIsPostTypeLegalization(bool Value = true) {\n      IsPostTypeLegalization = Value;\n      return *this;\n    }\n\n    MakeLibCallOptions &setTypeListBeforeSoften(ArrayRef<EVT> OpsVT, EVT RetVT,\n                                                bool Value = true) {\n      OpsVTBeforeSoften = OpsVT;\n      RetVTBeforeSoften = RetVT;\n      IsSoften = Value;\n      return *this;\n    }\n  };\n\n  /// This function lowers an abstract call to a function into an actual call.\n  /// This returns a pair of operands.  The first element is the return value\n  /// for the function (if RetTy is not VoidTy).  The second element is the\n  /// outgoing token chain. It calls LowerCall to do the actual lowering.\n  std::pair<SDValue, SDValue> LowerCallTo(CallLoweringInfo &CLI) const;\n\n  /// This hook must be implemented to lower calls into the specified\n  /// DAG. The outgoing arguments to the call are described by the Outs array,\n  /// and the values to be returned by the call are described by the Ins\n  /// array. The implementation should fill in the InVals array with legal-type\n  /// return values from the call, and return the resulting token chain value.\n  virtual SDValue\n    LowerCall(CallLoweringInfo &/*CLI*/,\n              SmallVectorImpl<SDValue> &/*InVals*/) const {\n    llvm_unreachable(\"Not Implemented\");\n  }\n\n  /// Target-specific cleanup for formal ByVal parameters.\n  virtual void HandleByVal(CCState *, unsigned &, Align) const {}\n\n  /// This hook should be implemented to check whether the return values\n  /// described by the Outs array can fit into the return registers.  If false\n  /// is returned, an sret-demotion is performed.\n  virtual bool CanLowerReturn(CallingConv::ID /*CallConv*/,\n                              MachineFunction &/*MF*/, bool /*isVarArg*/,\n               const SmallVectorImpl<ISD::OutputArg> &/*Outs*/,\n               LLVMContext &/*Context*/) const\n  {\n    // Return true by default to get preexisting behavior.\n    return true;\n  }\n\n  /// This hook must be implemented to lower outgoing return values, described\n  /// by the Outs array, into the specified DAG. The implementation should\n  /// return the resulting token chain value.\n  virtual SDValue LowerReturn(SDValue /*Chain*/, CallingConv::ID /*CallConv*/,\n                              bool /*isVarArg*/,\n                              const SmallVectorImpl<ISD::OutputArg> & /*Outs*/,\n                              const SmallVectorImpl<SDValue> & /*OutVals*/,\n                              const SDLoc & /*dl*/,\n                              SelectionDAG & /*DAG*/) const {\n    llvm_unreachable(\"Not Implemented\");\n  }\n\n  /// Return true if result of the specified node is used by a return node\n  /// only. It also compute and return the input chain for the tail call.\n  ///\n  /// This is used to determine whether it is possible to codegen a libcall as\n  /// tail call at legalization time.\n  virtual bool isUsedByReturnOnly(SDNode *, SDValue &/*Chain*/) const {\n    return false;\n  }\n\n  /// Return true if the target may be able emit the call instruction as a tail\n  /// call. This is used by optimization passes to determine if it's profitable\n  /// to duplicate return instructions to enable tailcall optimization.\n  virtual bool mayBeEmittedAsTailCall(const CallInst *) const {\n    return false;\n  }\n\n  /// Return the builtin name for the __builtin___clear_cache intrinsic\n  /// Default is to invoke the clear cache library call\n  virtual const char * getClearCacheBuiltinName() const {\n    return \"__clear_cache\";\n  }\n\n  /// Return the register ID of the name passed in. Used by named register\n  /// global variables extension. There is no target-independent behaviour\n  /// so the default action is to bail.\n  virtual Register getRegisterByName(const char* RegName, LLT Ty,\n                                     const MachineFunction &MF) const {\n    report_fatal_error(\"Named registers not implemented for this target\");\n  }\n\n  /// Return the type that should be used to zero or sign extend a\n  /// zeroext/signext integer return value.  FIXME: Some C calling conventions\n  /// require the return type to be promoted, but this is not true all the time,\n  /// e.g. i1/i8/i16 on x86/x86_64. It is also not necessary for non-C calling\n  /// conventions. The frontend should handle this and include all of the\n  /// necessary information.\n  virtual EVT getTypeForExtReturn(LLVMContext &Context, EVT VT,\n                                       ISD::NodeType /*ExtendKind*/) const {\n    EVT MinVT = getRegisterType(Context, MVT::i32);\n    return VT.bitsLT(MinVT) ? MinVT : VT;\n  }\n\n  /// For some targets, an LLVM struct type must be broken down into multiple\n  /// simple types, but the calling convention specifies that the entire struct\n  /// must be passed in a block of consecutive registers.\n  virtual bool\n  functionArgumentNeedsConsecutiveRegisters(Type *Ty, CallingConv::ID CallConv,\n                                            bool isVarArg) const {\n    return false;\n  }\n\n  /// For most targets, an LLVM type must be broken down into multiple\n  /// smaller types. Usually the halves are ordered according to the endianness\n  /// but for some platform that would break. So this method will default to\n  /// matching the endianness but can be overridden.\n  virtual bool\n  shouldSplitFunctionArgumentsAsLittleEndian(const DataLayout &DL) const {\n    return DL.isLittleEndian();\n  }\n\n  /// Returns a 0 terminated array of registers that can be safely used as\n  /// scratch registers.\n  virtual const MCPhysReg *getScratchRegisters(CallingConv::ID CC) const {\n    return nullptr;\n  }\n\n  /// This callback is used to prepare for a volatile or atomic load.\n  /// It takes a chain node as input and returns the chain for the load itself.\n  ///\n  /// Having a callback like this is necessary for targets like SystemZ,\n  /// which allows a CPU to reuse the result of a previous load indefinitely,\n  /// even if a cache-coherent store is performed by another CPU.  The default\n  /// implementation does nothing.\n  virtual SDValue prepareVolatileOrAtomicLoad(SDValue Chain, const SDLoc &DL,\n                                              SelectionDAG &DAG) const {\n    return Chain;\n  }\n\n  /// Should SelectionDAG lower an atomic store of the given kind as a normal\n  /// StoreSDNode (as opposed to an AtomicSDNode)?  NOTE: The intention is to\n  /// eventually migrate all targets to the using StoreSDNodes, but porting is\n  /// being done target at a time.\n  virtual bool lowerAtomicStoreAsStoreSDNode(const StoreInst &SI) const {\n    assert(SI.isAtomic() && \"violated precondition\");\n    return false;\n  }\n\n  /// Should SelectionDAG lower an atomic load of the given kind as a normal\n  /// LoadSDNode (as opposed to an AtomicSDNode)?  NOTE: The intention is to\n  /// eventually migrate all targets to the using LoadSDNodes, but porting is\n  /// being done target at a time.\n  virtual bool lowerAtomicLoadAsLoadSDNode(const LoadInst &LI) const {\n    assert(LI.isAtomic() && \"violated precondition\");\n    return false;\n  }\n\n\n  /// This callback is invoked by the type legalizer to legalize nodes with an\n  /// illegal operand type but legal result types.  It replaces the\n  /// LowerOperation callback in the type Legalizer.  The reason we can not do\n  /// away with LowerOperation entirely is that LegalizeDAG isn't yet ready to\n  /// use this callback.\n  ///\n  /// TODO: Consider merging with ReplaceNodeResults.\n  ///\n  /// The target places new result values for the node in Results (their number\n  /// and types must exactly match those of the original return values of\n  /// the node), or leaves Results empty, which indicates that the node is not\n  /// to be custom lowered after all.\n  /// The default implementation calls LowerOperation.\n  virtual void LowerOperationWrapper(SDNode *N,\n                                     SmallVectorImpl<SDValue> &Results,\n                                     SelectionDAG &DAG) const;\n\n  /// This callback is invoked for operations that are unsupported by the\n  /// target, which are registered to use 'custom' lowering, and whose defined\n  /// values are all legal.  If the target has no operations that require custom\n  /// lowering, it need not implement this.  The default implementation of this\n  /// aborts.\n  virtual SDValue LowerOperation(SDValue Op, SelectionDAG &DAG) const;\n\n  /// This callback is invoked when a node result type is illegal for the\n  /// target, and the operation was registered to use 'custom' lowering for that\n  /// result type.  The target places new result values for the node in Results\n  /// (their number and types must exactly match those of the original return\n  /// values of the node), or leaves Results empty, which indicates that the\n  /// node is not to be custom lowered after all.\n  ///\n  /// If the target has no operations that require custom lowering, it need not\n  /// implement this.  The default implementation aborts.\n  virtual void ReplaceNodeResults(SDNode * /*N*/,\n                                  SmallVectorImpl<SDValue> &/*Results*/,\n                                  SelectionDAG &/*DAG*/) const {\n    llvm_unreachable(\"ReplaceNodeResults not implemented for this target!\");\n  }\n\n  /// This method returns the name of a target specific DAG node.\n  virtual const char *getTargetNodeName(unsigned Opcode) const;\n\n  /// This method returns a target specific FastISel object, or null if the\n  /// target does not support \"fast\" ISel.\n  virtual FastISel *createFastISel(FunctionLoweringInfo &,\n                                   const TargetLibraryInfo *) const {\n    return nullptr;\n  }\n\n  bool verifyReturnAddressArgumentIsConstant(SDValue Op,\n                                             SelectionDAG &DAG) const;\n\n  //===--------------------------------------------------------------------===//\n  // Inline Asm Support hooks\n  //\n\n  /// This hook allows the target to expand an inline asm call to be explicit\n  /// llvm code if it wants to.  This is useful for turning simple inline asms\n  /// into LLVM intrinsics, which gives the compiler more information about the\n  /// behavior of the code.\n  virtual bool ExpandInlineAsm(CallInst *) const {\n    return false;\n  }\n\n  enum ConstraintType {\n    C_Register,            // Constraint represents specific register(s).\n    C_RegisterClass,       // Constraint represents any of register(s) in class.\n    C_Memory,              // Memory constraint.\n    C_Immediate,           // Requires an immediate.\n    C_Other,               // Something else.\n    C_Unknown              // Unsupported constraint.\n  };\n\n  enum ConstraintWeight {\n    // Generic weights.\n    CW_Invalid  = -1,     // No match.\n    CW_Okay     = 0,      // Acceptable.\n    CW_Good     = 1,      // Good weight.\n    CW_Better   = 2,      // Better weight.\n    CW_Best     = 3,      // Best weight.\n\n    // Well-known weights.\n    CW_SpecificReg  = CW_Okay,    // Specific register operands.\n    CW_Register     = CW_Good,    // Register operands.\n    CW_Memory       = CW_Better,  // Memory operands.\n    CW_Constant     = CW_Best,    // Constant operand.\n    CW_Default      = CW_Okay     // Default or don't know type.\n  };\n\n  /// This contains information for each constraint that we are lowering.\n  struct AsmOperandInfo : public InlineAsm::ConstraintInfo {\n    /// This contains the actual string for the code, like \"m\".  TargetLowering\n    /// picks the 'best' code from ConstraintInfo::Codes that most closely\n    /// matches the operand.\n    std::string ConstraintCode;\n\n    /// Information about the constraint code, e.g. Register, RegisterClass,\n    /// Memory, Other, Unknown.\n    TargetLowering::ConstraintType ConstraintType = TargetLowering::C_Unknown;\n\n    /// If this is the result output operand or a clobber, this is null,\n    /// otherwise it is the incoming operand to the CallInst.  This gets\n    /// modified as the asm is processed.\n    Value *CallOperandVal = nullptr;\n\n    /// The ValueType for the operand value.\n    MVT ConstraintVT = MVT::Other;\n\n    /// Copy constructor for copying from a ConstraintInfo.\n    AsmOperandInfo(InlineAsm::ConstraintInfo Info)\n        : InlineAsm::ConstraintInfo(std::move(Info)) {}\n\n    /// Return true of this is an input operand that is a matching constraint\n    /// like \"4\".\n    bool isMatchingInputConstraint() const;\n\n    /// If this is an input matching constraint, this method returns the output\n    /// operand it matches.\n    unsigned getMatchedOperand() const;\n  };\n\n  using AsmOperandInfoVector = std::vector<AsmOperandInfo>;\n\n  /// Split up the constraint string from the inline assembly value into the\n  /// specific constraints and their prefixes, and also tie in the associated\n  /// operand values.  If this returns an empty vector, and if the constraint\n  /// string itself isn't empty, there was an error parsing.\n  virtual AsmOperandInfoVector ParseConstraints(const DataLayout &DL,\n                                                const TargetRegisterInfo *TRI,\n                                                const CallBase &Call) const;\n\n  /// Examine constraint type and operand type and determine a weight value.\n  /// The operand object must already have been set up with the operand type.\n  virtual ConstraintWeight getMultipleConstraintMatchWeight(\n      AsmOperandInfo &info, int maIndex) const;\n\n  /// Examine constraint string and operand type and determine a weight value.\n  /// The operand object must already have been set up with the operand type.\n  virtual ConstraintWeight getSingleConstraintMatchWeight(\n      AsmOperandInfo &info, const char *constraint) const;\n\n  /// Determines the constraint code and constraint type to use for the specific\n  /// AsmOperandInfo, setting OpInfo.ConstraintCode and OpInfo.ConstraintType.\n  /// If the actual operand being passed in is available, it can be passed in as\n  /// Op, otherwise an empty SDValue can be passed.\n  virtual void ComputeConstraintToUse(AsmOperandInfo &OpInfo,\n                                      SDValue Op,\n                                      SelectionDAG *DAG = nullptr) const;\n\n  /// Given a constraint, return the type of constraint it is for this target.\n  virtual ConstraintType getConstraintType(StringRef Constraint) const;\n\n  /// Given a physical register constraint (e.g.  {edx}), return the register\n  /// number and the register class for the register.\n  ///\n  /// Given a register class constraint, like 'r', if this corresponds directly\n  /// to an LLVM register class, return a register of 0 and the register class\n  /// pointer.\n  ///\n  /// This should only be used for C_Register constraints.  On error, this\n  /// returns a register number of 0 and a null register class pointer.\n  virtual std::pair<unsigned, const TargetRegisterClass *>\n  getRegForInlineAsmConstraint(const TargetRegisterInfo *TRI,\n                               StringRef Constraint, MVT VT) const;\n\n  virtual unsigned getInlineAsmMemConstraint(StringRef ConstraintCode) const {\n    if (ConstraintCode == \"m\")\n      return InlineAsm::Constraint_m;\n    return InlineAsm::Constraint_Unknown;\n  }\n\n  /// Try to replace an X constraint, which matches anything, with another that\n  /// has more specific requirements based on the type of the corresponding\n  /// operand.  This returns null if there is no replacement to make.\n  virtual const char *LowerXConstraint(EVT ConstraintVT) const;\n\n  /// Lower the specified operand into the Ops vector.  If it is invalid, don't\n  /// add anything to Ops.\n  virtual void LowerAsmOperandForConstraint(SDValue Op, std::string &Constraint,\n                                            std::vector<SDValue> &Ops,\n                                            SelectionDAG &DAG) const;\n\n  // Lower custom output constraints. If invalid, return SDValue().\n  virtual SDValue LowerAsmOutputForConstraint(SDValue &Chain, SDValue &Flag,\n                                              const SDLoc &DL,\n                                              const AsmOperandInfo &OpInfo,\n                                              SelectionDAG &DAG) const;\n\n  //===--------------------------------------------------------------------===//\n  // Div utility functions\n  //\n  SDValue BuildSDIV(SDNode *N, SelectionDAG &DAG, bool IsAfterLegalization,\n                    SmallVectorImpl<SDNode *> &Created) const;\n  SDValue BuildUDIV(SDNode *N, SelectionDAG &DAG, bool IsAfterLegalization,\n                    SmallVectorImpl<SDNode *> &Created) const;\n\n  /// Targets may override this function to provide custom SDIV lowering for\n  /// power-of-2 denominators.  If the target returns an empty SDValue, LLVM\n  /// assumes SDIV is expensive and replaces it with a series of other integer\n  /// operations.\n  virtual SDValue BuildSDIVPow2(SDNode *N, const APInt &Divisor,\n                                SelectionDAG &DAG,\n                                SmallVectorImpl<SDNode *> &Created) const;\n\n  /// Indicate whether this target prefers to combine FDIVs with the same\n  /// divisor. If the transform should never be done, return zero. If the\n  /// transform should be done, return the minimum number of divisor uses\n  /// that must exist.\n  virtual unsigned combineRepeatedFPDivisors() const {\n    return 0;\n  }\n\n  /// Hooks for building estimates in place of slower divisions and square\n  /// roots.\n\n  /// Return either a square root or its reciprocal estimate value for the input\n  /// operand.\n  /// \\p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or\n  /// 'Enabled' as set by a potential default override attribute.\n  /// If \\p RefinementSteps is 'Unspecified', the number of Newton-Raphson\n  /// refinement iterations required to generate a sufficient (though not\n  /// necessarily IEEE-754 compliant) estimate is returned in that parameter.\n  /// The boolean UseOneConstNR output is used to select a Newton-Raphson\n  /// algorithm implementation that uses either one or two constants.\n  /// The boolean Reciprocal is used to select whether the estimate is for the\n  /// square root of the input operand or the reciprocal of its square root.\n  /// A target may choose to implement its own refinement within this function.\n  /// If that's true, then return '0' as the number of RefinementSteps to avoid\n  /// any further refinement of the estimate.\n  /// An empty SDValue return means no estimate sequence can be created.\n  virtual SDValue getSqrtEstimate(SDValue Operand, SelectionDAG &DAG,\n                                  int Enabled, int &RefinementSteps,\n                                  bool &UseOneConstNR, bool Reciprocal) const {\n    return SDValue();\n  }\n\n  /// Return a reciprocal estimate value for the input operand.\n  /// \\p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or\n  /// 'Enabled' as set by a potential default override attribute.\n  /// If \\p RefinementSteps is 'Unspecified', the number of Newton-Raphson\n  /// refinement iterations required to generate a sufficient (though not\n  /// necessarily IEEE-754 compliant) estimate is returned in that parameter.\n  /// A target may choose to implement its own refinement within this function.\n  /// If that's true, then return '0' as the number of RefinementSteps to avoid\n  /// any further refinement of the estimate.\n  /// An empty SDValue return means no estimate sequence can be created.\n  virtual SDValue getRecipEstimate(SDValue Operand, SelectionDAG &DAG,\n                                   int Enabled, int &RefinementSteps) const {\n    return SDValue();\n  }\n\n  /// Return a target-dependent comparison result if the input operand is\n  /// suitable for use with a square root estimate calculation. For example, the\n  /// comparison may check if the operand is NAN, INF, zero, normal, etc. The\n  /// result should be used as the condition operand for a select or branch.\n  virtual SDValue getSqrtInputTest(SDValue Operand, SelectionDAG &DAG,\n                                   const DenormalMode &Mode) const;\n\n  /// Return a target-dependent result if the input operand is not suitable for\n  /// use with a square root estimate calculation.\n  virtual SDValue getSqrtResultForDenormInput(SDValue Operand,\n                                              SelectionDAG &DAG) const {\n    return DAG.getConstantFP(0.0, SDLoc(Operand), Operand.getValueType());\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Legalization utility functions\n  //\n\n  /// Expand a MUL or [US]MUL_LOHI of n-bit values into two or four nodes,\n  /// respectively, each computing an n/2-bit part of the result.\n  /// \\param Result A vector that will be filled with the parts of the result\n  ///        in little-endian order.\n  /// \\param LL Low bits of the LHS of the MUL.  You can use this parameter\n  ///        if you want to control how low bits are extracted from the LHS.\n  /// \\param LH High bits of the LHS of the MUL.  See LL for meaning.\n  /// \\param RL Low bits of the RHS of the MUL.  See LL for meaning\n  /// \\param RH High bits of the RHS of the MUL.  See LL for meaning.\n  /// \\returns true if the node has been expanded, false if it has not\n  bool expandMUL_LOHI(unsigned Opcode, EVT VT, const SDLoc &dl, SDValue LHS,\n                      SDValue RHS, SmallVectorImpl<SDValue> &Result, EVT HiLoVT,\n                      SelectionDAG &DAG, MulExpansionKind Kind,\n                      SDValue LL = SDValue(), SDValue LH = SDValue(),\n                      SDValue RL = SDValue(), SDValue RH = SDValue()) const;\n\n  /// Expand a MUL into two nodes.  One that computes the high bits of\n  /// the result and one that computes the low bits.\n  /// \\param HiLoVT The value type to use for the Lo and Hi nodes.\n  /// \\param LL Low bits of the LHS of the MUL.  You can use this parameter\n  ///        if you want to control how low bits are extracted from the LHS.\n  /// \\param LH High bits of the LHS of the MUL.  See LL for meaning.\n  /// \\param RL Low bits of the RHS of the MUL.  See LL for meaning\n  /// \\param RH High bits of the RHS of the MUL.  See LL for meaning.\n  /// \\returns true if the node has been expanded. false if it has not\n  bool expandMUL(SDNode *N, SDValue &Lo, SDValue &Hi, EVT HiLoVT,\n                 SelectionDAG &DAG, MulExpansionKind Kind,\n                 SDValue LL = SDValue(), SDValue LH = SDValue(),\n                 SDValue RL = SDValue(), SDValue RH = SDValue()) const;\n\n  /// Expand funnel shift.\n  /// \\param N Node to expand\n  /// \\param Result output after conversion\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandFunnelShift(SDNode *N, SDValue &Result, SelectionDAG &DAG) const;\n\n  /// Expand rotations.\n  /// \\param N Node to expand\n  /// \\param AllowVectorOps expand vector rotate, this should only be performed\n  ///        if the legalization is happening outside of LegalizeVectorOps\n  /// \\param Result output after conversion\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandROT(SDNode *N, bool AllowVectorOps, SDValue &Result,\n                 SelectionDAG &DAG) const;\n\n  /// Expand float(f32) to SINT(i64) conversion\n  /// \\param N Node to expand\n  /// \\param Result output after conversion\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandFP_TO_SINT(SDNode *N, SDValue &Result, SelectionDAG &DAG) const;\n\n  /// Expand float to UINT conversion\n  /// \\param N Node to expand\n  /// \\param Result output after conversion\n  /// \\param Chain output chain after conversion\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandFP_TO_UINT(SDNode *N, SDValue &Result, SDValue &Chain,\n                        SelectionDAG &DAG) const;\n\n  /// Expand UINT(i64) to double(f64) conversion\n  /// \\param N Node to expand\n  /// \\param Result output after conversion\n  /// \\param Chain output chain after conversion\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandUINT_TO_FP(SDNode *N, SDValue &Result, SDValue &Chain,\n                        SelectionDAG &DAG) const;\n\n  /// Expand fminnum/fmaxnum into fminnum_ieee/fmaxnum_ieee with quieted inputs.\n  SDValue expandFMINNUM_FMAXNUM(SDNode *N, SelectionDAG &DAG) const;\n\n  /// Expand FP_TO_[US]INT_SAT into FP_TO_[US]INT and selects or min/max.\n  /// \\param N Node to expand\n  /// \\returns The expansion result\n  SDValue expandFP_TO_INT_SAT(SDNode *N, SelectionDAG &DAG) const;\n\n  /// Expand CTPOP nodes. Expands vector/scalar CTPOP nodes,\n  /// vector nodes can only succeed if all operations are legal/custom.\n  /// \\param N Node to expand\n  /// \\param Result output after conversion\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandCTPOP(SDNode *N, SDValue &Result, SelectionDAG &DAG) const;\n\n  /// Expand CTLZ/CTLZ_ZERO_UNDEF nodes. Expands vector/scalar CTLZ nodes,\n  /// vector nodes can only succeed if all operations are legal/custom.\n  /// \\param N Node to expand\n  /// \\param Result output after conversion\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandCTLZ(SDNode *N, SDValue &Result, SelectionDAG &DAG) const;\n\n  /// Expand CTTZ/CTTZ_ZERO_UNDEF nodes. Expands vector/scalar CTTZ nodes,\n  /// vector nodes can only succeed if all operations are legal/custom.\n  /// \\param N Node to expand\n  /// \\param Result output after conversion\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandCTTZ(SDNode *N, SDValue &Result, SelectionDAG &DAG) const;\n\n  /// Expand ABS nodes. Expands vector/scalar ABS nodes,\n  /// vector nodes can only succeed if all operations are legal/custom.\n  /// (ABS x) -> (XOR (ADD x, (SRA x, type_size)), (SRA x, type_size))\n  /// \\param N Node to expand\n  /// \\param Result output after conversion\n  /// \\param IsNegative indicate negated abs\n  /// \\returns True, if the expansion was successful, false otherwise\n  bool expandABS(SDNode *N, SDValue &Result, SelectionDAG &DAG,\n                 bool IsNegative = false) const;\n\n  /// Expand BSWAP nodes. Expands scalar/vector BSWAP nodes with i16/i32/i64\n  /// scalar types. Returns SDValue() if expand fails.\n  /// \\param N Node to expand\n  /// \\returns The expansion result or SDValue() if it fails.\n  SDValue expandBSWAP(SDNode *N, SelectionDAG &DAG) const;\n\n  /// Turn load of vector type into a load of the individual elements.\n  /// \\param LD load to expand\n  /// \\returns BUILD_VECTOR and TokenFactor nodes.\n  std::pair<SDValue, SDValue> scalarizeVectorLoad(LoadSDNode *LD,\n                                                  SelectionDAG &DAG) const;\n\n  // Turn a store of a vector type into stores of the individual elements.\n  /// \\param ST Store with a vector value type\n  /// \\returns TokenFactor of the individual store chains.\n  SDValue scalarizeVectorStore(StoreSDNode *ST, SelectionDAG &DAG) const;\n\n  /// Expands an unaligned load to 2 half-size loads for an integer, and\n  /// possibly more for vectors.\n  std::pair<SDValue, SDValue> expandUnalignedLoad(LoadSDNode *LD,\n                                                  SelectionDAG &DAG) const;\n\n  /// Expands an unaligned store to 2 half-size stores for integer values, and\n  /// possibly more for vectors.\n  SDValue expandUnalignedStore(StoreSDNode *ST, SelectionDAG &DAG) const;\n\n  /// Increments memory address \\p Addr according to the type of the value\n  /// \\p DataVT that should be stored. If the data is stored in compressed\n  /// form, the memory address should be incremented according to the number of\n  /// the stored elements. This number is equal to the number of '1's bits\n  /// in the \\p Mask.\n  /// \\p DataVT is a vector type. \\p Mask is a vector value.\n  /// \\p DataVT and \\p Mask have the same number of vector elements.\n  SDValue IncrementMemoryAddress(SDValue Addr, SDValue Mask, const SDLoc &DL,\n                                 EVT DataVT, SelectionDAG &DAG,\n                                 bool IsCompressedMemory) const;\n\n  /// Get a pointer to vector element \\p Idx located in memory for a vector of\n  /// type \\p VecVT starting at a base address of \\p VecPtr. If \\p Idx is out of\n  /// bounds the returned pointer is unspecified, but will be within the vector\n  /// bounds.\n  SDValue getVectorElementPointer(SelectionDAG &DAG, SDValue VecPtr, EVT VecVT,\n                                  SDValue Index) const;\n\n  /// Method for building the DAG expansion of ISD::[US][MIN|MAX]. This\n  /// method accepts integers as its arguments.\n  SDValue expandIntMINMAX(SDNode *Node, SelectionDAG &DAG) const;\n\n  /// Method for building the DAG expansion of ISD::[US][ADD|SUB]SAT. This\n  /// method accepts integers as its arguments.\n  SDValue expandAddSubSat(SDNode *Node, SelectionDAG &DAG) const;\n\n  /// Method for building the DAG expansion of ISD::[US]SHLSAT. This\n  /// method accepts integers as its arguments.\n  SDValue expandShlSat(SDNode *Node, SelectionDAG &DAG) const;\n\n  /// Method for building the DAG expansion of ISD::[U|S]MULFIX[SAT]. This\n  /// method accepts integers as its arguments.\n  SDValue expandFixedPointMul(SDNode *Node, SelectionDAG &DAG) const;\n\n  /// Method for building the DAG expansion of ISD::[US]DIVFIX[SAT]. This\n  /// method accepts integers as its arguments.\n  /// Note: This method may fail if the division could not be performed\n  /// within the type. Clients must retry with a wider type if this happens.\n  SDValue expandFixedPointDiv(unsigned Opcode, const SDLoc &dl,\n                              SDValue LHS, SDValue RHS,\n                              unsigned Scale, SelectionDAG &DAG) const;\n\n  /// Method for building the DAG expansion of ISD::U(ADD|SUB)O. Expansion\n  /// always suceeds and populates the Result and Overflow arguments.\n  void expandUADDSUBO(SDNode *Node, SDValue &Result, SDValue &Overflow,\n                      SelectionDAG &DAG) const;\n\n  /// Method for building the DAG expansion of ISD::S(ADD|SUB)O. Expansion\n  /// always suceeds and populates the Result and Overflow arguments.\n  void expandSADDSUBO(SDNode *Node, SDValue &Result, SDValue &Overflow,\n                      SelectionDAG &DAG) const;\n\n  /// Method for building the DAG expansion of ISD::[US]MULO. Returns whether\n  /// expansion was successful and populates the Result and Overflow arguments.\n  bool expandMULO(SDNode *Node, SDValue &Result, SDValue &Overflow,\n                  SelectionDAG &DAG) const;\n\n  /// Expand a VECREDUCE_* into an explicit calculation. If Count is specified,\n  /// only the first Count elements of the vector are used.\n  SDValue expandVecReduce(SDNode *Node, SelectionDAG &DAG) const;\n\n  /// Expand a VECREDUCE_SEQ_* into an explicit ordered calculation.\n  SDValue expandVecReduceSeq(SDNode *Node, SelectionDAG &DAG) const;\n\n  /// Expand an SREM or UREM using SDIV/UDIV or SDIVREM/UDIVREM, if legal.\n  /// Returns true if the expansion was successful.\n  bool expandREM(SDNode *Node, SDValue &Result, SelectionDAG &DAG) const;\n\n  //===--------------------------------------------------------------------===//\n  // Instruction Emitting Hooks\n  //\n\n  /// This method should be implemented by targets that mark instructions with\n  /// the 'usesCustomInserter' flag.  These instructions are special in various\n  /// ways, which require special support to insert.  The specified MachineInstr\n  /// is created but not inserted into any basic blocks, and this method is\n  /// called to expand it into a sequence of instructions, potentially also\n  /// creating new basic blocks and control flow.\n  /// As long as the returned basic block is different (i.e., we created a new\n  /// one), the custom inserter is free to modify the rest of \\p MBB.\n  virtual MachineBasicBlock *\n  EmitInstrWithCustomInserter(MachineInstr &MI, MachineBasicBlock *MBB) const;\n\n  /// This method should be implemented by targets that mark instructions with\n  /// the 'hasPostISelHook' flag. These instructions must be adjusted after\n  /// instruction selection by target hooks.  e.g. To fill in optional defs for\n  /// ARM 's' setting instructions.\n  virtual void AdjustInstrPostInstrSelection(MachineInstr &MI,\n                                             SDNode *Node) const;\n\n  /// If this function returns true, SelectionDAGBuilder emits a\n  /// LOAD_STACK_GUARD node when it is lowering Intrinsic::stackprotector.\n  virtual bool useLoadStackGuardNode() const {\n    return false;\n  }\n\n  virtual SDValue emitStackGuardXorFP(SelectionDAG &DAG, SDValue Val,\n                                      const SDLoc &DL) const {\n    llvm_unreachable(\"not implemented for this target\");\n  }\n\n  /// Lower TLS global address SDNode for target independent emulated TLS model.\n  virtual SDValue LowerToTLSEmulatedModel(const GlobalAddressSDNode *GA,\n                                          SelectionDAG &DAG) const;\n\n  /// Expands target specific indirect branch for the case of JumpTable\n  /// expanasion.\n  virtual SDValue expandIndirectJTBranch(const SDLoc& dl, SDValue Value, SDValue Addr,\n                                         SelectionDAG &DAG) const {\n    return DAG.getNode(ISD::BRIND, dl, MVT::Other, Value, Addr);\n  }\n\n  // seteq(x, 0) -> truncate(srl(ctlz(zext(x)), log2(#bits)))\n  // If we're comparing for equality to zero and isCtlzFast is true, expose the\n  // fact that this can be implemented as a ctlz/srl pair, so that the dag\n  // combiner can fold the new nodes.\n  SDValue lowerCmpEqZeroToCtlzSrl(SDValue Op, SelectionDAG &DAG) const;\n\n  /// Give targets the chance to reduce the number of distinct addresing modes.\n  ISD::MemIndexType getCanonicalIndexType(ISD::MemIndexType IndexType,\n                                          EVT MemVT, SDValue Offsets) const;\n\nprivate:\n  SDValue foldSetCCWithAnd(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,\n                           const SDLoc &DL, DAGCombinerInfo &DCI) const;\n  SDValue foldSetCCWithBinOp(EVT VT, SDValue N0, SDValue N1, ISD::CondCode Cond,\n                             const SDLoc &DL, DAGCombinerInfo &DCI) const;\n\n  SDValue optimizeSetCCOfSignedTruncationCheck(EVT SCCVT, SDValue N0,\n                                               SDValue N1, ISD::CondCode Cond,\n                                               DAGCombinerInfo &DCI,\n                                               const SDLoc &DL) const;\n\n  // (X & (C l>>/<< Y)) ==/!= 0  -->  ((X <</l>> Y) & C) ==/!= 0\n  SDValue optimizeSetCCByHoistingAndByConstFromLogicalShift(\n      EVT SCCVT, SDValue N0, SDValue N1C, ISD::CondCode Cond,\n      DAGCombinerInfo &DCI, const SDLoc &DL) const;\n\n  SDValue prepareUREMEqFold(EVT SETCCVT, SDValue REMNode,\n                            SDValue CompTargetNode, ISD::CondCode Cond,\n                            DAGCombinerInfo &DCI, const SDLoc &DL,\n                            SmallVectorImpl<SDNode *> &Created) const;\n  SDValue buildUREMEqFold(EVT SETCCVT, SDValue REMNode, SDValue CompTargetNode,\n                          ISD::CondCode Cond, DAGCombinerInfo &DCI,\n                          const SDLoc &DL) const;\n\n  SDValue prepareSREMEqFold(EVT SETCCVT, SDValue REMNode,\n                            SDValue CompTargetNode, ISD::CondCode Cond,\n                            DAGCombinerInfo &DCI, const SDLoc &DL,\n                            SmallVectorImpl<SDNode *> &Created) const;\n  SDValue buildSREMEqFold(EVT SETCCVT, SDValue REMNode, SDValue CompTargetNode,\n                          ISD::CondCode Cond, DAGCombinerInfo &DCI,\n                          const SDLoc &DL) const;\n};\n\n/// Given an LLVM IR type and return type attributes, compute the return value\n/// EVTs and flags, and optionally also the offsets, if the return value is\n/// being lowered to memory.\nvoid GetReturnInfo(CallingConv::ID CC, Type *ReturnType, AttributeList attr,\n                   SmallVectorImpl<ISD::OutputArg> &Outs,\n                   const TargetLowering &TLI, const DataLayout &DL);\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_TARGETLOWERING_H\n"}}, "reports": [{"events": [{"location": {"col": 22, "file": 2, "line": 2356}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 3371}, "message": "differing parameters are named here: ('DemandedEltMask'), in definition: ('OriginalDemandedElts')"}, {"location": {"col": 8, "file": 1, "line": 3371}, "message": "function 'llvm::TargetLowering::SimplifyDemandedVectorElts' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h", "reportHash": "8cca85632a0be7f05f653bf94ba83969", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 22, "file": 2, "line": 2938}, "message": "the definition seen here"}, {"location": {"col": 16, "file": 1, "line": 3414}, "message": "differing parameters are named here: ('FIOp'), in definition: ('FrameIdx')"}, {"location": {"col": 16, "file": 1, "line": 3414}, "message": "function 'llvm::TargetLowering::computeKnownBitsForFrameIndex' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h", "reportHash": "428b0c8c040f27068eb2b00c0b2bf311", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
