<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp", "content": "//===- SLPVectorizer.cpp - A bottom up SLP Vectorizer ---------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This pass implements the Bottom Up SLP vectorizer. It detects consecutive\n// stores that can be put together into vector-stores. Next, it attempts to\n// construct vectorizable tree using the use-def chains. If a profitable tree\n// was found, the SLP vectorizer performs vectorization on the tree.\n//\n// The pass is inspired by the work described in the paper:\n//  \"Loop-Aware SLP in GCC\" by Ira Rosen, Dorit Nuzman, Ayal Zaks.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/Transforms/Vectorize/SLPVectorizer.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PostOrderIterator.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Analysis/AliasAnalysis.h\"\n#include \"llvm/Analysis/AssumptionCache.h\"\n#include \"llvm/Analysis/CodeMetrics.h\"\n#include \"llvm/Analysis/DemandedBits.h\"\n#include \"llvm/Analysis/GlobalsModRef.h\"\n#include \"llvm/Analysis/IVDescriptors.h\"\n#include \"llvm/Analysis/LoopAccessAnalysis.h\"\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/Analysis/MemoryLocation.h\"\n#include \"llvm/Analysis/OptimizationRemarkEmitter.h\"\n#include \"llvm/Analysis/ScalarEvolution.h\"\n#include \"llvm/Analysis/ScalarEvolutionExpressions.h\"\n#include \"llvm/Analysis/TargetLibraryInfo.h\"\n#include \"llvm/Analysis/TargetTransformInfo.h\"\n#include \"llvm/Analysis/ValueTracking.h\"\n#include \"llvm/Analysis/VectorUtils.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/NoFolder.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/IR/Verifier.h\"\n#include \"llvm/InitializePasses.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/DOTGraphTraits.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/GraphWriter.h\"\n#include \"llvm/Support/InstructionCost.h\"\n#include \"llvm/Support/KnownBits.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Transforms/Utils/InjectTLIMappings.h\"\n#include \"llvm/Transforms/Utils/LoopUtils.h\"\n#include \"llvm/Transforms/Vectorize.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <iterator>\n#include <memory>\n#include <set>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nusing namespace llvm;\nusing namespace llvm::PatternMatch;\nusing namespace slpvectorizer;\n\n#define SV_NAME \"slp-vectorizer\"\n#define DEBUG_TYPE \"SLP\"\n\nSTATISTIC(NumVectorInstructions, \"Number of vector instructions generated\");\n\ncl::opt<bool> RunSLPVectorization(\"vectorize-slp\", cl::init(true), cl::Hidden,\n                                  cl::desc(\"Run the SLP vectorization passes\"));\n\nstatic cl::opt<int>\n    SLPCostThreshold(\"slp-threshold\", cl::init(0), cl::Hidden,\n                     cl::desc(\"Only vectorize if you gain more than this \"\n                              \"number \"));\n\nstatic cl::opt<bool>\nShouldVectorizeHor(\"slp-vectorize-hor\", cl::init(true), cl::Hidden,\n                   cl::desc(\"Attempt to vectorize horizontal reductions\"));\n\nstatic cl::opt<bool> ShouldStartVectorizeHorAtStore(\n    \"slp-vectorize-hor-store\", cl::init(false), cl::Hidden,\n    cl::desc(\n        \"Attempt to vectorize horizontal reductions feeding into a store\"));\n\nstatic cl::opt<int>\nMaxVectorRegSizeOption(\"slp-max-reg-size\", cl::init(128), cl::Hidden,\n    cl::desc(\"Attempt to vectorize for this register size in bits\"));\n\nstatic cl::opt<unsigned>\nMaxVFOption(\"slp-max-vf\", cl::init(0), cl::Hidden,\n    cl::desc(\"Maximum SLP vectorization factor (0=unlimited)\"));\n\nstatic cl::opt<int>\nMaxStoreLookup(\"slp-max-store-lookup\", cl::init(32), cl::Hidden,\n    cl::desc(\"Maximum depth of the lookup for consecutive stores.\"));\n\n/// Limits the size of scheduling regions in a block.\n/// It avoid long compile times for _very_ large blocks where vector\n/// instructions are spread over a wide range.\n/// This limit is way higher than needed by real-world functions.\nstatic cl::opt<int>\nScheduleRegionSizeBudget(\"slp-schedule-budget\", cl::init(100000), cl::Hidden,\n    cl::desc(\"Limit the size of the SLP scheduling region per block\"));\n\nstatic cl::opt<int> MinVectorRegSizeOption(\n    \"slp-min-reg-size\", cl::init(128), cl::Hidden,\n    cl::desc(\"Attempt to vectorize for this register size in bits\"));\n\nstatic cl::opt<unsigned> RecursionMaxDepth(\n    \"slp-recursion-max-depth\", cl::init(12), cl::Hidden,\n    cl::desc(\"Limit the recursion depth when building a vectorizable tree\"));\n\nstatic cl::opt<unsigned> MinTreeSize(\n    \"slp-min-tree-size\", cl::init(3), cl::Hidden,\n    cl::desc(\"Only vectorize small trees if they are fully vectorizable\"));\n\n// The maximum depth that the look-ahead score heuristic will explore.\n// The higher this value, the higher the compilation time overhead.\nstatic cl::opt<int> LookAheadMaxDepth(\n    \"slp-max-look-ahead-depth\", cl::init(2), cl::Hidden,\n    cl::desc(\"The maximum look-ahead depth for operand reordering scores\"));\n\n// The Look-ahead heuristic goes through the users of the bundle to calculate\n// the users cost in getExternalUsesCost(). To avoid compilation time increase\n// we limit the number of users visited to this value.\nstatic cl::opt<unsigned> LookAheadUsersBudget(\n    \"slp-look-ahead-users-budget\", cl::init(2), cl::Hidden,\n    cl::desc(\"The maximum number of users to visit while visiting the \"\n             \"predecessors. This prevents compilation time increase.\"));\n\nstatic cl::opt<bool>\n    ViewSLPTree(\"view-slp-tree\", cl::Hidden,\n                cl::desc(\"Display the SLP trees with Graphviz\"));\n\n// Limit the number of alias checks. The limit is chosen so that\n// it has no negative effect on the llvm benchmarks.\nstatic const unsigned AliasedCheckLimit = 10;\n\n// Another limit for the alias checks: The maximum distance between load/store\n// instructions where alias checks are done.\n// This limit is useful for very large basic blocks.\nstatic const unsigned MaxMemDepDistance = 160;\n\n/// If the ScheduleRegionSizeBudget is exhausted, we allow small scheduling\n/// regions to be handled.\nstatic const int MinScheduleRegionSize = 16;\n\n/// Predicate for the element types that the SLP vectorizer supports.\n///\n/// The most important thing to filter here are types which are invalid in LLVM\n/// vectors. We also filter target specific types which have absolutely no\n/// meaningful vectorization path such as x86_fp80 and ppc_f128. This just\n/// avoids spending time checking the cost model and realizing that they will\n/// be inevitably scalarized.\nstatic bool isValidElementType(Type *Ty) {\n  return VectorType::isValidElementType(Ty) && !Ty->isX86_FP80Ty() &&\n         !Ty->isPPC_FP128Ty();\n}\n\n/// \\returns true if all of the instructions in \\p VL are in the same block or\n/// false otherwise.\nstatic bool allSameBlock(ArrayRef<Value *> VL) {\n  Instruction *I0 = dyn_cast<Instruction>(VL[0]);\n  if (!I0)\n    return false;\n  BasicBlock *BB = I0->getParent();\n  for (int I = 1, E = VL.size(); I < E; I++) {\n    auto *II = dyn_cast<Instruction>(VL[I]);\n    if (!II)\n      return false;\n\n    if (BB != II->getParent())\n      return false;\n  }\n  return true;\n}\n\n/// \\returns True if all of the values in \\p VL are constants (but not\n/// globals/constant expressions).\nstatic bool allConstant(ArrayRef<Value *> VL) {\n  // Constant expressions and globals can't be vectorized like normal integer/FP\n  // constants.\n  for (Value *i : VL)\n    if (!isa<Constant>(i) || isa<ConstantExpr>(i) || isa<GlobalValue>(i))\n      return false;\n  return true;\n}\n\n/// \\returns True if all of the values in \\p VL are identical.\nstatic bool isSplat(ArrayRef<Value *> VL) {\n  for (unsigned i = 1, e = VL.size(); i < e; ++i)\n    if (VL[i] != VL[0])\n      return false;\n  return true;\n}\n\n/// \\returns True if \\p I is commutative, handles CmpInst and BinaryOperator.\nstatic bool isCommutative(Instruction *I) {\n  if (auto *Cmp = dyn_cast<CmpInst>(I))\n    return Cmp->isCommutative();\n  if (auto *BO = dyn_cast<BinaryOperator>(I))\n    return BO->isCommutative();\n  // TODO: This should check for generic Instruction::isCommutative(), but\n  //       we need to confirm that the caller code correctly handles Intrinsics\n  //       for example (does not have 2 operands).\n  return false;\n}\n\n/// Checks if the vector of instructions can be represented as a shuffle, like:\n/// %x0 = extractelement <4 x i8> %x, i32 0\n/// %x3 = extractelement <4 x i8> %x, i32 3\n/// %y1 = extractelement <4 x i8> %y, i32 1\n/// %y2 = extractelement <4 x i8> %y, i32 2\n/// %x0x0 = mul i8 %x0, %x0\n/// %x3x3 = mul i8 %x3, %x3\n/// %y1y1 = mul i8 %y1, %y1\n/// %y2y2 = mul i8 %y2, %y2\n/// %ins1 = insertelement <4 x i8> poison, i8 %x0x0, i32 0\n/// %ins2 = insertelement <4 x i8> %ins1, i8 %x3x3, i32 1\n/// %ins3 = insertelement <4 x i8> %ins2, i8 %y1y1, i32 2\n/// %ins4 = insertelement <4 x i8> %ins3, i8 %y2y2, i32 3\n/// ret <4 x i8> %ins4\n/// can be transformed into:\n/// %1 = shufflevector <4 x i8> %x, <4 x i8> %y, <4 x i32> <i32 0, i32 3, i32 5,\n///                                                         i32 6>\n/// %2 = mul <4 x i8> %1, %1\n/// ret <4 x i8> %2\n/// We convert this initially to something like:\n/// %x0 = extractelement <4 x i8> %x, i32 0\n/// %x3 = extractelement <4 x i8> %x, i32 3\n/// %y1 = extractelement <4 x i8> %y, i32 1\n/// %y2 = extractelement <4 x i8> %y, i32 2\n/// %1 = insertelement <4 x i8> poison, i8 %x0, i32 0\n/// %2 = insertelement <4 x i8> %1, i8 %x3, i32 1\n/// %3 = insertelement <4 x i8> %2, i8 %y1, i32 2\n/// %4 = insertelement <4 x i8> %3, i8 %y2, i32 3\n/// %5 = mul <4 x i8> %4, %4\n/// %6 = extractelement <4 x i8> %5, i32 0\n/// %ins1 = insertelement <4 x i8> poison, i8 %6, i32 0\n/// %7 = extractelement <4 x i8> %5, i32 1\n/// %ins2 = insertelement <4 x i8> %ins1, i8 %7, i32 1\n/// %8 = extractelement <4 x i8> %5, i32 2\n/// %ins3 = insertelement <4 x i8> %ins2, i8 %8, i32 2\n/// %9 = extractelement <4 x i8> %5, i32 3\n/// %ins4 = insertelement <4 x i8> %ins3, i8 %9, i32 3\n/// ret <4 x i8> %ins4\n/// InstCombiner transforms this into a shuffle and vector mul\n/// TODO: Can we split off and reuse the shuffle mask detection from\n/// TargetTransformInfo::getInstructionThroughput?\nstatic Optional<TargetTransformInfo::ShuffleKind>\nisShuffle(ArrayRef<Value *> VL) {\n  auto *EI0 = cast<ExtractElementInst>(VL[0]);\n  unsigned Size =\n      cast<FixedVectorType>(EI0->getVectorOperandType())->getNumElements();\n  Value *Vec1 = nullptr;\n  Value *Vec2 = nullptr;\n  enum ShuffleMode { Unknown, Select, Permute };\n  ShuffleMode CommonShuffleMode = Unknown;\n  for (unsigned I = 0, E = VL.size(); I < E; ++I) {\n    auto *EI = cast<ExtractElementInst>(VL[I]);\n    auto *Vec = EI->getVectorOperand();\n    // All vector operands must have the same number of vector elements.\n    if (cast<FixedVectorType>(Vec->getType())->getNumElements() != Size)\n      return None;\n    auto *Idx = dyn_cast<ConstantInt>(EI->getIndexOperand());\n    if (!Idx)\n      return None;\n    // Undefined behavior if Idx is negative or >= Size.\n    if (Idx->getValue().uge(Size))\n      continue;\n    unsigned IntIdx = Idx->getValue().getZExtValue();\n    // We can extractelement from undef or poison vector.\n    if (isa<UndefValue>(Vec))\n      continue;\n    // For correct shuffling we have to have at most 2 different vector operands\n    // in all extractelement instructions.\n    if (!Vec1 || Vec1 == Vec)\n      Vec1 = Vec;\n    else if (!Vec2 || Vec2 == Vec)\n      Vec2 = Vec;\n    else\n      return None;\n    if (CommonShuffleMode == Permute)\n      continue;\n    // If the extract index is not the same as the operation number, it is a\n    // permutation.\n    if (IntIdx != I) {\n      CommonShuffleMode = Permute;\n      continue;\n    }\n    CommonShuffleMode = Select;\n  }\n  // If we're not crossing lanes in different vectors, consider it as blending.\n  if (CommonShuffleMode == Select && Vec2)\n    return TargetTransformInfo::SK_Select;\n  // If Vec2 was never used, we have a permutation of a single vector, otherwise\n  // we have permutation of 2 vectors.\n  return Vec2 ? TargetTransformInfo::SK_PermuteTwoSrc\n              : TargetTransformInfo::SK_PermuteSingleSrc;\n}\n\nnamespace {\n\n/// Main data required for vectorization of instructions.\nstruct InstructionsState {\n  /// The very first instruction in the list with the main opcode.\n  Value *OpValue = nullptr;\n\n  /// The main/alternate instruction.\n  Instruction *MainOp = nullptr;\n  Instruction *AltOp = nullptr;\n\n  /// The main/alternate opcodes for the list of instructions.\n  unsigned getOpcode() const {\n    return MainOp ? MainOp->getOpcode() : 0;\n  }\n\n  unsigned getAltOpcode() const {\n    return AltOp ? AltOp->getOpcode() : 0;\n  }\n\n  /// Some of the instructions in the list have alternate opcodes.\n  bool isAltShuffle() const { return getOpcode() != getAltOpcode(); }\n\n  bool isOpcodeOrAlt(Instruction *I) const {\n    unsigned CheckedOpcode = I->getOpcode();\n    return getOpcode() == CheckedOpcode || getAltOpcode() == CheckedOpcode;\n  }\n\n  InstructionsState() = delete;\n  InstructionsState(Value *OpValue, Instruction *MainOp, Instruction *AltOp)\n      : OpValue(OpValue), MainOp(MainOp), AltOp(AltOp) {}\n};\n\n} // end anonymous namespace\n\n/// Chooses the correct key for scheduling data. If \\p Op has the same (or\n/// alternate) opcode as \\p OpValue, the key is \\p Op. Otherwise the key is \\p\n/// OpValue.\nstatic Value *isOneOf(const InstructionsState &S, Value *Op) {\n  auto *I = dyn_cast<Instruction>(Op);\n  if (I && S.isOpcodeOrAlt(I))\n    return Op;\n  return S.OpValue;\n}\n\n/// \\returns true if \\p Opcode is allowed as part of of the main/alternate\n/// instruction for SLP vectorization.\n///\n/// Example of unsupported opcode is SDIV that can potentially cause UB if the\n/// \"shuffled out\" lane would result in division by zero.\nstatic bool isValidForAlternation(unsigned Opcode) {\n  if (Instruction::isIntDivRem(Opcode))\n    return false;\n\n  return true;\n}\n\n/// \\returns analysis of the Instructions in \\p VL described in\n/// InstructionsState, the Opcode that we suppose the whole list\n/// could be vectorized even if its structure is diverse.\nstatic InstructionsState getSameOpcode(ArrayRef<Value *> VL,\n                                       unsigned BaseIndex = 0) {\n  // Make sure these are all Instructions.\n  if (llvm::any_of(VL, [](Value *V) { return !isa<Instruction>(V); }))\n    return InstructionsState(VL[BaseIndex], nullptr, nullptr);\n\n  bool IsCastOp = isa<CastInst>(VL[BaseIndex]);\n  bool IsBinOp = isa<BinaryOperator>(VL[BaseIndex]);\n  unsigned Opcode = cast<Instruction>(VL[BaseIndex])->getOpcode();\n  unsigned AltOpcode = Opcode;\n  unsigned AltIndex = BaseIndex;\n\n  // Check for one alternate opcode from another BinaryOperator.\n  // TODO - generalize to support all operators (types, calls etc.).\n  for (int Cnt = 0, E = VL.size(); Cnt < E; Cnt++) {\n    unsigned InstOpcode = cast<Instruction>(VL[Cnt])->getOpcode();\n    if (IsBinOp && isa<BinaryOperator>(VL[Cnt])) {\n      if (InstOpcode == Opcode || InstOpcode == AltOpcode)\n        continue;\n      if (Opcode == AltOpcode && isValidForAlternation(InstOpcode) &&\n          isValidForAlternation(Opcode)) {\n        AltOpcode = InstOpcode;\n        AltIndex = Cnt;\n        continue;\n      }\n    } else if (IsCastOp && isa<CastInst>(VL[Cnt])) {\n      Type *Ty0 = cast<Instruction>(VL[BaseIndex])->getOperand(0)->getType();\n      Type *Ty1 = cast<Instruction>(VL[Cnt])->getOperand(0)->getType();\n      if (Ty0 == Ty1) {\n        if (InstOpcode == Opcode || InstOpcode == AltOpcode)\n          continue;\n        if (Opcode == AltOpcode) {\n          assert(isValidForAlternation(Opcode) &&\n                 isValidForAlternation(InstOpcode) &&\n                 \"Cast isn't safe for alternation, logic needs to be updated!\");\n          AltOpcode = InstOpcode;\n          AltIndex = Cnt;\n          continue;\n        }\n      }\n    } else if (InstOpcode == Opcode || InstOpcode == AltOpcode)\n      continue;\n    return InstructionsState(VL[BaseIndex], nullptr, nullptr);\n  }\n\n  return InstructionsState(VL[BaseIndex], cast<Instruction>(VL[BaseIndex]),\n                           cast<Instruction>(VL[AltIndex]));\n}\n\n/// \\returns true if all of the values in \\p VL have the same type or false\n/// otherwise.\nstatic bool allSameType(ArrayRef<Value *> VL) {\n  Type *Ty = VL[0]->getType();\n  for (int i = 1, e = VL.size(); i < e; i++)\n    if (VL[i]->getType() != Ty)\n      return false;\n\n  return true;\n}\n\n/// \\returns True if Extract{Value,Element} instruction extracts element Idx.\nstatic Optional<unsigned> getExtractIndex(Instruction *E) {\n  unsigned Opcode = E->getOpcode();\n  assert((Opcode == Instruction::ExtractElement ||\n          Opcode == Instruction::ExtractValue) &&\n         \"Expected extractelement or extractvalue instruction.\");\n  if (Opcode == Instruction::ExtractElement) {\n    auto *CI = dyn_cast<ConstantInt>(E->getOperand(1));\n    if (!CI)\n      return None;\n    return CI->getZExtValue();\n  }\n  ExtractValueInst *EI = cast<ExtractValueInst>(E);\n  if (EI->getNumIndices() != 1)\n    return None;\n  return *EI->idx_begin();\n}\n\n/// \\returns True if in-tree use also needs extract. This refers to\n/// possible scalar operand in vectorized instruction.\nstatic bool InTreeUserNeedToExtract(Value *Scalar, Instruction *UserInst,\n                                    TargetLibraryInfo *TLI) {\n  unsigned Opcode = UserInst->getOpcode();\n  switch (Opcode) {\n  case Instruction::Load: {\n    LoadInst *LI = cast<LoadInst>(UserInst);\n    return (LI->getPointerOperand() == Scalar);\n  }\n  case Instruction::Store: {\n    StoreInst *SI = cast<StoreInst>(UserInst);\n    return (SI->getPointerOperand() == Scalar);\n  }\n  case Instruction::Call: {\n    CallInst *CI = cast<CallInst>(UserInst);\n    Intrinsic::ID ID = getVectorIntrinsicIDForCall(CI, TLI);\n    for (unsigned i = 0, e = CI->getNumArgOperands(); i != e; ++i) {\n      if (hasVectorInstrinsicScalarOpd(ID, i))\n        return (CI->getArgOperand(i) == Scalar);\n    }\n    LLVM_FALLTHROUGH;\n  }\n  default:\n    return false;\n  }\n}\n\n/// \\returns the AA location that is being access by the instruction.\nstatic MemoryLocation getLocation(Instruction *I, AAResults *AA) {\n  if (StoreInst *SI = dyn_cast<StoreInst>(I))\n    return MemoryLocation::get(SI);\n  if (LoadInst *LI = dyn_cast<LoadInst>(I))\n    return MemoryLocation::get(LI);\n  return MemoryLocation();\n}\n\n/// \\returns True if the instruction is not a volatile or atomic load/store.\nstatic bool isSimple(Instruction *I) {\n  if (LoadInst *LI = dyn_cast<LoadInst>(I))\n    return LI->isSimple();\n  if (StoreInst *SI = dyn_cast<StoreInst>(I))\n    return SI->isSimple();\n  if (MemIntrinsic *MI = dyn_cast<MemIntrinsic>(I))\n    return !MI->isVolatile();\n  return true;\n}\n\nnamespace llvm {\n\nstatic void inversePermutation(ArrayRef<unsigned> Indices,\n                               SmallVectorImpl<int> &Mask) {\n  Mask.clear();\n  const unsigned E = Indices.size();\n  Mask.resize(E, E + 1);\n  for (unsigned I = 0; I < E; ++I)\n    Mask[Indices[I]] = I;\n}\n\nnamespace slpvectorizer {\n\n/// Bottom Up SLP Vectorizer.\nclass BoUpSLP {\n  struct TreeEntry;\n  struct ScheduleData;\n\npublic:\n  using ValueList = SmallVector<Value *, 8>;\n  using InstrList = SmallVector<Instruction *, 16>;\n  using ValueSet = SmallPtrSet<Value *, 16>;\n  using StoreList = SmallVector<StoreInst *, 8>;\n  using ExtraValueToDebugLocsMap =\n      MapVector<Value *, SmallVector<Instruction *, 2>>;\n  using OrdersType = SmallVector<unsigned, 4>;\n\n  BoUpSLP(Function *Func, ScalarEvolution *Se, TargetTransformInfo *Tti,\n          TargetLibraryInfo *TLi, AAResults *Aa, LoopInfo *Li,\n          DominatorTree *Dt, AssumptionCache *AC, DemandedBits *DB,\n          const DataLayout *DL, OptimizationRemarkEmitter *ORE)\n      : F(Func), SE(Se), TTI(Tti), TLI(TLi), AA(Aa), LI(Li), DT(Dt), AC(AC),\n        DB(DB), DL(DL), ORE(ORE), Builder(Se->getContext()) {\n    CodeMetrics::collectEphemeralValues(F, AC, EphValues);\n    // Use the vector register size specified by the target unless overridden\n    // by a command-line option.\n    // TODO: It would be better to limit the vectorization factor based on\n    //       data type rather than just register size. For example, x86 AVX has\n    //       256-bit registers, but it does not support integer operations\n    //       at that width (that requires AVX2).\n    if (MaxVectorRegSizeOption.getNumOccurrences())\n      MaxVecRegSize = MaxVectorRegSizeOption;\n    else\n      MaxVecRegSize = TTI->getRegisterBitWidth(true);\n\n    if (MinVectorRegSizeOption.getNumOccurrences())\n      MinVecRegSize = MinVectorRegSizeOption;\n    else\n      MinVecRegSize = TTI->getMinVectorRegisterBitWidth();\n  }\n\n  /// Vectorize the tree that starts with the elements in \\p VL.\n  /// Returns the vectorized root.\n  Value *vectorizeTree();\n\n  /// Vectorize the tree but with the list of externally used values \\p\n  /// ExternallyUsedValues. Values in this MapVector can be replaced but the\n  /// generated extractvalue instructions.\n  Value *vectorizeTree(ExtraValueToDebugLocsMap &ExternallyUsedValues);\n\n  /// \\returns the cost incurred by unwanted spills and fills, caused by\n  /// holding live values over call sites.\n  InstructionCost getSpillCost() const;\n\n  /// \\returns the vectorization cost of the subtree that starts at \\p VL.\n  /// A negative number means that this is profitable.\n  InstructionCost getTreeCost();\n\n  /// Construct a vectorizable tree that starts at \\p Roots, ignoring users for\n  /// the purpose of scheduling and extraction in the \\p UserIgnoreLst.\n  void buildTree(ArrayRef<Value *> Roots,\n                 ArrayRef<Value *> UserIgnoreLst = None);\n\n  /// Construct a vectorizable tree that starts at \\p Roots, ignoring users for\n  /// the purpose of scheduling and extraction in the \\p UserIgnoreLst taking\n  /// into account (and updating it, if required) list of externally used\n  /// values stored in \\p ExternallyUsedValues.\n  void buildTree(ArrayRef<Value *> Roots,\n                 ExtraValueToDebugLocsMap &ExternallyUsedValues,\n                 ArrayRef<Value *> UserIgnoreLst = None);\n\n  /// Clear the internal data structures that are created by 'buildTree'.\n  void deleteTree() {\n    VectorizableTree.clear();\n    ScalarToTreeEntry.clear();\n    MustGather.clear();\n    ExternalUses.clear();\n    NumOpsWantToKeepOrder.clear();\n    NumOpsWantToKeepOriginalOrder = 0;\n    for (auto &Iter : BlocksSchedules) {\n      BlockScheduling *BS = Iter.second.get();\n      BS->clear();\n    }\n    MinBWs.clear();\n  }\n\n  unsigned getTreeSize() const { return VectorizableTree.size(); }\n\n  /// Perform LICM and CSE on the newly generated gather sequences.\n  void optimizeGatherSequence();\n\n  /// \\returns The best order of instructions for vectorization.\n  Optional<ArrayRef<unsigned>> bestOrder() const {\n    assert(llvm::all_of(\n               NumOpsWantToKeepOrder,\n               [this](const decltype(NumOpsWantToKeepOrder)::value_type &D) {\n                 return D.getFirst().size() ==\n                        VectorizableTree[0]->Scalars.size();\n               }) &&\n           \"All orders must have the same size as number of instructions in \"\n           \"tree node.\");\n    auto I = std::max_element(\n        NumOpsWantToKeepOrder.begin(), NumOpsWantToKeepOrder.end(),\n        [](const decltype(NumOpsWantToKeepOrder)::value_type &D1,\n           const decltype(NumOpsWantToKeepOrder)::value_type &D2) {\n          return D1.second < D2.second;\n        });\n    if (I == NumOpsWantToKeepOrder.end() ||\n        I->getSecond() <= NumOpsWantToKeepOriginalOrder)\n      return None;\n\n    return makeArrayRef(I->getFirst());\n  }\n\n  /// Builds the correct order for root instructions.\n  /// If some leaves have the same instructions to be vectorized, we may\n  /// incorrectly evaluate the best order for the root node (it is built for the\n  /// vector of instructions without repeated instructions and, thus, has less\n  /// elements than the root node). This function builds the correct order for\n  /// the root node.\n  /// For example, if the root node is \\<a+b, a+c, a+d, f+e\\>, then the leaves\n  /// are \\<a, a, a, f\\> and \\<b, c, d, e\\>. When we try to vectorize the first\n  /// leaf, it will be shrink to \\<a, b\\>. If instructions in this leaf should\n  /// be reordered, the best order will be \\<1, 0\\>. We need to extend this\n  /// order for the root node. For the root node this order should look like\n  /// \\<3, 0, 1, 2\\>. This function extends the order for the reused\n  /// instructions.\n  void findRootOrder(OrdersType &Order) {\n    // If the leaf has the same number of instructions to vectorize as the root\n    // - order must be set already.\n    unsigned RootSize = VectorizableTree[0]->Scalars.size();\n    if (Order.size() == RootSize)\n      return;\n    SmallVector<unsigned, 4> RealOrder(Order.size());\n    std::swap(Order, RealOrder);\n    SmallVector<int, 4> Mask;\n    inversePermutation(RealOrder, Mask);\n    Order.assign(Mask.begin(), Mask.end());\n    // The leaf has less number of instructions - need to find the true order of\n    // the root.\n    // Scan the nodes starting from the leaf back to the root.\n    const TreeEntry *PNode = VectorizableTree.back().get();\n    SmallVector<const TreeEntry *, 4> Nodes(1, PNode);\n    SmallPtrSet<const TreeEntry *, 4> Visited;\n    while (!Nodes.empty() && Order.size() != RootSize) {\n      const TreeEntry *PNode = Nodes.pop_back_val();\n      if (!Visited.insert(PNode).second)\n        continue;\n      const TreeEntry &Node = *PNode;\n      for (const EdgeInfo &EI : Node.UserTreeIndices)\n        if (EI.UserTE)\n          Nodes.push_back(EI.UserTE);\n      if (Node.ReuseShuffleIndices.empty())\n        continue;\n      // Build the order for the parent node.\n      OrdersType NewOrder(Node.ReuseShuffleIndices.size(), RootSize);\n      SmallVector<unsigned, 4> OrderCounter(Order.size(), 0);\n      // The algorithm of the order extension is:\n      // 1. Calculate the number of the same instructions for the order.\n      // 2. Calculate the index of the new order: total number of instructions\n      // with order less than the order of the current instruction + reuse\n      // number of the current instruction.\n      // 3. The new order is just the index of the instruction in the original\n      // vector of the instructions.\n      for (unsigned I : Node.ReuseShuffleIndices)\n        ++OrderCounter[Order[I]];\n      SmallVector<unsigned, 4> CurrentCounter(Order.size(), 0);\n      for (unsigned I = 0, E = Node.ReuseShuffleIndices.size(); I < E; ++I) {\n        unsigned ReusedIdx = Node.ReuseShuffleIndices[I];\n        unsigned OrderIdx = Order[ReusedIdx];\n        unsigned NewIdx = 0;\n        for (unsigned J = 0; J < OrderIdx; ++J)\n          NewIdx += OrderCounter[J];\n        NewIdx += CurrentCounter[OrderIdx];\n        ++CurrentCounter[OrderIdx];\n        assert(NewOrder[NewIdx] == RootSize &&\n               \"The order index should not be written already.\");\n        NewOrder[NewIdx] = I;\n      }\n      std::swap(Order, NewOrder);\n    }\n    assert(Order.size() == RootSize &&\n           \"Root node is expected or the size of the order must be the same as \"\n           \"the number of elements in the root node.\");\n    assert(llvm::all_of(Order,\n                        [RootSize](unsigned Val) { return Val != RootSize; }) &&\n           \"All indices must be initialized\");\n  }\n\n  /// \\return The vector element size in bits to use when vectorizing the\n  /// expression tree ending at \\p V. If V is a store, the size is the width of\n  /// the stored value. Otherwise, the size is the width of the largest loaded\n  /// value reaching V. This method is used by the vectorizer to calculate\n  /// vectorization factors.\n  unsigned getVectorElementSize(Value *V);\n\n  /// Compute the minimum type sizes required to represent the entries in a\n  /// vectorizable tree.\n  void computeMinimumValueSizes();\n\n  // \\returns maximum vector register size as set by TTI or overridden by cl::opt.\n  unsigned getMaxVecRegSize() const {\n    return MaxVecRegSize;\n  }\n\n  // \\returns minimum vector register size as set by cl::opt.\n  unsigned getMinVecRegSize() const {\n    return MinVecRegSize;\n  }\n\n  unsigned getMaximumVF(unsigned ElemWidth, unsigned Opcode) const {\n    unsigned MaxVF = MaxVFOption.getNumOccurrences() ?\n      MaxVFOption : TTI->getMaximumVF(ElemWidth, Opcode);\n    return MaxVF ? MaxVF : UINT_MAX;\n  }\n\n  /// Check if homogeneous aggregate is isomorphic to some VectorType.\n  /// Accepts homogeneous multidimensional aggregate of scalars/vectors like\n  /// {[4 x i16], [4 x i16]}, { <2 x float>, <2 x float> },\n  /// {{{i16, i16}, {i16, i16}}, {{i16, i16}, {i16, i16}}} and so on.\n  ///\n  /// \\returns number of elements in vector if isomorphism exists, 0 otherwise.\n  unsigned canMapToVector(Type *T, const DataLayout &DL) const;\n\n  /// \\returns True if the VectorizableTree is both tiny and not fully\n  /// vectorizable. We do not vectorize such trees.\n  bool isTreeTinyAndNotFullyVectorizable() const;\n\n  /// Assume that a legal-sized 'or'-reduction of shifted/zexted loaded values\n  /// can be load combined in the backend. Load combining may not be allowed in\n  /// the IR optimizer, so we do not want to alter the pattern. For example,\n  /// partially transforming a scalar bswap() pattern into vector code is\n  /// effectively impossible for the backend to undo.\n  /// TODO: If load combining is allowed in the IR optimizer, this analysis\n  ///       may not be necessary.\n  bool isLoadCombineReductionCandidate(RecurKind RdxKind) const;\n\n  /// Assume that a vector of stores of bitwise-or/shifted/zexted loaded values\n  /// can be load combined in the backend. Load combining may not be allowed in\n  /// the IR optimizer, so we do not want to alter the pattern. For example,\n  /// partially transforming a scalar bswap() pattern into vector code is\n  /// effectively impossible for the backend to undo.\n  /// TODO: If load combining is allowed in the IR optimizer, this analysis\n  ///       may not be necessary.\n  bool isLoadCombineCandidate() const;\n\n  OptimizationRemarkEmitter *getORE() { return ORE; }\n\n  /// This structure holds any data we need about the edges being traversed\n  /// during buildTree_rec(). We keep track of:\n  /// (i) the user TreeEntry index, and\n  /// (ii) the index of the edge.\n  struct EdgeInfo {\n    EdgeInfo() = default;\n    EdgeInfo(TreeEntry *UserTE, unsigned EdgeIdx)\n        : UserTE(UserTE), EdgeIdx(EdgeIdx) {}\n    /// The user TreeEntry.\n    TreeEntry *UserTE = nullptr;\n    /// The operand index of the use.\n    unsigned EdgeIdx = UINT_MAX;\n#ifndef NDEBUG\n    friend inline raw_ostream &operator<<(raw_ostream &OS,\n                                          const BoUpSLP::EdgeInfo &EI) {\n      EI.dump(OS);\n      return OS;\n    }\n    /// Debug print.\n    void dump(raw_ostream &OS) const {\n      OS << \"{User:\" << (UserTE ? std::to_string(UserTE->Idx) : \"null\")\n         << \" EdgeIdx:\" << EdgeIdx << \"}\";\n    }\n    LLVM_DUMP_METHOD void dump() const { dump(dbgs()); }\n#endif\n  };\n\n  /// A helper data structure to hold the operands of a vector of instructions.\n  /// This supports a fixed vector length for all operand vectors.\n  class VLOperands {\n    /// For each operand we need (i) the value, and (ii) the opcode that it\n    /// would be attached to if the expression was in a left-linearized form.\n    /// This is required to avoid illegal operand reordering.\n    /// For example:\n    /// \\verbatim\n    ///                         0 Op1\n    ///                         |/\n    /// Op1 Op2   Linearized    + Op2\n    ///   \\ /     ---------->   |/\n    ///    -                    -\n    ///\n    /// Op1 - Op2            (0 + Op1) - Op2\n    /// \\endverbatim\n    ///\n    /// Value Op1 is attached to a '+' operation, and Op2 to a '-'.\n    ///\n    /// Another way to think of this is to track all the operations across the\n    /// path from the operand all the way to the root of the tree and to\n    /// calculate the operation that corresponds to this path. For example, the\n    /// path from Op2 to the root crosses the RHS of the '-', therefore the\n    /// corresponding operation is a '-' (which matches the one in the\n    /// linearized tree, as shown above).\n    ///\n    /// For lack of a better term, we refer to this operation as Accumulated\n    /// Path Operation (APO).\n    struct OperandData {\n      OperandData() = default;\n      OperandData(Value *V, bool APO, bool IsUsed)\n          : V(V), APO(APO), IsUsed(IsUsed) {}\n      /// The operand value.\n      Value *V = nullptr;\n      /// TreeEntries only allow a single opcode, or an alternate sequence of\n      /// them (e.g, +, -). Therefore, we can safely use a boolean value for the\n      /// APO. It is set to 'true' if 'V' is attached to an inverse operation\n      /// in the left-linearized form (e.g., Sub/Div), and 'false' otherwise\n      /// (e.g., Add/Mul)\n      bool APO = false;\n      /// Helper data for the reordering function.\n      bool IsUsed = false;\n    };\n\n    /// During operand reordering, we are trying to select the operand at lane\n    /// that matches best with the operand at the neighboring lane. Our\n    /// selection is based on the type of value we are looking for. For example,\n    /// if the neighboring lane has a load, we need to look for a load that is\n    /// accessing a consecutive address. These strategies are summarized in the\n    /// 'ReorderingMode' enumerator.\n    enum class ReorderingMode {\n      Load,     ///< Matching loads to consecutive memory addresses\n      Opcode,   ///< Matching instructions based on opcode (same or alternate)\n      Constant, ///< Matching constants\n      Splat,    ///< Matching the same instruction multiple times (broadcast)\n      Failed,   ///< We failed to create a vectorizable group\n    };\n\n    using OperandDataVec = SmallVector<OperandData, 2>;\n\n    /// A vector of operand vectors.\n    SmallVector<OperandDataVec, 4> OpsVec;\n\n    const DataLayout &DL;\n    ScalarEvolution &SE;\n    const BoUpSLP &R;\n\n    /// \\returns the operand data at \\p OpIdx and \\p Lane.\n    OperandData &getData(unsigned OpIdx, unsigned Lane) {\n      return OpsVec[OpIdx][Lane];\n    }\n\n    /// \\returns the operand data at \\p OpIdx and \\p Lane. Const version.\n    const OperandData &getData(unsigned OpIdx, unsigned Lane) const {\n      return OpsVec[OpIdx][Lane];\n    }\n\n    /// Clears the used flag for all entries.\n    void clearUsed() {\n      for (unsigned OpIdx = 0, NumOperands = getNumOperands();\n           OpIdx != NumOperands; ++OpIdx)\n        for (unsigned Lane = 0, NumLanes = getNumLanes(); Lane != NumLanes;\n             ++Lane)\n          OpsVec[OpIdx][Lane].IsUsed = false;\n    }\n\n    /// Swap the operand at \\p OpIdx1 with that one at \\p OpIdx2.\n    void swap(unsigned OpIdx1, unsigned OpIdx2, unsigned Lane) {\n      std::swap(OpsVec[OpIdx1][Lane], OpsVec[OpIdx2][Lane]);\n    }\n\n    // The hard-coded scores listed here are not very important. When computing\n    // the scores of matching one sub-tree with another, we are basically\n    // counting the number of values that are matching. So even if all scores\n    // are set to 1, we would still get a decent matching result.\n    // However, sometimes we have to break ties. For example we may have to\n    // choose between matching loads vs matching opcodes. This is what these\n    // scores are helping us with: they provide the order of preference.\n\n    /// Loads from consecutive memory addresses, e.g. load(A[i]), load(A[i+1]).\n    static const int ScoreConsecutiveLoads = 3;\n    /// ExtractElementInst from same vector and consecutive indexes.\n    static const int ScoreConsecutiveExtracts = 3;\n    /// Constants.\n    static const int ScoreConstants = 2;\n    /// Instructions with the same opcode.\n    static const int ScoreSameOpcode = 2;\n    /// Instructions with alt opcodes (e.g, add + sub).\n    static const int ScoreAltOpcodes = 1;\n    /// Identical instructions (a.k.a. splat or broadcast).\n    static const int ScoreSplat = 1;\n    /// Matching with an undef is preferable to failing.\n    static const int ScoreUndef = 1;\n    /// Score for failing to find a decent match.\n    static const int ScoreFail = 0;\n    /// User exteranl to the vectorized code.\n    static const int ExternalUseCost = 1;\n    /// The user is internal but in a different lane.\n    static const int UserInDiffLaneCost = ExternalUseCost;\n\n    /// \\returns the score of placing \\p V1 and \\p V2 in consecutive lanes.\n    static int getShallowScore(Value *V1, Value *V2, const DataLayout &DL,\n                               ScalarEvolution &SE) {\n      auto *LI1 = dyn_cast<LoadInst>(V1);\n      auto *LI2 = dyn_cast<LoadInst>(V2);\n      if (LI1 && LI2)\n        return isConsecutiveAccess(LI1, LI2, DL, SE)\n                   ? VLOperands::ScoreConsecutiveLoads\n                   : VLOperands::ScoreFail;\n\n      auto *C1 = dyn_cast<Constant>(V1);\n      auto *C2 = dyn_cast<Constant>(V2);\n      if (C1 && C2)\n        return VLOperands::ScoreConstants;\n\n      // Extracts from consecutive indexes of the same vector better score as\n      // the extracts could be optimized away.\n      Value *EV;\n      ConstantInt *Ex1Idx, *Ex2Idx;\n      if (match(V1, m_ExtractElt(m_Value(EV), m_ConstantInt(Ex1Idx))) &&\n          match(V2, m_ExtractElt(m_Deferred(EV), m_ConstantInt(Ex2Idx))) &&\n          Ex1Idx->getZExtValue() + 1 == Ex2Idx->getZExtValue())\n        return VLOperands::ScoreConsecutiveExtracts;\n\n      auto *I1 = dyn_cast<Instruction>(V1);\n      auto *I2 = dyn_cast<Instruction>(V2);\n      if (I1 && I2) {\n        if (I1 == I2)\n          return VLOperands::ScoreSplat;\n        InstructionsState S = getSameOpcode({I1, I2});\n        // Note: Only consider instructions with <= 2 operands to avoid\n        // complexity explosion.\n        if (S.getOpcode() && S.MainOp->getNumOperands() <= 2)\n          return S.isAltShuffle() ? VLOperands::ScoreAltOpcodes\n                                  : VLOperands::ScoreSameOpcode;\n      }\n\n      if (isa<UndefValue>(V2))\n        return VLOperands::ScoreUndef;\n\n      return VLOperands::ScoreFail;\n    }\n\n    /// Holds the values and their lane that are taking part in the look-ahead\n    /// score calculation. This is used in the external uses cost calculation.\n    SmallDenseMap<Value *, int> InLookAheadValues;\n\n    /// \\Returns the additinal cost due to uses of \\p LHS and \\p RHS that are\n    /// either external to the vectorized code, or require shuffling.\n    int getExternalUsesCost(const std::pair<Value *, int> &LHS,\n                            const std::pair<Value *, int> &RHS) {\n      int Cost = 0;\n      std::array<std::pair<Value *, int>, 2> Values = {{LHS, RHS}};\n      for (int Idx = 0, IdxE = Values.size(); Idx != IdxE; ++Idx) {\n        Value *V = Values[Idx].first;\n        if (isa<Constant>(V)) {\n          // Since this is a function pass, it doesn't make semantic sense to\n          // walk the users of a subclass of Constant. The users could be in\n          // another function, or even another module that happens to be in\n          // the same LLVMContext.\n          continue;\n        }\n\n        // Calculate the absolute lane, using the minimum relative lane of LHS\n        // and RHS as base and Idx as the offset.\n        int Ln = std::min(LHS.second, RHS.second) + Idx;\n        assert(Ln >= 0 && \"Bad lane calculation\");\n        unsigned UsersBudget = LookAheadUsersBudget;\n        for (User *U : V->users()) {\n          if (const TreeEntry *UserTE = R.getTreeEntry(U)) {\n            // The user is in the VectorizableTree. Check if we need to insert.\n            auto It = llvm::find(UserTE->Scalars, U);\n            assert(It != UserTE->Scalars.end() && \"U is in UserTE\");\n            int UserLn = std::distance(UserTE->Scalars.begin(), It);\n            assert(UserLn >= 0 && \"Bad lane\");\n            if (UserLn != Ln)\n              Cost += UserInDiffLaneCost;\n          } else {\n            // Check if the user is in the look-ahead code.\n            auto It2 = InLookAheadValues.find(U);\n            if (It2 != InLookAheadValues.end()) {\n              // The user is in the look-ahead code. Check the lane.\n              if (It2->second != Ln)\n                Cost += UserInDiffLaneCost;\n            } else {\n              // The user is neither in SLP tree nor in the look-ahead code.\n              Cost += ExternalUseCost;\n            }\n          }\n          // Limit the number of visited uses to cap compilation time.\n          if (--UsersBudget == 0)\n            break;\n        }\n      }\n      return Cost;\n    }\n\n    /// Go through the operands of \\p LHS and \\p RHS recursively until \\p\n    /// MaxLevel, and return the cummulative score. For example:\n    /// \\verbatim\n    ///  A[0]  B[0]  A[1]  B[1]  C[0] D[0]  B[1] A[1]\n    ///     \\ /         \\ /         \\ /        \\ /\n    ///      +           +           +          +\n    ///     G1          G2          G3         G4\n    /// \\endverbatim\n    /// The getScoreAtLevelRec(G1, G2) function will try to match the nodes at\n    /// each level recursively, accumulating the score. It starts from matching\n    /// the additions at level 0, then moves on to the loads (level 1). The\n    /// score of G1 and G2 is higher than G1 and G3, because {A[0],A[1]} and\n    /// {B[0],B[1]} match with VLOperands::ScoreConsecutiveLoads, while\n    /// {A[0],C[0]} has a score of VLOperands::ScoreFail.\n    /// Please note that the order of the operands does not matter, as we\n    /// evaluate the score of all profitable combinations of operands. In\n    /// other words the score of G1 and G4 is the same as G1 and G2. This\n    /// heuristic is based on ideas described in:\n    ///   Look-ahead SLP: Auto-vectorization in the presence of commutative\n    ///   operations, CGO 2018 by Vasileios Porpodas, Rodrigo C. O. Rocha,\n    ///   Lu\u00eds F. W. G\u00f3es\n    int getScoreAtLevelRec(const std::pair<Value *, int> &LHS,\n                           const std::pair<Value *, int> &RHS, int CurrLevel,\n                           int MaxLevel) {\n\n      Value *V1 = LHS.first;\n      Value *V2 = RHS.first;\n      // Get the shallow score of V1 and V2.\n      int ShallowScoreAtThisLevel =\n          std::max((int)ScoreFail, getShallowScore(V1, V2, DL, SE) -\n                                       getExternalUsesCost(LHS, RHS));\n      int Lane1 = LHS.second;\n      int Lane2 = RHS.second;\n\n      // If reached MaxLevel,\n      //  or if V1 and V2 are not instructions,\n      //  or if they are SPLAT,\n      //  or if they are not consecutive, early return the current cost.\n      auto *I1 = dyn_cast<Instruction>(V1);\n      auto *I2 = dyn_cast<Instruction>(V2);\n      if (CurrLevel == MaxLevel || !(I1 && I2) || I1 == I2 ||\n          ShallowScoreAtThisLevel == VLOperands::ScoreFail ||\n          (isa<LoadInst>(I1) && isa<LoadInst>(I2) && ShallowScoreAtThisLevel))\n        return ShallowScoreAtThisLevel;\n      assert(I1 && I2 && \"Should have early exited.\");\n\n      // Keep track of in-tree values for determining the external-use cost.\n      InLookAheadValues[V1] = Lane1;\n      InLookAheadValues[V2] = Lane2;\n\n      // Contains the I2 operand indexes that got matched with I1 operands.\n      SmallSet<unsigned, 4> Op2Used;\n\n      // Recursion towards the operands of I1 and I2. We are trying all possbile\n      // operand pairs, and keeping track of the best score.\n      for (unsigned OpIdx1 = 0, NumOperands1 = I1->getNumOperands();\n           OpIdx1 != NumOperands1; ++OpIdx1) {\n        // Try to pair op1I with the best operand of I2.\n        int MaxTmpScore = 0;\n        unsigned MaxOpIdx2 = 0;\n        bool FoundBest = false;\n        // If I2 is commutative try all combinations.\n        unsigned FromIdx = isCommutative(I2) ? 0 : OpIdx1;\n        unsigned ToIdx = isCommutative(I2)\n                             ? I2->getNumOperands()\n                             : std::min(I2->getNumOperands(), OpIdx1 + 1);\n        assert(FromIdx <= ToIdx && \"Bad index\");\n        for (unsigned OpIdx2 = FromIdx; OpIdx2 != ToIdx; ++OpIdx2) {\n          // Skip operands already paired with OpIdx1.\n          if (Op2Used.count(OpIdx2))\n            continue;\n          // Recursively calculate the cost at each level\n          int TmpScore = getScoreAtLevelRec({I1->getOperand(OpIdx1), Lane1},\n                                            {I2->getOperand(OpIdx2), Lane2},\n                                            CurrLevel + 1, MaxLevel);\n          // Look for the best score.\n          if (TmpScore > VLOperands::ScoreFail && TmpScore > MaxTmpScore) {\n            MaxTmpScore = TmpScore;\n            MaxOpIdx2 = OpIdx2;\n            FoundBest = true;\n          }\n        }\n        if (FoundBest) {\n          // Pair {OpIdx1, MaxOpIdx2} was found to be best. Never revisit it.\n          Op2Used.insert(MaxOpIdx2);\n          ShallowScoreAtThisLevel += MaxTmpScore;\n        }\n      }\n      return ShallowScoreAtThisLevel;\n    }\n\n    /// \\Returns the look-ahead score, which tells us how much the sub-trees\n    /// rooted at \\p LHS and \\p RHS match, the more they match the higher the\n    /// score. This helps break ties in an informed way when we cannot decide on\n    /// the order of the operands by just considering the immediate\n    /// predecessors.\n    int getLookAheadScore(const std::pair<Value *, int> &LHS,\n                          const std::pair<Value *, int> &RHS) {\n      InLookAheadValues.clear();\n      return getScoreAtLevelRec(LHS, RHS, 1, LookAheadMaxDepth);\n    }\n\n    // Search all operands in Ops[*][Lane] for the one that matches best\n    // Ops[OpIdx][LastLane] and return its opreand index.\n    // If no good match can be found, return None.\n    Optional<unsigned>\n    getBestOperand(unsigned OpIdx, int Lane, int LastLane,\n                   ArrayRef<ReorderingMode> ReorderingModes) {\n      unsigned NumOperands = getNumOperands();\n\n      // The operand of the previous lane at OpIdx.\n      Value *OpLastLane = getData(OpIdx, LastLane).V;\n\n      // Our strategy mode for OpIdx.\n      ReorderingMode RMode = ReorderingModes[OpIdx];\n\n      // The linearized opcode of the operand at OpIdx, Lane.\n      bool OpIdxAPO = getData(OpIdx, Lane).APO;\n\n      // The best operand index and its score.\n      // Sometimes we have more than one option (e.g., Opcode and Undefs), so we\n      // are using the score to differentiate between the two.\n      struct BestOpData {\n        Optional<unsigned> Idx = None;\n        unsigned Score = 0;\n      } BestOp;\n\n      // Iterate through all unused operands and look for the best.\n      for (unsigned Idx = 0; Idx != NumOperands; ++Idx) {\n        // Get the operand at Idx and Lane.\n        OperandData &OpData = getData(Idx, Lane);\n        Value *Op = OpData.V;\n        bool OpAPO = OpData.APO;\n\n        // Skip already selected operands.\n        if (OpData.IsUsed)\n          continue;\n\n        // Skip if we are trying to move the operand to a position with a\n        // different opcode in the linearized tree form. This would break the\n        // semantics.\n        if (OpAPO != OpIdxAPO)\n          continue;\n\n        // Look for an operand that matches the current mode.\n        switch (RMode) {\n        case ReorderingMode::Load:\n        case ReorderingMode::Constant:\n        case ReorderingMode::Opcode: {\n          bool LeftToRight = Lane > LastLane;\n          Value *OpLeft = (LeftToRight) ? OpLastLane : Op;\n          Value *OpRight = (LeftToRight) ? Op : OpLastLane;\n          unsigned Score =\n              getLookAheadScore({OpLeft, LastLane}, {OpRight, Lane});\n          if (Score > BestOp.Score) {\n            BestOp.Idx = Idx;\n            BestOp.Score = Score;\n          }\n          break;\n        }\n        case ReorderingMode::Splat:\n          if (Op == OpLastLane)\n            BestOp.Idx = Idx;\n          break;\n        case ReorderingMode::Failed:\n          return None;\n        }\n      }\n\n      if (BestOp.Idx) {\n        getData(BestOp.Idx.getValue(), Lane).IsUsed = true;\n        return BestOp.Idx;\n      }\n      // If we could not find a good match return None.\n      return None;\n    }\n\n    /// Helper for reorderOperandVecs. \\Returns the lane that we should start\n    /// reordering from. This is the one which has the least number of operands\n    /// that can freely move about.\n    unsigned getBestLaneToStartReordering() const {\n      unsigned BestLane = 0;\n      unsigned Min = UINT_MAX;\n      for (unsigned Lane = 0, NumLanes = getNumLanes(); Lane != NumLanes;\n           ++Lane) {\n        unsigned NumFreeOps = getMaxNumOperandsThatCanBeReordered(Lane);\n        if (NumFreeOps < Min) {\n          Min = NumFreeOps;\n          BestLane = Lane;\n        }\n      }\n      return BestLane;\n    }\n\n    /// \\Returns the maximum number of operands that are allowed to be reordered\n    /// for \\p Lane. This is used as a heuristic for selecting the first lane to\n    /// start operand reordering.\n    unsigned getMaxNumOperandsThatCanBeReordered(unsigned Lane) const {\n      unsigned CntTrue = 0;\n      unsigned NumOperands = getNumOperands();\n      // Operands with the same APO can be reordered. We therefore need to count\n      // how many of them we have for each APO, like this: Cnt[APO] = x.\n      // Since we only have two APOs, namely true and false, we can avoid using\n      // a map. Instead we can simply count the number of operands that\n      // correspond to one of them (in this case the 'true' APO), and calculate\n      // the other by subtracting it from the total number of operands.\n      for (unsigned OpIdx = 0; OpIdx != NumOperands; ++OpIdx)\n        if (getData(OpIdx, Lane).APO)\n          ++CntTrue;\n      unsigned CntFalse = NumOperands - CntTrue;\n      return std::max(CntTrue, CntFalse);\n    }\n\n    /// Go through the instructions in VL and append their operands.\n    void appendOperandsOfVL(ArrayRef<Value *> VL) {\n      assert(!VL.empty() && \"Bad VL\");\n      assert((empty() || VL.size() == getNumLanes()) &&\n             \"Expected same number of lanes\");\n      assert(isa<Instruction>(VL[0]) && \"Expected instruction\");\n      unsigned NumOperands = cast<Instruction>(VL[0])->getNumOperands();\n      OpsVec.resize(NumOperands);\n      unsigned NumLanes = VL.size();\n      for (unsigned OpIdx = 0; OpIdx != NumOperands; ++OpIdx) {\n        OpsVec[OpIdx].resize(NumLanes);\n        for (unsigned Lane = 0; Lane != NumLanes; ++Lane) {\n          assert(isa<Instruction>(VL[Lane]) && \"Expected instruction\");\n          // Our tree has just 3 nodes: the root and two operands.\n          // It is therefore trivial to get the APO. We only need to check the\n          // opcode of VL[Lane] and whether the operand at OpIdx is the LHS or\n          // RHS operand. The LHS operand of both add and sub is never attached\n          // to an inversese operation in the linearized form, therefore its APO\n          // is false. The RHS is true only if VL[Lane] is an inverse operation.\n\n          // Since operand reordering is performed on groups of commutative\n          // operations or alternating sequences (e.g., +, -), we can safely\n          // tell the inverse operations by checking commutativity.\n          bool IsInverseOperation = !isCommutative(cast<Instruction>(VL[Lane]));\n          bool APO = (OpIdx == 0) ? false : IsInverseOperation;\n          OpsVec[OpIdx][Lane] = {cast<Instruction>(VL[Lane])->getOperand(OpIdx),\n                                 APO, false};\n        }\n      }\n    }\n\n    /// \\returns the number of operands.\n    unsigned getNumOperands() const { return OpsVec.size(); }\n\n    /// \\returns the number of lanes.\n    unsigned getNumLanes() const { return OpsVec[0].size(); }\n\n    /// \\returns the operand value at \\p OpIdx and \\p Lane.\n    Value *getValue(unsigned OpIdx, unsigned Lane) const {\n      return getData(OpIdx, Lane).V;\n    }\n\n    /// \\returns true if the data structure is empty.\n    bool empty() const { return OpsVec.empty(); }\n\n    /// Clears the data.\n    void clear() { OpsVec.clear(); }\n\n    /// \\Returns true if there are enough operands identical to \\p Op to fill\n    /// the whole vector.\n    /// Note: This modifies the 'IsUsed' flag, so a cleanUsed() must follow.\n    bool shouldBroadcast(Value *Op, unsigned OpIdx, unsigned Lane) {\n      bool OpAPO = getData(OpIdx, Lane).APO;\n      for (unsigned Ln = 0, Lns = getNumLanes(); Ln != Lns; ++Ln) {\n        if (Ln == Lane)\n          continue;\n        // This is set to true if we found a candidate for broadcast at Lane.\n        bool FoundCandidate = false;\n        for (unsigned OpI = 0, OpE = getNumOperands(); OpI != OpE; ++OpI) {\n          OperandData &Data = getData(OpI, Ln);\n          if (Data.APO != OpAPO || Data.IsUsed)\n            continue;\n          if (Data.V == Op) {\n            FoundCandidate = true;\n            Data.IsUsed = true;\n            break;\n          }\n        }\n        if (!FoundCandidate)\n          return false;\n      }\n      return true;\n    }\n\n  public:\n    /// Initialize with all the operands of the instruction vector \\p RootVL.\n    VLOperands(ArrayRef<Value *> RootVL, const DataLayout &DL,\n               ScalarEvolution &SE, const BoUpSLP &R)\n        : DL(DL), SE(SE), R(R) {\n      // Append all the operands of RootVL.\n      appendOperandsOfVL(RootVL);\n    }\n\n    /// \\Returns a value vector with the operands across all lanes for the\n    /// opearnd at \\p OpIdx.\n    ValueList getVL(unsigned OpIdx) const {\n      ValueList OpVL(OpsVec[OpIdx].size());\n      assert(OpsVec[OpIdx].size() == getNumLanes() &&\n             \"Expected same num of lanes across all operands\");\n      for (unsigned Lane = 0, Lanes = getNumLanes(); Lane != Lanes; ++Lane)\n        OpVL[Lane] = OpsVec[OpIdx][Lane].V;\n      return OpVL;\n    }\n\n    // Performs operand reordering for 2 or more operands.\n    // The original operands are in OrigOps[OpIdx][Lane].\n    // The reordered operands are returned in 'SortedOps[OpIdx][Lane]'.\n    void reorder() {\n      unsigned NumOperands = getNumOperands();\n      unsigned NumLanes = getNumLanes();\n      // Each operand has its own mode. We are using this mode to help us select\n      // the instructions for each lane, so that they match best with the ones\n      // we have selected so far.\n      SmallVector<ReorderingMode, 2> ReorderingModes(NumOperands);\n\n      // This is a greedy single-pass algorithm. We are going over each lane\n      // once and deciding on the best order right away with no back-tracking.\n      // However, in order to increase its effectiveness, we start with the lane\n      // that has operands that can move the least. For example, given the\n      // following lanes:\n      //  Lane 0 : A[0] = B[0] + C[0]   // Visited 3rd\n      //  Lane 1 : A[1] = C[1] - B[1]   // Visited 1st\n      //  Lane 2 : A[2] = B[2] + C[2]   // Visited 2nd\n      //  Lane 3 : A[3] = C[3] - B[3]   // Visited 4th\n      // we will start at Lane 1, since the operands of the subtraction cannot\n      // be reordered. Then we will visit the rest of the lanes in a circular\n      // fashion. That is, Lanes 2, then Lane 0, and finally Lane 3.\n\n      // Find the first lane that we will start our search from.\n      unsigned FirstLane = getBestLaneToStartReordering();\n\n      // Initialize the modes.\n      for (unsigned OpIdx = 0; OpIdx != NumOperands; ++OpIdx) {\n        Value *OpLane0 = getValue(OpIdx, FirstLane);\n        // Keep track if we have instructions with all the same opcode on one\n        // side.\n        if (isa<LoadInst>(OpLane0))\n          ReorderingModes[OpIdx] = ReorderingMode::Load;\n        else if (isa<Instruction>(OpLane0)) {\n          // Check if OpLane0 should be broadcast.\n          if (shouldBroadcast(OpLane0, OpIdx, FirstLane))\n            ReorderingModes[OpIdx] = ReorderingMode::Splat;\n          else\n            ReorderingModes[OpIdx] = ReorderingMode::Opcode;\n        }\n        else if (isa<Constant>(OpLane0))\n          ReorderingModes[OpIdx] = ReorderingMode::Constant;\n        else if (isa<Argument>(OpLane0))\n          // Our best hope is a Splat. It may save some cost in some cases.\n          ReorderingModes[OpIdx] = ReorderingMode::Splat;\n        else\n          // NOTE: This should be unreachable.\n          ReorderingModes[OpIdx] = ReorderingMode::Failed;\n      }\n\n      // If the initial strategy fails for any of the operand indexes, then we\n      // perform reordering again in a second pass. This helps avoid assigning\n      // high priority to the failed strategy, and should improve reordering for\n      // the non-failed operand indexes.\n      for (int Pass = 0; Pass != 2; ++Pass) {\n        // Skip the second pass if the first pass did not fail.\n        bool StrategyFailed = false;\n        // Mark all operand data as free to use.\n        clearUsed();\n        // We keep the original operand order for the FirstLane, so reorder the\n        // rest of the lanes. We are visiting the nodes in a circular fashion,\n        // using FirstLane as the center point and increasing the radius\n        // distance.\n        for (unsigned Distance = 1; Distance != NumLanes; ++Distance) {\n          // Visit the lane on the right and then the lane on the left.\n          for (int Direction : {+1, -1}) {\n            int Lane = FirstLane + Direction * Distance;\n            if (Lane < 0 || Lane >= (int)NumLanes)\n              continue;\n            int LastLane = Lane - Direction;\n            assert(LastLane >= 0 && LastLane < (int)NumLanes &&\n                   \"Out of bounds\");\n            // Look for a good match for each operand.\n            for (unsigned OpIdx = 0; OpIdx != NumOperands; ++OpIdx) {\n              // Search for the operand that matches SortedOps[OpIdx][Lane-1].\n              Optional<unsigned> BestIdx =\n                  getBestOperand(OpIdx, Lane, LastLane, ReorderingModes);\n              // By not selecting a value, we allow the operands that follow to\n              // select a better matching value. We will get a non-null value in\n              // the next run of getBestOperand().\n              if (BestIdx) {\n                // Swap the current operand with the one returned by\n                // getBestOperand().\n                swap(OpIdx, BestIdx.getValue(), Lane);\n              } else {\n                // We failed to find a best operand, set mode to 'Failed'.\n                ReorderingModes[OpIdx] = ReorderingMode::Failed;\n                // Enable the second pass.\n                StrategyFailed = true;\n              }\n            }\n          }\n        }\n        // Skip second pass if the strategy did not fail.\n        if (!StrategyFailed)\n          break;\n      }\n    }\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n    LLVM_DUMP_METHOD static StringRef getModeStr(ReorderingMode RMode) {\n      switch (RMode) {\n      case ReorderingMode::Load:\n        return \"Load\";\n      case ReorderingMode::Opcode:\n        return \"Opcode\";\n      case ReorderingMode::Constant:\n        return \"Constant\";\n      case ReorderingMode::Splat:\n        return \"Splat\";\n      case ReorderingMode::Failed:\n        return \"Failed\";\n      }\n      llvm_unreachable(\"Unimplemented Reordering Type\");\n    }\n\n    LLVM_DUMP_METHOD static raw_ostream &printMode(ReorderingMode RMode,\n                                                   raw_ostream &OS) {\n      return OS << getModeStr(RMode);\n    }\n\n    /// Debug print.\n    LLVM_DUMP_METHOD static void dumpMode(ReorderingMode RMode) {\n      printMode(RMode, dbgs());\n    }\n\n    friend raw_ostream &operator<<(raw_ostream &OS, ReorderingMode RMode) {\n      return printMode(RMode, OS);\n    }\n\n    LLVM_DUMP_METHOD raw_ostream &print(raw_ostream &OS) const {\n      const unsigned Indent = 2;\n      unsigned Cnt = 0;\n      for (const OperandDataVec &OpDataVec : OpsVec) {\n        OS << \"Operand \" << Cnt++ << \"\\n\";\n        for (const OperandData &OpData : OpDataVec) {\n          OS.indent(Indent) << \"{\";\n          if (Value *V = OpData.V)\n            OS << *V;\n          else\n            OS << \"null\";\n          OS << \", APO:\" << OpData.APO << \"}\\n\";\n        }\n        OS << \"\\n\";\n      }\n      return OS;\n    }\n\n    /// Debug print.\n    LLVM_DUMP_METHOD void dump() const { print(dbgs()); }\n#endif\n  };\n\n  /// Checks if the instruction is marked for deletion.\n  bool isDeleted(Instruction *I) const { return DeletedInstructions.count(I); }\n\n  /// Marks values operands for later deletion by replacing them with Undefs.\n  void eraseInstructions(ArrayRef<Value *> AV);\n\n  ~BoUpSLP();\n\nprivate:\n  /// Checks if all users of \\p I are the part of the vectorization tree.\n  bool areAllUsersVectorized(Instruction *I) const;\n\n  /// \\returns the cost of the vectorizable entry.\n  InstructionCost getEntryCost(TreeEntry *E);\n\n  /// This is the recursive part of buildTree.\n  void buildTree_rec(ArrayRef<Value *> Roots, unsigned Depth,\n                     const EdgeInfo &EI);\n\n  /// \\returns true if the ExtractElement/ExtractValue instructions in \\p VL can\n  /// be vectorized to use the original vector (or aggregate \"bitcast\" to a\n  /// vector) and sets \\p CurrentOrder to the identity permutation; otherwise\n  /// returns false, setting \\p CurrentOrder to either an empty vector or a\n  /// non-identity permutation that allows to reuse extract instructions.\n  bool canReuseExtract(ArrayRef<Value *> VL, Value *OpValue,\n                       SmallVectorImpl<unsigned> &CurrentOrder) const;\n\n  /// Vectorize a single entry in the tree.\n  Value *vectorizeTree(TreeEntry *E);\n\n  /// Vectorize a single entry in the tree, starting in \\p VL.\n  Value *vectorizeTree(ArrayRef<Value *> VL);\n\n  /// \\returns the scalarization cost for this type. Scalarization in this\n  /// context means the creation of vectors from a group of scalars.\n  InstructionCost\n  getGatherCost(FixedVectorType *Ty,\n                const DenseSet<unsigned> &ShuffledIndices) const;\n\n  /// \\returns the scalarization cost for this list of values. Assuming that\n  /// this subtree gets vectorized, we may need to extract the values from the\n  /// roots. This method calculates the cost of extracting the values.\n  InstructionCost getGatherCost(ArrayRef<Value *> VL) const;\n\n  /// Set the Builder insert point to one after the last instruction in\n  /// the bundle\n  void setInsertPointAfterBundle(TreeEntry *E);\n\n  /// \\returns a vector from a collection of scalars in \\p VL.\n  Value *gather(ArrayRef<Value *> VL);\n\n  /// \\returns whether the VectorizableTree is fully vectorizable and will\n  /// be beneficial even the tree height is tiny.\n  bool isFullyVectorizableTinyTree() const;\n\n  /// Reorder commutative or alt operands to get better probability of\n  /// generating vectorized code.\n  static void reorderInputsAccordingToOpcode(ArrayRef<Value *> VL,\n                                             SmallVectorImpl<Value *> &Left,\n                                             SmallVectorImpl<Value *> &Right,\n                                             const DataLayout &DL,\n                                             ScalarEvolution &SE,\n                                             const BoUpSLP &R);\n  struct TreeEntry {\n    using VecTreeTy = SmallVector<std::unique_ptr<TreeEntry>, 8>;\n    TreeEntry(VecTreeTy &Container) : Container(Container) {}\n\n    /// \\returns true if the scalars in VL are equal to this entry.\n    bool isSame(ArrayRef<Value *> VL) const {\n      if (VL.size() == Scalars.size())\n        return std::equal(VL.begin(), VL.end(), Scalars.begin());\n      return VL.size() == ReuseShuffleIndices.size() &&\n             std::equal(\n                 VL.begin(), VL.end(), ReuseShuffleIndices.begin(),\n                 [this](Value *V, int Idx) { return V == Scalars[Idx]; });\n    }\n\n    /// A vector of scalars.\n    ValueList Scalars;\n\n    /// The Scalars are vectorized into this value. It is initialized to Null.\n    Value *VectorizedValue = nullptr;\n\n    /// Do we need to gather this sequence or vectorize it\n    /// (either with vector instruction or with scatter/gather\n    /// intrinsics for store/load)?\n    enum EntryState { Vectorize, ScatterVectorize, NeedToGather };\n    EntryState State;\n\n    /// Does this sequence require some shuffling?\n    SmallVector<int, 4> ReuseShuffleIndices;\n\n    /// Does this entry require reordering?\n    SmallVector<unsigned, 4> ReorderIndices;\n\n    /// Points back to the VectorizableTree.\n    ///\n    /// Only used for Graphviz right now.  Unfortunately GraphTrait::NodeRef has\n    /// to be a pointer and needs to be able to initialize the child iterator.\n    /// Thus we need a reference back to the container to translate the indices\n    /// to entries.\n    VecTreeTy &Container;\n\n    /// The TreeEntry index containing the user of this entry.  We can actually\n    /// have multiple users so the data structure is not truly a tree.\n    SmallVector<EdgeInfo, 1> UserTreeIndices;\n\n    /// The index of this treeEntry in VectorizableTree.\n    int Idx = -1;\n\n  private:\n    /// The operands of each instruction in each lane Operands[op_index][lane].\n    /// Note: This helps avoid the replication of the code that performs the\n    /// reordering of operands during buildTree_rec() and vectorizeTree().\n    SmallVector<ValueList, 2> Operands;\n\n    /// The main/alternate instruction.\n    Instruction *MainOp = nullptr;\n    Instruction *AltOp = nullptr;\n\n  public:\n    /// Set this bundle's \\p OpIdx'th operand to \\p OpVL.\n    void setOperand(unsigned OpIdx, ArrayRef<Value *> OpVL) {\n      if (Operands.size() < OpIdx + 1)\n        Operands.resize(OpIdx + 1);\n      assert(Operands[OpIdx].size() == 0 && \"Already resized?\");\n      Operands[OpIdx].resize(Scalars.size());\n      for (unsigned Lane = 0, E = Scalars.size(); Lane != E; ++Lane)\n        Operands[OpIdx][Lane] = OpVL[Lane];\n    }\n\n    /// Set the operands of this bundle in their original order.\n    void setOperandsInOrder() {\n      assert(Operands.empty() && \"Already initialized?\");\n      auto *I0 = cast<Instruction>(Scalars[0]);\n      Operands.resize(I0->getNumOperands());\n      unsigned NumLanes = Scalars.size();\n      for (unsigned OpIdx = 0, NumOperands = I0->getNumOperands();\n           OpIdx != NumOperands; ++OpIdx) {\n        Operands[OpIdx].resize(NumLanes);\n        for (unsigned Lane = 0; Lane != NumLanes; ++Lane) {\n          auto *I = cast<Instruction>(Scalars[Lane]);\n          assert(I->getNumOperands() == NumOperands &&\n                 \"Expected same number of operands\");\n          Operands[OpIdx][Lane] = I->getOperand(OpIdx);\n        }\n      }\n    }\n\n    /// \\returns the \\p OpIdx operand of this TreeEntry.\n    ValueList &getOperand(unsigned OpIdx) {\n      assert(OpIdx < Operands.size() && \"Off bounds\");\n      return Operands[OpIdx];\n    }\n\n    /// \\returns the number of operands.\n    unsigned getNumOperands() const { return Operands.size(); }\n\n    /// \\return the single \\p OpIdx operand.\n    Value *getSingleOperand(unsigned OpIdx) const {\n      assert(OpIdx < Operands.size() && \"Off bounds\");\n      assert(!Operands[OpIdx].empty() && \"No operand available\");\n      return Operands[OpIdx][0];\n    }\n\n    /// Some of the instructions in the list have alternate opcodes.\n    bool isAltShuffle() const {\n      return getOpcode() != getAltOpcode();\n    }\n\n    bool isOpcodeOrAlt(Instruction *I) const {\n      unsigned CheckedOpcode = I->getOpcode();\n      return (getOpcode() == CheckedOpcode ||\n              getAltOpcode() == CheckedOpcode);\n    }\n\n    /// Chooses the correct key for scheduling data. If \\p Op has the same (or\n    /// alternate) opcode as \\p OpValue, the key is \\p Op. Otherwise the key is\n    /// \\p OpValue.\n    Value *isOneOf(Value *Op) const {\n      auto *I = dyn_cast<Instruction>(Op);\n      if (I && isOpcodeOrAlt(I))\n        return Op;\n      return MainOp;\n    }\n\n    void setOperations(const InstructionsState &S) {\n      MainOp = S.MainOp;\n      AltOp = S.AltOp;\n    }\n\n    Instruction *getMainOp() const {\n      return MainOp;\n    }\n\n    Instruction *getAltOp() const {\n      return AltOp;\n    }\n\n    /// The main/alternate opcodes for the list of instructions.\n    unsigned getOpcode() const {\n      return MainOp ? MainOp->getOpcode() : 0;\n    }\n\n    unsigned getAltOpcode() const {\n      return AltOp ? AltOp->getOpcode() : 0;\n    }\n\n    /// Update operations state of this entry if reorder occurred.\n    bool updateStateIfReorder() {\n      if (ReorderIndices.empty())\n        return false;\n      InstructionsState S = getSameOpcode(Scalars, ReorderIndices.front());\n      setOperations(S);\n      return true;\n    }\n\n#ifndef NDEBUG\n    /// Debug printer.\n    LLVM_DUMP_METHOD void dump() const {\n      dbgs() << Idx << \".\\n\";\n      for (unsigned OpI = 0, OpE = Operands.size(); OpI != OpE; ++OpI) {\n        dbgs() << \"Operand \" << OpI << \":\\n\";\n        for (const Value *V : Operands[OpI])\n          dbgs().indent(2) << *V << \"\\n\";\n      }\n      dbgs() << \"Scalars: \\n\";\n      for (Value *V : Scalars)\n        dbgs().indent(2) << *V << \"\\n\";\n      dbgs() << \"State: \";\n      switch (State) {\n      case Vectorize:\n        dbgs() << \"Vectorize\\n\";\n        break;\n      case ScatterVectorize:\n        dbgs() << \"ScatterVectorize\\n\";\n        break;\n      case NeedToGather:\n        dbgs() << \"NeedToGather\\n\";\n        break;\n      }\n      dbgs() << \"MainOp: \";\n      if (MainOp)\n        dbgs() << *MainOp << \"\\n\";\n      else\n        dbgs() << \"NULL\\n\";\n      dbgs() << \"AltOp: \";\n      if (AltOp)\n        dbgs() << *AltOp << \"\\n\";\n      else\n        dbgs() << \"NULL\\n\";\n      dbgs() << \"VectorizedValue: \";\n      if (VectorizedValue)\n        dbgs() << *VectorizedValue << \"\\n\";\n      else\n        dbgs() << \"NULL\\n\";\n      dbgs() << \"ReuseShuffleIndices: \";\n      if (ReuseShuffleIndices.empty())\n        dbgs() << \"Empty\";\n      else\n        for (unsigned ReuseIdx : ReuseShuffleIndices)\n          dbgs() << ReuseIdx << \", \";\n      dbgs() << \"\\n\";\n      dbgs() << \"ReorderIndices: \";\n      for (unsigned ReorderIdx : ReorderIndices)\n        dbgs() << ReorderIdx << \", \";\n      dbgs() << \"\\n\";\n      dbgs() << \"UserTreeIndices: \";\n      for (const auto &EInfo : UserTreeIndices)\n        dbgs() << EInfo << \", \";\n      dbgs() << \"\\n\";\n    }\n#endif\n  };\n\n#ifndef NDEBUG\n  void dumpTreeCosts(TreeEntry *E, InstructionCost ReuseShuffleCost,\n                     InstructionCost VecCost,\n                     InstructionCost ScalarCost) const {\n    dbgs() << \"SLP: Calculated costs for Tree:\\n\"; E->dump();\n    dbgs() << \"SLP: Costs:\\n\";\n    dbgs() << \"SLP:     ReuseShuffleCost = \" << ReuseShuffleCost << \"\\n\";\n    dbgs() << \"SLP:     VectorCost = \" << VecCost << \"\\n\";\n    dbgs() << \"SLP:     ScalarCost = \" << ScalarCost << \"\\n\";\n    dbgs() << \"SLP:     ReuseShuffleCost + VecCost - ScalarCost = \" <<\n               ReuseShuffleCost + VecCost - ScalarCost << \"\\n\";\n  }\n#endif\n\n  /// Create a new VectorizableTree entry.\n  TreeEntry *newTreeEntry(ArrayRef<Value *> VL, Optional<ScheduleData *> Bundle,\n                          const InstructionsState &S,\n                          const EdgeInfo &UserTreeIdx,\n                          ArrayRef<unsigned> ReuseShuffleIndices = None,\n                          ArrayRef<unsigned> ReorderIndices = None) {\n    TreeEntry::EntryState EntryState =\n        Bundle ? TreeEntry::Vectorize : TreeEntry::NeedToGather;\n    return newTreeEntry(VL, EntryState, Bundle, S, UserTreeIdx,\n                        ReuseShuffleIndices, ReorderIndices);\n  }\n\n  TreeEntry *newTreeEntry(ArrayRef<Value *> VL,\n                          TreeEntry::EntryState EntryState,\n                          Optional<ScheduleData *> Bundle,\n                          const InstructionsState &S,\n                          const EdgeInfo &UserTreeIdx,\n                          ArrayRef<unsigned> ReuseShuffleIndices = None,\n                          ArrayRef<unsigned> ReorderIndices = None) {\n    assert(((!Bundle && EntryState == TreeEntry::NeedToGather) ||\n            (Bundle && EntryState != TreeEntry::NeedToGather)) &&\n           \"Need to vectorize gather entry?\");\n    VectorizableTree.push_back(std::make_unique<TreeEntry>(VectorizableTree));\n    TreeEntry *Last = VectorizableTree.back().get();\n    Last->Idx = VectorizableTree.size() - 1;\n    Last->Scalars.insert(Last->Scalars.begin(), VL.begin(), VL.end());\n    Last->State = EntryState;\n    Last->ReuseShuffleIndices.append(ReuseShuffleIndices.begin(),\n                                     ReuseShuffleIndices.end());\n    Last->ReorderIndices.append(ReorderIndices.begin(), ReorderIndices.end());\n    Last->setOperations(S);\n    if (Last->State != TreeEntry::NeedToGather) {\n      for (Value *V : VL) {\n        assert(!getTreeEntry(V) && \"Scalar already in tree!\");\n        ScalarToTreeEntry[V] = Last;\n      }\n      // Update the scheduler bundle to point to this TreeEntry.\n      unsigned Lane = 0;\n      for (ScheduleData *BundleMember = Bundle.getValue(); BundleMember;\n           BundleMember = BundleMember->NextInBundle) {\n        BundleMember->TE = Last;\n        BundleMember->Lane = Lane;\n        ++Lane;\n      }\n      assert((!Bundle.getValue() || Lane == VL.size()) &&\n             \"Bundle and VL out of sync\");\n    } else {\n      MustGather.insert(VL.begin(), VL.end());\n    }\n\n    if (UserTreeIdx.UserTE)\n      Last->UserTreeIndices.push_back(UserTreeIdx);\n\n    return Last;\n  }\n\n  /// -- Vectorization State --\n  /// Holds all of the tree entries.\n  TreeEntry::VecTreeTy VectorizableTree;\n\n#ifndef NDEBUG\n  /// Debug printer.\n  LLVM_DUMP_METHOD void dumpVectorizableTree() const {\n    for (unsigned Id = 0, IdE = VectorizableTree.size(); Id != IdE; ++Id) {\n      VectorizableTree[Id]->dump();\n      dbgs() << \"\\n\";\n    }\n  }\n#endif\n\n  TreeEntry *getTreeEntry(Value *V) { return ScalarToTreeEntry.lookup(V); }\n\n  const TreeEntry *getTreeEntry(Value *V) const {\n    return ScalarToTreeEntry.lookup(V);\n  }\n\n  /// Maps a specific scalar to its tree entry.\n  SmallDenseMap<Value*, TreeEntry *> ScalarToTreeEntry;\n\n  /// Maps a value\u00a0to the proposed vectorizable size.\n  SmallDenseMap<Value *, unsigned> InstrElementSize;\n\n  /// A list of scalars that we found that we need to keep as scalars.\n  ValueSet MustGather;\n\n  /// This POD struct describes one external user in the vectorized tree.\n  struct ExternalUser {\n    ExternalUser(Value *S, llvm::User *U, int L)\n        : Scalar(S), User(U), Lane(L) {}\n\n    // Which scalar in our function.\n    Value *Scalar;\n\n    // Which user that uses the scalar.\n    llvm::User *User;\n\n    // Which lane does the scalar belong to.\n    int Lane;\n  };\n  using UserList = SmallVector<ExternalUser, 16>;\n\n  /// Checks if two instructions may access the same memory.\n  ///\n  /// \\p Loc1 is the location of \\p Inst1. It is passed explicitly because it\n  /// is invariant in the calling loop.\n  bool isAliased(const MemoryLocation &Loc1, Instruction *Inst1,\n                 Instruction *Inst2) {\n    // First check if the result is already in the cache.\n    AliasCacheKey key = std::make_pair(Inst1, Inst2);\n    Optional<bool> &result = AliasCache[key];\n    if (result.hasValue()) {\n      return result.getValue();\n    }\n    MemoryLocation Loc2 = getLocation(Inst2, AA);\n    bool aliased = true;\n    if (Loc1.Ptr && Loc2.Ptr && isSimple(Inst1) && isSimple(Inst2)) {\n      // Do the alias check.\n      aliased = AA->alias(Loc1, Loc2);\n    }\n    // Store the result in the cache.\n    result = aliased;\n    return aliased;\n  }\n\n  using AliasCacheKey = std::pair<Instruction *, Instruction *>;\n\n  /// Cache for alias results.\n  /// TODO: consider moving this to the AliasAnalysis itself.\n  DenseMap<AliasCacheKey, Optional<bool>> AliasCache;\n\n  /// Removes an instruction from its block and eventually deletes it.\n  /// It's like Instruction::eraseFromParent() except that the actual deletion\n  /// is delayed until BoUpSLP is destructed.\n  /// This is required to ensure that there are no incorrect collisions in the\n  /// AliasCache, which can happen if a new instruction is allocated at the\n  /// same address as a previously deleted instruction.\n  void eraseInstruction(Instruction *I, bool ReplaceOpsWithUndef = false) {\n    auto It = DeletedInstructions.try_emplace(I, ReplaceOpsWithUndef).first;\n    It->getSecond() = It->getSecond() && ReplaceOpsWithUndef;\n  }\n\n  /// Temporary store for deleted instructions. Instructions will be deleted\n  /// eventually when the BoUpSLP is destructed.\n  DenseMap<Instruction *, bool> DeletedInstructions;\n\n  /// A list of values that need to extracted out of the tree.\n  /// This list holds pairs of (Internal Scalar : External User). External User\n  /// can be nullptr, it means that this Internal Scalar will be used later,\n  /// after vectorization.\n  UserList ExternalUses;\n\n  /// Values used only by @llvm.assume calls.\n  SmallPtrSet<const Value *, 32> EphValues;\n\n  /// Holds all of the instructions that we gathered.\n  SetVector<Instruction *> GatherSeq;\n\n  /// A list of blocks that we are going to CSE.\n  SetVector<BasicBlock *> CSEBlocks;\n\n  /// Contains all scheduling relevant data for an instruction.\n  /// A ScheduleData either represents a single instruction or a member of an\n  /// instruction bundle (= a group of instructions which is combined into a\n  /// vector instruction).\n  struct ScheduleData {\n    // The initial value for the dependency counters. It means that the\n    // dependencies are not calculated yet.\n    enum { InvalidDeps = -1 };\n\n    ScheduleData() = default;\n\n    void init(int BlockSchedulingRegionID, Value *OpVal) {\n      FirstInBundle = this;\n      NextInBundle = nullptr;\n      NextLoadStore = nullptr;\n      IsScheduled = false;\n      SchedulingRegionID = BlockSchedulingRegionID;\n      UnscheduledDepsInBundle = UnscheduledDeps;\n      clearDependencies();\n      OpValue = OpVal;\n      TE = nullptr;\n      Lane = -1;\n    }\n\n    /// Returns true if the dependency information has been calculated.\n    bool hasValidDependencies() const { return Dependencies != InvalidDeps; }\n\n    /// Returns true for single instructions and for bundle representatives\n    /// (= the head of a bundle).\n    bool isSchedulingEntity() const { return FirstInBundle == this; }\n\n    /// Returns true if it represents an instruction bundle and not only a\n    /// single instruction.\n    bool isPartOfBundle() const {\n      return NextInBundle != nullptr || FirstInBundle != this;\n    }\n\n    /// Returns true if it is ready for scheduling, i.e. it has no more\n    /// unscheduled depending instructions/bundles.\n    bool isReady() const {\n      assert(isSchedulingEntity() &&\n             \"can't consider non-scheduling entity for ready list\");\n      return UnscheduledDepsInBundle == 0 && !IsScheduled;\n    }\n\n    /// Modifies the number of unscheduled dependencies, also updating it for\n    /// the whole bundle.\n    int incrementUnscheduledDeps(int Incr) {\n      UnscheduledDeps += Incr;\n      return FirstInBundle->UnscheduledDepsInBundle += Incr;\n    }\n\n    /// Sets the number of unscheduled dependencies to the number of\n    /// dependencies.\n    void resetUnscheduledDeps() {\n      incrementUnscheduledDeps(Dependencies - UnscheduledDeps);\n    }\n\n    /// Clears all dependency information.\n    void clearDependencies() {\n      Dependencies = InvalidDeps;\n      resetUnscheduledDeps();\n      MemoryDependencies.clear();\n    }\n\n    void dump(raw_ostream &os) const {\n      if (!isSchedulingEntity()) {\n        os << \"/ \" << *Inst;\n      } else if (NextInBundle) {\n        os << '[' << *Inst;\n        ScheduleData *SD = NextInBundle;\n        while (SD) {\n          os << ';' << *SD->Inst;\n          SD = SD->NextInBundle;\n        }\n        os << ']';\n      } else {\n        os << *Inst;\n      }\n    }\n\n    Instruction *Inst = nullptr;\n\n    /// Points to the head in an instruction bundle (and always to this for\n    /// single instructions).\n    ScheduleData *FirstInBundle = nullptr;\n\n    /// Single linked list of all instructions in a bundle. Null if it is a\n    /// single instruction.\n    ScheduleData *NextInBundle = nullptr;\n\n    /// Single linked list of all memory instructions (e.g. load, store, call)\n    /// in the block - until the end of the scheduling region.\n    ScheduleData *NextLoadStore = nullptr;\n\n    /// The dependent memory instructions.\n    /// This list is derived on demand in calculateDependencies().\n    SmallVector<ScheduleData *, 4> MemoryDependencies;\n\n    /// This ScheduleData is in the current scheduling region if this matches\n    /// the current SchedulingRegionID of BlockScheduling.\n    int SchedulingRegionID = 0;\n\n    /// Used for getting a \"good\" final ordering of instructions.\n    int SchedulingPriority = 0;\n\n    /// The number of dependencies. Constitutes of the number of users of the\n    /// instruction plus the number of dependent memory instructions (if any).\n    /// This value is calculated on demand.\n    /// If InvalidDeps, the number of dependencies is not calculated yet.\n    int Dependencies = InvalidDeps;\n\n    /// The number of dependencies minus the number of dependencies of scheduled\n    /// instructions. As soon as this is zero, the instruction/bundle gets ready\n    /// for scheduling.\n    /// Note that this is negative as long as Dependencies is not calculated.\n    int UnscheduledDeps = InvalidDeps;\n\n    /// The sum of UnscheduledDeps in a bundle. Equals to UnscheduledDeps for\n    /// single instructions.\n    int UnscheduledDepsInBundle = InvalidDeps;\n\n    /// True if this instruction is scheduled (or considered as scheduled in the\n    /// dry-run).\n    bool IsScheduled = false;\n\n    /// Opcode of the current instruction in the schedule data.\n    Value *OpValue = nullptr;\n\n    /// The TreeEntry that this instruction corresponds to.\n    TreeEntry *TE = nullptr;\n\n    /// The lane of this node in the TreeEntry.\n    int Lane = -1;\n  };\n\n#ifndef NDEBUG\n  friend inline raw_ostream &operator<<(raw_ostream &os,\n                                        const BoUpSLP::ScheduleData &SD) {\n    SD.dump(os);\n    return os;\n  }\n#endif\n\n  friend struct GraphTraits<BoUpSLP *>;\n  friend struct DOTGraphTraits<BoUpSLP *>;\n\n  /// Contains all scheduling data for a basic block.\n  struct BlockScheduling {\n    BlockScheduling(BasicBlock *BB)\n        : BB(BB), ChunkSize(BB->size()), ChunkPos(ChunkSize) {}\n\n    void clear() {\n      ReadyInsts.clear();\n      ScheduleStart = nullptr;\n      ScheduleEnd = nullptr;\n      FirstLoadStoreInRegion = nullptr;\n      LastLoadStoreInRegion = nullptr;\n\n      // Reduce the maximum schedule region size by the size of the\n      // previous scheduling run.\n      ScheduleRegionSizeLimit -= ScheduleRegionSize;\n      if (ScheduleRegionSizeLimit < MinScheduleRegionSize)\n        ScheduleRegionSizeLimit = MinScheduleRegionSize;\n      ScheduleRegionSize = 0;\n\n      // Make a new scheduling region, i.e. all existing ScheduleData is not\n      // in the new region yet.\n      ++SchedulingRegionID;\n    }\n\n    ScheduleData *getScheduleData(Value *V) {\n      ScheduleData *SD = ScheduleDataMap[V];\n      if (SD && SD->SchedulingRegionID == SchedulingRegionID)\n        return SD;\n      return nullptr;\n    }\n\n    ScheduleData *getScheduleData(Value *V, Value *Key) {\n      if (V == Key)\n        return getScheduleData(V);\n      auto I = ExtraScheduleDataMap.find(V);\n      if (I != ExtraScheduleDataMap.end()) {\n        ScheduleData *SD = I->second[Key];\n        if (SD && SD->SchedulingRegionID == SchedulingRegionID)\n          return SD;\n      }\n      return nullptr;\n    }\n\n    bool isInSchedulingRegion(ScheduleData *SD) const {\n      return SD->SchedulingRegionID == SchedulingRegionID;\n    }\n\n    /// Marks an instruction as scheduled and puts all dependent ready\n    /// instructions into the ready-list.\n    template <typename ReadyListType>\n    void schedule(ScheduleData *SD, ReadyListType &ReadyList) {\n      SD->IsScheduled = true;\n      LLVM_DEBUG(dbgs() << \"SLP:   schedule \" << *SD << \"\\n\");\n\n      ScheduleData *BundleMember = SD;\n      while (BundleMember) {\n        if (BundleMember->Inst != BundleMember->OpValue) {\n          BundleMember = BundleMember->NextInBundle;\n          continue;\n        }\n        // Handle the def-use chain dependencies.\n\n        // Decrement the unscheduled counter and insert to ready list if ready.\n        auto &&DecrUnsched = [this, &ReadyList](Instruction *I) {\n          doForAllOpcodes(I, [&ReadyList](ScheduleData *OpDef) {\n            if (OpDef && OpDef->hasValidDependencies() &&\n                OpDef->incrementUnscheduledDeps(-1) == 0) {\n              // There are no more unscheduled dependencies after\n              // decrementing, so we can put the dependent instruction\n              // into the ready list.\n              ScheduleData *DepBundle = OpDef->FirstInBundle;\n              assert(!DepBundle->IsScheduled &&\n                     \"already scheduled bundle gets ready\");\n              ReadyList.insert(DepBundle);\n              LLVM_DEBUG(dbgs()\n                         << \"SLP:    gets ready (def): \" << *DepBundle << \"\\n\");\n            }\n          });\n        };\n\n        // If BundleMember is a vector bundle, its operands may have been\n        // reordered duiring buildTree(). We therefore need to get its operands\n        // through the TreeEntry.\n        if (TreeEntry *TE = BundleMember->TE) {\n          int Lane = BundleMember->Lane;\n          assert(Lane >= 0 && \"Lane not set\");\n\n          // Since vectorization tree is being built recursively this assertion\n          // ensures that the tree entry has all operands set before reaching\n          // this code. Couple of exceptions known at the moment are extracts\n          // where their second (immediate) operand is not added. Since\n          // immediates do not affect scheduler behavior this is considered\n          // okay.\n          auto *In = TE->getMainOp();\n          assert(In &&\n                 (isa<ExtractValueInst>(In) || isa<ExtractElementInst>(In) ||\n                  In->getNumOperands() == TE->getNumOperands()) &&\n                 \"Missed TreeEntry operands?\");\n          (void)In; // fake use to avoid build failure when assertions disabled\n\n          for (unsigned OpIdx = 0, NumOperands = TE->getNumOperands();\n               OpIdx != NumOperands; ++OpIdx)\n            if (auto *I = dyn_cast<Instruction>(TE->getOperand(OpIdx)[Lane]))\n              DecrUnsched(I);\n        } else {\n          // If BundleMember is a stand-alone instruction, no operand reordering\n          // has taken place, so we directly access its operands.\n          for (Use &U : BundleMember->Inst->operands())\n            if (auto *I = dyn_cast<Instruction>(U.get()))\n              DecrUnsched(I);\n        }\n        // Handle the memory dependencies.\n        for (ScheduleData *MemoryDepSD : BundleMember->MemoryDependencies) {\n          if (MemoryDepSD->incrementUnscheduledDeps(-1) == 0) {\n            // There are no more unscheduled dependencies after decrementing,\n            // so we can put the dependent instruction into the ready list.\n            ScheduleData *DepBundle = MemoryDepSD->FirstInBundle;\n            assert(!DepBundle->IsScheduled &&\n                   \"already scheduled bundle gets ready\");\n            ReadyList.insert(DepBundle);\n            LLVM_DEBUG(dbgs()\n                       << \"SLP:    gets ready (mem): \" << *DepBundle << \"\\n\");\n          }\n        }\n        BundleMember = BundleMember->NextInBundle;\n      }\n    }\n\n    void doForAllOpcodes(Value *V,\n                         function_ref<void(ScheduleData *SD)> Action) {\n      if (ScheduleData *SD = getScheduleData(V))\n        Action(SD);\n      auto I = ExtraScheduleDataMap.find(V);\n      if (I != ExtraScheduleDataMap.end())\n        for (auto &P : I->second)\n          if (P.second->SchedulingRegionID == SchedulingRegionID)\n            Action(P.second);\n    }\n\n    /// Put all instructions into the ReadyList which are ready for scheduling.\n    template <typename ReadyListType>\n    void initialFillReadyList(ReadyListType &ReadyList) {\n      for (auto *I = ScheduleStart; I != ScheduleEnd; I = I->getNextNode()) {\n        doForAllOpcodes(I, [&](ScheduleData *SD) {\n          if (SD->isSchedulingEntity() && SD->isReady()) {\n            ReadyList.insert(SD);\n            LLVM_DEBUG(dbgs()\n                       << \"SLP:    initially in ready list: \" << *I << \"\\n\");\n          }\n        });\n      }\n    }\n\n    /// Checks if a bundle of instructions can be scheduled, i.e. has no\n    /// cyclic dependencies. This is only a dry-run, no instructions are\n    /// actually moved at this stage.\n    /// \\returns the scheduling bundle. The returned Optional value is non-None\n    /// if \\p VL is allowed to be scheduled.\n    Optional<ScheduleData *>\n    tryScheduleBundle(ArrayRef<Value *> VL, BoUpSLP *SLP,\n                      const InstructionsState &S);\n\n    /// Un-bundles a group of instructions.\n    void cancelScheduling(ArrayRef<Value *> VL, Value *OpValue);\n\n    /// Allocates schedule data chunk.\n    ScheduleData *allocateScheduleDataChunks();\n\n    /// Extends the scheduling region so that V is inside the region.\n    /// \\returns true if the region size is within the limit.\n    bool extendSchedulingRegion(Value *V, const InstructionsState &S);\n\n    /// Initialize the ScheduleData structures for new instructions in the\n    /// scheduling region.\n    void initScheduleData(Instruction *FromI, Instruction *ToI,\n                          ScheduleData *PrevLoadStore,\n                          ScheduleData *NextLoadStore);\n\n    /// Updates the dependency information of a bundle and of all instructions/\n    /// bundles which depend on the original bundle.\n    void calculateDependencies(ScheduleData *SD, bool InsertInReadyList,\n                               BoUpSLP *SLP);\n\n    /// Sets all instruction in the scheduling region to un-scheduled.\n    void resetSchedule();\n\n    BasicBlock *BB;\n\n    /// Simple memory allocation for ScheduleData.\n    std::vector<std::unique_ptr<ScheduleData[]>> ScheduleDataChunks;\n\n    /// The size of a ScheduleData array in ScheduleDataChunks.\n    int ChunkSize;\n\n    /// The allocator position in the current chunk, which is the last entry\n    /// of ScheduleDataChunks.\n    int ChunkPos;\n\n    /// Attaches ScheduleData to Instruction.\n    /// Note that the mapping survives during all vectorization iterations, i.e.\n    /// ScheduleData structures are recycled.\n    DenseMap<Value *, ScheduleData *> ScheduleDataMap;\n\n    /// Attaches ScheduleData to Instruction with the leading key.\n    DenseMap<Value *, SmallDenseMap<Value *, ScheduleData *>>\n        ExtraScheduleDataMap;\n\n    struct ReadyList : SmallVector<ScheduleData *, 8> {\n      void insert(ScheduleData *SD) { push_back(SD); }\n    };\n\n    /// The ready-list for scheduling (only used for the dry-run).\n    ReadyList ReadyInsts;\n\n    /// The first instruction of the scheduling region.\n    Instruction *ScheduleStart = nullptr;\n\n    /// The first instruction _after_ the scheduling region.\n    Instruction *ScheduleEnd = nullptr;\n\n    /// The first memory accessing instruction in the scheduling region\n    /// (can be null).\n    ScheduleData *FirstLoadStoreInRegion = nullptr;\n\n    /// The last memory accessing instruction in the scheduling region\n    /// (can be null).\n    ScheduleData *LastLoadStoreInRegion = nullptr;\n\n    /// The current size of the scheduling region.\n    int ScheduleRegionSize = 0;\n\n    /// The maximum size allowed for the scheduling region.\n    int ScheduleRegionSizeLimit = ScheduleRegionSizeBudget;\n\n    /// The ID of the scheduling region. For a new vectorization iteration this\n    /// is incremented which \"removes\" all ScheduleData from the region.\n    // Make sure that the initial SchedulingRegionID is greater than the\n    // initial SchedulingRegionID in ScheduleData (which is 0).\n    int SchedulingRegionID = 1;\n  };\n\n  /// Attaches the BlockScheduling structures to basic blocks.\n  MapVector<BasicBlock *, std::unique_ptr<BlockScheduling>> BlocksSchedules;\n\n  /// Performs the \"real\" scheduling. Done before vectorization is actually\n  /// performed in a basic block.\n  void scheduleBlock(BlockScheduling *BS);\n\n  /// List of users to ignore during scheduling and that don't need extracting.\n  ArrayRef<Value *> UserIgnoreList;\n\n  /// A DenseMapInfo implementation for holding DenseMaps and DenseSets of\n  /// sorted SmallVectors of unsigned.\n  struct OrdersTypeDenseMapInfo {\n    static OrdersType getEmptyKey() {\n      OrdersType V;\n      V.push_back(~1U);\n      return V;\n    }\n\n    static OrdersType getTombstoneKey() {\n      OrdersType V;\n      V.push_back(~2U);\n      return V;\n    }\n\n    static unsigned getHashValue(const OrdersType &V) {\n      return static_cast<unsigned>(hash_combine_range(V.begin(), V.end()));\n    }\n\n    static bool isEqual(const OrdersType &LHS, const OrdersType &RHS) {\n      return LHS == RHS;\n    }\n  };\n\n  /// Contains orders of operations along with the number of bundles that have\n  /// operations in this order. It stores only those orders that require\n  /// reordering, if reordering is not required it is counted using \\a\n  /// NumOpsWantToKeepOriginalOrder.\n  DenseMap<OrdersType, unsigned, OrdersTypeDenseMapInfo> NumOpsWantToKeepOrder;\n  /// Number of bundles that do not require reordering.\n  unsigned NumOpsWantToKeepOriginalOrder = 0;\n\n  // Analysis and block reference.\n  Function *F;\n  ScalarEvolution *SE;\n  TargetTransformInfo *TTI;\n  TargetLibraryInfo *TLI;\n  AAResults *AA;\n  LoopInfo *LI;\n  DominatorTree *DT;\n  AssumptionCache *AC;\n  DemandedBits *DB;\n  const DataLayout *DL;\n  OptimizationRemarkEmitter *ORE;\n\n  unsigned MaxVecRegSize; // This is set by TTI or overridden by cl::opt.\n  unsigned MinVecRegSize; // Set by cl::opt (default: 128).\n\n  /// Instruction builder to construct the vectorized tree.\n  IRBuilder<> Builder;\n\n  /// A map of scalar integer values to the smallest bit width with which they\n  /// can legally be represented. The values map to (width, signed) pairs,\n  /// where \"width\" indicates the minimum bit width and \"signed\" is True if the\n  /// value must be signed-extended, rather than zero-extended, back to its\n  /// original width.\n  MapVector<Value *, std::pair<uint64_t, bool>> MinBWs;\n};\n\n} // end namespace slpvectorizer\n\ntemplate <> struct GraphTraits<BoUpSLP *> {\n  using TreeEntry = BoUpSLP::TreeEntry;\n\n  /// NodeRef has to be a pointer per the GraphWriter.\n  using NodeRef = TreeEntry *;\n\n  using ContainerTy = BoUpSLP::TreeEntry::VecTreeTy;\n\n  /// Add the VectorizableTree to the index iterator to be able to return\n  /// TreeEntry pointers.\n  struct ChildIteratorType\n      : public iterator_adaptor_base<\n            ChildIteratorType, SmallVector<BoUpSLP::EdgeInfo, 1>::iterator> {\n    ContainerTy &VectorizableTree;\n\n    ChildIteratorType(SmallVector<BoUpSLP::EdgeInfo, 1>::iterator W,\n                      ContainerTy &VT)\n        : ChildIteratorType::iterator_adaptor_base(W), VectorizableTree(VT) {}\n\n    NodeRef operator*() { return I->UserTE; }\n  };\n\n  static NodeRef getEntryNode(BoUpSLP &R) {\n    return R.VectorizableTree[0].get();\n  }\n\n  static ChildIteratorType child_begin(NodeRef N) {\n    return {N->UserTreeIndices.begin(), N->Container};\n  }\n\n  static ChildIteratorType child_end(NodeRef N) {\n    return {N->UserTreeIndices.end(), N->Container};\n  }\n\n  /// For the node iterator we just need to turn the TreeEntry iterator into a\n  /// TreeEntry* iterator so that it dereferences to NodeRef.\n  class nodes_iterator {\n    using ItTy = ContainerTy::iterator;\n    ItTy It;\n\n  public:\n    nodes_iterator(const ItTy &It2) : It(It2) {}\n    NodeRef operator*() { return It->get(); }\n    nodes_iterator operator++() {\n      ++It;\n      return *this;\n    }\n    bool operator!=(const nodes_iterator &N2) const { return N2.It != It; }\n  };\n\n  static nodes_iterator nodes_begin(BoUpSLP *R) {\n    return nodes_iterator(R->VectorizableTree.begin());\n  }\n\n  static nodes_iterator nodes_end(BoUpSLP *R) {\n    return nodes_iterator(R->VectorizableTree.end());\n  }\n\n  static unsigned size(BoUpSLP *R) { return R->VectorizableTree.size(); }\n};\n\ntemplate <> struct DOTGraphTraits<BoUpSLP *> : public DefaultDOTGraphTraits {\n  using TreeEntry = BoUpSLP::TreeEntry;\n\n  DOTGraphTraits(bool isSimple = false) : DefaultDOTGraphTraits(isSimple) {}\n\n  std::string getNodeLabel(const TreeEntry *Entry, const BoUpSLP *R) {\n    std::string Str;\n    raw_string_ostream OS(Str);\n    if (isSplat(Entry->Scalars)) {\n      OS << \"<splat> \" << *Entry->Scalars[0];\n      return Str;\n    }\n    for (auto V : Entry->Scalars) {\n      OS << *V;\n      if (llvm::any_of(R->ExternalUses, [&](const BoUpSLP::ExternalUser &EU) {\n            return EU.Scalar == V;\n          }))\n        OS << \" <extract>\";\n      OS << \"\\n\";\n    }\n    return Str;\n  }\n\n  static std::string getNodeAttributes(const TreeEntry *Entry,\n                                       const BoUpSLP *) {\n    if (Entry->State == TreeEntry::NeedToGather)\n      return \"color=red\";\n    return \"\";\n  }\n};\n\n} // end namespace llvm\n\nBoUpSLP::~BoUpSLP() {\n  for (const auto &Pair : DeletedInstructions) {\n    // Replace operands of ignored instructions with Undefs in case if they were\n    // marked for deletion.\n    if (Pair.getSecond()) {\n      Value *Undef = UndefValue::get(Pair.getFirst()->getType());\n      Pair.getFirst()->replaceAllUsesWith(Undef);\n    }\n    Pair.getFirst()->dropAllReferences();\n  }\n  for (const auto &Pair : DeletedInstructions) {\n    assert(Pair.getFirst()->use_empty() &&\n           \"trying to erase instruction with users.\");\n    Pair.getFirst()->eraseFromParent();\n  }\n#ifdef EXPENSIVE_CHECKS\n  // If we could guarantee that this call is not extremely slow, we could\n  // remove the ifdef limitation (see PR47712).\n  assert(!verifyFunction(*F, &dbgs()));\n#endif\n}\n\nvoid BoUpSLP::eraseInstructions(ArrayRef<Value *> AV) {\n  for (auto *V : AV) {\n    if (auto *I = dyn_cast<Instruction>(V))\n      eraseInstruction(I, /*ReplaceOpsWithUndef=*/true);\n  };\n}\n\nvoid BoUpSLP::buildTree(ArrayRef<Value *> Roots,\n                        ArrayRef<Value *> UserIgnoreLst) {\n  ExtraValueToDebugLocsMap ExternallyUsedValues;\n  buildTree(Roots, ExternallyUsedValues, UserIgnoreLst);\n}\n\nvoid BoUpSLP::buildTree(ArrayRef<Value *> Roots,\n                        ExtraValueToDebugLocsMap &ExternallyUsedValues,\n                        ArrayRef<Value *> UserIgnoreLst) {\n  deleteTree();\n  UserIgnoreList = UserIgnoreLst;\n  if (!allSameType(Roots))\n    return;\n  buildTree_rec(Roots, 0, EdgeInfo());\n\n  // Collect the values that we need to extract from the tree.\n  for (auto &TEPtr : VectorizableTree) {\n    TreeEntry *Entry = TEPtr.get();\n\n    // No need to handle users of gathered values.\n    if (Entry->State == TreeEntry::NeedToGather)\n      continue;\n\n    // For each lane:\n    for (int Lane = 0, LE = Entry->Scalars.size(); Lane != LE; ++Lane) {\n      Value *Scalar = Entry->Scalars[Lane];\n      int FoundLane = Lane;\n      if (!Entry->ReuseShuffleIndices.empty()) {\n        FoundLane =\n            std::distance(Entry->ReuseShuffleIndices.begin(),\n                          llvm::find(Entry->ReuseShuffleIndices, FoundLane));\n      }\n\n      // Check if the scalar is externally used as an extra arg.\n      auto ExtI = ExternallyUsedValues.find(Scalar);\n      if (ExtI != ExternallyUsedValues.end()) {\n        LLVM_DEBUG(dbgs() << \"SLP: Need to extract: Extra arg from lane \"\n                          << Lane << \" from \" << *Scalar << \".\\n\");\n        ExternalUses.emplace_back(Scalar, nullptr, FoundLane);\n      }\n      for (User *U : Scalar->users()) {\n        LLVM_DEBUG(dbgs() << \"SLP: Checking user:\" << *U << \".\\n\");\n\n        Instruction *UserInst = dyn_cast<Instruction>(U);\n        if (!UserInst)\n          continue;\n\n        // Skip in-tree scalars that become vectors\n        if (TreeEntry *UseEntry = getTreeEntry(U)) {\n          Value *UseScalar = UseEntry->Scalars[0];\n          // Some in-tree scalars will remain as scalar in vectorized\n          // instructions. If that is the case, the one in Lane 0 will\n          // be used.\n          if (UseScalar != U ||\n              !InTreeUserNeedToExtract(Scalar, UserInst, TLI)) {\n            LLVM_DEBUG(dbgs() << \"SLP: \\tInternal user will be removed:\" << *U\n                              << \".\\n\");\n            assert(UseEntry->State != TreeEntry::NeedToGather && \"Bad state\");\n            continue;\n          }\n        }\n\n        // Ignore users in the user ignore list.\n        if (is_contained(UserIgnoreList, UserInst))\n          continue;\n\n        LLVM_DEBUG(dbgs() << \"SLP: Need to extract:\" << *U << \" from lane \"\n                          << Lane << \" from \" << *Scalar << \".\\n\");\n        ExternalUses.push_back(ExternalUser(Scalar, U, FoundLane));\n      }\n    }\n  }\n}\n\nvoid BoUpSLP::buildTree_rec(ArrayRef<Value *> VL, unsigned Depth,\n                            const EdgeInfo &UserTreeIdx) {\n  assert((allConstant(VL) || allSameType(VL)) && \"Invalid types!\");\n\n  InstructionsState S = getSameOpcode(VL);\n  if (Depth == RecursionMaxDepth) {\n    LLVM_DEBUG(dbgs() << \"SLP: Gathering due to max recursion depth.\\n\");\n    newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx);\n    return;\n  }\n\n  // Don't handle vectors.\n  if (S.OpValue->getType()->isVectorTy()) {\n    LLVM_DEBUG(dbgs() << \"SLP: Gathering due to vector type.\\n\");\n    newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx);\n    return;\n  }\n\n  if (StoreInst *SI = dyn_cast<StoreInst>(S.OpValue))\n    if (SI->getValueOperand()->getType()->isVectorTy()) {\n      LLVM_DEBUG(dbgs() << \"SLP: Gathering due to store vector type.\\n\");\n      newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx);\n      return;\n    }\n\n  // If all of the operands are identical or constant we have a simple solution.\n  if (allConstant(VL) || isSplat(VL) || !allSameBlock(VL) || !S.getOpcode()) {\n    LLVM_DEBUG(dbgs() << \"SLP: Gathering due to C,S,B,O. \\n\");\n    newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx);\n    return;\n  }\n\n  // We now know that this is a vector of instructions of the same type from\n  // the same block.\n\n  // Don't vectorize ephemeral values.\n  for (Value *V : VL) {\n    if (EphValues.count(V)) {\n      LLVM_DEBUG(dbgs() << \"SLP: The instruction (\" << *V\n                        << \") is ephemeral.\\n\");\n      newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx);\n      return;\n    }\n  }\n\n  // Check if this is a duplicate of another entry.\n  if (TreeEntry *E = getTreeEntry(S.OpValue)) {\n    LLVM_DEBUG(dbgs() << \"SLP: \\tChecking bundle: \" << *S.OpValue << \".\\n\");\n    if (!E->isSame(VL)) {\n      LLVM_DEBUG(dbgs() << \"SLP: Gathering due to partial overlap.\\n\");\n      newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx);\n      return;\n    }\n    // Record the reuse of the tree node.  FIXME, currently this is only used to\n    // properly draw the graph rather than for the actual vectorization.\n    E->UserTreeIndices.push_back(UserTreeIdx);\n    LLVM_DEBUG(dbgs() << \"SLP: Perfect diamond merge at \" << *S.OpValue\n                      << \".\\n\");\n    return;\n  }\n\n  // Check that none of the instructions in the bundle are already in the tree.\n  for (Value *V : VL) {\n    auto *I = dyn_cast<Instruction>(V);\n    if (!I)\n      continue;\n    if (getTreeEntry(I)) {\n      LLVM_DEBUG(dbgs() << \"SLP: The instruction (\" << *V\n                        << \") is already in tree.\\n\");\n      newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx);\n      return;\n    }\n  }\n\n  // If any of the scalars is marked as a value that needs to stay scalar, then\n  // we need to gather the scalars.\n  // The reduction nodes (stored in UserIgnoreList) also should stay scalar.\n  for (Value *V : VL) {\n    if (MustGather.count(V) || is_contained(UserIgnoreList, V)) {\n      LLVM_DEBUG(dbgs() << \"SLP: Gathering due to gathered scalar.\\n\");\n      newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx);\n      return;\n    }\n  }\n\n  // Check that all of the users of the scalars that we want to vectorize are\n  // schedulable.\n  auto *VL0 = cast<Instruction>(S.OpValue);\n  BasicBlock *BB = VL0->getParent();\n\n  if (!DT->isReachableFromEntry(BB)) {\n    // Don't go into unreachable blocks. They may contain instructions with\n    // dependency cycles which confuse the final scheduling.\n    LLVM_DEBUG(dbgs() << \"SLP: bundle in unreachable block.\\n\");\n    newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx);\n    return;\n  }\n\n  // Check that every instruction appears once in this bundle.\n  SmallVector<unsigned, 4> ReuseShuffleIndicies;\n  SmallVector<Value *, 4> UniqueValues;\n  DenseMap<Value *, unsigned> UniquePositions;\n  for (Value *V : VL) {\n    auto Res = UniquePositions.try_emplace(V, UniqueValues.size());\n    ReuseShuffleIndicies.emplace_back(Res.first->second);\n    if (Res.second)\n      UniqueValues.emplace_back(V);\n  }\n  size_t NumUniqueScalarValues = UniqueValues.size();\n  if (NumUniqueScalarValues == VL.size()) {\n    ReuseShuffleIndicies.clear();\n  } else {\n    LLVM_DEBUG(dbgs() << \"SLP: Shuffle for reused scalars.\\n\");\n    if (NumUniqueScalarValues <= 1 ||\n        !llvm::isPowerOf2_32(NumUniqueScalarValues)) {\n      LLVM_DEBUG(dbgs() << \"SLP: Scalar used twice in bundle.\\n\");\n      newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx);\n      return;\n    }\n    VL = UniqueValues;\n  }\n\n  auto &BSRef = BlocksSchedules[BB];\n  if (!BSRef)\n    BSRef = std::make_unique<BlockScheduling>(BB);\n\n  BlockScheduling &BS = *BSRef.get();\n\n  Optional<ScheduleData *> Bundle = BS.tryScheduleBundle(VL, this, S);\n  if (!Bundle) {\n    LLVM_DEBUG(dbgs() << \"SLP: We are not able to schedule this bundle!\\n\");\n    assert((!BS.getScheduleData(VL0) ||\n            !BS.getScheduleData(VL0)->isPartOfBundle()) &&\n           \"tryScheduleBundle should cancelScheduling on failure\");\n    newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                 ReuseShuffleIndicies);\n    return;\n  }\n  LLVM_DEBUG(dbgs() << \"SLP: We are able to schedule this bundle.\\n\");\n\n  unsigned ShuffleOrOp = S.isAltShuffle() ?\n                (unsigned) Instruction::ShuffleVector : S.getOpcode();\n  switch (ShuffleOrOp) {\n    case Instruction::PHI: {\n      auto *PH = cast<PHINode>(VL0);\n\n      // Check for terminator values (e.g. invoke).\n      for (Value *V : VL)\n        for (unsigned I = 0, E = PH->getNumIncomingValues(); I < E; ++I) {\n          Instruction *Term = dyn_cast<Instruction>(\n              cast<PHINode>(V)->getIncomingValueForBlock(\n                  PH->getIncomingBlock(I)));\n          if (Term && Term->isTerminator()) {\n            LLVM_DEBUG(dbgs()\n                       << \"SLP: Need to swizzle PHINodes (terminator use).\\n\");\n            BS.cancelScheduling(VL, VL0);\n            newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                         ReuseShuffleIndicies);\n            return;\n          }\n        }\n\n      TreeEntry *TE =\n          newTreeEntry(VL, Bundle, S, UserTreeIdx, ReuseShuffleIndicies);\n      LLVM_DEBUG(dbgs() << \"SLP: added a vector of PHINodes.\\n\");\n\n      // Keeps the reordered operands to avoid code duplication.\n      SmallVector<ValueList, 2> OperandsVec;\n      for (unsigned I = 0, E = PH->getNumIncomingValues(); I < E; ++I) {\n        ValueList Operands;\n        // Prepare the operand vector.\n        for (Value *V : VL)\n          Operands.push_back(cast<PHINode>(V)->getIncomingValueForBlock(\n              PH->getIncomingBlock(I)));\n        TE->setOperand(I, Operands);\n        OperandsVec.push_back(Operands);\n      }\n      for (unsigned OpIdx = 0, OpE = OperandsVec.size(); OpIdx != OpE; ++OpIdx)\n        buildTree_rec(OperandsVec[OpIdx], Depth + 1, {TE, OpIdx});\n      return;\n    }\n    case Instruction::ExtractValue:\n    case Instruction::ExtractElement: {\n      OrdersType CurrentOrder;\n      bool Reuse = canReuseExtract(VL, VL0, CurrentOrder);\n      if (Reuse) {\n        LLVM_DEBUG(dbgs() << \"SLP: Reusing or shuffling extract sequence.\\n\");\n        ++NumOpsWantToKeepOriginalOrder;\n        newTreeEntry(VL, Bundle /*vectorized*/, S, UserTreeIdx,\n                     ReuseShuffleIndicies);\n        // This is a special case, as it does not gather, but at the same time\n        // we are not extending buildTree_rec() towards the operands.\n        ValueList Op0;\n        Op0.assign(VL.size(), VL0->getOperand(0));\n        VectorizableTree.back()->setOperand(0, Op0);\n        return;\n      }\n      if (!CurrentOrder.empty()) {\n        LLVM_DEBUG({\n          dbgs() << \"SLP: Reusing or shuffling of reordered extract sequence \"\n                    \"with order\";\n          for (unsigned Idx : CurrentOrder)\n            dbgs() << \" \" << Idx;\n          dbgs() << \"\\n\";\n        });\n        // Insert new order with initial value 0, if it does not exist,\n        // otherwise return the iterator to the existing one.\n        newTreeEntry(VL, Bundle /*vectorized*/, S, UserTreeIdx,\n                     ReuseShuffleIndicies, CurrentOrder);\n        findRootOrder(CurrentOrder);\n        ++NumOpsWantToKeepOrder[CurrentOrder];\n        // This is a special case, as it does not gather, but at the same time\n        // we are not extending buildTree_rec() towards the operands.\n        ValueList Op0;\n        Op0.assign(VL.size(), VL0->getOperand(0));\n        VectorizableTree.back()->setOperand(0, Op0);\n        return;\n      }\n      LLVM_DEBUG(dbgs() << \"SLP: Gather extract sequence.\\n\");\n      newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                   ReuseShuffleIndicies);\n      BS.cancelScheduling(VL, VL0);\n      return;\n    }\n    case Instruction::Load: {\n      // Check that a vectorized load would load the same memory as a scalar\n      // load. For example, we don't want to vectorize loads that are smaller\n      // than 8-bit. Even though we have a packed struct {<i2, i2, i2, i2>} LLVM\n      // treats loading/storing it as an i8 struct. If we vectorize loads/stores\n      // from such a struct, we read/write packed bits disagreeing with the\n      // unvectorized version.\n      Type *ScalarTy = VL0->getType();\n\n      if (DL->getTypeSizeInBits(ScalarTy) !=\n          DL->getTypeAllocSizeInBits(ScalarTy)) {\n        BS.cancelScheduling(VL, VL0);\n        newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                     ReuseShuffleIndicies);\n        LLVM_DEBUG(dbgs() << \"SLP: Gathering loads of non-packed type.\\n\");\n        return;\n      }\n\n      // Make sure all loads in the bundle are simple - we can't vectorize\n      // atomic or volatile loads.\n      SmallVector<Value *, 4> PointerOps(VL.size());\n      auto POIter = PointerOps.begin();\n      for (Value *V : VL) {\n        auto *L = cast<LoadInst>(V);\n        if (!L->isSimple()) {\n          BS.cancelScheduling(VL, VL0);\n          newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                       ReuseShuffleIndicies);\n          LLVM_DEBUG(dbgs() << \"SLP: Gathering non-simple loads.\\n\");\n          return;\n        }\n        *POIter = L->getPointerOperand();\n        ++POIter;\n      }\n\n      OrdersType CurrentOrder;\n      // Check the order of pointer operands.\n      if (llvm::sortPtrAccesses(PointerOps, *DL, *SE, CurrentOrder)) {\n        Value *Ptr0;\n        Value *PtrN;\n        if (CurrentOrder.empty()) {\n          Ptr0 = PointerOps.front();\n          PtrN = PointerOps.back();\n        } else {\n          Ptr0 = PointerOps[CurrentOrder.front()];\n          PtrN = PointerOps[CurrentOrder.back()];\n        }\n        const SCEV *Scev0 = SE->getSCEV(Ptr0);\n        const SCEV *ScevN = SE->getSCEV(PtrN);\n        const auto *Diff =\n            dyn_cast<SCEVConstant>(SE->getMinusSCEV(ScevN, Scev0));\n        uint64_t Size = DL->getTypeAllocSize(ScalarTy);\n        // Check that the sorted loads are consecutive.\n        if (Diff && Diff->getAPInt() == (VL.size() - 1) * Size) {\n          if (CurrentOrder.empty()) {\n            // Original loads are consecutive and does not require reordering.\n            ++NumOpsWantToKeepOriginalOrder;\n            TreeEntry *TE = newTreeEntry(VL, Bundle /*vectorized*/, S,\n                                         UserTreeIdx, ReuseShuffleIndicies);\n            TE->setOperandsInOrder();\n            LLVM_DEBUG(dbgs() << \"SLP: added a vector of loads.\\n\");\n          } else {\n            // Need to reorder.\n            TreeEntry *TE =\n                newTreeEntry(VL, Bundle /*vectorized*/, S, UserTreeIdx,\n                             ReuseShuffleIndicies, CurrentOrder);\n            TE->setOperandsInOrder();\n            LLVM_DEBUG(dbgs() << \"SLP: added a vector of jumbled loads.\\n\");\n            findRootOrder(CurrentOrder);\n            ++NumOpsWantToKeepOrder[CurrentOrder];\n          }\n          return;\n        }\n        // Vectorizing non-consecutive loads with `llvm.masked.gather`.\n        TreeEntry *TE = newTreeEntry(VL, TreeEntry::ScatterVectorize, Bundle, S,\n                                     UserTreeIdx, ReuseShuffleIndicies);\n        TE->setOperandsInOrder();\n        buildTree_rec(PointerOps, Depth + 1, {TE, 0});\n        LLVM_DEBUG(dbgs() << \"SLP: added a vector of non-consecutive loads.\\n\");\n        return;\n      }\n\n      LLVM_DEBUG(dbgs() << \"SLP: Gathering non-consecutive loads.\\n\");\n      BS.cancelScheduling(VL, VL0);\n      newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                   ReuseShuffleIndicies);\n      return;\n    }\n    case Instruction::ZExt:\n    case Instruction::SExt:\n    case Instruction::FPToUI:\n    case Instruction::FPToSI:\n    case Instruction::FPExt:\n    case Instruction::PtrToInt:\n    case Instruction::IntToPtr:\n    case Instruction::SIToFP:\n    case Instruction::UIToFP:\n    case Instruction::Trunc:\n    case Instruction::FPTrunc:\n    case Instruction::BitCast: {\n      Type *SrcTy = VL0->getOperand(0)->getType();\n      for (Value *V : VL) {\n        Type *Ty = cast<Instruction>(V)->getOperand(0)->getType();\n        if (Ty != SrcTy || !isValidElementType(Ty)) {\n          BS.cancelScheduling(VL, VL0);\n          newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                       ReuseShuffleIndicies);\n          LLVM_DEBUG(dbgs()\n                     << \"SLP: Gathering casts with different src types.\\n\");\n          return;\n        }\n      }\n      TreeEntry *TE = newTreeEntry(VL, Bundle /*vectorized*/, S, UserTreeIdx,\n                                   ReuseShuffleIndicies);\n      LLVM_DEBUG(dbgs() << \"SLP: added a vector of casts.\\n\");\n\n      TE->setOperandsInOrder();\n      for (unsigned i = 0, e = VL0->getNumOperands(); i < e; ++i) {\n        ValueList Operands;\n        // Prepare the operand vector.\n        for (Value *V : VL)\n          Operands.push_back(cast<Instruction>(V)->getOperand(i));\n\n        buildTree_rec(Operands, Depth + 1, {TE, i});\n      }\n      return;\n    }\n    case Instruction::ICmp:\n    case Instruction::FCmp: {\n      // Check that all of the compares have the same predicate.\n      CmpInst::Predicate P0 = cast<CmpInst>(VL0)->getPredicate();\n      CmpInst::Predicate SwapP0 = CmpInst::getSwappedPredicate(P0);\n      Type *ComparedTy = VL0->getOperand(0)->getType();\n      for (Value *V : VL) {\n        CmpInst *Cmp = cast<CmpInst>(V);\n        if ((Cmp->getPredicate() != P0 && Cmp->getPredicate() != SwapP0) ||\n            Cmp->getOperand(0)->getType() != ComparedTy) {\n          BS.cancelScheduling(VL, VL0);\n          newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                       ReuseShuffleIndicies);\n          LLVM_DEBUG(dbgs()\n                     << \"SLP: Gathering cmp with different predicate.\\n\");\n          return;\n        }\n      }\n\n      TreeEntry *TE = newTreeEntry(VL, Bundle /*vectorized*/, S, UserTreeIdx,\n                                   ReuseShuffleIndicies);\n      LLVM_DEBUG(dbgs() << \"SLP: added a vector of compares.\\n\");\n\n      ValueList Left, Right;\n      if (cast<CmpInst>(VL0)->isCommutative()) {\n        // Commutative predicate - collect + sort operands of the instructions\n        // so that each side is more likely to have the same opcode.\n        assert(P0 == SwapP0 && \"Commutative Predicate mismatch\");\n        reorderInputsAccordingToOpcode(VL, Left, Right, *DL, *SE, *this);\n      } else {\n        // Collect operands - commute if it uses the swapped predicate.\n        for (Value *V : VL) {\n          auto *Cmp = cast<CmpInst>(V);\n          Value *LHS = Cmp->getOperand(0);\n          Value *RHS = Cmp->getOperand(1);\n          if (Cmp->getPredicate() != P0)\n            std::swap(LHS, RHS);\n          Left.push_back(LHS);\n          Right.push_back(RHS);\n        }\n      }\n      TE->setOperand(0, Left);\n      TE->setOperand(1, Right);\n      buildTree_rec(Left, Depth + 1, {TE, 0});\n      buildTree_rec(Right, Depth + 1, {TE, 1});\n      return;\n    }\n    case Instruction::Select:\n    case Instruction::FNeg:\n    case Instruction::Add:\n    case Instruction::FAdd:\n    case Instruction::Sub:\n    case Instruction::FSub:\n    case Instruction::Mul:\n    case Instruction::FMul:\n    case Instruction::UDiv:\n    case Instruction::SDiv:\n    case Instruction::FDiv:\n    case Instruction::URem:\n    case Instruction::SRem:\n    case Instruction::FRem:\n    case Instruction::Shl:\n    case Instruction::LShr:\n    case Instruction::AShr:\n    case Instruction::And:\n    case Instruction::Or:\n    case Instruction::Xor: {\n      TreeEntry *TE = newTreeEntry(VL, Bundle /*vectorized*/, S, UserTreeIdx,\n                                   ReuseShuffleIndicies);\n      LLVM_DEBUG(dbgs() << \"SLP: added a vector of un/bin op.\\n\");\n\n      // Sort operands of the instructions so that each side is more likely to\n      // have the same opcode.\n      if (isa<BinaryOperator>(VL0) && VL0->isCommutative()) {\n        ValueList Left, Right;\n        reorderInputsAccordingToOpcode(VL, Left, Right, *DL, *SE, *this);\n        TE->setOperand(0, Left);\n        TE->setOperand(1, Right);\n        buildTree_rec(Left, Depth + 1, {TE, 0});\n        buildTree_rec(Right, Depth + 1, {TE, 1});\n        return;\n      }\n\n      TE->setOperandsInOrder();\n      for (unsigned i = 0, e = VL0->getNumOperands(); i < e; ++i) {\n        ValueList Operands;\n        // Prepare the operand vector.\n        for (Value *V : VL)\n          Operands.push_back(cast<Instruction>(V)->getOperand(i));\n\n        buildTree_rec(Operands, Depth + 1, {TE, i});\n      }\n      return;\n    }\n    case Instruction::GetElementPtr: {\n      // We don't combine GEPs with complicated (nested) indexing.\n      for (Value *V : VL) {\n        if (cast<Instruction>(V)->getNumOperands() != 2) {\n          LLVM_DEBUG(dbgs() << \"SLP: not-vectorizable GEP (nested indexes).\\n\");\n          BS.cancelScheduling(VL, VL0);\n          newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                       ReuseShuffleIndicies);\n          return;\n        }\n      }\n\n      // We can't combine several GEPs into one vector if they operate on\n      // different types.\n      Type *Ty0 = VL0->getOperand(0)->getType();\n      for (Value *V : VL) {\n        Type *CurTy = cast<Instruction>(V)->getOperand(0)->getType();\n        if (Ty0 != CurTy) {\n          LLVM_DEBUG(dbgs()\n                     << \"SLP: not-vectorizable GEP (different types).\\n\");\n          BS.cancelScheduling(VL, VL0);\n          newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                       ReuseShuffleIndicies);\n          return;\n        }\n      }\n\n      // We don't combine GEPs with non-constant indexes.\n      Type *Ty1 = VL0->getOperand(1)->getType();\n      for (Value *V : VL) {\n        auto Op = cast<Instruction>(V)->getOperand(1);\n        if (!isa<ConstantInt>(Op) ||\n            (Op->getType() != Ty1 &&\n             Op->getType()->getScalarSizeInBits() >\n                 DL->getIndexSizeInBits(\n                     V->getType()->getPointerAddressSpace()))) {\n          LLVM_DEBUG(dbgs()\n                     << \"SLP: not-vectorizable GEP (non-constant indexes).\\n\");\n          BS.cancelScheduling(VL, VL0);\n          newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                       ReuseShuffleIndicies);\n          return;\n        }\n      }\n\n      TreeEntry *TE = newTreeEntry(VL, Bundle /*vectorized*/, S, UserTreeIdx,\n                                   ReuseShuffleIndicies);\n      LLVM_DEBUG(dbgs() << \"SLP: added a vector of GEPs.\\n\");\n      TE->setOperandsInOrder();\n      for (unsigned i = 0, e = 2; i < e; ++i) {\n        ValueList Operands;\n        // Prepare the operand vector.\n        for (Value *V : VL)\n          Operands.push_back(cast<Instruction>(V)->getOperand(i));\n\n        buildTree_rec(Operands, Depth + 1, {TE, i});\n      }\n      return;\n    }\n    case Instruction::Store: {\n      // Check if the stores are consecutive or if we need to swizzle them.\n      llvm::Type *ScalarTy = cast<StoreInst>(VL0)->getValueOperand()->getType();\n      // Avoid types that are padded when being allocated as scalars, while\n      // being packed together in a vector (such as i1).\n      if (DL->getTypeSizeInBits(ScalarTy) !=\n          DL->getTypeAllocSizeInBits(ScalarTy)) {\n        BS.cancelScheduling(VL, VL0);\n        newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                     ReuseShuffleIndicies);\n        LLVM_DEBUG(dbgs() << \"SLP: Gathering stores of non-packed type.\\n\");\n        return;\n      }\n      // Make sure all stores in the bundle are simple - we can't vectorize\n      // atomic or volatile stores.\n      SmallVector<Value *, 4> PointerOps(VL.size());\n      ValueList Operands(VL.size());\n      auto POIter = PointerOps.begin();\n      auto OIter = Operands.begin();\n      for (Value *V : VL) {\n        auto *SI = cast<StoreInst>(V);\n        if (!SI->isSimple()) {\n          BS.cancelScheduling(VL, VL0);\n          newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                       ReuseShuffleIndicies);\n          LLVM_DEBUG(dbgs() << \"SLP: Gathering non-simple stores.\\n\");\n          return;\n        }\n        *POIter = SI->getPointerOperand();\n        *OIter = SI->getValueOperand();\n        ++POIter;\n        ++OIter;\n      }\n\n      OrdersType CurrentOrder;\n      // Check the order of pointer operands.\n      if (llvm::sortPtrAccesses(PointerOps, *DL, *SE, CurrentOrder)) {\n        Value *Ptr0;\n        Value *PtrN;\n        if (CurrentOrder.empty()) {\n          Ptr0 = PointerOps.front();\n          PtrN = PointerOps.back();\n        } else {\n          Ptr0 = PointerOps[CurrentOrder.front()];\n          PtrN = PointerOps[CurrentOrder.back()];\n        }\n        const SCEV *Scev0 = SE->getSCEV(Ptr0);\n        const SCEV *ScevN = SE->getSCEV(PtrN);\n        const auto *Diff =\n            dyn_cast<SCEVConstant>(SE->getMinusSCEV(ScevN, Scev0));\n        uint64_t Size = DL->getTypeAllocSize(ScalarTy);\n        // Check that the sorted pointer operands are consecutive.\n        if (Diff && Diff->getAPInt() == (VL.size() - 1) * Size) {\n          if (CurrentOrder.empty()) {\n            // Original stores are consecutive and does not require reordering.\n            ++NumOpsWantToKeepOriginalOrder;\n            TreeEntry *TE = newTreeEntry(VL, Bundle /*vectorized*/, S,\n                                         UserTreeIdx, ReuseShuffleIndicies);\n            TE->setOperandsInOrder();\n            buildTree_rec(Operands, Depth + 1, {TE, 0});\n            LLVM_DEBUG(dbgs() << \"SLP: added a vector of stores.\\n\");\n          } else {\n            TreeEntry *TE =\n                newTreeEntry(VL, Bundle /*vectorized*/, S, UserTreeIdx,\n                             ReuseShuffleIndicies, CurrentOrder);\n            TE->setOperandsInOrder();\n            buildTree_rec(Operands, Depth + 1, {TE, 0});\n            LLVM_DEBUG(dbgs() << \"SLP: added a vector of jumbled stores.\\n\");\n            findRootOrder(CurrentOrder);\n            ++NumOpsWantToKeepOrder[CurrentOrder];\n          }\n          return;\n        }\n      }\n\n      BS.cancelScheduling(VL, VL0);\n      newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                   ReuseShuffleIndicies);\n      LLVM_DEBUG(dbgs() << \"SLP: Non-consecutive store.\\n\");\n      return;\n    }\n    case Instruction::Call: {\n      // Check if the calls are all to the same vectorizable intrinsic or\n      // library function.\n      CallInst *CI = cast<CallInst>(VL0);\n      Intrinsic::ID ID = getVectorIntrinsicIDForCall(CI, TLI);\n\n      VFShape Shape = VFShape::get(\n          *CI, ElementCount::getFixed(static_cast<unsigned int>(VL.size())),\n          false /*HasGlobalPred*/);\n      Function *VecFunc = VFDatabase(*CI).getVectorizedFunction(Shape);\n\n      if (!VecFunc && !isTriviallyVectorizable(ID)) {\n        BS.cancelScheduling(VL, VL0);\n        newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                     ReuseShuffleIndicies);\n        LLVM_DEBUG(dbgs() << \"SLP: Non-vectorizable call.\\n\");\n        return;\n      }\n      Function *F = CI->getCalledFunction();\n      unsigned NumArgs = CI->getNumArgOperands();\n      SmallVector<Value*, 4> ScalarArgs(NumArgs, nullptr);\n      for (unsigned j = 0; j != NumArgs; ++j)\n        if (hasVectorInstrinsicScalarOpd(ID, j))\n          ScalarArgs[j] = CI->getArgOperand(j);\n      for (Value *V : VL) {\n        CallInst *CI2 = dyn_cast<CallInst>(V);\n        if (!CI2 || CI2->getCalledFunction() != F ||\n            getVectorIntrinsicIDForCall(CI2, TLI) != ID ||\n            (VecFunc &&\n             VecFunc != VFDatabase(*CI2).getVectorizedFunction(Shape)) ||\n            !CI->hasIdenticalOperandBundleSchema(*CI2)) {\n          BS.cancelScheduling(VL, VL0);\n          newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                       ReuseShuffleIndicies);\n          LLVM_DEBUG(dbgs() << \"SLP: mismatched calls:\" << *CI << \"!=\" << *V\n                            << \"\\n\");\n          return;\n        }\n        // Some intrinsics have scalar arguments and should be same in order for\n        // them to be vectorized.\n        for (unsigned j = 0; j != NumArgs; ++j) {\n          if (hasVectorInstrinsicScalarOpd(ID, j)) {\n            Value *A1J = CI2->getArgOperand(j);\n            if (ScalarArgs[j] != A1J) {\n              BS.cancelScheduling(VL, VL0);\n              newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                           ReuseShuffleIndicies);\n              LLVM_DEBUG(dbgs() << \"SLP: mismatched arguments in call:\" << *CI\n                                << \" argument \" << ScalarArgs[j] << \"!=\" << A1J\n                                << \"\\n\");\n              return;\n            }\n          }\n        }\n        // Verify that the bundle operands are identical between the two calls.\n        if (CI->hasOperandBundles() &&\n            !std::equal(CI->op_begin() + CI->getBundleOperandsStartIndex(),\n                        CI->op_begin() + CI->getBundleOperandsEndIndex(),\n                        CI2->op_begin() + CI2->getBundleOperandsStartIndex())) {\n          BS.cancelScheduling(VL, VL0);\n          newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                       ReuseShuffleIndicies);\n          LLVM_DEBUG(dbgs() << \"SLP: mismatched bundle operands in calls:\"\n                            << *CI << \"!=\" << *V << '\\n');\n          return;\n        }\n      }\n\n      TreeEntry *TE = newTreeEntry(VL, Bundle /*vectorized*/, S, UserTreeIdx,\n                                   ReuseShuffleIndicies);\n      TE->setOperandsInOrder();\n      for (unsigned i = 0, e = CI->getNumArgOperands(); i != e; ++i) {\n        ValueList Operands;\n        // Prepare the operand vector.\n        for (Value *V : VL) {\n          auto *CI2 = cast<CallInst>(V);\n          Operands.push_back(CI2->getArgOperand(i));\n        }\n        buildTree_rec(Operands, Depth + 1, {TE, i});\n      }\n      return;\n    }\n    case Instruction::ShuffleVector: {\n      // If this is not an alternate sequence of opcode like add-sub\n      // then do not vectorize this instruction.\n      if (!S.isAltShuffle()) {\n        BS.cancelScheduling(VL, VL0);\n        newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                     ReuseShuffleIndicies);\n        LLVM_DEBUG(dbgs() << \"SLP: ShuffleVector are not vectorized.\\n\");\n        return;\n      }\n      TreeEntry *TE = newTreeEntry(VL, Bundle /*vectorized*/, S, UserTreeIdx,\n                                   ReuseShuffleIndicies);\n      LLVM_DEBUG(dbgs() << \"SLP: added a ShuffleVector op.\\n\");\n\n      // Reorder operands if reordering would enable vectorization.\n      if (isa<BinaryOperator>(VL0)) {\n        ValueList Left, Right;\n        reorderInputsAccordingToOpcode(VL, Left, Right, *DL, *SE, *this);\n        TE->setOperand(0, Left);\n        TE->setOperand(1, Right);\n        buildTree_rec(Left, Depth + 1, {TE, 0});\n        buildTree_rec(Right, Depth + 1, {TE, 1});\n        return;\n      }\n\n      TE->setOperandsInOrder();\n      for (unsigned i = 0, e = VL0->getNumOperands(); i < e; ++i) {\n        ValueList Operands;\n        // Prepare the operand vector.\n        for (Value *V : VL)\n          Operands.push_back(cast<Instruction>(V)->getOperand(i));\n\n        buildTree_rec(Operands, Depth + 1, {TE, i});\n      }\n      return;\n    }\n    default:\n      BS.cancelScheduling(VL, VL0);\n      newTreeEntry(VL, None /*not vectorized*/, S, UserTreeIdx,\n                   ReuseShuffleIndicies);\n      LLVM_DEBUG(dbgs() << \"SLP: Gathering unknown instruction.\\n\");\n      return;\n  }\n}\n\nunsigned BoUpSLP::canMapToVector(Type *T, const DataLayout &DL) const {\n  unsigned N = 1;\n  Type *EltTy = T;\n\n  while (isa<StructType>(EltTy) || isa<ArrayType>(EltTy) ||\n         isa<VectorType>(EltTy)) {\n    if (auto *ST = dyn_cast<StructType>(EltTy)) {\n      // Check that struct is homogeneous.\n      for (const auto *Ty : ST->elements())\n        if (Ty != *ST->element_begin())\n          return 0;\n      N *= ST->getNumElements();\n      EltTy = *ST->element_begin();\n    } else if (auto *AT = dyn_cast<ArrayType>(EltTy)) {\n      N *= AT->getNumElements();\n      EltTy = AT->getElementType();\n    } else {\n      auto *VT = cast<FixedVectorType>(EltTy);\n      N *= VT->getNumElements();\n      EltTy = VT->getElementType();\n    }\n  }\n\n  if (!isValidElementType(EltTy))\n    return 0;\n  uint64_t VTSize = DL.getTypeStoreSizeInBits(FixedVectorType::get(EltTy, N));\n  if (VTSize < MinVecRegSize || VTSize > MaxVecRegSize || VTSize != DL.getTypeStoreSizeInBits(T))\n    return 0;\n  return N;\n}\n\nbool BoUpSLP::canReuseExtract(ArrayRef<Value *> VL, Value *OpValue,\n                              SmallVectorImpl<unsigned> &CurrentOrder) const {\n  Instruction *E0 = cast<Instruction>(OpValue);\n  assert(E0->getOpcode() == Instruction::ExtractElement ||\n         E0->getOpcode() == Instruction::ExtractValue);\n  assert(E0->getOpcode() == getSameOpcode(VL).getOpcode() && \"Invalid opcode\");\n  // Check if all of the extracts come from the same vector and from the\n  // correct offset.\n  Value *Vec = E0->getOperand(0);\n\n  CurrentOrder.clear();\n\n  // We have to extract from a vector/aggregate with the same number of elements.\n  unsigned NElts;\n  if (E0->getOpcode() == Instruction::ExtractValue) {\n    const DataLayout &DL = E0->getModule()->getDataLayout();\n    NElts = canMapToVector(Vec->getType(), DL);\n    if (!NElts)\n      return false;\n    // Check if load can be rewritten as load of vector.\n    LoadInst *LI = dyn_cast<LoadInst>(Vec);\n    if (!LI || !LI->isSimple() || !LI->hasNUses(VL.size()))\n      return false;\n  } else {\n    NElts = cast<FixedVectorType>(Vec->getType())->getNumElements();\n  }\n\n  if (NElts != VL.size())\n    return false;\n\n  // Check that all of the indices extract from the correct offset.\n  bool ShouldKeepOrder = true;\n  unsigned E = VL.size();\n  // Assign to all items the initial value E + 1 so we can check if the extract\n  // instruction index was used already.\n  // Also, later we can check that all the indices are used and we have a\n  // consecutive access in the extract instructions, by checking that no\n  // element of CurrentOrder still has value E + 1.\n  CurrentOrder.assign(E, E + 1);\n  unsigned I = 0;\n  for (; I < E; ++I) {\n    auto *Inst = cast<Instruction>(VL[I]);\n    if (Inst->getOperand(0) != Vec)\n      break;\n    Optional<unsigned> Idx = getExtractIndex(Inst);\n    if (!Idx)\n      break;\n    const unsigned ExtIdx = *Idx;\n    if (ExtIdx != I) {\n      if (ExtIdx >= E || CurrentOrder[ExtIdx] != E + 1)\n        break;\n      ShouldKeepOrder = false;\n      CurrentOrder[ExtIdx] = I;\n    } else {\n      if (CurrentOrder[I] != E + 1)\n        break;\n      CurrentOrder[I] = I;\n    }\n  }\n  if (I < E) {\n    CurrentOrder.clear();\n    return false;\n  }\n\n  return ShouldKeepOrder;\n}\n\nbool BoUpSLP::areAllUsersVectorized(Instruction *I) const {\n  return I->hasOneUse() || llvm::all_of(I->users(), [this](User *U) {\n           return ScalarToTreeEntry.count(U) > 0;\n         });\n}\n\nstatic std::pair<InstructionCost, InstructionCost>\ngetVectorCallCosts(CallInst *CI, FixedVectorType *VecTy,\n                   TargetTransformInfo *TTI, TargetLibraryInfo *TLI) {\n  Intrinsic::ID ID = getVectorIntrinsicIDForCall(CI, TLI);\n\n  // Calculate the cost of the scalar and vector calls.\n  SmallVector<Type *, 4> VecTys;\n  for (Use &Arg : CI->args())\n    VecTys.push_back(\n        FixedVectorType::get(Arg->getType(), VecTy->getNumElements()));\n  FastMathFlags FMF;\n  if (auto *FPCI = dyn_cast<FPMathOperator>(CI))\n    FMF = FPCI->getFastMathFlags();\n  SmallVector<const Value *> Arguments(CI->arg_begin(), CI->arg_end());\n  IntrinsicCostAttributes CostAttrs(ID, VecTy, Arguments, VecTys, FMF,\n                                    dyn_cast<IntrinsicInst>(CI));\n  auto IntrinsicCost =\n    TTI->getIntrinsicInstrCost(CostAttrs, TTI::TCK_RecipThroughput);\n\n  auto Shape = VFShape::get(*CI, ElementCount::getFixed(static_cast<unsigned>(\n                                     VecTy->getNumElements())),\n                            false /*HasGlobalPred*/);\n  Function *VecFunc = VFDatabase(*CI).getVectorizedFunction(Shape);\n  auto LibCost = IntrinsicCost;\n  if (!CI->isNoBuiltin() && VecFunc) {\n    // Calculate the cost of the vector library call.\n    // If the corresponding vector call is cheaper, return its cost.\n    LibCost = TTI->getCallInstrCost(nullptr, VecTy, VecTys,\n                                    TTI::TCK_RecipThroughput);\n  }\n  return {IntrinsicCost, LibCost};\n}\n\nInstructionCost BoUpSLP::getEntryCost(TreeEntry *E) {\n  ArrayRef<Value*> VL = E->Scalars;\n\n  Type *ScalarTy = VL[0]->getType();\n  if (StoreInst *SI = dyn_cast<StoreInst>(VL[0]))\n    ScalarTy = SI->getValueOperand()->getType();\n  else if (CmpInst *CI = dyn_cast<CmpInst>(VL[0]))\n    ScalarTy = CI->getOperand(0)->getType();\n  auto *VecTy = FixedVectorType::get(ScalarTy, VL.size());\n  TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput;\n\n  // If we have computed a smaller type for the expression, update VecTy so\n  // that the costs will be accurate.\n  if (MinBWs.count(VL[0]))\n    VecTy = FixedVectorType::get(\n        IntegerType::get(F->getContext(), MinBWs[VL[0]].first), VL.size());\n\n  unsigned ReuseShuffleNumbers = E->ReuseShuffleIndices.size();\n  bool NeedToShuffleReuses = !E->ReuseShuffleIndices.empty();\n  InstructionCost ReuseShuffleCost = 0;\n  if (NeedToShuffleReuses) {\n    ReuseShuffleCost =\n        TTI->getShuffleCost(TargetTransformInfo::SK_PermuteSingleSrc, VecTy);\n  }\n  if (E->State == TreeEntry::NeedToGather) {\n    if (allConstant(VL))\n      return 0;\n    if (isSplat(VL)) {\n      return ReuseShuffleCost +\n             TTI->getShuffleCost(TargetTransformInfo::SK_Broadcast, VecTy, 0);\n    }\n    if (E->getOpcode() == Instruction::ExtractElement &&\n        allSameType(VL) && allSameBlock(VL)) {\n      Optional<TargetTransformInfo::ShuffleKind> ShuffleKind = isShuffle(VL);\n      if (ShuffleKind.hasValue()) {\n        InstructionCost Cost =\n            TTI->getShuffleCost(ShuffleKind.getValue(), VecTy);\n        for (auto *V : VL) {\n          // If all users of instruction are going to be vectorized and this\n          // instruction itself is not going to be vectorized, consider this\n          // instruction as dead and remove its cost from the final cost of the\n          // vectorized tree.\n          if (areAllUsersVectorized(cast<Instruction>(V)) &&\n              !ScalarToTreeEntry.count(V)) {\n            auto *IO = cast<ConstantInt>(\n                cast<ExtractElementInst>(V)->getIndexOperand());\n            Cost -= TTI->getVectorInstrCost(Instruction::ExtractElement, VecTy,\n                                            IO->getZExtValue());\n          }\n        }\n        return ReuseShuffleCost + Cost;\n      }\n    }\n    return ReuseShuffleCost + getGatherCost(VL);\n  }\n  assert((E->State == TreeEntry::Vectorize ||\n          E->State == TreeEntry::ScatterVectorize) &&\n         \"Unhandled state\");\n  assert(E->getOpcode() && allSameType(VL) && allSameBlock(VL) && \"Invalid VL\");\n  Instruction *VL0 = E->getMainOp();\n  unsigned ShuffleOrOp =\n      E->isAltShuffle() ? (unsigned)Instruction::ShuffleVector : E->getOpcode();\n  switch (ShuffleOrOp) {\n    case Instruction::PHI:\n      return 0;\n\n    case Instruction::ExtractValue:\n    case Instruction::ExtractElement: {\n      if (NeedToShuffleReuses) {\n        unsigned Idx = 0;\n        for (unsigned I : E->ReuseShuffleIndices) {\n          if (ShuffleOrOp == Instruction::ExtractElement) {\n            auto *IO = cast<ConstantInt>(\n                cast<ExtractElementInst>(VL[I])->getIndexOperand());\n            Idx = IO->getZExtValue();\n            ReuseShuffleCost -= TTI->getVectorInstrCost(\n                Instruction::ExtractElement, VecTy, Idx);\n          } else {\n            ReuseShuffleCost -= TTI->getVectorInstrCost(\n                Instruction::ExtractElement, VecTy, Idx);\n            ++Idx;\n          }\n        }\n        Idx = ReuseShuffleNumbers;\n        for (Value *V : VL) {\n          if (ShuffleOrOp == Instruction::ExtractElement) {\n            auto *IO = cast<ConstantInt>(\n                cast<ExtractElementInst>(V)->getIndexOperand());\n            Idx = IO->getZExtValue();\n          } else {\n            --Idx;\n          }\n          ReuseShuffleCost +=\n              TTI->getVectorInstrCost(Instruction::ExtractElement, VecTy, Idx);\n        }\n      }\n      InstructionCost DeadCost = ReuseShuffleCost;\n      if (!E->ReorderIndices.empty()) {\n        // TODO: Merge this shuffle with the ReuseShuffleCost.\n        DeadCost += TTI->getShuffleCost(\n            TargetTransformInfo::SK_PermuteSingleSrc, VecTy);\n      }\n      for (unsigned I = 0, E = VL.size(); I < E; ++I) {\n        Instruction *EI = cast<Instruction>(VL[I]);\n        // If all users are going to be vectorized, instruction can be\n        // considered as dead.\n        // The same, if have only one user, it will be vectorized for sure.\n        if (areAllUsersVectorized(EI)) {\n          // Take credit for instruction that will become dead.\n          if (EI->hasOneUse()) {\n            Instruction *Ext = EI->user_back();\n            if ((isa<SExtInst>(Ext) || isa<ZExtInst>(Ext)) &&\n                all_of(Ext->users(),\n                       [](User *U) { return isa<GetElementPtrInst>(U); })) {\n              // Use getExtractWithExtendCost() to calculate the cost of\n              // extractelement/ext pair.\n              DeadCost -= TTI->getExtractWithExtendCost(\n                  Ext->getOpcode(), Ext->getType(), VecTy, I);\n              // Add back the cost of s|zext which is subtracted separately.\n              DeadCost += TTI->getCastInstrCost(\n                  Ext->getOpcode(), Ext->getType(), EI->getType(),\n                  TTI::getCastContextHint(Ext), CostKind, Ext);\n              continue;\n            }\n          }\n          DeadCost -=\n              TTI->getVectorInstrCost(Instruction::ExtractElement, VecTy, I);\n        }\n      }\n      return DeadCost;\n    }\n    case Instruction::ZExt:\n    case Instruction::SExt:\n    case Instruction::FPToUI:\n    case Instruction::FPToSI:\n    case Instruction::FPExt:\n    case Instruction::PtrToInt:\n    case Instruction::IntToPtr:\n    case Instruction::SIToFP:\n    case Instruction::UIToFP:\n    case Instruction::Trunc:\n    case Instruction::FPTrunc:\n    case Instruction::BitCast: {\n      Type *SrcTy = VL0->getOperand(0)->getType();\n      InstructionCost ScalarEltCost =\n          TTI->getCastInstrCost(E->getOpcode(), ScalarTy, SrcTy,\n                                TTI::getCastContextHint(VL0), CostKind, VL0);\n      if (NeedToShuffleReuses) {\n        ReuseShuffleCost -= (ReuseShuffleNumbers - VL.size()) * ScalarEltCost;\n      }\n\n      // Calculate the cost of this instruction.\n      InstructionCost ScalarCost = VL.size() * ScalarEltCost;\n\n      auto *SrcVecTy = FixedVectorType::get(SrcTy, VL.size());\n      InstructionCost VecCost = 0;\n      // Check if the values are candidates to demote.\n      if (!MinBWs.count(VL0) || VecTy != SrcVecTy) {\n        VecCost =\n            ReuseShuffleCost +\n            TTI->getCastInstrCost(E->getOpcode(), VecTy, SrcVecTy,\n                                  TTI::getCastContextHint(VL0), CostKind, VL0);\n      }\n      LLVM_DEBUG(dumpTreeCosts(E, ReuseShuffleCost, VecCost, ScalarCost));\n      return VecCost - ScalarCost;\n    }\n    case Instruction::FCmp:\n    case Instruction::ICmp:\n    case Instruction::Select: {\n      // Calculate the cost of this instruction.\n      InstructionCost ScalarEltCost =\n          TTI->getCmpSelInstrCost(E->getOpcode(), ScalarTy, Builder.getInt1Ty(),\n                                  CmpInst::BAD_ICMP_PREDICATE, CostKind, VL0);\n      if (NeedToShuffleReuses) {\n        ReuseShuffleCost -= (ReuseShuffleNumbers - VL.size()) * ScalarEltCost;\n      }\n      auto *MaskTy = FixedVectorType::get(Builder.getInt1Ty(), VL.size());\n      InstructionCost ScalarCost = VecTy->getNumElements() * ScalarEltCost;\n\n      // Check if all entries in VL are either compares or selects with compares\n      // as condition that have the same predicates.\n      CmpInst::Predicate VecPred = CmpInst::BAD_ICMP_PREDICATE;\n      bool First = true;\n      for (auto *V : VL) {\n        CmpInst::Predicate CurrentPred;\n        auto MatchCmp = m_Cmp(CurrentPred, m_Value(), m_Value());\n        if ((!match(V, m_Select(MatchCmp, m_Value(), m_Value())) &&\n             !match(V, MatchCmp)) ||\n            (!First && VecPred != CurrentPred)) {\n          VecPred = CmpInst::BAD_ICMP_PREDICATE;\n          break;\n        }\n        First = false;\n        VecPred = CurrentPred;\n      }\n\n      InstructionCost VecCost = TTI->getCmpSelInstrCost(\n          E->getOpcode(), VecTy, MaskTy, VecPred, CostKind, VL0);\n      // Check if it is possible and profitable to use min/max for selects in\n      // VL.\n      //\n      auto IntrinsicAndUse = canConvertToMinOrMaxIntrinsic(VL);\n      if (IntrinsicAndUse.first != Intrinsic::not_intrinsic) {\n        IntrinsicCostAttributes CostAttrs(IntrinsicAndUse.first, VecTy,\n                                          {VecTy, VecTy});\n        InstructionCost IntrinsicCost =\n            TTI->getIntrinsicInstrCost(CostAttrs, CostKind);\n        // If the selects are the only uses of the compares, they will be dead\n        // and we can adjust the cost by removing their cost.\n        if (IntrinsicAndUse.second)\n          IntrinsicCost -=\n              TTI->getCmpSelInstrCost(Instruction::ICmp, VecTy, MaskTy,\n                                      CmpInst::BAD_ICMP_PREDICATE, CostKind);\n        VecCost = std::min(VecCost, IntrinsicCost);\n      }\n      LLVM_DEBUG(dumpTreeCosts(E, ReuseShuffleCost, VecCost, ScalarCost));\n      return ReuseShuffleCost + VecCost - ScalarCost;\n    }\n    case Instruction::FNeg:\n    case Instruction::Add:\n    case Instruction::FAdd:\n    case Instruction::Sub:\n    case Instruction::FSub:\n    case Instruction::Mul:\n    case Instruction::FMul:\n    case Instruction::UDiv:\n    case Instruction::SDiv:\n    case Instruction::FDiv:\n    case Instruction::URem:\n    case Instruction::SRem:\n    case Instruction::FRem:\n    case Instruction::Shl:\n    case Instruction::LShr:\n    case Instruction::AShr:\n    case Instruction::And:\n    case Instruction::Or:\n    case Instruction::Xor: {\n      // Certain instructions can be cheaper to vectorize if they have a\n      // constant second vector operand.\n      TargetTransformInfo::OperandValueKind Op1VK =\n          TargetTransformInfo::OK_AnyValue;\n      TargetTransformInfo::OperandValueKind Op2VK =\n          TargetTransformInfo::OK_UniformConstantValue;\n      TargetTransformInfo::OperandValueProperties Op1VP =\n          TargetTransformInfo::OP_None;\n      TargetTransformInfo::OperandValueProperties Op2VP =\n          TargetTransformInfo::OP_PowerOf2;\n\n      // If all operands are exactly the same ConstantInt then set the\n      // operand kind to OK_UniformConstantValue.\n      // If instead not all operands are constants, then set the operand kind\n      // to OK_AnyValue. If all operands are constants but not the same,\n      // then set the operand kind to OK_NonUniformConstantValue.\n      ConstantInt *CInt0 = nullptr;\n      for (unsigned i = 0, e = VL.size(); i < e; ++i) {\n        const Instruction *I = cast<Instruction>(VL[i]);\n        unsigned OpIdx = isa<BinaryOperator>(I) ? 1 : 0;\n        ConstantInt *CInt = dyn_cast<ConstantInt>(I->getOperand(OpIdx));\n        if (!CInt) {\n          Op2VK = TargetTransformInfo::OK_AnyValue;\n          Op2VP = TargetTransformInfo::OP_None;\n          break;\n        }\n        if (Op2VP == TargetTransformInfo::OP_PowerOf2 &&\n            !CInt->getValue().isPowerOf2())\n          Op2VP = TargetTransformInfo::OP_None;\n        if (i == 0) {\n          CInt0 = CInt;\n          continue;\n        }\n        if (CInt0 != CInt)\n          Op2VK = TargetTransformInfo::OK_NonUniformConstantValue;\n      }\n\n      SmallVector<const Value *, 4> Operands(VL0->operand_values());\n      InstructionCost ScalarEltCost =\n          TTI->getArithmeticInstrCost(E->getOpcode(), ScalarTy, CostKind, Op1VK,\n                                      Op2VK, Op1VP, Op2VP, Operands, VL0);\n      if (NeedToShuffleReuses) {\n        ReuseShuffleCost -= (ReuseShuffleNumbers - VL.size()) * ScalarEltCost;\n      }\n      InstructionCost ScalarCost = VecTy->getNumElements() * ScalarEltCost;\n      InstructionCost VecCost =\n          TTI->getArithmeticInstrCost(E->getOpcode(), VecTy, CostKind, Op1VK,\n                                      Op2VK, Op1VP, Op2VP, Operands, VL0);\n      LLVM_DEBUG(dumpTreeCosts(E, ReuseShuffleCost, VecCost, ScalarCost));\n      return ReuseShuffleCost + VecCost - ScalarCost;\n    }\n    case Instruction::GetElementPtr: {\n      TargetTransformInfo::OperandValueKind Op1VK =\n          TargetTransformInfo::OK_AnyValue;\n      TargetTransformInfo::OperandValueKind Op2VK =\n          TargetTransformInfo::OK_UniformConstantValue;\n\n      InstructionCost ScalarEltCost = TTI->getArithmeticInstrCost(\n          Instruction::Add, ScalarTy, CostKind, Op1VK, Op2VK);\n      if (NeedToShuffleReuses) {\n        ReuseShuffleCost -= (ReuseShuffleNumbers - VL.size()) * ScalarEltCost;\n      }\n      InstructionCost ScalarCost = VecTy->getNumElements() * ScalarEltCost;\n      InstructionCost VecCost = TTI->getArithmeticInstrCost(\n          Instruction::Add, VecTy, CostKind, Op1VK, Op2VK);\n      LLVM_DEBUG(dumpTreeCosts(E, ReuseShuffleCost, VecCost, ScalarCost));\n      return ReuseShuffleCost + VecCost - ScalarCost;\n    }\n    case Instruction::Load: {\n      // Cost of wide load - cost of scalar loads.\n      Align alignment = cast<LoadInst>(VL0)->getAlign();\n      InstructionCost ScalarEltCost = TTI->getMemoryOpCost(\n          Instruction::Load, ScalarTy, alignment, 0, CostKind, VL0);\n      if (NeedToShuffleReuses) {\n        ReuseShuffleCost -= (ReuseShuffleNumbers - VL.size()) * ScalarEltCost;\n      }\n      InstructionCost ScalarLdCost = VecTy->getNumElements() * ScalarEltCost;\n      InstructionCost VecLdCost;\n      if (E->State == TreeEntry::Vectorize) {\n        VecLdCost = TTI->getMemoryOpCost(Instruction::Load, VecTy, alignment, 0,\n                                         CostKind, VL0);\n      } else {\n        assert(E->State == TreeEntry::ScatterVectorize && \"Unknown EntryState\");\n        VecLdCost = TTI->getGatherScatterOpCost(\n            Instruction::Load, VecTy, cast<LoadInst>(VL0)->getPointerOperand(),\n            /*VariableMask=*/false, alignment, CostKind, VL0);\n      }\n      if (!E->ReorderIndices.empty()) {\n        // TODO: Merge this shuffle with the ReuseShuffleCost.\n        VecLdCost += TTI->getShuffleCost(\n            TargetTransformInfo::SK_PermuteSingleSrc, VecTy);\n      }\n      LLVM_DEBUG(dumpTreeCosts(E, ReuseShuffleCost, VecLdCost, ScalarLdCost));\n      return ReuseShuffleCost + VecLdCost - ScalarLdCost;\n    }\n    case Instruction::Store: {\n      // We know that we can merge the stores. Calculate the cost.\n      bool IsReorder = !E->ReorderIndices.empty();\n      auto *SI =\n          cast<StoreInst>(IsReorder ? VL[E->ReorderIndices.front()] : VL0);\n      Align Alignment = SI->getAlign();\n      InstructionCost ScalarEltCost = TTI->getMemoryOpCost(\n          Instruction::Store, ScalarTy, Alignment, 0, CostKind, VL0);\n      if (NeedToShuffleReuses)\n        ReuseShuffleCost = -(ReuseShuffleNumbers - VL.size()) * ScalarEltCost;\n      InstructionCost ScalarStCost = VecTy->getNumElements() * ScalarEltCost;\n      InstructionCost VecStCost = TTI->getMemoryOpCost(\n          Instruction::Store, VecTy, Alignment, 0, CostKind, VL0);\n      if (IsReorder) {\n        // TODO: Merge this shuffle with the ReuseShuffleCost.\n        VecStCost += TTI->getShuffleCost(\n            TargetTransformInfo::SK_PermuteSingleSrc, VecTy);\n      }\n      LLVM_DEBUG(dumpTreeCosts(E, ReuseShuffleCost, VecStCost, ScalarStCost));\n      return ReuseShuffleCost + VecStCost - ScalarStCost;\n    }\n    case Instruction::Call: {\n      CallInst *CI = cast<CallInst>(VL0);\n      Intrinsic::ID ID = getVectorIntrinsicIDForCall(CI, TLI);\n\n      // Calculate the cost of the scalar and vector calls.\n      IntrinsicCostAttributes CostAttrs(ID, *CI, 1);\n      InstructionCost ScalarEltCost =\n          TTI->getIntrinsicInstrCost(CostAttrs, CostKind);\n      if (NeedToShuffleReuses) {\n        ReuseShuffleCost -= (ReuseShuffleNumbers - VL.size()) * ScalarEltCost;\n      }\n      InstructionCost ScalarCallCost = VecTy->getNumElements() * ScalarEltCost;\n\n      auto VecCallCosts = getVectorCallCosts(CI, VecTy, TTI, TLI);\n      InstructionCost VecCallCost =\n          std::min(VecCallCosts.first, VecCallCosts.second);\n\n      LLVM_DEBUG(dbgs() << \"SLP: Call cost \" << VecCallCost - ScalarCallCost\n                        << \" (\" << VecCallCost << \"-\" << ScalarCallCost << \")\"\n                        << \" for \" << *CI << \"\\n\");\n\n      return ReuseShuffleCost + VecCallCost - ScalarCallCost;\n    }\n    case Instruction::ShuffleVector: {\n      assert(E->isAltShuffle() &&\n             ((Instruction::isBinaryOp(E->getOpcode()) &&\n               Instruction::isBinaryOp(E->getAltOpcode())) ||\n              (Instruction::isCast(E->getOpcode()) &&\n               Instruction::isCast(E->getAltOpcode()))) &&\n             \"Invalid Shuffle Vector Operand\");\n      InstructionCost ScalarCost = 0;\n      if (NeedToShuffleReuses) {\n        for (unsigned Idx : E->ReuseShuffleIndices) {\n          Instruction *I = cast<Instruction>(VL[Idx]);\n          ReuseShuffleCost -= TTI->getInstructionCost(I, CostKind);\n        }\n        for (Value *V : VL) {\n          Instruction *I = cast<Instruction>(V);\n          ReuseShuffleCost += TTI->getInstructionCost(I, CostKind);\n        }\n      }\n      for (Value *V : VL) {\n        Instruction *I = cast<Instruction>(V);\n        assert(E->isOpcodeOrAlt(I) && \"Unexpected main/alternate opcode\");\n        ScalarCost += TTI->getInstructionCost(I, CostKind);\n      }\n      // VecCost is equal to sum of the cost of creating 2 vectors\n      // and the cost of creating shuffle.\n      InstructionCost VecCost = 0;\n      if (Instruction::isBinaryOp(E->getOpcode())) {\n        VecCost = TTI->getArithmeticInstrCost(E->getOpcode(), VecTy, CostKind);\n        VecCost += TTI->getArithmeticInstrCost(E->getAltOpcode(), VecTy,\n                                               CostKind);\n      } else {\n        Type *Src0SclTy = E->getMainOp()->getOperand(0)->getType();\n        Type *Src1SclTy = E->getAltOp()->getOperand(0)->getType();\n        auto *Src0Ty = FixedVectorType::get(Src0SclTy, VL.size());\n        auto *Src1Ty = FixedVectorType::get(Src1SclTy, VL.size());\n        VecCost = TTI->getCastInstrCost(E->getOpcode(), VecTy, Src0Ty,\n                                        TTI::CastContextHint::None, CostKind);\n        VecCost += TTI->getCastInstrCost(E->getAltOpcode(), VecTy, Src1Ty,\n                                         TTI::CastContextHint::None, CostKind);\n      }\n      VecCost += TTI->getShuffleCost(TargetTransformInfo::SK_Select, VecTy, 0);\n      LLVM_DEBUG(dumpTreeCosts(E, ReuseShuffleCost, VecCost, ScalarCost));\n      return ReuseShuffleCost + VecCost - ScalarCost;\n    }\n    default:\n      llvm_unreachable(\"Unknown instruction\");\n  }\n}\n\nbool BoUpSLP::isFullyVectorizableTinyTree() const {\n  LLVM_DEBUG(dbgs() << \"SLP: Check whether the tree with height \"\n                    << VectorizableTree.size() << \" is fully vectorizable .\\n\");\n\n  // We only handle trees of heights 1 and 2.\n  if (VectorizableTree.size() == 1 &&\n      VectorizableTree[0]->State == TreeEntry::Vectorize)\n    return true;\n\n  if (VectorizableTree.size() != 2)\n    return false;\n\n  // Handle splat and all-constants stores.\n  if (VectorizableTree[0]->State == TreeEntry::Vectorize &&\n      (allConstant(VectorizableTree[1]->Scalars) ||\n       isSplat(VectorizableTree[1]->Scalars)))\n    return true;\n\n  // Gathering cost would be too much for tiny trees.\n  if (VectorizableTree[0]->State == TreeEntry::NeedToGather ||\n      VectorizableTree[1]->State == TreeEntry::NeedToGather)\n    return false;\n\n  return true;\n}\n\nstatic bool isLoadCombineCandidateImpl(Value *Root, unsigned NumElts,\n                                       TargetTransformInfo *TTI) {\n  // Look past the root to find a source value. Arbitrarily follow the\n  // path through operand 0 of any 'or'. Also, peek through optional\n  // shift-left-by-multiple-of-8-bits.\n  Value *ZextLoad = Root;\n  const APInt *ShAmtC;\n  while (!isa<ConstantExpr>(ZextLoad) &&\n         (match(ZextLoad, m_Or(m_Value(), m_Value())) ||\n          (match(ZextLoad, m_Shl(m_Value(), m_APInt(ShAmtC))) &&\n           ShAmtC->urem(8) == 0)))\n    ZextLoad = cast<BinaryOperator>(ZextLoad)->getOperand(0);\n\n  // Check if the input is an extended load of the required or/shift expression.\n  Value *LoadPtr;\n  if (ZextLoad == Root || !match(ZextLoad, m_ZExt(m_Load(m_Value(LoadPtr)))))\n    return false;\n\n  // Require that the total load bit width is a legal integer type.\n  // For example, <8 x i8> --> i64 is a legal integer on a 64-bit target.\n  // But <16 x i8> --> i128 is not, so the backend probably can't reduce it.\n  Type *SrcTy = LoadPtr->getType()->getPointerElementType();\n  unsigned LoadBitWidth = SrcTy->getIntegerBitWidth() * NumElts;\n  if (!TTI->isTypeLegal(IntegerType::get(Root->getContext(), LoadBitWidth)))\n    return false;\n\n  // Everything matched - assume that we can fold the whole sequence using\n  // load combining.\n  LLVM_DEBUG(dbgs() << \"SLP: Assume load combining for tree starting at \"\n             << *(cast<Instruction>(Root)) << \"\\n\");\n\n  return true;\n}\n\nbool BoUpSLP::isLoadCombineReductionCandidate(RecurKind RdxKind) const {\n  if (RdxKind != RecurKind::Or)\n    return false;\n\n  unsigned NumElts = VectorizableTree[0]->Scalars.size();\n  Value *FirstReduced = VectorizableTree[0]->Scalars[0];\n  return isLoadCombineCandidateImpl(FirstReduced, NumElts, TTI);\n}\n\nbool BoUpSLP::isLoadCombineCandidate() const {\n  // Peek through a final sequence of stores and check if all operations are\n  // likely to be load-combined.\n  unsigned NumElts = VectorizableTree[0]->Scalars.size();\n  for (Value *Scalar : VectorizableTree[0]->Scalars) {\n    Value *X;\n    if (!match(Scalar, m_Store(m_Value(X), m_Value())) ||\n        !isLoadCombineCandidateImpl(X, NumElts, TTI))\n      return false;\n  }\n  return true;\n}\n\nbool BoUpSLP::isTreeTinyAndNotFullyVectorizable() const {\n  // We can vectorize the tree if its size is greater than or equal to the\n  // minimum size specified by the MinTreeSize command line option.\n  if (VectorizableTree.size() >= MinTreeSize)\n    return false;\n\n  // If we have a tiny tree (a tree whose size is less than MinTreeSize), we\n  // can vectorize it if we can prove it fully vectorizable.\n  if (isFullyVectorizableTinyTree())\n    return false;\n\n  assert(VectorizableTree.empty()\n             ? ExternalUses.empty()\n             : true && \"We shouldn't have any external users\");\n\n  // Otherwise, we can't vectorize the tree. It is both tiny and not fully\n  // vectorizable.\n  return true;\n}\n\nInstructionCost BoUpSLP::getSpillCost() const {\n  // Walk from the bottom of the tree to the top, tracking which values are\n  // live. When we see a call instruction that is not part of our tree,\n  // query TTI to see if there is a cost to keeping values live over it\n  // (for example, if spills and fills are required).\n  unsigned BundleWidth = VectorizableTree.front()->Scalars.size();\n  InstructionCost Cost = 0;\n\n  SmallPtrSet<Instruction*, 4> LiveValues;\n  Instruction *PrevInst = nullptr;\n\n  // The entries in VectorizableTree are not necessarily ordered by their\n  // position in basic blocks. Collect them and order them by dominance so later\n  // instructions are guaranteed to be visited first. For instructions in\n  // different basic blocks, we only scan to the beginning of the block, so\n  // their order does not matter, as long as all instructions in a basic block\n  // are grouped together. Using dominance ensures a deterministic order.\n  SmallVector<Instruction *, 16> OrderedScalars;\n  for (const auto &TEPtr : VectorizableTree) {\n    Instruction *Inst = dyn_cast<Instruction>(TEPtr->Scalars[0]);\n    if (!Inst)\n      continue;\n    OrderedScalars.push_back(Inst);\n  }\n  llvm::stable_sort(OrderedScalars, [this](Instruction *A, Instruction *B) {\n    return DT->dominates(B, A);\n  });\n\n  for (Instruction *Inst : OrderedScalars) {\n    if (!PrevInst) {\n      PrevInst = Inst;\n      continue;\n    }\n\n    // Update LiveValues.\n    LiveValues.erase(PrevInst);\n    for (auto &J : PrevInst->operands()) {\n      if (isa<Instruction>(&*J) && getTreeEntry(&*J))\n        LiveValues.insert(cast<Instruction>(&*J));\n    }\n\n    LLVM_DEBUG({\n      dbgs() << \"SLP: #LV: \" << LiveValues.size();\n      for (auto *X : LiveValues)\n        dbgs() << \" \" << X->getName();\n      dbgs() << \", Looking at \";\n      Inst->dump();\n    });\n\n    // Now find the sequence of instructions between PrevInst and Inst.\n    unsigned NumCalls = 0;\n    BasicBlock::reverse_iterator InstIt = ++Inst->getIterator().getReverse(),\n                                 PrevInstIt =\n                                     PrevInst->getIterator().getReverse();\n    while (InstIt != PrevInstIt) {\n      if (PrevInstIt == PrevInst->getParent()->rend()) {\n        PrevInstIt = Inst->getParent()->rbegin();\n        continue;\n      }\n\n      // Debug information does not impact spill cost.\n      if ((isa<CallInst>(&*PrevInstIt) &&\n           !isa<DbgInfoIntrinsic>(&*PrevInstIt)) &&\n          &*PrevInstIt != PrevInst)\n        NumCalls++;\n\n      ++PrevInstIt;\n    }\n\n    if (NumCalls) {\n      SmallVector<Type*, 4> V;\n      for (auto *II : LiveValues)\n        V.push_back(FixedVectorType::get(II->getType(), BundleWidth));\n      Cost += NumCalls * TTI->getCostOfKeepingLiveOverCall(V);\n    }\n\n    PrevInst = Inst;\n  }\n\n  return Cost;\n}\n\nInstructionCost BoUpSLP::getTreeCost() {\n  InstructionCost Cost = 0;\n  LLVM_DEBUG(dbgs() << \"SLP: Calculating cost for tree of size \"\n                    << VectorizableTree.size() << \".\\n\");\n\n  unsigned BundleWidth = VectorizableTree[0]->Scalars.size();\n\n  for (unsigned I = 0, E = VectorizableTree.size(); I < E; ++I) {\n    TreeEntry &TE = *VectorizableTree[I].get();\n\n    // We create duplicate tree entries for gather sequences that have multiple\n    // uses. However, we should not compute the cost of duplicate sequences.\n    // For example, if we have a build vector (i.e., insertelement sequence)\n    // that is used by more than one vector instruction, we only need to\n    // compute the cost of the insertelement instructions once. The redundant\n    // instructions will be eliminated by CSE.\n    //\n    // We should consider not creating duplicate tree entries for gather\n    // sequences, and instead add additional edges to the tree representing\n    // their uses. Since such an approach results in fewer total entries,\n    // existing heuristics based on tree size may yield different results.\n    //\n    if (TE.State == TreeEntry::NeedToGather &&\n        std::any_of(std::next(VectorizableTree.begin(), I + 1),\n                    VectorizableTree.end(),\n                    [TE](const std::unique_ptr<TreeEntry> &EntryPtr) {\n                      return EntryPtr->State == TreeEntry::NeedToGather &&\n                             EntryPtr->isSame(TE.Scalars);\n                    }))\n      continue;\n\n    InstructionCost C = getEntryCost(&TE);\n    Cost += C;\n    LLVM_DEBUG(dbgs() << \"SLP: Adding cost \" << C\n                      << \" for bundle that starts with \" << *TE.Scalars[0]\n                      << \".\\n\"\n                      << \"SLP: Current total cost = \" << Cost << \"\\n\");\n  }\n\n  SmallPtrSet<Value *, 16> ExtractCostCalculated;\n  InstructionCost ExtractCost = 0;\n  for (ExternalUser &EU : ExternalUses) {\n    // We only add extract cost once for the same scalar.\n    if (!ExtractCostCalculated.insert(EU.Scalar).second)\n      continue;\n\n    // Uses by ephemeral values are free (because the ephemeral value will be\n    // removed prior to code generation, and so the extraction will be\n    // removed as well).\n    if (EphValues.count(EU.User))\n      continue;\n\n    // If we plan to rewrite the tree in a smaller type, we will need to sign\n    // extend the extracted value back to the original type. Here, we account\n    // for the extract and the added cost of the sign extend if needed.\n    auto *VecTy = FixedVectorType::get(EU.Scalar->getType(), BundleWidth);\n    auto *ScalarRoot = VectorizableTree[0]->Scalars[0];\n    if (MinBWs.count(ScalarRoot)) {\n      auto *MinTy = IntegerType::get(F->getContext(), MinBWs[ScalarRoot].first);\n      auto Extend =\n          MinBWs[ScalarRoot].second ? Instruction::SExt : Instruction::ZExt;\n      VecTy = FixedVectorType::get(MinTy, BundleWidth);\n      ExtractCost += TTI->getExtractWithExtendCost(Extend, EU.Scalar->getType(),\n                                                   VecTy, EU.Lane);\n    } else {\n      ExtractCost +=\n          TTI->getVectorInstrCost(Instruction::ExtractElement, VecTy, EU.Lane);\n    }\n  }\n\n  InstructionCost SpillCost = getSpillCost();\n  Cost += SpillCost + ExtractCost;\n\n#ifndef NDEBUG\n  SmallString<256> Str;\n  {\n    raw_svector_ostream OS(Str);\n    OS << \"SLP: Spill Cost = \" << SpillCost << \".\\n\"\n       << \"SLP: Extract Cost = \" << ExtractCost << \".\\n\"\n       << \"SLP: Total Cost = \" << Cost << \".\\n\";\n  }\n  LLVM_DEBUG(dbgs() << Str);\n  if (ViewSLPTree)\n    ViewGraph(this, \"SLP\" + F->getName(), false, Str);\n#endif\n\n  return Cost;\n}\n\nInstructionCost\nBoUpSLP::getGatherCost(FixedVectorType *Ty,\n                       const DenseSet<unsigned> &ShuffledIndices) const {\n  unsigned NumElts = Ty->getNumElements();\n  APInt DemandedElts = APInt::getNullValue(NumElts);\n  for (unsigned I = 0; I < NumElts; ++I)\n    if (!ShuffledIndices.count(I))\n      DemandedElts.setBit(I);\n  InstructionCost Cost =\n      TTI->getScalarizationOverhead(Ty, DemandedElts, /*Insert*/ true,\n                                    /*Extract*/ false);\n  if (!ShuffledIndices.empty())\n    Cost += TTI->getShuffleCost(TargetTransformInfo::SK_PermuteSingleSrc, Ty);\n  return Cost;\n}\n\nInstructionCost BoUpSLP::getGatherCost(ArrayRef<Value *> VL) const {\n  // Find the type of the operands in VL.\n  Type *ScalarTy = VL[0]->getType();\n  if (StoreInst *SI = dyn_cast<StoreInst>(VL[0]))\n    ScalarTy = SI->getValueOperand()->getType();\n  auto *VecTy = FixedVectorType::get(ScalarTy, VL.size());\n  // Find the cost of inserting/extracting values from the vector.\n  // Check if the same elements are inserted several times and count them as\n  // shuffle candidates.\n  DenseSet<unsigned> ShuffledElements;\n  DenseSet<Value *> UniqueElements;\n  // Iterate in reverse order to consider insert elements with the high cost.\n  for (unsigned I = VL.size(); I > 0; --I) {\n    unsigned Idx = I - 1;\n    if (!UniqueElements.insert(VL[Idx]).second)\n      ShuffledElements.insert(Idx);\n  }\n  return getGatherCost(VecTy, ShuffledElements);\n}\n\n// Perform operand reordering on the instructions in VL and return the reordered\n// operands in Left and Right.\nvoid BoUpSLP::reorderInputsAccordingToOpcode(ArrayRef<Value *> VL,\n                                             SmallVectorImpl<Value *> &Left,\n                                             SmallVectorImpl<Value *> &Right,\n                                             const DataLayout &DL,\n                                             ScalarEvolution &SE,\n                                             const BoUpSLP &R) {\n  if (VL.empty())\n    return;\n  VLOperands Ops(VL, DL, SE, R);\n  // Reorder the operands in place.\n  Ops.reorder();\n  Left = Ops.getVL(0);\n  Right = Ops.getVL(1);\n}\n\nvoid BoUpSLP::setInsertPointAfterBundle(TreeEntry *E) {\n  // Get the basic block this bundle is in. All instructions in the bundle\n  // should be in this block.\n  auto *Front = E->getMainOp();\n  auto *BB = Front->getParent();\n  assert(llvm::all_of(E->Scalars, [=](Value *V) -> bool {\n    auto *I = cast<Instruction>(V);\n    return !E->isOpcodeOrAlt(I) || I->getParent() == BB;\n  }));\n\n  // The last instruction in the bundle in program order.\n  Instruction *LastInst = nullptr;\n\n  // Find the last instruction. The common case should be that BB has been\n  // scheduled, and the last instruction is VL.back(). So we start with\n  // VL.back() and iterate over schedule data until we reach the end of the\n  // bundle. The end of the bundle is marked by null ScheduleData.\n  if (BlocksSchedules.count(BB)) {\n    auto *Bundle =\n        BlocksSchedules[BB]->getScheduleData(E->isOneOf(E->Scalars.back()));\n    if (Bundle && Bundle->isPartOfBundle())\n      for (; Bundle; Bundle = Bundle->NextInBundle)\n        if (Bundle->OpValue == Bundle->Inst)\n          LastInst = Bundle->Inst;\n  }\n\n  // LastInst can still be null at this point if there's either not an entry\n  // for BB in BlocksSchedules or there's no ScheduleData available for\n  // VL.back(). This can be the case if buildTree_rec aborts for various\n  // reasons (e.g., the maximum recursion depth is reached, the maximum region\n  // size is reached, etc.). ScheduleData is initialized in the scheduling\n  // \"dry-run\".\n  //\n  // If this happens, we can still find the last instruction by brute force. We\n  // iterate forwards from Front (inclusive) until we either see all\n  // instructions in the bundle or reach the end of the block. If Front is the\n  // last instruction in program order, LastInst will be set to Front, and we\n  // will visit all the remaining instructions in the block.\n  //\n  // One of the reasons we exit early from buildTree_rec is to place an upper\n  // bound on compile-time. Thus, taking an additional compile-time hit here is\n  // not ideal. However, this should be exceedingly rare since it requires that\n  // we both exit early from buildTree_rec and that the bundle be out-of-order\n  // (causing us to iterate all the way to the end of the block).\n  if (!LastInst) {\n    SmallPtrSet<Value *, 16> Bundle(E->Scalars.begin(), E->Scalars.end());\n    for (auto &I : make_range(BasicBlock::iterator(Front), BB->end())) {\n      if (Bundle.erase(&I) && E->isOpcodeOrAlt(&I))\n        LastInst = &I;\n      if (Bundle.empty())\n        break;\n    }\n  }\n  assert(LastInst && \"Failed to find last instruction in bundle\");\n\n  // Set the insertion point after the last instruction in the bundle. Set the\n  // debug location to Front.\n  Builder.SetInsertPoint(BB, ++LastInst->getIterator());\n  Builder.SetCurrentDebugLocation(Front->getDebugLoc());\n}\n\nValue *BoUpSLP::gather(ArrayRef<Value *> VL) {\n  Value *Val0 =\n      isa<StoreInst>(VL[0]) ? cast<StoreInst>(VL[0])->getValueOperand() : VL[0];\n  FixedVectorType *VecTy = FixedVectorType::get(Val0->getType(), VL.size());\n  Value *Vec = PoisonValue::get(VecTy);\n  unsigned InsIndex = 0;\n  for (Value *Val : VL) {\n    Vec = Builder.CreateInsertElement(Vec, Val, Builder.getInt32(InsIndex++));\n    auto *InsElt = dyn_cast<InsertElementInst>(Vec);\n    if (!InsElt)\n      continue;\n    GatherSeq.insert(InsElt);\n    CSEBlocks.insert(InsElt->getParent());\n    // Add to our 'need-to-extract' list.\n    if (TreeEntry *Entry = getTreeEntry(Val)) {\n      // Find which lane we need to extract.\n      unsigned FoundLane = std::distance(Entry->Scalars.begin(),\n                                         find(Entry->Scalars, Val));\n      assert(FoundLane < Entry->Scalars.size() && \"Couldn't find extract lane\");\n      if (!Entry->ReuseShuffleIndices.empty()) {\n        FoundLane = std::distance(Entry->ReuseShuffleIndices.begin(),\n                                  find(Entry->ReuseShuffleIndices, FoundLane));\n      }\n      ExternalUses.push_back(ExternalUser(Val, InsElt, FoundLane));\n    }\n  }\n\n  return Vec;\n}\n\nValue *BoUpSLP::vectorizeTree(ArrayRef<Value *> VL) {\n  InstructionsState S = getSameOpcode(VL);\n  if (S.getOpcode()) {\n    if (TreeEntry *E = getTreeEntry(S.OpValue)) {\n      if (E->isSame(VL)) {\n        Value *V = vectorizeTree(E);\n        if (VL.size() == E->Scalars.size() && !E->ReuseShuffleIndices.empty()) {\n          // We need to get the vectorized value but without shuffle.\n          if (auto *SV = dyn_cast<ShuffleVectorInst>(V)) {\n            V = SV->getOperand(0);\n          } else {\n            // Reshuffle to get only unique values.\n            SmallVector<int, 4> UniqueIdxs;\n            SmallSet<int, 4> UsedIdxs;\n            for (int Idx : E->ReuseShuffleIndices)\n              if (UsedIdxs.insert(Idx).second)\n                UniqueIdxs.emplace_back(Idx);\n            V = Builder.CreateShuffleVector(V, UniqueIdxs);\n          }\n        }\n        return V;\n      }\n    }\n  }\n\n  // Check that every instruction appears once in this bundle.\n  SmallVector<int, 4> ReuseShuffleIndicies;\n  SmallVector<Value *, 4> UniqueValues;\n  if (VL.size() > 2) {\n    DenseMap<Value *, unsigned> UniquePositions;\n    for (Value *V : VL) {\n      auto Res = UniquePositions.try_emplace(V, UniqueValues.size());\n      ReuseShuffleIndicies.emplace_back(Res.first->second);\n      if (Res.second || isa<Constant>(V))\n        UniqueValues.emplace_back(V);\n    }\n    // Do not shuffle single element or if number of unique values is not power\n    // of 2.\n    if (UniqueValues.size() == VL.size() || UniqueValues.size() <= 1 ||\n        !llvm::isPowerOf2_32(UniqueValues.size()))\n      ReuseShuffleIndicies.clear();\n    else\n      VL = UniqueValues;\n  }\n\n  Value *Vec = gather(VL);\n  if (!ReuseShuffleIndicies.empty()) {\n    Vec = Builder.CreateShuffleVector(Vec, ReuseShuffleIndicies, \"shuffle\");\n    if (auto *I = dyn_cast<Instruction>(Vec)) {\n      GatherSeq.insert(I);\n      CSEBlocks.insert(I->getParent());\n    }\n  }\n  return Vec;\n}\n\nValue *BoUpSLP::vectorizeTree(TreeEntry *E) {\n  IRBuilder<>::InsertPointGuard Guard(Builder);\n\n  if (E->VectorizedValue) {\n    LLVM_DEBUG(dbgs() << \"SLP: Diamond merged for \" << *E->Scalars[0] << \".\\n\");\n    return E->VectorizedValue;\n  }\n\n  bool NeedToShuffleReuses = !E->ReuseShuffleIndices.empty();\n  if (E->State == TreeEntry::NeedToGather) {\n    setInsertPointAfterBundle(E);\n    Value *Vec = gather(E->Scalars);\n    if (NeedToShuffleReuses) {\n      Vec = Builder.CreateShuffleVector(Vec, E->ReuseShuffleIndices, \"shuffle\");\n      if (auto *I = dyn_cast<Instruction>(Vec)) {\n        GatherSeq.insert(I);\n        CSEBlocks.insert(I->getParent());\n      }\n    }\n    E->VectorizedValue = Vec;\n    return Vec;\n  }\n\n  assert((E->State == TreeEntry::Vectorize ||\n          E->State == TreeEntry::ScatterVectorize) &&\n         \"Unhandled state\");\n  unsigned ShuffleOrOp =\n      E->isAltShuffle() ? (unsigned)Instruction::ShuffleVector : E->getOpcode();\n  Instruction *VL0 = E->getMainOp();\n  Type *ScalarTy = VL0->getType();\n  if (auto *Store = dyn_cast<StoreInst>(VL0))\n    ScalarTy = Store->getValueOperand()->getType();\n  auto *VecTy = FixedVectorType::get(ScalarTy, E->Scalars.size());\n  switch (ShuffleOrOp) {\n    case Instruction::PHI: {\n      auto *PH = cast<PHINode>(VL0);\n      Builder.SetInsertPoint(PH->getParent()->getFirstNonPHI());\n      Builder.SetCurrentDebugLocation(PH->getDebugLoc());\n      PHINode *NewPhi = Builder.CreatePHI(VecTy, PH->getNumIncomingValues());\n      Value *V = NewPhi;\n      if (NeedToShuffleReuses)\n        V = Builder.CreateShuffleVector(V, E->ReuseShuffleIndices, \"shuffle\");\n\n      E->VectorizedValue = V;\n\n      // PHINodes may have multiple entries from the same block. We want to\n      // visit every block once.\n      SmallPtrSet<BasicBlock*, 4> VisitedBBs;\n\n      for (unsigned i = 0, e = PH->getNumIncomingValues(); i < e; ++i) {\n        ValueList Operands;\n        BasicBlock *IBB = PH->getIncomingBlock(i);\n\n        if (!VisitedBBs.insert(IBB).second) {\n          NewPhi->addIncoming(NewPhi->getIncomingValueForBlock(IBB), IBB);\n          continue;\n        }\n\n        Builder.SetInsertPoint(IBB->getTerminator());\n        Builder.SetCurrentDebugLocation(PH->getDebugLoc());\n        Value *Vec = vectorizeTree(E->getOperand(i));\n        NewPhi->addIncoming(Vec, IBB);\n      }\n\n      assert(NewPhi->getNumIncomingValues() == PH->getNumIncomingValues() &&\n             \"Invalid number of incoming values\");\n      return V;\n    }\n\n    case Instruction::ExtractElement: {\n      Value *V = E->getSingleOperand(0);\n      if (!E->ReorderIndices.empty()) {\n        SmallVector<int, 4> Mask;\n        inversePermutation(E->ReorderIndices, Mask);\n        Builder.SetInsertPoint(VL0);\n        V = Builder.CreateShuffleVector(V, Mask, \"reorder_shuffle\");\n      }\n      if (NeedToShuffleReuses) {\n        // TODO: Merge this shuffle with the ReorderShuffleMask.\n        if (E->ReorderIndices.empty())\n          Builder.SetInsertPoint(VL0);\n        V = Builder.CreateShuffleVector(V, E->ReuseShuffleIndices, \"shuffle\");\n      }\n      E->VectorizedValue = V;\n      return V;\n    }\n    case Instruction::ExtractValue: {\n      auto *LI = cast<LoadInst>(E->getSingleOperand(0));\n      Builder.SetInsertPoint(LI);\n      auto *PtrTy = PointerType::get(VecTy, LI->getPointerAddressSpace());\n      Value *Ptr = Builder.CreateBitCast(LI->getOperand(0), PtrTy);\n      LoadInst *V = Builder.CreateAlignedLoad(VecTy, Ptr, LI->getAlign());\n      Value *NewV = propagateMetadata(V, E->Scalars);\n      if (!E->ReorderIndices.empty()) {\n        SmallVector<int, 4> Mask;\n        inversePermutation(E->ReorderIndices, Mask);\n        NewV = Builder.CreateShuffleVector(NewV, Mask, \"reorder_shuffle\");\n      }\n      if (NeedToShuffleReuses) {\n        // TODO: Merge this shuffle with the ReorderShuffleMask.\n        NewV = Builder.CreateShuffleVector(NewV, E->ReuseShuffleIndices,\n                                           \"shuffle\");\n      }\n      E->VectorizedValue = NewV;\n      return NewV;\n    }\n    case Instruction::ZExt:\n    case Instruction::SExt:\n    case Instruction::FPToUI:\n    case Instruction::FPToSI:\n    case Instruction::FPExt:\n    case Instruction::PtrToInt:\n    case Instruction::IntToPtr:\n    case Instruction::SIToFP:\n    case Instruction::UIToFP:\n    case Instruction::Trunc:\n    case Instruction::FPTrunc:\n    case Instruction::BitCast: {\n      setInsertPointAfterBundle(E);\n\n      Value *InVec = vectorizeTree(E->getOperand(0));\n\n      if (E->VectorizedValue) {\n        LLVM_DEBUG(dbgs() << \"SLP: Diamond merged for \" << *VL0 << \".\\n\");\n        return E->VectorizedValue;\n      }\n\n      auto *CI = cast<CastInst>(VL0);\n      Value *V = Builder.CreateCast(CI->getOpcode(), InVec, VecTy);\n      if (NeedToShuffleReuses)\n        V = Builder.CreateShuffleVector(V, E->ReuseShuffleIndices, \"shuffle\");\n\n      E->VectorizedValue = V;\n      ++NumVectorInstructions;\n      return V;\n    }\n    case Instruction::FCmp:\n    case Instruction::ICmp: {\n      setInsertPointAfterBundle(E);\n\n      Value *L = vectorizeTree(E->getOperand(0));\n      Value *R = vectorizeTree(E->getOperand(1));\n\n      if (E->VectorizedValue) {\n        LLVM_DEBUG(dbgs() << \"SLP: Diamond merged for \" << *VL0 << \".\\n\");\n        return E->VectorizedValue;\n      }\n\n      CmpInst::Predicate P0 = cast<CmpInst>(VL0)->getPredicate();\n      Value *V = Builder.CreateCmp(P0, L, R);\n      propagateIRFlags(V, E->Scalars, VL0);\n      if (NeedToShuffleReuses)\n        V = Builder.CreateShuffleVector(V, E->ReuseShuffleIndices, \"shuffle\");\n\n      E->VectorizedValue = V;\n      ++NumVectorInstructions;\n      return V;\n    }\n    case Instruction::Select: {\n      setInsertPointAfterBundle(E);\n\n      Value *Cond = vectorizeTree(E->getOperand(0));\n      Value *True = vectorizeTree(E->getOperand(1));\n      Value *False = vectorizeTree(E->getOperand(2));\n\n      if (E->VectorizedValue) {\n        LLVM_DEBUG(dbgs() << \"SLP: Diamond merged for \" << *VL0 << \".\\n\");\n        return E->VectorizedValue;\n      }\n\n      Value *V = Builder.CreateSelect(Cond, True, False);\n      if (NeedToShuffleReuses)\n        V = Builder.CreateShuffleVector(V, E->ReuseShuffleIndices, \"shuffle\");\n\n      E->VectorizedValue = V;\n      ++NumVectorInstructions;\n      return V;\n    }\n    case Instruction::FNeg: {\n      setInsertPointAfterBundle(E);\n\n      Value *Op = vectorizeTree(E->getOperand(0));\n\n      if (E->VectorizedValue) {\n        LLVM_DEBUG(dbgs() << \"SLP: Diamond merged for \" << *VL0 << \".\\n\");\n        return E->VectorizedValue;\n      }\n\n      Value *V = Builder.CreateUnOp(\n          static_cast<Instruction::UnaryOps>(E->getOpcode()), Op);\n      propagateIRFlags(V, E->Scalars, VL0);\n      if (auto *I = dyn_cast<Instruction>(V))\n        V = propagateMetadata(I, E->Scalars);\n\n      if (NeedToShuffleReuses)\n        V = Builder.CreateShuffleVector(V, E->ReuseShuffleIndices, \"shuffle\");\n\n      E->VectorizedValue = V;\n      ++NumVectorInstructions;\n\n      return V;\n    }\n    case Instruction::Add:\n    case Instruction::FAdd:\n    case Instruction::Sub:\n    case Instruction::FSub:\n    case Instruction::Mul:\n    case Instruction::FMul:\n    case Instruction::UDiv:\n    case Instruction::SDiv:\n    case Instruction::FDiv:\n    case Instruction::URem:\n    case Instruction::SRem:\n    case Instruction::FRem:\n    case Instruction::Shl:\n    case Instruction::LShr:\n    case Instruction::AShr:\n    case Instruction::And:\n    case Instruction::Or:\n    case Instruction::Xor: {\n      setInsertPointAfterBundle(E);\n\n      Value *LHS = vectorizeTree(E->getOperand(0));\n      Value *RHS = vectorizeTree(E->getOperand(1));\n\n      if (E->VectorizedValue) {\n        LLVM_DEBUG(dbgs() << \"SLP: Diamond merged for \" << *VL0 << \".\\n\");\n        return E->VectorizedValue;\n      }\n\n      Value *V = Builder.CreateBinOp(\n          static_cast<Instruction::BinaryOps>(E->getOpcode()), LHS,\n          RHS);\n      propagateIRFlags(V, E->Scalars, VL0);\n      if (auto *I = dyn_cast<Instruction>(V))\n        V = propagateMetadata(I, E->Scalars);\n\n      if (NeedToShuffleReuses)\n        V = Builder.CreateShuffleVector(V, E->ReuseShuffleIndices, \"shuffle\");\n\n      E->VectorizedValue = V;\n      ++NumVectorInstructions;\n\n      return V;\n    }\n    case Instruction::Load: {\n      // Loads are inserted at the head of the tree because we don't want to\n      // sink them all the way down past store instructions.\n      bool IsReorder = E->updateStateIfReorder();\n      if (IsReorder)\n        VL0 = E->getMainOp();\n      setInsertPointAfterBundle(E);\n\n      LoadInst *LI = cast<LoadInst>(VL0);\n      Instruction *NewLI;\n      unsigned AS = LI->getPointerAddressSpace();\n      Value *PO = LI->getPointerOperand();\n      if (E->State == TreeEntry::Vectorize) {\n\n        Value *VecPtr = Builder.CreateBitCast(PO, VecTy->getPointerTo(AS));\n\n        // The pointer operand uses an in-tree scalar so we add the new BitCast\n        // to ExternalUses list to make sure that an extract will be generated\n        // in the future.\n        if (getTreeEntry(PO))\n          ExternalUses.emplace_back(PO, cast<User>(VecPtr), 0);\n\n        NewLI = Builder.CreateAlignedLoad(VecTy, VecPtr, LI->getAlign());\n      } else {\n        assert(E->State == TreeEntry::ScatterVectorize && \"Unhandled state\");\n        Value *VecPtr = vectorizeTree(E->getOperand(0));\n        // Use the minimum alignment of the gathered loads.\n        Align CommonAlignment = LI->getAlign();\n        for (Value *V : E->Scalars)\n          CommonAlignment =\n              commonAlignment(CommonAlignment, cast<LoadInst>(V)->getAlign());\n        NewLI = Builder.CreateMaskedGather(VecPtr, CommonAlignment);\n      }\n      Value *V = propagateMetadata(NewLI, E->Scalars);\n\n      if (IsReorder) {\n        SmallVector<int, 4> Mask;\n        inversePermutation(E->ReorderIndices, Mask);\n        V = Builder.CreateShuffleVector(V, Mask, \"reorder_shuffle\");\n      }\n      if (NeedToShuffleReuses) {\n        // TODO: Merge this shuffle with the ReorderShuffleMask.\n        V = Builder.CreateShuffleVector(V, E->ReuseShuffleIndices, \"shuffle\");\n      }\n      E->VectorizedValue = V;\n      ++NumVectorInstructions;\n      return V;\n    }\n    case Instruction::Store: {\n      bool IsReorder = !E->ReorderIndices.empty();\n      auto *SI = cast<StoreInst>(\n          IsReorder ? E->Scalars[E->ReorderIndices.front()] : VL0);\n      unsigned AS = SI->getPointerAddressSpace();\n\n      setInsertPointAfterBundle(E);\n\n      Value *VecValue = vectorizeTree(E->getOperand(0));\n      if (IsReorder) {\n        SmallVector<int, 4> Mask(E->ReorderIndices.begin(),\n                                 E->ReorderIndices.end());\n        VecValue = Builder.CreateShuffleVector(VecValue, Mask, \"reorder_shuf\");\n      }\n      Value *ScalarPtr = SI->getPointerOperand();\n      Value *VecPtr = Builder.CreateBitCast(\n          ScalarPtr, VecValue->getType()->getPointerTo(AS));\n      StoreInst *ST = Builder.CreateAlignedStore(VecValue, VecPtr,\n                                                 SI->getAlign());\n\n      // The pointer operand uses an in-tree scalar, so add the new BitCast to\n      // ExternalUses to make sure that an extract will be generated in the\n      // future.\n      if (getTreeEntry(ScalarPtr))\n        ExternalUses.push_back(ExternalUser(ScalarPtr, cast<User>(VecPtr), 0));\n\n      Value *V = propagateMetadata(ST, E->Scalars);\n      if (NeedToShuffleReuses)\n        V = Builder.CreateShuffleVector(V, E->ReuseShuffleIndices, \"shuffle\");\n\n      E->VectorizedValue = V;\n      ++NumVectorInstructions;\n      return V;\n    }\n    case Instruction::GetElementPtr: {\n      setInsertPointAfterBundle(E);\n\n      Value *Op0 = vectorizeTree(E->getOperand(0));\n\n      std::vector<Value *> OpVecs;\n      for (int j = 1, e = cast<GetElementPtrInst>(VL0)->getNumOperands(); j < e;\n           ++j) {\n        ValueList &VL = E->getOperand(j);\n        // Need to cast all elements to the same type before vectorization to\n        // avoid crash.\n        Type *VL0Ty = VL0->getOperand(j)->getType();\n        Type *Ty = llvm::all_of(\n                       VL, [VL0Ty](Value *V) { return VL0Ty == V->getType(); })\n                       ? VL0Ty\n                       : DL->getIndexType(cast<GetElementPtrInst>(VL0)\n                                              ->getPointerOperandType()\n                                              ->getScalarType());\n        for (Value *&V : VL) {\n          auto *CI = cast<ConstantInt>(V);\n          V = ConstantExpr::getIntegerCast(CI, Ty,\n                                           CI->getValue().isSignBitSet());\n        }\n        Value *OpVec = vectorizeTree(VL);\n        OpVecs.push_back(OpVec);\n      }\n\n      Value *V = Builder.CreateGEP(\n          cast<GetElementPtrInst>(VL0)->getSourceElementType(), Op0, OpVecs);\n      if (Instruction *I = dyn_cast<Instruction>(V))\n        V = propagateMetadata(I, E->Scalars);\n\n      if (NeedToShuffleReuses)\n        V = Builder.CreateShuffleVector(V, E->ReuseShuffleIndices, \"shuffle\");\n\n      E->VectorizedValue = V;\n      ++NumVectorInstructions;\n\n      return V;\n    }\n    case Instruction::Call: {\n      CallInst *CI = cast<CallInst>(VL0);\n      setInsertPointAfterBundle(E);\n\n      Intrinsic::ID IID  = Intrinsic::not_intrinsic;\n      if (Function *FI = CI->getCalledFunction())\n        IID = FI->getIntrinsicID();\n\n      Intrinsic::ID ID = getVectorIntrinsicIDForCall(CI, TLI);\n\n      auto VecCallCosts = getVectorCallCosts(CI, VecTy, TTI, TLI);\n      bool UseIntrinsic = ID != Intrinsic::not_intrinsic &&\n                          VecCallCosts.first <= VecCallCosts.second;\n\n      Value *ScalarArg = nullptr;\n      std::vector<Value *> OpVecs;\n      for (int j = 0, e = CI->getNumArgOperands(); j < e; ++j) {\n        ValueList OpVL;\n        // Some intrinsics have scalar arguments. This argument should not be\n        // vectorized.\n        if (UseIntrinsic && hasVectorInstrinsicScalarOpd(IID, j)) {\n          CallInst *CEI = cast<CallInst>(VL0);\n          ScalarArg = CEI->getArgOperand(j);\n          OpVecs.push_back(CEI->getArgOperand(j));\n          continue;\n        }\n\n        Value *OpVec = vectorizeTree(E->getOperand(j));\n        LLVM_DEBUG(dbgs() << \"SLP: OpVec[\" << j << \"]: \" << *OpVec << \"\\n\");\n        OpVecs.push_back(OpVec);\n      }\n\n      Function *CF;\n      if (!UseIntrinsic) {\n        VFShape Shape =\n            VFShape::get(*CI, ElementCount::getFixed(static_cast<unsigned>(\n                                  VecTy->getNumElements())),\n                         false /*HasGlobalPred*/);\n        CF = VFDatabase(*CI).getVectorizedFunction(Shape);\n      } else {\n        Type *Tys[] = {FixedVectorType::get(CI->getType(), E->Scalars.size())};\n        CF = Intrinsic::getDeclaration(F->getParent(), ID, Tys);\n      }\n\n      SmallVector<OperandBundleDef, 1> OpBundles;\n      CI->getOperandBundlesAsDefs(OpBundles);\n      Value *V = Builder.CreateCall(CF, OpVecs, OpBundles);\n\n      // The scalar argument uses an in-tree scalar so we add the new vectorized\n      // call to ExternalUses list to make sure that an extract will be\n      // generated in the future.\n      if (ScalarArg && getTreeEntry(ScalarArg))\n        ExternalUses.push_back(ExternalUser(ScalarArg, cast<User>(V), 0));\n\n      propagateIRFlags(V, E->Scalars, VL0);\n      if (NeedToShuffleReuses)\n        V = Builder.CreateShuffleVector(V, E->ReuseShuffleIndices, \"shuffle\");\n\n      E->VectorizedValue = V;\n      ++NumVectorInstructions;\n      return V;\n    }\n    case Instruction::ShuffleVector: {\n      assert(E->isAltShuffle() &&\n             ((Instruction::isBinaryOp(E->getOpcode()) &&\n               Instruction::isBinaryOp(E->getAltOpcode())) ||\n              (Instruction::isCast(E->getOpcode()) &&\n               Instruction::isCast(E->getAltOpcode()))) &&\n             \"Invalid Shuffle Vector Operand\");\n\n      Value *LHS = nullptr, *RHS = nullptr;\n      if (Instruction::isBinaryOp(E->getOpcode())) {\n        setInsertPointAfterBundle(E);\n        LHS = vectorizeTree(E->getOperand(0));\n        RHS = vectorizeTree(E->getOperand(1));\n      } else {\n        setInsertPointAfterBundle(E);\n        LHS = vectorizeTree(E->getOperand(0));\n      }\n\n      if (E->VectorizedValue) {\n        LLVM_DEBUG(dbgs() << \"SLP: Diamond merged for \" << *VL0 << \".\\n\");\n        return E->VectorizedValue;\n      }\n\n      Value *V0, *V1;\n      if (Instruction::isBinaryOp(E->getOpcode())) {\n        V0 = Builder.CreateBinOp(\n            static_cast<Instruction::BinaryOps>(E->getOpcode()), LHS, RHS);\n        V1 = Builder.CreateBinOp(\n            static_cast<Instruction::BinaryOps>(E->getAltOpcode()), LHS, RHS);\n      } else {\n        V0 = Builder.CreateCast(\n            static_cast<Instruction::CastOps>(E->getOpcode()), LHS, VecTy);\n        V1 = Builder.CreateCast(\n            static_cast<Instruction::CastOps>(E->getAltOpcode()), LHS, VecTy);\n      }\n\n      // Create shuffle to take alternate operations from the vector.\n      // Also, gather up main and alt scalar ops to propagate IR flags to\n      // each vector operation.\n      ValueList OpScalars, AltScalars;\n      unsigned e = E->Scalars.size();\n      SmallVector<int, 8> Mask(e);\n      for (unsigned i = 0; i < e; ++i) {\n        auto *OpInst = cast<Instruction>(E->Scalars[i]);\n        assert(E->isOpcodeOrAlt(OpInst) && \"Unexpected main/alternate opcode\");\n        if (OpInst->getOpcode() == E->getAltOpcode()) {\n          Mask[i] = e + i;\n          AltScalars.push_back(E->Scalars[i]);\n        } else {\n          Mask[i] = i;\n          OpScalars.push_back(E->Scalars[i]);\n        }\n      }\n\n      propagateIRFlags(V0, OpScalars);\n      propagateIRFlags(V1, AltScalars);\n\n      Value *V = Builder.CreateShuffleVector(V0, V1, Mask);\n      if (Instruction *I = dyn_cast<Instruction>(V))\n        V = propagateMetadata(I, E->Scalars);\n      if (NeedToShuffleReuses)\n        V = Builder.CreateShuffleVector(V, E->ReuseShuffleIndices, \"shuffle\");\n\n      E->VectorizedValue = V;\n      ++NumVectorInstructions;\n\n      return V;\n    }\n    default:\n    llvm_unreachable(\"unknown inst\");\n  }\n  return nullptr;\n}\n\nValue *BoUpSLP::vectorizeTree() {\n  ExtraValueToDebugLocsMap ExternallyUsedValues;\n  return vectorizeTree(ExternallyUsedValues);\n}\n\nValue *\nBoUpSLP::vectorizeTree(ExtraValueToDebugLocsMap &ExternallyUsedValues) {\n  // All blocks must be scheduled before any instructions are inserted.\n  for (auto &BSIter : BlocksSchedules) {\n    scheduleBlock(BSIter.second.get());\n  }\n\n  Builder.SetInsertPoint(&F->getEntryBlock().front());\n  auto *VectorRoot = vectorizeTree(VectorizableTree[0].get());\n\n  // If the vectorized tree can be rewritten in a smaller type, we truncate the\n  // vectorized root. InstCombine will then rewrite the entire expression. We\n  // sign extend the extracted values below.\n  auto *ScalarRoot = VectorizableTree[0]->Scalars[0];\n  if (MinBWs.count(ScalarRoot)) {\n    if (auto *I = dyn_cast<Instruction>(VectorRoot))\n      Builder.SetInsertPoint(&*++BasicBlock::iterator(I));\n    auto BundleWidth = VectorizableTree[0]->Scalars.size();\n    auto *MinTy = IntegerType::get(F->getContext(), MinBWs[ScalarRoot].first);\n    auto *VecTy = FixedVectorType::get(MinTy, BundleWidth);\n    auto *Trunc = Builder.CreateTrunc(VectorRoot, VecTy);\n    VectorizableTree[0]->VectorizedValue = Trunc;\n  }\n\n  LLVM_DEBUG(dbgs() << \"SLP: Extracting \" << ExternalUses.size()\n                    << \" values .\\n\");\n\n  // If necessary, sign-extend or zero-extend ScalarRoot to the larger type\n  // specified by ScalarType.\n  auto extend = [&](Value *ScalarRoot, Value *Ex, Type *ScalarType) {\n    if (!MinBWs.count(ScalarRoot))\n      return Ex;\n    if (MinBWs[ScalarRoot].second)\n      return Builder.CreateSExt(Ex, ScalarType);\n    return Builder.CreateZExt(Ex, ScalarType);\n  };\n\n  // Extract all of the elements with the external uses.\n  for (const auto &ExternalUse : ExternalUses) {\n    Value *Scalar = ExternalUse.Scalar;\n    llvm::User *User = ExternalUse.User;\n\n    // Skip users that we already RAUW. This happens when one instruction\n    // has multiple uses of the same value.\n    if (User && !is_contained(Scalar->users(), User))\n      continue;\n    TreeEntry *E = getTreeEntry(Scalar);\n    assert(E && \"Invalid scalar\");\n    assert(E->State != TreeEntry::NeedToGather &&\n           \"Extracting from a gather list\");\n\n    Value *Vec = E->VectorizedValue;\n    assert(Vec && \"Can't find vectorizable value\");\n\n    Value *Lane = Builder.getInt32(ExternalUse.Lane);\n    // If User == nullptr, the Scalar is used as extra arg. Generate\n    // ExtractElement instruction and update the record for this scalar in\n    // ExternallyUsedValues.\n    if (!User) {\n      assert(ExternallyUsedValues.count(Scalar) &&\n             \"Scalar with nullptr as an external user must be registered in \"\n             \"ExternallyUsedValues map\");\n      if (auto *VecI = dyn_cast<Instruction>(Vec)) {\n        Builder.SetInsertPoint(VecI->getParent(),\n                               std::next(VecI->getIterator()));\n      } else {\n        Builder.SetInsertPoint(&F->getEntryBlock().front());\n      }\n      Value *Ex = Builder.CreateExtractElement(Vec, Lane);\n      Ex = extend(ScalarRoot, Ex, Scalar->getType());\n      CSEBlocks.insert(cast<Instruction>(Scalar)->getParent());\n      auto &Locs = ExternallyUsedValues[Scalar];\n      ExternallyUsedValues.insert({Ex, Locs});\n      ExternallyUsedValues.erase(Scalar);\n      // Required to update internally referenced instructions.\n      Scalar->replaceAllUsesWith(Ex);\n      continue;\n    }\n\n    // Generate extracts for out-of-tree users.\n    // Find the insertion point for the extractelement lane.\n    if (auto *VecI = dyn_cast<Instruction>(Vec)) {\n      if (PHINode *PH = dyn_cast<PHINode>(User)) {\n        for (int i = 0, e = PH->getNumIncomingValues(); i != e; ++i) {\n          if (PH->getIncomingValue(i) == Scalar) {\n            Instruction *IncomingTerminator =\n                PH->getIncomingBlock(i)->getTerminator();\n            if (isa<CatchSwitchInst>(IncomingTerminator)) {\n              Builder.SetInsertPoint(VecI->getParent(),\n                                     std::next(VecI->getIterator()));\n            } else {\n              Builder.SetInsertPoint(PH->getIncomingBlock(i)->getTerminator());\n            }\n            Value *Ex = Builder.CreateExtractElement(Vec, Lane);\n            Ex = extend(ScalarRoot, Ex, Scalar->getType());\n            CSEBlocks.insert(PH->getIncomingBlock(i));\n            PH->setOperand(i, Ex);\n          }\n        }\n      } else {\n        Builder.SetInsertPoint(cast<Instruction>(User));\n        Value *Ex = Builder.CreateExtractElement(Vec, Lane);\n        Ex = extend(ScalarRoot, Ex, Scalar->getType());\n        CSEBlocks.insert(cast<Instruction>(User)->getParent());\n        User->replaceUsesOfWith(Scalar, Ex);\n      }\n    } else {\n      Builder.SetInsertPoint(&F->getEntryBlock().front());\n      Value *Ex = Builder.CreateExtractElement(Vec, Lane);\n      Ex = extend(ScalarRoot, Ex, Scalar->getType());\n      CSEBlocks.insert(&F->getEntryBlock());\n      User->replaceUsesOfWith(Scalar, Ex);\n    }\n\n    LLVM_DEBUG(dbgs() << \"SLP: Replaced:\" << *User << \".\\n\");\n  }\n\n  // For each vectorized value:\n  for (auto &TEPtr : VectorizableTree) {\n    TreeEntry *Entry = TEPtr.get();\n\n    // No need to handle users of gathered values.\n    if (Entry->State == TreeEntry::NeedToGather)\n      continue;\n\n    assert(Entry->VectorizedValue && \"Can't find vectorizable value\");\n\n    // For each lane:\n    for (int Lane = 0, LE = Entry->Scalars.size(); Lane != LE; ++Lane) {\n      Value *Scalar = Entry->Scalars[Lane];\n\n#ifndef NDEBUG\n      Type *Ty = Scalar->getType();\n      if (!Ty->isVoidTy()) {\n        for (User *U : Scalar->users()) {\n          LLVM_DEBUG(dbgs() << \"SLP: \\tvalidating user:\" << *U << \".\\n\");\n\n          // It is legal to delete users in the ignorelist.\n          assert((getTreeEntry(U) || is_contained(UserIgnoreList, U)) &&\n                 \"Deleting out-of-tree value\");\n        }\n      }\n#endif\n      LLVM_DEBUG(dbgs() << \"SLP: \\tErasing scalar:\" << *Scalar << \".\\n\");\n      eraseInstruction(cast<Instruction>(Scalar));\n    }\n  }\n\n  Builder.ClearInsertionPoint();\n  InstrElementSize.clear();\n\n  return VectorizableTree[0]->VectorizedValue;\n}\n\nvoid BoUpSLP::optimizeGatherSequence() {\n  LLVM_DEBUG(dbgs() << \"SLP: Optimizing \" << GatherSeq.size()\n                    << \" gather sequences instructions.\\n\");\n  // LICM InsertElementInst sequences.\n  for (Instruction *I : GatherSeq) {\n    if (isDeleted(I))\n      continue;\n\n    // Check if this block is inside a loop.\n    Loop *L = LI->getLoopFor(I->getParent());\n    if (!L)\n      continue;\n\n    // Check if it has a preheader.\n    BasicBlock *PreHeader = L->getLoopPreheader();\n    if (!PreHeader)\n      continue;\n\n    // If the vector or the element that we insert into it are\n    // instructions that are defined in this basic block then we can't\n    // hoist this instruction.\n    auto *Op0 = dyn_cast<Instruction>(I->getOperand(0));\n    auto *Op1 = dyn_cast<Instruction>(I->getOperand(1));\n    if (Op0 && L->contains(Op0))\n      continue;\n    if (Op1 && L->contains(Op1))\n      continue;\n\n    // We can hoist this instruction. Move it to the pre-header.\n    I->moveBefore(PreHeader->getTerminator());\n  }\n\n  // Make a list of all reachable blocks in our CSE queue.\n  SmallVector<const DomTreeNode *, 8> CSEWorkList;\n  CSEWorkList.reserve(CSEBlocks.size());\n  for (BasicBlock *BB : CSEBlocks)\n    if (DomTreeNode *N = DT->getNode(BB)) {\n      assert(DT->isReachableFromEntry(N));\n      CSEWorkList.push_back(N);\n    }\n\n  // Sort blocks by domination. This ensures we visit a block after all blocks\n  // dominating it are visited.\n  llvm::stable_sort(CSEWorkList,\n                    [this](const DomTreeNode *A, const DomTreeNode *B) {\n                      return DT->properlyDominates(A, B);\n                    });\n\n  // Perform O(N^2) search over the gather sequences and merge identical\n  // instructions. TODO: We can further optimize this scan if we split the\n  // instructions into different buckets based on the insert lane.\n  SmallVector<Instruction *, 16> Visited;\n  for (auto I = CSEWorkList.begin(), E = CSEWorkList.end(); I != E; ++I) {\n    assert(*I &&\n           (I == CSEWorkList.begin() || !DT->dominates(*I, *std::prev(I))) &&\n           \"Worklist not sorted properly!\");\n    BasicBlock *BB = (*I)->getBlock();\n    // For all instructions in blocks containing gather sequences:\n    for (BasicBlock::iterator it = BB->begin(), e = BB->end(); it != e;) {\n      Instruction *In = &*it++;\n      if (isDeleted(In))\n        continue;\n      if (!isa<InsertElementInst>(In) && !isa<ExtractElementInst>(In))\n        continue;\n\n      // Check if we can replace this instruction with any of the\n      // visited instructions.\n      for (Instruction *v : Visited) {\n        if (In->isIdenticalTo(v) &&\n            DT->dominates(v->getParent(), In->getParent())) {\n          In->replaceAllUsesWith(v);\n          eraseInstruction(In);\n          In = nullptr;\n          break;\n        }\n      }\n      if (In) {\n        assert(!is_contained(Visited, In));\n        Visited.push_back(In);\n      }\n    }\n  }\n  CSEBlocks.clear();\n  GatherSeq.clear();\n}\n\n// Groups the instructions to a bundle (which is then a single scheduling entity)\n// and schedules instructions until the bundle gets ready.\nOptional<BoUpSLP::ScheduleData *>\nBoUpSLP::BlockScheduling::tryScheduleBundle(ArrayRef<Value *> VL, BoUpSLP *SLP,\n                                            const InstructionsState &S) {\n  if (isa<PHINode>(S.OpValue))\n    return nullptr;\n\n  // Initialize the instruction bundle.\n  Instruction *OldScheduleEnd = ScheduleEnd;\n  ScheduleData *PrevInBundle = nullptr;\n  ScheduleData *Bundle = nullptr;\n  bool ReSchedule = false;\n  LLVM_DEBUG(dbgs() << \"SLP:  bundle: \" << *S.OpValue << \"\\n\");\n\n  // Make sure that the scheduling region contains all\n  // instructions of the bundle.\n  for (Value *V : VL) {\n    if (!extendSchedulingRegion(V, S))\n      return None;\n  }\n\n  for (Value *V : VL) {\n    ScheduleData *BundleMember = getScheduleData(V);\n    assert(BundleMember &&\n           \"no ScheduleData for bundle member (maybe not in same basic block)\");\n    if (BundleMember->IsScheduled) {\n      // A bundle member was scheduled as single instruction before and now\n      // needs to be scheduled as part of the bundle. We just get rid of the\n      // existing schedule.\n      LLVM_DEBUG(dbgs() << \"SLP:  reset schedule because \" << *BundleMember\n                        << \" was already scheduled\\n\");\n      ReSchedule = true;\n    }\n    assert(BundleMember->isSchedulingEntity() &&\n           \"bundle member already part of other bundle\");\n    if (PrevInBundle) {\n      PrevInBundle->NextInBundle = BundleMember;\n    } else {\n      Bundle = BundleMember;\n    }\n    BundleMember->UnscheduledDepsInBundle = 0;\n    Bundle->UnscheduledDepsInBundle += BundleMember->UnscheduledDeps;\n\n    // Group the instructions to a bundle.\n    BundleMember->FirstInBundle = Bundle;\n    PrevInBundle = BundleMember;\n  }\n  if (ScheduleEnd != OldScheduleEnd) {\n    // The scheduling region got new instructions at the lower end (or it is a\n    // new region for the first bundle). This makes it necessary to\n    // recalculate all dependencies.\n    // It is seldom that this needs to be done a second time after adding the\n    // initial bundle to the region.\n    for (auto *I = ScheduleStart; I != ScheduleEnd; I = I->getNextNode()) {\n      doForAllOpcodes(I, [](ScheduleData *SD) {\n        SD->clearDependencies();\n      });\n    }\n    ReSchedule = true;\n  }\n  if (ReSchedule) {\n    resetSchedule();\n    initialFillReadyList(ReadyInsts);\n  }\n  assert(Bundle && \"Failed to find schedule bundle\");\n\n  LLVM_DEBUG(dbgs() << \"SLP: try schedule bundle \" << *Bundle << \" in block \"\n                    << BB->getName() << \"\\n\");\n\n  calculateDependencies(Bundle, true, SLP);\n\n  // Now try to schedule the new bundle. As soon as the bundle is \"ready\" it\n  // means that there are no cyclic dependencies and we can schedule it.\n  // Note that's important that we don't \"schedule\" the bundle yet (see\n  // cancelScheduling).\n  while (!Bundle->isReady() && !ReadyInsts.empty()) {\n\n    ScheduleData *pickedSD = ReadyInsts.pop_back_val();\n\n    if (pickedSD->isSchedulingEntity() && pickedSD->isReady()) {\n      schedule(pickedSD, ReadyInsts);\n    }\n  }\n  if (!Bundle->isReady()) {\n    cancelScheduling(VL, S.OpValue);\n    return None;\n  }\n  return Bundle;\n}\n\nvoid BoUpSLP::BlockScheduling::cancelScheduling(ArrayRef<Value *> VL,\n                                                Value *OpValue) {\n  if (isa<PHINode>(OpValue))\n    return;\n\n  ScheduleData *Bundle = getScheduleData(OpValue);\n  LLVM_DEBUG(dbgs() << \"SLP:  cancel scheduling of \" << *Bundle << \"\\n\");\n  assert(!Bundle->IsScheduled &&\n         \"Can't cancel bundle which is already scheduled\");\n  assert(Bundle->isSchedulingEntity() && Bundle->isPartOfBundle() &&\n         \"tried to unbundle something which is not a bundle\");\n\n  // Un-bundle: make single instructions out of the bundle.\n  ScheduleData *BundleMember = Bundle;\n  while (BundleMember) {\n    assert(BundleMember->FirstInBundle == Bundle && \"corrupt bundle links\");\n    BundleMember->FirstInBundle = BundleMember;\n    ScheduleData *Next = BundleMember->NextInBundle;\n    BundleMember->NextInBundle = nullptr;\n    BundleMember->UnscheduledDepsInBundle = BundleMember->UnscheduledDeps;\n    if (BundleMember->UnscheduledDepsInBundle == 0) {\n      ReadyInsts.insert(BundleMember);\n    }\n    BundleMember = Next;\n  }\n}\n\nBoUpSLP::ScheduleData *BoUpSLP::BlockScheduling::allocateScheduleDataChunks() {\n  // Allocate a new ScheduleData for the instruction.\n  if (ChunkPos >= ChunkSize) {\n    ScheduleDataChunks.push_back(std::make_unique<ScheduleData[]>(ChunkSize));\n    ChunkPos = 0;\n  }\n  return &(ScheduleDataChunks.back()[ChunkPos++]);\n}\n\nbool BoUpSLP::BlockScheduling::extendSchedulingRegion(Value *V,\n                                                      const InstructionsState &S) {\n  if (getScheduleData(V, isOneOf(S, V)))\n    return true;\n  Instruction *I = dyn_cast<Instruction>(V);\n  assert(I && \"bundle member must be an instruction\");\n  assert(!isa<PHINode>(I) && \"phi nodes don't need to be scheduled\");\n  auto &&CheckSheduleForI = [this, &S](Instruction *I) -> bool {\n    ScheduleData *ISD = getScheduleData(I);\n    if (!ISD)\n      return false;\n    assert(isInSchedulingRegion(ISD) &&\n           \"ScheduleData not in scheduling region\");\n    ScheduleData *SD = allocateScheduleDataChunks();\n    SD->Inst = I;\n    SD->init(SchedulingRegionID, S.OpValue);\n    ExtraScheduleDataMap[I][S.OpValue] = SD;\n    return true;\n  };\n  if (CheckSheduleForI(I))\n    return true;\n  if (!ScheduleStart) {\n    // It's the first instruction in the new region.\n    initScheduleData(I, I->getNextNode(), nullptr, nullptr);\n    ScheduleStart = I;\n    ScheduleEnd = I->getNextNode();\n    if (isOneOf(S, I) != I)\n      CheckSheduleForI(I);\n    assert(ScheduleEnd && \"tried to vectorize a terminator?\");\n    LLVM_DEBUG(dbgs() << \"SLP:  initialize schedule region to \" << *I << \"\\n\");\n    return true;\n  }\n  // Search up and down at the same time, because we don't know if the new\n  // instruction is above or below the existing scheduling region.\n  BasicBlock::reverse_iterator UpIter =\n      ++ScheduleStart->getIterator().getReverse();\n  BasicBlock::reverse_iterator UpperEnd = BB->rend();\n  BasicBlock::iterator DownIter = ScheduleEnd->getIterator();\n  BasicBlock::iterator LowerEnd = BB->end();\n  while (true) {\n    if (++ScheduleRegionSize > ScheduleRegionSizeLimit) {\n      LLVM_DEBUG(dbgs() << \"SLP:  exceeded schedule region size limit\\n\");\n      return false;\n    }\n\n    if (UpIter != UpperEnd) {\n      if (&*UpIter == I) {\n        initScheduleData(I, ScheduleStart, nullptr, FirstLoadStoreInRegion);\n        ScheduleStart = I;\n        if (isOneOf(S, I) != I)\n          CheckSheduleForI(I);\n        LLVM_DEBUG(dbgs() << \"SLP:  extend schedule region start to \" << *I\n                          << \"\\n\");\n        return true;\n      }\n      ++UpIter;\n    }\n    if (DownIter != LowerEnd) {\n      if (&*DownIter == I) {\n        initScheduleData(ScheduleEnd, I->getNextNode(), LastLoadStoreInRegion,\n                         nullptr);\n        ScheduleEnd = I->getNextNode();\n        if (isOneOf(S, I) != I)\n          CheckSheduleForI(I);\n        assert(ScheduleEnd && \"tried to vectorize a terminator?\");\n        LLVM_DEBUG(dbgs() << \"SLP:  extend schedule region end to \" << *I\n                          << \"\\n\");\n        return true;\n      }\n      ++DownIter;\n    }\n    assert((UpIter != UpperEnd || DownIter != LowerEnd) &&\n           \"instruction not found in block\");\n  }\n  return true;\n}\n\nvoid BoUpSLP::BlockScheduling::initScheduleData(Instruction *FromI,\n                                                Instruction *ToI,\n                                                ScheduleData *PrevLoadStore,\n                                                ScheduleData *NextLoadStore) {\n  ScheduleData *CurrentLoadStore = PrevLoadStore;\n  for (Instruction *I = FromI; I != ToI; I = I->getNextNode()) {\n    ScheduleData *SD = ScheduleDataMap[I];\n    if (!SD) {\n      SD = allocateScheduleDataChunks();\n      ScheduleDataMap[I] = SD;\n      SD->Inst = I;\n    }\n    assert(!isInSchedulingRegion(SD) &&\n           \"new ScheduleData already in scheduling region\");\n    SD->init(SchedulingRegionID, I);\n\n    if (I->mayReadOrWriteMemory() &&\n        (!isa<IntrinsicInst>(I) ||\n         (cast<IntrinsicInst>(I)->getIntrinsicID() != Intrinsic::sideeffect &&\n          cast<IntrinsicInst>(I)->getIntrinsicID() !=\n              Intrinsic::pseudoprobe))) {\n      // Update the linked list of memory accessing instructions.\n      if (CurrentLoadStore) {\n        CurrentLoadStore->NextLoadStore = SD;\n      } else {\n        FirstLoadStoreInRegion = SD;\n      }\n      CurrentLoadStore = SD;\n    }\n  }\n  if (NextLoadStore) {\n    if (CurrentLoadStore)\n      CurrentLoadStore->NextLoadStore = NextLoadStore;\n  } else {\n    LastLoadStoreInRegion = CurrentLoadStore;\n  }\n}\n\nvoid BoUpSLP::BlockScheduling::calculateDependencies(ScheduleData *SD,\n                                                     bool InsertInReadyList,\n                                                     BoUpSLP *SLP) {\n  assert(SD->isSchedulingEntity());\n\n  SmallVector<ScheduleData *, 10> WorkList;\n  WorkList.push_back(SD);\n\n  while (!WorkList.empty()) {\n    ScheduleData *SD = WorkList.pop_back_val();\n\n    ScheduleData *BundleMember = SD;\n    while (BundleMember) {\n      assert(isInSchedulingRegion(BundleMember));\n      if (!BundleMember->hasValidDependencies()) {\n\n        LLVM_DEBUG(dbgs() << \"SLP:       update deps of \" << *BundleMember\n                          << \"\\n\");\n        BundleMember->Dependencies = 0;\n        BundleMember->resetUnscheduledDeps();\n\n        // Handle def-use chain dependencies.\n        if (BundleMember->OpValue != BundleMember->Inst) {\n          ScheduleData *UseSD = getScheduleData(BundleMember->Inst);\n          if (UseSD && isInSchedulingRegion(UseSD->FirstInBundle)) {\n            BundleMember->Dependencies++;\n            ScheduleData *DestBundle = UseSD->FirstInBundle;\n            if (!DestBundle->IsScheduled)\n              BundleMember->incrementUnscheduledDeps(1);\n            if (!DestBundle->hasValidDependencies())\n              WorkList.push_back(DestBundle);\n          }\n        } else {\n          for (User *U : BundleMember->Inst->users()) {\n            if (isa<Instruction>(U)) {\n              ScheduleData *UseSD = getScheduleData(U);\n              if (UseSD && isInSchedulingRegion(UseSD->FirstInBundle)) {\n                BundleMember->Dependencies++;\n                ScheduleData *DestBundle = UseSD->FirstInBundle;\n                if (!DestBundle->IsScheduled)\n                  BundleMember->incrementUnscheduledDeps(1);\n                if (!DestBundle->hasValidDependencies())\n                  WorkList.push_back(DestBundle);\n              }\n            } else {\n              // I'm not sure if this can ever happen. But we need to be safe.\n              // This lets the instruction/bundle never be scheduled and\n              // eventually disable vectorization.\n              BundleMember->Dependencies++;\n              BundleMember->incrementUnscheduledDeps(1);\n            }\n          }\n        }\n\n        // Handle the memory dependencies.\n        ScheduleData *DepDest = BundleMember->NextLoadStore;\n        if (DepDest) {\n          Instruction *SrcInst = BundleMember->Inst;\n          MemoryLocation SrcLoc = getLocation(SrcInst, SLP->AA);\n          bool SrcMayWrite = BundleMember->Inst->mayWriteToMemory();\n          unsigned numAliased = 0;\n          unsigned DistToSrc = 1;\n\n          while (DepDest) {\n            assert(isInSchedulingRegion(DepDest));\n\n            // We have two limits to reduce the complexity:\n            // 1) AliasedCheckLimit: It's a small limit to reduce calls to\n            //    SLP->isAliased (which is the expensive part in this loop).\n            // 2) MaxMemDepDistance: It's for very large blocks and it aborts\n            //    the whole loop (even if the loop is fast, it's quadratic).\n            //    It's important for the loop break condition (see below) to\n            //    check this limit even between two read-only instructions.\n            if (DistToSrc >= MaxMemDepDistance ||\n                    ((SrcMayWrite || DepDest->Inst->mayWriteToMemory()) &&\n                     (numAliased >= AliasedCheckLimit ||\n                      SLP->isAliased(SrcLoc, SrcInst, DepDest->Inst)))) {\n\n              // We increment the counter only if the locations are aliased\n              // (instead of counting all alias checks). This gives a better\n              // balance between reduced runtime and accurate dependencies.\n              numAliased++;\n\n              DepDest->MemoryDependencies.push_back(BundleMember);\n              BundleMember->Dependencies++;\n              ScheduleData *DestBundle = DepDest->FirstInBundle;\n              if (!DestBundle->IsScheduled) {\n                BundleMember->incrementUnscheduledDeps(1);\n              }\n              if (!DestBundle->hasValidDependencies()) {\n                WorkList.push_back(DestBundle);\n              }\n            }\n            DepDest = DepDest->NextLoadStore;\n\n            // Example, explaining the loop break condition: Let's assume our\n            // starting instruction is i0 and MaxMemDepDistance = 3.\n            //\n            //                      +--------v--v--v\n            //             i0,i1,i2,i3,i4,i5,i6,i7,i8\n            //             +--------^--^--^\n            //\n            // MaxMemDepDistance let us stop alias-checking at i3 and we add\n            // dependencies from i0 to i3,i4,.. (even if they are not aliased).\n            // Previously we already added dependencies from i3 to i6,i7,i8\n            // (because of MaxMemDepDistance). As we added a dependency from\n            // i0 to i3, we have transitive dependencies from i0 to i6,i7,i8\n            // and we can abort this loop at i6.\n            if (DistToSrc >= 2 * MaxMemDepDistance)\n              break;\n            DistToSrc++;\n          }\n        }\n      }\n      BundleMember = BundleMember->NextInBundle;\n    }\n    if (InsertInReadyList && SD->isReady()) {\n      ReadyInsts.push_back(SD);\n      LLVM_DEBUG(dbgs() << \"SLP:     gets ready on update: \" << *SD->Inst\n                        << \"\\n\");\n    }\n  }\n}\n\nvoid BoUpSLP::BlockScheduling::resetSchedule() {\n  assert(ScheduleStart &&\n         \"tried to reset schedule on block which has not been scheduled\");\n  for (Instruction *I = ScheduleStart; I != ScheduleEnd; I = I->getNextNode()) {\n    doForAllOpcodes(I, [&](ScheduleData *SD) {\n      assert(isInSchedulingRegion(SD) &&\n             \"ScheduleData not in scheduling region\");\n      SD->IsScheduled = false;\n      SD->resetUnscheduledDeps();\n    });\n  }\n  ReadyInsts.clear();\n}\n\nvoid BoUpSLP::scheduleBlock(BlockScheduling *BS) {\n  if (!BS->ScheduleStart)\n    return;\n\n  LLVM_DEBUG(dbgs() << \"SLP: schedule block \" << BS->BB->getName() << \"\\n\");\n\n  BS->resetSchedule();\n\n  // For the real scheduling we use a more sophisticated ready-list: it is\n  // sorted by the original instruction location. This lets the final schedule\n  // be as  close as possible to the original instruction order.\n  struct ScheduleDataCompare {\n    bool operator()(ScheduleData *SD1, ScheduleData *SD2) const {\n      return SD2->SchedulingPriority < SD1->SchedulingPriority;\n    }\n  };\n  std::set<ScheduleData *, ScheduleDataCompare> ReadyInsts;\n\n  // Ensure that all dependency data is updated and fill the ready-list with\n  // initial instructions.\n  int Idx = 0;\n  int NumToSchedule = 0;\n  for (auto *I = BS->ScheduleStart; I != BS->ScheduleEnd;\n       I = I->getNextNode()) {\n    BS->doForAllOpcodes(I, [this, &Idx, &NumToSchedule, BS](ScheduleData *SD) {\n      assert(SD->isPartOfBundle() ==\n                 (getTreeEntry(SD->Inst) != nullptr) &&\n             \"scheduler and vectorizer bundle mismatch\");\n      SD->FirstInBundle->SchedulingPriority = Idx++;\n      if (SD->isSchedulingEntity()) {\n        BS->calculateDependencies(SD, false, this);\n        NumToSchedule++;\n      }\n    });\n  }\n  BS->initialFillReadyList(ReadyInsts);\n\n  Instruction *LastScheduledInst = BS->ScheduleEnd;\n\n  // Do the \"real\" scheduling.\n  while (!ReadyInsts.empty()) {\n    ScheduleData *picked = *ReadyInsts.begin();\n    ReadyInsts.erase(ReadyInsts.begin());\n\n    // Move the scheduled instruction(s) to their dedicated places, if not\n    // there yet.\n    ScheduleData *BundleMember = picked;\n    while (BundleMember) {\n      Instruction *pickedInst = BundleMember->Inst;\n      if (LastScheduledInst->getNextNode() != pickedInst) {\n        BS->BB->getInstList().remove(pickedInst);\n        BS->BB->getInstList().insert(LastScheduledInst->getIterator(),\n                                     pickedInst);\n      }\n      LastScheduledInst = pickedInst;\n      BundleMember = BundleMember->NextInBundle;\n    }\n\n    BS->schedule(picked, ReadyInsts);\n    NumToSchedule--;\n  }\n  assert(NumToSchedule == 0 && \"could not schedule all instructions\");\n\n  // Avoid duplicate scheduling of the block.\n  BS->ScheduleStart = nullptr;\n}\n\nunsigned BoUpSLP::getVectorElementSize(Value *V) {\n  // If V is a store, just return the width of the stored value (or value\n  // truncated just before storing) without traversing the expression tree.\n  // This is the common case.\n  if (auto *Store = dyn_cast<StoreInst>(V)) {\n    if (auto *Trunc = dyn_cast<TruncInst>(Store->getValueOperand()))\n      return DL->getTypeSizeInBits(Trunc->getSrcTy());\n    else\n      return DL->getTypeSizeInBits(Store->getValueOperand()->getType());\n  }\n\n  auto E = InstrElementSize.find(V);\n  if (E != InstrElementSize.end())\n    return E->second;\n\n  // If V is not a store, we can traverse the expression tree to find loads\n  // that feed it. The type of the loaded value may indicate a more suitable\n  // width than V's type. We want to base the vector element size on the width\n  // of memory operations where possible.\n  SmallVector<Instruction *, 16> Worklist;\n  SmallPtrSet<Instruction *, 16> Visited;\n  if (auto *I = dyn_cast<Instruction>(V)) {\n    Worklist.push_back(I);\n    Visited.insert(I);\n  }\n\n  // Traverse the expression tree in bottom-up order looking for loads. If we\n  // encounter an instruction we don't yet handle, we give up.\n  auto MaxWidth = 0u;\n  auto FoundUnknownInst = false;\n  while (!Worklist.empty() && !FoundUnknownInst) {\n    auto *I = Worklist.pop_back_val();\n\n    // We should only be looking at scalar instructions here. If the current\n    // instruction has a vector type, give up.\n    auto *Ty = I->getType();\n    if (isa<VectorType>(Ty))\n      FoundUnknownInst = true;\n\n    // If the current instruction is a load, update MaxWidth to reflect the\n    // width of the loaded value.\n    else if (isa<LoadInst>(I))\n      MaxWidth = std::max<unsigned>(MaxWidth, DL->getTypeSizeInBits(Ty));\n\n    // Otherwise, we need to visit the operands of the instruction. We only\n    // handle the interesting cases from buildTree here. If an operand is an\n    // instruction we haven't yet visited, we add it to the worklist.\n    else if (isa<PHINode>(I) || isa<CastInst>(I) || isa<GetElementPtrInst>(I) ||\n             isa<CmpInst>(I) || isa<SelectInst>(I) || isa<BinaryOperator>(I)) {\n      for (Use &U : I->operands())\n        if (auto *J = dyn_cast<Instruction>(U.get()))\n          if (Visited.insert(J).second)\n            Worklist.push_back(J);\n    }\n\n    // If we don't yet handle the instruction, give up.\n    else\n      FoundUnknownInst = true;\n  }\n\n  int Width = MaxWidth;\n  // If we didn't encounter a memory access in the expression tree, or if we\n  // gave up for some reason, just return the width of V. Otherwise, return the\n  // maximum width we found.\n  if (!MaxWidth || FoundUnknownInst)\n    Width = DL->getTypeSizeInBits(V->getType());\n\n  for (Instruction *I : Visited)\n    InstrElementSize[I] = Width;\n\n  return Width;\n}\n\n// Determine if a value V in a vectorizable expression Expr can be demoted to a\n// smaller type with a truncation. We collect the values that will be demoted\n// in ToDemote and additional roots that require investigating in Roots.\nstatic bool collectValuesToDemote(Value *V, SmallPtrSetImpl<Value *> &Expr,\n                                  SmallVectorImpl<Value *> &ToDemote,\n                                  SmallVectorImpl<Value *> &Roots) {\n  // We can always demote constants.\n  if (isa<Constant>(V)) {\n    ToDemote.push_back(V);\n    return true;\n  }\n\n  // If the value is not an instruction in the expression with only one use, it\n  // cannot be demoted.\n  auto *I = dyn_cast<Instruction>(V);\n  if (!I || !I->hasOneUse() || !Expr.count(I))\n    return false;\n\n  switch (I->getOpcode()) {\n\n  // We can always demote truncations and extensions. Since truncations can\n  // seed additional demotion, we save the truncated value.\n  case Instruction::Trunc:\n    Roots.push_back(I->getOperand(0));\n    break;\n  case Instruction::ZExt:\n  case Instruction::SExt:\n    break;\n\n  // We can demote certain binary operations if we can demote both of their\n  // operands.\n  case Instruction::Add:\n  case Instruction::Sub:\n  case Instruction::Mul:\n  case Instruction::And:\n  case Instruction::Or:\n  case Instruction::Xor:\n    if (!collectValuesToDemote(I->getOperand(0), Expr, ToDemote, Roots) ||\n        !collectValuesToDemote(I->getOperand(1), Expr, ToDemote, Roots))\n      return false;\n    break;\n\n  // We can demote selects if we can demote their true and false values.\n  case Instruction::Select: {\n    SelectInst *SI = cast<SelectInst>(I);\n    if (!collectValuesToDemote(SI->getTrueValue(), Expr, ToDemote, Roots) ||\n        !collectValuesToDemote(SI->getFalseValue(), Expr, ToDemote, Roots))\n      return false;\n    break;\n  }\n\n  // We can demote phis if we can demote all their incoming operands. Note that\n  // we don't need to worry about cycles since we ensure single use above.\n  case Instruction::PHI: {\n    PHINode *PN = cast<PHINode>(I);\n    for (Value *IncValue : PN->incoming_values())\n      if (!collectValuesToDemote(IncValue, Expr, ToDemote, Roots))\n        return false;\n    break;\n  }\n\n  // Otherwise, conservatively give up.\n  default:\n    return false;\n  }\n\n  // Record the value that we can demote.\n  ToDemote.push_back(V);\n  return true;\n}\n\nvoid BoUpSLP::computeMinimumValueSizes() {\n  // If there are no external uses, the expression tree must be rooted by a\n  // store. We can't demote in-memory values, so there is nothing to do here.\n  if (ExternalUses.empty())\n    return;\n\n  // We only attempt to truncate integer expressions.\n  auto &TreeRoot = VectorizableTree[0]->Scalars;\n  auto *TreeRootIT = dyn_cast<IntegerType>(TreeRoot[0]->getType());\n  if (!TreeRootIT)\n    return;\n\n  // If the expression is not rooted by a store, these roots should have\n  // external uses. We will rely on InstCombine to rewrite the expression in\n  // the narrower type. However, InstCombine only rewrites single-use values.\n  // This means that if a tree entry other than a root is used externally, it\n  // must have multiple uses and InstCombine will not rewrite it. The code\n  // below ensures that only the roots are used externally.\n  SmallPtrSet<Value *, 32> Expr(TreeRoot.begin(), TreeRoot.end());\n  for (auto &EU : ExternalUses)\n    if (!Expr.erase(EU.Scalar))\n      return;\n  if (!Expr.empty())\n    return;\n\n  // Collect the scalar values of the vectorizable expression. We will use this\n  // context to determine which values can be demoted. If we see a truncation,\n  // we mark it as seeding another demotion.\n  for (auto &EntryPtr : VectorizableTree)\n    Expr.insert(EntryPtr->Scalars.begin(), EntryPtr->Scalars.end());\n\n  // Ensure the roots of the vectorizable tree don't form a cycle. They must\n  // have a single external user that is not in the vectorizable tree.\n  for (auto *Root : TreeRoot)\n    if (!Root->hasOneUse() || Expr.count(*Root->user_begin()))\n      return;\n\n  // Conservatively determine if we can actually truncate the roots of the\n  // expression. Collect the values that can be demoted in ToDemote and\n  // additional roots that require investigating in Roots.\n  SmallVector<Value *, 32> ToDemote;\n  SmallVector<Value *, 4> Roots;\n  for (auto *Root : TreeRoot)\n    if (!collectValuesToDemote(Root, Expr, ToDemote, Roots))\n      return;\n\n  // The maximum bit width required to represent all the values that can be\n  // demoted without loss of precision. It would be safe to truncate the roots\n  // of the expression to this width.\n  auto MaxBitWidth = 8u;\n\n  // We first check if all the bits of the roots are demanded. If they're not,\n  // we can truncate the roots to this narrower type.\n  for (auto *Root : TreeRoot) {\n    auto Mask = DB->getDemandedBits(cast<Instruction>(Root));\n    MaxBitWidth = std::max<unsigned>(\n        Mask.getBitWidth() - Mask.countLeadingZeros(), MaxBitWidth);\n  }\n\n  // True if the roots can be zero-extended back to their original type, rather\n  // than sign-extended. We know that if the leading bits are not demanded, we\n  // can safely zero-extend. So we initialize IsKnownPositive to True.\n  bool IsKnownPositive = true;\n\n  // If all the bits of the roots are demanded, we can try a little harder to\n  // compute a narrower type. This can happen, for example, if the roots are\n  // getelementptr indices. InstCombine promotes these indices to the pointer\n  // width. Thus, all their bits are technically demanded even though the\n  // address computation might be vectorized in a smaller type.\n  //\n  // We start by looking at each entry that can be demoted. We compute the\n  // maximum bit width required to store the scalar by using ValueTracking to\n  // compute the number of high-order bits we can truncate.\n  if (MaxBitWidth == DL->getTypeSizeInBits(TreeRoot[0]->getType()) &&\n      llvm::all_of(TreeRoot, [](Value *R) {\n        assert(R->hasOneUse() && \"Root should have only one use!\");\n        return isa<GetElementPtrInst>(R->user_back());\n      })) {\n    MaxBitWidth = 8u;\n\n    // Determine if the sign bit of all the roots is known to be zero. If not,\n    // IsKnownPositive is set to False.\n    IsKnownPositive = llvm::all_of(TreeRoot, [&](Value *R) {\n      KnownBits Known = computeKnownBits(R, *DL);\n      return Known.isNonNegative();\n    });\n\n    // Determine the maximum number of bits required to store the scalar\n    // values.\n    for (auto *Scalar : ToDemote) {\n      auto NumSignBits = ComputeNumSignBits(Scalar, *DL, 0, AC, nullptr, DT);\n      auto NumTypeBits = DL->getTypeSizeInBits(Scalar->getType());\n      MaxBitWidth = std::max<unsigned>(NumTypeBits - NumSignBits, MaxBitWidth);\n    }\n\n    // If we can't prove that the sign bit is zero, we must add one to the\n    // maximum bit width to account for the unknown sign bit. This preserves\n    // the existing sign bit so we can safely sign-extend the root back to the\n    // original type. Otherwise, if we know the sign bit is zero, we will\n    // zero-extend the root instead.\n    //\n    // FIXME: This is somewhat suboptimal, as there will be cases where adding\n    //        one to the maximum bit width will yield a larger-than-necessary\n    //        type. In general, we need to add an extra bit only if we can't\n    //        prove that the upper bit of the original type is equal to the\n    //        upper bit of the proposed smaller type. If these two bits are the\n    //        same (either zero or one) we know that sign-extending from the\n    //        smaller type will result in the same value. Here, since we can't\n    //        yet prove this, we are just making the proposed smaller type\n    //        larger to ensure correctness.\n    if (!IsKnownPositive)\n      ++MaxBitWidth;\n  }\n\n  // Round MaxBitWidth up to the next power-of-two.\n  if (!isPowerOf2_64(MaxBitWidth))\n    MaxBitWidth = NextPowerOf2(MaxBitWidth);\n\n  // If the maximum bit width we compute is less than the with of the roots'\n  // type, we can proceed with the narrowing. Otherwise, do nothing.\n  if (MaxBitWidth >= TreeRootIT->getBitWidth())\n    return;\n\n  // If we can truncate the root, we must collect additional values that might\n  // be demoted as a result. That is, those seeded by truncations we will\n  // modify.\n  while (!Roots.empty())\n    collectValuesToDemote(Roots.pop_back_val(), Expr, ToDemote, Roots);\n\n  // Finally, map the values we can demote to the maximum bit with we computed.\n  for (auto *Scalar : ToDemote)\n    MinBWs[Scalar] = std::make_pair(MaxBitWidth, !IsKnownPositive);\n}\n\nnamespace {\n\n/// The SLPVectorizer Pass.\nstruct SLPVectorizer : public FunctionPass {\n  SLPVectorizerPass Impl;\n\n  /// Pass identification, replacement for typeid\n  static char ID;\n\n  explicit SLPVectorizer() : FunctionPass(ID) {\n    initializeSLPVectorizerPass(*PassRegistry::getPassRegistry());\n  }\n\n  bool doInitialization(Module &M) override {\n    return false;\n  }\n\n  bool runOnFunction(Function &F) override {\n    if (skipFunction(F))\n      return false;\n\n    auto *SE = &getAnalysis<ScalarEvolutionWrapperPass>().getSE();\n    auto *TTI = &getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);\n    auto *TLIP = getAnalysisIfAvailable<TargetLibraryInfoWrapperPass>();\n    auto *TLI = TLIP ? &TLIP->getTLI(F) : nullptr;\n    auto *AA = &getAnalysis<AAResultsWrapperPass>().getAAResults();\n    auto *LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();\n    auto *DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();\n    auto *AC = &getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);\n    auto *DB = &getAnalysis<DemandedBitsWrapperPass>().getDemandedBits();\n    auto *ORE = &getAnalysis<OptimizationRemarkEmitterWrapperPass>().getORE();\n\n    return Impl.runImpl(F, SE, TTI, TLI, AA, LI, DT, AC, DB, ORE);\n  }\n\n  void getAnalysisUsage(AnalysisUsage &AU) const override {\n    FunctionPass::getAnalysisUsage(AU);\n    AU.addRequired<AssumptionCacheTracker>();\n    AU.addRequired<ScalarEvolutionWrapperPass>();\n    AU.addRequired<AAResultsWrapperPass>();\n    AU.addRequired<TargetTransformInfoWrapperPass>();\n    AU.addRequired<LoopInfoWrapperPass>();\n    AU.addRequired<DominatorTreeWrapperPass>();\n    AU.addRequired<DemandedBitsWrapperPass>();\n    AU.addRequired<OptimizationRemarkEmitterWrapperPass>();\n    AU.addRequired<InjectTLIMappingsLegacy>();\n    AU.addPreserved<LoopInfoWrapperPass>();\n    AU.addPreserved<DominatorTreeWrapperPass>();\n    AU.addPreserved<AAResultsWrapperPass>();\n    AU.addPreserved<GlobalsAAWrapperPass>();\n    AU.setPreservesCFG();\n  }\n};\n\n} // end anonymous namespace\n\nPreservedAnalyses SLPVectorizerPass::run(Function &F, FunctionAnalysisManager &AM) {\n  auto *SE = &AM.getResult<ScalarEvolutionAnalysis>(F);\n  auto *TTI = &AM.getResult<TargetIRAnalysis>(F);\n  auto *TLI = AM.getCachedResult<TargetLibraryAnalysis>(F);\n  auto *AA = &AM.getResult<AAManager>(F);\n  auto *LI = &AM.getResult<LoopAnalysis>(F);\n  auto *DT = &AM.getResult<DominatorTreeAnalysis>(F);\n  auto *AC = &AM.getResult<AssumptionAnalysis>(F);\n  auto *DB = &AM.getResult<DemandedBitsAnalysis>(F);\n  auto *ORE = &AM.getResult<OptimizationRemarkEmitterAnalysis>(F);\n\n  bool Changed = runImpl(F, SE, TTI, TLI, AA, LI, DT, AC, DB, ORE);\n  if (!Changed)\n    return PreservedAnalyses::all();\n\n  PreservedAnalyses PA;\n  PA.preserveSet<CFGAnalyses>();\n  PA.preserve<AAManager>();\n  PA.preserve<GlobalsAA>();\n  return PA;\n}\n\nbool SLPVectorizerPass::runImpl(Function &F, ScalarEvolution *SE_,\n                                TargetTransformInfo *TTI_,\n                                TargetLibraryInfo *TLI_, AAResults *AA_,\n                                LoopInfo *LI_, DominatorTree *DT_,\n                                AssumptionCache *AC_, DemandedBits *DB_,\n                                OptimizationRemarkEmitter *ORE_) {\n  if (!RunSLPVectorization)\n    return false;\n  SE = SE_;\n  TTI = TTI_;\n  TLI = TLI_;\n  AA = AA_;\n  LI = LI_;\n  DT = DT_;\n  AC = AC_;\n  DB = DB_;\n  DL = &F.getParent()->getDataLayout();\n\n  Stores.clear();\n  GEPs.clear();\n  bool Changed = false;\n\n  // If the target claims to have no vector registers don't attempt\n  // vectorization.\n  if (!TTI->getNumberOfRegisters(TTI->getRegisterClassForType(true)))\n    return false;\n\n  // Don't vectorize when the attribute NoImplicitFloat is used.\n  if (F.hasFnAttribute(Attribute::NoImplicitFloat))\n    return false;\n\n  LLVM_DEBUG(dbgs() << \"SLP: Analyzing blocks in \" << F.getName() << \".\\n\");\n\n  // Use the bottom up slp vectorizer to construct chains that start with\n  // store instructions.\n  BoUpSLP R(&F, SE, TTI, TLI, AA, LI, DT, AC, DB, DL, ORE_);\n\n  // A general note: the vectorizer must use BoUpSLP::eraseInstruction() to\n  // delete instructions.\n\n  // Scan the blocks in the function in post order.\n  for (auto BB : post_order(&F.getEntryBlock())) {\n    collectSeedInstructions(BB);\n\n    // Vectorize trees that end at stores.\n    if (!Stores.empty()) {\n      LLVM_DEBUG(dbgs() << \"SLP: Found stores for \" << Stores.size()\n                        << \" underlying objects.\\n\");\n      Changed |= vectorizeStoreChains(R);\n    }\n\n    // Vectorize trees that end at reductions.\n    Changed |= vectorizeChainsInBlock(BB, R);\n\n    // Vectorize the index computations of getelementptr instructions. This\n    // is primarily intended to catch gather-like idioms ending at\n    // non-consecutive loads.\n    if (!GEPs.empty()) {\n      LLVM_DEBUG(dbgs() << \"SLP: Found GEPs for \" << GEPs.size()\n                        << \" underlying objects.\\n\");\n      Changed |= vectorizeGEPIndices(BB, R);\n    }\n  }\n\n  if (Changed) {\n    R.optimizeGatherSequence();\n    LLVM_DEBUG(dbgs() << \"SLP: vectorized \\\"\" << F.getName() << \"\\\"\\n\");\n  }\n  return Changed;\n}\n\nbool SLPVectorizerPass::vectorizeStoreChain(ArrayRef<Value *> Chain, BoUpSLP &R,\n                                            unsigned Idx) {\n  LLVM_DEBUG(dbgs() << \"SLP: Analyzing a store chain of length \" << Chain.size()\n                    << \"\\n\");\n  const unsigned Sz = R.getVectorElementSize(Chain[0]);\n  const unsigned MinVF = R.getMinVecRegSize() / Sz;\n  unsigned VF = Chain.size();\n\n  if (!isPowerOf2_32(Sz) || !isPowerOf2_32(VF) || VF < 2 || VF < MinVF)\n    return false;\n\n  LLVM_DEBUG(dbgs() << \"SLP: Analyzing \" << VF << \" stores at offset \" << Idx\n                    << \"\\n\");\n\n  R.buildTree(Chain);\n  Optional<ArrayRef<unsigned>> Order = R.bestOrder();\n  // TODO: Handle orders of size less than number of elements in the vector.\n  if (Order && Order->size() == Chain.size()) {\n    // TODO: reorder tree nodes without tree rebuilding.\n    SmallVector<Value *, 4> ReorderedOps(Chain.rbegin(), Chain.rend());\n    llvm::transform(*Order, ReorderedOps.begin(),\n                    [Chain](const unsigned Idx) { return Chain[Idx]; });\n    R.buildTree(ReorderedOps);\n  }\n  if (R.isTreeTinyAndNotFullyVectorizable())\n    return false;\n  if (R.isLoadCombineCandidate())\n    return false;\n\n  R.computeMinimumValueSizes();\n\n  InstructionCost Cost = R.getTreeCost();\n\n  LLVM_DEBUG(dbgs() << \"SLP: Found cost = \" << Cost << \" for VF =\" << VF << \"\\n\");\n  if (Cost < -SLPCostThreshold) {\n    LLVM_DEBUG(dbgs() << \"SLP: Decided to vectorize cost = \" << Cost << \"\\n\");\n\n    using namespace ore;\n\n    R.getORE()->emit(OptimizationRemark(SV_NAME, \"StoresVectorized\",\n                                        cast<StoreInst>(Chain[0]))\n                     << \"Stores SLP vectorized with cost \" << NV(\"Cost\", Cost)\n                     << \" and with tree size \"\n                     << NV(\"TreeSize\", R.getTreeSize()));\n\n    R.vectorizeTree();\n    return true;\n  }\n\n  return false;\n}\n\nbool SLPVectorizerPass::vectorizeStores(ArrayRef<StoreInst *> Stores,\n                                        BoUpSLP &R) {\n  // We may run into multiple chains that merge into a single chain. We mark the\n  // stores that we vectorized so that we don't visit the same store twice.\n  BoUpSLP::ValueSet VectorizedStores;\n  bool Changed = false;\n\n  int E = Stores.size();\n  SmallBitVector Tails(E, false);\n  SmallVector<int, 16> ConsecutiveChain(E, E + 1);\n  int MaxIter = MaxStoreLookup.getValue();\n  int IterCnt;\n  auto &&FindConsecutiveAccess = [this, &Stores, &Tails, &IterCnt, MaxIter,\n                                  &ConsecutiveChain](int K, int Idx) {\n    if (IterCnt >= MaxIter)\n      return true;\n    ++IterCnt;\n    if (!isConsecutiveAccess(Stores[K], Stores[Idx], *DL, *SE))\n      return false;\n\n    Tails.set(Idx);\n    ConsecutiveChain[K] = Idx;\n    return true;\n  };\n  // Do a quadratic search on all of the given stores in reverse order and find\n  // all of the pairs of stores that follow each other.\n  for (int Idx = E - 1; Idx >= 0; --Idx) {\n    // If a store has multiple consecutive store candidates, search according\n    // to the sequence: Idx-1, Idx+1, Idx-2, Idx+2, ...\n    // This is because usually pairing with immediate succeeding or preceding\n    // candidate create the best chance to find slp vectorization opportunity.\n    const int MaxLookDepth = std::max(E - Idx, Idx + 1);\n    IterCnt = 0;\n    for (int Offset = 1, F = MaxLookDepth; Offset < F; ++Offset)\n      if ((Idx >= Offset && FindConsecutiveAccess(Idx - Offset, Idx)) ||\n          (Idx + Offset < E && FindConsecutiveAccess(Idx + Offset, Idx)))\n        break;\n  }\n\n  // For stores that start but don't end a link in the chain:\n  for (int Cnt = E; Cnt > 0; --Cnt) {\n    int I = Cnt - 1;\n    if (ConsecutiveChain[I] == E + 1 || Tails.test(I))\n      continue;\n    // We found a store instr that starts a chain. Now follow the chain and try\n    // to vectorize it.\n    BoUpSLP::ValueList Operands;\n    // Collect the chain into a list.\n    while (I != E + 1 && !VectorizedStores.count(Stores[I])) {\n      Operands.push_back(Stores[I]);\n      // Move to the next value in the chain.\n      I = ConsecutiveChain[I];\n    }\n\n    // If a vector register can't hold 1 element, we are done.\n    unsigned MaxVecRegSize = R.getMaxVecRegSize();\n    unsigned EltSize = R.getVectorElementSize(Operands[0]);\n    if (MaxVecRegSize % EltSize != 0)\n      continue;\n\n    unsigned MaxElts = MaxVecRegSize / EltSize;\n    // FIXME: Is division-by-2 the correct step? Should we assert that the\n    // register size is a power-of-2?\n    unsigned StartIdx = 0;\n    for (unsigned Size = llvm::PowerOf2Ceil(MaxElts); Size >= 2; Size /= 2) {\n      for (unsigned Cnt = StartIdx, E = Operands.size(); Cnt + Size <= E;) {\n        ArrayRef<Value *> Slice = makeArrayRef(Operands).slice(Cnt, Size);\n        if (!VectorizedStores.count(Slice.front()) &&\n            !VectorizedStores.count(Slice.back()) &&\n            vectorizeStoreChain(Slice, R, Cnt)) {\n          // Mark the vectorized stores so that we don't vectorize them again.\n          VectorizedStores.insert(Slice.begin(), Slice.end());\n          Changed = true;\n          // If we vectorized initial block, no need to try to vectorize it\n          // again.\n          if (Cnt == StartIdx)\n            StartIdx += Size;\n          Cnt += Size;\n          continue;\n        }\n        ++Cnt;\n      }\n      // Check if the whole array was vectorized already - exit.\n      if (StartIdx >= Operands.size())\n        break;\n    }\n  }\n\n  return Changed;\n}\n\nvoid SLPVectorizerPass::collectSeedInstructions(BasicBlock *BB) {\n  // Initialize the collections. We will make a single pass over the block.\n  Stores.clear();\n  GEPs.clear();\n\n  // Visit the store and getelementptr instructions in BB and organize them in\n  // Stores and GEPs according to the underlying objects of their pointer\n  // operands.\n  for (Instruction &I : *BB) {\n    // Ignore store instructions that are volatile or have a pointer operand\n    // that doesn't point to a scalar type.\n    if (auto *SI = dyn_cast<StoreInst>(&I)) {\n      if (!SI->isSimple())\n        continue;\n      if (!isValidElementType(SI->getValueOperand()->getType()))\n        continue;\n      Stores[getUnderlyingObject(SI->getPointerOperand())].push_back(SI);\n    }\n\n    // Ignore getelementptr instructions that have more than one index, a\n    // constant index, or a pointer operand that doesn't point to a scalar\n    // type.\n    else if (auto *GEP = dyn_cast<GetElementPtrInst>(&I)) {\n      auto Idx = GEP->idx_begin()->get();\n      if (GEP->getNumIndices() > 1 || isa<Constant>(Idx))\n        continue;\n      if (!isValidElementType(Idx->getType()))\n        continue;\n      if (GEP->getType()->isVectorTy())\n        continue;\n      GEPs[GEP->getPointerOperand()].push_back(GEP);\n    }\n  }\n}\n\nbool SLPVectorizerPass::tryToVectorizePair(Value *A, Value *B, BoUpSLP &R) {\n  if (!A || !B)\n    return false;\n  Value *VL[] = {A, B};\n  return tryToVectorizeList(VL, R, /*AllowReorder=*/true);\n}\n\nbool SLPVectorizerPass::tryToVectorizeList(ArrayRef<Value *> VL, BoUpSLP &R,\n                                           bool AllowReorder,\n                                           ArrayRef<Value *> InsertUses) {\n  if (VL.size() < 2)\n    return false;\n\n  LLVM_DEBUG(dbgs() << \"SLP: Trying to vectorize a list of length = \"\n                    << VL.size() << \".\\n\");\n\n  // Check that all of the parts are instructions of the same type,\n  // we permit an alternate opcode via InstructionsState.\n  InstructionsState S = getSameOpcode(VL);\n  if (!S.getOpcode())\n    return false;\n\n  Instruction *I0 = cast<Instruction>(S.OpValue);\n  // Make sure invalid types (including vector type) are rejected before\n  // determining vectorization factor for scalar instructions.\n  for (Value *V : VL) {\n    Type *Ty = V->getType();\n    if (!isValidElementType(Ty)) {\n      // NOTE: the following will give user internal llvm type name, which may\n      // not be useful.\n      R.getORE()->emit([&]() {\n        std::string type_str;\n        llvm::raw_string_ostream rso(type_str);\n        Ty->print(rso);\n        return OptimizationRemarkMissed(SV_NAME, \"UnsupportedType\", I0)\n               << \"Cannot SLP vectorize list: type \"\n               << rso.str() + \" is unsupported by vectorizer\";\n      });\n      return false;\n    }\n  }\n\n  unsigned Sz = R.getVectorElementSize(I0);\n  unsigned MinVF = std::max(2U, R.getMinVecRegSize() / Sz);\n  unsigned MaxVF = std::max<unsigned>(PowerOf2Floor(VL.size()), MinVF);\n  MaxVF = std::min(R.getMaximumVF(Sz, S.getOpcode()), MaxVF);\n  if (MaxVF < 2) {\n    R.getORE()->emit([&]() {\n      return OptimizationRemarkMissed(SV_NAME, \"SmallVF\", I0)\n             << \"Cannot SLP vectorize list: vectorization factor \"\n             << \"less than 2 is not supported\";\n    });\n    return false;\n  }\n\n  bool Changed = false;\n  bool CandidateFound = false;\n  InstructionCost MinCost = SLPCostThreshold.getValue();\n\n  bool CompensateUseCost =\n      !InsertUses.empty() && llvm::all_of(InsertUses, [](const Value *V) {\n        return V && isa<InsertElementInst>(V);\n      });\n  assert((!CompensateUseCost || InsertUses.size() == VL.size()) &&\n         \"Each scalar expected to have an associated InsertElement user.\");\n\n  unsigned NextInst = 0, MaxInst = VL.size();\n  for (unsigned VF = MaxVF; NextInst + 1 < MaxInst && VF >= MinVF; VF /= 2) {\n    // No actual vectorization should happen, if number of parts is the same as\n    // provided vectorization factor (i.e. the scalar type is used for vector\n    // code during codegen).\n    auto *VecTy = FixedVectorType::get(VL[0]->getType(), VF);\n    if (TTI->getNumberOfParts(VecTy) == VF)\n      continue;\n    for (unsigned I = NextInst; I < MaxInst; ++I) {\n      unsigned OpsWidth = 0;\n\n      if (I + VF > MaxInst)\n        OpsWidth = MaxInst - I;\n      else\n        OpsWidth = VF;\n\n      if (!isPowerOf2_32(OpsWidth) || OpsWidth < 2)\n        break;\n\n      ArrayRef<Value *> Ops = VL.slice(I, OpsWidth);\n      // Check that a previous iteration of this loop did not delete the Value.\n      if (llvm::any_of(Ops, [&R](Value *V) {\n            auto *I = dyn_cast<Instruction>(V);\n            return I && R.isDeleted(I);\n          }))\n        continue;\n\n      LLVM_DEBUG(dbgs() << \"SLP: Analyzing \" << OpsWidth << \" operations \"\n                        << \"\\n\");\n\n      R.buildTree(Ops);\n      Optional<ArrayRef<unsigned>> Order = R.bestOrder();\n      // TODO: check if we can allow reordering for more cases.\n      if (AllowReorder && Order) {\n        // TODO: reorder tree nodes without tree rebuilding.\n        // Conceptually, there is nothing actually preventing us from trying to\n        // reorder a larger list. In fact, we do exactly this when vectorizing\n        // reductions. However, at this point, we only expect to get here when\n        // there are exactly two operations.\n        assert(Ops.size() == 2);\n        Value *ReorderedOps[] = {Ops[1], Ops[0]};\n        R.buildTree(ReorderedOps, None);\n      }\n      if (R.isTreeTinyAndNotFullyVectorizable())\n        continue;\n\n      R.computeMinimumValueSizes();\n      InstructionCost Cost = R.getTreeCost();\n      CandidateFound = true;\n      if (CompensateUseCost) {\n        // TODO: Use TTI's getScalarizationOverhead for sequence of inserts\n        // rather than sum of single inserts as the latter may overestimate\n        // cost. This work should imply improving cost estimation for extracts\n        // that added in for external (for vectorization tree) users,i.e. that\n        // part should also switch to same interface.\n        // For example, the following case is projected code after SLP:\n        //  %4 = extractelement <4 x i64> %3, i32 0\n        //  %v0 = insertelement <4 x i64> poison, i64 %4, i32 0\n        //  %5 = extractelement <4 x i64> %3, i32 1\n        //  %v1 = insertelement <4 x i64> %v0, i64 %5, i32 1\n        //  %6 = extractelement <4 x i64> %3, i32 2\n        //  %v2 = insertelement <4 x i64> %v1, i64 %6, i32 2\n        //  %7 = extractelement <4 x i64> %3, i32 3\n        //  %v3 = insertelement <4 x i64> %v2, i64 %7, i32 3\n        //\n        // Extracts here added by SLP in order to feed users (the inserts) of\n        // original scalars and contribute to \"ExtractCost\" at cost evaluation.\n        // The inserts in turn form sequence to build an aggregate that\n        // detected by findBuildAggregate routine.\n        // SLP makes an assumption that such sequence will be optimized away\n        // later (instcombine) so it tries to compensate ExctractCost with\n        // cost of insert sequence.\n        // Current per element cost calculation approach is not quite accurate\n        // and tends to create bias toward favoring vectorization.\n        // Switching to the TTI interface might help a bit.\n        // Alternative solution could be pattern-match to detect a no-op or\n        // shuffle.\n        InstructionCost UserCost = 0;\n        for (unsigned Lane = 0; Lane < OpsWidth; Lane++) {\n          auto *IE = cast<InsertElementInst>(InsertUses[I + Lane]);\n          if (auto *CI = dyn_cast<ConstantInt>(IE->getOperand(2)))\n            UserCost += TTI->getVectorInstrCost(\n                Instruction::InsertElement, IE->getType(), CI->getZExtValue());\n        }\n        LLVM_DEBUG(dbgs() << \"SLP: Compensate cost of users by: \" << UserCost\n                          << \".\\n\");\n        Cost -= UserCost;\n      }\n\n      MinCost = std::min(MinCost, Cost);\n\n      if (Cost < -SLPCostThreshold) {\n        LLVM_DEBUG(dbgs() << \"SLP: Vectorizing list at cost:\" << Cost << \".\\n\");\n        R.getORE()->emit(OptimizationRemark(SV_NAME, \"VectorizedList\",\n                                                    cast<Instruction>(Ops[0]))\n                                 << \"SLP vectorized with cost \" << ore::NV(\"Cost\", Cost)\n                                 << \" and with tree size \"\n                                 << ore::NV(\"TreeSize\", R.getTreeSize()));\n\n        R.vectorizeTree();\n        // Move to the next bundle.\n        I += VF - 1;\n        NextInst = I + 1;\n        Changed = true;\n      }\n    }\n  }\n\n  if (!Changed && CandidateFound) {\n    R.getORE()->emit([&]() {\n      return OptimizationRemarkMissed(SV_NAME, \"NotBeneficial\", I0)\n             << \"List vectorization was possible but not beneficial with cost \"\n             << ore::NV(\"Cost\", MinCost) << \" >= \"\n             << ore::NV(\"Treshold\", -SLPCostThreshold);\n    });\n  } else if (!Changed) {\n    R.getORE()->emit([&]() {\n      return OptimizationRemarkMissed(SV_NAME, \"NotPossible\", I0)\n             << \"Cannot SLP vectorize list: vectorization was impossible\"\n             << \" with available vectorization factors\";\n    });\n  }\n  return Changed;\n}\n\nbool SLPVectorizerPass::tryToVectorize(Instruction *I, BoUpSLP &R) {\n  if (!I)\n    return false;\n\n  if (!isa<BinaryOperator>(I) && !isa<CmpInst>(I))\n    return false;\n\n  Value *P = I->getParent();\n\n  // Vectorize in current basic block only.\n  auto *Op0 = dyn_cast<Instruction>(I->getOperand(0));\n  auto *Op1 = dyn_cast<Instruction>(I->getOperand(1));\n  if (!Op0 || !Op1 || Op0->getParent() != P || Op1->getParent() != P)\n    return false;\n\n  // Try to vectorize V.\n  if (tryToVectorizePair(Op0, Op1, R))\n    return true;\n\n  auto *A = dyn_cast<BinaryOperator>(Op0);\n  auto *B = dyn_cast<BinaryOperator>(Op1);\n  // Try to skip B.\n  if (B && B->hasOneUse()) {\n    auto *B0 = dyn_cast<BinaryOperator>(B->getOperand(0));\n    auto *B1 = dyn_cast<BinaryOperator>(B->getOperand(1));\n    if (B0 && B0->getParent() == P && tryToVectorizePair(A, B0, R))\n      return true;\n    if (B1 && B1->getParent() == P && tryToVectorizePair(A, B1, R))\n      return true;\n  }\n\n  // Try to skip A.\n  if (A && A->hasOneUse()) {\n    auto *A0 = dyn_cast<BinaryOperator>(A->getOperand(0));\n    auto *A1 = dyn_cast<BinaryOperator>(A->getOperand(1));\n    if (A0 && A0->getParent() == P && tryToVectorizePair(A0, B, R))\n      return true;\n    if (A1 && A1->getParent() == P && tryToVectorizePair(A1, B, R))\n      return true;\n  }\n  return false;\n}\n\nnamespace {\n\n/// Model horizontal reductions.\n///\n/// A horizontal reduction is a tree of reduction instructions that has values\n/// that can be put into a vector as its leaves. For example:\n///\n/// mul mul mul mul\n///  \\  /    \\  /\n///   +       +\n///    \\     /\n///       +\n/// This tree has \"mul\" as its leaf values and \"+\" as its reduction\n/// instructions. A reduction can feed into a store or a binary operation\n/// feeding a phi.\n///    ...\n///    \\  /\n///     +\n///     |\n///  phi +=\n///\n///  Or:\n///    ...\n///    \\  /\n///     +\n///     |\n///   *p =\n///\nclass HorizontalReduction {\n  using ReductionOpsType = SmallVector<Value *, 16>;\n  using ReductionOpsListType = SmallVector<ReductionOpsType, 2>;\n  ReductionOpsListType ReductionOps;\n  SmallVector<Value *, 32> ReducedVals;\n  // Use map vector to make stable output.\n  MapVector<Instruction *, Value *> ExtraArgs;\n  WeakTrackingVH ReductionRoot;\n  /// The type of reduction operation.\n  RecurKind RdxKind;\n\n  /// Checks if instruction is associative and can be vectorized.\n  static bool isVectorizable(RecurKind Kind, Instruction *I) {\n    if (Kind == RecurKind::None)\n      return false;\n    if (RecurrenceDescriptor::isIntMinMaxRecurrenceKind(Kind))\n      return true;\n\n    if (Kind == RecurKind::FMax || Kind == RecurKind::FMin) {\n      // FP min/max are associative except for NaN and -0.0. We do not\n      // have to rule out -0.0 here because the intrinsic semantics do not\n      // specify a fixed result for it.\n      return I->getFastMathFlags().noNaNs();\n    }\n\n    return I->isAssociative();\n  }\n\n  /// Checks if the ParentStackElem.first should be marked as a reduction\n  /// operation with an extra argument or as extra argument itself.\n  void markExtraArg(std::pair<Instruction *, unsigned> &ParentStackElem,\n                    Value *ExtraArg) {\n    if (ExtraArgs.count(ParentStackElem.first)) {\n      ExtraArgs[ParentStackElem.first] = nullptr;\n      // We ran into something like:\n      // ParentStackElem.first = ExtraArgs[ParentStackElem.first] + ExtraArg.\n      // The whole ParentStackElem.first should be considered as an extra value\n      // in this case.\n      // Do not perform analysis of remaining operands of ParentStackElem.first\n      // instruction, this whole instruction is an extra argument.\n      RecurKind ParentRdxKind = getRdxKind(ParentStackElem.first);\n      ParentStackElem.second = getNumberOfOperands(ParentRdxKind);\n    } else {\n      // We ran into something like:\n      // ParentStackElem.first += ... + ExtraArg + ...\n      ExtraArgs[ParentStackElem.first] = ExtraArg;\n    }\n  }\n\n  /// Creates reduction operation with the current opcode.\n  static Value *createOp(IRBuilder<> &Builder, RecurKind Kind, Value *LHS,\n                         Value *RHS, const Twine &Name) {\n    unsigned RdxOpcode = RecurrenceDescriptor::getOpcode(Kind);\n    switch (Kind) {\n    case RecurKind::Add:\n    case RecurKind::Mul:\n    case RecurKind::Or:\n    case RecurKind::And:\n    case RecurKind::Xor:\n    case RecurKind::FAdd:\n    case RecurKind::FMul:\n      return Builder.CreateBinOp((Instruction::BinaryOps)RdxOpcode, LHS, RHS,\n                                 Name);\n    case RecurKind::FMax:\n      return Builder.CreateBinaryIntrinsic(Intrinsic::maxnum, LHS, RHS);\n    case RecurKind::FMin:\n      return Builder.CreateBinaryIntrinsic(Intrinsic::minnum, LHS, RHS);\n\n    case RecurKind::SMax: {\n      Value *Cmp = Builder.CreateICmpSGT(LHS, RHS, Name);\n      return Builder.CreateSelect(Cmp, LHS, RHS, Name);\n    }\n    case RecurKind::SMin: {\n      Value *Cmp = Builder.CreateICmpSLT(LHS, RHS, Name);\n      return Builder.CreateSelect(Cmp, LHS, RHS, Name);\n    }\n    case RecurKind::UMax: {\n      Value *Cmp = Builder.CreateICmpUGT(LHS, RHS, Name);\n      return Builder.CreateSelect(Cmp, LHS, RHS, Name);\n    }\n    case RecurKind::UMin: {\n      Value *Cmp = Builder.CreateICmpULT(LHS, RHS, Name);\n      return Builder.CreateSelect(Cmp, LHS, RHS, Name);\n    }\n    default:\n      llvm_unreachable(\"Unknown reduction operation.\");\n    }\n  }\n\n  /// Creates reduction operation with the current opcode with the IR flags\n  /// from \\p ReductionOps.\n  static Value *createOp(IRBuilder<> &Builder, RecurKind RdxKind, Value *LHS,\n                         Value *RHS, const Twine &Name,\n                         const ReductionOpsListType &ReductionOps) {\n    Value *Op = createOp(Builder, RdxKind, LHS, RHS, Name);\n    if (RecurrenceDescriptor::isIntMinMaxRecurrenceKind(RdxKind)) {\n      if (auto *Sel = dyn_cast<SelectInst>(Op))\n        propagateIRFlags(Sel->getCondition(), ReductionOps[0]);\n      propagateIRFlags(Op, ReductionOps[1]);\n      return Op;\n    }\n    propagateIRFlags(Op, ReductionOps[0]);\n    return Op;\n  }\n  /// Creates reduction operation with the current opcode with the IR flags\n  /// from \\p I.\n  static Value *createOp(IRBuilder<> &Builder, RecurKind RdxKind, Value *LHS,\n                         Value *RHS, const Twine &Name, Instruction *I) {\n    Value *Op = createOp(Builder, RdxKind, LHS, RHS, Name);\n    if (RecurrenceDescriptor::isIntMinMaxRecurrenceKind(RdxKind)) {\n      if (auto *Sel = dyn_cast<SelectInst>(Op)) {\n        propagateIRFlags(Sel->getCondition(),\n                         cast<SelectInst>(I)->getCondition());\n      }\n    }\n    propagateIRFlags(Op, I);\n    return Op;\n  }\n\n  static RecurKind getRdxKind(Instruction *I) {\n    assert(I && \"Expected instruction for reduction matching\");\n    TargetTransformInfo::ReductionFlags RdxFlags;\n    if (match(I, m_Add(m_Value(), m_Value())))\n      return RecurKind::Add;\n    if (match(I, m_Mul(m_Value(), m_Value())))\n      return RecurKind::Mul;\n    if (match(I, m_And(m_Value(), m_Value())))\n      return RecurKind::And;\n    if (match(I, m_Or(m_Value(), m_Value())))\n      return RecurKind::Or;\n    if (match(I, m_Xor(m_Value(), m_Value())))\n      return RecurKind::Xor;\n    if (match(I, m_FAdd(m_Value(), m_Value())))\n      return RecurKind::FAdd;\n    if (match(I, m_FMul(m_Value(), m_Value())))\n      return RecurKind::FMul;\n\n    if (match(I, m_Intrinsic<Intrinsic::maxnum>(m_Value(), m_Value())))\n      return RecurKind::FMax;\n    if (match(I, m_Intrinsic<Intrinsic::minnum>(m_Value(), m_Value())))\n      return RecurKind::FMin;\n\n    if (match(I, m_SMax(m_Value(), m_Value())))\n      return RecurKind::SMax;\n    if (match(I, m_SMin(m_Value(), m_Value())))\n      return RecurKind::SMin;\n    if (match(I, m_UMax(m_Value(), m_Value())))\n      return RecurKind::UMax;\n    if (match(I, m_UMin(m_Value(), m_Value())))\n      return RecurKind::UMin;\n\n    if (auto *Select = dyn_cast<SelectInst>(I)) {\n      // Try harder: look for min/max pattern based on instructions producing\n      // same values such as: select ((cmp Inst1, Inst2), Inst1, Inst2).\n      // During the intermediate stages of SLP, it's very common to have\n      // pattern like this (since optimizeGatherSequence is run only once\n      // at the end):\n      // %1 = extractelement <2 x i32> %a, i32 0\n      // %2 = extractelement <2 x i32> %a, i32 1\n      // %cond = icmp sgt i32 %1, %2\n      // %3 = extractelement <2 x i32> %a, i32 0\n      // %4 = extractelement <2 x i32> %a, i32 1\n      // %select = select i1 %cond, i32 %3, i32 %4\n      CmpInst::Predicate Pred;\n      Instruction *L1;\n      Instruction *L2;\n\n      Value *LHS = Select->getTrueValue();\n      Value *RHS = Select->getFalseValue();\n      Value *Cond = Select->getCondition();\n\n      // TODO: Support inverse predicates.\n      if (match(Cond, m_Cmp(Pred, m_Specific(LHS), m_Instruction(L2)))) {\n        if (!isa<ExtractElementInst>(RHS) ||\n            !L2->isIdenticalTo(cast<Instruction>(RHS)))\n          return RecurKind::None;\n      } else if (match(Cond, m_Cmp(Pred, m_Instruction(L1), m_Specific(RHS)))) {\n        if (!isa<ExtractElementInst>(LHS) ||\n            !L1->isIdenticalTo(cast<Instruction>(LHS)))\n          return RecurKind::None;\n      } else {\n        if (!isa<ExtractElementInst>(LHS) || !isa<ExtractElementInst>(RHS))\n          return RecurKind::None;\n        if (!match(Cond, m_Cmp(Pred, m_Instruction(L1), m_Instruction(L2))) ||\n            !L1->isIdenticalTo(cast<Instruction>(LHS)) ||\n            !L2->isIdenticalTo(cast<Instruction>(RHS)))\n          return RecurKind::None;\n      }\n\n      TargetTransformInfo::ReductionFlags RdxFlags;\n      switch (Pred) {\n      default:\n        return RecurKind::None;\n      case CmpInst::ICMP_SGT:\n      case CmpInst::ICMP_SGE:\n        return RecurKind::SMax;\n      case CmpInst::ICMP_SLT:\n      case CmpInst::ICMP_SLE:\n        return RecurKind::SMin;\n      case CmpInst::ICMP_UGT:\n      case CmpInst::ICMP_UGE:\n        return RecurKind::UMax;\n      case CmpInst::ICMP_ULT:\n      case CmpInst::ICMP_ULE:\n        return RecurKind::UMin;\n      }\n    }\n    return RecurKind::None;\n  }\n\n  /// Return true if this operation is a cmp+select idiom.\n  static bool isCmpSel(RecurKind Kind) {\n    return RecurrenceDescriptor::isIntMinMaxRecurrenceKind(Kind);\n  }\n\n  /// Get the index of the first operand.\n  static unsigned getFirstOperandIndex(RecurKind Kind) {\n    // We allow calling this before 'Kind' is set, so handle that specially.\n    if (Kind == RecurKind::None)\n      return 0;\n    return isCmpSel(Kind) ? 1 : 0;\n  }\n\n  /// Total number of operands in the reduction operation.\n  static unsigned getNumberOfOperands(RecurKind Kind) {\n    return isCmpSel(Kind) ? 3 : 2;\n  }\n\n  /// Checks if the instruction is in basic block \\p BB.\n  /// For a min/max reduction check that both compare and select are in \\p BB.\n  static bool hasSameParent(RecurKind Kind, Instruction *I, BasicBlock *BB,\n                            bool IsRedOp) {\n    if (IsRedOp && isCmpSel(Kind)) {\n      auto *Cmp = cast<Instruction>(cast<SelectInst>(I)->getCondition());\n      return I->getParent() == BB && Cmp && Cmp->getParent() == BB;\n    }\n    return I->getParent() == BB;\n  }\n\n  /// Expected number of uses for reduction operations/reduced values.\n  static bool hasRequiredNumberOfUses(RecurKind Kind, Instruction *I,\n                                      bool IsReductionOp) {\n    // SelectInst must be used twice while the condition op must have single\n    // use only.\n    if (isCmpSel(Kind))\n      return I->hasNUses(2) &&\n             (!IsReductionOp ||\n              cast<SelectInst>(I)->getCondition()->hasOneUse());\n\n    // Arithmetic reduction operation must be used once only.\n    return I->hasOneUse();\n  }\n\n  /// Initializes the list of reduction operations.\n  void initReductionOps(RecurKind Kind) {\n    if (isCmpSel(Kind))\n      ReductionOps.assign(2, ReductionOpsType());\n    else\n      ReductionOps.assign(1, ReductionOpsType());\n  }\n\n  /// Add all reduction operations for the reduction instruction \\p I.\n  void addReductionOps(RecurKind Kind, Instruction *I) {\n    assert(Kind != RecurKind::None && \"Expected reduction operation.\");\n    if (isCmpSel(Kind)) {\n      ReductionOps[0].emplace_back(cast<SelectInst>(I)->getCondition());\n      ReductionOps[1].emplace_back(I);\n    } else {\n      ReductionOps[0].emplace_back(I);\n    }\n  }\n\n  static Value *getLHS(RecurKind Kind, Instruction *I) {\n    if (Kind == RecurKind::None)\n      return nullptr;\n    return I->getOperand(getFirstOperandIndex(Kind));\n  }\n  static Value *getRHS(RecurKind Kind, Instruction *I) {\n    if (Kind == RecurKind::None)\n      return nullptr;\n    return I->getOperand(getFirstOperandIndex(Kind) + 1);\n  }\n\npublic:\n  HorizontalReduction() = default;\n\n  /// Try to find a reduction tree.\n  bool matchAssociativeReduction(PHINode *Phi, Instruction *B) {\n    assert((!Phi || is_contained(Phi->operands(), B)) &&\n           \"Phi needs to use the binary operator\");\n\n    RdxKind = getRdxKind(B);\n\n    // We could have a initial reductions that is not an add.\n    //  r *= v1 + v2 + v3 + v4\n    // In such a case start looking for a tree rooted in the first '+'.\n    if (Phi) {\n      if (getLHS(RdxKind, B) == Phi) {\n        Phi = nullptr;\n        B = dyn_cast<Instruction>(getRHS(RdxKind, B));\n        if (!B)\n          return false;\n        RdxKind = getRdxKind(B);\n      } else if (getRHS(RdxKind, B) == Phi) {\n        Phi = nullptr;\n        B = dyn_cast<Instruction>(getLHS(RdxKind, B));\n        if (!B)\n          return false;\n        RdxKind = getRdxKind(B);\n      }\n    }\n\n    if (!isVectorizable(RdxKind, B))\n      return false;\n\n    // Analyze \"regular\" integer/FP types for reductions - no target-specific\n    // types or pointers.\n    Type *Ty = B->getType();\n    if (!isValidElementType(Ty) || Ty->isPointerTy())\n      return false;\n\n    ReductionRoot = B;\n\n    // The opcode for leaf values that we perform a reduction on.\n    // For example: load(x) + load(y) + load(z) + fptoui(w)\n    // The leaf opcode for 'w' does not match, so we don't include it as a\n    // potential candidate for the reduction.\n    unsigned LeafOpcode = 0;\n\n    // Post order traverse the reduction tree starting at B. We only handle true\n    // trees containing only binary operators.\n    SmallVector<std::pair<Instruction *, unsigned>, 32> Stack;\n    Stack.push_back(std::make_pair(B, getFirstOperandIndex(RdxKind)));\n    initReductionOps(RdxKind);\n    while (!Stack.empty()) {\n      Instruction *TreeN = Stack.back().first;\n      unsigned EdgeToVisit = Stack.back().second++;\n      const RecurKind TreeRdxKind = getRdxKind(TreeN);\n      bool IsReducedValue = TreeRdxKind != RdxKind;\n\n      // Postorder visit.\n      if (IsReducedValue || EdgeToVisit == getNumberOfOperands(TreeRdxKind)) {\n        if (IsReducedValue)\n          ReducedVals.push_back(TreeN);\n        else {\n          auto I = ExtraArgs.find(TreeN);\n          if (I != ExtraArgs.end() && !I->second) {\n            // Check if TreeN is an extra argument of its parent operation.\n            if (Stack.size() <= 1) {\n              // TreeN can't be an extra argument as it is a root reduction\n              // operation.\n              return false;\n            }\n            // Yes, TreeN is an extra argument, do not add it to a list of\n            // reduction operations.\n            // Stack[Stack.size() - 2] always points to the parent operation.\n            markExtraArg(Stack[Stack.size() - 2], TreeN);\n            ExtraArgs.erase(TreeN);\n          } else\n            addReductionOps(RdxKind, TreeN);\n        }\n        // Retract.\n        Stack.pop_back();\n        continue;\n      }\n\n      // Visit left or right.\n      Value *EdgeVal = TreeN->getOperand(EdgeToVisit);\n      auto *I = dyn_cast<Instruction>(EdgeVal);\n      if (!I) {\n        // Edge value is not a reduction instruction or a leaf instruction.\n        // (It may be a constant, function argument, or something else.)\n        markExtraArg(Stack.back(), EdgeVal);\n        continue;\n      }\n      RecurKind EdgeRdxKind = getRdxKind(I);\n      // Continue analysis if the next operand is a reduction operation or\n      // (possibly) a leaf value. If the leaf value opcode is not set,\n      // the first met operation != reduction operation is considered as the\n      // leaf opcode.\n      // Only handle trees in the current basic block.\n      // Each tree node needs to have minimal number of users except for the\n      // ultimate reduction.\n      const bool IsRdxInst = EdgeRdxKind == RdxKind;\n      if (I != Phi && I != B &&\n          hasSameParent(RdxKind, I, B->getParent(), IsRdxInst) &&\n          hasRequiredNumberOfUses(RdxKind, I, IsRdxInst) &&\n          (!LeafOpcode || LeafOpcode == I->getOpcode() || IsRdxInst)) {\n        if (IsRdxInst) {\n          // We need to be able to reassociate the reduction operations.\n          if (!isVectorizable(EdgeRdxKind, I)) {\n            // I is an extra argument for TreeN (its parent operation).\n            markExtraArg(Stack.back(), I);\n            continue;\n          }\n        } else if (!LeafOpcode) {\n          LeafOpcode = I->getOpcode();\n        }\n        Stack.push_back(std::make_pair(I, getFirstOperandIndex(EdgeRdxKind)));\n        continue;\n      }\n      // I is an extra argument for TreeN (its parent operation).\n      markExtraArg(Stack.back(), I);\n    }\n    return true;\n  }\n\n  /// Attempt to vectorize the tree found by matchAssociativeReduction.\n  bool tryToReduce(BoUpSLP &V, TargetTransformInfo *TTI) {\n    // If there are a sufficient number of reduction values, reduce\n    // to a nearby power-of-2. We can safely generate oversized\n    // vectors and rely on the backend to split them to legal sizes.\n    unsigned NumReducedVals = ReducedVals.size();\n    if (NumReducedVals < 4)\n      return false;\n\n    // Intersect the fast-math-flags from all reduction operations.\n    FastMathFlags RdxFMF;\n    RdxFMF.set();\n    for (ReductionOpsType &RdxOp : ReductionOps) {\n      for (Value *RdxVal : RdxOp) {\n        if (auto *FPMO = dyn_cast<FPMathOperator>(RdxVal))\n          RdxFMF &= FPMO->getFastMathFlags();\n      }\n    }\n\n    IRBuilder<> Builder(cast<Instruction>(ReductionRoot));\n    Builder.setFastMathFlags(RdxFMF);\n\n    BoUpSLP::ExtraValueToDebugLocsMap ExternallyUsedValues;\n    // The same extra argument may be used several times, so log each attempt\n    // to use it.\n    for (const std::pair<Instruction *, Value *> &Pair : ExtraArgs) {\n      assert(Pair.first && \"DebugLoc must be set.\");\n      ExternallyUsedValues[Pair.second].push_back(Pair.first);\n    }\n\n    // The compare instruction of a min/max is the insertion point for new\n    // instructions and may be replaced with a new compare instruction.\n    auto getCmpForMinMaxReduction = [](Instruction *RdxRootInst) {\n      assert(isa<SelectInst>(RdxRootInst) &&\n             \"Expected min/max reduction to have select root instruction\");\n      Value *ScalarCond = cast<SelectInst>(RdxRootInst)->getCondition();\n      assert(isa<Instruction>(ScalarCond) &&\n             \"Expected min/max reduction to have compare condition\");\n      return cast<Instruction>(ScalarCond);\n    };\n\n    // The reduction root is used as the insertion point for new instructions,\n    // so set it as externally used to prevent it from being deleted.\n    ExternallyUsedValues[ReductionRoot];\n    SmallVector<Value *, 16> IgnoreList;\n    for (ReductionOpsType &RdxOp : ReductionOps)\n      IgnoreList.append(RdxOp.begin(), RdxOp.end());\n\n    unsigned ReduxWidth = PowerOf2Floor(NumReducedVals);\n    if (NumReducedVals > ReduxWidth) {\n      // In the loop below, we are building a tree based on a window of\n      // 'ReduxWidth' values.\n      // If the operands of those values have common traits (compare predicate,\n      // constant operand, etc), then we want to group those together to\n      // minimize the cost of the reduction.\n\n      // TODO: This should be extended to count common operands for\n      //       compares and binops.\n\n      // Step 1: Count the number of times each compare predicate occurs.\n      SmallDenseMap<unsigned, unsigned> PredCountMap;\n      for (Value *RdxVal : ReducedVals) {\n        CmpInst::Predicate Pred;\n        if (match(RdxVal, m_Cmp(Pred, m_Value(), m_Value())))\n          ++PredCountMap[Pred];\n      }\n      // Step 2: Sort the values so the most common predicates come first.\n      stable_sort(ReducedVals, [&PredCountMap](Value *A, Value *B) {\n        CmpInst::Predicate PredA, PredB;\n        if (match(A, m_Cmp(PredA, m_Value(), m_Value())) &&\n            match(B, m_Cmp(PredB, m_Value(), m_Value()))) {\n          return PredCountMap[PredA] > PredCountMap[PredB];\n        }\n        return false;\n      });\n    }\n\n    Value *VectorizedTree = nullptr;\n    unsigned i = 0;\n    while (i < NumReducedVals - ReduxWidth + 1 && ReduxWidth > 2) {\n      ArrayRef<Value *> VL(&ReducedVals[i], ReduxWidth);\n      V.buildTree(VL, ExternallyUsedValues, IgnoreList);\n      Optional<ArrayRef<unsigned>> Order = V.bestOrder();\n      if (Order) {\n        assert(Order->size() == VL.size() &&\n               \"Order size must be the same as number of vectorized \"\n               \"instructions.\");\n        // TODO: reorder tree nodes without tree rebuilding.\n        SmallVector<Value *, 4> ReorderedOps(VL.size());\n        llvm::transform(*Order, ReorderedOps.begin(),\n                        [VL](const unsigned Idx) { return VL[Idx]; });\n        V.buildTree(ReorderedOps, ExternallyUsedValues, IgnoreList);\n      }\n      if (V.isTreeTinyAndNotFullyVectorizable())\n        break;\n      if (V.isLoadCombineReductionCandidate(RdxKind))\n        break;\n\n      V.computeMinimumValueSizes();\n\n      // Estimate cost.\n      InstructionCost TreeCost = V.getTreeCost();\n      InstructionCost ReductionCost =\n          getReductionCost(TTI, ReducedVals[i], ReduxWidth);\n      InstructionCost Cost = TreeCost + ReductionCost;\n      if (!Cost.isValid()) {\n        LLVM_DEBUG(dbgs() << \"Encountered invalid baseline cost.\\n\");\n        return false;\n      }\n      if (Cost >= -SLPCostThreshold) {\n        V.getORE()->emit([&]() {\n          return OptimizationRemarkMissed(SV_NAME, \"HorSLPNotBeneficial\",\n                                          cast<Instruction>(VL[0]))\n                 << \"Vectorizing horizontal reduction is possible\"\n                 << \"but not beneficial with cost \" << ore::NV(\"Cost\", Cost)\n                 << \" and threshold \"\n                 << ore::NV(\"Threshold\", -SLPCostThreshold);\n        });\n        break;\n      }\n\n      LLVM_DEBUG(dbgs() << \"SLP: Vectorizing horizontal reduction at cost:\"\n                        << Cost << \". (HorRdx)\\n\");\n      V.getORE()->emit([&]() {\n        return OptimizationRemark(SV_NAME, \"VectorizedHorizontalReduction\",\n                                  cast<Instruction>(VL[0]))\n               << \"Vectorized horizontal reduction with cost \"\n               << ore::NV(\"Cost\", Cost) << \" and with tree size \"\n               << ore::NV(\"TreeSize\", V.getTreeSize());\n      });\n\n      // Vectorize a tree.\n      DebugLoc Loc = cast<Instruction>(ReducedVals[i])->getDebugLoc();\n      Value *VectorizedRoot = V.vectorizeTree(ExternallyUsedValues);\n\n      // Emit a reduction. If the root is a select (min/max idiom), the insert\n      // point is the compare condition of that select.\n      Instruction *RdxRootInst = cast<Instruction>(ReductionRoot);\n      if (isCmpSel(RdxKind))\n        Builder.SetInsertPoint(getCmpForMinMaxReduction(RdxRootInst));\n      else\n        Builder.SetInsertPoint(RdxRootInst);\n\n      Value *ReducedSubTree =\n          emitReduction(VectorizedRoot, Builder, ReduxWidth, TTI);\n\n      if (!VectorizedTree) {\n        // Initialize the final value in the reduction.\n        VectorizedTree = ReducedSubTree;\n      } else {\n        // Update the final value in the reduction.\n        Builder.SetCurrentDebugLocation(Loc);\n        VectorizedTree = createOp(Builder, RdxKind, VectorizedTree,\n                                  ReducedSubTree, \"op.rdx\", ReductionOps);\n      }\n      i += ReduxWidth;\n      ReduxWidth = PowerOf2Floor(NumReducedVals - i);\n    }\n\n    if (VectorizedTree) {\n      // Finish the reduction.\n      for (; i < NumReducedVals; ++i) {\n        auto *I = cast<Instruction>(ReducedVals[i]);\n        Builder.SetCurrentDebugLocation(I->getDebugLoc());\n        VectorizedTree =\n            createOp(Builder, RdxKind, VectorizedTree, I, \"\", ReductionOps);\n      }\n      for (auto &Pair : ExternallyUsedValues) {\n        // Add each externally used value to the final reduction.\n        for (auto *I : Pair.second) {\n          Builder.SetCurrentDebugLocation(I->getDebugLoc());\n          VectorizedTree = createOp(Builder, RdxKind, VectorizedTree,\n                                    Pair.first, \"op.extra\", I);\n        }\n      }\n\n      // Update users. For a min/max reduction that ends with a compare and\n      // select, we also have to RAUW for the compare instruction feeding the\n      // reduction root. That's because the original compare may have extra uses\n      // besides the final select of the reduction.\n      if (isCmpSel(RdxKind)) {\n        if (auto *VecSelect = dyn_cast<SelectInst>(VectorizedTree)) {\n          Instruction *ScalarCmp =\n              getCmpForMinMaxReduction(cast<Instruction>(ReductionRoot));\n          ScalarCmp->replaceAllUsesWith(VecSelect->getCondition());\n        }\n      }\n      ReductionRoot->replaceAllUsesWith(VectorizedTree);\n\n      // Mark all scalar reduction ops for deletion, they are replaced by the\n      // vector reductions.\n      V.eraseInstructions(IgnoreList);\n    }\n    return VectorizedTree != nullptr;\n  }\n\n  unsigned numReductionValues() const { return ReducedVals.size(); }\n\nprivate:\n  /// Calculate the cost of a reduction.\n  InstructionCost getReductionCost(TargetTransformInfo *TTI,\n                                   Value *FirstReducedVal,\n                                   unsigned ReduxWidth) {\n    Type *ScalarTy = FirstReducedVal->getType();\n    FixedVectorType *VectorTy = FixedVectorType::get(ScalarTy, ReduxWidth);\n    InstructionCost VectorCost, ScalarCost;\n    switch (RdxKind) {\n    case RecurKind::Add:\n    case RecurKind::Mul:\n    case RecurKind::Or:\n    case RecurKind::And:\n    case RecurKind::Xor:\n    case RecurKind::FAdd:\n    case RecurKind::FMul: {\n      unsigned RdxOpcode = RecurrenceDescriptor::getOpcode(RdxKind);\n      VectorCost = TTI->getArithmeticReductionCost(RdxOpcode, VectorTy,\n                                                   /*IsPairwiseForm=*/false);\n      ScalarCost = TTI->getArithmeticInstrCost(RdxOpcode, ScalarTy);\n      break;\n    }\n    case RecurKind::FMax:\n    case RecurKind::FMin: {\n      auto *VecCondTy = cast<VectorType>(CmpInst::makeCmpResultType(VectorTy));\n      VectorCost =\n          TTI->getMinMaxReductionCost(VectorTy, VecCondTy,\n                                      /*pairwise=*/false, /*unsigned=*/false);\n      ScalarCost =\n          TTI->getCmpSelInstrCost(Instruction::FCmp, ScalarTy) +\n          TTI->getCmpSelInstrCost(Instruction::Select, ScalarTy,\n                                  CmpInst::makeCmpResultType(ScalarTy));\n      break;\n    }\n    case RecurKind::SMax:\n    case RecurKind::SMin:\n    case RecurKind::UMax:\n    case RecurKind::UMin: {\n      auto *VecCondTy = cast<VectorType>(CmpInst::makeCmpResultType(VectorTy));\n      bool IsUnsigned =\n          RdxKind == RecurKind::UMax || RdxKind == RecurKind::UMin;\n      VectorCost =\n          TTI->getMinMaxReductionCost(VectorTy, VecCondTy,\n                                      /*IsPairwiseForm=*/false, IsUnsigned);\n      ScalarCost =\n          TTI->getCmpSelInstrCost(Instruction::ICmp, ScalarTy) +\n          TTI->getCmpSelInstrCost(Instruction::Select, ScalarTy,\n                                  CmpInst::makeCmpResultType(ScalarTy));\n      break;\n    }\n    default:\n      llvm_unreachable(\"Expected arithmetic or min/max reduction operation\");\n    }\n\n    // Scalar cost is repeated for N-1 elements.\n    ScalarCost *= (ReduxWidth - 1);\n    LLVM_DEBUG(dbgs() << \"SLP: Adding cost \" << VectorCost - ScalarCost\n                      << \" for reduction that starts with \" << *FirstReducedVal\n                      << \" (It is a splitting reduction)\\n\");\n    return VectorCost - ScalarCost;\n  }\n\n  /// Emit a horizontal reduction of the vectorized value.\n  Value *emitReduction(Value *VectorizedValue, IRBuilder<> &Builder,\n                       unsigned ReduxWidth, const TargetTransformInfo *TTI) {\n    assert(VectorizedValue && \"Need to have a vectorized tree node\");\n    assert(isPowerOf2_32(ReduxWidth) &&\n           \"We only handle power-of-two reductions for now\");\n\n    return createSimpleTargetReduction(Builder, TTI, VectorizedValue, RdxKind,\n                                       ReductionOps.back());\n  }\n};\n\n} // end anonymous namespace\n\nstatic Optional<unsigned> getAggregateSize(Instruction *InsertInst) {\n  if (auto *IE = dyn_cast<InsertElementInst>(InsertInst))\n    return cast<FixedVectorType>(IE->getType())->getNumElements();\n\n  unsigned AggregateSize = 1;\n  auto *IV = cast<InsertValueInst>(InsertInst);\n  Type *CurrentType = IV->getType();\n  do {\n    if (auto *ST = dyn_cast<StructType>(CurrentType)) {\n      for (auto *Elt : ST->elements())\n        if (Elt != ST->getElementType(0)) // check homogeneity\n          return None;\n      AggregateSize *= ST->getNumElements();\n      CurrentType = ST->getElementType(0);\n    } else if (auto *AT = dyn_cast<ArrayType>(CurrentType)) {\n      AggregateSize *= AT->getNumElements();\n      CurrentType = AT->getElementType();\n    } else if (auto *VT = dyn_cast<FixedVectorType>(CurrentType)) {\n      AggregateSize *= VT->getNumElements();\n      return AggregateSize;\n    } else if (CurrentType->isSingleValueType()) {\n      return AggregateSize;\n    } else {\n      return None;\n    }\n  } while (true);\n}\n\nstatic Optional<unsigned> getOperandIndex(Instruction *InsertInst,\n                                          unsigned OperandOffset) {\n  unsigned OperandIndex = OperandOffset;\n  if (auto *IE = dyn_cast<InsertElementInst>(InsertInst)) {\n    if (auto *CI = dyn_cast<ConstantInt>(IE->getOperand(2))) {\n      auto *VT = cast<FixedVectorType>(IE->getType());\n      OperandIndex *= VT->getNumElements();\n      OperandIndex += CI->getZExtValue();\n      return OperandIndex;\n    }\n    return None;\n  }\n\n  auto *IV = cast<InsertValueInst>(InsertInst);\n  Type *CurrentType = IV->getType();\n  for (unsigned int Index : IV->indices()) {\n    if (auto *ST = dyn_cast<StructType>(CurrentType)) {\n      OperandIndex *= ST->getNumElements();\n      CurrentType = ST->getElementType(Index);\n    } else if (auto *AT = dyn_cast<ArrayType>(CurrentType)) {\n      OperandIndex *= AT->getNumElements();\n      CurrentType = AT->getElementType();\n    } else {\n      return None;\n    }\n    OperandIndex += Index;\n  }\n  return OperandIndex;\n}\n\nstatic bool findBuildAggregate_rec(Instruction *LastInsertInst,\n                                   TargetTransformInfo *TTI,\n                                   SmallVectorImpl<Value *> &BuildVectorOpds,\n                                   SmallVectorImpl<Value *> &InsertElts,\n                                   unsigned OperandOffset) {\n  do {\n    Value *InsertedOperand = LastInsertInst->getOperand(1);\n    Optional<unsigned> OperandIndex =\n        getOperandIndex(LastInsertInst, OperandOffset);\n    if (!OperandIndex)\n      return false;\n    if (isa<InsertElementInst>(InsertedOperand) ||\n        isa<InsertValueInst>(InsertedOperand)) {\n      if (!findBuildAggregate_rec(cast<Instruction>(InsertedOperand), TTI,\n                                  BuildVectorOpds, InsertElts, *OperandIndex))\n        return false;\n    } else {\n      BuildVectorOpds[*OperandIndex] = InsertedOperand;\n      InsertElts[*OperandIndex] = LastInsertInst;\n    }\n    if (isa<UndefValue>(LastInsertInst->getOperand(0)))\n      return true;\n    LastInsertInst = dyn_cast<Instruction>(LastInsertInst->getOperand(0));\n  } while (LastInsertInst != nullptr &&\n           (isa<InsertValueInst>(LastInsertInst) ||\n            isa<InsertElementInst>(LastInsertInst)) &&\n           LastInsertInst->hasOneUse());\n  return false;\n}\n\n/// Recognize construction of vectors like\n///  %ra = insertelement <4 x float> poison, float %s0, i32 0\n///  %rb = insertelement <4 x float> %ra, float %s1, i32 1\n///  %rc = insertelement <4 x float> %rb, float %s2, i32 2\n///  %rd = insertelement <4 x float> %rc, float %s3, i32 3\n///  starting from the last insertelement or insertvalue instruction.\n///\n/// Also recognize homogeneous aggregates like {<2 x float>, <2 x float>},\n/// {{float, float}, {float, float}}, [2 x {float, float}] and so on.\n/// See llvm/test/Transforms/SLPVectorizer/X86/pr42022.ll for examples.\n///\n/// Assume LastInsertInst is of InsertElementInst or InsertValueInst type.\n///\n/// \\return true if it matches.\nstatic bool findBuildAggregate(Instruction *LastInsertInst,\n                               TargetTransformInfo *TTI,\n                               SmallVectorImpl<Value *> &BuildVectorOpds,\n                               SmallVectorImpl<Value *> &InsertElts) {\n\n  assert((isa<InsertElementInst>(LastInsertInst) ||\n          isa<InsertValueInst>(LastInsertInst)) &&\n         \"Expected insertelement or insertvalue instruction!\");\n\n  assert((BuildVectorOpds.empty() && InsertElts.empty()) &&\n         \"Expected empty result vectors!\");\n\n  Optional<unsigned> AggregateSize = getAggregateSize(LastInsertInst);\n  if (!AggregateSize)\n    return false;\n  BuildVectorOpds.resize(*AggregateSize);\n  InsertElts.resize(*AggregateSize);\n\n  if (findBuildAggregate_rec(LastInsertInst, TTI, BuildVectorOpds, InsertElts,\n                             0)) {\n    llvm::erase_value(BuildVectorOpds, nullptr);\n    llvm::erase_value(InsertElts, nullptr);\n    if (BuildVectorOpds.size() >= 2)\n      return true;\n  }\n\n  return false;\n}\n\nstatic bool PhiTypeSorterFunc(Value *V, Value *V2) {\n  return V->getType() < V2->getType();\n}\n\n/// Try and get a reduction value from a phi node.\n///\n/// Given a phi node \\p P in a block \\p ParentBB, consider possible reductions\n/// if they come from either \\p ParentBB or a containing loop latch.\n///\n/// \\returns A candidate reduction value if possible, or \\code nullptr \\endcode\n/// if not possible.\nstatic Value *getReductionValue(const DominatorTree *DT, PHINode *P,\n                                BasicBlock *ParentBB, LoopInfo *LI) {\n  // There are situations where the reduction value is not dominated by the\n  // reduction phi. Vectorizing such cases has been reported to cause\n  // miscompiles. See PR25787.\n  auto DominatedReduxValue = [&](Value *R) {\n    return isa<Instruction>(R) &&\n           DT->dominates(P->getParent(), cast<Instruction>(R)->getParent());\n  };\n\n  Value *Rdx = nullptr;\n\n  // Return the incoming value if it comes from the same BB as the phi node.\n  if (P->getIncomingBlock(0) == ParentBB) {\n    Rdx = P->getIncomingValue(0);\n  } else if (P->getIncomingBlock(1) == ParentBB) {\n    Rdx = P->getIncomingValue(1);\n  }\n\n  if (Rdx && DominatedReduxValue(Rdx))\n    return Rdx;\n\n  // Otherwise, check whether we have a loop latch to look at.\n  Loop *BBL = LI->getLoopFor(ParentBB);\n  if (!BBL)\n    return nullptr;\n  BasicBlock *BBLatch = BBL->getLoopLatch();\n  if (!BBLatch)\n    return nullptr;\n\n  // There is a loop latch, return the incoming value if it comes from\n  // that. This reduction pattern occasionally turns up.\n  if (P->getIncomingBlock(0) == BBLatch) {\n    Rdx = P->getIncomingValue(0);\n  } else if (P->getIncomingBlock(1) == BBLatch) {\n    Rdx = P->getIncomingValue(1);\n  }\n\n  if (Rdx && DominatedReduxValue(Rdx))\n    return Rdx;\n\n  return nullptr;\n}\n\nstatic bool matchRdxBop(Instruction *I, Value *&V0, Value *&V1) {\n  if (match(I, m_BinOp(m_Value(V0), m_Value(V1))))\n    return true;\n  if (match(I, m_Intrinsic<Intrinsic::maxnum>(m_Value(V0), m_Value(V1))))\n    return true;\n  if (match(I, m_Intrinsic<Intrinsic::minnum>(m_Value(V0), m_Value(V1))))\n    return true;\n  return false;\n}\n\n/// Attempt to reduce a horizontal reduction.\n/// If it is legal to match a horizontal reduction feeding the phi node \\a P\n/// with reduction operators \\a Root (or one of its operands) in a basic block\n/// \\a BB, then check if it can be done. If horizontal reduction is not found\n/// and root instruction is a binary operation, vectorization of the operands is\n/// attempted.\n/// \\returns true if a horizontal reduction was matched and reduced or operands\n/// of one of the binary instruction were vectorized.\n/// \\returns false if a horizontal reduction was not matched (or not possible)\n/// or no vectorization of any binary operation feeding \\a Root instruction was\n/// performed.\nstatic bool tryToVectorizeHorReductionOrInstOperands(\n    PHINode *P, Instruction *Root, BasicBlock *BB, BoUpSLP &R,\n    TargetTransformInfo *TTI,\n    const function_ref<bool(Instruction *, BoUpSLP &)> Vectorize) {\n  if (!ShouldVectorizeHor)\n    return false;\n\n  if (!Root)\n    return false;\n\n  if (Root->getParent() != BB || isa<PHINode>(Root))\n    return false;\n  // Start analysis starting from Root instruction. If horizontal reduction is\n  // found, try to vectorize it. If it is not a horizontal reduction or\n  // vectorization is not possible or not effective, and currently analyzed\n  // instruction is a binary operation, try to vectorize the operands, using\n  // pre-order DFS traversal order. If the operands were not vectorized, repeat\n  // the same procedure considering each operand as a possible root of the\n  // horizontal reduction.\n  // Interrupt the process if the Root instruction itself was vectorized or all\n  // sub-trees not higher that RecursionMaxDepth were analyzed/vectorized.\n  SmallVector<std::pair<Instruction *, unsigned>, 8> Stack(1, {Root, 0});\n  SmallPtrSet<Value *, 8> VisitedInstrs;\n  bool Res = false;\n  while (!Stack.empty()) {\n    Instruction *Inst;\n    unsigned Level;\n    std::tie(Inst, Level) = Stack.pop_back_val();\n    Value *B0, *B1;\n    bool IsBinop = matchRdxBop(Inst, B0, B1);\n    bool IsSelect = match(Inst, m_Select(m_Value(), m_Value(), m_Value()));\n    if (IsBinop || IsSelect) {\n      HorizontalReduction HorRdx;\n      if (HorRdx.matchAssociativeReduction(P, Inst)) {\n        if (HorRdx.tryToReduce(R, TTI)) {\n          Res = true;\n          // Set P to nullptr to avoid re-analysis of phi node in\n          // matchAssociativeReduction function unless this is the root node.\n          P = nullptr;\n          continue;\n        }\n      }\n      if (P && IsBinop) {\n        Inst = dyn_cast<Instruction>(B0);\n        if (Inst == P)\n          Inst = dyn_cast<Instruction>(B1);\n        if (!Inst) {\n          // Set P to nullptr to avoid re-analysis of phi node in\n          // matchAssociativeReduction function unless this is the root node.\n          P = nullptr;\n          continue;\n        }\n      }\n    }\n    // Set P to nullptr to avoid re-analysis of phi node in\n    // matchAssociativeReduction function unless this is the root node.\n    P = nullptr;\n    if (Vectorize(Inst, R)) {\n      Res = true;\n      continue;\n    }\n\n    // Try to vectorize operands.\n    // Continue analysis for the instruction from the same basic block only to\n    // save compile time.\n    if (++Level < RecursionMaxDepth)\n      for (auto *Op : Inst->operand_values())\n        if (VisitedInstrs.insert(Op).second)\n          if (auto *I = dyn_cast<Instruction>(Op))\n            if (!isa<PHINode>(I) && !R.isDeleted(I) && I->getParent() == BB)\n              Stack.emplace_back(I, Level);\n  }\n  return Res;\n}\n\nbool SLPVectorizerPass::vectorizeRootInstruction(PHINode *P, Value *V,\n                                                 BasicBlock *BB, BoUpSLP &R,\n                                                 TargetTransformInfo *TTI) {\n  auto *I = dyn_cast_or_null<Instruction>(V);\n  if (!I)\n    return false;\n\n  if (!isa<BinaryOperator>(I))\n    P = nullptr;\n  // Try to match and vectorize a horizontal reduction.\n  auto &&ExtraVectorization = [this](Instruction *I, BoUpSLP &R) -> bool {\n    return tryToVectorize(I, R);\n  };\n  return tryToVectorizeHorReductionOrInstOperands(P, I, BB, R, TTI,\n                                                  ExtraVectorization);\n}\n\nbool SLPVectorizerPass::vectorizeInsertValueInst(InsertValueInst *IVI,\n                                                 BasicBlock *BB, BoUpSLP &R) {\n  const DataLayout &DL = BB->getModule()->getDataLayout();\n  if (!R.canMapToVector(IVI->getType(), DL))\n    return false;\n\n  SmallVector<Value *, 16> BuildVectorOpds;\n  SmallVector<Value *, 16> BuildVectorInsts;\n  if (!findBuildAggregate(IVI, TTI, BuildVectorOpds, BuildVectorInsts))\n    return false;\n\n  LLVM_DEBUG(dbgs() << \"SLP: array mappable to vector: \" << *IVI << \"\\n\");\n  // Aggregate value is unlikely to be processed in vector register, we need to\n  // extract scalars into scalar registers, so NeedExtraction is set true.\n  return tryToVectorizeList(BuildVectorOpds, R, /*AllowReorder=*/false,\n                            BuildVectorInsts);\n}\n\nbool SLPVectorizerPass::vectorizeInsertElementInst(InsertElementInst *IEI,\n                                                   BasicBlock *BB, BoUpSLP &R) {\n  SmallVector<Value *, 16> BuildVectorInsts;\n  SmallVector<Value *, 16> BuildVectorOpds;\n  if (!findBuildAggregate(IEI, TTI, BuildVectorOpds, BuildVectorInsts) ||\n      (llvm::all_of(BuildVectorOpds,\n                    [](Value *V) { return isa<ExtractElementInst>(V); }) &&\n       isShuffle(BuildVectorOpds)))\n    return false;\n\n  // Vectorize starting with the build vector operands ignoring the BuildVector\n  // instructions for the purpose of scheduling and user extraction.\n  return tryToVectorizeList(BuildVectorOpds, R, /*AllowReorder=*/false,\n                            BuildVectorInsts);\n}\n\nbool SLPVectorizerPass::vectorizeCmpInst(CmpInst *CI, BasicBlock *BB,\n                                         BoUpSLP &R) {\n  if (tryToVectorizePair(CI->getOperand(0), CI->getOperand(1), R))\n    return true;\n\n  bool OpsChanged = false;\n  for (int Idx = 0; Idx < 2; ++Idx) {\n    OpsChanged |=\n        vectorizeRootInstruction(nullptr, CI->getOperand(Idx), BB, R, TTI);\n  }\n  return OpsChanged;\n}\n\nbool SLPVectorizerPass::vectorizeSimpleInstructions(\n    SmallVectorImpl<Instruction *> &Instructions, BasicBlock *BB, BoUpSLP &R) {\n  bool OpsChanged = false;\n  for (auto *I : reverse(Instructions)) {\n    if (R.isDeleted(I))\n      continue;\n    if (auto *LastInsertValue = dyn_cast<InsertValueInst>(I))\n      OpsChanged |= vectorizeInsertValueInst(LastInsertValue, BB, R);\n    else if (auto *LastInsertElem = dyn_cast<InsertElementInst>(I))\n      OpsChanged |= vectorizeInsertElementInst(LastInsertElem, BB, R);\n    else if (auto *CI = dyn_cast<CmpInst>(I))\n      OpsChanged |= vectorizeCmpInst(CI, BB, R);\n  }\n  Instructions.clear();\n  return OpsChanged;\n}\n\nbool SLPVectorizerPass::vectorizeChainsInBlock(BasicBlock *BB, BoUpSLP &R) {\n  bool Changed = false;\n  SmallVector<Value *, 4> Incoming;\n  SmallPtrSet<Value *, 16> VisitedInstrs;\n\n  bool HaveVectorizedPhiNodes = true;\n  while (HaveVectorizedPhiNodes) {\n    HaveVectorizedPhiNodes = false;\n\n    // Collect the incoming values from the PHIs.\n    Incoming.clear();\n    for (Instruction &I : *BB) {\n      PHINode *P = dyn_cast<PHINode>(&I);\n      if (!P)\n        break;\n\n      if (!VisitedInstrs.count(P) && !R.isDeleted(P))\n        Incoming.push_back(P);\n    }\n\n    // Sort by type.\n    llvm::stable_sort(Incoming, PhiTypeSorterFunc);\n\n    // Try to vectorize elements base on their type.\n    for (SmallVector<Value *, 4>::iterator IncIt = Incoming.begin(),\n                                           E = Incoming.end();\n         IncIt != E;) {\n\n      // Look for the next elements with the same type.\n      SmallVector<Value *, 4>::iterator SameTypeIt = IncIt;\n      while (SameTypeIt != E &&\n             (*SameTypeIt)->getType() == (*IncIt)->getType()) {\n        VisitedInstrs.insert(*SameTypeIt);\n        ++SameTypeIt;\n      }\n\n      // Try to vectorize them.\n      unsigned NumElts = (SameTypeIt - IncIt);\n      LLVM_DEBUG(dbgs() << \"SLP: Trying to vectorize starting at PHIs (\"\n                        << NumElts << \")\\n\");\n      // The order in which the phi nodes appear in the program does not matter.\n      // So allow tryToVectorizeList to reorder them if it is beneficial. This\n      // is done when there are exactly two elements since tryToVectorizeList\n      // asserts that there are only two values when AllowReorder is true.\n      bool AllowReorder = NumElts == 2;\n      if (NumElts > 1 &&\n          tryToVectorizeList(makeArrayRef(IncIt, NumElts), R, AllowReorder)) {\n        // Success start over because instructions might have been changed.\n        HaveVectorizedPhiNodes = true;\n        Changed = true;\n        break;\n      }\n\n      // Start over at the next instruction of a different type (or the end).\n      IncIt = SameTypeIt;\n    }\n  }\n\n  VisitedInstrs.clear();\n\n  SmallVector<Instruction *, 8> PostProcessInstructions;\n  SmallDenseSet<Instruction *, 4> KeyNodes;\n  for (BasicBlock::iterator it = BB->begin(), e = BB->end(); it != e; ++it) {\n    // Skip instructions with scalable type. The num of elements is unknown at\n    // compile-time for scalable type.\n    if (isa<ScalableVectorType>(it->getType()))\n      continue;\n\n    // Skip instructions marked for the deletion.\n    if (R.isDeleted(&*it))\n      continue;\n    // We may go through BB multiple times so skip the one we have checked.\n    if (!VisitedInstrs.insert(&*it).second) {\n      if (it->use_empty() && KeyNodes.contains(&*it) &&\n          vectorizeSimpleInstructions(PostProcessInstructions, BB, R)) {\n        // We would like to start over since some instructions are deleted\n        // and the iterator may become invalid value.\n        Changed = true;\n        it = BB->begin();\n        e = BB->end();\n      }\n      continue;\n    }\n\n    if (isa<DbgInfoIntrinsic>(it))\n      continue;\n\n    // Try to vectorize reductions that use PHINodes.\n    if (PHINode *P = dyn_cast<PHINode>(it)) {\n      // Check that the PHI is a reduction PHI.\n      if (P->getNumIncomingValues() == 2) {\n        // Try to match and vectorize a horizontal reduction.\n        if (vectorizeRootInstruction(P, getReductionValue(DT, P, BB, LI), BB, R,\n                                     TTI)) {\n          Changed = true;\n          it = BB->begin();\n          e = BB->end();\n          continue;\n        }\n      }\n      // Try to vectorize the incoming values of the PHI, to catch reductions\n      // that feed into PHIs.\n      for (unsigned I = 0, E = P->getNumIncomingValues(); I != E; I++) {\n        // Skip if the incoming block is the current BB for now. Also, bypass\n        // unreachable IR for efficiency and to avoid crashing.\n        // TODO: Collect the skipped incoming values and try to vectorize them\n        // after processing BB.\n        if (BB == P->getIncomingBlock(I) ||\n            !DT->isReachableFromEntry(P->getIncomingBlock(I)))\n          continue;\n\n        Changed |= vectorizeRootInstruction(nullptr, P->getIncomingValue(I),\n                                            P->getIncomingBlock(I), R, TTI);\n      }\n      continue;\n    }\n\n    // Ran into an instruction without users, like terminator, or function call\n    // with ignored return value, store. Ignore unused instructions (basing on\n    // instruction type, except for CallInst and InvokeInst).\n    if (it->use_empty() && (it->getType()->isVoidTy() || isa<CallInst>(it) ||\n                            isa<InvokeInst>(it))) {\n      KeyNodes.insert(&*it);\n      bool OpsChanged = false;\n      if (ShouldStartVectorizeHorAtStore || !isa<StoreInst>(it)) {\n        for (auto *V : it->operand_values()) {\n          // Try to match and vectorize a horizontal reduction.\n          OpsChanged |= vectorizeRootInstruction(nullptr, V, BB, R, TTI);\n        }\n      }\n      // Start vectorization of post-process list of instructions from the\n      // top-tree instructions to try to vectorize as many instructions as\n      // possible.\n      OpsChanged |= vectorizeSimpleInstructions(PostProcessInstructions, BB, R);\n      if (OpsChanged) {\n        // We would like to start over since some instructions are deleted\n        // and the iterator may become invalid value.\n        Changed = true;\n        it = BB->begin();\n        e = BB->end();\n        continue;\n      }\n    }\n\n    if (isa<InsertElementInst>(it) || isa<CmpInst>(it) ||\n        isa<InsertValueInst>(it))\n      PostProcessInstructions.push_back(&*it);\n  }\n\n  return Changed;\n}\n\nbool SLPVectorizerPass::vectorizeGEPIndices(BasicBlock *BB, BoUpSLP &R) {\n  auto Changed = false;\n  for (auto &Entry : GEPs) {\n    // If the getelementptr list has fewer than two elements, there's nothing\n    // to do.\n    if (Entry.second.size() < 2)\n      continue;\n\n    LLVM_DEBUG(dbgs() << \"SLP: Analyzing a getelementptr list of length \"\n                      << Entry.second.size() << \".\\n\");\n\n    // Process the GEP list in chunks suitable for the target's supported\n    // vector size. If a vector register can't hold 1 element, we are done. We\n    // are trying to vectorize the index computations, so the maximum number of\n    // elements is based on the size of the index expression, rather than the\n    // size of the GEP itself (the target's pointer size).\n    unsigned MaxVecRegSize = R.getMaxVecRegSize();\n    unsigned EltSize = R.getVectorElementSize(*Entry.second[0]->idx_begin());\n    if (MaxVecRegSize < EltSize)\n      continue;\n\n    unsigned MaxElts = MaxVecRegSize / EltSize;\n    for (unsigned BI = 0, BE = Entry.second.size(); BI < BE; BI += MaxElts) {\n      auto Len = std::min<unsigned>(BE - BI, MaxElts);\n      ArrayRef<GetElementPtrInst *> GEPList(&Entry.second[BI], Len);\n\n      // Initialize a set a candidate getelementptrs. Note that we use a\n      // SetVector here to preserve program order. If the index computations\n      // are vectorizable and begin with loads, we want to minimize the chance\n      // of having to reorder them later.\n      SetVector<Value *> Candidates(GEPList.begin(), GEPList.end());\n\n      // Some of the candidates may have already been vectorized after we\n      // initially collected them. If so, they are marked as deleted, so remove\n      // them from the set of candidates.\n      Candidates.remove_if(\n          [&R](Value *I) { return R.isDeleted(cast<Instruction>(I)); });\n\n      // Remove from the set of candidates all pairs of getelementptrs with\n      // constant differences. Such getelementptrs are likely not good\n      // candidates for vectorization in a bottom-up phase since one can be\n      // computed from the other. We also ensure all candidate getelementptr\n      // indices are unique.\n      for (int I = 0, E = GEPList.size(); I < E && Candidates.size() > 1; ++I) {\n        auto *GEPI = GEPList[I];\n        if (!Candidates.count(GEPI))\n          continue;\n        auto *SCEVI = SE->getSCEV(GEPList[I]);\n        for (int J = I + 1; J < E && Candidates.size() > 1; ++J) {\n          auto *GEPJ = GEPList[J];\n          auto *SCEVJ = SE->getSCEV(GEPList[J]);\n          if (isa<SCEVConstant>(SE->getMinusSCEV(SCEVI, SCEVJ))) {\n            Candidates.remove(GEPI);\n            Candidates.remove(GEPJ);\n          } else if (GEPI->idx_begin()->get() == GEPJ->idx_begin()->get()) {\n            Candidates.remove(GEPJ);\n          }\n        }\n      }\n\n      // We break out of the above computation as soon as we know there are\n      // fewer than two candidates remaining.\n      if (Candidates.size() < 2)\n        continue;\n\n      // Add the single, non-constant index of each candidate to the bundle. We\n      // ensured the indices met these constraints when we originally collected\n      // the getelementptrs.\n      SmallVector<Value *, 16> Bundle(Candidates.size());\n      auto BundleIndex = 0u;\n      for (auto *V : Candidates) {\n        auto *GEP = cast<GetElementPtrInst>(V);\n        auto *GEPIdx = GEP->idx_begin()->get();\n        assert(GEP->getNumIndices() == 1 || !isa<Constant>(GEPIdx));\n        Bundle[BundleIndex++] = GEPIdx;\n      }\n\n      // Try and vectorize the indices. We are currently only interested in\n      // gather-like cases of the form:\n      //\n      // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...\n      //\n      // where the loads of \"a\", the loads of \"b\", and the subtractions can be\n      // performed in parallel. It's likely that detecting this pattern in a\n      // bottom-up phase will be simpler and less costly than building a\n      // full-blown top-down phase beginning at the consecutive loads.\n      Changed |= tryToVectorizeList(Bundle, R);\n    }\n  }\n  return Changed;\n}\n\nbool SLPVectorizerPass::vectorizeStoreChains(BoUpSLP &R) {\n  bool Changed = false;\n  // Attempt to sort and vectorize each of the store-groups.\n  for (StoreListMap::iterator it = Stores.begin(), e = Stores.end(); it != e;\n       ++it) {\n    if (it->second.size() < 2)\n      continue;\n\n    LLVM_DEBUG(dbgs() << \"SLP: Analyzing a store chain of length \"\n                      << it->second.size() << \".\\n\");\n\n    Changed |= vectorizeStores(it->second, R);\n  }\n  return Changed;\n}\n\nchar SLPVectorizer::ID = 0;\n\nstatic const char lv_name[] = \"SLP Vectorizer\";\n\nINITIALIZE_PASS_BEGIN(SLPVectorizer, SV_NAME, lv_name, false, false)\nINITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)\nINITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(LoopSimplify)\nINITIALIZE_PASS_DEPENDENCY(DemandedBitsWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(OptimizationRemarkEmitterWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(InjectTLIMappingsLegacy)\nINITIALIZE_PASS_END(SLPVectorizer, SV_NAME, lv_name, false, false)\n\nPass *llvm::createSLPVectorizerPass() { return new SLPVectorizer(); }\n"}}, "reports": [{"events": [{"location": {"col": 15, "file": 3, "line": 2598}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 3, "line": 1509}, "message": "differing parameters are named here: ('Roots', 'EI'), in definition: ('VL', 'UserTreeIdx')"}, {"location": {"col": 8, "file": 3, "line": 1509}, "message": "function 'llvm::slpvectorizer::BoUpSLP::buildTree_rec' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp", "reportHash": "da34972b0bc68b97ca8c5cf1dac26017", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
