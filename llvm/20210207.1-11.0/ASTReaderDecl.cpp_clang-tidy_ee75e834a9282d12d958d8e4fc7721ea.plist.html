<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp", "content": "//===- ASTReaderDecl.cpp - Decl Deserialization ---------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the ASTReader::readDeclRecord method, which is the\n// entrypoint for loading a decl.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"ASTCommon.h\"\n#include \"ASTReaderInternals.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/AttrIterator.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclFriend.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclOpenMP.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/DeclVisitor.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/LambdaCapture.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/OpenMPClause.h\"\n#include \"clang/AST/Redeclarable.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/UnresolvedSet.h\"\n#include \"clang/Basic/AttrKinds.h\"\n#include \"clang/Basic/ExceptionSpecificationType.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Lambda.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/Linkage.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/PragmaKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Sema/IdentifierResolver.h\"\n#include \"clang/Serialization/ASTBitCodes.h\"\n#include \"clang/Serialization/ASTRecordReader.h\"\n#include \"clang/Serialization/ContinuousRangeMap.h\"\n#include \"clang/Serialization/ModuleFile.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Bitstream/BitstreamReader.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/SaveAndRestore.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <cstring>\n#include <string>\n#include <utility>\n\nusing namespace clang;\nusing namespace serialization;\n\n//===----------------------------------------------------------------------===//\n// Declaration deserialization\n//===----------------------------------------------------------------------===//\n\nnamespace clang {\n\n  class ASTDeclReader : public DeclVisitor<ASTDeclReader, void> {\n    ASTReader &Reader;\n    ASTRecordReader &Record;\n    ASTReader::RecordLocation Loc;\n    const DeclID ThisDeclID;\n    const SourceLocation ThisDeclLoc;\n\n    using RecordData = ASTReader::RecordData;\n\n    TypeID DeferredTypeID = 0;\n    unsigned AnonymousDeclNumber;\n    GlobalDeclID NamedDeclForTagDecl = 0;\n    IdentifierInfo *TypedefNameForLinkage = nullptr;\n\n    bool HasPendingBody = false;\n\n    ///A flag to carry the information for a decl from the entity is\n    /// used. We use it to delay the marking of the canonical decl as used until\n    /// the entire declaration is deserialized and merged.\n    bool IsDeclMarkedUsed = false;\n\n    uint64_t GetCurrentCursorOffset();\n\n    uint64_t ReadLocalOffset() {\n      uint64_t LocalOffset = Record.readInt();\n      assert(LocalOffset < Loc.Offset && \"offset point after current record\");\n      return LocalOffset ? Loc.Offset - LocalOffset : 0;\n    }\n\n    uint64_t ReadGlobalOffset() {\n      uint64_t Local = ReadLocalOffset();\n      return Local ? Record.getGlobalBitOffset(Local) : 0;\n    }\n\n    SourceLocation readSourceLocation() {\n      return Record.readSourceLocation();\n    }\n\n    SourceRange readSourceRange() {\n      return Record.readSourceRange();\n    }\n\n    TypeSourceInfo *readTypeSourceInfo() {\n      return Record.readTypeSourceInfo();\n    }\n\n    serialization::DeclID readDeclID() {\n      return Record.readDeclID();\n    }\n\n    std::string readString() {\n      return Record.readString();\n    }\n\n    void readDeclIDList(SmallVectorImpl<DeclID> &IDs) {\n      for (unsigned I = 0, Size = Record.readInt(); I != Size; ++I)\n        IDs.push_back(readDeclID());\n    }\n\n    Decl *readDecl() {\n      return Record.readDecl();\n    }\n\n    template<typename T>\n    T *readDeclAs() {\n      return Record.readDeclAs<T>();\n    }\n\n    serialization::SubmoduleID readSubmoduleID() {\n      if (Record.getIdx() == Record.size())\n        return 0;\n\n      return Record.getGlobalSubmoduleID(Record.readInt());\n    }\n\n    Module *readModule() {\n      return Record.getSubmodule(readSubmoduleID());\n    }\n\n    void ReadCXXRecordDefinition(CXXRecordDecl *D, bool Update);\n    void ReadCXXDefinitionData(struct CXXRecordDecl::DefinitionData &Data,\n                               const CXXRecordDecl *D);\n    void MergeDefinitionData(CXXRecordDecl *D,\n                             struct CXXRecordDecl::DefinitionData &&NewDD);\n    void ReadObjCDefinitionData(struct ObjCInterfaceDecl::DefinitionData &Data);\n    void MergeDefinitionData(ObjCInterfaceDecl *D,\n                             struct ObjCInterfaceDecl::DefinitionData &&NewDD);\n    void ReadObjCDefinitionData(struct ObjCProtocolDecl::DefinitionData &Data);\n    void MergeDefinitionData(ObjCProtocolDecl *D,\n                             struct ObjCProtocolDecl::DefinitionData &&NewDD);\n\n    static DeclContext *getPrimaryDCForAnonymousDecl(DeclContext *LexicalDC);\n\n    static NamedDecl *getAnonymousDeclForMerging(ASTReader &Reader,\n                                                 DeclContext *DC,\n                                                 unsigned Index);\n    static void setAnonymousDeclForMerging(ASTReader &Reader, DeclContext *DC,\n                                           unsigned Index, NamedDecl *D);\n\n    /// Results from loading a RedeclarableDecl.\n    class RedeclarableResult {\n      Decl *MergeWith;\n      GlobalDeclID FirstID;\n      bool IsKeyDecl;\n\n    public:\n      RedeclarableResult(Decl *MergeWith, GlobalDeclID FirstID, bool IsKeyDecl)\n          : MergeWith(MergeWith), FirstID(FirstID), IsKeyDecl(IsKeyDecl) {}\n\n      /// Retrieve the first ID.\n      GlobalDeclID getFirstID() const { return FirstID; }\n\n      /// Is this declaration a key declaration?\n      bool isKeyDecl() const { return IsKeyDecl; }\n\n      /// Get a known declaration that this should be merged with, if\n      /// any.\n      Decl *getKnownMergeTarget() const { return MergeWith; }\n    };\n\n    /// Class used to capture the result of searching for an existing\n    /// declaration of a specific kind and name, along with the ability\n    /// to update the place where this result was found (the declaration\n    /// chain hanging off an identifier or the DeclContext we searched in)\n    /// if requested.\n    class FindExistingResult {\n      ASTReader &Reader;\n      NamedDecl *New = nullptr;\n      NamedDecl *Existing = nullptr;\n      bool AddResult = false;\n      unsigned AnonymousDeclNumber = 0;\n      IdentifierInfo *TypedefNameForLinkage = nullptr;\n\n    public:\n      FindExistingResult(ASTReader &Reader) : Reader(Reader) {}\n\n      FindExistingResult(ASTReader &Reader, NamedDecl *New, NamedDecl *Existing,\n                         unsigned AnonymousDeclNumber,\n                         IdentifierInfo *TypedefNameForLinkage)\n          : Reader(Reader), New(New), Existing(Existing), AddResult(true),\n            AnonymousDeclNumber(AnonymousDeclNumber),\n            TypedefNameForLinkage(TypedefNameForLinkage) {}\n\n      FindExistingResult(FindExistingResult &&Other)\n          : Reader(Other.Reader), New(Other.New), Existing(Other.Existing),\n            AddResult(Other.AddResult),\n            AnonymousDeclNumber(Other.AnonymousDeclNumber),\n            TypedefNameForLinkage(Other.TypedefNameForLinkage) {\n        Other.AddResult = false;\n      }\n\n      FindExistingResult &operator=(FindExistingResult &&) = delete;\n      ~FindExistingResult();\n\n      /// Suppress the addition of this result into the known set of\n      /// names.\n      void suppress() { AddResult = false; }\n\n      operator NamedDecl*() const { return Existing; }\n\n      template<typename T>\n      operator T*() const { return dyn_cast_or_null<T>(Existing); }\n    };\n\n    static DeclContext *getPrimaryContextForMerging(ASTReader &Reader,\n                                                    DeclContext *DC);\n    FindExistingResult findExisting(NamedDecl *D);\n\n  public:\n    ASTDeclReader(ASTReader &Reader, ASTRecordReader &Record,\n                  ASTReader::RecordLocation Loc,\n                  DeclID thisDeclID, SourceLocation ThisDeclLoc)\n        : Reader(Reader), Record(Record), Loc(Loc), ThisDeclID(thisDeclID),\n          ThisDeclLoc(ThisDeclLoc) {}\n\n    template <typename T> static\n    void AddLazySpecializations(T *D,\n                                SmallVectorImpl<serialization::DeclID>& IDs) {\n      if (IDs.empty())\n        return;\n\n      // FIXME: We should avoid this pattern of getting the ASTContext.\n      ASTContext &C = D->getASTContext();\n\n      auto *&LazySpecializations = D->getCommonPtr()->LazySpecializations;\n\n      if (auto &Old = LazySpecializations) {\n        IDs.insert(IDs.end(), Old + 1, Old + 1 + Old[0]);\n        llvm::sort(IDs);\n        IDs.erase(std::unique(IDs.begin(), IDs.end()), IDs.end());\n      }\n\n      auto *Result = new (C) serialization::DeclID[1 + IDs.size()];\n      *Result = IDs.size();\n      std::copy(IDs.begin(), IDs.end(), Result + 1);\n\n      LazySpecializations = Result;\n    }\n\n    template <typename DeclT>\n    static Decl *getMostRecentDeclImpl(Redeclarable<DeclT> *D);\n    static Decl *getMostRecentDeclImpl(...);\n    static Decl *getMostRecentDecl(Decl *D);\n\n    static void mergeInheritableAttributes(ASTReader &Reader, Decl *D,\n                                           Decl *Previous);\n\n    template <typename DeclT>\n    static void attachPreviousDeclImpl(ASTReader &Reader,\n                                       Redeclarable<DeclT> *D, Decl *Previous,\n                                       Decl *Canon);\n    static void attachPreviousDeclImpl(ASTReader &Reader, ...);\n    static void attachPreviousDecl(ASTReader &Reader, Decl *D, Decl *Previous,\n                                   Decl *Canon);\n\n    template <typename DeclT>\n    static void attachLatestDeclImpl(Redeclarable<DeclT> *D, Decl *Latest);\n    static void attachLatestDeclImpl(...);\n    static void attachLatestDecl(Decl *D, Decl *latest);\n\n    template <typename DeclT>\n    static void markIncompleteDeclChainImpl(Redeclarable<DeclT> *D);\n    static void markIncompleteDeclChainImpl(...);\n\n    /// Determine whether this declaration has a pending body.\n    bool hasPendingBody() const { return HasPendingBody; }\n\n    void ReadFunctionDefinition(FunctionDecl *FD);\n    void Visit(Decl *D);\n\n    void UpdateDecl(Decl *D, SmallVectorImpl<serialization::DeclID> &);\n\n    static void setNextObjCCategory(ObjCCategoryDecl *Cat,\n                                    ObjCCategoryDecl *Next) {\n      Cat->NextClassCategory = Next;\n    }\n\n    void VisitDecl(Decl *D);\n    void VisitPragmaCommentDecl(PragmaCommentDecl *D);\n    void VisitPragmaDetectMismatchDecl(PragmaDetectMismatchDecl *D);\n    void VisitTranslationUnitDecl(TranslationUnitDecl *TU);\n    void VisitNamedDecl(NamedDecl *ND);\n    void VisitLabelDecl(LabelDecl *LD);\n    void VisitNamespaceDecl(NamespaceDecl *D);\n    void VisitUsingDirectiveDecl(UsingDirectiveDecl *D);\n    void VisitNamespaceAliasDecl(NamespaceAliasDecl *D);\n    void VisitTypeDecl(TypeDecl *TD);\n    RedeclarableResult VisitTypedefNameDecl(TypedefNameDecl *TD);\n    void VisitTypedefDecl(TypedefDecl *TD);\n    void VisitTypeAliasDecl(TypeAliasDecl *TD);\n    void VisitUnresolvedUsingTypenameDecl(UnresolvedUsingTypenameDecl *D);\n    RedeclarableResult VisitTagDecl(TagDecl *TD);\n    void VisitEnumDecl(EnumDecl *ED);\n    RedeclarableResult VisitRecordDeclImpl(RecordDecl *RD);\n    void VisitRecordDecl(RecordDecl *RD) { VisitRecordDeclImpl(RD); }\n    RedeclarableResult VisitCXXRecordDeclImpl(CXXRecordDecl *D);\n    void VisitCXXRecordDecl(CXXRecordDecl *D) { VisitCXXRecordDeclImpl(D); }\n    RedeclarableResult VisitClassTemplateSpecializationDeclImpl(\n                                            ClassTemplateSpecializationDecl *D);\n\n    void VisitClassTemplateSpecializationDecl(\n        ClassTemplateSpecializationDecl *D) {\n      VisitClassTemplateSpecializationDeclImpl(D);\n    }\n\n    void VisitClassTemplatePartialSpecializationDecl(\n                                     ClassTemplatePartialSpecializationDecl *D);\n    void VisitClassScopeFunctionSpecializationDecl(\n                                       ClassScopeFunctionSpecializationDecl *D);\n    RedeclarableResult\n    VisitVarTemplateSpecializationDeclImpl(VarTemplateSpecializationDecl *D);\n\n    void VisitVarTemplateSpecializationDecl(VarTemplateSpecializationDecl *D) {\n      VisitVarTemplateSpecializationDeclImpl(D);\n    }\n\n    void VisitVarTemplatePartialSpecializationDecl(\n        VarTemplatePartialSpecializationDecl *D);\n    void VisitTemplateTypeParmDecl(TemplateTypeParmDecl *D);\n    void VisitValueDecl(ValueDecl *VD);\n    void VisitEnumConstantDecl(EnumConstantDecl *ECD);\n    void VisitUnresolvedUsingValueDecl(UnresolvedUsingValueDecl *D);\n    void VisitDeclaratorDecl(DeclaratorDecl *DD);\n    void VisitFunctionDecl(FunctionDecl *FD);\n    void VisitCXXDeductionGuideDecl(CXXDeductionGuideDecl *GD);\n    void VisitCXXMethodDecl(CXXMethodDecl *D);\n    void VisitCXXConstructorDecl(CXXConstructorDecl *D);\n    void VisitCXXDestructorDecl(CXXDestructorDecl *D);\n    void VisitCXXConversionDecl(CXXConversionDecl *D);\n    void VisitFieldDecl(FieldDecl *FD);\n    void VisitMSPropertyDecl(MSPropertyDecl *FD);\n    void VisitMSGuidDecl(MSGuidDecl *D);\n    void VisitTemplateParamObjectDecl(TemplateParamObjectDecl *D);\n    void VisitIndirectFieldDecl(IndirectFieldDecl *FD);\n    RedeclarableResult VisitVarDeclImpl(VarDecl *D);\n    void VisitVarDecl(VarDecl *VD) { VisitVarDeclImpl(VD); }\n    void VisitImplicitParamDecl(ImplicitParamDecl *PD);\n    void VisitParmVarDecl(ParmVarDecl *PD);\n    void VisitDecompositionDecl(DecompositionDecl *DD);\n    void VisitBindingDecl(BindingDecl *BD);\n    void VisitNonTypeTemplateParmDecl(NonTypeTemplateParmDecl *D);\n    DeclID VisitTemplateDecl(TemplateDecl *D);\n    void VisitConceptDecl(ConceptDecl *D);\n    void VisitRequiresExprBodyDecl(RequiresExprBodyDecl *D);\n    RedeclarableResult VisitRedeclarableTemplateDecl(RedeclarableTemplateDecl *D);\n    void VisitClassTemplateDecl(ClassTemplateDecl *D);\n    void VisitBuiltinTemplateDecl(BuiltinTemplateDecl *D);\n    void VisitVarTemplateDecl(VarTemplateDecl *D);\n    void VisitFunctionTemplateDecl(FunctionTemplateDecl *D);\n    void VisitTemplateTemplateParmDecl(TemplateTemplateParmDecl *D);\n    void VisitTypeAliasTemplateDecl(TypeAliasTemplateDecl *D);\n    void VisitUsingDecl(UsingDecl *D);\n    void VisitUsingPackDecl(UsingPackDecl *D);\n    void VisitUsingShadowDecl(UsingShadowDecl *D);\n    void VisitConstructorUsingShadowDecl(ConstructorUsingShadowDecl *D);\n    void VisitLinkageSpecDecl(LinkageSpecDecl *D);\n    void VisitExportDecl(ExportDecl *D);\n    void VisitFileScopeAsmDecl(FileScopeAsmDecl *AD);\n    void VisitImportDecl(ImportDecl *D);\n    void VisitAccessSpecDecl(AccessSpecDecl *D);\n    void VisitFriendDecl(FriendDecl *D);\n    void VisitFriendTemplateDecl(FriendTemplateDecl *D);\n    void VisitStaticAssertDecl(StaticAssertDecl *D);\n    void VisitBlockDecl(BlockDecl *BD);\n    void VisitCapturedDecl(CapturedDecl *CD);\n    void VisitEmptyDecl(EmptyDecl *D);\n    void VisitLifetimeExtendedTemporaryDecl(LifetimeExtendedTemporaryDecl *D);\n\n    std::pair<uint64_t, uint64_t> VisitDeclContext(DeclContext *DC);\n\n    template<typename T>\n    RedeclarableResult VisitRedeclarable(Redeclarable<T> *D);\n\n    template<typename T>\n    void mergeRedeclarable(Redeclarable<T> *D, RedeclarableResult &Redecl,\n                           DeclID TemplatePatternID = 0);\n\n    template<typename T>\n    void mergeRedeclarable(Redeclarable<T> *D, T *Existing,\n                           RedeclarableResult &Redecl,\n                           DeclID TemplatePatternID = 0);\n\n    template<typename T>\n    void mergeMergeable(Mergeable<T> *D);\n\n    void mergeMergeable(LifetimeExtendedTemporaryDecl *D);\n\n    void mergeTemplatePattern(RedeclarableTemplateDecl *D,\n                              RedeclarableTemplateDecl *Existing,\n                              DeclID DsID, bool IsKeyDecl);\n\n    ObjCTypeParamList *ReadObjCTypeParamList();\n\n    // FIXME: Reorder according to DeclNodes.td?\n    void VisitObjCMethodDecl(ObjCMethodDecl *D);\n    void VisitObjCTypeParamDecl(ObjCTypeParamDecl *D);\n    void VisitObjCContainerDecl(ObjCContainerDecl *D);\n    void VisitObjCInterfaceDecl(ObjCInterfaceDecl *D);\n    void VisitObjCIvarDecl(ObjCIvarDecl *D);\n    void VisitObjCProtocolDecl(ObjCProtocolDecl *D);\n    void VisitObjCAtDefsFieldDecl(ObjCAtDefsFieldDecl *D);\n    void VisitObjCCategoryDecl(ObjCCategoryDecl *D);\n    void VisitObjCImplDecl(ObjCImplDecl *D);\n    void VisitObjCCategoryImplDecl(ObjCCategoryImplDecl *D);\n    void VisitObjCImplementationDecl(ObjCImplementationDecl *D);\n    void VisitObjCCompatibleAliasDecl(ObjCCompatibleAliasDecl *D);\n    void VisitObjCPropertyDecl(ObjCPropertyDecl *D);\n    void VisitObjCPropertyImplDecl(ObjCPropertyImplDecl *D);\n    void VisitOMPThreadPrivateDecl(OMPThreadPrivateDecl *D);\n    void VisitOMPAllocateDecl(OMPAllocateDecl *D);\n    void VisitOMPDeclareReductionDecl(OMPDeclareReductionDecl *D);\n    void VisitOMPDeclareMapperDecl(OMPDeclareMapperDecl *D);\n    void VisitOMPRequiresDecl(OMPRequiresDecl *D);\n    void VisitOMPCapturedExprDecl(OMPCapturedExprDecl *D);\n  };\n\n} // namespace clang\n\nnamespace {\n\n/// Iterator over the redeclarations of a declaration that have already\n/// been merged into the same redeclaration chain.\ntemplate<typename DeclT>\nclass MergedRedeclIterator {\n  DeclT *Start;\n  DeclT *Canonical = nullptr;\n  DeclT *Current = nullptr;\n\npublic:\n  MergedRedeclIterator() = default;\n  MergedRedeclIterator(DeclT *Start) : Start(Start), Current(Start) {}\n\n  DeclT *operator*() { return Current; }\n\n  MergedRedeclIterator &operator++() {\n    if (Current->isFirstDecl()) {\n      Canonical = Current;\n      Current = Current->getMostRecentDecl();\n    } else\n      Current = Current->getPreviousDecl();\n\n    // If we started in the merged portion, we'll reach our start position\n    // eventually. Otherwise, we'll never reach it, but the second declaration\n    // we reached was the canonical declaration, so stop when we see that one\n    // again.\n    if (Current == Start || Current == Canonical)\n      Current = nullptr;\n    return *this;\n  }\n\n  friend bool operator!=(const MergedRedeclIterator &A,\n                         const MergedRedeclIterator &B) {\n    return A.Current != B.Current;\n  }\n};\n\n} // namespace\n\ntemplate <typename DeclT>\nstatic llvm::iterator_range<MergedRedeclIterator<DeclT>>\nmerged_redecls(DeclT *D) {\n  return llvm::make_range(MergedRedeclIterator<DeclT>(D),\n                          MergedRedeclIterator<DeclT>());\n}\n\nuint64_t ASTDeclReader::GetCurrentCursorOffset() {\n  return Loc.F->DeclsCursor.GetCurrentBitNo() + Loc.F->GlobalBitOffset;\n}\n\nvoid ASTDeclReader::ReadFunctionDefinition(FunctionDecl *FD) {\n  if (Record.readInt()) {\n    Reader.DefinitionSource[FD] =\n        Loc.F->Kind == ModuleKind::MK_MainFile ||\n        Reader.getContext().getLangOpts().BuildingPCHWithObjectFile;\n  }\n  if (auto *CD = dyn_cast<CXXConstructorDecl>(FD)) {\n    CD->setNumCtorInitializers(Record.readInt());\n    if (CD->getNumCtorInitializers())\n      CD->CtorInitializers = ReadGlobalOffset();\n  }\n  // Store the offset of the body so we can lazily load it later.\n  Reader.PendingBodies[FD] = GetCurrentCursorOffset();\n  HasPendingBody = true;\n}\n\nvoid ASTDeclReader::Visit(Decl *D) {\n  DeclVisitor<ASTDeclReader, void>::Visit(D);\n\n  // At this point we have deserialized and merged the decl and it is safe to\n  // update its canonical decl to signal that the entire entity is used.\n  D->getCanonicalDecl()->Used |= IsDeclMarkedUsed;\n  IsDeclMarkedUsed = false;\n\n  if (auto *DD = dyn_cast<DeclaratorDecl>(D)) {\n    if (auto *TInfo = DD->getTypeSourceInfo())\n      Record.readTypeLoc(TInfo->getTypeLoc());\n  }\n\n  if (auto *TD = dyn_cast<TypeDecl>(D)) {\n    // We have a fully initialized TypeDecl. Read its type now.\n    TD->setTypeForDecl(Reader.GetType(DeferredTypeID).getTypePtrOrNull());\n\n    // If this is a tag declaration with a typedef name for linkage, it's safe\n    // to load that typedef now.\n    if (NamedDeclForTagDecl)\n      cast<TagDecl>(D)->TypedefNameDeclOrQualifier =\n          cast<TypedefNameDecl>(Reader.GetDecl(NamedDeclForTagDecl));\n  } else if (auto *ID = dyn_cast<ObjCInterfaceDecl>(D)) {\n    // if we have a fully initialized TypeDecl, we can safely read its type now.\n    ID->TypeForDecl = Reader.GetType(DeferredTypeID).getTypePtrOrNull();\n  } else if (auto *FD = dyn_cast<FunctionDecl>(D)) {\n    // FunctionDecl's body was written last after all other Stmts/Exprs.\n    // We only read it if FD doesn't already have a body (e.g., from another\n    // module).\n    // FIXME: Can we diagnose ODR violations somehow?\n    if (Record.readInt())\n      ReadFunctionDefinition(FD);\n  }\n}\n\nvoid ASTDeclReader::VisitDecl(Decl *D) {\n  if (D->isTemplateParameter() || D->isTemplateParameterPack() ||\n      isa<ParmVarDecl>(D) || isa<ObjCTypeParamDecl>(D)) {\n    // We don't want to deserialize the DeclContext of a template\n    // parameter or of a parameter of a function template immediately.   These\n    // entities might be used in the formulation of its DeclContext (for\n    // example, a function parameter can be used in decltype() in trailing\n    // return type of the function).  Use the translation unit DeclContext as a\n    // placeholder.\n    GlobalDeclID SemaDCIDForTemplateParmDecl = readDeclID();\n    GlobalDeclID LexicalDCIDForTemplateParmDecl = readDeclID();\n    if (!LexicalDCIDForTemplateParmDecl)\n      LexicalDCIDForTemplateParmDecl = SemaDCIDForTemplateParmDecl;\n    Reader.addPendingDeclContextInfo(D,\n                                     SemaDCIDForTemplateParmDecl,\n                                     LexicalDCIDForTemplateParmDecl);\n    D->setDeclContext(Reader.getContext().getTranslationUnitDecl());\n  } else {\n    auto *SemaDC = readDeclAs<DeclContext>();\n    auto *LexicalDC = readDeclAs<DeclContext>();\n    if (!LexicalDC)\n      LexicalDC = SemaDC;\n    DeclContext *MergedSemaDC = Reader.MergedDeclContexts.lookup(SemaDC);\n    // Avoid calling setLexicalDeclContext() directly because it uses\n    // Decl::getASTContext() internally which is unsafe during derialization.\n    D->setDeclContextsImpl(MergedSemaDC ? MergedSemaDC : SemaDC, LexicalDC,\n                           Reader.getContext());\n  }\n  D->setLocation(ThisDeclLoc);\n  D->InvalidDecl = Record.readInt();\n  if (Record.readInt()) { // hasAttrs\n    AttrVec Attrs;\n    Record.readAttributes(Attrs);\n    // Avoid calling setAttrs() directly because it uses Decl::getASTContext()\n    // internally which is unsafe during derialization.\n    D->setAttrsImpl(Attrs, Reader.getContext());\n  }\n  D->setImplicit(Record.readInt());\n  D->Used = Record.readInt();\n  IsDeclMarkedUsed |= D->Used;\n  D->setReferenced(Record.readInt());\n  D->setTopLevelDeclInObjCContainer(Record.readInt());\n  D->setAccess((AccessSpecifier)Record.readInt());\n  D->FromASTFile = true;\n  bool ModulePrivate = Record.readInt();\n\n  // Determine whether this declaration is part of a (sub)module. If so, it\n  // may not yet be visible.\n  if (unsigned SubmoduleID = readSubmoduleID()) {\n    // Store the owning submodule ID in the declaration.\n    D->setModuleOwnershipKind(\n        ModulePrivate ? Decl::ModuleOwnershipKind::ModulePrivate\n                      : Decl::ModuleOwnershipKind::VisibleWhenImported);\n    D->setOwningModuleID(SubmoduleID);\n\n    if (ModulePrivate) {\n      // Module-private declarations are never visible, so there is no work to\n      // do.\n    } else if (Reader.getContext().getLangOpts().ModulesLocalVisibility) {\n      // If local visibility is being tracked, this declaration will become\n      // hidden and visible as the owning module does.\n    } else if (Module *Owner = Reader.getSubmodule(SubmoduleID)) {\n      // Mark the declaration as visible when its owning module becomes visible.\n      if (Owner->NameVisibility == Module::AllVisible)\n        D->setVisibleDespiteOwningModule();\n      else\n        Reader.HiddenNamesMap[Owner].push_back(D);\n    }\n  } else if (ModulePrivate) {\n    D->setModuleOwnershipKind(Decl::ModuleOwnershipKind::ModulePrivate);\n  }\n}\n\nvoid ASTDeclReader::VisitPragmaCommentDecl(PragmaCommentDecl *D) {\n  VisitDecl(D);\n  D->setLocation(readSourceLocation());\n  D->CommentKind = (PragmaMSCommentKind)Record.readInt();\n  std::string Arg = readString();\n  memcpy(D->getTrailingObjects<char>(), Arg.data(), Arg.size());\n  D->getTrailingObjects<char>()[Arg.size()] = '\\0';\n}\n\nvoid ASTDeclReader::VisitPragmaDetectMismatchDecl(PragmaDetectMismatchDecl *D) {\n  VisitDecl(D);\n  D->setLocation(readSourceLocation());\n  std::string Name = readString();\n  memcpy(D->getTrailingObjects<char>(), Name.data(), Name.size());\n  D->getTrailingObjects<char>()[Name.size()] = '\\0';\n\n  D->ValueStart = Name.size() + 1;\n  std::string Value = readString();\n  memcpy(D->getTrailingObjects<char>() + D->ValueStart, Value.data(),\n         Value.size());\n  D->getTrailingObjects<char>()[D->ValueStart + Value.size()] = '\\0';\n}\n\nvoid ASTDeclReader::VisitTranslationUnitDecl(TranslationUnitDecl *TU) {\n  llvm_unreachable(\"Translation units are not serialized\");\n}\n\nvoid ASTDeclReader::VisitNamedDecl(NamedDecl *ND) {\n  VisitDecl(ND);\n  ND->setDeclName(Record.readDeclarationName());\n  AnonymousDeclNumber = Record.readInt();\n}\n\nvoid ASTDeclReader::VisitTypeDecl(TypeDecl *TD) {\n  VisitNamedDecl(TD);\n  TD->setLocStart(readSourceLocation());\n  // Delay type reading until after we have fully initialized the decl.\n  DeferredTypeID = Record.getGlobalTypeID(Record.readInt());\n}\n\nASTDeclReader::RedeclarableResult\nASTDeclReader::VisitTypedefNameDecl(TypedefNameDecl *TD) {\n  RedeclarableResult Redecl = VisitRedeclarable(TD);\n  VisitTypeDecl(TD);\n  TypeSourceInfo *TInfo = readTypeSourceInfo();\n  if (Record.readInt()) { // isModed\n    QualType modedT = Record.readType();\n    TD->setModedTypeSourceInfo(TInfo, modedT);\n  } else\n    TD->setTypeSourceInfo(TInfo);\n  // Read and discard the declaration for which this is a typedef name for\n  // linkage, if it exists. We cannot rely on our type to pull in this decl,\n  // because it might have been merged with a type from another module and\n  // thus might not refer to our version of the declaration.\n  readDecl();\n  return Redecl;\n}\n\nvoid ASTDeclReader::VisitTypedefDecl(TypedefDecl *TD) {\n  RedeclarableResult Redecl = VisitTypedefNameDecl(TD);\n  mergeRedeclarable(TD, Redecl);\n}\n\nvoid ASTDeclReader::VisitTypeAliasDecl(TypeAliasDecl *TD) {\n  RedeclarableResult Redecl = VisitTypedefNameDecl(TD);\n  if (auto *Template = readDeclAs<TypeAliasTemplateDecl>())\n    // Merged when we merge the template.\n    TD->setDescribedAliasTemplate(Template);\n  else\n    mergeRedeclarable(TD, Redecl);\n}\n\nASTDeclReader::RedeclarableResult ASTDeclReader::VisitTagDecl(TagDecl *TD) {\n  RedeclarableResult Redecl = VisitRedeclarable(TD);\n  VisitTypeDecl(TD);\n\n  TD->IdentifierNamespace = Record.readInt();\n  TD->setTagKind((TagDecl::TagKind)Record.readInt());\n  if (!isa<CXXRecordDecl>(TD))\n    TD->setCompleteDefinition(Record.readInt());\n  TD->setEmbeddedInDeclarator(Record.readInt());\n  TD->setFreeStanding(Record.readInt());\n  TD->setCompleteDefinitionRequired(Record.readInt());\n  TD->setBraceRange(readSourceRange());\n\n  switch (Record.readInt()) {\n  case 0:\n    break;\n  case 1: { // ExtInfo\n    auto *Info = new (Reader.getContext()) TagDecl::ExtInfo();\n    Record.readQualifierInfo(*Info);\n    TD->TypedefNameDeclOrQualifier = Info;\n    break;\n  }\n  case 2: // TypedefNameForAnonDecl\n    NamedDeclForTagDecl = readDeclID();\n    TypedefNameForLinkage = Record.readIdentifier();\n    break;\n  default:\n    llvm_unreachable(\"unexpected tag info kind\");\n  }\n\n  if (!isa<CXXRecordDecl>(TD))\n    mergeRedeclarable(TD, Redecl);\n  return Redecl;\n}\n\nvoid ASTDeclReader::VisitEnumDecl(EnumDecl *ED) {\n  VisitTagDecl(ED);\n  if (TypeSourceInfo *TI = readTypeSourceInfo())\n    ED->setIntegerTypeSourceInfo(TI);\n  else\n    ED->setIntegerType(Record.readType());\n  ED->setPromotionType(Record.readType());\n  ED->setNumPositiveBits(Record.readInt());\n  ED->setNumNegativeBits(Record.readInt());\n  ED->setScoped(Record.readInt());\n  ED->setScopedUsingClassTag(Record.readInt());\n  ED->setFixed(Record.readInt());\n\n  ED->setHasODRHash(true);\n  ED->ODRHash = Record.readInt();\n\n  // If this is a definition subject to the ODR, and we already have a\n  // definition, merge this one into it.\n  if (ED->isCompleteDefinition() &&\n      Reader.getContext().getLangOpts().Modules &&\n      Reader.getContext().getLangOpts().CPlusPlus) {\n    EnumDecl *&OldDef = Reader.EnumDefinitions[ED->getCanonicalDecl()];\n    if (!OldDef) {\n      // This is the first time we've seen an imported definition. Look for a\n      // local definition before deciding that we are the first definition.\n      for (auto *D : merged_redecls(ED->getCanonicalDecl())) {\n        if (!D->isFromASTFile() && D->isCompleteDefinition()) {\n          OldDef = D;\n          break;\n        }\n      }\n    }\n    if (OldDef) {\n      Reader.MergedDeclContexts.insert(std::make_pair(ED, OldDef));\n      ED->setCompleteDefinition(false);\n      Reader.mergeDefinitionVisibility(OldDef, ED);\n      if (OldDef->getODRHash() != ED->getODRHash())\n        Reader.PendingEnumOdrMergeFailures[OldDef].push_back(ED);\n    } else {\n      OldDef = ED;\n    }\n  }\n\n  if (auto *InstED = readDeclAs<EnumDecl>()) {\n    auto TSK = (TemplateSpecializationKind)Record.readInt();\n    SourceLocation POI = readSourceLocation();\n    ED->setInstantiationOfMemberEnum(Reader.getContext(), InstED, TSK);\n    ED->getMemberSpecializationInfo()->setPointOfInstantiation(POI);\n  }\n}\n\nASTDeclReader::RedeclarableResult\nASTDeclReader::VisitRecordDeclImpl(RecordDecl *RD) {\n  RedeclarableResult Redecl = VisitTagDecl(RD);\n  RD->setHasFlexibleArrayMember(Record.readInt());\n  RD->setAnonymousStructOrUnion(Record.readInt());\n  RD->setHasObjectMember(Record.readInt());\n  RD->setHasVolatileMember(Record.readInt());\n  RD->setNonTrivialToPrimitiveDefaultInitialize(Record.readInt());\n  RD->setNonTrivialToPrimitiveCopy(Record.readInt());\n  RD->setNonTrivialToPrimitiveDestroy(Record.readInt());\n  RD->setHasNonTrivialToPrimitiveDefaultInitializeCUnion(Record.readInt());\n  RD->setHasNonTrivialToPrimitiveDestructCUnion(Record.readInt());\n  RD->setHasNonTrivialToPrimitiveCopyCUnion(Record.readInt());\n  RD->setParamDestroyedInCallee(Record.readInt());\n  RD->setArgPassingRestrictions((RecordDecl::ArgPassingKind)Record.readInt());\n  return Redecl;\n}\n\nvoid ASTDeclReader::VisitValueDecl(ValueDecl *VD) {\n  VisitNamedDecl(VD);\n  // For function declarations, defer reading the type in case the function has\n  // a deduced return type that references an entity declared within the\n  // function.\n  if (isa<FunctionDecl>(VD))\n    DeferredTypeID = Record.getGlobalTypeID(Record.readInt());\n  else\n    VD->setType(Record.readType());\n}\n\nvoid ASTDeclReader::VisitEnumConstantDecl(EnumConstantDecl *ECD) {\n  VisitValueDecl(ECD);\n  if (Record.readInt())\n    ECD->setInitExpr(Record.readExpr());\n  ECD->setInitVal(Record.readAPSInt());\n  mergeMergeable(ECD);\n}\n\nvoid ASTDeclReader::VisitDeclaratorDecl(DeclaratorDecl *DD) {\n  VisitValueDecl(DD);\n  DD->setInnerLocStart(readSourceLocation());\n  if (Record.readInt()) { // hasExtInfo\n    auto *Info = new (Reader.getContext()) DeclaratorDecl::ExtInfo();\n    Record.readQualifierInfo(*Info);\n    Info->TrailingRequiresClause = Record.readExpr();\n    DD->DeclInfo = Info;\n  }\n  QualType TSIType = Record.readType();\n  DD->setTypeSourceInfo(\n      TSIType.isNull() ? nullptr\n                       : Reader.getContext().CreateTypeSourceInfo(TSIType));\n}\n\nvoid ASTDeclReader::VisitFunctionDecl(FunctionDecl *FD) {\n  RedeclarableResult Redecl = VisitRedeclarable(FD);\n  VisitDeclaratorDecl(FD);\n\n  // Attach a type to this function. Use the real type if possible, but fall\n  // back to the type as written if it involves a deduced return type.\n  if (FD->getTypeSourceInfo() &&\n      FD->getTypeSourceInfo()->getType()->castAs<FunctionType>()\n                             ->getReturnType()->getContainedAutoType()) {\n    // We'll set up the real type in Visit, once we've finished loading the\n    // function.\n    FD->setType(FD->getTypeSourceInfo()->getType());\n    Reader.PendingFunctionTypes.push_back({FD, DeferredTypeID});\n  } else {\n    FD->setType(Reader.GetType(DeferredTypeID));\n  }\n  DeferredTypeID = 0;\n\n  FD->DNLoc = Record.readDeclarationNameLoc(FD->getDeclName());\n  FD->IdentifierNamespace = Record.readInt();\n\n  // FunctionDecl's body is handled last at ASTDeclReader::Visit,\n  // after everything else is read.\n\n  FD->setStorageClass(static_cast<StorageClass>(Record.readInt()));\n  FD->setInlineSpecified(Record.readInt());\n  FD->setImplicitlyInline(Record.readInt());\n  FD->setVirtualAsWritten(Record.readInt());\n  // We defer calling `FunctionDecl::setPure()` here as for methods of\n  // `CXXTemplateSpecializationDecl`s, we may not have connected up the\n  // definition (which is required for `setPure`).\n  const bool Pure = Record.readInt();\n  FD->setHasInheritedPrototype(Record.readInt());\n  FD->setHasWrittenPrototype(Record.readInt());\n  FD->setDeletedAsWritten(Record.readInt());\n  FD->setTrivial(Record.readInt());\n  FD->setTrivialForCall(Record.readInt());\n  FD->setDefaulted(Record.readInt());\n  FD->setExplicitlyDefaulted(Record.readInt());\n  FD->setHasImplicitReturnZero(Record.readInt());\n  FD->setConstexprKind(static_cast<ConstexprSpecKind>(Record.readInt()));\n  FD->setUsesSEHTry(Record.readInt());\n  FD->setHasSkippedBody(Record.readInt());\n  FD->setIsMultiVersion(Record.readInt());\n  FD->setLateTemplateParsed(Record.readInt());\n\n  FD->setCachedLinkage(static_cast<Linkage>(Record.readInt()));\n  FD->EndRangeLoc = readSourceLocation();\n\n  FD->ODRHash = Record.readInt();\n  FD->setHasODRHash(true);\n\n  if (FD->isDefaulted()) {\n    if (unsigned NumLookups = Record.readInt()) {\n      SmallVector<DeclAccessPair, 8> Lookups;\n      for (unsigned I = 0; I != NumLookups; ++I) {\n        NamedDecl *ND = Record.readDeclAs<NamedDecl>();\n        AccessSpecifier AS = (AccessSpecifier)Record.readInt();\n        Lookups.push_back(DeclAccessPair::make(ND, AS));\n      }\n      FD->setDefaultedFunctionInfo(FunctionDecl::DefaultedFunctionInfo::Create(\n          Reader.getContext(), Lookups));\n    }\n  }\n\n  switch ((FunctionDecl::TemplatedKind)Record.readInt()) {\n  case FunctionDecl::TK_NonTemplate:\n    mergeRedeclarable(FD, Redecl);\n    break;\n  case FunctionDecl::TK_FunctionTemplate:\n    // Merged when we merge the template.\n    FD->setDescribedFunctionTemplate(readDeclAs<FunctionTemplateDecl>());\n    break;\n  case FunctionDecl::TK_MemberSpecialization: {\n    auto *InstFD = readDeclAs<FunctionDecl>();\n    auto TSK = (TemplateSpecializationKind)Record.readInt();\n    SourceLocation POI = readSourceLocation();\n    FD->setInstantiationOfMemberFunction(Reader.getContext(), InstFD, TSK);\n    FD->getMemberSpecializationInfo()->setPointOfInstantiation(POI);\n    mergeRedeclarable(FD, Redecl);\n    break;\n  }\n  case FunctionDecl::TK_FunctionTemplateSpecialization: {\n    auto *Template = readDeclAs<FunctionTemplateDecl>();\n    auto TSK = (TemplateSpecializationKind)Record.readInt();\n\n    // Template arguments.\n    SmallVector<TemplateArgument, 8> TemplArgs;\n    Record.readTemplateArgumentList(TemplArgs, /*Canonicalize*/ true);\n\n    // Template args as written.\n    SmallVector<TemplateArgumentLoc, 8> TemplArgLocs;\n    SourceLocation LAngleLoc, RAngleLoc;\n    bool HasTemplateArgumentsAsWritten = Record.readInt();\n    if (HasTemplateArgumentsAsWritten) {\n      unsigned NumTemplateArgLocs = Record.readInt();\n      TemplArgLocs.reserve(NumTemplateArgLocs);\n      for (unsigned i = 0; i != NumTemplateArgLocs; ++i)\n        TemplArgLocs.push_back(Record.readTemplateArgumentLoc());\n\n      LAngleLoc = readSourceLocation();\n      RAngleLoc = readSourceLocation();\n    }\n\n    SourceLocation POI = readSourceLocation();\n\n    ASTContext &C = Reader.getContext();\n    TemplateArgumentList *TemplArgList\n      = TemplateArgumentList::CreateCopy(C, TemplArgs);\n    TemplateArgumentListInfo TemplArgsInfo(LAngleLoc, RAngleLoc);\n    for (unsigned i = 0, e = TemplArgLocs.size(); i != e; ++i)\n      TemplArgsInfo.addArgument(TemplArgLocs[i]);\n\n    MemberSpecializationInfo *MSInfo = nullptr;\n    if (Record.readInt()) {\n      auto *FD = readDeclAs<FunctionDecl>();\n      auto TSK = (TemplateSpecializationKind)Record.readInt();\n      SourceLocation POI = readSourceLocation();\n\n      MSInfo = new (C) MemberSpecializationInfo(FD, TSK);\n      MSInfo->setPointOfInstantiation(POI);\n    }\n\n    FunctionTemplateSpecializationInfo *FTInfo =\n        FunctionTemplateSpecializationInfo::Create(\n            C, FD, Template, TSK, TemplArgList,\n            HasTemplateArgumentsAsWritten ? &TemplArgsInfo : nullptr, POI,\n            MSInfo);\n    FD->TemplateOrSpecialization = FTInfo;\n\n    if (FD->isCanonicalDecl()) { // if canonical add to template's set.\n      // The template that contains the specializations set. It's not safe to\n      // use getCanonicalDecl on Template since it may still be initializing.\n      auto *CanonTemplate = readDeclAs<FunctionTemplateDecl>();\n      // Get the InsertPos by FindNodeOrInsertPos() instead of calling\n      // InsertNode(FTInfo) directly to avoid the getASTContext() call in\n      // FunctionTemplateSpecializationInfo's Profile().\n      // We avoid getASTContext because a decl in the parent hierarchy may\n      // be initializing.\n      llvm::FoldingSetNodeID ID;\n      FunctionTemplateSpecializationInfo::Profile(ID, TemplArgs, C);\n      void *InsertPos = nullptr;\n      FunctionTemplateDecl::Common *CommonPtr = CanonTemplate->getCommonPtr();\n      FunctionTemplateSpecializationInfo *ExistingInfo =\n          CommonPtr->Specializations.FindNodeOrInsertPos(ID, InsertPos);\n      if (InsertPos)\n        CommonPtr->Specializations.InsertNode(FTInfo, InsertPos);\n      else {\n        assert(Reader.getContext().getLangOpts().Modules &&\n               \"already deserialized this template specialization\");\n        mergeRedeclarable(FD, ExistingInfo->getFunction(), Redecl);\n      }\n    }\n    break;\n  }\n  case FunctionDecl::TK_DependentFunctionTemplateSpecialization: {\n    // Templates.\n    UnresolvedSet<8> TemplDecls;\n    unsigned NumTemplates = Record.readInt();\n    while (NumTemplates--)\n      TemplDecls.addDecl(readDeclAs<NamedDecl>());\n\n    // Templates args.\n    TemplateArgumentListInfo TemplArgs;\n    unsigned NumArgs = Record.readInt();\n    while (NumArgs--)\n      TemplArgs.addArgument(Record.readTemplateArgumentLoc());\n    TemplArgs.setLAngleLoc(readSourceLocation());\n    TemplArgs.setRAngleLoc(readSourceLocation());\n\n    FD->setDependentTemplateSpecialization(Reader.getContext(),\n                                           TemplDecls, TemplArgs);\n    // These are not merged; we don't need to merge redeclarations of dependent\n    // template friends.\n    break;\n  }\n  }\n\n  // Defer calling `setPure` until merging above has guaranteed we've set\n  // `DefinitionData` (as this will need to access it).\n  FD->setPure(Pure);\n\n  // Read in the parameters.\n  unsigned NumParams = Record.readInt();\n  SmallVector<ParmVarDecl *, 16> Params;\n  Params.reserve(NumParams);\n  for (unsigned I = 0; I != NumParams; ++I)\n    Params.push_back(readDeclAs<ParmVarDecl>());\n  FD->setParams(Reader.getContext(), Params);\n}\n\nvoid ASTDeclReader::VisitObjCMethodDecl(ObjCMethodDecl *MD) {\n  VisitNamedDecl(MD);\n  if (Record.readInt()) {\n    // Load the body on-demand. Most clients won't care, because method\n    // definitions rarely show up in headers.\n    Reader.PendingBodies[MD] = GetCurrentCursorOffset();\n    HasPendingBody = true;\n  }\n  MD->setSelfDecl(readDeclAs<ImplicitParamDecl>());\n  MD->setCmdDecl(readDeclAs<ImplicitParamDecl>());\n  MD->setInstanceMethod(Record.readInt());\n  MD->setVariadic(Record.readInt());\n  MD->setPropertyAccessor(Record.readInt());\n  MD->setSynthesizedAccessorStub(Record.readInt());\n  MD->setDefined(Record.readInt());\n  MD->setOverriding(Record.readInt());\n  MD->setHasSkippedBody(Record.readInt());\n\n  MD->setIsRedeclaration(Record.readInt());\n  MD->setHasRedeclaration(Record.readInt());\n  if (MD->hasRedeclaration())\n    Reader.getContext().setObjCMethodRedeclaration(MD,\n                                       readDeclAs<ObjCMethodDecl>());\n\n  MD->setDeclImplementation((ObjCMethodDecl::ImplementationControl)Record.readInt());\n  MD->setObjCDeclQualifier((Decl::ObjCDeclQualifier)Record.readInt());\n  MD->setRelatedResultType(Record.readInt());\n  MD->setReturnType(Record.readType());\n  MD->setReturnTypeSourceInfo(readTypeSourceInfo());\n  MD->DeclEndLoc = readSourceLocation();\n  unsigned NumParams = Record.readInt();\n  SmallVector<ParmVarDecl *, 16> Params;\n  Params.reserve(NumParams);\n  for (unsigned I = 0; I != NumParams; ++I)\n    Params.push_back(readDeclAs<ParmVarDecl>());\n\n  MD->setSelLocsKind((SelectorLocationsKind)Record.readInt());\n  unsigned NumStoredSelLocs = Record.readInt();\n  SmallVector<SourceLocation, 16> SelLocs;\n  SelLocs.reserve(NumStoredSelLocs);\n  for (unsigned i = 0; i != NumStoredSelLocs; ++i)\n    SelLocs.push_back(readSourceLocation());\n\n  MD->setParamsAndSelLocs(Reader.getContext(), Params, SelLocs);\n}\n\nvoid ASTDeclReader::VisitObjCTypeParamDecl(ObjCTypeParamDecl *D) {\n  VisitTypedefNameDecl(D);\n\n  D->Variance = Record.readInt();\n  D->Index = Record.readInt();\n  D->VarianceLoc = readSourceLocation();\n  D->ColonLoc = readSourceLocation();\n}\n\nvoid ASTDeclReader::VisitObjCContainerDecl(ObjCContainerDecl *CD) {\n  VisitNamedDecl(CD);\n  CD->setAtStartLoc(readSourceLocation());\n  CD->setAtEndRange(readSourceRange());\n}\n\nObjCTypeParamList *ASTDeclReader::ReadObjCTypeParamList() {\n  unsigned numParams = Record.readInt();\n  if (numParams == 0)\n    return nullptr;\n\n  SmallVector<ObjCTypeParamDecl *, 4> typeParams;\n  typeParams.reserve(numParams);\n  for (unsigned i = 0; i != numParams; ++i) {\n    auto *typeParam = readDeclAs<ObjCTypeParamDecl>();\n    if (!typeParam)\n      return nullptr;\n\n    typeParams.push_back(typeParam);\n  }\n\n  SourceLocation lAngleLoc = readSourceLocation();\n  SourceLocation rAngleLoc = readSourceLocation();\n\n  return ObjCTypeParamList::create(Reader.getContext(), lAngleLoc,\n                                   typeParams, rAngleLoc);\n}\n\nvoid ASTDeclReader::ReadObjCDefinitionData(\n         struct ObjCInterfaceDecl::DefinitionData &Data) {\n  // Read the superclass.\n  Data.SuperClassTInfo = readTypeSourceInfo();\n\n  Data.EndLoc = readSourceLocation();\n  Data.HasDesignatedInitializers = Record.readInt();\n\n  // Read the directly referenced protocols and their SourceLocations.\n  unsigned NumProtocols = Record.readInt();\n  SmallVector<ObjCProtocolDecl *, 16> Protocols;\n  Protocols.reserve(NumProtocols);\n  for (unsigned I = 0; I != NumProtocols; ++I)\n    Protocols.push_back(readDeclAs<ObjCProtocolDecl>());\n  SmallVector<SourceLocation, 16> ProtoLocs;\n  ProtoLocs.reserve(NumProtocols);\n  for (unsigned I = 0; I != NumProtocols; ++I)\n    ProtoLocs.push_back(readSourceLocation());\n  Data.ReferencedProtocols.set(Protocols.data(), NumProtocols, ProtoLocs.data(),\n                               Reader.getContext());\n\n  // Read the transitive closure of protocols referenced by this class.\n  NumProtocols = Record.readInt();\n  Protocols.clear();\n  Protocols.reserve(NumProtocols);\n  for (unsigned I = 0; I != NumProtocols; ++I)\n    Protocols.push_back(readDeclAs<ObjCProtocolDecl>());\n  Data.AllReferencedProtocols.set(Protocols.data(), NumProtocols,\n                                  Reader.getContext());\n}\n\nvoid ASTDeclReader::MergeDefinitionData(ObjCInterfaceDecl *D,\n         struct ObjCInterfaceDecl::DefinitionData &&NewDD) {\n  // FIXME: odr checking?\n}\n\nvoid ASTDeclReader::VisitObjCInterfaceDecl(ObjCInterfaceDecl *ID) {\n  RedeclarableResult Redecl = VisitRedeclarable(ID);\n  VisitObjCContainerDecl(ID);\n  DeferredTypeID = Record.getGlobalTypeID(Record.readInt());\n  mergeRedeclarable(ID, Redecl);\n\n  ID->TypeParamList = ReadObjCTypeParamList();\n  if (Record.readInt()) {\n    // Read the definition.\n    ID->allocateDefinitionData();\n\n    ReadObjCDefinitionData(ID->data());\n    ObjCInterfaceDecl *Canon = ID->getCanonicalDecl();\n    if (Canon->Data.getPointer()) {\n      // If we already have a definition, keep the definition invariant and\n      // merge the data.\n      MergeDefinitionData(Canon, std::move(ID->data()));\n      ID->Data = Canon->Data;\n    } else {\n      // Set the definition data of the canonical declaration, so other\n      // redeclarations will see it.\n      ID->getCanonicalDecl()->Data = ID->Data;\n\n      // We will rebuild this list lazily.\n      ID->setIvarList(nullptr);\n    }\n\n    // Note that we have deserialized a definition.\n    Reader.PendingDefinitions.insert(ID);\n\n    // Note that we've loaded this Objective-C class.\n    Reader.ObjCClassesLoaded.push_back(ID);\n  } else {\n    ID->Data = ID->getCanonicalDecl()->Data;\n  }\n}\n\nvoid ASTDeclReader::VisitObjCIvarDecl(ObjCIvarDecl *IVD) {\n  VisitFieldDecl(IVD);\n  IVD->setAccessControl((ObjCIvarDecl::AccessControl)Record.readInt());\n  // This field will be built lazily.\n  IVD->setNextIvar(nullptr);\n  bool synth = Record.readInt();\n  IVD->setSynthesize(synth);\n}\n\nvoid ASTDeclReader::ReadObjCDefinitionData(\n         struct ObjCProtocolDecl::DefinitionData &Data) {\n    unsigned NumProtoRefs = Record.readInt();\n    SmallVector<ObjCProtocolDecl *, 16> ProtoRefs;\n    ProtoRefs.reserve(NumProtoRefs);\n    for (unsigned I = 0; I != NumProtoRefs; ++I)\n      ProtoRefs.push_back(readDeclAs<ObjCProtocolDecl>());\n    SmallVector<SourceLocation, 16> ProtoLocs;\n    ProtoLocs.reserve(NumProtoRefs);\n    for (unsigned I = 0; I != NumProtoRefs; ++I)\n      ProtoLocs.push_back(readSourceLocation());\n    Data.ReferencedProtocols.set(ProtoRefs.data(), NumProtoRefs,\n                                 ProtoLocs.data(), Reader.getContext());\n}\n\nvoid ASTDeclReader::MergeDefinitionData(ObjCProtocolDecl *D,\n         struct ObjCProtocolDecl::DefinitionData &&NewDD) {\n  // FIXME: odr checking?\n}\n\nvoid ASTDeclReader::VisitObjCProtocolDecl(ObjCProtocolDecl *PD) {\n  RedeclarableResult Redecl = VisitRedeclarable(PD);\n  VisitObjCContainerDecl(PD);\n  mergeRedeclarable(PD, Redecl);\n\n  if (Record.readInt()) {\n    // Read the definition.\n    PD->allocateDefinitionData();\n\n    ReadObjCDefinitionData(PD->data());\n\n    ObjCProtocolDecl *Canon = PD->getCanonicalDecl();\n    if (Canon->Data.getPointer()) {\n      // If we already have a definition, keep the definition invariant and\n      // merge the data.\n      MergeDefinitionData(Canon, std::move(PD->data()));\n      PD->Data = Canon->Data;\n    } else {\n      // Set the definition data of the canonical declaration, so other\n      // redeclarations will see it.\n      PD->getCanonicalDecl()->Data = PD->Data;\n    }\n    // Note that we have deserialized a definition.\n    Reader.PendingDefinitions.insert(PD);\n  } else {\n    PD->Data = PD->getCanonicalDecl()->Data;\n  }\n}\n\nvoid ASTDeclReader::VisitObjCAtDefsFieldDecl(ObjCAtDefsFieldDecl *FD) {\n  VisitFieldDecl(FD);\n}\n\nvoid ASTDeclReader::VisitObjCCategoryDecl(ObjCCategoryDecl *CD) {\n  VisitObjCContainerDecl(CD);\n  CD->setCategoryNameLoc(readSourceLocation());\n  CD->setIvarLBraceLoc(readSourceLocation());\n  CD->setIvarRBraceLoc(readSourceLocation());\n\n  // Note that this category has been deserialized. We do this before\n  // deserializing the interface declaration, so that it will consider this\n  /// category.\n  Reader.CategoriesDeserialized.insert(CD);\n\n  CD->ClassInterface = readDeclAs<ObjCInterfaceDecl>();\n  CD->TypeParamList = ReadObjCTypeParamList();\n  unsigned NumProtoRefs = Record.readInt();\n  SmallVector<ObjCProtocolDecl *, 16> ProtoRefs;\n  ProtoRefs.reserve(NumProtoRefs);\n  for (unsigned I = 0; I != NumProtoRefs; ++I)\n    ProtoRefs.push_back(readDeclAs<ObjCProtocolDecl>());\n  SmallVector<SourceLocation, 16> ProtoLocs;\n  ProtoLocs.reserve(NumProtoRefs);\n  for (unsigned I = 0; I != NumProtoRefs; ++I)\n    ProtoLocs.push_back(readSourceLocation());\n  CD->setProtocolList(ProtoRefs.data(), NumProtoRefs, ProtoLocs.data(),\n                      Reader.getContext());\n\n  // Protocols in the class extension belong to the class.\n  if (NumProtoRefs > 0 && CD->ClassInterface && CD->IsClassExtension())\n    CD->ClassInterface->mergeClassExtensionProtocolList(\n        (ObjCProtocolDecl *const *)ProtoRefs.data(), NumProtoRefs,\n        Reader.getContext());\n}\n\nvoid ASTDeclReader::VisitObjCCompatibleAliasDecl(ObjCCompatibleAliasDecl *CAD) {\n  VisitNamedDecl(CAD);\n  CAD->setClassInterface(readDeclAs<ObjCInterfaceDecl>());\n}\n\nvoid ASTDeclReader::VisitObjCPropertyDecl(ObjCPropertyDecl *D) {\n  VisitNamedDecl(D);\n  D->setAtLoc(readSourceLocation());\n  D->setLParenLoc(readSourceLocation());\n  QualType T = Record.readType();\n  TypeSourceInfo *TSI = readTypeSourceInfo();\n  D->setType(T, TSI);\n  D->setPropertyAttributes((ObjCPropertyAttribute::Kind)Record.readInt());\n  D->setPropertyAttributesAsWritten(\n      (ObjCPropertyAttribute::Kind)Record.readInt());\n  D->setPropertyImplementation(\n      (ObjCPropertyDecl::PropertyControl)Record.readInt());\n  DeclarationName GetterName = Record.readDeclarationName();\n  SourceLocation GetterLoc = readSourceLocation();\n  D->setGetterName(GetterName.getObjCSelector(), GetterLoc);\n  DeclarationName SetterName = Record.readDeclarationName();\n  SourceLocation SetterLoc = readSourceLocation();\n  D->setSetterName(SetterName.getObjCSelector(), SetterLoc);\n  D->setGetterMethodDecl(readDeclAs<ObjCMethodDecl>());\n  D->setSetterMethodDecl(readDeclAs<ObjCMethodDecl>());\n  D->setPropertyIvarDecl(readDeclAs<ObjCIvarDecl>());\n}\n\nvoid ASTDeclReader::VisitObjCImplDecl(ObjCImplDecl *D) {\n  VisitObjCContainerDecl(D);\n  D->setClassInterface(readDeclAs<ObjCInterfaceDecl>());\n}\n\nvoid ASTDeclReader::VisitObjCCategoryImplDecl(ObjCCategoryImplDecl *D) {\n  VisitObjCImplDecl(D);\n  D->CategoryNameLoc = readSourceLocation();\n}\n\nvoid ASTDeclReader::VisitObjCImplementationDecl(ObjCImplementationDecl *D) {\n  VisitObjCImplDecl(D);\n  D->setSuperClass(readDeclAs<ObjCInterfaceDecl>());\n  D->SuperLoc = readSourceLocation();\n  D->setIvarLBraceLoc(readSourceLocation());\n  D->setIvarRBraceLoc(readSourceLocation());\n  D->setHasNonZeroConstructors(Record.readInt());\n  D->setHasDestructors(Record.readInt());\n  D->NumIvarInitializers = Record.readInt();\n  if (D->NumIvarInitializers)\n    D->IvarInitializers = ReadGlobalOffset();\n}\n\nvoid ASTDeclReader::VisitObjCPropertyImplDecl(ObjCPropertyImplDecl *D) {\n  VisitDecl(D);\n  D->setAtLoc(readSourceLocation());\n  D->setPropertyDecl(readDeclAs<ObjCPropertyDecl>());\n  D->PropertyIvarDecl = readDeclAs<ObjCIvarDecl>();\n  D->IvarLoc = readSourceLocation();\n  D->setGetterMethodDecl(readDeclAs<ObjCMethodDecl>());\n  D->setSetterMethodDecl(readDeclAs<ObjCMethodDecl>());\n  D->setGetterCXXConstructor(Record.readExpr());\n  D->setSetterCXXAssignment(Record.readExpr());\n}\n\nvoid ASTDeclReader::VisitFieldDecl(FieldDecl *FD) {\n  VisitDeclaratorDecl(FD);\n  FD->Mutable = Record.readInt();\n\n  if (auto ISK = static_cast<FieldDecl::InitStorageKind>(Record.readInt())) {\n    FD->InitStorage.setInt(ISK);\n    FD->InitStorage.setPointer(ISK == FieldDecl::ISK_CapturedVLAType\n                                   ? Record.readType().getAsOpaquePtr()\n                                   : Record.readExpr());\n  }\n\n  if (auto *BW = Record.readExpr())\n    FD->setBitWidth(BW);\n\n  if (!FD->getDeclName()) {\n    if (auto *Tmpl = readDeclAs<FieldDecl>())\n      Reader.getContext().setInstantiatedFromUnnamedFieldDecl(FD, Tmpl);\n  }\n  mergeMergeable(FD);\n}\n\nvoid ASTDeclReader::VisitMSPropertyDecl(MSPropertyDecl *PD) {\n  VisitDeclaratorDecl(PD);\n  PD->GetterId = Record.readIdentifier();\n  PD->SetterId = Record.readIdentifier();\n}\n\nvoid ASTDeclReader::VisitMSGuidDecl(MSGuidDecl *D) {\n  VisitValueDecl(D);\n  D->PartVal.Part1 = Record.readInt();\n  D->PartVal.Part2 = Record.readInt();\n  D->PartVal.Part3 = Record.readInt();\n  for (auto &C : D->PartVal.Part4And5)\n    C = Record.readInt();\n\n  // Add this GUID to the AST context's lookup structure, and merge if needed.\n  if (MSGuidDecl *Existing = Reader.getContext().MSGuidDecls.GetOrInsertNode(D))\n    Reader.getContext().setPrimaryMergedDecl(D, Existing->getCanonicalDecl());\n}\n\nvoid ASTDeclReader::VisitTemplateParamObjectDecl(TemplateParamObjectDecl *D) {\n  VisitValueDecl(D);\n  D->Value = Record.readAPValue();\n\n  // Add this template parameter object to the AST context's lookup structure,\n  // and merge if needed.\n  if (TemplateParamObjectDecl *Existing =\n          Reader.getContext().TemplateParamObjectDecls.GetOrInsertNode(D))\n    Reader.getContext().setPrimaryMergedDecl(D, Existing->getCanonicalDecl());\n}\n\nvoid ASTDeclReader::VisitIndirectFieldDecl(IndirectFieldDecl *FD) {\n  VisitValueDecl(FD);\n\n  FD->ChainingSize = Record.readInt();\n  assert(FD->ChainingSize >= 2 && \"Anonymous chaining must be >= 2\");\n  FD->Chaining = new (Reader.getContext())NamedDecl*[FD->ChainingSize];\n\n  for (unsigned I = 0; I != FD->ChainingSize; ++I)\n    FD->Chaining[I] = readDeclAs<NamedDecl>();\n\n  mergeMergeable(FD);\n}\n\nASTDeclReader::RedeclarableResult ASTDeclReader::VisitVarDeclImpl(VarDecl *VD) {\n  RedeclarableResult Redecl = VisitRedeclarable(VD);\n  VisitDeclaratorDecl(VD);\n\n  VD->VarDeclBits.SClass = (StorageClass)Record.readInt();\n  VD->VarDeclBits.TSCSpec = Record.readInt();\n  VD->VarDeclBits.InitStyle = Record.readInt();\n  VD->VarDeclBits.ARCPseudoStrong = Record.readInt();\n  if (!isa<ParmVarDecl>(VD)) {\n    VD->NonParmVarDeclBits.IsThisDeclarationADemotedDefinition =\n        Record.readInt();\n    VD->NonParmVarDeclBits.ExceptionVar = Record.readInt();\n    VD->NonParmVarDeclBits.NRVOVariable = Record.readInt();\n    VD->NonParmVarDeclBits.CXXForRangeDecl = Record.readInt();\n    VD->NonParmVarDeclBits.ObjCForDecl = Record.readInt();\n    VD->NonParmVarDeclBits.IsInline = Record.readInt();\n    VD->NonParmVarDeclBits.IsInlineSpecified = Record.readInt();\n    VD->NonParmVarDeclBits.IsConstexpr = Record.readInt();\n    VD->NonParmVarDeclBits.IsInitCapture = Record.readInt();\n    VD->NonParmVarDeclBits.PreviousDeclInSameBlockScope = Record.readInt();\n    VD->NonParmVarDeclBits.ImplicitParamKind = Record.readInt();\n    VD->NonParmVarDeclBits.EscapingByref = Record.readInt();\n  }\n  auto VarLinkage = Linkage(Record.readInt());\n  VD->setCachedLinkage(VarLinkage);\n\n  // Reconstruct the one piece of the IdentifierNamespace that we need.\n  if (VD->getStorageClass() == SC_Extern && VarLinkage != NoLinkage &&\n      VD->getLexicalDeclContext()->isFunctionOrMethod())\n    VD->setLocalExternDecl();\n\n  if (uint64_t Val = Record.readInt()) {\n    VD->setInit(Record.readExpr());\n    if (Val != 1) {\n      EvaluatedStmt *Eval = VD->ensureEvaluatedStmt();\n      Eval->HasConstantInitialization = (Val & 2) != 0;\n      Eval->HasConstantDestruction = (Val & 4) != 0;\n    }\n  }\n\n  if (VD->hasAttr<BlocksAttr>() && VD->getType()->getAsCXXRecordDecl()) {\n    Expr *CopyExpr = Record.readExpr();\n    if (CopyExpr)\n      Reader.getContext().setBlockVarCopyInit(VD, CopyExpr, Record.readInt());\n  }\n\n  if (VD->getStorageDuration() == SD_Static && Record.readInt()) {\n    Reader.DefinitionSource[VD] =\n        Loc.F->Kind == ModuleKind::MK_MainFile ||\n        Reader.getContext().getLangOpts().BuildingPCHWithObjectFile;\n  }\n\n  enum VarKind {\n    VarNotTemplate = 0, VarTemplate, StaticDataMemberSpecialization\n  };\n  switch ((VarKind)Record.readInt()) {\n  case VarNotTemplate:\n    // Only true variables (not parameters or implicit parameters) can be\n    // merged; the other kinds are not really redeclarable at all.\n    if (!isa<ParmVarDecl>(VD) && !isa<ImplicitParamDecl>(VD) &&\n        !isa<VarTemplateSpecializationDecl>(VD))\n      mergeRedeclarable(VD, Redecl);\n    break;\n  case VarTemplate:\n    // Merged when we merge the template.\n    VD->setDescribedVarTemplate(readDeclAs<VarTemplateDecl>());\n    break;\n  case StaticDataMemberSpecialization: { // HasMemberSpecializationInfo.\n    auto *Tmpl = readDeclAs<VarDecl>();\n    auto TSK = (TemplateSpecializationKind)Record.readInt();\n    SourceLocation POI = readSourceLocation();\n    Reader.getContext().setInstantiatedFromStaticDataMember(VD, Tmpl, TSK,POI);\n    mergeRedeclarable(VD, Redecl);\n    break;\n  }\n  }\n\n  return Redecl;\n}\n\nvoid ASTDeclReader::VisitImplicitParamDecl(ImplicitParamDecl *PD) {\n  VisitVarDecl(PD);\n}\n\nvoid ASTDeclReader::VisitParmVarDecl(ParmVarDecl *PD) {\n  VisitVarDecl(PD);\n  unsigned isObjCMethodParam = Record.readInt();\n  unsigned scopeDepth = Record.readInt();\n  unsigned scopeIndex = Record.readInt();\n  unsigned declQualifier = Record.readInt();\n  if (isObjCMethodParam) {\n    assert(scopeDepth == 0);\n    PD->setObjCMethodScopeInfo(scopeIndex);\n    PD->ParmVarDeclBits.ScopeDepthOrObjCQuals = declQualifier;\n  } else {\n    PD->setScopeInfo(scopeDepth, scopeIndex);\n  }\n  PD->ParmVarDeclBits.IsKNRPromoted = Record.readInt();\n  PD->ParmVarDeclBits.HasInheritedDefaultArg = Record.readInt();\n  if (Record.readInt()) // hasUninstantiatedDefaultArg.\n    PD->setUninstantiatedDefaultArg(Record.readExpr());\n\n  // FIXME: If this is a redeclaration of a function from another module, handle\n  // inheritance of default arguments.\n}\n\nvoid ASTDeclReader::VisitDecompositionDecl(DecompositionDecl *DD) {\n  VisitVarDecl(DD);\n  auto **BDs = DD->getTrailingObjects<BindingDecl *>();\n  for (unsigned I = 0; I != DD->NumBindings; ++I) {\n    BDs[I] = readDeclAs<BindingDecl>();\n    BDs[I]->setDecomposedDecl(DD);\n  }\n}\n\nvoid ASTDeclReader::VisitBindingDecl(BindingDecl *BD) {\n  VisitValueDecl(BD);\n  BD->Binding = Record.readExpr();\n}\n\nvoid ASTDeclReader::VisitFileScopeAsmDecl(FileScopeAsmDecl *AD) {\n  VisitDecl(AD);\n  AD->setAsmString(cast<StringLiteral>(Record.readExpr()));\n  AD->setRParenLoc(readSourceLocation());\n}\n\nvoid ASTDeclReader::VisitBlockDecl(BlockDecl *BD) {\n  VisitDecl(BD);\n  BD->setBody(cast_or_null<CompoundStmt>(Record.readStmt()));\n  BD->setSignatureAsWritten(readTypeSourceInfo());\n  unsigned NumParams = Record.readInt();\n  SmallVector<ParmVarDecl *, 16> Params;\n  Params.reserve(NumParams);\n  for (unsigned I = 0; I != NumParams; ++I)\n    Params.push_back(readDeclAs<ParmVarDecl>());\n  BD->setParams(Params);\n\n  BD->setIsVariadic(Record.readInt());\n  BD->setBlockMissingReturnType(Record.readInt());\n  BD->setIsConversionFromLambda(Record.readInt());\n  BD->setDoesNotEscape(Record.readInt());\n  BD->setCanAvoidCopyToHeap(Record.readInt());\n\n  bool capturesCXXThis = Record.readInt();\n  unsigned numCaptures = Record.readInt();\n  SmallVector<BlockDecl::Capture, 16> captures;\n  captures.reserve(numCaptures);\n  for (unsigned i = 0; i != numCaptures; ++i) {\n    auto *decl = readDeclAs<VarDecl>();\n    unsigned flags = Record.readInt();\n    bool byRef = (flags & 1);\n    bool nested = (flags & 2);\n    Expr *copyExpr = ((flags & 4) ? Record.readExpr() : nullptr);\n\n    captures.push_back(BlockDecl::Capture(decl, byRef, nested, copyExpr));\n  }\n  BD->setCaptures(Reader.getContext(), captures, capturesCXXThis);\n}\n\nvoid ASTDeclReader::VisitCapturedDecl(CapturedDecl *CD) {\n  VisitDecl(CD);\n  unsigned ContextParamPos = Record.readInt();\n  CD->setNothrow(Record.readInt() != 0);\n  // Body is set by VisitCapturedStmt.\n  for (unsigned I = 0; I < CD->NumParams; ++I) {\n    if (I != ContextParamPos)\n      CD->setParam(I, readDeclAs<ImplicitParamDecl>());\n    else\n      CD->setContextParam(I, readDeclAs<ImplicitParamDecl>());\n  }\n}\n\nvoid ASTDeclReader::VisitLinkageSpecDecl(LinkageSpecDecl *D) {\n  VisitDecl(D);\n  D->setLanguage((LinkageSpecDecl::LanguageIDs)Record.readInt());\n  D->setExternLoc(readSourceLocation());\n  D->setRBraceLoc(readSourceLocation());\n}\n\nvoid ASTDeclReader::VisitExportDecl(ExportDecl *D) {\n  VisitDecl(D);\n  D->RBraceLoc = readSourceLocation();\n}\n\nvoid ASTDeclReader::VisitLabelDecl(LabelDecl *D) {\n  VisitNamedDecl(D);\n  D->setLocStart(readSourceLocation());\n}\n\nvoid ASTDeclReader::VisitNamespaceDecl(NamespaceDecl *D) {\n  RedeclarableResult Redecl = VisitRedeclarable(D);\n  VisitNamedDecl(D);\n  D->setInline(Record.readInt());\n  D->LocStart = readSourceLocation();\n  D->RBraceLoc = readSourceLocation();\n\n  // Defer loading the anonymous namespace until we've finished merging\n  // this namespace; loading it might load a later declaration of the\n  // same namespace, and we have an invariant that older declarations\n  // get merged before newer ones try to merge.\n  GlobalDeclID AnonNamespace = 0;\n  if (Redecl.getFirstID() == ThisDeclID) {\n    AnonNamespace = readDeclID();\n  } else {\n    // Link this namespace back to the first declaration, which has already\n    // been deserialized.\n    D->AnonOrFirstNamespaceAndInline.setPointer(D->getFirstDecl());\n  }\n\n  mergeRedeclarable(D, Redecl);\n\n  if (AnonNamespace) {\n    // Each module has its own anonymous namespace, which is disjoint from\n    // any other module's anonymous namespaces, so don't attach the anonymous\n    // namespace at all.\n    auto *Anon = cast<NamespaceDecl>(Reader.GetDecl(AnonNamespace));\n    if (!Record.isModule())\n      D->setAnonymousNamespace(Anon);\n  }\n}\n\nvoid ASTDeclReader::VisitNamespaceAliasDecl(NamespaceAliasDecl *D) {\n  RedeclarableResult Redecl = VisitRedeclarable(D);\n  VisitNamedDecl(D);\n  D->NamespaceLoc = readSourceLocation();\n  D->IdentLoc = readSourceLocation();\n  D->QualifierLoc = Record.readNestedNameSpecifierLoc();\n  D->Namespace = readDeclAs<NamedDecl>();\n  mergeRedeclarable(D, Redecl);\n}\n\nvoid ASTDeclReader::VisitUsingDecl(UsingDecl *D) {\n  VisitNamedDecl(D);\n  D->setUsingLoc(readSourceLocation());\n  D->QualifierLoc = Record.readNestedNameSpecifierLoc();\n  D->DNLoc = Record.readDeclarationNameLoc(D->getDeclName());\n  D->FirstUsingShadow.setPointer(readDeclAs<UsingShadowDecl>());\n  D->setTypename(Record.readInt());\n  if (auto *Pattern = readDeclAs<NamedDecl>())\n    Reader.getContext().setInstantiatedFromUsingDecl(D, Pattern);\n  mergeMergeable(D);\n}\n\nvoid ASTDeclReader::VisitUsingPackDecl(UsingPackDecl *D) {\n  VisitNamedDecl(D);\n  D->InstantiatedFrom = readDeclAs<NamedDecl>();\n  auto **Expansions = D->getTrailingObjects<NamedDecl *>();\n  for (unsigned I = 0; I != D->NumExpansions; ++I)\n    Expansions[I] = readDeclAs<NamedDecl>();\n  mergeMergeable(D);\n}\n\nvoid ASTDeclReader::VisitUsingShadowDecl(UsingShadowDecl *D) {\n  RedeclarableResult Redecl = VisitRedeclarable(D);\n  VisitNamedDecl(D);\n  D->Underlying = readDeclAs<NamedDecl>();\n  D->IdentifierNamespace = Record.readInt();\n  D->UsingOrNextShadow = readDeclAs<NamedDecl>();\n  auto *Pattern = readDeclAs<UsingShadowDecl>();\n  if (Pattern)\n    Reader.getContext().setInstantiatedFromUsingShadowDecl(D, Pattern);\n  mergeRedeclarable(D, Redecl);\n}\n\nvoid ASTDeclReader::VisitConstructorUsingShadowDecl(\n    ConstructorUsingShadowDecl *D) {\n  VisitUsingShadowDecl(D);\n  D->NominatedBaseClassShadowDecl = readDeclAs<ConstructorUsingShadowDecl>();\n  D->ConstructedBaseClassShadowDecl = readDeclAs<ConstructorUsingShadowDecl>();\n  D->IsVirtual = Record.readInt();\n}\n\nvoid ASTDeclReader::VisitUsingDirectiveDecl(UsingDirectiveDecl *D) {\n  VisitNamedDecl(D);\n  D->UsingLoc = readSourceLocation();\n  D->NamespaceLoc = readSourceLocation();\n  D->QualifierLoc = Record.readNestedNameSpecifierLoc();\n  D->NominatedNamespace = readDeclAs<NamedDecl>();\n  D->CommonAncestor = readDeclAs<DeclContext>();\n}\n\nvoid ASTDeclReader::VisitUnresolvedUsingValueDecl(UnresolvedUsingValueDecl *D) {\n  VisitValueDecl(D);\n  D->setUsingLoc(readSourceLocation());\n  D->QualifierLoc = Record.readNestedNameSpecifierLoc();\n  D->DNLoc = Record.readDeclarationNameLoc(D->getDeclName());\n  D->EllipsisLoc = readSourceLocation();\n  mergeMergeable(D);\n}\n\nvoid ASTDeclReader::VisitUnresolvedUsingTypenameDecl(\n                                               UnresolvedUsingTypenameDecl *D) {\n  VisitTypeDecl(D);\n  D->TypenameLocation = readSourceLocation();\n  D->QualifierLoc = Record.readNestedNameSpecifierLoc();\n  D->EllipsisLoc = readSourceLocation();\n  mergeMergeable(D);\n}\n\nvoid ASTDeclReader::ReadCXXDefinitionData(\n    struct CXXRecordDecl::DefinitionData &Data, const CXXRecordDecl *D) {\n  #define FIELD(Name, Width, Merge) \\\n  Data.Name = Record.readInt();\n  #include \"clang/AST/CXXRecordDeclDefinitionBits.def\"\n\n  // Note: the caller has deserialized the IsLambda bit already.\n  Data.ODRHash = Record.readInt();\n  Data.HasODRHash = true;\n\n  if (Record.readInt()) {\n    Reader.DefinitionSource[D] = \n        Loc.F->Kind == ModuleKind::MK_MainFile ||\n        Reader.getContext().getLangOpts().BuildingPCHWithObjectFile;\n  }\n\n  Data.NumBases = Record.readInt();\n  if (Data.NumBases)\n    Data.Bases = ReadGlobalOffset();\n  Data.NumVBases = Record.readInt();\n  if (Data.NumVBases)\n    Data.VBases = ReadGlobalOffset();\n\n  Record.readUnresolvedSet(Data.Conversions);\n  Data.ComputedVisibleConversions = Record.readInt();\n  if (Data.ComputedVisibleConversions)\n    Record.readUnresolvedSet(Data.VisibleConversions);\n  assert(Data.Definition && \"Data.Definition should be already set!\");\n  Data.FirstFriend = readDeclID();\n\n  if (Data.IsLambda) {\n    using Capture = LambdaCapture;\n\n    auto &Lambda = static_cast<CXXRecordDecl::LambdaDefinitionData &>(Data);\n    Lambda.Dependent = Record.readInt();\n    Lambda.IsGenericLambda = Record.readInt();\n    Lambda.CaptureDefault = Record.readInt();\n    Lambda.NumCaptures = Record.readInt();\n    Lambda.NumExplicitCaptures = Record.readInt();\n    Lambda.HasKnownInternalLinkage = Record.readInt();\n    Lambda.ManglingNumber = Record.readInt();\n    D->setDeviceLambdaManglingNumber(Record.readInt());\n    Lambda.ContextDecl = readDeclID();\n    Lambda.Captures = (Capture *)Reader.getContext().Allocate(\n        sizeof(Capture) * Lambda.NumCaptures);\n    Capture *ToCapture = Lambda.Captures;\n    Lambda.MethodTyInfo = readTypeSourceInfo();\n    for (unsigned I = 0, N = Lambda.NumCaptures; I != N; ++I) {\n      SourceLocation Loc = readSourceLocation();\n      bool IsImplicit = Record.readInt();\n      auto Kind = static_cast<LambdaCaptureKind>(Record.readInt());\n      switch (Kind) {\n      case LCK_StarThis:\n      case LCK_This:\n      case LCK_VLAType:\n        *ToCapture++ = Capture(Loc, IsImplicit, Kind, nullptr,SourceLocation());\n        break;\n      case LCK_ByCopy:\n      case LCK_ByRef:\n        auto *Var = readDeclAs<VarDecl>();\n        SourceLocation EllipsisLoc = readSourceLocation();\n        *ToCapture++ = Capture(Loc, IsImplicit, Kind, Var, EllipsisLoc);\n        break;\n      }\n    }\n  }\n}\n\nvoid ASTDeclReader::MergeDefinitionData(\n    CXXRecordDecl *D, struct CXXRecordDecl::DefinitionData &&MergeDD) {\n  assert(D->DefinitionData &&\n         \"merging class definition into non-definition\");\n  auto &DD = *D->DefinitionData;\n\n  if (DD.Definition != MergeDD.Definition) {\n    // Track that we merged the definitions.\n    Reader.MergedDeclContexts.insert(std::make_pair(MergeDD.Definition,\n                                                    DD.Definition));\n    Reader.PendingDefinitions.erase(MergeDD.Definition);\n    MergeDD.Definition->setCompleteDefinition(false);\n    Reader.mergeDefinitionVisibility(DD.Definition, MergeDD.Definition);\n    assert(Reader.Lookups.find(MergeDD.Definition) == Reader.Lookups.end() &&\n           \"already loaded pending lookups for merged definition\");\n  }\n\n  auto PFDI = Reader.PendingFakeDefinitionData.find(&DD);\n  if (PFDI != Reader.PendingFakeDefinitionData.end() &&\n      PFDI->second == ASTReader::PendingFakeDefinitionKind::Fake) {\n    // We faked up this definition data because we found a class for which we'd\n    // not yet loaded the definition. Replace it with the real thing now.\n    assert(!DD.IsLambda && !MergeDD.IsLambda && \"faked up lambda definition?\");\n    PFDI->second = ASTReader::PendingFakeDefinitionKind::FakeLoaded;\n\n    // Don't change which declaration is the definition; that is required\n    // to be invariant once we select it.\n    auto *Def = DD.Definition;\n    DD = std::move(MergeDD);\n    DD.Definition = Def;\n    return;\n  }\n\n  bool DetectedOdrViolation = false;\n\n  #define FIELD(Name, Width, Merge) Merge(Name)\n  #define MERGE_OR(Field) DD.Field |= MergeDD.Field;\n  #define NO_MERGE(Field) \\\n    DetectedOdrViolation |= DD.Field != MergeDD.Field; \\\n    MERGE_OR(Field)\n  #include \"clang/AST/CXXRecordDeclDefinitionBits.def\"\n  NO_MERGE(IsLambda)\n  #undef NO_MERGE\n  #undef MERGE_OR\n\n  if (DD.NumBases != MergeDD.NumBases || DD.NumVBases != MergeDD.NumVBases)\n    DetectedOdrViolation = true;\n  // FIXME: Issue a diagnostic if the base classes don't match when we come\n  // to lazily load them.\n\n  // FIXME: Issue a diagnostic if the list of conversion functions doesn't\n  // match when we come to lazily load them.\n  if (MergeDD.ComputedVisibleConversions && !DD.ComputedVisibleConversions) {\n    DD.VisibleConversions = std::move(MergeDD.VisibleConversions);\n    DD.ComputedVisibleConversions = true;\n  }\n\n  // FIXME: Issue a diagnostic if FirstFriend doesn't match when we come to\n  // lazily load it.\n\n  if (DD.IsLambda) {\n    // FIXME: ODR-checking for merging lambdas (this happens, for instance,\n    // when they occur within the body of a function template specialization).\n  }\n\n  if (D->getODRHash() != MergeDD.ODRHash) {\n    DetectedOdrViolation = true;\n  }\n\n  if (DetectedOdrViolation)\n    Reader.PendingOdrMergeFailures[DD.Definition].push_back(\n        {MergeDD.Definition, &MergeDD});\n}\n\nvoid ASTDeclReader::ReadCXXRecordDefinition(CXXRecordDecl *D, bool Update) {\n  struct CXXRecordDecl::DefinitionData *DD;\n  ASTContext &C = Reader.getContext();\n\n  // Determine whether this is a lambda closure type, so that we can\n  // allocate the appropriate DefinitionData structure.\n  bool IsLambda = Record.readInt();\n  if (IsLambda)\n    DD = new (C) CXXRecordDecl::LambdaDefinitionData(D, nullptr, false, false,\n                                                     LCD_None);\n  else\n    DD = new (C) struct CXXRecordDecl::DefinitionData(D);\n\n  CXXRecordDecl *Canon = D->getCanonicalDecl();\n  // Set decl definition data before reading it, so that during deserialization\n  // when we read CXXRecordDecl, it already has definition data and we don't\n  // set fake one.\n  if (!Canon->DefinitionData)\n    Canon->DefinitionData = DD;\n  D->DefinitionData = Canon->DefinitionData;\n  ReadCXXDefinitionData(*DD, D);\n\n  // We might already have a different definition for this record. This can\n  // happen either because we're reading an update record, or because we've\n  // already done some merging. Either way, just merge into it.\n  if (Canon->DefinitionData != DD) {\n    MergeDefinitionData(Canon, std::move(*DD));\n    return;\n  }\n\n  // Mark this declaration as being a definition.\n  D->setCompleteDefinition(true);\n\n  // If this is not the first declaration or is an update record, we can have\n  // other redeclarations already. Make a note that we need to propagate the\n  // DefinitionData pointer onto them.\n  if (Update || Canon != D)\n    Reader.PendingDefinitions.insert(D);\n}\n\nASTDeclReader::RedeclarableResult\nASTDeclReader::VisitCXXRecordDeclImpl(CXXRecordDecl *D) {\n  RedeclarableResult Redecl = VisitRecordDeclImpl(D);\n\n  ASTContext &C = Reader.getContext();\n\n  enum CXXRecKind {\n    CXXRecNotTemplate = 0, CXXRecTemplate, CXXRecMemberSpecialization\n  };\n  switch ((CXXRecKind)Record.readInt()) {\n  case CXXRecNotTemplate:\n    // Merged when we merge the folding set entry in the primary template.\n    if (!isa<ClassTemplateSpecializationDecl>(D))\n      mergeRedeclarable(D, Redecl);\n    break;\n  case CXXRecTemplate: {\n    // Merged when we merge the template.\n    auto *Template = readDeclAs<ClassTemplateDecl>();\n    D->TemplateOrInstantiation = Template;\n    if (!Template->getTemplatedDecl()) {\n      // We've not actually loaded the ClassTemplateDecl yet, because we're\n      // currently being loaded as its pattern. Rely on it to set up our\n      // TypeForDecl (see VisitClassTemplateDecl).\n      //\n      // Beware: we do not yet know our canonical declaration, and may still\n      // get merged once the surrounding class template has got off the ground.\n      DeferredTypeID = 0;\n    }\n    break;\n  }\n  case CXXRecMemberSpecialization: {\n    auto *RD = readDeclAs<CXXRecordDecl>();\n    auto TSK = (TemplateSpecializationKind)Record.readInt();\n    SourceLocation POI = readSourceLocation();\n    MemberSpecializationInfo *MSI = new (C) MemberSpecializationInfo(RD, TSK);\n    MSI->setPointOfInstantiation(POI);\n    D->TemplateOrInstantiation = MSI;\n    mergeRedeclarable(D, Redecl);\n    break;\n  }\n  }\n\n  bool WasDefinition = Record.readInt();\n  if (WasDefinition)\n    ReadCXXRecordDefinition(D, /*Update*/false);\n  else\n    // Propagate DefinitionData pointer from the canonical declaration.\n    D->DefinitionData = D->getCanonicalDecl()->DefinitionData;\n\n  // Lazily load the key function to avoid deserializing every method so we can\n  // compute it.\n  if (WasDefinition) {\n    DeclID KeyFn = readDeclID();\n    if (KeyFn && D->isCompleteDefinition())\n      // FIXME: This is wrong for the ARM ABI, where some other module may have\n      // made this function no longer be a key function. We need an update\n      // record or similar for that case.\n      C.KeyFunctions[D] = KeyFn;\n  }\n\n  return Redecl;\n}\n\nvoid ASTDeclReader::VisitCXXDeductionGuideDecl(CXXDeductionGuideDecl *D) {\n  D->setExplicitSpecifier(Record.readExplicitSpec());\n  VisitFunctionDecl(D);\n  D->setIsCopyDeductionCandidate(Record.readInt());\n}\n\nvoid ASTDeclReader::VisitCXXMethodDecl(CXXMethodDecl *D) {\n  VisitFunctionDecl(D);\n\n  unsigned NumOverridenMethods = Record.readInt();\n  if (D->isCanonicalDecl()) {\n    while (NumOverridenMethods--) {\n      // Avoid invariant checking of CXXMethodDecl::addOverriddenMethod,\n      // MD may be initializing.\n      if (auto *MD = readDeclAs<CXXMethodDecl>())\n        Reader.getContext().addOverriddenMethod(D, MD->getCanonicalDecl());\n    }\n  } else {\n    // We don't care about which declarations this used to override; we get\n    // the relevant information from the canonical declaration.\n    Record.skipInts(NumOverridenMethods);\n  }\n}\n\nvoid ASTDeclReader::VisitCXXConstructorDecl(CXXConstructorDecl *D) {\n  // We need the inherited constructor information to merge the declaration,\n  // so we have to read it before we call VisitCXXMethodDecl.\n  D->setExplicitSpecifier(Record.readExplicitSpec());\n  if (D->isInheritingConstructor()) {\n    auto *Shadow = readDeclAs<ConstructorUsingShadowDecl>();\n    auto *Ctor = readDeclAs<CXXConstructorDecl>();\n    *D->getTrailingObjects<InheritedConstructor>() =\n        InheritedConstructor(Shadow, Ctor);\n  }\n\n  VisitCXXMethodDecl(D);\n}\n\nvoid ASTDeclReader::VisitCXXDestructorDecl(CXXDestructorDecl *D) {\n  VisitCXXMethodDecl(D);\n\n  if (auto *OperatorDelete = readDeclAs<FunctionDecl>()) {\n    CXXDestructorDecl *Canon = D->getCanonicalDecl();\n    auto *ThisArg = Record.readExpr();\n    // FIXME: Check consistency if we have an old and new operator delete.\n    if (!Canon->OperatorDelete) {\n      Canon->OperatorDelete = OperatorDelete;\n      Canon->OperatorDeleteThisArg = ThisArg;\n    }\n  }\n}\n\nvoid ASTDeclReader::VisitCXXConversionDecl(CXXConversionDecl *D) {\n  D->setExplicitSpecifier(Record.readExplicitSpec());\n  VisitCXXMethodDecl(D);\n}\n\nvoid ASTDeclReader::VisitImportDecl(ImportDecl *D) {\n  VisitDecl(D);\n  D->ImportedModule = readModule();\n  D->setImportComplete(Record.readInt());\n  auto *StoredLocs = D->getTrailingObjects<SourceLocation>();\n  for (unsigned I = 0, N = Record.back(); I != N; ++I)\n    StoredLocs[I] = readSourceLocation();\n  Record.skipInts(1); // The number of stored source locations.\n}\n\nvoid ASTDeclReader::VisitAccessSpecDecl(AccessSpecDecl *D) {\n  VisitDecl(D);\n  D->setColonLoc(readSourceLocation());\n}\n\nvoid ASTDeclReader::VisitFriendDecl(FriendDecl *D) {\n  VisitDecl(D);\n  if (Record.readInt()) // hasFriendDecl\n    D->Friend = readDeclAs<NamedDecl>();\n  else\n    D->Friend = readTypeSourceInfo();\n  for (unsigned i = 0; i != D->NumTPLists; ++i)\n    D->getTrailingObjects<TemplateParameterList *>()[i] =\n        Record.readTemplateParameterList();\n  D->NextFriend = readDeclID();\n  D->UnsupportedFriend = (Record.readInt() != 0);\n  D->FriendLoc = readSourceLocation();\n}\n\nvoid ASTDeclReader::VisitFriendTemplateDecl(FriendTemplateDecl *D) {\n  VisitDecl(D);\n  unsigned NumParams = Record.readInt();\n  D->NumParams = NumParams;\n  D->Params = new TemplateParameterList*[NumParams];\n  for (unsigned i = 0; i != NumParams; ++i)\n    D->Params[i] = Record.readTemplateParameterList();\n  if (Record.readInt()) // HasFriendDecl\n    D->Friend = readDeclAs<NamedDecl>();\n  else\n    D->Friend = readTypeSourceInfo();\n  D->FriendLoc = readSourceLocation();\n}\n\nDeclID ASTDeclReader::VisitTemplateDecl(TemplateDecl *D) {\n  VisitNamedDecl(D);\n\n  DeclID PatternID = readDeclID();\n  auto *TemplatedDecl = cast_or_null<NamedDecl>(Reader.GetDecl(PatternID));\n  TemplateParameterList *TemplateParams = Record.readTemplateParameterList();\n  D->init(TemplatedDecl, TemplateParams);\n\n  return PatternID;\n}\n\nvoid ASTDeclReader::VisitConceptDecl(ConceptDecl *D) {\n  VisitTemplateDecl(D);\n  D->ConstraintExpr = Record.readExpr();\n  mergeMergeable(D);\n}\n\nvoid ASTDeclReader::VisitRequiresExprBodyDecl(RequiresExprBodyDecl *D) {\n}\n\nASTDeclReader::RedeclarableResult\nASTDeclReader::VisitRedeclarableTemplateDecl(RedeclarableTemplateDecl *D) {\n  RedeclarableResult Redecl = VisitRedeclarable(D);\n\n  // Make sure we've allocated the Common pointer first. We do this before\n  // VisitTemplateDecl so that getCommonPtr() can be used during initialization.\n  RedeclarableTemplateDecl *CanonD = D->getCanonicalDecl();\n  if (!CanonD->Common) {\n    CanonD->Common = CanonD->newCommon(Reader.getContext());\n    Reader.PendingDefinitions.insert(CanonD);\n  }\n  D->Common = CanonD->Common;\n\n  // If this is the first declaration of the template, fill in the information\n  // for the 'common' pointer.\n  if (ThisDeclID == Redecl.getFirstID()) {\n    if (auto *RTD = readDeclAs<RedeclarableTemplateDecl>()) {\n      assert(RTD->getKind() == D->getKind() &&\n             \"InstantiatedFromMemberTemplate kind mismatch\");\n      D->setInstantiatedFromMemberTemplate(RTD);\n      if (Record.readInt())\n        D->setMemberSpecialization();\n    }\n  }\n\n  DeclID PatternID = VisitTemplateDecl(D);\n  D->IdentifierNamespace = Record.readInt();\n\n  mergeRedeclarable(D, Redecl, PatternID);\n\n  // If we merged the template with a prior declaration chain, merge the common\n  // pointer.\n  // FIXME: Actually merge here, don't just overwrite.\n  D->Common = D->getCanonicalDecl()->Common;\n\n  return Redecl;\n}\n\nvoid ASTDeclReader::VisitClassTemplateDecl(ClassTemplateDecl *D) {\n  RedeclarableResult Redecl = VisitRedeclarableTemplateDecl(D);\n\n  if (ThisDeclID == Redecl.getFirstID()) {\n    // This ClassTemplateDecl owns a CommonPtr; read it to keep track of all of\n    // the specializations.\n    SmallVector<serialization::DeclID, 32> SpecIDs;\n    readDeclIDList(SpecIDs);\n    ASTDeclReader::AddLazySpecializations(D, SpecIDs);\n  }\n\n  if (D->getTemplatedDecl()->TemplateOrInstantiation) {\n    // We were loaded before our templated declaration was. We've not set up\n    // its corresponding type yet (see VisitCXXRecordDeclImpl), so reconstruct\n    // it now.\n    Reader.getContext().getInjectedClassNameType(\n        D->getTemplatedDecl(), D->getInjectedClassNameSpecialization());\n  }\n}\n\nvoid ASTDeclReader::VisitBuiltinTemplateDecl(BuiltinTemplateDecl *D) {\n  llvm_unreachable(\"BuiltinTemplates are not serialized\");\n}\n\n/// TODO: Unify with ClassTemplateDecl version?\n///       May require unifying ClassTemplateDecl and\n///        VarTemplateDecl beyond TemplateDecl...\nvoid ASTDeclReader::VisitVarTemplateDecl(VarTemplateDecl *D) {\n  RedeclarableResult Redecl = VisitRedeclarableTemplateDecl(D);\n\n  if (ThisDeclID == Redecl.getFirstID()) {\n    // This VarTemplateDecl owns a CommonPtr; read it to keep track of all of\n    // the specializations.\n    SmallVector<serialization::DeclID, 32> SpecIDs;\n    readDeclIDList(SpecIDs);\n    ASTDeclReader::AddLazySpecializations(D, SpecIDs);\n  }\n}\n\nASTDeclReader::RedeclarableResult\nASTDeclReader::VisitClassTemplateSpecializationDeclImpl(\n    ClassTemplateSpecializationDecl *D) {\n  RedeclarableResult Redecl = VisitCXXRecordDeclImpl(D);\n\n  ASTContext &C = Reader.getContext();\n  if (Decl *InstD = readDecl()) {\n    if (auto *CTD = dyn_cast<ClassTemplateDecl>(InstD)) {\n      D->SpecializedTemplate = CTD;\n    } else {\n      SmallVector<TemplateArgument, 8> TemplArgs;\n      Record.readTemplateArgumentList(TemplArgs);\n      TemplateArgumentList *ArgList\n        = TemplateArgumentList::CreateCopy(C, TemplArgs);\n      auto *PS =\n          new (C) ClassTemplateSpecializationDecl::\n                                             SpecializedPartialSpecialization();\n      PS->PartialSpecialization\n          = cast<ClassTemplatePartialSpecializationDecl>(InstD);\n      PS->TemplateArgs = ArgList;\n      D->SpecializedTemplate = PS;\n    }\n  }\n\n  SmallVector<TemplateArgument, 8> TemplArgs;\n  Record.readTemplateArgumentList(TemplArgs, /*Canonicalize*/ true);\n  D->TemplateArgs = TemplateArgumentList::CreateCopy(C, TemplArgs);\n  D->PointOfInstantiation = readSourceLocation();\n  D->SpecializationKind = (TemplateSpecializationKind)Record.readInt();\n\n  bool writtenAsCanonicalDecl = Record.readInt();\n  if (writtenAsCanonicalDecl) {\n    auto *CanonPattern = readDeclAs<ClassTemplateDecl>();\n    if (D->isCanonicalDecl()) { // It's kept in the folding set.\n      // Set this as, or find, the canonical declaration for this specialization\n      ClassTemplateSpecializationDecl *CanonSpec;\n      if (auto *Partial = dyn_cast<ClassTemplatePartialSpecializationDecl>(D)) {\n        CanonSpec = CanonPattern->getCommonPtr()->PartialSpecializations\n            .GetOrInsertNode(Partial);\n      } else {\n        CanonSpec =\n            CanonPattern->getCommonPtr()->Specializations.GetOrInsertNode(D);\n      }\n      // If there was already a canonical specialization, merge into it.\n      if (CanonSpec != D) {\n        mergeRedeclarable<TagDecl>(D, CanonSpec, Redecl);\n\n        // This declaration might be a definition. Merge with any existing\n        // definition.\n        if (auto *DDD = D->DefinitionData) {\n          if (CanonSpec->DefinitionData)\n            MergeDefinitionData(CanonSpec, std::move(*DDD));\n          else\n            CanonSpec->DefinitionData = D->DefinitionData;\n        }\n        D->DefinitionData = CanonSpec->DefinitionData;\n      }\n    }\n  }\n\n  // Explicit info.\n  if (TypeSourceInfo *TyInfo = readTypeSourceInfo()) {\n    auto *ExplicitInfo =\n        new (C) ClassTemplateSpecializationDecl::ExplicitSpecializationInfo;\n    ExplicitInfo->TypeAsWritten = TyInfo;\n    ExplicitInfo->ExternLoc = readSourceLocation();\n    ExplicitInfo->TemplateKeywordLoc = readSourceLocation();\n    D->ExplicitInfo = ExplicitInfo;\n  }\n\n  return Redecl;\n}\n\nvoid ASTDeclReader::VisitClassTemplatePartialSpecializationDecl(\n                                    ClassTemplatePartialSpecializationDecl *D) {\n  // We need to read the template params first because redeclarable is going to\n  // need them for profiling\n  TemplateParameterList *Params = Record.readTemplateParameterList();\n  D->TemplateParams = Params;\n  D->ArgsAsWritten = Record.readASTTemplateArgumentListInfo();\n\n  RedeclarableResult Redecl = VisitClassTemplateSpecializationDeclImpl(D);\n\n  // These are read/set from/to the first declaration.\n  if (ThisDeclID == Redecl.getFirstID()) {\n    D->InstantiatedFromMember.setPointer(\n      readDeclAs<ClassTemplatePartialSpecializationDecl>());\n    D->InstantiatedFromMember.setInt(Record.readInt());\n  }\n}\n\nvoid ASTDeclReader::VisitClassScopeFunctionSpecializationDecl(\n                                    ClassScopeFunctionSpecializationDecl *D) {\n  VisitDecl(D);\n  D->Specialization = readDeclAs<CXXMethodDecl>();\n  if (Record.readInt())\n    D->TemplateArgs = Record.readASTTemplateArgumentListInfo();\n}\n\nvoid ASTDeclReader::VisitFunctionTemplateDecl(FunctionTemplateDecl *D) {\n  RedeclarableResult Redecl = VisitRedeclarableTemplateDecl(D);\n\n  if (ThisDeclID == Redecl.getFirstID()) {\n    // This FunctionTemplateDecl owns a CommonPtr; read it.\n    SmallVector<serialization::DeclID, 32> SpecIDs;\n    readDeclIDList(SpecIDs);\n    ASTDeclReader::AddLazySpecializations(D, SpecIDs);\n  }\n}\n\n/// TODO: Unify with ClassTemplateSpecializationDecl version?\n///       May require unifying ClassTemplate(Partial)SpecializationDecl and\n///        VarTemplate(Partial)SpecializationDecl with a new data\n///        structure Template(Partial)SpecializationDecl, and\n///        using Template(Partial)SpecializationDecl as input type.\nASTDeclReader::RedeclarableResult\nASTDeclReader::VisitVarTemplateSpecializationDeclImpl(\n    VarTemplateSpecializationDecl *D) {\n  RedeclarableResult Redecl = VisitVarDeclImpl(D);\n\n  ASTContext &C = Reader.getContext();\n  if (Decl *InstD = readDecl()) {\n    if (auto *VTD = dyn_cast<VarTemplateDecl>(InstD)) {\n      D->SpecializedTemplate = VTD;\n    } else {\n      SmallVector<TemplateArgument, 8> TemplArgs;\n      Record.readTemplateArgumentList(TemplArgs);\n      TemplateArgumentList *ArgList = TemplateArgumentList::CreateCopy(\n          C, TemplArgs);\n      auto *PS =\n          new (C)\n          VarTemplateSpecializationDecl::SpecializedPartialSpecialization();\n      PS->PartialSpecialization =\n          cast<VarTemplatePartialSpecializationDecl>(InstD);\n      PS->TemplateArgs = ArgList;\n      D->SpecializedTemplate = PS;\n    }\n  }\n\n  // Explicit info.\n  if (TypeSourceInfo *TyInfo = readTypeSourceInfo()) {\n    auto *ExplicitInfo =\n        new (C) VarTemplateSpecializationDecl::ExplicitSpecializationInfo;\n    ExplicitInfo->TypeAsWritten = TyInfo;\n    ExplicitInfo->ExternLoc = readSourceLocation();\n    ExplicitInfo->TemplateKeywordLoc = readSourceLocation();\n    D->ExplicitInfo = ExplicitInfo;\n  }\n\n  SmallVector<TemplateArgument, 8> TemplArgs;\n  Record.readTemplateArgumentList(TemplArgs, /*Canonicalize*/ true);\n  D->TemplateArgs = TemplateArgumentList::CreateCopy(C, TemplArgs);\n  D->PointOfInstantiation = readSourceLocation();\n  D->SpecializationKind = (TemplateSpecializationKind)Record.readInt();\n  D->IsCompleteDefinition = Record.readInt();\n\n  bool writtenAsCanonicalDecl = Record.readInt();\n  if (writtenAsCanonicalDecl) {\n    auto *CanonPattern = readDeclAs<VarTemplateDecl>();\n    if (D->isCanonicalDecl()) { // It's kept in the folding set.\n      // FIXME: If it's already present, merge it.\n      if (auto *Partial = dyn_cast<VarTemplatePartialSpecializationDecl>(D)) {\n        CanonPattern->getCommonPtr()->PartialSpecializations\n            .GetOrInsertNode(Partial);\n      } else {\n        CanonPattern->getCommonPtr()->Specializations.GetOrInsertNode(D);\n      }\n    }\n  }\n\n  return Redecl;\n}\n\n/// TODO: Unify with ClassTemplatePartialSpecializationDecl version?\n///       May require unifying ClassTemplate(Partial)SpecializationDecl and\n///        VarTemplate(Partial)SpecializationDecl with a new data\n///        structure Template(Partial)SpecializationDecl, and\n///        using Template(Partial)SpecializationDecl as input type.\nvoid ASTDeclReader::VisitVarTemplatePartialSpecializationDecl(\n    VarTemplatePartialSpecializationDecl *D) {\n  TemplateParameterList *Params = Record.readTemplateParameterList();\n  D->TemplateParams = Params;\n  D->ArgsAsWritten = Record.readASTTemplateArgumentListInfo();\n\n  RedeclarableResult Redecl = VisitVarTemplateSpecializationDeclImpl(D);\n\n  // These are read/set from/to the first declaration.\n  if (ThisDeclID == Redecl.getFirstID()) {\n    D->InstantiatedFromMember.setPointer(\n        readDeclAs<VarTemplatePartialSpecializationDecl>());\n    D->InstantiatedFromMember.setInt(Record.readInt());\n  }\n}\n\nvoid ASTDeclReader::VisitTemplateTypeParmDecl(TemplateTypeParmDecl *D) {\n  VisitTypeDecl(D);\n\n  D->setDeclaredWithTypename(Record.readInt());\n\n  if (Record.readBool()) {\n    NestedNameSpecifierLoc NNS = Record.readNestedNameSpecifierLoc();\n    DeclarationNameInfo DN = Record.readDeclarationNameInfo();\n    ConceptDecl *NamedConcept = Record.readDeclAs<ConceptDecl>();\n    const ASTTemplateArgumentListInfo *ArgsAsWritten = nullptr;\n    if (Record.readBool())\n        ArgsAsWritten = Record.readASTTemplateArgumentListInfo();\n    Expr *ImmediatelyDeclaredConstraint = Record.readExpr();\n    D->setTypeConstraint(NNS, DN, /*FoundDecl=*/nullptr, NamedConcept,\n                         ArgsAsWritten, ImmediatelyDeclaredConstraint);\n    if ((D->ExpandedParameterPack = Record.readInt()))\n      D->NumExpanded = Record.readInt();\n  }\n\n  if (Record.readInt())\n    D->setDefaultArgument(readTypeSourceInfo());\n}\n\nvoid ASTDeclReader::VisitNonTypeTemplateParmDecl(NonTypeTemplateParmDecl *D) {\n  VisitDeclaratorDecl(D);\n  // TemplateParmPosition.\n  D->setDepth(Record.readInt());\n  D->setPosition(Record.readInt());\n  if (D->hasPlaceholderTypeConstraint())\n    D->setPlaceholderTypeConstraint(Record.readExpr());\n  if (D->isExpandedParameterPack()) {\n    auto TypesAndInfos =\n        D->getTrailingObjects<std::pair<QualType, TypeSourceInfo *>>();\n    for (unsigned I = 0, N = D->getNumExpansionTypes(); I != N; ++I) {\n      new (&TypesAndInfos[I].first) QualType(Record.readType());\n      TypesAndInfos[I].second = readTypeSourceInfo();\n    }\n  } else {\n    // Rest of NonTypeTemplateParmDecl.\n    D->ParameterPack = Record.readInt();\n    if (Record.readInt())\n      D->setDefaultArgument(Record.readExpr());\n  }\n}\n\nvoid ASTDeclReader::VisitTemplateTemplateParmDecl(TemplateTemplateParmDecl *D) {\n  VisitTemplateDecl(D);\n  // TemplateParmPosition.\n  D->setDepth(Record.readInt());\n  D->setPosition(Record.readInt());\n  if (D->isExpandedParameterPack()) {\n    auto **Data = D->getTrailingObjects<TemplateParameterList *>();\n    for (unsigned I = 0, N = D->getNumExpansionTemplateParameters();\n         I != N; ++I)\n      Data[I] = Record.readTemplateParameterList();\n  } else {\n    // Rest of TemplateTemplateParmDecl.\n    D->ParameterPack = Record.readInt();\n    if (Record.readInt())\n      D->setDefaultArgument(Reader.getContext(),\n                            Record.readTemplateArgumentLoc());\n  }\n}\n\nvoid ASTDeclReader::VisitTypeAliasTemplateDecl(TypeAliasTemplateDecl *D) {\n  VisitRedeclarableTemplateDecl(D);\n}\n\nvoid ASTDeclReader::VisitStaticAssertDecl(StaticAssertDecl *D) {\n  VisitDecl(D);\n  D->AssertExprAndFailed.setPointer(Record.readExpr());\n  D->AssertExprAndFailed.setInt(Record.readInt());\n  D->Message = cast_or_null<StringLiteral>(Record.readExpr());\n  D->RParenLoc = readSourceLocation();\n}\n\nvoid ASTDeclReader::VisitEmptyDecl(EmptyDecl *D) {\n  VisitDecl(D);\n}\n\nvoid ASTDeclReader::VisitLifetimeExtendedTemporaryDecl(\n    LifetimeExtendedTemporaryDecl *D) {\n  VisitDecl(D);\n  D->ExtendingDecl = readDeclAs<ValueDecl>();\n  D->ExprWithTemporary = Record.readStmt();\n  if (Record.readInt()) {\n    D->Value = new (D->getASTContext()) APValue(Record.readAPValue());\n    D->getASTContext().addDestruction(D->Value);\n  }\n  D->ManglingNumber = Record.readInt();\n  mergeMergeable(D);\n}\n\nstd::pair<uint64_t, uint64_t>\nASTDeclReader::VisitDeclContext(DeclContext *DC) {\n  uint64_t LexicalOffset = ReadLocalOffset();\n  uint64_t VisibleOffset = ReadLocalOffset();\n  return std::make_pair(LexicalOffset, VisibleOffset);\n}\n\ntemplate <typename T>\nASTDeclReader::RedeclarableResult\nASTDeclReader::VisitRedeclarable(Redeclarable<T> *D) {\n  DeclID FirstDeclID = readDeclID();\n  Decl *MergeWith = nullptr;\n\n  bool IsKeyDecl = ThisDeclID == FirstDeclID;\n  bool IsFirstLocalDecl = false;\n\n  uint64_t RedeclOffset = 0;\n\n  // 0 indicates that this declaration was the only declaration of its entity,\n  // and is used for space optimization.\n  if (FirstDeclID == 0) {\n    FirstDeclID = ThisDeclID;\n    IsKeyDecl = true;\n    IsFirstLocalDecl = true;\n  } else if (unsigned N = Record.readInt()) {\n    // This declaration was the first local declaration, but may have imported\n    // other declarations.\n    IsKeyDecl = N == 1;\n    IsFirstLocalDecl = true;\n\n    // We have some declarations that must be before us in our redeclaration\n    // chain. Read them now, and remember that we ought to merge with one of\n    // them.\n    // FIXME: Provide a known merge target to the second and subsequent such\n    // declaration.\n    for (unsigned I = 0; I != N - 1; ++I)\n      MergeWith = readDecl();\n\n    RedeclOffset = ReadLocalOffset();\n  } else {\n    // This declaration was not the first local declaration. Read the first\n    // local declaration now, to trigger the import of other redeclarations.\n    (void)readDecl();\n  }\n\n  auto *FirstDecl = cast_or_null<T>(Reader.GetDecl(FirstDeclID));\n  if (FirstDecl != D) {\n    // We delay loading of the redeclaration chain to avoid deeply nested calls.\n    // We temporarily set the first (canonical) declaration as the previous one\n    // which is the one that matters and mark the real previous DeclID to be\n    // loaded & attached later on.\n    D->RedeclLink = Redeclarable<T>::PreviousDeclLink(FirstDecl);\n    D->First = FirstDecl->getCanonicalDecl();\n  }\n\n  auto *DAsT = static_cast<T *>(D);\n\n  // Note that we need to load local redeclarations of this decl and build a\n  // decl chain for them. This must happen *after* we perform the preloading\n  // above; this ensures that the redeclaration chain is built in the correct\n  // order.\n  if (IsFirstLocalDecl)\n    Reader.PendingDeclChains.push_back(std::make_pair(DAsT, RedeclOffset));\n\n  return RedeclarableResult(MergeWith, FirstDeclID, IsKeyDecl);\n}\n\n/// Attempts to merge the given declaration (D) with another declaration\n/// of the same entity.\ntemplate<typename T>\nvoid ASTDeclReader::mergeRedeclarable(Redeclarable<T> *DBase,\n                                      RedeclarableResult &Redecl,\n                                      DeclID TemplatePatternID) {\n  // If modules are not available, there is no reason to perform this merge.\n  if (!Reader.getContext().getLangOpts().Modules)\n    return;\n\n  // If we're not the canonical declaration, we don't need to merge.\n  if (!DBase->isFirstDecl())\n    return;\n\n  auto *D = static_cast<T *>(DBase);\n\n  if (auto *Existing = Redecl.getKnownMergeTarget())\n    // We already know of an existing declaration we should merge with.\n    mergeRedeclarable(D, cast<T>(Existing), Redecl, TemplatePatternID);\n  else if (FindExistingResult ExistingRes = findExisting(D))\n    if (T *Existing = ExistingRes)\n      mergeRedeclarable(D, Existing, Redecl, TemplatePatternID);\n}\n\n/// \"Cast\" to type T, asserting if we don't have an implicit conversion.\n/// We use this to put code in a template that will only be valid for certain\n/// instantiations.\ntemplate<typename T> static T assert_cast(T t) { return t; }\ntemplate<typename T> static T assert_cast(...) {\n  llvm_unreachable(\"bad assert_cast\");\n}\n\n/// Merge together the pattern declarations from two template\n/// declarations.\nvoid ASTDeclReader::mergeTemplatePattern(RedeclarableTemplateDecl *D,\n                                         RedeclarableTemplateDecl *Existing,\n                                         DeclID DsID, bool IsKeyDecl) {\n  auto *DPattern = D->getTemplatedDecl();\n  auto *ExistingPattern = Existing->getTemplatedDecl();\n  RedeclarableResult Result(/*MergeWith*/ ExistingPattern,\n                            DPattern->getCanonicalDecl()->getGlobalID(),\n                            IsKeyDecl);\n\n  if (auto *DClass = dyn_cast<CXXRecordDecl>(DPattern)) {\n    // Merge with any existing definition.\n    // FIXME: This is duplicated in several places. Refactor.\n    auto *ExistingClass =\n        cast<CXXRecordDecl>(ExistingPattern)->getCanonicalDecl();\n    if (auto *DDD = DClass->DefinitionData) {\n      if (ExistingClass->DefinitionData) {\n        MergeDefinitionData(ExistingClass, std::move(*DDD));\n      } else {\n        ExistingClass->DefinitionData = DClass->DefinitionData;\n        // We may have skipped this before because we thought that DClass\n        // was the canonical declaration.\n        Reader.PendingDefinitions.insert(DClass);\n      }\n    }\n    DClass->DefinitionData = ExistingClass->DefinitionData;\n\n    return mergeRedeclarable(DClass, cast<TagDecl>(ExistingPattern),\n                             Result);\n  }\n  if (auto *DFunction = dyn_cast<FunctionDecl>(DPattern))\n    return mergeRedeclarable(DFunction, cast<FunctionDecl>(ExistingPattern),\n                             Result);\n  if (auto *DVar = dyn_cast<VarDecl>(DPattern))\n    return mergeRedeclarable(DVar, cast<VarDecl>(ExistingPattern), Result);\n  if (auto *DAlias = dyn_cast<TypeAliasDecl>(DPattern))\n    return mergeRedeclarable(DAlias, cast<TypedefNameDecl>(ExistingPattern),\n                             Result);\n  llvm_unreachable(\"merged an unknown kind of redeclarable template\");\n}\n\n/// Attempts to merge the given declaration (D) with another declaration\n/// of the same entity.\ntemplate<typename T>\nvoid ASTDeclReader::mergeRedeclarable(Redeclarable<T> *DBase, T *Existing,\n                                      RedeclarableResult &Redecl,\n                                      DeclID TemplatePatternID) {\n  auto *D = static_cast<T *>(DBase);\n  T *ExistingCanon = Existing->getCanonicalDecl();\n  T *DCanon = D->getCanonicalDecl();\n  if (ExistingCanon != DCanon) {\n    assert(DCanon->getGlobalID() == Redecl.getFirstID() &&\n           \"already merged this declaration\");\n\n    // Have our redeclaration link point back at the canonical declaration\n    // of the existing declaration, so that this declaration has the\n    // appropriate canonical declaration.\n    D->RedeclLink = Redeclarable<T>::PreviousDeclLink(ExistingCanon);\n    D->First = ExistingCanon;\n    ExistingCanon->Used |= D->Used;\n    D->Used = false;\n\n    // When we merge a namespace, update its pointer to the first namespace.\n    // We cannot have loaded any redeclarations of this declaration yet, so\n    // there's nothing else that needs to be updated.\n    if (auto *Namespace = dyn_cast<NamespaceDecl>(D))\n      Namespace->AnonOrFirstNamespaceAndInline.setPointer(\n          assert_cast<NamespaceDecl*>(ExistingCanon));\n\n    // When we merge a template, merge its pattern.\n    if (auto *DTemplate = dyn_cast<RedeclarableTemplateDecl>(D))\n      mergeTemplatePattern(\n          DTemplate, assert_cast<RedeclarableTemplateDecl*>(ExistingCanon),\n          TemplatePatternID, Redecl.isKeyDecl());\n\n    // If this declaration is a key declaration, make a note of that.\n    if (Redecl.isKeyDecl())\n      Reader.KeyDecls[ExistingCanon].push_back(Redecl.getFirstID());\n  }\n}\n\n/// ODR-like semantics for C/ObjC allow us to merge tag types and a structural\n/// check in Sema guarantees the types can be merged (see C11 6.2.7/1 or C89\n/// 6.1.2.6/1). Although most merging is done in Sema, we need to guarantee\n/// that some types are mergeable during deserialization, otherwise name\n/// lookup fails. This is the case for EnumConstantDecl.\nstatic bool allowODRLikeMergeInC(NamedDecl *ND) {\n  if (!ND)\n    return false;\n  // TODO: implement merge for other necessary decls.\n  if (isa<EnumConstantDecl>(ND))\n    return true;\n  return false;\n}\n\n/// Attempts to merge LifetimeExtendedTemporaryDecl with\n/// identical class definitions from two different modules.\nvoid ASTDeclReader::mergeMergeable(LifetimeExtendedTemporaryDecl *D) {\n  // If modules are not available, there is no reason to perform this merge.\n  if (!Reader.getContext().getLangOpts().Modules)\n    return;\n\n  LifetimeExtendedTemporaryDecl *LETDecl = D;\n\n  LifetimeExtendedTemporaryDecl *&LookupResult =\n      Reader.LETemporaryForMerging[std::make_pair(\n          LETDecl->getExtendingDecl(), LETDecl->getManglingNumber())];\n  if (LookupResult)\n    Reader.getContext().setPrimaryMergedDecl(LETDecl,\n                                             LookupResult->getCanonicalDecl());\n  else\n    LookupResult = LETDecl;\n}\n\n/// Attempts to merge the given declaration (D) with another declaration\n/// of the same entity, for the case where the entity is not actually\n/// redeclarable. This happens, for instance, when merging the fields of\n/// identical class definitions from two different modules.\ntemplate<typename T>\nvoid ASTDeclReader::mergeMergeable(Mergeable<T> *D) {\n  // If modules are not available, there is no reason to perform this merge.\n  if (!Reader.getContext().getLangOpts().Modules)\n    return;\n\n  // ODR-based merging is performed in C++ and in some cases (tag types) in C.\n  // Note that C identically-named things in different translation units are\n  // not redeclarations, but may still have compatible types, where ODR-like\n  // semantics may apply.\n  if (!Reader.getContext().getLangOpts().CPlusPlus &&\n      !allowODRLikeMergeInC(dyn_cast<NamedDecl>(static_cast<T*>(D))))\n    return;\n\n  if (FindExistingResult ExistingRes = findExisting(static_cast<T*>(D)))\n    if (T *Existing = ExistingRes)\n      Reader.getContext().setPrimaryMergedDecl(static_cast<T *>(D),\n                                               Existing->getCanonicalDecl());\n}\n\nvoid ASTDeclReader::VisitOMPThreadPrivateDecl(OMPThreadPrivateDecl *D) {\n  Record.readOMPChildren(D->Data);\n  VisitDecl(D);\n}\n\nvoid ASTDeclReader::VisitOMPAllocateDecl(OMPAllocateDecl *D) {\n  Record.readOMPChildren(D->Data);\n  VisitDecl(D);\n}\n\nvoid ASTDeclReader::VisitOMPRequiresDecl(OMPRequiresDecl * D) {\n  Record.readOMPChildren(D->Data);\n  VisitDecl(D);\n}\n\nvoid ASTDeclReader::VisitOMPDeclareReductionDecl(OMPDeclareReductionDecl *D) {\n  VisitValueDecl(D);\n  D->setLocation(readSourceLocation());\n  Expr *In = Record.readExpr();\n  Expr *Out = Record.readExpr();\n  D->setCombinerData(In, Out);\n  Expr *Combiner = Record.readExpr();\n  D->setCombiner(Combiner);\n  Expr *Orig = Record.readExpr();\n  Expr *Priv = Record.readExpr();\n  D->setInitializerData(Orig, Priv);\n  Expr *Init = Record.readExpr();\n  auto IK = static_cast<OMPDeclareReductionDecl::InitKind>(Record.readInt());\n  D->setInitializer(Init, IK);\n  D->PrevDeclInScope = readDeclID();\n}\n\nvoid ASTDeclReader::VisitOMPDeclareMapperDecl(OMPDeclareMapperDecl *D) {\n  Record.readOMPChildren(D->Data);\n  VisitValueDecl(D);\n  D->VarName = Record.readDeclarationName();\n  D->PrevDeclInScope = readDeclID();\n}\n\nvoid ASTDeclReader::VisitOMPCapturedExprDecl(OMPCapturedExprDecl *D) {\n  VisitVarDecl(D);\n}\n\n//===----------------------------------------------------------------------===//\n// Attribute Reading\n//===----------------------------------------------------------------------===//\n\nnamespace {\nclass AttrReader {\n  ASTRecordReader &Reader;\n\npublic:\n  AttrReader(ASTRecordReader &Reader) : Reader(Reader) {}\n\n  uint64_t readInt() {\n    return Reader.readInt();\n  }\n\n  SourceRange readSourceRange() {\n    return Reader.readSourceRange();\n  }\n\n  SourceLocation readSourceLocation() {\n    return Reader.readSourceLocation();\n  }\n\n  Expr *readExpr() { return Reader.readExpr(); }\n\n  std::string readString() {\n    return Reader.readString();\n  }\n\n  TypeSourceInfo *readTypeSourceInfo() {\n    return Reader.readTypeSourceInfo();\n  }\n\n  IdentifierInfo *readIdentifier() {\n    return Reader.readIdentifier();\n  }\n\n  VersionTuple readVersionTuple() {\n    return Reader.readVersionTuple();\n  }\n\n  OMPTraitInfo *readOMPTraitInfo() { return Reader.readOMPTraitInfo(); }\n\n  template <typename T> T *GetLocalDeclAs(uint32_t LocalID) {\n    return Reader.GetLocalDeclAs<T>(LocalID);\n  }\n};\n}\n\nAttr *ASTRecordReader::readAttr() {\n  AttrReader Record(*this);\n  auto V = Record.readInt();\n  if (!V)\n    return nullptr;\n\n  Attr *New = nullptr;\n  // Kind is stored as a 1-based integer because 0 is used to indicate a null\n  // Attr pointer.\n  auto Kind = static_cast<attr::Kind>(V - 1);\n  ASTContext &Context = getContext();\n\n  IdentifierInfo *AttrName = Record.readIdentifier();\n  IdentifierInfo *ScopeName = Record.readIdentifier();\n  SourceRange AttrRange = Record.readSourceRange();\n  SourceLocation ScopeLoc = Record.readSourceLocation();\n  unsigned ParsedKind = Record.readInt();\n  unsigned Syntax = Record.readInt();\n  unsigned SpellingIndex = Record.readInt();\n\n  AttributeCommonInfo Info(AttrName, ScopeName, AttrRange, ScopeLoc,\n                           AttributeCommonInfo::Kind(ParsedKind),\n                           AttributeCommonInfo::Syntax(Syntax), SpellingIndex);\n\n#include \"clang/Serialization/AttrPCHRead.inc\"\n\n  assert(New && \"Unable to decode attribute?\");\n  return New;\n}\n\n/// Reads attributes from the current stream position.\nvoid ASTRecordReader::readAttributes(AttrVec &Attrs) {\n  for (unsigned I = 0, E = readInt(); I != E; ++I)\n    Attrs.push_back(readAttr());\n}\n\n//===----------------------------------------------------------------------===//\n// ASTReader Implementation\n//===----------------------------------------------------------------------===//\n\n/// Note that we have loaded the declaration with the given\n/// Index.\n///\n/// This routine notes that this declaration has already been loaded,\n/// so that future GetDecl calls will return this declaration rather\n/// than trying to load a new declaration.\ninline void ASTReader::LoadedDecl(unsigned Index, Decl *D) {\n  assert(!DeclsLoaded[Index] && \"Decl loaded twice?\");\n  DeclsLoaded[Index] = D;\n}\n\n/// Determine whether the consumer will be interested in seeing\n/// this declaration (via HandleTopLevelDecl).\n///\n/// This routine should return true for anything that might affect\n/// code generation, e.g., inline function definitions, Objective-C\n/// declarations with metadata, etc.\nstatic bool isConsumerInterestedIn(ASTContext &Ctx, Decl *D, bool HasBody) {\n  // An ObjCMethodDecl is never considered as \"interesting\" because its\n  // implementation container always is.\n\n  // An ImportDecl or VarDecl imported from a module map module will get\n  // emitted when we import the relevant module.\n  if (isPartOfPerModuleInitializer(D)) {\n    auto *M = D->getImportedOwningModule();\n    if (M && M->Kind == Module::ModuleMapModule &&\n        Ctx.DeclMustBeEmitted(D))\n      return false;\n  }\n\n  if (isa<FileScopeAsmDecl>(D) ||\n      isa<ObjCProtocolDecl>(D) ||\n      isa<ObjCImplDecl>(D) ||\n      isa<ImportDecl>(D) ||\n      isa<PragmaCommentDecl>(D) ||\n      isa<PragmaDetectMismatchDecl>(D))\n    return true;\n  if (isa<OMPThreadPrivateDecl>(D) || isa<OMPDeclareReductionDecl>(D) ||\n      isa<OMPDeclareMapperDecl>(D) || isa<OMPAllocateDecl>(D) ||\n      isa<OMPRequiresDecl>(D))\n    return !D->getDeclContext()->isFunctionOrMethod();\n  if (const auto *Var = dyn_cast<VarDecl>(D))\n    return Var->isFileVarDecl() &&\n           (Var->isThisDeclarationADefinition() == VarDecl::Definition ||\n            OMPDeclareTargetDeclAttr::isDeclareTargetDeclaration(Var));\n  if (const auto *Func = dyn_cast<FunctionDecl>(D))\n    return Func->doesThisDeclarationHaveABody() || HasBody;\n\n  if (auto *ES = D->getASTContext().getExternalSource())\n    if (ES->hasExternalDefinitions(D) == ExternalASTSource::EK_Never)\n      return true;\n\n  return false;\n}\n\n/// Get the correct cursor and offset for loading a declaration.\nASTReader::RecordLocation\nASTReader::DeclCursorForID(DeclID ID, SourceLocation &Loc) {\n  GlobalDeclMapType::iterator I = GlobalDeclMap.find(ID);\n  assert(I != GlobalDeclMap.end() && \"Corrupted global declaration map\");\n  ModuleFile *M = I->second;\n  const DeclOffset &DOffs =\n      M->DeclOffsets[ID - M->BaseDeclID - NUM_PREDEF_DECL_IDS];\n  Loc = TranslateSourceLocation(*M, DOffs.getLocation());\n  return RecordLocation(M, DOffs.getBitOffset(M->DeclsBlockStartOffset));\n}\n\nASTReader::RecordLocation ASTReader::getLocalBitOffset(uint64_t GlobalOffset) {\n  auto I = GlobalBitOffsetsMap.find(GlobalOffset);\n\n  assert(I != GlobalBitOffsetsMap.end() && \"Corrupted global bit offsets map\");\n  return RecordLocation(I->second, GlobalOffset - I->second->GlobalBitOffset);\n}\n\nuint64_t ASTReader::getGlobalBitOffset(ModuleFile &M, uint64_t LocalOffset) {\n  return LocalOffset + M.GlobalBitOffset;\n}\n\nstatic bool isSameTemplateParameterList(const ASTContext &C,\n                                        const TemplateParameterList *X,\n                                        const TemplateParameterList *Y);\n\n/// Determine whether two template parameters are similar enough\n/// that they may be used in declarations of the same template.\nstatic bool isSameTemplateParameter(const NamedDecl *X,\n                                    const NamedDecl *Y) {\n  if (X->getKind() != Y->getKind())\n    return false;\n\n  if (const auto *TX = dyn_cast<TemplateTypeParmDecl>(X)) {\n    const auto *TY = cast<TemplateTypeParmDecl>(Y);\n    if (TX->isParameterPack() != TY->isParameterPack())\n      return false;\n    if (TX->hasTypeConstraint() != TY->hasTypeConstraint())\n      return false;\n    const TypeConstraint *TXTC = TX->getTypeConstraint();\n    const TypeConstraint *TYTC = TY->getTypeConstraint();\n    if (!TXTC != !TYTC)\n      return false;\n    if (TXTC && TYTC) {\n      if (TXTC->getNamedConcept() != TYTC->getNamedConcept())\n        return false;\n      if (TXTC->hasExplicitTemplateArgs() != TYTC->hasExplicitTemplateArgs())\n        return false;\n      if (TXTC->hasExplicitTemplateArgs()) {\n        const auto *TXTCArgs = TXTC->getTemplateArgsAsWritten();\n        const auto *TYTCArgs = TYTC->getTemplateArgsAsWritten();\n        if (TXTCArgs->NumTemplateArgs != TYTCArgs->NumTemplateArgs)\n          return false;\n        llvm::FoldingSetNodeID XID, YID;\n        for (const auto &ArgLoc : TXTCArgs->arguments())\n          ArgLoc.getArgument().Profile(XID, X->getASTContext());\n        for (const auto &ArgLoc : TYTCArgs->arguments())\n          ArgLoc.getArgument().Profile(YID, Y->getASTContext());\n        if (XID != YID)\n          return false;\n      }\n    }\n    return true;\n  }\n\n  if (const auto *TX = dyn_cast<NonTypeTemplateParmDecl>(X)) {\n    const auto *TY = cast<NonTypeTemplateParmDecl>(Y);\n    return TX->isParameterPack() == TY->isParameterPack() &&\n           TX->getASTContext().hasSameType(TX->getType(), TY->getType());\n  }\n\n  const auto *TX = cast<TemplateTemplateParmDecl>(X);\n  const auto *TY = cast<TemplateTemplateParmDecl>(Y);\n  return TX->isParameterPack() == TY->isParameterPack() &&\n         isSameTemplateParameterList(TX->getASTContext(),\n                                     TX->getTemplateParameters(),\n                                     TY->getTemplateParameters());\n}\n\nstatic NamespaceDecl *getNamespace(const NestedNameSpecifier *X) {\n  if (auto *NS = X->getAsNamespace())\n    return NS;\n  if (auto *NAS = X->getAsNamespaceAlias())\n    return NAS->getNamespace();\n  return nullptr;\n}\n\nstatic bool isSameQualifier(const NestedNameSpecifier *X,\n                            const NestedNameSpecifier *Y) {\n  if (auto *NSX = getNamespace(X)) {\n    auto *NSY = getNamespace(Y);\n    if (!NSY || NSX->getCanonicalDecl() != NSY->getCanonicalDecl())\n      return false;\n  } else if (X->getKind() != Y->getKind())\n    return false;\n\n  // FIXME: For namespaces and types, we're permitted to check that the entity\n  // is named via the same tokens. We should probably do so.\n  switch (X->getKind()) {\n  case NestedNameSpecifier::Identifier:\n    if (X->getAsIdentifier() != Y->getAsIdentifier())\n      return false;\n    break;\n  case NestedNameSpecifier::Namespace:\n  case NestedNameSpecifier::NamespaceAlias:\n    // We've already checked that we named the same namespace.\n    break;\n  case NestedNameSpecifier::TypeSpec:\n  case NestedNameSpecifier::TypeSpecWithTemplate:\n    if (X->getAsType()->getCanonicalTypeInternal() !=\n        Y->getAsType()->getCanonicalTypeInternal())\n      return false;\n    break;\n  case NestedNameSpecifier::Global:\n  case NestedNameSpecifier::Super:\n    return true;\n  }\n\n  // Recurse into earlier portion of NNS, if any.\n  auto *PX = X->getPrefix();\n  auto *PY = Y->getPrefix();\n  if (PX && PY)\n    return isSameQualifier(PX, PY);\n  return !PX && !PY;\n}\n\n/// Determine whether two template parameter lists are similar enough\n/// that they may be used in declarations of the same template.\nstatic bool isSameTemplateParameterList(const ASTContext &C,\n                                        const TemplateParameterList *X,\n                                        const TemplateParameterList *Y) {\n  if (X->size() != Y->size())\n    return false;\n\n  for (unsigned I = 0, N = X->size(); I != N; ++I)\n    if (!isSameTemplateParameter(X->getParam(I), Y->getParam(I)))\n      return false;\n\n  const Expr *XRC = X->getRequiresClause();\n  const Expr *YRC = Y->getRequiresClause();\n  if (!XRC != !YRC)\n    return false;\n  if (XRC) {\n    llvm::FoldingSetNodeID XRCID, YRCID;\n    XRC->Profile(XRCID, C, /*Canonical=*/true);\n    YRC->Profile(YRCID, C, /*Canonical=*/true);\n    if (XRCID != YRCID)\n      return false;\n  }\n\n  return true;\n}\n\n/// Determine whether the attributes we can overload on are identical for A and\n/// B. Will ignore any overloadable attrs represented in the type of A and B.\nstatic bool hasSameOverloadableAttrs(const FunctionDecl *A,\n                                     const FunctionDecl *B) {\n  // Note that pass_object_size attributes are represented in the function's\n  // ExtParameterInfo, so we don't need to check them here.\n\n  llvm::FoldingSetNodeID Cand1ID, Cand2ID;\n  auto AEnableIfAttrs = A->specific_attrs<EnableIfAttr>();\n  auto BEnableIfAttrs = B->specific_attrs<EnableIfAttr>();\n\n  for (auto Pair : zip_longest(AEnableIfAttrs, BEnableIfAttrs)) {\n    Optional<EnableIfAttr *> Cand1A = std::get<0>(Pair);\n    Optional<EnableIfAttr *> Cand2A = std::get<1>(Pair);\n\n    // Return false if the number of enable_if attributes is different.\n    if (!Cand1A || !Cand2A)\n      return false;\n\n    Cand1ID.clear();\n    Cand2ID.clear();\n\n    (*Cand1A)->getCond()->Profile(Cand1ID, A->getASTContext(), true);\n    (*Cand2A)->getCond()->Profile(Cand2ID, B->getASTContext(), true);\n\n    // Return false if any of the enable_if expressions of A and B are\n    // different.\n    if (Cand1ID != Cand2ID)\n      return false;\n  }\n  return true;\n}\n\n/// Determine whether the two declarations refer to the same entity.pr\nstatic bool isSameEntity(NamedDecl *X, NamedDecl *Y) {\n  assert(X->getDeclName() == Y->getDeclName() && \"Declaration name mismatch!\");\n\n  if (X == Y)\n    return true;\n\n  // Must be in the same context.\n  //\n  // Note that we can't use DeclContext::Equals here, because the DeclContexts\n  // could be two different declarations of the same function. (We will fix the\n  // semantic DC to refer to the primary definition after merging.)\n  if (!declaresSameEntity(cast<Decl>(X->getDeclContext()->getRedeclContext()),\n                          cast<Decl>(Y->getDeclContext()->getRedeclContext())))\n    return false;\n\n  // Two typedefs refer to the same entity if they have the same underlying\n  // type.\n  if (const auto *TypedefX = dyn_cast<TypedefNameDecl>(X))\n    if (const auto *TypedefY = dyn_cast<TypedefNameDecl>(Y))\n      return X->getASTContext().hasSameType(TypedefX->getUnderlyingType(),\n                                            TypedefY->getUnderlyingType());\n\n  // Must have the same kind.\n  if (X->getKind() != Y->getKind())\n    return false;\n\n  // Objective-C classes and protocols with the same name always match.\n  if (isa<ObjCInterfaceDecl>(X) || isa<ObjCProtocolDecl>(X))\n    return true;\n\n  if (isa<ClassTemplateSpecializationDecl>(X)) {\n    // No need to handle these here: we merge them when adding them to the\n    // template.\n    return false;\n  }\n\n  // Compatible tags match.\n  if (const auto *TagX = dyn_cast<TagDecl>(X)) {\n    const auto *TagY = cast<TagDecl>(Y);\n    return (TagX->getTagKind() == TagY->getTagKind()) ||\n      ((TagX->getTagKind() == TTK_Struct || TagX->getTagKind() == TTK_Class ||\n        TagX->getTagKind() == TTK_Interface) &&\n       (TagY->getTagKind() == TTK_Struct || TagY->getTagKind() == TTK_Class ||\n        TagY->getTagKind() == TTK_Interface));\n  }\n\n  // Functions with the same type and linkage match.\n  // FIXME: This needs to cope with merging of prototyped/non-prototyped\n  // functions, etc.\n  if (const auto *FuncX = dyn_cast<FunctionDecl>(X)) {\n    const auto *FuncY = cast<FunctionDecl>(Y);\n    if (const auto *CtorX = dyn_cast<CXXConstructorDecl>(X)) {\n      const auto *CtorY = cast<CXXConstructorDecl>(Y);\n      if (CtorX->getInheritedConstructor() &&\n          !isSameEntity(CtorX->getInheritedConstructor().getConstructor(),\n                        CtorY->getInheritedConstructor().getConstructor()))\n        return false;\n    }\n\n    if (FuncX->isMultiVersion() != FuncY->isMultiVersion())\n      return false;\n\n    // Multiversioned functions with different feature strings are represented\n    // as separate declarations.\n    if (FuncX->isMultiVersion()) {\n      const auto *TAX = FuncX->getAttr<TargetAttr>();\n      const auto *TAY = FuncY->getAttr<TargetAttr>();\n      assert(TAX && TAY && \"Multiversion Function without target attribute\");\n\n      if (TAX->getFeaturesStr() != TAY->getFeaturesStr())\n        return false;\n    }\n\n    ASTContext &C = FuncX->getASTContext();\n\n    const Expr *XRC = FuncX->getTrailingRequiresClause();\n    const Expr *YRC = FuncY->getTrailingRequiresClause();\n    if (!XRC != !YRC)\n      return false;\n    if (XRC) {\n      llvm::FoldingSetNodeID XRCID, YRCID;\n      XRC->Profile(XRCID, C, /*Canonical=*/true);\n      YRC->Profile(YRCID, C, /*Canonical=*/true);\n      if (XRCID != YRCID)\n        return false;\n    }\n\n    auto GetTypeAsWritten = [](const FunctionDecl *FD) {\n      // Map to the first declaration that we've already merged into this one.\n      // The TSI of redeclarations might not match (due to calling conventions\n      // being inherited onto the type but not the TSI), but the TSI type of\n      // the first declaration of the function should match across modules.\n      FD = FD->getCanonicalDecl();\n      return FD->getTypeSourceInfo() ? FD->getTypeSourceInfo()->getType()\n                                     : FD->getType();\n    };\n    QualType XT = GetTypeAsWritten(FuncX), YT = GetTypeAsWritten(FuncY);\n    if (!C.hasSameType(XT, YT)) {\n      // We can get functions with different types on the redecl chain in C++17\n      // if they have differing exception specifications and at least one of\n      // the excpetion specs is unresolved.\n      auto *XFPT = XT->getAs<FunctionProtoType>();\n      auto *YFPT = YT->getAs<FunctionProtoType>();\n      if (C.getLangOpts().CPlusPlus17 && XFPT && YFPT &&\n          (isUnresolvedExceptionSpec(XFPT->getExceptionSpecType()) ||\n           isUnresolvedExceptionSpec(YFPT->getExceptionSpecType())) &&\n          C.hasSameFunctionTypeIgnoringExceptionSpec(XT, YT))\n        return true;\n      return false;\n    }\n\n    return FuncX->getLinkageInternal() == FuncY->getLinkageInternal() &&\n           hasSameOverloadableAttrs(FuncX, FuncY);\n  }\n\n  // Variables with the same type and linkage match.\n  if (const auto *VarX = dyn_cast<VarDecl>(X)) {\n    const auto *VarY = cast<VarDecl>(Y);\n    if (VarX->getLinkageInternal() == VarY->getLinkageInternal()) {\n      ASTContext &C = VarX->getASTContext();\n      if (C.hasSameType(VarX->getType(), VarY->getType()))\n        return true;\n\n      // We can get decls with different types on the redecl chain. Eg.\n      // template <typename T> struct S { static T Var[]; }; // #1\n      // template <typename T> T S<T>::Var[sizeof(T)]; // #2\n      // Only? happens when completing an incomplete array type. In this case\n      // when comparing #1 and #2 we should go through their element type.\n      const ArrayType *VarXTy = C.getAsArrayType(VarX->getType());\n      const ArrayType *VarYTy = C.getAsArrayType(VarY->getType());\n      if (!VarXTy || !VarYTy)\n        return false;\n      if (VarXTy->isIncompleteArrayType() || VarYTy->isIncompleteArrayType())\n        return C.hasSameType(VarXTy->getElementType(), VarYTy->getElementType());\n    }\n    return false;\n  }\n\n  // Namespaces with the same name and inlinedness match.\n  if (const auto *NamespaceX = dyn_cast<NamespaceDecl>(X)) {\n    const auto *NamespaceY = cast<NamespaceDecl>(Y);\n    return NamespaceX->isInline() == NamespaceY->isInline();\n  }\n\n  // Identical template names and kinds match if their template parameter lists\n  // and patterns match.\n  if (const auto *TemplateX = dyn_cast<TemplateDecl>(X)) {\n    const auto *TemplateY = cast<TemplateDecl>(Y);\n    return isSameEntity(TemplateX->getTemplatedDecl(),\n                        TemplateY->getTemplatedDecl()) &&\n           isSameTemplateParameterList(TemplateX->getASTContext(),\n                                       TemplateX->getTemplateParameters(),\n                                       TemplateY->getTemplateParameters());\n  }\n\n  // Fields with the same name and the same type match.\n  if (const auto *FDX = dyn_cast<FieldDecl>(X)) {\n    const auto *FDY = cast<FieldDecl>(Y);\n    // FIXME: Also check the bitwidth is odr-equivalent, if any.\n    return X->getASTContext().hasSameType(FDX->getType(), FDY->getType());\n  }\n\n  // Indirect fields with the same target field match.\n  if (const auto *IFDX = dyn_cast<IndirectFieldDecl>(X)) {\n    const auto *IFDY = cast<IndirectFieldDecl>(Y);\n    return IFDX->getAnonField()->getCanonicalDecl() ==\n           IFDY->getAnonField()->getCanonicalDecl();\n  }\n\n  // Enumerators with the same name match.\n  if (isa<EnumConstantDecl>(X))\n    // FIXME: Also check the value is odr-equivalent.\n    return true;\n\n  // Using shadow declarations with the same target match.\n  if (const auto *USX = dyn_cast<UsingShadowDecl>(X)) {\n    const auto *USY = cast<UsingShadowDecl>(Y);\n    return USX->getTargetDecl() == USY->getTargetDecl();\n  }\n\n  // Using declarations with the same qualifier match. (We already know that\n  // the name matches.)\n  if (const auto *UX = dyn_cast<UsingDecl>(X)) {\n    const auto *UY = cast<UsingDecl>(Y);\n    return isSameQualifier(UX->getQualifier(), UY->getQualifier()) &&\n           UX->hasTypename() == UY->hasTypename() &&\n           UX->isAccessDeclaration() == UY->isAccessDeclaration();\n  }\n  if (const auto *UX = dyn_cast<UnresolvedUsingValueDecl>(X)) {\n    const auto *UY = cast<UnresolvedUsingValueDecl>(Y);\n    return isSameQualifier(UX->getQualifier(), UY->getQualifier()) &&\n           UX->isAccessDeclaration() == UY->isAccessDeclaration();\n  }\n  if (const auto *UX = dyn_cast<UnresolvedUsingTypenameDecl>(X))\n    return isSameQualifier(\n        UX->getQualifier(),\n        cast<UnresolvedUsingTypenameDecl>(Y)->getQualifier());\n\n  // Namespace alias definitions with the same target match.\n  if (const auto *NAX = dyn_cast<NamespaceAliasDecl>(X)) {\n    const auto *NAY = cast<NamespaceAliasDecl>(Y);\n    return NAX->getNamespace()->Equals(NAY->getNamespace());\n  }\n\n  return false;\n}\n\n/// Find the context in which we should search for previous declarations when\n/// looking for declarations to merge.\nDeclContext *ASTDeclReader::getPrimaryContextForMerging(ASTReader &Reader,\n                                                        DeclContext *DC) {\n  if (auto *ND = dyn_cast<NamespaceDecl>(DC))\n    return ND->getOriginalNamespace();\n\n  if (auto *RD = dyn_cast<CXXRecordDecl>(DC)) {\n    // Try to dig out the definition.\n    auto *DD = RD->DefinitionData;\n    if (!DD)\n      DD = RD->getCanonicalDecl()->DefinitionData;\n\n    // If there's no definition yet, then DC's definition is added by an update\n    // record, but we've not yet loaded that update record. In this case, we\n    // commit to DC being the canonical definition now, and will fix this when\n    // we load the update record.\n    if (!DD) {\n      DD = new (Reader.getContext()) struct CXXRecordDecl::DefinitionData(RD);\n      RD->setCompleteDefinition(true);\n      RD->DefinitionData = DD;\n      RD->getCanonicalDecl()->DefinitionData = DD;\n\n      // Track that we did this horrible thing so that we can fix it later.\n      Reader.PendingFakeDefinitionData.insert(\n          std::make_pair(DD, ASTReader::PendingFakeDefinitionKind::Fake));\n    }\n\n    return DD->Definition;\n  }\n\n  if (auto *ED = dyn_cast<EnumDecl>(DC))\n    return ED->getASTContext().getLangOpts().CPlusPlus? ED->getDefinition()\n                                                      : nullptr;\n\n  // We can see the TU here only if we have no Sema object. In that case,\n  // there's no TU scope to look in, so using the DC alone is sufficient.\n  if (auto *TU = dyn_cast<TranslationUnitDecl>(DC))\n    return TU;\n\n  return nullptr;\n}\n\nASTDeclReader::FindExistingResult::~FindExistingResult() {\n  // Record that we had a typedef name for linkage whether or not we merge\n  // with that declaration.\n  if (TypedefNameForLinkage) {\n    DeclContext *DC = New->getDeclContext()->getRedeclContext();\n    Reader.ImportedTypedefNamesForLinkage.insert(\n        std::make_pair(std::make_pair(DC, TypedefNameForLinkage), New));\n    return;\n  }\n\n  if (!AddResult || Existing)\n    return;\n\n  DeclarationName Name = New->getDeclName();\n  DeclContext *DC = New->getDeclContext()->getRedeclContext();\n  if (needsAnonymousDeclarationNumber(New)) {\n    setAnonymousDeclForMerging(Reader, New->getLexicalDeclContext(),\n                               AnonymousDeclNumber, New);\n  } else if (DC->isTranslationUnit() &&\n             !Reader.getContext().getLangOpts().CPlusPlus) {\n    if (Reader.getIdResolver().tryAddTopLevelDecl(New, Name))\n      Reader.PendingFakeLookupResults[Name.getAsIdentifierInfo()]\n            .push_back(New);\n  } else if (DeclContext *MergeDC = getPrimaryContextForMerging(Reader, DC)) {\n    // Add the declaration to its redeclaration context so later merging\n    // lookups will find it.\n    MergeDC->makeDeclVisibleInContextImpl(New, /*Internal*/true);\n  }\n}\n\n/// Find the declaration that should be merged into, given the declaration found\n/// by name lookup. If we're merging an anonymous declaration within a typedef,\n/// we need a matching typedef, and we merge with the type inside it.\nstatic NamedDecl *getDeclForMerging(NamedDecl *Found,\n                                    bool IsTypedefNameForLinkage) {\n  if (!IsTypedefNameForLinkage)\n    return Found;\n\n  // If we found a typedef declaration that gives a name to some other\n  // declaration, then we want that inner declaration. Declarations from\n  // AST files are handled via ImportedTypedefNamesForLinkage.\n  if (Found->isFromASTFile())\n    return nullptr;\n\n  if (auto *TND = dyn_cast<TypedefNameDecl>(Found))\n    return TND->getAnonDeclWithTypedefName(/*AnyRedecl*/true);\n\n  return nullptr;\n}\n\n/// Find the declaration to use to populate the anonymous declaration table\n/// for the given lexical DeclContext. We only care about finding local\n/// definitions of the context; we'll merge imported ones as we go.\nDeclContext *\nASTDeclReader::getPrimaryDCForAnonymousDecl(DeclContext *LexicalDC) {\n  // For classes, we track the definition as we merge.\n  if (auto *RD = dyn_cast<CXXRecordDecl>(LexicalDC)) {\n    auto *DD = RD->getCanonicalDecl()->DefinitionData;\n    return DD ? DD->Definition : nullptr;\n  }\n\n  // For anything else, walk its merged redeclarations looking for a definition.\n  // Note that we can't just call getDefinition here because the redeclaration\n  // chain isn't wired up.\n  for (auto *D : merged_redecls(cast<Decl>(LexicalDC))) {\n    if (auto *FD = dyn_cast<FunctionDecl>(D))\n      if (FD->isThisDeclarationADefinition())\n        return FD;\n    if (auto *MD = dyn_cast<ObjCMethodDecl>(D))\n      if (MD->isThisDeclarationADefinition())\n        return MD;\n  }\n\n  // No merged definition yet.\n  return nullptr;\n}\n\nNamedDecl *ASTDeclReader::getAnonymousDeclForMerging(ASTReader &Reader,\n                                                     DeclContext *DC,\n                                                     unsigned Index) {\n  // If the lexical context has been merged, look into the now-canonical\n  // definition.\n  auto *CanonDC = cast<Decl>(DC)->getCanonicalDecl();\n\n  // If we've seen this before, return the canonical declaration.\n  auto &Previous = Reader.AnonymousDeclarationsForMerging[CanonDC];\n  if (Index < Previous.size() && Previous[Index])\n    return Previous[Index];\n\n  // If this is the first time, but we have parsed a declaration of the context,\n  // build the anonymous declaration list from the parsed declaration.\n  auto *PrimaryDC = getPrimaryDCForAnonymousDecl(DC);\n  if (PrimaryDC && !cast<Decl>(PrimaryDC)->isFromASTFile()) {\n    numberAnonymousDeclsWithin(PrimaryDC, [&](NamedDecl *ND, unsigned Number) {\n      if (Previous.size() == Number)\n        Previous.push_back(cast<NamedDecl>(ND->getCanonicalDecl()));\n      else\n        Previous[Number] = cast<NamedDecl>(ND->getCanonicalDecl());\n    });\n  }\n\n  return Index < Previous.size() ? Previous[Index] : nullptr;\n}\n\nvoid ASTDeclReader::setAnonymousDeclForMerging(ASTReader &Reader,\n                                               DeclContext *DC, unsigned Index,\n                                               NamedDecl *D) {\n  auto *CanonDC = cast<Decl>(DC)->getCanonicalDecl();\n\n  auto &Previous = Reader.AnonymousDeclarationsForMerging[CanonDC];\n  if (Index >= Previous.size())\n    Previous.resize(Index + 1);\n  if (!Previous[Index])\n    Previous[Index] = D;\n}\n\nASTDeclReader::FindExistingResult ASTDeclReader::findExisting(NamedDecl *D) {\n  DeclarationName Name = TypedefNameForLinkage ? TypedefNameForLinkage\n                                               : D->getDeclName();\n\n  if (!Name && !needsAnonymousDeclarationNumber(D)) {\n    // Don't bother trying to find unnamed declarations that are in\n    // unmergeable contexts.\n    FindExistingResult Result(Reader, D, /*Existing=*/nullptr,\n                              AnonymousDeclNumber, TypedefNameForLinkage);\n    Result.suppress();\n    return Result;\n  }\n\n  DeclContext *DC = D->getDeclContext()->getRedeclContext();\n  if (TypedefNameForLinkage) {\n    auto It = Reader.ImportedTypedefNamesForLinkage.find(\n        std::make_pair(DC, TypedefNameForLinkage));\n    if (It != Reader.ImportedTypedefNamesForLinkage.end())\n      if (isSameEntity(It->second, D))\n        return FindExistingResult(Reader, D, It->second, AnonymousDeclNumber,\n                                  TypedefNameForLinkage);\n    // Go on to check in other places in case an existing typedef name\n    // was not imported.\n  }\n\n  if (needsAnonymousDeclarationNumber(D)) {\n    // This is an anonymous declaration that we may need to merge. Look it up\n    // in its context by number.\n    if (auto *Existing = getAnonymousDeclForMerging(\n            Reader, D->getLexicalDeclContext(), AnonymousDeclNumber))\n      if (isSameEntity(Existing, D))\n        return FindExistingResult(Reader, D, Existing, AnonymousDeclNumber,\n                                  TypedefNameForLinkage);\n  } else if (DC->isTranslationUnit() &&\n             !Reader.getContext().getLangOpts().CPlusPlus) {\n    IdentifierResolver &IdResolver = Reader.getIdResolver();\n\n    // Temporarily consider the identifier to be up-to-date. We don't want to\n    // cause additional lookups here.\n    class UpToDateIdentifierRAII {\n      IdentifierInfo *II;\n      bool WasOutToDate = false;\n\n    public:\n      explicit UpToDateIdentifierRAII(IdentifierInfo *II) : II(II) {\n        if (II) {\n          WasOutToDate = II->isOutOfDate();\n          if (WasOutToDate)\n            II->setOutOfDate(false);\n        }\n      }\n\n      ~UpToDateIdentifierRAII() {\n        if (WasOutToDate)\n          II->setOutOfDate(true);\n      }\n    } UpToDate(Name.getAsIdentifierInfo());\n\n    for (IdentifierResolver::iterator I = IdResolver.begin(Name),\n                                   IEnd = IdResolver.end();\n         I != IEnd; ++I) {\n      if (NamedDecl *Existing = getDeclForMerging(*I, TypedefNameForLinkage))\n        if (isSameEntity(Existing, D))\n          return FindExistingResult(Reader, D, Existing, AnonymousDeclNumber,\n                                    TypedefNameForLinkage);\n    }\n  } else if (DeclContext *MergeDC = getPrimaryContextForMerging(Reader, DC)) {\n    DeclContext::lookup_result R = MergeDC->noload_lookup(Name);\n    for (DeclContext::lookup_iterator I = R.begin(), E = R.end(); I != E; ++I) {\n      if (NamedDecl *Existing = getDeclForMerging(*I, TypedefNameForLinkage))\n        if (isSameEntity(Existing, D))\n          return FindExistingResult(Reader, D, Existing, AnonymousDeclNumber,\n                                    TypedefNameForLinkage);\n    }\n  } else {\n    // Not in a mergeable context.\n    return FindExistingResult(Reader);\n  }\n\n  // If this declaration is from a merged context, make a note that we need to\n  // check that the canonical definition of that context contains the decl.\n  //\n  // FIXME: We should do something similar if we merge two definitions of the\n  // same template specialization into the same CXXRecordDecl.\n  auto MergedDCIt = Reader.MergedDeclContexts.find(D->getLexicalDeclContext());\n  if (MergedDCIt != Reader.MergedDeclContexts.end() &&\n      MergedDCIt->second == D->getDeclContext())\n    Reader.PendingOdrMergeChecks.push_back(D);\n\n  return FindExistingResult(Reader, D, /*Existing=*/nullptr,\n                            AnonymousDeclNumber, TypedefNameForLinkage);\n}\n\ntemplate<typename DeclT>\nDecl *ASTDeclReader::getMostRecentDeclImpl(Redeclarable<DeclT> *D) {\n  return D->RedeclLink.getLatestNotUpdated();\n}\n\nDecl *ASTDeclReader::getMostRecentDeclImpl(...) {\n  llvm_unreachable(\"getMostRecentDecl on non-redeclarable declaration\");\n}\n\nDecl *ASTDeclReader::getMostRecentDecl(Decl *D) {\n  assert(D);\n\n  switch (D->getKind()) {\n#define ABSTRACT_DECL(TYPE)\n#define DECL(TYPE, BASE)                               \\\n  case Decl::TYPE:                                     \\\n    return getMostRecentDeclImpl(cast<TYPE##Decl>(D));\n#include \"clang/AST/DeclNodes.inc\"\n  }\n  llvm_unreachable(\"unknown decl kind\");\n}\n\nDecl *ASTReader::getMostRecentExistingDecl(Decl *D) {\n  return ASTDeclReader::getMostRecentDecl(D->getCanonicalDecl());\n}\n\nvoid ASTDeclReader::mergeInheritableAttributes(ASTReader &Reader, Decl *D,\n                                               Decl *Previous) {\n  InheritableAttr *NewAttr = nullptr;\n  ASTContext &Context = Reader.getContext();\n  const auto *IA = Previous->getAttr<MSInheritanceAttr>();\n\n  if (IA && !D->hasAttr<MSInheritanceAttr>()) {\n    NewAttr = cast<InheritableAttr>(IA->clone(Context));\n    NewAttr->setInherited(true);\n    D->addAttr(NewAttr);\n  }\n}\n\ntemplate<typename DeclT>\nvoid ASTDeclReader::attachPreviousDeclImpl(ASTReader &Reader,\n                                           Redeclarable<DeclT> *D,\n                                           Decl *Previous, Decl *Canon) {\n  D->RedeclLink.setPrevious(cast<DeclT>(Previous));\n  D->First = cast<DeclT>(Previous)->First;\n}\n\nnamespace clang {\n\ntemplate<>\nvoid ASTDeclReader::attachPreviousDeclImpl(ASTReader &Reader,\n                                           Redeclarable<VarDecl> *D,\n                                           Decl *Previous, Decl *Canon) {\n  auto *VD = static_cast<VarDecl *>(D);\n  auto *PrevVD = cast<VarDecl>(Previous);\n  D->RedeclLink.setPrevious(PrevVD);\n  D->First = PrevVD->First;\n\n  // We should keep at most one definition on the chain.\n  // FIXME: Cache the definition once we've found it. Building a chain with\n  // N definitions currently takes O(N^2) time here.\n  if (VD->isThisDeclarationADefinition() == VarDecl::Definition) {\n    for (VarDecl *CurD = PrevVD; CurD; CurD = CurD->getPreviousDecl()) {\n      if (CurD->isThisDeclarationADefinition() == VarDecl::Definition) {\n        Reader.mergeDefinitionVisibility(CurD, VD);\n        VD->demoteThisDefinitionToDeclaration();\n        break;\n      }\n    }\n  }\n}\n\nstatic bool isUndeducedReturnType(QualType T) {\n  auto *DT = T->getContainedDeducedType();\n  return DT && !DT->isDeduced();\n}\n\ntemplate<>\nvoid ASTDeclReader::attachPreviousDeclImpl(ASTReader &Reader,\n                                           Redeclarable<FunctionDecl> *D,\n                                           Decl *Previous, Decl *Canon) {\n  auto *FD = static_cast<FunctionDecl *>(D);\n  auto *PrevFD = cast<FunctionDecl>(Previous);\n\n  FD->RedeclLink.setPrevious(PrevFD);\n  FD->First = PrevFD->First;\n\n  // If the previous declaration is an inline function declaration, then this\n  // declaration is too.\n  if (PrevFD->isInlined() != FD->isInlined()) {\n    // FIXME: [dcl.fct.spec]p4:\n    //   If a function with external linkage is declared inline in one\n    //   translation unit, it shall be declared inline in all translation\n    //   units in which it appears.\n    //\n    // Be careful of this case:\n    //\n    // module A:\n    //   template<typename T> struct X { void f(); };\n    //   template<typename T> inline void X<T>::f() {}\n    //\n    // module B instantiates the declaration of X<int>::f\n    // module C instantiates the definition of X<int>::f\n    //\n    // If module B and C are merged, we do not have a violation of this rule.\n    FD->setImplicitlyInline(true);\n  }\n\n  auto *FPT = FD->getType()->getAs<FunctionProtoType>();\n  auto *PrevFPT = PrevFD->getType()->getAs<FunctionProtoType>();\n  if (FPT && PrevFPT) {\n    // If we need to propagate an exception specification along the redecl\n    // chain, make a note of that so that we can do so later.\n    bool IsUnresolved = isUnresolvedExceptionSpec(FPT->getExceptionSpecType());\n    bool WasUnresolved =\n        isUnresolvedExceptionSpec(PrevFPT->getExceptionSpecType());\n    if (IsUnresolved != WasUnresolved)\n      Reader.PendingExceptionSpecUpdates.insert(\n          {Canon, IsUnresolved ? PrevFD : FD});\n\n    // If we need to propagate a deduced return type along the redecl chain,\n    // make a note of that so that we can do it later.\n    bool IsUndeduced = isUndeducedReturnType(FPT->getReturnType());\n    bool WasUndeduced = isUndeducedReturnType(PrevFPT->getReturnType());\n    if (IsUndeduced != WasUndeduced)\n      Reader.PendingDeducedTypeUpdates.insert(\n          {cast<FunctionDecl>(Canon),\n           (IsUndeduced ? PrevFPT : FPT)->getReturnType()});\n  }\n}\n\n} // namespace clang\n\nvoid ASTDeclReader::attachPreviousDeclImpl(ASTReader &Reader, ...) {\n  llvm_unreachable(\"attachPreviousDecl on non-redeclarable declaration\");\n}\n\n/// Inherit the default template argument from \\p From to \\p To. Returns\n/// \\c false if there is no default template for \\p From.\ntemplate <typename ParmDecl>\nstatic bool inheritDefaultTemplateArgument(ASTContext &Context, ParmDecl *From,\n                                           Decl *ToD) {\n  auto *To = cast<ParmDecl>(ToD);\n  if (!From->hasDefaultArgument())\n    return false;\n  To->setInheritedDefaultArgument(Context, From);\n  return true;\n}\n\nstatic void inheritDefaultTemplateArguments(ASTContext &Context,\n                                            TemplateDecl *From,\n                                            TemplateDecl *To) {\n  auto *FromTP = From->getTemplateParameters();\n  auto *ToTP = To->getTemplateParameters();\n  assert(FromTP->size() == ToTP->size() && \"merged mismatched templates?\");\n\n  for (unsigned I = 0, N = FromTP->size(); I != N; ++I) {\n    NamedDecl *FromParam = FromTP->getParam(I);\n    NamedDecl *ToParam = ToTP->getParam(I);\n\n    if (auto *FTTP = dyn_cast<TemplateTypeParmDecl>(FromParam))\n      inheritDefaultTemplateArgument(Context, FTTP, ToParam);\n    else if (auto *FNTTP = dyn_cast<NonTypeTemplateParmDecl>(FromParam))\n      inheritDefaultTemplateArgument(Context, FNTTP, ToParam);\n    else\n      inheritDefaultTemplateArgument(\n              Context, cast<TemplateTemplateParmDecl>(FromParam), ToParam);\n  }\n}\n\nvoid ASTDeclReader::attachPreviousDecl(ASTReader &Reader, Decl *D,\n                                       Decl *Previous, Decl *Canon) {\n  assert(D && Previous);\n\n  switch (D->getKind()) {\n#define ABSTRACT_DECL(TYPE)\n#define DECL(TYPE, BASE)                                                  \\\n  case Decl::TYPE:                                                        \\\n    attachPreviousDeclImpl(Reader, cast<TYPE##Decl>(D), Previous, Canon); \\\n    break;\n#include \"clang/AST/DeclNodes.inc\"\n  }\n\n  // If the declaration was visible in one module, a redeclaration of it in\n  // another module remains visible even if it wouldn't be visible by itself.\n  //\n  // FIXME: In this case, the declaration should only be visible if a module\n  //        that makes it visible has been imported.\n  D->IdentifierNamespace |=\n      Previous->IdentifierNamespace &\n      (Decl::IDNS_Ordinary | Decl::IDNS_Tag | Decl::IDNS_Type);\n\n  // If the declaration declares a template, it may inherit default arguments\n  // from the previous declaration.\n  if (auto *TD = dyn_cast<TemplateDecl>(D))\n    inheritDefaultTemplateArguments(Reader.getContext(),\n                                    cast<TemplateDecl>(Previous), TD);\n\n  // If any of the declaration in the chain contains an Inheritable attribute,\n  // it needs to be added to all the declarations in the redeclarable chain.\n  // FIXME: Only the logic of merging MSInheritableAttr is present, it should\n  // be extended for all inheritable attributes.\n  mergeInheritableAttributes(Reader, D, Previous);\n}\n\ntemplate<typename DeclT>\nvoid ASTDeclReader::attachLatestDeclImpl(Redeclarable<DeclT> *D, Decl *Latest) {\n  D->RedeclLink.setLatest(cast<DeclT>(Latest));\n}\n\nvoid ASTDeclReader::attachLatestDeclImpl(...) {\n  llvm_unreachable(\"attachLatestDecl on non-redeclarable declaration\");\n}\n\nvoid ASTDeclReader::attachLatestDecl(Decl *D, Decl *Latest) {\n  assert(D && Latest);\n\n  switch (D->getKind()) {\n#define ABSTRACT_DECL(TYPE)\n#define DECL(TYPE, BASE)                                  \\\n  case Decl::TYPE:                                        \\\n    attachLatestDeclImpl(cast<TYPE##Decl>(D), Latest); \\\n    break;\n#include \"clang/AST/DeclNodes.inc\"\n  }\n}\n\ntemplate<typename DeclT>\nvoid ASTDeclReader::markIncompleteDeclChainImpl(Redeclarable<DeclT> *D) {\n  D->RedeclLink.markIncomplete();\n}\n\nvoid ASTDeclReader::markIncompleteDeclChainImpl(...) {\n  llvm_unreachable(\"markIncompleteDeclChain on non-redeclarable declaration\");\n}\n\nvoid ASTReader::markIncompleteDeclChain(Decl *D) {\n  switch (D->getKind()) {\n#define ABSTRACT_DECL(TYPE)\n#define DECL(TYPE, BASE)                                             \\\n  case Decl::TYPE:                                                   \\\n    ASTDeclReader::markIncompleteDeclChainImpl(cast<TYPE##Decl>(D)); \\\n    break;\n#include \"clang/AST/DeclNodes.inc\"\n  }\n}\n\n/// Read the declaration at the given offset from the AST file.\nDecl *ASTReader::ReadDeclRecord(DeclID ID) {\n  unsigned Index = ID - NUM_PREDEF_DECL_IDS;\n  SourceLocation DeclLoc;\n  RecordLocation Loc = DeclCursorForID(ID, DeclLoc);\n  llvm::BitstreamCursor &DeclsCursor = Loc.F->DeclsCursor;\n  // Keep track of where we are in the stream, then jump back there\n  // after reading this declaration.\n  SavedStreamPosition SavedPosition(DeclsCursor);\n\n  ReadingKindTracker ReadingKind(Read_Decl, *this);\n\n  // Note that we are loading a declaration record.\n  Deserializing ADecl(this);\n\n  auto Fail = [](const char *what, llvm::Error &&Err) {\n    llvm::report_fatal_error(Twine(\"ASTReader::readDeclRecord failed \") + what +\n                             \": \" + toString(std::move(Err)));\n  };\n\n  if (llvm::Error JumpFailed = DeclsCursor.JumpToBit(Loc.Offset))\n    Fail(\"jumping\", std::move(JumpFailed));\n  ASTRecordReader Record(*this, *Loc.F);\n  ASTDeclReader Reader(*this, Record, Loc, ID, DeclLoc);\n  Expected<unsigned> MaybeCode = DeclsCursor.ReadCode();\n  if (!MaybeCode)\n    Fail(\"reading code\", MaybeCode.takeError());\n  unsigned Code = MaybeCode.get();\n\n  ASTContext &Context = getContext();\n  Decl *D = nullptr;\n  Expected<unsigned> MaybeDeclCode = Record.readRecord(DeclsCursor, Code);\n  if (!MaybeDeclCode)\n    llvm::report_fatal_error(\n        \"ASTReader::readDeclRecord failed reading decl code: \" +\n        toString(MaybeDeclCode.takeError()));\n  switch ((DeclCode)MaybeDeclCode.get()) {\n  case DECL_CONTEXT_LEXICAL:\n  case DECL_CONTEXT_VISIBLE:\n    llvm_unreachable(\"Record cannot be de-serialized with readDeclRecord\");\n  case DECL_TYPEDEF:\n    D = TypedefDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_TYPEALIAS:\n    D = TypeAliasDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_ENUM:\n    D = EnumDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_RECORD:\n    D = RecordDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_ENUM_CONSTANT:\n    D = EnumConstantDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_FUNCTION:\n    D = FunctionDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_LINKAGE_SPEC:\n    D = LinkageSpecDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_EXPORT:\n    D = ExportDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_LABEL:\n    D = LabelDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_NAMESPACE:\n    D = NamespaceDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_NAMESPACE_ALIAS:\n    D = NamespaceAliasDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_USING:\n    D = UsingDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_USING_PACK:\n    D = UsingPackDecl::CreateDeserialized(Context, ID, Record.readInt());\n    break;\n  case DECL_USING_SHADOW:\n    D = UsingShadowDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CONSTRUCTOR_USING_SHADOW:\n    D = ConstructorUsingShadowDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_USING_DIRECTIVE:\n    D = UsingDirectiveDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_UNRESOLVED_USING_VALUE:\n    D = UnresolvedUsingValueDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_UNRESOLVED_USING_TYPENAME:\n    D = UnresolvedUsingTypenameDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CXX_RECORD:\n    D = CXXRecordDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CXX_DEDUCTION_GUIDE:\n    D = CXXDeductionGuideDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CXX_METHOD:\n    D = CXXMethodDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CXX_CONSTRUCTOR:\n    D = CXXConstructorDecl::CreateDeserialized(Context, ID, Record.readInt());\n    break;\n  case DECL_CXX_DESTRUCTOR:\n    D = CXXDestructorDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CXX_CONVERSION:\n    D = CXXConversionDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_ACCESS_SPEC:\n    D = AccessSpecDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_FRIEND:\n    D = FriendDecl::CreateDeserialized(Context, ID, Record.readInt());\n    break;\n  case DECL_FRIEND_TEMPLATE:\n    D = FriendTemplateDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CLASS_TEMPLATE:\n    D = ClassTemplateDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CLASS_TEMPLATE_SPECIALIZATION:\n    D = ClassTemplateSpecializationDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CLASS_TEMPLATE_PARTIAL_SPECIALIZATION:\n    D = ClassTemplatePartialSpecializationDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_VAR_TEMPLATE:\n    D = VarTemplateDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_VAR_TEMPLATE_SPECIALIZATION:\n    D = VarTemplateSpecializationDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_VAR_TEMPLATE_PARTIAL_SPECIALIZATION:\n    D = VarTemplatePartialSpecializationDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CLASS_SCOPE_FUNCTION_SPECIALIZATION:\n    D = ClassScopeFunctionSpecializationDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_FUNCTION_TEMPLATE:\n    D = FunctionTemplateDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_TEMPLATE_TYPE_PARM: {\n    bool HasTypeConstraint = Record.readInt();\n    D = TemplateTypeParmDecl::CreateDeserialized(Context, ID,\n                                                 HasTypeConstraint);\n    break;\n  }\n  case DECL_NON_TYPE_TEMPLATE_PARM: {\n    bool HasTypeConstraint = Record.readInt();\n    D = NonTypeTemplateParmDecl::CreateDeserialized(Context, ID,\n                                                    HasTypeConstraint);\n    break;\n  }\n  case DECL_EXPANDED_NON_TYPE_TEMPLATE_PARM_PACK: {\n    bool HasTypeConstraint = Record.readInt();\n    D = NonTypeTemplateParmDecl::CreateDeserialized(Context, ID,\n                                                    Record.readInt(),\n                                                    HasTypeConstraint);\n    break;\n  }\n  case DECL_TEMPLATE_TEMPLATE_PARM:\n    D = TemplateTemplateParmDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_EXPANDED_TEMPLATE_TEMPLATE_PARM_PACK:\n    D = TemplateTemplateParmDecl::CreateDeserialized(Context, ID,\n                                                     Record.readInt());\n    break;\n  case DECL_TYPE_ALIAS_TEMPLATE:\n    D = TypeAliasTemplateDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CONCEPT:\n    D = ConceptDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_REQUIRES_EXPR_BODY:\n    D = RequiresExprBodyDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_STATIC_ASSERT:\n    D = StaticAssertDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_METHOD:\n    D = ObjCMethodDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_INTERFACE:\n    D = ObjCInterfaceDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_IVAR:\n    D = ObjCIvarDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_PROTOCOL:\n    D = ObjCProtocolDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_AT_DEFS_FIELD:\n    D = ObjCAtDefsFieldDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_CATEGORY:\n    D = ObjCCategoryDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_CATEGORY_IMPL:\n    D = ObjCCategoryImplDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_IMPLEMENTATION:\n    D = ObjCImplementationDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_COMPATIBLE_ALIAS:\n    D = ObjCCompatibleAliasDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_PROPERTY:\n    D = ObjCPropertyDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_PROPERTY_IMPL:\n    D = ObjCPropertyImplDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_FIELD:\n    D = FieldDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_INDIRECTFIELD:\n    D = IndirectFieldDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_VAR:\n    D = VarDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_IMPLICIT_PARAM:\n    D = ImplicitParamDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_PARM_VAR:\n    D = ParmVarDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_DECOMPOSITION:\n    D = DecompositionDecl::CreateDeserialized(Context, ID, Record.readInt());\n    break;\n  case DECL_BINDING:\n    D = BindingDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_FILE_SCOPE_ASM:\n    D = FileScopeAsmDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_BLOCK:\n    D = BlockDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_MS_PROPERTY:\n    D = MSPropertyDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_MS_GUID:\n    D = MSGuidDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_TEMPLATE_PARAM_OBJECT:\n    D = TemplateParamObjectDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CAPTURED:\n    D = CapturedDecl::CreateDeserialized(Context, ID, Record.readInt());\n    break;\n  case DECL_CXX_BASE_SPECIFIERS:\n    Error(\"attempt to read a C++ base-specifier record as a declaration\");\n    return nullptr;\n  case DECL_CXX_CTOR_INITIALIZERS:\n    Error(\"attempt to read a C++ ctor initializer record as a declaration\");\n    return nullptr;\n  case DECL_IMPORT:\n    // Note: last entry of the ImportDecl record is the number of stored source\n    // locations.\n    D = ImportDecl::CreateDeserialized(Context, ID, Record.back());\n    break;\n  case DECL_OMP_THREADPRIVATE: {\n    Record.skipInts(1);\n    unsigned NumChildren = Record.readInt();\n    Record.skipInts(1);\n    D = OMPThreadPrivateDecl::CreateDeserialized(Context, ID, NumChildren);\n    break;\n  }\n  case DECL_OMP_ALLOCATE: {\n    unsigned NumClauses = Record.readInt();\n    unsigned NumVars = Record.readInt();\n    Record.skipInts(1);\n    D = OMPAllocateDecl::CreateDeserialized(Context, ID, NumVars, NumClauses);\n    break;\n  }\n  case DECL_OMP_REQUIRES: {\n    unsigned NumClauses = Record.readInt();\n    Record.skipInts(2);\n    D = OMPRequiresDecl::CreateDeserialized(Context, ID, NumClauses);\n    break;\n  }\n  case DECL_OMP_DECLARE_REDUCTION:\n    D = OMPDeclareReductionDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OMP_DECLARE_MAPPER: {\n    unsigned NumClauses = Record.readInt();\n    Record.skipInts(2);\n    D = OMPDeclareMapperDecl::CreateDeserialized(Context, ID, NumClauses);\n    break;\n  }\n  case DECL_OMP_CAPTUREDEXPR:\n    D = OMPCapturedExprDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_PRAGMA_COMMENT:\n    D = PragmaCommentDecl::CreateDeserialized(Context, ID, Record.readInt());\n    break;\n  case DECL_PRAGMA_DETECT_MISMATCH:\n    D = PragmaDetectMismatchDecl::CreateDeserialized(Context, ID,\n                                                     Record.readInt());\n    break;\n  case DECL_EMPTY:\n    D = EmptyDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_LIFETIME_EXTENDED_TEMPORARY:\n    D = LifetimeExtendedTemporaryDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_TYPE_PARAM:\n    D = ObjCTypeParamDecl::CreateDeserialized(Context, ID);\n    break;\n  }\n\n  assert(D && \"Unknown declaration reading AST file\");\n  LoadedDecl(Index, D);\n  // Set the DeclContext before doing any deserialization, to make sure internal\n  // calls to Decl::getASTContext() by Decl's methods will find the\n  // TranslationUnitDecl without crashing.\n  D->setDeclContext(Context.getTranslationUnitDecl());\n  Reader.Visit(D);\n\n  // If this declaration is also a declaration context, get the\n  // offsets for its tables of lexical and visible declarations.\n  if (auto *DC = dyn_cast<DeclContext>(D)) {\n    std::pair<uint64_t, uint64_t> Offsets = Reader.VisitDeclContext(DC);\n    if (Offsets.first &&\n        ReadLexicalDeclContextStorage(*Loc.F, DeclsCursor, Offsets.first, DC))\n      return nullptr;\n    if (Offsets.second &&\n        ReadVisibleDeclContextStorage(*Loc.F, DeclsCursor, Offsets.second, ID))\n      return nullptr;\n  }\n  assert(Record.getIdx() == Record.size());\n\n  // Load any relevant update records.\n  PendingUpdateRecords.push_back(\n      PendingUpdateRecord(ID, D, /*JustLoaded=*/true));\n\n  // Load the categories after recursive loading is finished.\n  if (auto *Class = dyn_cast<ObjCInterfaceDecl>(D))\n    // If we already have a definition when deserializing the ObjCInterfaceDecl,\n    // we put the Decl in PendingDefinitions so we can pull the categories here.\n    if (Class->isThisDeclarationADefinition() ||\n        PendingDefinitions.count(Class))\n      loadObjCCategories(ID, Class);\n\n  // If we have deserialized a declaration that has a definition the\n  // AST consumer might need to know about, queue it.\n  // We don't pass it to the consumer immediately because we may be in recursive\n  // loading, and some declarations may still be initializing.\n  PotentiallyInterestingDecls.push_back(\n      InterestingDecl(D, Reader.hasPendingBody()));\n\n  return D;\n}\n\nvoid ASTReader::PassInterestingDeclsToConsumer() {\n  assert(Consumer);\n\n  if (PassingDeclsToConsumer)\n    return;\n\n  // Guard variable to avoid recursively redoing the process of passing\n  // decls to consumer.\n  SaveAndRestore<bool> GuardPassingDeclsToConsumer(PassingDeclsToConsumer,\n                                                   true);\n\n  // Ensure that we've loaded all potentially-interesting declarations\n  // that need to be eagerly loaded.\n  for (auto ID : EagerlyDeserializedDecls)\n    GetDecl(ID);\n  EagerlyDeserializedDecls.clear();\n\n  while (!PotentiallyInterestingDecls.empty()) {\n    InterestingDecl D = PotentiallyInterestingDecls.front();\n    PotentiallyInterestingDecls.pop_front();\n    if (isConsumerInterestedIn(getContext(), D.getDecl(), D.hasPendingBody()))\n      PassInterestingDeclToConsumer(D.getDecl());\n  }\n}\n\nvoid ASTReader::loadDeclUpdateRecords(PendingUpdateRecord &Record) {\n  // The declaration may have been modified by files later in the chain.\n  // If this is the case, read the record containing the updates from each file\n  // and pass it to ASTDeclReader to make the modifications.\n  serialization::GlobalDeclID ID = Record.ID;\n  Decl *D = Record.D;\n  ProcessingUpdatesRAIIObj ProcessingUpdates(*this);\n  DeclUpdateOffsetsMap::iterator UpdI = DeclUpdateOffsets.find(ID);\n\n  SmallVector<serialization::DeclID, 8> PendingLazySpecializationIDs;\n\n  if (UpdI != DeclUpdateOffsets.end()) {\n    auto UpdateOffsets = std::move(UpdI->second);\n    DeclUpdateOffsets.erase(UpdI);\n\n    // Check if this decl was interesting to the consumer. If we just loaded\n    // the declaration, then we know it was interesting and we skip the call\n    // to isConsumerInterestedIn because it is unsafe to call in the\n    // current ASTReader state.\n    bool WasInteresting =\n        Record.JustLoaded || isConsumerInterestedIn(getContext(), D, false);\n    for (auto &FileAndOffset : UpdateOffsets) {\n      ModuleFile *F = FileAndOffset.first;\n      uint64_t Offset = FileAndOffset.second;\n      llvm::BitstreamCursor &Cursor = F->DeclsCursor;\n      SavedStreamPosition SavedPosition(Cursor);\n      if (llvm::Error JumpFailed = Cursor.JumpToBit(Offset))\n        // FIXME don't do a fatal error.\n        llvm::report_fatal_error(\n            \"ASTReader::loadDeclUpdateRecords failed jumping: \" +\n            toString(std::move(JumpFailed)));\n      Expected<unsigned> MaybeCode = Cursor.ReadCode();\n      if (!MaybeCode)\n        llvm::report_fatal_error(\n            \"ASTReader::loadDeclUpdateRecords failed reading code: \" +\n            toString(MaybeCode.takeError()));\n      unsigned Code = MaybeCode.get();\n      ASTRecordReader Record(*this, *F);\n      if (Expected<unsigned> MaybeRecCode = Record.readRecord(Cursor, Code))\n        assert(MaybeRecCode.get() == DECL_UPDATES &&\n               \"Expected DECL_UPDATES record!\");\n      else\n        llvm::report_fatal_error(\n            \"ASTReader::loadDeclUpdateRecords failed reading rec code: \" +\n            toString(MaybeCode.takeError()));\n\n      ASTDeclReader Reader(*this, Record, RecordLocation(F, Offset), ID,\n                           SourceLocation());\n      Reader.UpdateDecl(D, PendingLazySpecializationIDs);\n\n      // We might have made this declaration interesting. If so, remember that\n      // we need to hand it off to the consumer.\n      if (!WasInteresting &&\n          isConsumerInterestedIn(getContext(), D, Reader.hasPendingBody())) {\n        PotentiallyInterestingDecls.push_back(\n            InterestingDecl(D, Reader.hasPendingBody()));\n        WasInteresting = true;\n      }\n    }\n  }\n  // Add the lazy specializations to the template.\n  assert((PendingLazySpecializationIDs.empty() || isa<ClassTemplateDecl>(D) ||\n          isa<FunctionTemplateDecl>(D) || isa<VarTemplateDecl>(D)) &&\n         \"Must not have pending specializations\");\n  if (auto *CTD = dyn_cast<ClassTemplateDecl>(D))\n    ASTDeclReader::AddLazySpecializations(CTD, PendingLazySpecializationIDs);\n  else if (auto *FTD = dyn_cast<FunctionTemplateDecl>(D))\n    ASTDeclReader::AddLazySpecializations(FTD, PendingLazySpecializationIDs);\n  else if (auto *VTD = dyn_cast<VarTemplateDecl>(D))\n    ASTDeclReader::AddLazySpecializations(VTD, PendingLazySpecializationIDs);\n  PendingLazySpecializationIDs.clear();\n\n  // Load the pending visible updates for this decl context, if it has any.\n  auto I = PendingVisibleUpdates.find(ID);\n  if (I != PendingVisibleUpdates.end()) {\n    auto VisibleUpdates = std::move(I->second);\n    PendingVisibleUpdates.erase(I);\n\n    auto *DC = cast<DeclContext>(D)->getPrimaryContext();\n    for (const auto &Update : VisibleUpdates)\n      Lookups[DC].Table.add(\n          Update.Mod, Update.Data,\n          reader::ASTDeclContextNameLookupTrait(*this, *Update.Mod));\n    DC->setHasExternalVisibleStorage(true);\n  }\n}\n\nvoid ASTReader::loadPendingDeclChain(Decl *FirstLocal, uint64_t LocalOffset) {\n  // Attach FirstLocal to the end of the decl chain.\n  Decl *CanonDecl = FirstLocal->getCanonicalDecl();\n  if (FirstLocal != CanonDecl) {\n    Decl *PrevMostRecent = ASTDeclReader::getMostRecentDecl(CanonDecl);\n    ASTDeclReader::attachPreviousDecl(\n        *this, FirstLocal, PrevMostRecent ? PrevMostRecent : CanonDecl,\n        CanonDecl);\n  }\n\n  if (!LocalOffset) {\n    ASTDeclReader::attachLatestDecl(CanonDecl, FirstLocal);\n    return;\n  }\n\n  // Load the list of other redeclarations from this module file.\n  ModuleFile *M = getOwningModuleFile(FirstLocal);\n  assert(M && \"imported decl from no module file\");\n\n  llvm::BitstreamCursor &Cursor = M->DeclsCursor;\n  SavedStreamPosition SavedPosition(Cursor);\n  if (llvm::Error JumpFailed = Cursor.JumpToBit(LocalOffset))\n    llvm::report_fatal_error(\n        \"ASTReader::loadPendingDeclChain failed jumping: \" +\n        toString(std::move(JumpFailed)));\n\n  RecordData Record;\n  Expected<unsigned> MaybeCode = Cursor.ReadCode();\n  if (!MaybeCode)\n    llvm::report_fatal_error(\n        \"ASTReader::loadPendingDeclChain failed reading code: \" +\n        toString(MaybeCode.takeError()));\n  unsigned Code = MaybeCode.get();\n  if (Expected<unsigned> MaybeRecCode = Cursor.readRecord(Code, Record))\n    assert(MaybeRecCode.get() == LOCAL_REDECLARATIONS &&\n           \"expected LOCAL_REDECLARATIONS record!\");\n  else\n    llvm::report_fatal_error(\n        \"ASTReader::loadPendingDeclChain failed reading rec code: \" +\n        toString(MaybeCode.takeError()));\n\n  // FIXME: We have several different dispatches on decl kind here; maybe\n  // we should instead generate one loop per kind and dispatch up-front?\n  Decl *MostRecent = FirstLocal;\n  for (unsigned I = 0, N = Record.size(); I != N; ++I) {\n    auto *D = GetLocalDecl(*M, Record[N - I - 1]);\n    ASTDeclReader::attachPreviousDecl(*this, D, MostRecent, CanonDecl);\n    MostRecent = D;\n  }\n  ASTDeclReader::attachLatestDecl(CanonDecl, MostRecent);\n}\n\nnamespace {\n\n  /// Given an ObjC interface, goes through the modules and links to the\n  /// interface all the categories for it.\n  class ObjCCategoriesVisitor {\n    ASTReader &Reader;\n    ObjCInterfaceDecl *Interface;\n    llvm::SmallPtrSetImpl<ObjCCategoryDecl *> &Deserialized;\n    ObjCCategoryDecl *Tail = nullptr;\n    llvm::DenseMap<DeclarationName, ObjCCategoryDecl *> NameCategoryMap;\n    serialization::GlobalDeclID InterfaceID;\n    unsigned PreviousGeneration;\n\n    void add(ObjCCategoryDecl *Cat) {\n      // Only process each category once.\n      if (!Deserialized.erase(Cat))\n        return;\n\n      // Check for duplicate categories.\n      if (Cat->getDeclName()) {\n        ObjCCategoryDecl *&Existing = NameCategoryMap[Cat->getDeclName()];\n        if (Existing &&\n            Reader.getOwningModuleFile(Existing)\n                                          != Reader.getOwningModuleFile(Cat)) {\n          // FIXME: We should not warn for duplicates in diamond:\n          //\n          //   MT     //\n          //  /  \\    //\n          // ML  MR   //\n          //  \\  /    //\n          //   MB     //\n          //\n          // If there are duplicates in ML/MR, there will be warning when\n          // creating MB *and* when importing MB. We should not warn when\n          // importing.\n          Reader.Diag(Cat->getLocation(), diag::warn_dup_category_def)\n            << Interface->getDeclName() << Cat->getDeclName();\n          Reader.Diag(Existing->getLocation(), diag::note_previous_definition);\n        } else if (!Existing) {\n          // Record this category.\n          Existing = Cat;\n        }\n      }\n\n      // Add this category to the end of the chain.\n      if (Tail)\n        ASTDeclReader::setNextObjCCategory(Tail, Cat);\n      else\n        Interface->setCategoryListRaw(Cat);\n      Tail = Cat;\n    }\n\n  public:\n    ObjCCategoriesVisitor(ASTReader &Reader,\n                          ObjCInterfaceDecl *Interface,\n                          llvm::SmallPtrSetImpl<ObjCCategoryDecl *> &Deserialized,\n                          serialization::GlobalDeclID InterfaceID,\n                          unsigned PreviousGeneration)\n        : Reader(Reader), Interface(Interface), Deserialized(Deserialized),\n          InterfaceID(InterfaceID), PreviousGeneration(PreviousGeneration) {\n      // Populate the name -> category map with the set of known categories.\n      for (auto *Cat : Interface->known_categories()) {\n        if (Cat->getDeclName())\n          NameCategoryMap[Cat->getDeclName()] = Cat;\n\n        // Keep track of the tail of the category list.\n        Tail = Cat;\n      }\n    }\n\n    bool operator()(ModuleFile &M) {\n      // If we've loaded all of the category information we care about from\n      // this module file, we're done.\n      if (M.Generation <= PreviousGeneration)\n        return true;\n\n      // Map global ID of the definition down to the local ID used in this\n      // module file. If there is no such mapping, we'll find nothing here\n      // (or in any module it imports).\n      DeclID LocalID = Reader.mapGlobalIDToModuleFileGlobalID(M, InterfaceID);\n      if (!LocalID)\n        return true;\n\n      // Perform a binary search to find the local redeclarations for this\n      // declaration (if any).\n      const ObjCCategoriesInfo Compare = { LocalID, 0 };\n      const ObjCCategoriesInfo *Result\n        = std::lower_bound(M.ObjCCategoriesMap,\n                           M.ObjCCategoriesMap + M.LocalNumObjCCategoriesInMap,\n                           Compare);\n      if (Result == M.ObjCCategoriesMap + M.LocalNumObjCCategoriesInMap ||\n          Result->DefinitionID != LocalID) {\n        // We didn't find anything. If the class definition is in this module\n        // file, then the module files it depends on cannot have any categories,\n        // so suppress further lookup.\n        return Reader.isDeclIDFromModule(InterfaceID, M);\n      }\n\n      // We found something. Dig out all of the categories.\n      unsigned Offset = Result->Offset;\n      unsigned N = M.ObjCCategories[Offset];\n      M.ObjCCategories[Offset++] = 0; // Don't try to deserialize again\n      for (unsigned I = 0; I != N; ++I)\n        add(cast_or_null<ObjCCategoryDecl>(\n              Reader.GetLocalDecl(M, M.ObjCCategories[Offset++])));\n      return true;\n    }\n  };\n\n} // namespace\n\nvoid ASTReader::loadObjCCategories(serialization::GlobalDeclID ID,\n                                   ObjCInterfaceDecl *D,\n                                   unsigned PreviousGeneration) {\n  ObjCCategoriesVisitor Visitor(*this, D, CategoriesDeserialized, ID,\n                                PreviousGeneration);\n  ModuleMgr.visit(Visitor);\n}\n\ntemplate<typename DeclT, typename Fn>\nstatic void forAllLaterRedecls(DeclT *D, Fn F) {\n  F(D);\n\n  // Check whether we've already merged D into its redeclaration chain.\n  // MostRecent may or may not be nullptr if D has not been merged. If\n  // not, walk the merged redecl chain and see if it's there.\n  auto *MostRecent = D->getMostRecentDecl();\n  bool Found = false;\n  for (auto *Redecl = MostRecent; Redecl && !Found;\n       Redecl = Redecl->getPreviousDecl())\n    Found = (Redecl == D);\n\n  // If this declaration is merged, apply the functor to all later decls.\n  if (Found) {\n    for (auto *Redecl = MostRecent; Redecl != D;\n         Redecl = Redecl->getPreviousDecl())\n      F(Redecl);\n  }\n}\n\nvoid ASTDeclReader::UpdateDecl(Decl *D,\n   llvm::SmallVectorImpl<serialization::DeclID> &PendingLazySpecializationIDs) {\n  while (Record.getIdx() < Record.size()) {\n    switch ((DeclUpdateKind)Record.readInt()) {\n    case UPD_CXX_ADDED_IMPLICIT_MEMBER: {\n      auto *RD = cast<CXXRecordDecl>(D);\n      // FIXME: If we also have an update record for instantiating the\n      // definition of D, we need that to happen before we get here.\n      Decl *MD = Record.readDecl();\n      assert(MD && \"couldn't read decl from update record\");\n      // FIXME: We should call addHiddenDecl instead, to add the member\n      // to its DeclContext.\n      RD->addedMember(MD);\n      break;\n    }\n\n    case UPD_CXX_ADDED_TEMPLATE_SPECIALIZATION:\n      // It will be added to the template's lazy specialization set.\n      PendingLazySpecializationIDs.push_back(readDeclID());\n      break;\n\n    case UPD_CXX_ADDED_ANONYMOUS_NAMESPACE: {\n      auto *Anon = readDeclAs<NamespaceDecl>();\n\n      // Each module has its own anonymous namespace, which is disjoint from\n      // any other module's anonymous namespaces, so don't attach the anonymous\n      // namespace at all.\n      if (!Record.isModule()) {\n        if (auto *TU = dyn_cast<TranslationUnitDecl>(D))\n          TU->setAnonymousNamespace(Anon);\n        else\n          cast<NamespaceDecl>(D)->setAnonymousNamespace(Anon);\n      }\n      break;\n    }\n\n    case UPD_CXX_ADDED_VAR_DEFINITION: {\n      auto *VD = cast<VarDecl>(D);\n      VD->NonParmVarDeclBits.IsInline = Record.readInt();\n      VD->NonParmVarDeclBits.IsInlineSpecified = Record.readInt();\n      uint64_t Val = Record.readInt();\n      if (Val && !VD->getInit()) {\n        VD->setInit(Record.readExpr());\n        if (Val != 1) {\n          EvaluatedStmt *Eval = VD->ensureEvaluatedStmt();\n          Eval->HasConstantInitialization = (Val & 2) != 0;\n          Eval->HasConstantDestruction = (Val & 4) != 0;\n        }\n      }\n      break;\n    }\n\n    case UPD_CXX_POINT_OF_INSTANTIATION: {\n      SourceLocation POI = Record.readSourceLocation();\n      if (auto *VTSD = dyn_cast<VarTemplateSpecializationDecl>(D)) {\n        VTSD->setPointOfInstantiation(POI);\n      } else if (auto *VD = dyn_cast<VarDecl>(D)) {\n        VD->getMemberSpecializationInfo()->setPointOfInstantiation(POI);\n      } else {\n        auto *FD = cast<FunctionDecl>(D);\n        if (auto *FTSInfo = FD->TemplateOrSpecialization\n                    .dyn_cast<FunctionTemplateSpecializationInfo *>())\n          FTSInfo->setPointOfInstantiation(POI);\n        else\n          FD->TemplateOrSpecialization.get<MemberSpecializationInfo *>()\n              ->setPointOfInstantiation(POI);\n      }\n      break;\n    }\n\n    case UPD_CXX_INSTANTIATED_DEFAULT_ARGUMENT: {\n      auto *Param = cast<ParmVarDecl>(D);\n\n      // We have to read the default argument regardless of whether we use it\n      // so that hypothetical further update records aren't messed up.\n      // TODO: Add a function to skip over the next expr record.\n      auto *DefaultArg = Record.readExpr();\n\n      // Only apply the update if the parameter still has an uninstantiated\n      // default argument.\n      if (Param->hasUninstantiatedDefaultArg())\n        Param->setDefaultArg(DefaultArg);\n      break;\n    }\n\n    case UPD_CXX_INSTANTIATED_DEFAULT_MEMBER_INITIALIZER: {\n      auto *FD = cast<FieldDecl>(D);\n      auto *DefaultInit = Record.readExpr();\n\n      // Only apply the update if the field still has an uninstantiated\n      // default member initializer.\n      if (FD->hasInClassInitializer() && !FD->getInClassInitializer()) {\n        if (DefaultInit)\n          FD->setInClassInitializer(DefaultInit);\n        else\n          // Instantiation failed. We can get here if we serialized an AST for\n          // an invalid program.\n          FD->removeInClassInitializer();\n      }\n      break;\n    }\n\n    case UPD_CXX_ADDED_FUNCTION_DEFINITION: {\n      auto *FD = cast<FunctionDecl>(D);\n      if (Reader.PendingBodies[FD]) {\n        // FIXME: Maybe check for ODR violations.\n        // It's safe to stop now because this update record is always last.\n        return;\n      }\n\n      if (Record.readInt()) {\n        // Maintain AST consistency: any later redeclarations of this function\n        // are inline if this one is. (We might have merged another declaration\n        // into this one.)\n        forAllLaterRedecls(FD, [](FunctionDecl *FD) {\n          FD->setImplicitlyInline();\n        });\n      }\n      FD->setInnerLocStart(readSourceLocation());\n      ReadFunctionDefinition(FD);\n      assert(Record.getIdx() == Record.size() && \"lazy body must be last\");\n      break;\n    }\n\n    case UPD_CXX_INSTANTIATED_CLASS_DEFINITION: {\n      auto *RD = cast<CXXRecordDecl>(D);\n      auto *OldDD = RD->getCanonicalDecl()->DefinitionData;\n      bool HadRealDefinition =\n          OldDD && (OldDD->Definition != RD ||\n                    !Reader.PendingFakeDefinitionData.count(OldDD));\n      RD->setParamDestroyedInCallee(Record.readInt());\n      RD->setArgPassingRestrictions(\n          (RecordDecl::ArgPassingKind)Record.readInt());\n      ReadCXXRecordDefinition(RD, /*Update*/true);\n\n      // Visible update is handled separately.\n      uint64_t LexicalOffset = ReadLocalOffset();\n      if (!HadRealDefinition && LexicalOffset) {\n        Record.readLexicalDeclContextStorage(LexicalOffset, RD);\n        Reader.PendingFakeDefinitionData.erase(OldDD);\n      }\n\n      auto TSK = (TemplateSpecializationKind)Record.readInt();\n      SourceLocation POI = readSourceLocation();\n      if (MemberSpecializationInfo *MSInfo =\n              RD->getMemberSpecializationInfo()) {\n        MSInfo->setTemplateSpecializationKind(TSK);\n        MSInfo->setPointOfInstantiation(POI);\n      } else {\n        auto *Spec = cast<ClassTemplateSpecializationDecl>(RD);\n        Spec->setTemplateSpecializationKind(TSK);\n        Spec->setPointOfInstantiation(POI);\n\n        if (Record.readInt()) {\n          auto *PartialSpec =\n              readDeclAs<ClassTemplatePartialSpecializationDecl>();\n          SmallVector<TemplateArgument, 8> TemplArgs;\n          Record.readTemplateArgumentList(TemplArgs);\n          auto *TemplArgList = TemplateArgumentList::CreateCopy(\n              Reader.getContext(), TemplArgs);\n\n          // FIXME: If we already have a partial specialization set,\n          // check that it matches.\n          if (!Spec->getSpecializedTemplateOrPartial()\n                   .is<ClassTemplatePartialSpecializationDecl *>())\n            Spec->setInstantiationOf(PartialSpec, TemplArgList);\n        }\n      }\n\n      RD->setTagKind((TagTypeKind)Record.readInt());\n      RD->setLocation(readSourceLocation());\n      RD->setLocStart(readSourceLocation());\n      RD->setBraceRange(readSourceRange());\n\n      if (Record.readInt()) {\n        AttrVec Attrs;\n        Record.readAttributes(Attrs);\n        // If the declaration already has attributes, we assume that some other\n        // AST file already loaded them.\n        if (!D->hasAttrs())\n          D->setAttrsImpl(Attrs, Reader.getContext());\n      }\n      break;\n    }\n\n    case UPD_CXX_RESOLVED_DTOR_DELETE: {\n      // Set the 'operator delete' directly to avoid emitting another update\n      // record.\n      auto *Del = readDeclAs<FunctionDecl>();\n      auto *First = cast<CXXDestructorDecl>(D->getCanonicalDecl());\n      auto *ThisArg = Record.readExpr();\n      // FIXME: Check consistency if we have an old and new operator delete.\n      if (!First->OperatorDelete) {\n        First->OperatorDelete = Del;\n        First->OperatorDeleteThisArg = ThisArg;\n      }\n      break;\n    }\n\n    case UPD_CXX_RESOLVED_EXCEPTION_SPEC: {\n      SmallVector<QualType, 8> ExceptionStorage;\n      auto ESI = Record.readExceptionSpecInfo(ExceptionStorage);\n\n      // Update this declaration's exception specification, if needed.\n      auto *FD = cast<FunctionDecl>(D);\n      auto *FPT = FD->getType()->castAs<FunctionProtoType>();\n      // FIXME: If the exception specification is already present, check that it\n      // matches.\n      if (isUnresolvedExceptionSpec(FPT->getExceptionSpecType())) {\n        FD->setType(Reader.getContext().getFunctionType(\n            FPT->getReturnType(), FPT->getParamTypes(),\n            FPT->getExtProtoInfo().withExceptionSpec(ESI)));\n\n        // When we get to the end of deserializing, see if there are other decls\n        // that we need to propagate this exception specification onto.\n        Reader.PendingExceptionSpecUpdates.insert(\n            std::make_pair(FD->getCanonicalDecl(), FD));\n      }\n      break;\n    }\n\n    case UPD_CXX_DEDUCED_RETURN_TYPE: {\n      auto *FD = cast<FunctionDecl>(D);\n      QualType DeducedResultType = Record.readType();\n      Reader.PendingDeducedTypeUpdates.insert(\n          {FD->getCanonicalDecl(), DeducedResultType});\n      break;\n    }\n\n    case UPD_DECL_MARKED_USED:\n      // Maintain AST consistency: any later redeclarations are used too.\n      D->markUsed(Reader.getContext());\n      break;\n\n    case UPD_MANGLING_NUMBER:\n      Reader.getContext().setManglingNumber(cast<NamedDecl>(D),\n                                            Record.readInt());\n      break;\n\n    case UPD_STATIC_LOCAL_NUMBER:\n      Reader.getContext().setStaticLocalNumber(cast<VarDecl>(D),\n                                               Record.readInt());\n      break;\n\n    case UPD_DECL_MARKED_OPENMP_THREADPRIVATE:\n      D->addAttr(OMPThreadPrivateDeclAttr::CreateImplicit(\n          Reader.getContext(), readSourceRange(),\n          AttributeCommonInfo::AS_Pragma));\n      break;\n\n    case UPD_DECL_MARKED_OPENMP_ALLOCATE: {\n      auto AllocatorKind =\n          static_cast<OMPAllocateDeclAttr::AllocatorTypeTy>(Record.readInt());\n      Expr *Allocator = Record.readExpr();\n      SourceRange SR = readSourceRange();\n      D->addAttr(OMPAllocateDeclAttr::CreateImplicit(\n          Reader.getContext(), AllocatorKind, Allocator, SR,\n          AttributeCommonInfo::AS_Pragma));\n      break;\n    }\n\n    case UPD_DECL_EXPORTED: {\n      unsigned SubmoduleID = readSubmoduleID();\n      auto *Exported = cast<NamedDecl>(D);\n      Module *Owner = SubmoduleID ? Reader.getSubmodule(SubmoduleID) : nullptr;\n      Reader.getContext().mergeDefinitionIntoModule(Exported, Owner);\n      Reader.PendingMergedDefinitionsToDeduplicate.insert(Exported);\n      break;\n    }\n\n    case UPD_DECL_MARKED_OPENMP_DECLARETARGET: {\n      auto MapType = Record.readEnum<OMPDeclareTargetDeclAttr::MapTypeTy>();\n      auto DevType = Record.readEnum<OMPDeclareTargetDeclAttr::DevTypeTy>();\n      unsigned Level = Record.readInt();\n      D->addAttr(OMPDeclareTargetDeclAttr::CreateImplicit(\n          Reader.getContext(), MapType, DevType, Level, readSourceRange(),\n          AttributeCommonInfo::AS_Pragma));\n      break;\n    }\n\n    case UPD_ADDED_ATTR_TO_RECORD:\n      AttrVec Attrs;\n      Record.readAttributes(Attrs);\n      assert(Attrs.size() == 1);\n      D->addAttr(Attrs[0]);\n      break;\n    }\n  }\n}\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTReader.h", "content": "//===- ASTReader.h - AST File Reader ----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the ASTReader class, which reads AST files.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SERIALIZATION_ASTREADER_H\n#define LLVM_CLANG_SERIALIZATION_ASTREADER_H\n\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/DiagnosticOptions.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/OpenCLOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Version.h\"\n#include \"clang/Lex/ExternalPreprocessorSource.h\"\n#include \"clang/Lex/HeaderSearch.h\"\n#include \"clang/Lex/PreprocessingRecord.h\"\n#include \"clang/Lex/PreprocessorOptions.h\"\n#include \"clang/Sema/ExternalSemaSource.h\"\n#include \"clang/Sema/IdentifierResolver.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"clang/Serialization/ASTBitCodes.h\"\n#include \"clang/Serialization/ContinuousRangeMap.h\"\n#include \"clang/Serialization/ModuleFile.h\"\n#include \"clang/Serialization/ModuleFileExtension.h\"\n#include \"clang/Serialization/ModuleManager.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Bitstream/BitstreamReader.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/Timer.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <ctime>\n#include <deque>\n#include <memory>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass ASTConsumer;\nclass ASTContext;\nclass ASTDeserializationListener;\nclass ASTReader;\nclass ASTRecordReader;\nclass CXXTemporary;\nclass Decl;\nclass DeclarationName;\nclass DeclaratorDecl;\nclass DeclContext;\nclass EnumDecl;\nclass Expr;\nclass FieldDecl;\nclass FileEntry;\nclass FileManager;\nclass FileSystemOptions;\nclass FunctionDecl;\nclass GlobalModuleIndex;\nstruct HeaderFileInfo;\nclass HeaderSearchOptions;\nclass LangOptions;\nclass LazyASTUnresolvedSet;\nclass MacroInfo;\nclass InMemoryModuleCache;\nclass NamedDecl;\nclass NamespaceDecl;\nclass ObjCCategoryDecl;\nclass ObjCInterfaceDecl;\nclass PCHContainerReader;\nclass Preprocessor;\nclass PreprocessorOptions;\nstruct QualifierInfo;\nclass Sema;\nclass SourceManager;\nclass Stmt;\nclass SwitchCase;\nclass TargetOptions;\nclass Token;\nclass TypedefNameDecl;\nclass ValueDecl;\nclass VarDecl;\n\n/// Abstract interface for callback invocations by the ASTReader.\n///\n/// While reading an AST file, the ASTReader will call the methods of the\n/// listener to pass on specific information. Some of the listener methods can\n/// return true to indicate to the ASTReader that the information (and\n/// consequently the AST file) is invalid.\nclass ASTReaderListener {\npublic:\n  virtual ~ASTReaderListener();\n\n  /// Receives the full Clang version information.\n  ///\n  /// \\returns true to indicate that the version is invalid. Subclasses should\n  /// generally defer to this implementation.\n  virtual bool ReadFullVersionInformation(StringRef FullVersion) {\n    return FullVersion != getClangFullRepositoryVersion();\n  }\n\n  virtual void ReadModuleName(StringRef ModuleName) {}\n  virtual void ReadModuleMapFile(StringRef ModuleMapPath) {}\n\n  /// Receives the language options.\n  ///\n  /// \\returns true to indicate the options are invalid or false otherwise.\n  virtual bool ReadLanguageOptions(const LangOptions &LangOpts,\n                                   bool Complain,\n                                   bool AllowCompatibleDifferences) {\n    return false;\n  }\n\n  /// Receives the target options.\n  ///\n  /// \\returns true to indicate the target options are invalid, or false\n  /// otherwise.\n  virtual bool ReadTargetOptions(const TargetOptions &TargetOpts, bool Complain,\n                                 bool AllowCompatibleDifferences) {\n    return false;\n  }\n\n  /// Receives the diagnostic options.\n  ///\n  /// \\returns true to indicate the diagnostic options are invalid, or false\n  /// otherwise.\n  virtual bool\n  ReadDiagnosticOptions(IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts,\n                        bool Complain) {\n    return false;\n  }\n\n  /// Receives the file system options.\n  ///\n  /// \\returns true to indicate the file system options are invalid, or false\n  /// otherwise.\n  virtual bool ReadFileSystemOptions(const FileSystemOptions &FSOpts,\n                                     bool Complain) {\n    return false;\n  }\n\n  /// Receives the header search options.\n  ///\n  /// \\returns true to indicate the header search options are invalid, or false\n  /// otherwise.\n  virtual bool ReadHeaderSearchOptions(const HeaderSearchOptions &HSOpts,\n                                       StringRef SpecificModuleCachePath,\n                                       bool Complain) {\n    return false;\n  }\n\n  /// Receives the preprocessor options.\n  ///\n  /// \\param SuggestedPredefines Can be filled in with the set of predefines\n  /// that are suggested by the preprocessor options. Typically only used when\n  /// loading a precompiled header.\n  ///\n  /// \\returns true to indicate the preprocessor options are invalid, or false\n  /// otherwise.\n  virtual bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts,\n                                       bool Complain,\n                                       std::string &SuggestedPredefines) {\n    return false;\n  }\n\n  /// Receives __COUNTER__ value.\n  virtual void ReadCounter(const serialization::ModuleFile &M,\n                           unsigned Value) {}\n\n  /// This is called for each AST file loaded.\n  virtual void visitModuleFile(StringRef Filename,\n                               serialization::ModuleKind Kind) {}\n\n  /// Returns true if this \\c ASTReaderListener wants to receive the\n  /// input files of the AST file via \\c visitInputFile, false otherwise.\n  virtual bool needsInputFileVisitation() { return false; }\n\n  /// Returns true if this \\c ASTReaderListener wants to receive the\n  /// system input files of the AST file via \\c visitInputFile, false otherwise.\n  virtual bool needsSystemInputFileVisitation() { return false; }\n\n  /// if \\c needsInputFileVisitation returns true, this is called for\n  /// each non-system input file of the AST File. If\n  /// \\c needsSystemInputFileVisitation is true, then it is called for all\n  /// system input files as well.\n  ///\n  /// \\returns true to continue receiving the next input file, false to stop.\n  virtual bool visitInputFile(StringRef Filename, bool isSystem,\n                              bool isOverridden, bool isExplicitModule) {\n    return true;\n  }\n\n  /// Returns true if this \\c ASTReaderListener wants to receive the\n  /// imports of the AST file via \\c visitImport, false otherwise.\n  virtual bool needsImportVisitation() const { return false; }\n\n  /// If needsImportVisitation returns \\c true, this is called for each\n  /// AST file imported by this AST file.\n  virtual void visitImport(StringRef ModuleName, StringRef Filename) {}\n\n  /// Indicates that a particular module file extension has been read.\n  virtual void readModuleFileExtension(\n                 const ModuleFileExtensionMetadata &Metadata) {}\n};\n\n/// Simple wrapper class for chaining listeners.\nclass ChainedASTReaderListener : public ASTReaderListener {\n  std::unique_ptr<ASTReaderListener> First;\n  std::unique_ptr<ASTReaderListener> Second;\n\npublic:\n  /// Takes ownership of \\p First and \\p Second.\n  ChainedASTReaderListener(std::unique_ptr<ASTReaderListener> First,\n                           std::unique_ptr<ASTReaderListener> Second)\n      : First(std::move(First)), Second(std::move(Second)) {}\n\n  std::unique_ptr<ASTReaderListener> takeFirst() { return std::move(First); }\n  std::unique_ptr<ASTReaderListener> takeSecond() { return std::move(Second); }\n\n  bool ReadFullVersionInformation(StringRef FullVersion) override;\n  void ReadModuleName(StringRef ModuleName) override;\n  void ReadModuleMapFile(StringRef ModuleMapPath) override;\n  bool ReadLanguageOptions(const LangOptions &LangOpts, bool Complain,\n                           bool AllowCompatibleDifferences) override;\n  bool ReadTargetOptions(const TargetOptions &TargetOpts, bool Complain,\n                         bool AllowCompatibleDifferences) override;\n  bool ReadDiagnosticOptions(IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts,\n                             bool Complain) override;\n  bool ReadFileSystemOptions(const FileSystemOptions &FSOpts,\n                             bool Complain) override;\n\n  bool ReadHeaderSearchOptions(const HeaderSearchOptions &HSOpts,\n                               StringRef SpecificModuleCachePath,\n                               bool Complain) override;\n  bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts,\n                               bool Complain,\n                               std::string &SuggestedPredefines) override;\n\n  void ReadCounter(const serialization::ModuleFile &M, unsigned Value) override;\n  bool needsInputFileVisitation() override;\n  bool needsSystemInputFileVisitation() override;\n  void visitModuleFile(StringRef Filename,\n                       serialization::ModuleKind Kind) override;\n  bool visitInputFile(StringRef Filename, bool isSystem,\n                      bool isOverridden, bool isExplicitModule) override;\n  void readModuleFileExtension(\n         const ModuleFileExtensionMetadata &Metadata) override;\n};\n\n/// ASTReaderListener implementation to validate the information of\n/// the PCH file against an initialized Preprocessor.\nclass PCHValidator : public ASTReaderListener {\n  Preprocessor &PP;\n  ASTReader &Reader;\n\npublic:\n  PCHValidator(Preprocessor &PP, ASTReader &Reader)\n      : PP(PP), Reader(Reader) {}\n\n  bool ReadLanguageOptions(const LangOptions &LangOpts, bool Complain,\n                           bool AllowCompatibleDifferences) override;\n  bool ReadTargetOptions(const TargetOptions &TargetOpts, bool Complain,\n                         bool AllowCompatibleDifferences) override;\n  bool ReadDiagnosticOptions(IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts,\n                             bool Complain) override;\n  bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts, bool Complain,\n                               std::string &SuggestedPredefines) override;\n  bool ReadHeaderSearchOptions(const HeaderSearchOptions &HSOpts,\n                               StringRef SpecificModuleCachePath,\n                               bool Complain) override;\n  void ReadCounter(const serialization::ModuleFile &M, unsigned Value) override;\n\nprivate:\n  void Error(const char *Msg);\n};\n\n/// ASTReaderListenter implementation to set SuggestedPredefines of\n/// ASTReader which is required to use a pch file. This is the replacement\n/// of PCHValidator or SimplePCHValidator when using a pch file without\n/// validating it.\nclass SimpleASTReaderListener : public ASTReaderListener {\n  Preprocessor &PP;\n\npublic:\n  SimpleASTReaderListener(Preprocessor &PP) : PP(PP) {}\n\n  bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts, bool Complain,\n                               std::string &SuggestedPredefines) override;\n};\n\nnamespace serialization {\n\nclass ReadMethodPoolVisitor;\n\nnamespace reader {\n\nclass ASTIdentifierLookupTrait;\n\n/// The on-disk hash table(s) used for DeclContext name lookup.\nstruct DeclContextLookupTable;\n\n} // namespace reader\n\n} // namespace serialization\n\n/// Reads an AST files chain containing the contents of a translation\n/// unit.\n///\n/// The ASTReader class reads bitstreams (produced by the ASTWriter\n/// class) containing the serialized representation of a given\n/// abstract syntax tree and its supporting data structures. An\n/// instance of the ASTReader can be attached to an ASTContext object,\n/// which will provide access to the contents of the AST files.\n///\n/// The AST reader provides lazy de-serialization of declarations, as\n/// required when traversing the AST. Only those AST nodes that are\n/// actually required will be de-serialized.\nclass ASTReader\n  : public ExternalPreprocessorSource,\n    public ExternalPreprocessingRecordSource,\n    public ExternalHeaderFileInfoSource,\n    public ExternalSemaSource,\n    public IdentifierInfoLookup,\n    public ExternalSLocEntrySource\n{\npublic:\n  /// Types of AST files.\n  friend class ASTDeclReader;\n  friend class ASTIdentifierIterator;\n  friend class ASTRecordReader;\n  friend class ASTUnit; // ASTUnit needs to remap source locations.\n  friend class ASTWriter;\n  friend class PCHValidator;\n  friend class serialization::reader::ASTIdentifierLookupTrait;\n  friend class serialization::ReadMethodPoolVisitor;\n  friend class TypeLocReader;\n\n  using RecordData = SmallVector<uint64_t, 64>;\n  using RecordDataImpl = SmallVectorImpl<uint64_t>;\n\n  /// The result of reading the control block of an AST file, which\n  /// can fail for various reasons.\n  enum ASTReadResult {\n    /// The control block was read successfully. Aside from failures,\n    /// the AST file is safe to read into the current context.\n    Success,\n\n    /// The AST file itself appears corrupted.\n    Failure,\n\n    /// The AST file was missing.\n    Missing,\n\n    /// The AST file is out-of-date relative to its input files,\n    /// and needs to be regenerated.\n    OutOfDate,\n\n    /// The AST file was written by a different version of Clang.\n    VersionMismatch,\n\n    /// The AST file was writtten with a different language/target\n    /// configuration.\n    ConfigurationMismatch,\n\n    /// The AST file has errors.\n    HadErrors\n  };\n\n  using ModuleFile = serialization::ModuleFile;\n  using ModuleKind = serialization::ModuleKind;\n  using ModuleManager = serialization::ModuleManager;\n  using ModuleIterator = ModuleManager::ModuleIterator;\n  using ModuleConstIterator = ModuleManager::ModuleConstIterator;\n  using ModuleReverseIterator = ModuleManager::ModuleReverseIterator;\n\nprivate:\n  /// The receiver of some callbacks invoked by ASTReader.\n  std::unique_ptr<ASTReaderListener> Listener;\n\n  /// The receiver of deserialization events.\n  ASTDeserializationListener *DeserializationListener = nullptr;\n\n  bool OwnsDeserializationListener = false;\n\n  SourceManager &SourceMgr;\n  FileManager &FileMgr;\n  const PCHContainerReader &PCHContainerRdr;\n  DiagnosticsEngine &Diags;\n\n  /// The semantic analysis object that will be processing the\n  /// AST files and the translation unit that uses it.\n  Sema *SemaObj = nullptr;\n\n  /// The preprocessor that will be loading the source file.\n  Preprocessor &PP;\n\n  /// The AST context into which we'll read the AST files.\n  ASTContext *ContextObj = nullptr;\n\n  /// The AST consumer.\n  ASTConsumer *Consumer = nullptr;\n\n  /// The module manager which manages modules and their dependencies\n  ModuleManager ModuleMgr;\n\n  /// A dummy identifier resolver used to merge TU-scope declarations in\n  /// C, for the cases where we don't have a Sema object to provide a real\n  /// identifier resolver.\n  IdentifierResolver DummyIdResolver;\n\n  /// A mapping from extension block names to module file extensions.\n  llvm::StringMap<std::shared_ptr<ModuleFileExtension>> ModuleFileExtensions;\n\n  /// A timer used to track the time spent deserializing.\n  std::unique_ptr<llvm::Timer> ReadTimer;\n\n  /// The location where the module file will be considered as\n  /// imported from. For non-module AST types it should be invalid.\n  SourceLocation CurrentImportLoc;\n\n  /// The module kind that is currently deserializing.\n  Optional<ModuleKind> CurrentDeserializingModuleKind;\n\n  /// The global module index, if loaded.\n  std::unique_ptr<GlobalModuleIndex> GlobalIndex;\n\n  /// A map of global bit offsets to the module that stores entities\n  /// at those bit offsets.\n  ContinuousRangeMap<uint64_t, ModuleFile*, 4> GlobalBitOffsetsMap;\n\n  /// A map of negated SLocEntryIDs to the modules containing them.\n  ContinuousRangeMap<unsigned, ModuleFile*, 64> GlobalSLocEntryMap;\n\n  using GlobalSLocOffsetMapType =\n      ContinuousRangeMap<unsigned, ModuleFile *, 64>;\n\n  /// A map of reversed (SourceManager::MaxLoadedOffset - SLocOffset)\n  /// SourceLocation offsets to the modules containing them.\n  GlobalSLocOffsetMapType GlobalSLocOffsetMap;\n\n  /// Types that have already been loaded from the chain.\n  ///\n  /// When the pointer at index I is non-NULL, the type with\n  /// ID = (I + 1) << FastQual::Width has already been loaded\n  std::vector<QualType> TypesLoaded;\n\n  using GlobalTypeMapType =\n      ContinuousRangeMap<serialization::TypeID, ModuleFile *, 4>;\n\n  /// Mapping from global type IDs to the module in which the\n  /// type resides along with the offset that should be added to the\n  /// global type ID to produce a local ID.\n  GlobalTypeMapType GlobalTypeMap;\n\n  /// Declarations that have already been loaded from the chain.\n  ///\n  /// When the pointer at index I is non-NULL, the declaration with ID\n  /// = I + 1 has already been loaded.\n  std::vector<Decl *> DeclsLoaded;\n\n  using GlobalDeclMapType =\n      ContinuousRangeMap<serialization::DeclID, ModuleFile *, 4>;\n\n  /// Mapping from global declaration IDs to the module in which the\n  /// declaration resides.\n  GlobalDeclMapType GlobalDeclMap;\n\n  using FileOffset = std::pair<ModuleFile *, uint64_t>;\n  using FileOffsetsTy = SmallVector<FileOffset, 2>;\n  using DeclUpdateOffsetsMap =\n      llvm::DenseMap<serialization::DeclID, FileOffsetsTy>;\n\n  /// Declarations that have modifications residing in a later file\n  /// in the chain.\n  DeclUpdateOffsetsMap DeclUpdateOffsets;\n\n  struct PendingUpdateRecord {\n    Decl *D;\n    serialization::GlobalDeclID ID;\n\n    // Whether the declaration was just deserialized.\n    bool JustLoaded;\n\n    PendingUpdateRecord(serialization::GlobalDeclID ID, Decl *D,\n                        bool JustLoaded)\n        : D(D), ID(ID), JustLoaded(JustLoaded) {}\n  };\n\n  /// Declaration updates for already-loaded declarations that we need\n  /// to apply once we finish processing an import.\n  llvm::SmallVector<PendingUpdateRecord, 16> PendingUpdateRecords;\n\n  enum class PendingFakeDefinitionKind { NotFake, Fake, FakeLoaded };\n\n  /// The DefinitionData pointers that we faked up for class definitions\n  /// that we needed but hadn't loaded yet.\n  llvm::DenseMap<void *, PendingFakeDefinitionKind> PendingFakeDefinitionData;\n\n  /// Exception specification updates that have been loaded but not yet\n  /// propagated across the relevant redeclaration chain. The map key is the\n  /// canonical declaration (used only for deduplication) and the value is a\n  /// declaration that has an exception specification.\n  llvm::SmallMapVector<Decl *, FunctionDecl *, 4> PendingExceptionSpecUpdates;\n\n  /// Deduced return type updates that have been loaded but not yet propagated\n  /// across the relevant redeclaration chain. The map key is the canonical\n  /// declaration and the value is the deduced return type.\n  llvm::SmallMapVector<FunctionDecl *, QualType, 4> PendingDeducedTypeUpdates;\n\n  /// Declarations that have been imported and have typedef names for\n  /// linkage purposes.\n  llvm::DenseMap<std::pair<DeclContext *, IdentifierInfo *>, NamedDecl *>\n      ImportedTypedefNamesForLinkage;\n\n  /// Mergeable declaration contexts that have anonymous declarations\n  /// within them, and those anonymous declarations.\n  llvm::DenseMap<Decl*, llvm::SmallVector<NamedDecl*, 2>>\n    AnonymousDeclarationsForMerging;\n\n  /// Key used to identify LifetimeExtendedTemporaryDecl for merging,\n  /// containing the lifetime-extending declaration and the mangling number.\n  using LETemporaryKey = std::pair<Decl *, unsigned>;\n\n  /// Map of already deserialiazed temporaries.\n  llvm::DenseMap<LETemporaryKey, LifetimeExtendedTemporaryDecl *>\n      LETemporaryForMerging;\n\n  struct FileDeclsInfo {\n    ModuleFile *Mod = nullptr;\n    ArrayRef<serialization::LocalDeclID> Decls;\n\n    FileDeclsInfo() = default;\n    FileDeclsInfo(ModuleFile *Mod, ArrayRef<serialization::LocalDeclID> Decls)\n        : Mod(Mod), Decls(Decls) {}\n  };\n\n  /// Map from a FileID to the file-level declarations that it contains.\n  llvm::DenseMap<FileID, FileDeclsInfo> FileDeclIDs;\n\n  /// An array of lexical contents of a declaration context, as a sequence of\n  /// Decl::Kind, DeclID pairs.\n  using LexicalContents = ArrayRef<llvm::support::unaligned_uint32_t>;\n\n  /// Map from a DeclContext to its lexical contents.\n  llvm::DenseMap<const DeclContext*, std::pair<ModuleFile*, LexicalContents>>\n      LexicalDecls;\n\n  /// Map from the TU to its lexical contents from each module file.\n  std::vector<std::pair<ModuleFile*, LexicalContents>> TULexicalDecls;\n\n  /// Map from a DeclContext to its lookup tables.\n  llvm::DenseMap<const DeclContext *,\n                 serialization::reader::DeclContextLookupTable> Lookups;\n\n  // Updates for visible decls can occur for other contexts than just the\n  // TU, and when we read those update records, the actual context may not\n  // be available yet, so have this pending map using the ID as a key. It\n  // will be realized when the context is actually loaded.\n  struct PendingVisibleUpdate {\n    ModuleFile *Mod;\n    const unsigned char *Data;\n  };\n  using DeclContextVisibleUpdates = SmallVector<PendingVisibleUpdate, 1>;\n\n  /// Updates to the visible declarations of declaration contexts that\n  /// haven't been loaded yet.\n  llvm::DenseMap<serialization::DeclID, DeclContextVisibleUpdates>\n      PendingVisibleUpdates;\n\n  /// The set of C++ or Objective-C classes that have forward\n  /// declarations that have not yet been linked to their definitions.\n  llvm::SmallPtrSet<Decl *, 4> PendingDefinitions;\n\n  using PendingBodiesMap =\n      llvm::MapVector<Decl *, uint64_t,\n                      llvm::SmallDenseMap<Decl *, unsigned, 4>,\n                      SmallVector<std::pair<Decl *, uint64_t>, 4>>;\n\n  /// Functions or methods that have bodies that will be attached.\n  PendingBodiesMap PendingBodies;\n\n  /// Definitions for which we have added merged definitions but not yet\n  /// performed deduplication.\n  llvm::SetVector<NamedDecl *> PendingMergedDefinitionsToDeduplicate;\n\n  /// Read the record that describes the lexical contents of a DC.\n  bool ReadLexicalDeclContextStorage(ModuleFile &M,\n                                     llvm::BitstreamCursor &Cursor,\n                                     uint64_t Offset, DeclContext *DC);\n\n  /// Read the record that describes the visible contents of a DC.\n  bool ReadVisibleDeclContextStorage(ModuleFile &M,\n                                     llvm::BitstreamCursor &Cursor,\n                                     uint64_t Offset, serialization::DeclID ID);\n\n  /// A vector containing identifiers that have already been\n  /// loaded.\n  ///\n  /// If the pointer at index I is non-NULL, then it refers to the\n  /// IdentifierInfo for the identifier with ID=I+1 that has already\n  /// been loaded.\n  std::vector<IdentifierInfo *> IdentifiersLoaded;\n\n  using GlobalIdentifierMapType =\n      ContinuousRangeMap<serialization::IdentID, ModuleFile *, 4>;\n\n  /// Mapping from global identifier IDs to the module in which the\n  /// identifier resides along with the offset that should be added to the\n  /// global identifier ID to produce a local ID.\n  GlobalIdentifierMapType GlobalIdentifierMap;\n\n  /// A vector containing macros that have already been\n  /// loaded.\n  ///\n  /// If the pointer at index I is non-NULL, then it refers to the\n  /// MacroInfo for the identifier with ID=I+1 that has already\n  /// been loaded.\n  std::vector<MacroInfo *> MacrosLoaded;\n\n  using LoadedMacroInfo =\n      std::pair<IdentifierInfo *, serialization::SubmoduleID>;\n\n  /// A set of #undef directives that we have loaded; used to\n  /// deduplicate the same #undef information coming from multiple module\n  /// files.\n  llvm::DenseSet<LoadedMacroInfo> LoadedUndefs;\n\n  using GlobalMacroMapType =\n      ContinuousRangeMap<serialization::MacroID, ModuleFile *, 4>;\n\n  /// Mapping from global macro IDs to the module in which the\n  /// macro resides along with the offset that should be added to the\n  /// global macro ID to produce a local ID.\n  GlobalMacroMapType GlobalMacroMap;\n\n  /// A vector containing submodules that have already been loaded.\n  ///\n  /// This vector is indexed by the Submodule ID (-1). NULL submodule entries\n  /// indicate that the particular submodule ID has not yet been loaded.\n  SmallVector<Module *, 2> SubmodulesLoaded;\n\n  using GlobalSubmoduleMapType =\n      ContinuousRangeMap<serialization::SubmoduleID, ModuleFile *, 4>;\n\n  /// Mapping from global submodule IDs to the module file in which the\n  /// submodule resides along with the offset that should be added to the\n  /// global submodule ID to produce a local ID.\n  GlobalSubmoduleMapType GlobalSubmoduleMap;\n\n  /// A set of hidden declarations.\n  using HiddenNames = SmallVector<Decl *, 2>;\n  using HiddenNamesMapType = llvm::DenseMap<Module *, HiddenNames>;\n\n  /// A mapping from each of the hidden submodules to the deserialized\n  /// declarations in that submodule that could be made visible.\n  HiddenNamesMapType HiddenNamesMap;\n\n  /// A module import, export, or conflict that hasn't yet been resolved.\n  struct UnresolvedModuleRef {\n    /// The file in which this module resides.\n    ModuleFile *File;\n\n    /// The module that is importing or exporting.\n    Module *Mod;\n\n    /// The kind of module reference.\n    enum { Import, Export, Conflict } Kind;\n\n    /// The local ID of the module that is being exported.\n    unsigned ID;\n\n    /// Whether this is a wildcard export.\n    unsigned IsWildcard : 1;\n\n    /// String data.\n    StringRef String;\n  };\n\n  /// The set of module imports and exports that still need to be\n  /// resolved.\n  SmallVector<UnresolvedModuleRef, 2> UnresolvedModuleRefs;\n\n  /// A vector containing selectors that have already been loaded.\n  ///\n  /// This vector is indexed by the Selector ID (-1). NULL selector\n  /// entries indicate that the particular selector ID has not yet\n  /// been loaded.\n  SmallVector<Selector, 16> SelectorsLoaded;\n\n  using GlobalSelectorMapType =\n      ContinuousRangeMap<serialization::SelectorID, ModuleFile *, 4>;\n\n  /// Mapping from global selector IDs to the module in which the\n  /// global selector ID to produce a local ID.\n  GlobalSelectorMapType GlobalSelectorMap;\n\n  /// The generation number of the last time we loaded data from the\n  /// global method pool for this selector.\n  llvm::DenseMap<Selector, unsigned> SelectorGeneration;\n\n  /// Whether a selector is out of date. We mark a selector as out of date\n  /// if we load another module after the method pool entry was pulled in.\n  llvm::DenseMap<Selector, bool> SelectorOutOfDate;\n\n  struct PendingMacroInfo {\n    ModuleFile *M;\n    /// Offset relative to ModuleFile::MacroOffsetsBase.\n    uint32_t MacroDirectivesOffset;\n\n    PendingMacroInfo(ModuleFile *M, uint32_t MacroDirectivesOffset)\n        : M(M), MacroDirectivesOffset(MacroDirectivesOffset) {}\n  };\n\n  using PendingMacroIDsMap =\n      llvm::MapVector<IdentifierInfo *, SmallVector<PendingMacroInfo, 2>>;\n\n  /// Mapping from identifiers that have a macro history to the global\n  /// IDs have not yet been deserialized to the global IDs of those macros.\n  PendingMacroIDsMap PendingMacroIDs;\n\n  using GlobalPreprocessedEntityMapType =\n      ContinuousRangeMap<unsigned, ModuleFile *, 4>;\n\n  /// Mapping from global preprocessing entity IDs to the module in\n  /// which the preprocessed entity resides along with the offset that should be\n  /// added to the global preprocessing entity ID to produce a local ID.\n  GlobalPreprocessedEntityMapType GlobalPreprocessedEntityMap;\n\n  using GlobalSkippedRangeMapType =\n      ContinuousRangeMap<unsigned, ModuleFile *, 4>;\n\n  /// Mapping from global skipped range base IDs to the module in which\n  /// the skipped ranges reside.\n  GlobalSkippedRangeMapType GlobalSkippedRangeMap;\n\n  /// \\name CodeGen-relevant special data\n  /// Fields containing data that is relevant to CodeGen.\n  //@{\n\n  /// The IDs of all declarations that fulfill the criteria of\n  /// \"interesting\" decls.\n  ///\n  /// This contains the data loaded from all EAGERLY_DESERIALIZED_DECLS blocks\n  /// in the chain. The referenced declarations are deserialized and passed to\n  /// the consumer eagerly.\n  SmallVector<uint64_t, 16> EagerlyDeserializedDecls;\n\n  /// The IDs of all tentative definitions stored in the chain.\n  ///\n  /// Sema keeps track of all tentative definitions in a TU because it has to\n  /// complete them and pass them on to CodeGen. Thus, tentative definitions in\n  /// the PCH chain must be eagerly deserialized.\n  SmallVector<uint64_t, 16> TentativeDefinitions;\n\n  /// The IDs of all CXXRecordDecls stored in the chain whose VTables are\n  /// used.\n  ///\n  /// CodeGen has to emit VTables for these records, so they have to be eagerly\n  /// deserialized.\n  SmallVector<uint64_t, 64> VTableUses;\n\n  /// A snapshot of the pending instantiations in the chain.\n  ///\n  /// This record tracks the instantiations that Sema has to perform at the\n  /// end of the TU. It consists of a pair of values for every pending\n  /// instantiation where the first value is the ID of the decl and the second\n  /// is the instantiation location.\n  SmallVector<uint64_t, 64> PendingInstantiations;\n\n  //@}\n\n  /// \\name DiagnosticsEngine-relevant special data\n  /// Fields containing data that is used for generating diagnostics\n  //@{\n\n  /// A snapshot of Sema's unused file-scoped variable tracking, for\n  /// generating warnings.\n  SmallVector<uint64_t, 16> UnusedFileScopedDecls;\n\n  /// A list of all the delegating constructors we've seen, to diagnose\n  /// cycles.\n  SmallVector<uint64_t, 4> DelegatingCtorDecls;\n\n  /// Method selectors used in a @selector expression. Used for\n  /// implementation of -Wselector.\n  SmallVector<uint64_t, 64> ReferencedSelectorsData;\n\n  /// A snapshot of Sema's weak undeclared identifier tracking, for\n  /// generating warnings.\n  SmallVector<uint64_t, 64> WeakUndeclaredIdentifiers;\n\n  /// The IDs of type aliases for ext_vectors that exist in the chain.\n  ///\n  /// Used by Sema for finding sugared names for ext_vectors in diagnostics.\n  SmallVector<uint64_t, 4> ExtVectorDecls;\n\n  //@}\n\n  /// \\name Sema-relevant special data\n  /// Fields containing data that is used for semantic analysis\n  //@{\n\n  /// The IDs of all potentially unused typedef names in the chain.\n  ///\n  /// Sema tracks these to emit warnings.\n  SmallVector<uint64_t, 16> UnusedLocalTypedefNameCandidates;\n\n  /// Our current depth in #pragma cuda force_host_device begin/end\n  /// macros.\n  unsigned ForceCUDAHostDeviceDepth = 0;\n\n  /// The IDs of the declarations Sema stores directly.\n  ///\n  /// Sema tracks a few important decls, such as namespace std, directly.\n  SmallVector<uint64_t, 4> SemaDeclRefs;\n\n  /// The IDs of the types ASTContext stores directly.\n  ///\n  /// The AST context tracks a few important types, such as va_list, directly.\n  SmallVector<uint64_t, 16> SpecialTypes;\n\n  /// The IDs of CUDA-specific declarations ASTContext stores directly.\n  ///\n  /// The AST context tracks a few important decls, currently cudaConfigureCall,\n  /// directly.\n  SmallVector<uint64_t, 2> CUDASpecialDeclRefs;\n\n  /// The floating point pragma option settings.\n  SmallVector<uint64_t, 1> FPPragmaOptions;\n\n  /// The pragma clang optimize location (if the pragma state is \"off\").\n  SourceLocation OptimizeOffPragmaLocation;\n\n  /// The PragmaMSStructKind pragma ms_struct state if set, or -1.\n  int PragmaMSStructState = -1;\n\n  /// The PragmaMSPointersToMembersKind pragma pointers_to_members state.\n  int PragmaMSPointersToMembersState = -1;\n  SourceLocation PointersToMembersPragmaLocation;\n\n  /// The pragma float_control state.\n  Optional<FPOptionsOverride> FpPragmaCurrentValue;\n  SourceLocation FpPragmaCurrentLocation;\n  struct FpPragmaStackEntry {\n    FPOptionsOverride Value;\n    SourceLocation Location;\n    SourceLocation PushLocation;\n    StringRef SlotLabel;\n  };\n  llvm::SmallVector<FpPragmaStackEntry, 2> FpPragmaStack;\n  llvm::SmallVector<std::string, 2> FpPragmaStrings;\n\n  /// The pragma align/pack state.\n  Optional<Sema::AlignPackInfo> PragmaAlignPackCurrentValue;\n  SourceLocation PragmaAlignPackCurrentLocation;\n  struct PragmaAlignPackStackEntry {\n    Sema::AlignPackInfo Value;\n    SourceLocation Location;\n    SourceLocation PushLocation;\n    StringRef SlotLabel;\n  };\n  llvm::SmallVector<PragmaAlignPackStackEntry, 2> PragmaAlignPackStack;\n  llvm::SmallVector<std::string, 2> PragmaAlignPackStrings;\n\n  /// The OpenCL extension settings.\n  OpenCLOptions OpenCLExtensions;\n\n  /// Extensions required by an OpenCL type.\n  llvm::DenseMap<const Type *, std::set<std::string>> OpenCLTypeExtMap;\n\n  /// Extensions required by an OpenCL declaration.\n  llvm::DenseMap<const Decl *, std::set<std::string>> OpenCLDeclExtMap;\n\n  /// A list of the namespaces we've seen.\n  SmallVector<uint64_t, 4> KnownNamespaces;\n\n  /// A list of undefined decls with internal linkage followed by the\n  /// SourceLocation of a matching ODR-use.\n  SmallVector<uint64_t, 8> UndefinedButUsed;\n\n  /// Delete expressions to analyze at the end of translation unit.\n  SmallVector<uint64_t, 8> DelayedDeleteExprs;\n\n  // A list of late parsed template function data with their module files.\n  SmallVector<std::pair<ModuleFile *, SmallVector<uint64_t, 1>>, 4>\n      LateParsedTemplates;\n\n  /// The IDs of all decls to be checked for deferred diags.\n  ///\n  /// Sema tracks these to emit deferred diags.\n  SmallVector<uint64_t, 4> DeclsToCheckForDeferredDiags;\n\n\npublic:\n  struct ImportedSubmodule {\n    serialization::SubmoduleID ID;\n    SourceLocation ImportLoc;\n\n    ImportedSubmodule(serialization::SubmoduleID ID, SourceLocation ImportLoc)\n        : ID(ID), ImportLoc(ImportLoc) {}\n  };\n\nprivate:\n  /// A list of modules that were imported by precompiled headers or\n  /// any other non-module AST file.\n  SmallVector<ImportedSubmodule, 2> ImportedModules;\n  //@}\n\n  /// The system include root to be used when loading the\n  /// precompiled header.\n  std::string isysroot;\n\n  /// Whether to disable the normal validation performed on precompiled\n  /// headers and module files when they are loaded.\n  DisableValidationForModuleKind DisableValidationKind;\n\n  /// Whether to accept an AST file with compiler errors.\n  bool AllowASTWithCompilerErrors;\n\n  /// Whether to accept an AST file that has a different configuration\n  /// from the current compiler instance.\n  bool AllowConfigurationMismatch;\n\n  /// Whether validate system input files.\n  bool ValidateSystemInputs;\n\n  /// Whether validate headers and module maps using hash based on contents.\n  bool ValidateASTInputFilesContent;\n\n  /// Whether we are allowed to use the global module index.\n  bool UseGlobalIndex;\n\n  /// Whether we have tried loading the global module index yet.\n  bool TriedLoadingGlobalIndex = false;\n\n  ///Whether we are currently processing update records.\n  bool ProcessingUpdateRecords = false;\n\n  using SwitchCaseMapTy = llvm::DenseMap<unsigned, SwitchCase *>;\n\n  /// Mapping from switch-case IDs in the chain to switch-case statements\n  ///\n  /// Statements usually don't have IDs, but switch cases need them, so that the\n  /// switch statement can refer to them.\n  SwitchCaseMapTy SwitchCaseStmts;\n\n  SwitchCaseMapTy *CurrSwitchCaseStmts;\n\n  /// The number of source location entries de-serialized from\n  /// the PCH file.\n  unsigned NumSLocEntriesRead = 0;\n\n  /// The number of source location entries in the chain.\n  unsigned TotalNumSLocEntries = 0;\n\n  /// The number of statements (and expressions) de-serialized\n  /// from the chain.\n  unsigned NumStatementsRead = 0;\n\n  /// The total number of statements (and expressions) stored\n  /// in the chain.\n  unsigned TotalNumStatements = 0;\n\n  /// The number of macros de-serialized from the chain.\n  unsigned NumMacrosRead = 0;\n\n  /// The total number of macros stored in the chain.\n  unsigned TotalNumMacros = 0;\n\n  /// The number of lookups into identifier tables.\n  unsigned NumIdentifierLookups = 0;\n\n  /// The number of lookups into identifier tables that succeed.\n  unsigned NumIdentifierLookupHits = 0;\n\n  /// The number of selectors that have been read.\n  unsigned NumSelectorsRead = 0;\n\n  /// The number of method pool entries that have been read.\n  unsigned NumMethodPoolEntriesRead = 0;\n\n  /// The number of times we have looked up a selector in the method\n  /// pool.\n  unsigned NumMethodPoolLookups = 0;\n\n  /// The number of times we have looked up a selector in the method\n  /// pool and found something.\n  unsigned NumMethodPoolHits = 0;\n\n  /// The number of times we have looked up a selector in the method\n  /// pool within a specific module.\n  unsigned NumMethodPoolTableLookups = 0;\n\n  /// The number of times we have looked up a selector in the method\n  /// pool within a specific module and found something.\n  unsigned NumMethodPoolTableHits = 0;\n\n  /// The total number of method pool entries in the selector table.\n  unsigned TotalNumMethodPoolEntries = 0;\n\n  /// Number of lexical decl contexts read/total.\n  unsigned NumLexicalDeclContextsRead = 0, TotalLexicalDeclContexts = 0;\n\n  /// Number of visible decl contexts read/total.\n  unsigned NumVisibleDeclContextsRead = 0, TotalVisibleDeclContexts = 0;\n\n  /// Total size of modules, in bits, currently loaded\n  uint64_t TotalModulesSizeInBits = 0;\n\n  /// Number of Decl/types that are currently deserializing.\n  unsigned NumCurrentElementsDeserializing = 0;\n\n  /// Set true while we are in the process of passing deserialized\n  /// \"interesting\" decls to consumer inside FinishedDeserializing().\n  /// This is used as a guard to avoid recursively repeating the process of\n  /// passing decls to consumer.\n  bool PassingDeclsToConsumer = false;\n\n  /// The set of identifiers that were read while the AST reader was\n  /// (recursively) loading declarations.\n  ///\n  /// The declarations on the identifier chain for these identifiers will be\n  /// loaded once the recursive loading has completed.\n  llvm::MapVector<IdentifierInfo *, SmallVector<uint32_t, 4>>\n    PendingIdentifierInfos;\n\n  /// The set of lookup results that we have faked in order to support\n  /// merging of partially deserialized decls but that we have not yet removed.\n  llvm::SmallMapVector<IdentifierInfo *, SmallVector<NamedDecl*, 2>, 16>\n    PendingFakeLookupResults;\n\n  /// The generation number of each identifier, which keeps track of\n  /// the last time we loaded information about this identifier.\n  llvm::DenseMap<IdentifierInfo *, unsigned> IdentifierGeneration;\n\n  class InterestingDecl {\n    Decl *D;\n    bool DeclHasPendingBody;\n\n  public:\n    InterestingDecl(Decl *D, bool HasBody)\n        : D(D), DeclHasPendingBody(HasBody) {}\n\n    Decl *getDecl() { return D; }\n\n    /// Whether the declaration has a pending body.\n    bool hasPendingBody() { return DeclHasPendingBody; }\n  };\n\n  /// Contains declarations and definitions that could be\n  /// \"interesting\" to the ASTConsumer, when we get that AST consumer.\n  ///\n  /// \"Interesting\" declarations are those that have data that may\n  /// need to be emitted, such as inline function definitions or\n  /// Objective-C protocols.\n  std::deque<InterestingDecl> PotentiallyInterestingDecls;\n\n  /// The list of deduced function types that we have not yet read, because\n  /// they might contain a deduced return type that refers to a local type\n  /// declared within the function.\n  SmallVector<std::pair<FunctionDecl *, serialization::TypeID>, 16>\n      PendingFunctionTypes;\n\n  /// The list of redeclaration chains that still need to be\n  /// reconstructed, and the local offset to the corresponding list\n  /// of redeclarations.\n  SmallVector<std::pair<Decl *, uint64_t>, 16> PendingDeclChains;\n\n  /// The list of canonical declarations whose redeclaration chains\n  /// need to be marked as incomplete once we're done deserializing things.\n  SmallVector<Decl *, 16> PendingIncompleteDeclChains;\n\n  /// The Decl IDs for the Sema/Lexical DeclContext of a Decl that has\n  /// been loaded but its DeclContext was not set yet.\n  struct PendingDeclContextInfo {\n    Decl *D;\n    serialization::GlobalDeclID SemaDC;\n    serialization::GlobalDeclID LexicalDC;\n  };\n\n  /// The set of Decls that have been loaded but their DeclContexts are\n  /// not set yet.\n  ///\n  /// The DeclContexts for these Decls will be set once recursive loading has\n  /// been completed.\n  std::deque<PendingDeclContextInfo> PendingDeclContextInfos;\n\n  /// The set of NamedDecls that have been loaded, but are members of a\n  /// context that has been merged into another context where the corresponding\n  /// declaration is either missing or has not yet been loaded.\n  ///\n  /// We will check whether the corresponding declaration is in fact missing\n  /// once recursing loading has been completed.\n  llvm::SmallVector<NamedDecl *, 16> PendingOdrMergeChecks;\n\n  using DataPointers =\n      std::pair<CXXRecordDecl *, struct CXXRecordDecl::DefinitionData *>;\n\n  /// Record definitions in which we found an ODR violation.\n  llvm::SmallDenseMap<CXXRecordDecl *, llvm::SmallVector<DataPointers, 2>, 2>\n      PendingOdrMergeFailures;\n\n  /// Function definitions in which we found an ODR violation.\n  llvm::SmallDenseMap<FunctionDecl *, llvm::SmallVector<FunctionDecl *, 2>, 2>\n      PendingFunctionOdrMergeFailures;\n\n  /// Enum definitions in which we found an ODR violation.\n  llvm::SmallDenseMap<EnumDecl *, llvm::SmallVector<EnumDecl *, 2>, 2>\n      PendingEnumOdrMergeFailures;\n\n  /// DeclContexts in which we have diagnosed an ODR violation.\n  llvm::SmallPtrSet<DeclContext*, 2> DiagnosedOdrMergeFailures;\n\n  /// The set of Objective-C categories that have been deserialized\n  /// since the last time the declaration chains were linked.\n  llvm::SmallPtrSet<ObjCCategoryDecl *, 16> CategoriesDeserialized;\n\n  /// The set of Objective-C class definitions that have already been\n  /// loaded, for which we will need to check for categories whenever a new\n  /// module is loaded.\n  SmallVector<ObjCInterfaceDecl *, 16> ObjCClassesLoaded;\n\n  using KeyDeclsMap =\n      llvm::DenseMap<Decl *, SmallVector<serialization::DeclID, 2>>;\n\n  /// A mapping from canonical declarations to the set of global\n  /// declaration IDs for key declaration that have been merged with that\n  /// canonical declaration. A key declaration is a formerly-canonical\n  /// declaration whose module did not import any other key declaration for that\n  /// entity. These are the IDs that we use as keys when finding redecl chains.\n  KeyDeclsMap KeyDecls;\n\n  /// A mapping from DeclContexts to the semantic DeclContext that we\n  /// are treating as the definition of the entity. This is used, for instance,\n  /// when merging implicit instantiations of class templates across modules.\n  llvm::DenseMap<DeclContext *, DeclContext *> MergedDeclContexts;\n\n  /// A mapping from canonical declarations of enums to their canonical\n  /// definitions. Only populated when using modules in C++.\n  llvm::DenseMap<EnumDecl *, EnumDecl *> EnumDefinitions;\n\n  /// When reading a Stmt tree, Stmt operands are placed in this stack.\n  SmallVector<Stmt *, 16> StmtStack;\n\n  /// What kind of records we are reading.\n  enum ReadingKind {\n    Read_None, Read_Decl, Read_Type, Read_Stmt\n  };\n\n  /// What kind of records we are reading.\n  ReadingKind ReadingKind = Read_None;\n\n  /// RAII object to change the reading kind.\n  class ReadingKindTracker {\n    ASTReader &Reader;\n    enum ReadingKind PrevKind;\n\n  public:\n    ReadingKindTracker(enum ReadingKind newKind, ASTReader &reader)\n        : Reader(reader), PrevKind(Reader.ReadingKind) {\n      Reader.ReadingKind = newKind;\n    }\n\n    ReadingKindTracker(const ReadingKindTracker &) = delete;\n    ReadingKindTracker &operator=(const ReadingKindTracker &) = delete;\n    ~ReadingKindTracker() { Reader.ReadingKind = PrevKind; }\n  };\n\n  /// RAII object to mark the start of processing updates.\n  class ProcessingUpdatesRAIIObj {\n    ASTReader &Reader;\n    bool PrevState;\n\n  public:\n    ProcessingUpdatesRAIIObj(ASTReader &reader)\n        : Reader(reader), PrevState(Reader.ProcessingUpdateRecords) {\n      Reader.ProcessingUpdateRecords = true;\n    }\n\n    ProcessingUpdatesRAIIObj(const ProcessingUpdatesRAIIObj &) = delete;\n    ProcessingUpdatesRAIIObj &\n    operator=(const ProcessingUpdatesRAIIObj &) = delete;\n    ~ProcessingUpdatesRAIIObj() { Reader.ProcessingUpdateRecords = PrevState; }\n  };\n\n  /// Suggested contents of the predefines buffer, after this\n  /// PCH file has been processed.\n  ///\n  /// In most cases, this string will be empty, because the predefines\n  /// buffer computed to build the PCH file will be identical to the\n  /// predefines buffer computed from the command line. However, when\n  /// there are differences that the PCH reader can work around, this\n  /// predefines buffer may contain additional definitions.\n  std::string SuggestedPredefines;\n\n  llvm::DenseMap<const Decl *, bool> DefinitionSource;\n\n  bool shouldDisableValidationForFile(const serialization::ModuleFile &M) const;\n\n  /// Reads a statement from the specified cursor.\n  Stmt *ReadStmtFromStream(ModuleFile &F);\n\n  struct InputFileInfo {\n    std::string Filename;\n    uint64_t ContentHash;\n    off_t StoredSize;\n    time_t StoredTime;\n    bool Overridden;\n    bool Transient;\n    bool TopLevelModuleMap;\n  };\n\n  /// Reads the stored information about an input file.\n  InputFileInfo readInputFileInfo(ModuleFile &F, unsigned ID);\n\n  /// Retrieve the file entry and 'overridden' bit for an input\n  /// file in the given module file.\n  serialization::InputFile getInputFile(ModuleFile &F, unsigned ID,\n                                        bool Complain = true);\n\npublic:\n  void ResolveImportedPath(ModuleFile &M, std::string &Filename);\n  static void ResolveImportedPath(std::string &Filename, StringRef Prefix);\n\n  /// Returns the first key declaration for the given declaration. This\n  /// is one that is formerly-canonical (or still canonical) and whose module\n  /// did not import any other key declaration of the entity.\n  Decl *getKeyDeclaration(Decl *D) {\n    D = D->getCanonicalDecl();\n    if (D->isFromASTFile())\n      return D;\n\n    auto I = KeyDecls.find(D);\n    if (I == KeyDecls.end() || I->second.empty())\n      return D;\n    return GetExistingDecl(I->second[0]);\n  }\n  const Decl *getKeyDeclaration(const Decl *D) {\n    return getKeyDeclaration(const_cast<Decl*>(D));\n  }\n\n  /// Run a callback on each imported key declaration of \\p D.\n  template <typename Fn>\n  void forEachImportedKeyDecl(const Decl *D, Fn Visit) {\n    D = D->getCanonicalDecl();\n    if (D->isFromASTFile())\n      Visit(D);\n\n    auto It = KeyDecls.find(const_cast<Decl*>(D));\n    if (It != KeyDecls.end())\n      for (auto ID : It->second)\n        Visit(GetExistingDecl(ID));\n  }\n\n  /// Get the loaded lookup tables for \\p Primary, if any.\n  const serialization::reader::DeclContextLookupTable *\n  getLoadedLookupTables(DeclContext *Primary) const;\n\nprivate:\n  struct ImportedModule {\n    ModuleFile *Mod;\n    ModuleFile *ImportedBy;\n    SourceLocation ImportLoc;\n\n    ImportedModule(ModuleFile *Mod,\n                   ModuleFile *ImportedBy,\n                   SourceLocation ImportLoc)\n        : Mod(Mod), ImportedBy(ImportedBy), ImportLoc(ImportLoc) {}\n  };\n\n  ASTReadResult ReadASTCore(StringRef FileName, ModuleKind Type,\n                            SourceLocation ImportLoc, ModuleFile *ImportedBy,\n                            SmallVectorImpl<ImportedModule> &Loaded,\n                            off_t ExpectedSize, time_t ExpectedModTime,\n                            ASTFileSignature ExpectedSignature,\n                            unsigned ClientLoadCapabilities);\n  ASTReadResult ReadControlBlock(ModuleFile &F,\n                                 SmallVectorImpl<ImportedModule> &Loaded,\n                                 const ModuleFile *ImportedBy,\n                                 unsigned ClientLoadCapabilities);\n  static ASTReadResult ReadOptionsBlock(\n      llvm::BitstreamCursor &Stream, unsigned ClientLoadCapabilities,\n      bool AllowCompatibleConfigurationMismatch, ASTReaderListener &Listener,\n      std::string &SuggestedPredefines);\n\n  /// Read the unhashed control block.\n  ///\n  /// This has no effect on \\c F.Stream, instead creating a fresh cursor from\n  /// \\c F.Data and reading ahead.\n  ASTReadResult readUnhashedControlBlock(ModuleFile &F, bool WasImportedBy,\n                                         unsigned ClientLoadCapabilities);\n\n  static ASTReadResult\n  readUnhashedControlBlockImpl(ModuleFile *F, llvm::StringRef StreamData,\n                               unsigned ClientLoadCapabilities,\n                               bool AllowCompatibleConfigurationMismatch,\n                               ASTReaderListener *Listener,\n                               bool ValidateDiagnosticOptions);\n\n  ASTReadResult ReadASTBlock(ModuleFile &F, unsigned ClientLoadCapabilities);\n  ASTReadResult ReadExtensionBlock(ModuleFile &F);\n  void ReadModuleOffsetMap(ModuleFile &F) const;\n  bool ParseLineTable(ModuleFile &F, const RecordData &Record);\n  bool ReadSourceManagerBlock(ModuleFile &F);\n  llvm::BitstreamCursor &SLocCursorForID(int ID);\n  SourceLocation getImportLocation(ModuleFile *F);\n  ASTReadResult ReadModuleMapFileBlock(RecordData &Record, ModuleFile &F,\n                                       const ModuleFile *ImportedBy,\n                                       unsigned ClientLoadCapabilities);\n  ASTReadResult ReadSubmoduleBlock(ModuleFile &F,\n                                   unsigned ClientLoadCapabilities);\n  static bool ParseLanguageOptions(const RecordData &Record, bool Complain,\n                                   ASTReaderListener &Listener,\n                                   bool AllowCompatibleDifferences);\n  static bool ParseTargetOptions(const RecordData &Record, bool Complain,\n                                 ASTReaderListener &Listener,\n                                 bool AllowCompatibleDifferences);\n  static bool ParseDiagnosticOptions(const RecordData &Record, bool Complain,\n                                     ASTReaderListener &Listener);\n  static bool ParseFileSystemOptions(const RecordData &Record, bool Complain,\n                                     ASTReaderListener &Listener);\n  static bool ParseHeaderSearchOptions(const RecordData &Record, bool Complain,\n                                       ASTReaderListener &Listener);\n  static bool ParsePreprocessorOptions(const RecordData &Record, bool Complain,\n                                       ASTReaderListener &Listener,\n                                       std::string &SuggestedPredefines);\n\n  struct RecordLocation {\n    ModuleFile *F;\n    uint64_t Offset;\n\n    RecordLocation(ModuleFile *M, uint64_t O) : F(M), Offset(O) {}\n  };\n\n  QualType readTypeRecord(unsigned Index);\n  RecordLocation TypeCursorForIndex(unsigned Index);\n  void LoadedDecl(unsigned Index, Decl *D);\n  Decl *ReadDeclRecord(serialization::DeclID ID);\n  void markIncompleteDeclChain(Decl *Canon);\n\n  /// Returns the most recent declaration of a declaration (which must be\n  /// of a redeclarable kind) that is either local or has already been loaded\n  /// merged into its redecl chain.\n  Decl *getMostRecentExistingDecl(Decl *D);\n\n  RecordLocation DeclCursorForID(serialization::DeclID ID,\n                                 SourceLocation &Location);\n  void loadDeclUpdateRecords(PendingUpdateRecord &Record);\n  void loadPendingDeclChain(Decl *D, uint64_t LocalOffset);\n  void loadObjCCategories(serialization::GlobalDeclID ID, ObjCInterfaceDecl *D,\n                          unsigned PreviousGeneration = 0);\n\n  RecordLocation getLocalBitOffset(uint64_t GlobalOffset);\n  uint64_t getGlobalBitOffset(ModuleFile &M, uint64_t LocalOffset);\n\n  /// Returns the first preprocessed entity ID that begins or ends after\n  /// \\arg Loc.\n  serialization::PreprocessedEntityID\n  findPreprocessedEntity(SourceLocation Loc, bool EndsAfter) const;\n\n  /// Find the next module that contains entities and return the ID\n  /// of the first entry.\n  ///\n  /// \\param SLocMapI points at a chunk of a module that contains no\n  /// preprocessed entities or the entities it contains are not the\n  /// ones we are looking for.\n  serialization::PreprocessedEntityID\n    findNextPreprocessedEntity(\n                        GlobalSLocOffsetMapType::const_iterator SLocMapI) const;\n\n  /// Returns (ModuleFile, Local index) pair for \\p GlobalIndex of a\n  /// preprocessed entity.\n  std::pair<ModuleFile *, unsigned>\n    getModulePreprocessedEntity(unsigned GlobalIndex);\n\n  /// Returns (begin, end) pair for the preprocessed entities of a\n  /// particular module.\n  llvm::iterator_range<PreprocessingRecord::iterator>\n  getModulePreprocessedEntities(ModuleFile &Mod) const;\n\npublic:\n  class ModuleDeclIterator\n      : public llvm::iterator_adaptor_base<\n            ModuleDeclIterator, const serialization::LocalDeclID *,\n            std::random_access_iterator_tag, const Decl *, ptrdiff_t,\n            const Decl *, const Decl *> {\n    ASTReader *Reader = nullptr;\n    ModuleFile *Mod = nullptr;\n\n  public:\n    ModuleDeclIterator() : iterator_adaptor_base(nullptr) {}\n\n    ModuleDeclIterator(ASTReader *Reader, ModuleFile *Mod,\n                       const serialization::LocalDeclID *Pos)\n        : iterator_adaptor_base(Pos), Reader(Reader), Mod(Mod) {}\n\n    value_type operator*() const {\n      return Reader->GetDecl(Reader->getGlobalDeclID(*Mod, *I));\n    }\n\n    value_type operator->() const { return **this; }\n\n    bool operator==(const ModuleDeclIterator &RHS) const {\n      assert(Reader == RHS.Reader && Mod == RHS.Mod);\n      return I == RHS.I;\n    }\n  };\n\n  llvm::iterator_range<ModuleDeclIterator>\n  getModuleFileLevelDecls(ModuleFile &Mod);\n\nprivate:\n  void PassInterestingDeclsToConsumer();\n  void PassInterestingDeclToConsumer(Decl *D);\n\n  void finishPendingActions();\n  void diagnoseOdrViolations();\n\n  void pushExternalDeclIntoScope(NamedDecl *D, DeclarationName Name);\n\n  void addPendingDeclContextInfo(Decl *D,\n                                 serialization::GlobalDeclID SemaDC,\n                                 serialization::GlobalDeclID LexicalDC) {\n    assert(D);\n    PendingDeclContextInfo Info = { D, SemaDC, LexicalDC };\n    PendingDeclContextInfos.push_back(Info);\n  }\n\n  /// Produce an error diagnostic and return true.\n  ///\n  /// This routine should only be used for fatal errors that have to\n  /// do with non-routine failures (e.g., corrupted AST file).\n  void Error(StringRef Msg) const;\n  void Error(unsigned DiagID, StringRef Arg1 = StringRef(),\n             StringRef Arg2 = StringRef(), StringRef Arg3 = StringRef()) const;\n  void Error(llvm::Error &&Err) const;\n\npublic:\n  /// Load the AST file and validate its contents against the given\n  /// Preprocessor.\n  ///\n  /// \\param PP the preprocessor associated with the context in which this\n  /// precompiled header will be loaded.\n  ///\n  /// \\param Context the AST context that this precompiled header will be\n  /// loaded into, if any.\n  ///\n  /// \\param PCHContainerRdr the PCHContainerOperations to use for loading and\n  /// creating modules.\n  ///\n  /// \\param Extensions the list of module file extensions that can be loaded\n  /// from the AST files.\n  ///\n  /// \\param isysroot If non-NULL, the system include path specified by the\n  /// user. This is only used with relocatable PCH files. If non-NULL,\n  /// a relocatable PCH file will use the default path \"/\".\n  ///\n  /// \\param DisableValidationKind If set, the AST reader will suppress most\n  /// of its regular consistency checking, allowing the use of precompiled\n  /// headers and module files that cannot be determined to be compatible.\n  ///\n  /// \\param AllowASTWithCompilerErrors If true, the AST reader will accept an\n  /// AST file the was created out of an AST with compiler errors,\n  /// otherwise it will reject it.\n  ///\n  /// \\param AllowConfigurationMismatch If true, the AST reader will not check\n  /// for configuration differences between the AST file and the invocation.\n  ///\n  /// \\param ValidateSystemInputs If true, the AST reader will validate\n  /// system input files in addition to user input files. This is only\n  /// meaningful if \\p DisableValidation is false.\n  ///\n  /// \\param UseGlobalIndex If true, the AST reader will try to load and use\n  /// the global module index.\n  ///\n  /// \\param ReadTimer If non-null, a timer used to track the time spent\n  /// deserializing.\n  ASTReader(Preprocessor &PP, InMemoryModuleCache &ModuleCache,\n            ASTContext *Context, const PCHContainerReader &PCHContainerRdr,\n            ArrayRef<std::shared_ptr<ModuleFileExtension>> Extensions,\n            StringRef isysroot = \"\",\n            DisableValidationForModuleKind DisableValidationKind =\n                DisableValidationForModuleKind::None,\n            bool AllowASTWithCompilerErrors = false,\n            bool AllowConfigurationMismatch = false,\n            bool ValidateSystemInputs = false,\n            bool ValidateASTInputFilesContent = false,\n            bool UseGlobalIndex = true,\n            std::unique_ptr<llvm::Timer> ReadTimer = {});\n  ASTReader(const ASTReader &) = delete;\n  ASTReader &operator=(const ASTReader &) = delete;\n  ~ASTReader() override;\n\n  SourceManager &getSourceManager() const { return SourceMgr; }\n  FileManager &getFileManager() const { return FileMgr; }\n  DiagnosticsEngine &getDiags() const { return Diags; }\n\n  /// Flags that indicate what kind of AST loading failures the client\n  /// of the AST reader can directly handle.\n  ///\n  /// When a client states that it can handle a particular kind of failure,\n  /// the AST reader will not emit errors when producing that kind of failure.\n  enum LoadFailureCapabilities {\n    /// The client can't handle any AST loading failures.\n    ARR_None = 0,\n\n    /// The client can handle an AST file that cannot load because it\n    /// is missing.\n    ARR_Missing = 0x1,\n\n    /// The client can handle an AST file that cannot load because it\n    /// is out-of-date relative to its input files.\n    ARR_OutOfDate = 0x2,\n\n    /// The client can handle an AST file that cannot load because it\n    /// was built with a different version of Clang.\n    ARR_VersionMismatch = 0x4,\n\n    /// The client can handle an AST file that cannot load because it's\n    /// compiled configuration doesn't match that of the context it was\n    /// loaded into.\n    ARR_ConfigurationMismatch = 0x8\n  };\n\n  /// Load the AST file designated by the given file name.\n  ///\n  /// \\param FileName The name of the AST file to load.\n  ///\n  /// \\param Type The kind of AST being loaded, e.g., PCH, module, main file,\n  /// or preamble.\n  ///\n  /// \\param ImportLoc the location where the module file will be considered as\n  /// imported from. For non-module AST types it should be invalid.\n  ///\n  /// \\param ClientLoadCapabilities The set of client load-failure\n  /// capabilities, represented as a bitset of the enumerators of\n  /// LoadFailureCapabilities.\n  ///\n  /// \\param Imported optional out-parameter to append the list of modules\n  /// that were imported by precompiled headers or any other non-module AST file\n  ASTReadResult ReadAST(StringRef FileName, ModuleKind Type,\n                        SourceLocation ImportLoc,\n                        unsigned ClientLoadCapabilities,\n                        SmallVectorImpl<ImportedSubmodule> *Imported = nullptr);\n\n  /// Make the entities in the given module and any of its (non-explicit)\n  /// submodules visible to name lookup.\n  ///\n  /// \\param Mod The module whose names should be made visible.\n  ///\n  /// \\param NameVisibility The level of visibility to give the names in the\n  /// module.  Visibility can only be increased over time.\n  ///\n  /// \\param ImportLoc The location at which the import occurs.\n  void makeModuleVisible(Module *Mod,\n                         Module::NameVisibilityKind NameVisibility,\n                         SourceLocation ImportLoc);\n\n  /// Make the names within this set of hidden names visible.\n  void makeNamesVisible(const HiddenNames &Names, Module *Owner);\n\n  /// Note that MergedDef is a redefinition of the canonical definition\n  /// Def, so Def should be visible whenever MergedDef is.\n  void mergeDefinitionVisibility(NamedDecl *Def, NamedDecl *MergedDef);\n\n  /// Take the AST callbacks listener.\n  std::unique_ptr<ASTReaderListener> takeListener() {\n    return std::move(Listener);\n  }\n\n  /// Set the AST callbacks listener.\n  void setListener(std::unique_ptr<ASTReaderListener> Listener) {\n    this->Listener = std::move(Listener);\n  }\n\n  /// Add an AST callback listener.\n  ///\n  /// Takes ownership of \\p L.\n  void addListener(std::unique_ptr<ASTReaderListener> L) {\n    if (Listener)\n      L = std::make_unique<ChainedASTReaderListener>(std::move(L),\n                                                      std::move(Listener));\n    Listener = std::move(L);\n  }\n\n  /// RAII object to temporarily add an AST callback listener.\n  class ListenerScope {\n    ASTReader &Reader;\n    bool Chained = false;\n\n  public:\n    ListenerScope(ASTReader &Reader, std::unique_ptr<ASTReaderListener> L)\n        : Reader(Reader) {\n      auto Old = Reader.takeListener();\n      if (Old) {\n        Chained = true;\n        L = std::make_unique<ChainedASTReaderListener>(std::move(L),\n                                                        std::move(Old));\n      }\n      Reader.setListener(std::move(L));\n    }\n\n    ~ListenerScope() {\n      auto New = Reader.takeListener();\n      if (Chained)\n        Reader.setListener(static_cast<ChainedASTReaderListener *>(New.get())\n                               ->takeSecond());\n    }\n  };\n\n  /// Set the AST deserialization listener.\n  void setDeserializationListener(ASTDeserializationListener *Listener,\n                                  bool TakeOwnership = false);\n\n  /// Get the AST deserialization listener.\n  ASTDeserializationListener *getDeserializationListener() {\n    return DeserializationListener;\n  }\n\n  /// Determine whether this AST reader has a global index.\n  bool hasGlobalIndex() const { return (bool)GlobalIndex; }\n\n  /// Return global module index.\n  GlobalModuleIndex *getGlobalIndex() { return GlobalIndex.get(); }\n\n  /// Reset reader for a reload try.\n  void resetForReload() { TriedLoadingGlobalIndex = false; }\n\n  /// Attempts to load the global index.\n  ///\n  /// \\returns true if loading the global index has failed for any reason.\n  bool loadGlobalIndex();\n\n  /// Determine whether we tried to load the global index, but failed,\n  /// e.g., because it is out-of-date or does not exist.\n  bool isGlobalIndexUnavailable() const;\n\n  /// Initializes the ASTContext\n  void InitializeContext();\n\n  /// Update the state of Sema after loading some additional modules.\n  void UpdateSema();\n\n  /// Add in-memory (virtual file) buffer.\n  void addInMemoryBuffer(StringRef &FileName,\n                         std::unique_ptr<llvm::MemoryBuffer> Buffer) {\n    ModuleMgr.addInMemoryBuffer(FileName, std::move(Buffer));\n  }\n\n  /// Finalizes the AST reader's state before writing an AST file to\n  /// disk.\n  ///\n  /// This operation may undo temporary state in the AST that should not be\n  /// emitted.\n  void finalizeForWriting();\n\n  /// Retrieve the module manager.\n  ModuleManager &getModuleManager() { return ModuleMgr; }\n\n  /// Retrieve the preprocessor.\n  Preprocessor &getPreprocessor() const { return PP; }\n\n  /// Retrieve the name of the original source file name for the primary\n  /// module file.\n  StringRef getOriginalSourceFile() {\n    return ModuleMgr.getPrimaryModule().OriginalSourceFileName;\n  }\n\n  /// Retrieve the name of the original source file name directly from\n  /// the AST file, without actually loading the AST file.\n  static std::string\n  getOriginalSourceFile(const std::string &ASTFileName, FileManager &FileMgr,\n                        const PCHContainerReader &PCHContainerRdr,\n                        DiagnosticsEngine &Diags);\n\n  /// Read the control block for the named AST file.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  static bool\n  readASTFileControlBlock(StringRef Filename, FileManager &FileMgr,\n                          const PCHContainerReader &PCHContainerRdr,\n                          bool FindModuleFileExtensions,\n                          ASTReaderListener &Listener,\n                          bool ValidateDiagnosticOptions);\n\n  /// Determine whether the given AST file is acceptable to load into a\n  /// translation unit with the given language and target options.\n  static bool isAcceptableASTFile(StringRef Filename, FileManager &FileMgr,\n                                  const PCHContainerReader &PCHContainerRdr,\n                                  const LangOptions &LangOpts,\n                                  const TargetOptions &TargetOpts,\n                                  const PreprocessorOptions &PPOpts,\n                                  StringRef ExistingModuleCachePath);\n\n  /// Returns the suggested contents of the predefines buffer,\n  /// which contains a (typically-empty) subset of the predefines\n  /// build prior to including the precompiled header.\n  const std::string &getSuggestedPredefines() { return SuggestedPredefines; }\n\n  /// Read a preallocated preprocessed entity from the external source.\n  ///\n  /// \\returns null if an error occurred that prevented the preprocessed\n  /// entity from being loaded.\n  PreprocessedEntity *ReadPreprocessedEntity(unsigned Index) override;\n\n  /// Returns a pair of [Begin, End) indices of preallocated\n  /// preprocessed entities that \\p Range encompasses.\n  std::pair<unsigned, unsigned>\n      findPreprocessedEntitiesInRange(SourceRange Range) override;\n\n  /// Optionally returns true or false if the preallocated preprocessed\n  /// entity with index \\p Index came from file \\p FID.\n  Optional<bool> isPreprocessedEntityInFileID(unsigned Index,\n                                              FileID FID) override;\n\n  /// Read a preallocated skipped range from the external source.\n  SourceRange ReadSkippedRange(unsigned Index) override;\n\n  /// Read the header file information for the given file entry.\n  HeaderFileInfo GetHeaderFileInfo(const FileEntry *FE) override;\n\n  void ReadPragmaDiagnosticMappings(DiagnosticsEngine &Diag);\n\n  /// Returns the number of source locations found in the chain.\n  unsigned getTotalNumSLocs() const {\n    return TotalNumSLocEntries;\n  }\n\n  /// Returns the number of identifiers found in the chain.\n  unsigned getTotalNumIdentifiers() const {\n    return static_cast<unsigned>(IdentifiersLoaded.size());\n  }\n\n  /// Returns the number of macros found in the chain.\n  unsigned getTotalNumMacros() const {\n    return static_cast<unsigned>(MacrosLoaded.size());\n  }\n\n  /// Returns the number of types found in the chain.\n  unsigned getTotalNumTypes() const {\n    return static_cast<unsigned>(TypesLoaded.size());\n  }\n\n  /// Returns the number of declarations found in the chain.\n  unsigned getTotalNumDecls() const {\n    return static_cast<unsigned>(DeclsLoaded.size());\n  }\n\n  /// Returns the number of submodules known.\n  unsigned getTotalNumSubmodules() const {\n    return static_cast<unsigned>(SubmodulesLoaded.size());\n  }\n\n  /// Returns the number of selectors found in the chain.\n  unsigned getTotalNumSelectors() const {\n    return static_cast<unsigned>(SelectorsLoaded.size());\n  }\n\n  /// Returns the number of preprocessed entities known to the AST\n  /// reader.\n  unsigned getTotalNumPreprocessedEntities() const {\n    unsigned Result = 0;\n    for (const auto &M : ModuleMgr)\n      Result += M.NumPreprocessedEntities;\n    return Result;\n  }\n\n  /// Resolve a type ID into a type, potentially building a new\n  /// type.\n  QualType GetType(serialization::TypeID ID);\n\n  /// Resolve a local type ID within a given AST file into a type.\n  QualType getLocalType(ModuleFile &F, unsigned LocalID);\n\n  /// Map a local type ID within a given AST file into a global type ID.\n  serialization::TypeID getGlobalTypeID(ModuleFile &F, unsigned LocalID) const;\n\n  /// Read a type from the current position in the given record, which\n  /// was read from the given AST file.\n  QualType readType(ModuleFile &F, const RecordData &Record, unsigned &Idx) {\n    if (Idx >= Record.size())\n      return {};\n\n    return getLocalType(F, Record[Idx++]);\n  }\n\n  /// Map from a local declaration ID within a given module to a\n  /// global declaration ID.\n  serialization::DeclID getGlobalDeclID(ModuleFile &F,\n                                      serialization::LocalDeclID LocalID) const;\n\n  /// Returns true if global DeclID \\p ID originated from module \\p M.\n  bool isDeclIDFromModule(serialization::GlobalDeclID ID, ModuleFile &M) const;\n\n  /// Retrieve the module file that owns the given declaration, or NULL\n  /// if the declaration is not from a module file.\n  ModuleFile *getOwningModuleFile(const Decl *D);\n\n  /// Get the best name we know for the module that owns the given\n  /// declaration, or an empty string if the declaration is not from a module.\n  std::string getOwningModuleNameForDiagnostic(const Decl *D);\n\n  /// Returns the source location for the decl \\p ID.\n  SourceLocation getSourceLocationForDeclID(serialization::GlobalDeclID ID);\n\n  /// Resolve a declaration ID into a declaration, potentially\n  /// building a new declaration.\n  Decl *GetDecl(serialization::DeclID ID);\n  Decl *GetExternalDecl(uint32_t ID) override;\n\n  /// Resolve a declaration ID into a declaration. Return 0 if it's not\n  /// been loaded yet.\n  Decl *GetExistingDecl(serialization::DeclID ID);\n\n  /// Reads a declaration with the given local ID in the given module.\n  Decl *GetLocalDecl(ModuleFile &F, uint32_t LocalID) {\n    return GetDecl(getGlobalDeclID(F, LocalID));\n  }\n\n  /// Reads a declaration with the given local ID in the given module.\n  ///\n  /// \\returns The requested declaration, casted to the given return type.\n  template<typename T>\n  T *GetLocalDeclAs(ModuleFile &F, uint32_t LocalID) {\n    return cast_or_null<T>(GetLocalDecl(F, LocalID));\n  }\n\n  /// Map a global declaration ID into the declaration ID used to\n  /// refer to this declaration within the given module fule.\n  ///\n  /// \\returns the global ID of the given declaration as known in the given\n  /// module file.\n  serialization::DeclID\n  mapGlobalIDToModuleFileGlobalID(ModuleFile &M,\n                                  serialization::DeclID GlobalID);\n\n  /// Reads a declaration ID from the given position in a record in the\n  /// given module.\n  ///\n  /// \\returns The declaration ID read from the record, adjusted to a global ID.\n  serialization::DeclID ReadDeclID(ModuleFile &F, const RecordData &Record,\n                                   unsigned &Idx);\n\n  /// Reads a declaration from the given position in a record in the\n  /// given module.\n  Decl *ReadDecl(ModuleFile &F, const RecordData &R, unsigned &I) {\n    return GetDecl(ReadDeclID(F, R, I));\n  }\n\n  /// Reads a declaration from the given position in a record in the\n  /// given module.\n  ///\n  /// \\returns The declaration read from this location, casted to the given\n  /// result type.\n  template<typename T>\n  T *ReadDeclAs(ModuleFile &F, const RecordData &R, unsigned &I) {\n    return cast_or_null<T>(GetDecl(ReadDeclID(F, R, I)));\n  }\n\n  /// If any redeclarations of \\p D have been imported since it was\n  /// last checked, this digs out those redeclarations and adds them to the\n  /// redeclaration chain for \\p D.\n  void CompleteRedeclChain(const Decl *D) override;\n\n  CXXBaseSpecifier *GetExternalCXXBaseSpecifiers(uint64_t Offset) override;\n\n  /// Resolve the offset of a statement into a statement.\n  ///\n  /// This operation will read a new statement from the external\n  /// source each time it is called, and is meant to be used via a\n  /// LazyOffsetPtr (which is used by Decls for the body of functions, etc).\n  Stmt *GetExternalDeclStmt(uint64_t Offset) override;\n\n  /// ReadBlockAbbrevs - Enter a subblock of the specified BlockID with the\n  /// specified cursor.  Read the abbreviations that are at the top of the block\n  /// and then leave the cursor pointing into the block.\n  static bool ReadBlockAbbrevs(llvm::BitstreamCursor &Cursor, unsigned BlockID,\n                               uint64_t *StartOfBlockOffset = nullptr);\n\n  /// Finds all the visible declarations with a given name.\n  /// The current implementation of this method just loads the entire\n  /// lookup table as unmaterialized references.\n  bool FindExternalVisibleDeclsByName(const DeclContext *DC,\n                                      DeclarationName Name) override;\n\n  /// Read all of the declarations lexically stored in a\n  /// declaration context.\n  ///\n  /// \\param DC The declaration context whose declarations will be\n  /// read.\n  ///\n  /// \\param IsKindWeWant A predicate indicating which declaration kinds\n  /// we are interested in.\n  ///\n  /// \\param Decls Vector that will contain the declarations loaded\n  /// from the external source. The caller is responsible for merging\n  /// these declarations with any declarations already stored in the\n  /// declaration context.\n  void\n  FindExternalLexicalDecls(const DeclContext *DC,\n                           llvm::function_ref<bool(Decl::Kind)> IsKindWeWant,\n                           SmallVectorImpl<Decl *> &Decls) override;\n\n  /// Get the decls that are contained in a file in the Offset/Length\n  /// range. \\p Length can be 0 to indicate a point at \\p Offset instead of\n  /// a range.\n  void FindFileRegionDecls(FileID File, unsigned Offset, unsigned Length,\n                           SmallVectorImpl<Decl *> &Decls) override;\n\n  /// Notify ASTReader that we started deserialization of\n  /// a decl or type so until FinishedDeserializing is called there may be\n  /// decls that are initializing. Must be paired with FinishedDeserializing.\n  void StartedDeserializing() override;\n\n  /// Notify ASTReader that we finished the deserialization of\n  /// a decl or type. Must be paired with StartedDeserializing.\n  void FinishedDeserializing() override;\n\n  /// Function that will be invoked when we begin parsing a new\n  /// translation unit involving this external AST source.\n  ///\n  /// This function will provide all of the external definitions to\n  /// the ASTConsumer.\n  void StartTranslationUnit(ASTConsumer *Consumer) override;\n\n  /// Print some statistics about AST usage.\n  void PrintStats() override;\n\n  /// Dump information about the AST reader to standard error.\n  void dump();\n\n  /// Return the amount of memory used by memory buffers, breaking down\n  /// by heap-backed versus mmap'ed memory.\n  void getMemoryBufferSizes(MemoryBufferSizes &sizes) const override;\n\n  /// Initialize the semantic source with the Sema instance\n  /// being used to perform semantic analysis on the abstract syntax\n  /// tree.\n  void InitializeSema(Sema &S) override;\n\n  /// Inform the semantic consumer that Sema is no longer available.\n  void ForgetSema() override { SemaObj = nullptr; }\n\n  /// Retrieve the IdentifierInfo for the named identifier.\n  ///\n  /// This routine builds a new IdentifierInfo for the given identifier. If any\n  /// declarations with this name are visible from translation unit scope, their\n  /// declarations will be deserialized and introduced into the declaration\n  /// chain of the identifier.\n  IdentifierInfo *get(StringRef Name) override;\n\n  /// Retrieve an iterator into the set of all identifiers\n  /// in all loaded AST files.\n  IdentifierIterator *getIdentifiers() override;\n\n  /// Load the contents of the global method pool for a given\n  /// selector.\n  void ReadMethodPool(Selector Sel) override;\n\n  /// Load the contents of the global method pool for a given\n  /// selector if necessary.\n  void updateOutOfDateSelector(Selector Sel) override;\n\n  /// Load the set of namespaces that are known to the external source,\n  /// which will be used during typo correction.\n  void ReadKnownNamespaces(\n                         SmallVectorImpl<NamespaceDecl *> &Namespaces) override;\n\n  void ReadUndefinedButUsed(\n      llvm::MapVector<NamedDecl *, SourceLocation> &Undefined) override;\n\n  void ReadMismatchingDeleteExpressions(llvm::MapVector<\n      FieldDecl *, llvm::SmallVector<std::pair<SourceLocation, bool>, 4>> &\n                                            Exprs) override;\n\n  void ReadTentativeDefinitions(\n                            SmallVectorImpl<VarDecl *> &TentativeDefs) override;\n\n  void ReadUnusedFileScopedDecls(\n                       SmallVectorImpl<const DeclaratorDecl *> &Decls) override;\n\n  void ReadDelegatingConstructors(\n                         SmallVectorImpl<CXXConstructorDecl *> &Decls) override;\n\n  void ReadExtVectorDecls(SmallVectorImpl<TypedefNameDecl *> &Decls) override;\n\n  void ReadUnusedLocalTypedefNameCandidates(\n      llvm::SmallSetVector<const TypedefNameDecl *, 4> &Decls) override;\n\n  void ReadDeclsToCheckForDeferredDiags(\n      llvm::SmallVector<Decl *, 4> &Decls) override;\n\n  void ReadReferencedSelectors(\n           SmallVectorImpl<std::pair<Selector, SourceLocation>> &Sels) override;\n\n  void ReadWeakUndeclaredIdentifiers(\n           SmallVectorImpl<std::pair<IdentifierInfo *, WeakInfo>> &WI) override;\n\n  void ReadUsedVTables(SmallVectorImpl<ExternalVTableUse> &VTables) override;\n\n  void ReadPendingInstantiations(\n                  SmallVectorImpl<std::pair<ValueDecl *,\n                                            SourceLocation>> &Pending) override;\n\n  void ReadLateParsedTemplates(\n      llvm::MapVector<const FunctionDecl *, std::unique_ptr<LateParsedTemplate>>\n          &LPTMap) override;\n\n  /// Load a selector from disk, registering its ID if it exists.\n  void LoadSelector(Selector Sel);\n\n  void SetIdentifierInfo(unsigned ID, IdentifierInfo *II);\n  void SetGloballyVisibleDecls(IdentifierInfo *II,\n                               const SmallVectorImpl<uint32_t> &DeclIDs,\n                               SmallVectorImpl<Decl *> *Decls = nullptr);\n\n  /// Report a diagnostic.\n  DiagnosticBuilder Diag(unsigned DiagID) const;\n\n  /// Report a diagnostic.\n  DiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID) const;\n\n  IdentifierInfo *DecodeIdentifierInfo(serialization::IdentifierID ID);\n\n  IdentifierInfo *readIdentifier(ModuleFile &M, const RecordData &Record,\n                                 unsigned &Idx) {\n    return DecodeIdentifierInfo(getGlobalIdentifierID(M, Record[Idx++]));\n  }\n\n  IdentifierInfo *GetIdentifier(serialization::IdentifierID ID) override {\n    // Note that we are loading an identifier.\n    Deserializing AnIdentifier(this);\n\n    return DecodeIdentifierInfo(ID);\n  }\n\n  IdentifierInfo *getLocalIdentifier(ModuleFile &M, unsigned LocalID);\n\n  serialization::IdentifierID getGlobalIdentifierID(ModuleFile &M,\n                                                    unsigned LocalID);\n\n  void resolvePendingMacro(IdentifierInfo *II, const PendingMacroInfo &PMInfo);\n\n  /// Retrieve the macro with the given ID.\n  MacroInfo *getMacro(serialization::MacroID ID);\n\n  /// Retrieve the global macro ID corresponding to the given local\n  /// ID within the given module file.\n  serialization::MacroID getGlobalMacroID(ModuleFile &M, unsigned LocalID);\n\n  /// Read the source location entry with index ID.\n  bool ReadSLocEntry(int ID) override;\n\n  /// Retrieve the module import location and module name for the\n  /// given source manager entry ID.\n  std::pair<SourceLocation, StringRef> getModuleImportLoc(int ID) override;\n\n  /// Retrieve the global submodule ID given a module and its local ID\n  /// number.\n  serialization::SubmoduleID\n  getGlobalSubmoduleID(ModuleFile &M, unsigned LocalID);\n\n  /// Retrieve the submodule that corresponds to a global submodule ID.\n  ///\n  Module *getSubmodule(serialization::SubmoduleID GlobalID);\n\n  /// Retrieve the module that corresponds to the given module ID.\n  ///\n  /// Note: overrides method in ExternalASTSource\n  Module *getModule(unsigned ID) override;\n\n  /// Retrieve the module file with a given local ID within the specified\n  /// ModuleFile.\n  ModuleFile *getLocalModuleFile(ModuleFile &M, unsigned ID);\n\n  /// Get an ID for the given module file.\n  unsigned getModuleFileID(ModuleFile *M);\n\n  /// Return a descriptor for the corresponding module.\n  llvm::Optional<ASTSourceDescriptor> getSourceDescriptor(unsigned ID) override;\n\n  ExtKind hasExternalDefinitions(const Decl *D) override;\n\n  /// Retrieve a selector from the given module with its local ID\n  /// number.\n  Selector getLocalSelector(ModuleFile &M, unsigned LocalID);\n\n  Selector DecodeSelector(serialization::SelectorID Idx);\n\n  Selector GetExternalSelector(serialization::SelectorID ID) override;\n  uint32_t GetNumExternalSelectors() override;\n\n  Selector ReadSelector(ModuleFile &M, const RecordData &Record, unsigned &Idx) {\n    return getLocalSelector(M, Record[Idx++]);\n  }\n\n  /// Retrieve the global selector ID that corresponds to this\n  /// the local selector ID in a given module.\n  serialization::SelectorID getGlobalSelectorID(ModuleFile &F,\n                                                unsigned LocalID) const;\n\n  /// Read the contents of a CXXCtorInitializer array.\n  CXXCtorInitializer **GetExternalCXXCtorInitializers(uint64_t Offset) override;\n\n  /// Read a AlignPackInfo from raw form.\n  Sema::AlignPackInfo ReadAlignPackInfo(uint32_t Raw) const {\n    return Sema::AlignPackInfo::getFromRawEncoding(Raw);\n  }\n\n  /// Read a source location from raw form and return it in its\n  /// originating module file's source location space.\n  SourceLocation ReadUntranslatedSourceLocation(uint32_t Raw) const {\n    return SourceLocation::getFromRawEncoding((Raw >> 1) | (Raw << 31));\n  }\n\n  /// Read a source location from raw form.\n  SourceLocation ReadSourceLocation(ModuleFile &ModuleFile, uint32_t Raw) const {\n    SourceLocation Loc = ReadUntranslatedSourceLocation(Raw);\n    return TranslateSourceLocation(ModuleFile, Loc);\n  }\n\n  /// Translate a source location from another module file's source\n  /// location space into ours.\n  SourceLocation TranslateSourceLocation(ModuleFile &ModuleFile,\n                                         SourceLocation Loc) const {\n    if (!ModuleFile.ModuleOffsetMap.empty())\n      ReadModuleOffsetMap(ModuleFile);\n    assert(ModuleFile.SLocRemap.find(Loc.getOffset()) !=\n               ModuleFile.SLocRemap.end() &&\n           \"Cannot find offset to remap.\");\n    int Remap = ModuleFile.SLocRemap.find(Loc.getOffset())->second;\n    return Loc.getLocWithOffset(Remap);\n  }\n\n  /// Read a source location.\n  SourceLocation ReadSourceLocation(ModuleFile &ModuleFile,\n                                    const RecordDataImpl &Record,\n                                    unsigned &Idx) {\n    return ReadSourceLocation(ModuleFile, Record[Idx++]);\n  }\n\n  /// Read a source range.\n  SourceRange ReadSourceRange(ModuleFile &F,\n                              const RecordData &Record, unsigned &Idx);\n\n  // Read a string\n  static std::string ReadString(const RecordData &Record, unsigned &Idx);\n\n  // Skip a string\n  static void SkipString(const RecordData &Record, unsigned &Idx) {\n    Idx += Record[Idx] + 1;\n  }\n\n  // Read a path\n  std::string ReadPath(ModuleFile &F, const RecordData &Record, unsigned &Idx);\n\n  // Read a path\n  std::string ReadPath(StringRef BaseDirectory, const RecordData &Record,\n                       unsigned &Idx);\n\n  // Skip a path\n  static void SkipPath(const RecordData &Record, unsigned &Idx) {\n    SkipString(Record, Idx);\n  }\n\n  /// Read a version tuple.\n  static VersionTuple ReadVersionTuple(const RecordData &Record, unsigned &Idx);\n\n  CXXTemporary *ReadCXXTemporary(ModuleFile &F, const RecordData &Record,\n                                 unsigned &Idx);\n\n  /// Reads a statement.\n  Stmt *ReadStmt(ModuleFile &F);\n\n  /// Reads an expression.\n  Expr *ReadExpr(ModuleFile &F);\n\n  /// Reads a sub-statement operand during statement reading.\n  Stmt *ReadSubStmt() {\n    assert(ReadingKind == Read_Stmt &&\n           \"Should be called only during statement reading!\");\n    // Subexpressions are stored from last to first, so the next Stmt we need\n    // is at the back of the stack.\n    assert(!StmtStack.empty() && \"Read too many sub-statements!\");\n    return StmtStack.pop_back_val();\n  }\n\n  /// Reads a sub-expression operand during statement reading.\n  Expr *ReadSubExpr();\n\n  /// Reads a token out of a record.\n  Token ReadToken(ModuleFile &M, const RecordDataImpl &Record, unsigned &Idx);\n\n  /// Reads the macro record located at the given offset.\n  MacroInfo *ReadMacroRecord(ModuleFile &F, uint64_t Offset);\n\n  /// Determine the global preprocessed entity ID that corresponds to\n  /// the given local ID within the given module.\n  serialization::PreprocessedEntityID\n  getGlobalPreprocessedEntityID(ModuleFile &M, unsigned LocalID) const;\n\n  /// Add a macro to deserialize its macro directive history.\n  ///\n  /// \\param II The name of the macro.\n  /// \\param M The module file.\n  /// \\param MacroDirectivesOffset Offset of the serialized macro directive\n  /// history.\n  void addPendingMacro(IdentifierInfo *II, ModuleFile *M,\n                       uint32_t MacroDirectivesOffset);\n\n  /// Read the set of macros defined by this external macro source.\n  void ReadDefinedMacros() override;\n\n  /// Update an out-of-date identifier.\n  void updateOutOfDateIdentifier(IdentifierInfo &II) override;\n\n  /// Note that this identifier is up-to-date.\n  void markIdentifierUpToDate(IdentifierInfo *II);\n\n  /// Load all external visible decls in the given DeclContext.\n  void completeVisibleDeclsMap(const DeclContext *DC) override;\n\n  /// Retrieve the AST context that this AST reader supplements.\n  ASTContext &getContext() {\n    assert(ContextObj && \"requested AST context when not loading AST\");\n    return *ContextObj;\n  }\n\n  // Contains the IDs for declarations that were requested before we have\n  // access to a Sema object.\n  SmallVector<uint64_t, 16> PreloadedDeclIDs;\n\n  /// Retrieve the semantic analysis object used to analyze the\n  /// translation unit in which the precompiled header is being\n  /// imported.\n  Sema *getSema() { return SemaObj; }\n\n  /// Get the identifier resolver used for name lookup / updates\n  /// in the translation unit scope. We have one of these even if we don't\n  /// have a Sema object.\n  IdentifierResolver &getIdResolver();\n\n  /// Retrieve the identifier table associated with the\n  /// preprocessor.\n  IdentifierTable &getIdentifierTable();\n\n  /// Record that the given ID maps to the given switch-case\n  /// statement.\n  void RecordSwitchCaseID(SwitchCase *SC, unsigned ID);\n\n  /// Retrieve the switch-case statement with the given ID.\n  SwitchCase *getSwitchCaseWithID(unsigned ID);\n\n  void ClearSwitchCaseIDs();\n\n  /// Cursors for comments blocks.\n  SmallVector<std::pair<llvm::BitstreamCursor,\n                        serialization::ModuleFile *>, 8> CommentsCursors;\n\n  /// Loads comments ranges.\n  void ReadComments() override;\n\n  /// Visit all the input files of the given module file.\n  void visitInputFiles(serialization::ModuleFile &MF,\n                       bool IncludeSystem, bool Complain,\n          llvm::function_ref<void(const serialization::InputFile &IF,\n                                  bool isSystem)> Visitor);\n\n  /// Visit all the top-level module maps loaded when building the given module\n  /// file.\n  void visitTopLevelModuleMaps(serialization::ModuleFile &MF,\n                               llvm::function_ref<\n                                   void(const FileEntry *)> Visitor);\n\n  bool isProcessingUpdateRecords() { return ProcessingUpdateRecords; }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SERIALIZATION_ASTREADER_H\n"}}, "reports": [{"events": [{"location": {"col": 17, "file": 2, "line": 3747}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 1363}, "message": "differing parameters are named here: ('Canon'), in definition: ('D')"}, {"location": {"col": 8, "file": 1, "line": 1363}, "message": "function 'clang::ASTReader::markIncompleteDeclChain' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTReader.h", "reportHash": "1b5a636821cb7551cd194bac35671ce6", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 2, "line": 4229}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 1373}, "message": "differing parameters are named here: ('D'), in definition: ('FirstLocal')"}, {"location": {"col": 8, "file": 1, "line": 1373}, "message": "function 'clang::ASTReader::loadPendingDeclChain' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTReader.h", "reportHash": "6fe4466aabf7ad9166f87e0f9855f0ba", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
