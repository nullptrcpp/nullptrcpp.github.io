<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/build/projects/openmp/runtime/src/kmp_config.h", "content": "/*\n * kmp_config.h -- Feature macros\n */\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n#ifndef KMP_CONFIG_H\n#define KMP_CONFIG_H\n\n#include \"kmp_platform.h\"\n\n// cmakedefine01 MACRO will define MACRO as either 0 or 1\n// cmakedefine MACRO 1 will define MACRO as 1 or leave undefined\n#define DEBUG_BUILD 0\n#define RELWITHDEBINFO_BUILD 0\n#define LIBOMP_USE_ITT_NOTIFY 1\n#define USE_ITT_NOTIFY LIBOMP_USE_ITT_NOTIFY\n#if ! LIBOMP_USE_ITT_NOTIFY\n# define INTEL_NO_ITTNOTIFY_API\n#endif\n#define LIBOMP_USE_VERSION_SYMBOLS 1\n#if LIBOMP_USE_VERSION_SYMBOLS\n# define KMP_USE_VERSION_SYMBOLS\n#endif\n#define LIBOMP_HAVE_WEAK_ATTRIBUTE 1\n#define KMP_HAVE_WEAK_ATTRIBUTE LIBOMP_HAVE_WEAK_ATTRIBUTE\n#define LIBOMP_HAVE_PSAPI 0\n#define KMP_HAVE_PSAPI LIBOMP_HAVE_PSAPI\n#define LIBOMP_STATS 0\n#define KMP_STATS_ENABLED LIBOMP_STATS\n#define LIBOMP_HAVE_X86INTRIN_H 0\n#define KMP_HAVE_X86INTRIN_H LIBOMP_HAVE_X86INTRIN_H\n#define LIBOMP_HAVE___BUILTIN_READCYCLECOUNTER 0\n#define KMP_HAVE___BUILTIN_READCYCLECOUNTER LIBOMP_HAVE___BUILTIN_READCYCLECOUNTER\n#define LIBOMP_HAVE___RDTSC 0\n#define KMP_HAVE___RDTSC LIBOMP_HAVE___RDTSC\n#define LIBOMP_USE_DEBUGGER 0\n#define USE_DEBUGGER LIBOMP_USE_DEBUGGER\n#define LIBOMP_OMPT_DEBUG 0\n#define OMPT_DEBUG LIBOMP_OMPT_DEBUG\n#define LIBOMP_OMPT_SUPPORT 1\n#define OMPT_SUPPORT LIBOMP_OMPT_SUPPORT\n#define LIBOMP_PROFILING_SUPPORT 0\n#define OMP_PROFILING_SUPPORT LIBOMP_PROFILING_SUPPORT\n#define LIBOMP_OMPT_OPTIONAL 1\n#define OMPT_OPTIONAL LIBOMP_OMPT_OPTIONAL\n#define LIBOMP_USE_ADAPTIVE_LOCKS 1\n#define KMP_USE_ADAPTIVE_LOCKS LIBOMP_USE_ADAPTIVE_LOCKS\n#define KMP_DEBUG_ADAPTIVE_LOCKS 0\n#define LIBOMP_USE_INTERNODE_ALIGNMENT 0\n#define KMP_USE_INTERNODE_ALIGNMENT LIBOMP_USE_INTERNODE_ALIGNMENT\n#define LIBOMP_ENABLE_ASSERTIONS 0\n#define KMP_USE_ASSERT LIBOMP_ENABLE_ASSERTIONS\n#define LIBOMP_USE_HIER_SCHED 0\n#define KMP_USE_HIER_SCHED LIBOMP_USE_HIER_SCHED\n#define STUBS_LIBRARY 0\n#define LIBOMP_USE_HWLOC 0\n#define KMP_USE_HWLOC LIBOMP_USE_HWLOC\n#define LIBOMP_ENABLE_SHARED 1\n#define KMP_DYNAMIC_LIB LIBOMP_ENABLE_SHARED\n#define KMP_ARCH_STR \"Intel(R) 64\"\n#define KMP_LIBRARY_FILE \"libomp.so\"\n#define KMP_VERSION_MAJOR 5\n#define KMP_VERSION_MINOR 0\n#define LIBOMP_TSAN_SUPPORT 0\n#if LIBOMP_TSAN_SUPPORT\n#define TSAN_SUPPORT\n#endif\n#define MSVC 0\n#define KMP_MSVC_COMPAT MSVC\n#define LIBOMP_HAVE_WAITPKG_INTRINSICS 1\n#define KMP_HAVE_WAITPKG_INTRINSICS LIBOMP_HAVE_WAITPKG_INTRINSICS\n#define LIBOMP_HAVE_RTM_INTRINSICS 1\n#define KMP_HAVE_RTM_INTRINSICS LIBOMP_HAVE_RTM_INTRINSICS\n#define LIBOMP_HAVE_IMMINTRIN_H 1\n#define KMP_HAVE_IMMINTRIN_H LIBOMP_HAVE_IMMINTRIN_H\n#define LIBOMP_HAVE_INTRIN_H 0\n#define KMP_HAVE_INTRIN_H LIBOMP_HAVE_INTRIN_H\n#define LIBOMP_HAVE_ATTRIBUTE_WAITPKG 1\n#define KMP_HAVE_ATTRIBUTE_WAITPKG LIBOMP_HAVE_ATTRIBUTE_WAITPKG\n#define LIBOMP_HAVE_ATTRIBUTE_RTM 1\n#define KMP_HAVE_ATTRIBUTE_RTM LIBOMP_HAVE_ATTRIBUTE_RTM\n#define LIBOMP_ARCH_AARCH64_A64FX 0\n#define KMP_ARCH_AARCH64_A64FX LIBOMP_ARCH_AARCH64_A64FX\n\n// Configured cache line based on architecture\n#if KMP_ARCH_PPC64\n# define CACHE_LINE 128\n#elif KMP_ARCH_AARCH64_A64FX\n# define CACHE_LINE 256\n#else\n# define CACHE_LINE 64\n#endif\n\n#if ! KMP_32_BIT_ARCH\n# define BUILD_I8 1\n#endif\n\n#define KMP_NESTED_HOT_TEAMS 1\n#define KMP_ADJUST_BLOCKTIME 1\n#define BUILD_PARALLEL_ORDERED 1\n#define KMP_ASM_INTRINS 1\n#define USE_ITT_BUILD LIBOMP_USE_ITT_NOTIFY\n#define INTEL_ITTNOTIFY_PREFIX __kmp_itt_\n#if ! KMP_MIC\n# define USE_LOAD_BALANCE 1\n#endif\n#if ! (KMP_OS_WINDOWS || KMP_OS_DARWIN)\n# define KMP_TDATA_GTID 1\n#endif\n#if STUBS_LIBRARY\n# define KMP_STUB 1\n#endif\n#if DEBUG_BUILD || RELWITHDEBINFO_BUILD\n# define KMP_DEBUG 1\n#endif\n\n#if KMP_OS_WINDOWS\n# define KMP_WIN_CDECL\n#else\n# define BUILD_TV\n# define KMP_GOMP_COMPAT\n#endif\n\n#endif // KMP_CONFIG_H\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/build/projects/openmp/runtime/src/omp-tools.h", "content": "/*\n * include/omp-tools.h.var\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __OMPT__\n#define __OMPT__\n\n/*****************************************************************************\n * system include files\n *****************************************************************************/\n\n#include <stdint.h>\n#include <stddef.h>\n\n#ifdef DEPRECATION_WARNINGS \n# ifdef __cplusplus\n# define DEPRECATED_51 [[deprecated(\"as of 5.1\")]]\n# else\n# define DEPRECATED_51 __attribute__((deprecated(\"as of 5.1\")))\n#endif\n#else\n#define DEPRECATED_51\n#endif\n\n/*****************************************************************************\n * iteration macros\n *****************************************************************************/\n\n#define FOREACH_OMPT_INQUIRY_FN(macro)      \\\n    macro (ompt_enumerate_states)           \\\n    macro (ompt_enumerate_mutex_impls)      \\\n                                            \\\n    macro (ompt_set_callback)               \\\n    macro (ompt_get_callback)               \\\n                                            \\\n    macro (ompt_get_state)                  \\\n                                            \\\n    macro (ompt_get_parallel_info)          \\\n    macro (ompt_get_task_info)              \\\n    macro (ompt_get_task_memory)            \\\n    macro (ompt_get_thread_data)            \\\n    macro (ompt_get_unique_id)              \\\n    macro (ompt_finalize_tool)              \\\n                                            \\\n    macro(ompt_get_num_procs)               \\\n    macro(ompt_get_num_places)              \\\n    macro(ompt_get_place_proc_ids)          \\\n    macro(ompt_get_place_num)               \\\n    macro(ompt_get_partition_place_nums)    \\\n    macro(ompt_get_proc_id)                 \\\n                                            \\\n    macro(ompt_get_target_info)             \\\n    macro(ompt_get_num_devices)\n\n#define FOREACH_OMPT_STATE(macro)                                                                \\\n                                                                                                \\\n    /* first available state */                                                                 \\\n    macro (ompt_state_undefined, 0x102)      /* undefined thread state */                        \\\n                                                                                                \\\n    /* work states (0..15) */                                                                   \\\n    macro (ompt_state_work_serial, 0x000)    /* working outside parallel */                      \\\n    macro (ompt_state_work_parallel, 0x001)  /* working within parallel */                       \\\n    macro (ompt_state_work_reduction, 0x002) /* performing a reduction */                        \\\n                                                                                                \\\n    /* barrier wait states (16..31) */                                                          \\\n    macro (ompt_state_wait_barrier, 0x010)   /* waiting at a barrier */                          \\\n    macro (ompt_state_wait_barrier_implicit_parallel, 0x011)                                     \\\n                                            /* implicit barrier at the end of parallel region */\\\n    macro (ompt_state_wait_barrier_implicit_workshare, 0x012)                                    \\\n                                            /* implicit barrier at the end of worksharing */    \\\n    macro (ompt_state_wait_barrier_implicit, 0x013)  /* implicit barrier */                      \\\n    macro (ompt_state_wait_barrier_explicit, 0x014)  /* explicit barrier */                      \\\n                                                                                                \\\n    /* task wait states (32..63) */                                                             \\\n    macro (ompt_state_wait_taskwait, 0x020)  /* waiting at a taskwait */                         \\\n    macro (ompt_state_wait_taskgroup, 0x021) /* waiting at a taskgroup */                        \\\n                                                                                                \\\n    /* mutex wait states (64..127) */                                                           \\\n    macro (ompt_state_wait_mutex, 0x040)                                                         \\\n    macro (ompt_state_wait_lock, 0x041)      /* waiting for lock */                              \\\n    macro (ompt_state_wait_critical, 0x042)  /* waiting for critical */                          \\\n    macro (ompt_state_wait_atomic, 0x043)    /* waiting for atomic */                            \\\n    macro (ompt_state_wait_ordered, 0x044)   /* waiting for ordered */                           \\\n                                                                                                \\\n    /* target wait states (128..255) */                                                         \\\n    macro (ompt_state_wait_target, 0x080)        /* waiting for target region */                 \\\n    macro (ompt_state_wait_target_map, 0x081)    /* waiting for target data mapping operation */ \\\n    macro (ompt_state_wait_target_update, 0x082) /* waiting for target update operation */       \\\n                                                                                                \\\n    /* misc (256..511) */                                                                       \\\n    macro (ompt_state_idle, 0x100)           /* waiting for work */                              \\\n    macro (ompt_state_overhead, 0x101)       /* overhead excluding wait states */                \\\n                                                                                                \\\n    /* implementation-specific states (512..) */\n\n\n#define FOREACH_KMP_MUTEX_IMPL(macro)                                                \\\n    macro (kmp_mutex_impl_none, 0)         /* unknown implementation */              \\\n    macro (kmp_mutex_impl_spin, 1)         /* based on spin */                       \\\n    macro (kmp_mutex_impl_queuing, 2)      /* based on some fair policy */           \\\n    macro (kmp_mutex_impl_speculative, 3)  /* based on HW-supported speculation */\n\n#define FOREACH_OMPT_EVENT(macro)                                                                                        \\\n                                                                                                                         \\\n    /*--- Mandatory Events ---*/                                                                                         \\\n    macro (ompt_callback_thread_begin,      ompt_callback_thread_begin_t,       1) /* thread begin                    */ \\\n    macro (ompt_callback_thread_end,        ompt_callback_thread_end_t,         2) /* thread end                      */ \\\n                                                                                                                         \\\n    macro (ompt_callback_parallel_begin,    ompt_callback_parallel_begin_t,     3) /* parallel begin                  */ \\\n    macro (ompt_callback_parallel_end,      ompt_callback_parallel_end_t,       4) /* parallel end                    */ \\\n                                                                                                                         \\\n    macro (ompt_callback_task_create,       ompt_callback_task_create_t,        5) /* task begin                      */ \\\n    macro (ompt_callback_task_schedule,     ompt_callback_task_schedule_t,      6) /* task schedule                   */ \\\n    macro (ompt_callback_implicit_task,     ompt_callback_implicit_task_t,      7) /* implicit task                   */ \\\n                                                                                                                         \\\n    macro (ompt_callback_target,            ompt_callback_target_t,             8) /* target                          */ \\\n    macro (ompt_callback_target_data_op,    ompt_callback_target_data_op_t,     9) /* target data op                  */ \\\n    macro (ompt_callback_target_submit,     ompt_callback_target_submit_t,     10) /* target  submit                  */ \\\n                                                                                                                         \\\n    macro (ompt_callback_control_tool,      ompt_callback_control_tool_t,      11) /* control tool                    */ \\\n                                                                                                                         \\\n    macro (ompt_callback_device_initialize, ompt_callback_device_initialize_t, 12) /* device initialize               */ \\\n    macro (ompt_callback_device_finalize,   ompt_callback_device_finalize_t,   13) /* device finalize                 */ \\\n                                                                                                                         \\\n    macro (ompt_callback_device_load,       ompt_callback_device_load_t,       14) /* device load                     */ \\\n    macro (ompt_callback_device_unload,     ompt_callback_device_unload_t,     15) /* device unload                   */ \\\n                                                                                                                         \\\n    /* Optional Events */                                                                                                \\\n    macro (ompt_callback_sync_region_wait,  ompt_callback_sync_region_t,       16) /* sync region wait begin or end   */ \\\n                                                                                                                         \\\n    macro (ompt_callback_mutex_released,    ompt_callback_mutex_t,             17) /* mutex released                  */ \\\n                                                                                                                         \\\n    macro (ompt_callback_dependences,       ompt_callback_dependences_t,       18) /* report task dependences         */ \\\n    macro (ompt_callback_task_dependence,   ompt_callback_task_dependence_t,   19) /* report task dependence          */ \\\n                                                                                                                         \\\n    macro (ompt_callback_work,              ompt_callback_work_t,              20) /* task at work begin or end       */ \\\n                                                                                                                         \\\n    macro (ompt_callback_masked,            ompt_callback_masked_t,            21) /* task at masked begin or end     */ \\\n                                                                                                                         \\\n    macro (ompt_callback_target_map,        ompt_callback_target_map_t,        22) /* target map                      */ \\\n                                                                                                                         \\\n    macro (ompt_callback_sync_region,       ompt_callback_sync_region_t,       23) /* sync region begin or end        */ \\\n                                                                                                                         \\\n    macro (ompt_callback_lock_init,         ompt_callback_mutex_acquire_t,     24) /* lock init                       */ \\\n    macro (ompt_callback_lock_destroy,      ompt_callback_mutex_t,             25) /* lock destroy                    */ \\\n                                                                                                                         \\\n    macro (ompt_callback_mutex_acquire,     ompt_callback_mutex_acquire_t,     26) /* mutex acquire                   */ \\\n    macro (ompt_callback_mutex_acquired,    ompt_callback_mutex_t,             27) /* mutex acquired                  */ \\\n                                                                                                                         \\\n    macro (ompt_callback_nest_lock,         ompt_callback_nest_lock_t,         28) /* nest lock                       */ \\\n                                                                                                                         \\\n    macro (ompt_callback_flush,             ompt_callback_flush_t,             29) /* after executing flush           */ \\\n                                                                                                                         \\\n    macro (ompt_callback_cancel,            ompt_callback_cancel_t,            30) /* cancel innermost binding region */ \\\n                                                                                                                         \\\n    macro (ompt_callback_reduction,         ompt_callback_sync_region_t,       31) /* reduction                       */ \\\n                                                                                                                         \\\n    macro (ompt_callback_dispatch,          ompt_callback_dispatch_t,          32) /* dispatch of work                */ \\\n    macro (ompt_callback_target_emi,        ompt_callback_target_emi_t,        33) /* target                          */ \\\n    macro (ompt_callback_target_data_op_emi,ompt_callback_target_data_op_emi_t,34) /* target data op                  */ \\\n    macro (ompt_callback_target_submit_emi, ompt_callback_target_submit_emi_t, 35) /* target submit                   */ \\\n    macro (ompt_callback_target_map_emi,    ompt_callback_target_map_emi_t,    36) /* target map                      */ \\\n    macro (ompt_callback_error,             ompt_callback_error_t,             37) /* error                           */\n\n/*****************************************************************************\n * implementation specific types\n *****************************************************************************/\n\ntypedef enum kmp_mutex_impl_t {\n#define kmp_mutex_impl_macro(impl, code) impl = code,\n    FOREACH_KMP_MUTEX_IMPL(kmp_mutex_impl_macro)\n#undef kmp_mutex_impl_macro\n} kmp_mutex_impl_t;\n\n/*****************************************************************************\n * definitions generated from spec\n *****************************************************************************/\n\ntypedef enum ompt_callbacks_t {\n  ompt_callback_thread_begin             = 1,\n  ompt_callback_thread_end               = 2,\n  ompt_callback_parallel_begin           = 3,\n  ompt_callback_parallel_end             = 4,\n  ompt_callback_task_create              = 5,\n  ompt_callback_task_schedule            = 6,\n  ompt_callback_implicit_task            = 7,\n  ompt_callback_target                   = 8,\n  ompt_callback_target_data_op           = 9,\n  ompt_callback_target_submit            = 10,\n  ompt_callback_control_tool             = 11,\n  ompt_callback_device_initialize        = 12,\n  ompt_callback_device_finalize          = 13,\n  ompt_callback_device_load              = 14,\n  ompt_callback_device_unload            = 15,\n  ompt_callback_sync_region_wait         = 16,\n  ompt_callback_mutex_released           = 17,\n  ompt_callback_dependences              = 18,\n  ompt_callback_task_dependence          = 19,\n  ompt_callback_work                     = 20,\n  ompt_callback_master     DEPRECATED_51 = 21,\n  ompt_callback_masked                   = 21,\n  ompt_callback_target_map               = 22,\n  ompt_callback_sync_region              = 23,\n  ompt_callback_lock_init                = 24,\n  ompt_callback_lock_destroy             = 25,\n  ompt_callback_mutex_acquire            = 26,\n  ompt_callback_mutex_acquired           = 27,\n  ompt_callback_nest_lock                = 28,\n  ompt_callback_flush                    = 29,\n  ompt_callback_cancel                   = 30,\n  ompt_callback_reduction                = 31,\n  ompt_callback_dispatch                 = 32,\n  ompt_callback_target_emi               = 33,\n  ompt_callback_target_data_op_emi       = 34,\n  ompt_callback_target_submit_emi        = 35,\n  ompt_callback_target_map_emi           = 36,\n  ompt_callback_error                    = 37\n} ompt_callbacks_t;\n\ntypedef enum ompt_record_t {\n  ompt_record_ompt               = 1,\n  ompt_record_native             = 2,\n  ompt_record_invalid            = 3\n} ompt_record_t;\n\ntypedef enum ompt_record_native_t {\n  ompt_record_native_info  = 1,\n  ompt_record_native_event = 2\n} ompt_record_native_t;\n\ntypedef enum ompt_set_result_t {\n  ompt_set_error            = 0,\n  ompt_set_never            = 1,\n  ompt_set_impossible       = 2,\n  ompt_set_sometimes        = 3,\n  ompt_set_sometimes_paired = 4,\n  ompt_set_always           = 5\n} ompt_set_result_t;\n\ntypedef uint64_t ompt_id_t;\n\ntypedef uint64_t ompt_device_time_t;\n\ntypedef uint64_t ompt_buffer_cursor_t;\n\ntypedef enum ompt_thread_t {\n  ompt_thread_initial                 = 1,\n  ompt_thread_worker                  = 2,\n  ompt_thread_other                   = 3,\n  ompt_thread_unknown                 = 4\n} ompt_thread_t;\n\ntypedef enum ompt_scope_endpoint_t {\n  ompt_scope_begin                    = 1,\n  ompt_scope_end                      = 2,\n  ompt_scope_beginend                 = 3\n} ompt_scope_endpoint_t;\n\ntypedef enum ompt_dispatch_t {\n  ompt_dispatch_iteration             = 1,\n  ompt_dispatch_section               = 2\n} ompt_dispatch_t;\n\ntypedef enum ompt_sync_region_t {\n  ompt_sync_region_barrier                DEPRECATED_51 = 1,\n  ompt_sync_region_barrier_implicit       DEPRECATED_51 = 2,\n  ompt_sync_region_barrier_explicit       = 3,\n  ompt_sync_region_barrier_implementation = 4,\n  ompt_sync_region_taskwait               = 5,\n  ompt_sync_region_taskgroup              = 6,\n  ompt_sync_region_reduction              = 7,\n  ompt_sync_region_barrier_implicit_workshare = 8,\n  ompt_sync_region_barrier_implicit_parallel = 9,\n  ompt_sync_region_barrier_teams = 10\n} ompt_sync_region_t;\n\ntypedef enum ompt_target_data_op_t {\n  ompt_target_data_alloc                      = 1,\n  ompt_target_data_transfer_to_device         = 2,\n  ompt_target_data_transfer_from_device       = 3,\n  ompt_target_data_delete                     = 4,\n  ompt_target_data_associate                  = 5,\n  ompt_target_data_disassociate               = 6,\n  ompt_target_data_alloc_async                = 17,\n  ompt_target_data_transfer_to_device_async   = 18,\n  ompt_target_data_transfer_from_device_async = 19,\n  ompt_target_data_delete_async               = 20\n} ompt_target_data_op_t;\n\ntypedef enum ompt_work_t {\n  ompt_work_loop               = 1,\n  ompt_work_sections           = 2,\n  ompt_work_single_executor    = 3,\n  ompt_work_single_other       = 4,\n  ompt_work_workshare          = 5,\n  ompt_work_distribute         = 6,\n  ompt_work_taskloop           = 7,\n  ompt_work_scope              = 8\n} ompt_work_t;\n\ntypedef enum ompt_mutex_t {\n  ompt_mutex_lock                     = 1,\n  ompt_mutex_test_lock                = 2,\n  ompt_mutex_nest_lock                = 3,\n  ompt_mutex_test_nest_lock           = 4,\n  ompt_mutex_critical                 = 5,\n  ompt_mutex_atomic                   = 6,\n  ompt_mutex_ordered                  = 7\n} ompt_mutex_t;\n\ntypedef enum ompt_native_mon_flag_t {\n  ompt_native_data_motion_explicit    = 0x01,\n  ompt_native_data_motion_implicit    = 0x02,\n  ompt_native_kernel_invocation       = 0x04,\n  ompt_native_kernel_execution        = 0x08,\n  ompt_native_driver                  = 0x10,\n  ompt_native_runtime                 = 0x20,\n  ompt_native_overhead                = 0x40,\n  ompt_native_idleness                = 0x80\n} ompt_native_mon_flag_t;\n\ntypedef enum ompt_task_flag_t {\n  ompt_task_initial                   = 0x00000001,\n  ompt_task_implicit                  = 0x00000002,\n  ompt_task_explicit                  = 0x00000004,\n  ompt_task_target                    = 0x00000008,\n  ompt_task_taskwait                  = 0x00000010,\n  ompt_task_undeferred                = 0x08000000,\n  ompt_task_untied                    = 0x10000000,\n  ompt_task_final                     = 0x20000000,\n  ompt_task_mergeable                 = 0x40000000,\n  ompt_task_merged                    = 0x80000000\n} ompt_task_flag_t;\n\ntypedef enum ompt_task_status_t {\n  ompt_task_complete      = 1,\n  ompt_task_yield         = 2,\n  ompt_task_cancel        = 3,\n  ompt_task_detach        = 4,\n  ompt_task_early_fulfill = 5,\n  ompt_task_late_fulfill  = 6,\n  ompt_task_switch        = 7,\n  ompt_taskwait_complete  = 8\n} ompt_task_status_t;\n\ntypedef enum ompt_target_t {\n  ompt_target                         = 1,\n  ompt_target_enter_data              = 2,\n  ompt_target_exit_data               = 3,\n  ompt_target_update                  = 4,\n  ompt_target_nowait                  = 9,\n  ompt_target_enter_data_nowait       = 10,\n  ompt_target_exit_data_nowait        = 11,\n  ompt_target_update_nowait           = 12\n} ompt_target_t;\n\ntypedef enum ompt_parallel_flag_t {\n  ompt_parallel_invoker_program = 0x00000001,\n  ompt_parallel_invoker_runtime = 0x00000002,\n  ompt_parallel_league          = 0x40000000,\n  ompt_parallel_team            = 0x80000000\n} ompt_parallel_flag_t;\n\ntypedef enum ompt_target_map_flag_t {\n  ompt_target_map_flag_to             = 0x01,\n  ompt_target_map_flag_from           = 0x02,\n  ompt_target_map_flag_alloc          = 0x04,\n  ompt_target_map_flag_release        = 0x08,\n  ompt_target_map_flag_delete         = 0x10,\n  ompt_target_map_flag_implicit       = 0x20\n} ompt_target_map_flag_t;\n\ntypedef enum ompt_dependence_type_t {\n  ompt_dependence_type_in              = 1,\n  ompt_dependence_type_out             = 2,\n  ompt_dependence_type_inout           = 3,\n  ompt_dependence_type_mutexinoutset   = 4,\n  ompt_dependence_type_source          = 5,\n  ompt_dependence_type_sink            = 6,\n  ompt_dependence_type_inoutset        = 7\n} ompt_dependence_type_t;\n\ntypedef enum ompt_severity_t {\n  ompt_warning                         = 1,\n  ompt_fatal                           = 2\n} ompt_severity_t;\n\ntypedef enum ompt_cancel_flag_t {\n  ompt_cancel_parallel       = 0x01,\n  ompt_cancel_sections       = 0x02,\n  ompt_cancel_loop           = 0x04,\n  ompt_cancel_taskgroup      = 0x08,\n  ompt_cancel_activated      = 0x10,\n  ompt_cancel_detected       = 0x20,\n  ompt_cancel_discarded_task = 0x40\n} ompt_cancel_flag_t;\n\ntypedef uint64_t ompt_hwid_t;\n\ntypedef uint64_t ompt_wait_id_t;\n\ntypedef enum ompt_frame_flag_t {\n  ompt_frame_runtime        = 0x00,\n  ompt_frame_application    = 0x01,\n  ompt_frame_cfa            = 0x10,\n  ompt_frame_framepointer   = 0x20,\n  ompt_frame_stackaddress   = 0x30\n} ompt_frame_flag_t;\n\ntypedef enum ompt_state_t {\n  ompt_state_work_serial                      = 0x000,\n  ompt_state_work_parallel                    = 0x001,\n  ompt_state_work_reduction                   = 0x002,\n\n  ompt_state_wait_barrier                     DEPRECATED_51 = 0x010,\n  ompt_state_wait_barrier_implicit_parallel   = 0x011,\n  ompt_state_wait_barrier_implicit_workshare  = 0x012,\n  ompt_state_wait_barrier_implicit            DEPRECATED_51 = 0x013,\n  ompt_state_wait_barrier_explicit            = 0x014,\n  ompt_state_wait_barrier_implementation      = 0x015,\n  ompt_state_wait_barrier_teams               = 0x016,\n\n  ompt_state_wait_taskwait                    = 0x020,\n  ompt_state_wait_taskgroup                   = 0x021,\n\n  ompt_state_wait_mutex                       = 0x040,\n  ompt_state_wait_lock                        = 0x041,\n  ompt_state_wait_critical                    = 0x042,\n  ompt_state_wait_atomic                      = 0x043,\n  ompt_state_wait_ordered                     = 0x044,\n\n  ompt_state_wait_target                      = 0x080,\n  ompt_state_wait_target_map                  = 0x081,\n  ompt_state_wait_target_update               = 0x082,\n\n  ompt_state_idle                             = 0x100,\n  ompt_state_overhead                         = 0x101,\n  ompt_state_undefined                        = 0x102\n} ompt_state_t;\n\ntypedef uint64_t (*ompt_get_unique_id_t) (void);\n\ntypedef uint64_t ompd_size_t;\n\ntypedef uint64_t ompd_wait_id_t;\n\ntypedef uint64_t ompd_addr_t;\ntypedef int64_t  ompd_word_t;\ntypedef uint64_t ompd_seg_t;\n\ntypedef uint64_t ompd_device_t;\n\ntypedef uint64_t ompd_thread_id_t;\n\ntypedef enum ompd_scope_t {\n  ompd_scope_global = 1,\n  ompd_scope_address_space = 2,\n  ompd_scope_thread = 3,\n  ompd_scope_parallel = 4,\n  ompd_scope_implicit_task = 5,\n  ompd_scope_task = 6\n} ompd_scope_t;\n\ntypedef uint64_t ompd_icv_id_t;\n\ntypedef enum ompd_rc_t {\n  ompd_rc_ok = 0,\n  ompd_rc_unavailable = 1,\n  ompd_rc_stale_handle = 2,\n  ompd_rc_bad_input = 3,\n  ompd_rc_error = 4,\n  ompd_rc_unsupported = 5,\n  ompd_rc_needs_state_tracking = 6,\n  ompd_rc_incompatible = 7,\n  ompd_rc_device_read_error = 8,\n  ompd_rc_device_write_error = 9,\n  ompd_rc_nomem = 10,\n} ompd_rc_t;\n\ntypedef void (*ompt_interface_fn_t) (void);\n\ntypedef ompt_interface_fn_t (*ompt_function_lookup_t) (\n  const char *interface_function_name\n);\n\ntypedef union ompt_data_t {\n  uint64_t value;\n  void *ptr;\n} ompt_data_t;\n\ntypedef struct ompt_frame_t {\n  ompt_data_t exit_frame;\n  ompt_data_t enter_frame;\n  int exit_frame_flags;\n  int enter_frame_flags;\n} ompt_frame_t;\n\ntypedef void (*ompt_callback_t) (void);\n\ntypedef void ompt_device_t;\n\ntypedef void ompt_buffer_t;\n\ntypedef void (*ompt_callback_buffer_request_t) (\n  int device_num,\n  ompt_buffer_t **buffer,\n  size_t *bytes\n);\n\ntypedef void (*ompt_callback_buffer_complete_t) (\n  int device_num,\n  ompt_buffer_t *buffer,\n  size_t bytes,\n  ompt_buffer_cursor_t begin,\n  int buffer_owned\n);\n\ntypedef void (*ompt_finalize_t) (\n  ompt_data_t *tool_data\n);\n\ntypedef int (*ompt_initialize_t) (\n  ompt_function_lookup_t lookup,\n  int initial_device_num,\n  ompt_data_t *tool_data\n);\n\ntypedef struct ompt_start_tool_result_t {\n  ompt_initialize_t initialize;\n  ompt_finalize_t finalize;\n  ompt_data_t tool_data;\n} ompt_start_tool_result_t;\n\ntypedef struct ompt_record_abstract_t {\n  ompt_record_native_t rclass;\n  const char *type;\n  ompt_device_time_t start_time;\n  ompt_device_time_t end_time;\n  ompt_hwid_t hwid;\n} ompt_record_abstract_t;\n\ntypedef struct ompt_dependence_t {\n  ompt_data_t variable;\n  ompt_dependence_type_t dependence_type;\n} ompt_dependence_t;\n\ntypedef int (*ompt_enumerate_states_t) (\n  int current_state,\n  int *next_state,\n  const char **next_state_name\n);\n\ntypedef int (*ompt_enumerate_mutex_impls_t) (\n  int current_impl,\n  int *next_impl,\n  const char **next_impl_name\n);\n\ntypedef ompt_set_result_t (*ompt_set_callback_t) (\n  ompt_callbacks_t event,\n  ompt_callback_t callback\n);\n\ntypedef int (*ompt_get_callback_t) (\n  ompt_callbacks_t event,\n  ompt_callback_t *callback\n);\n\ntypedef ompt_data_t *(*ompt_get_thread_data_t) (void);\n\ntypedef int (*ompt_get_num_procs_t) (void);\n\ntypedef int (*ompt_get_num_places_t) (void);\n\ntypedef int (*ompt_get_place_proc_ids_t) (\n  int place_num,\n  int ids_size,\n  int *ids\n);\n\ntypedef int (*ompt_get_place_num_t) (void);\n\ntypedef int (*ompt_get_partition_place_nums_t) (\n  int place_nums_size,\n  int *place_nums\n);\n\ntypedef int (*ompt_get_proc_id_t) (void);\n\ntypedef int (*ompt_get_state_t) (\n  ompt_wait_id_t *wait_id\n);\n\ntypedef int (*ompt_get_parallel_info_t) (\n  int ancestor_level,\n  ompt_data_t **parallel_data,\n  int *team_size\n);\n\ntypedef int (*ompt_get_task_info_t) (\n  int ancestor_level,\n  int *flags,\n  ompt_data_t **task_data,\n  ompt_frame_t **task_frame,\n  ompt_data_t **parallel_data,\n  int *thread_num\n);\n\ntypedef int (*ompt_get_task_memory_t)(\n  void **addr,\n  size_t *size,\n  int block\n);\n\ntypedef int (*ompt_get_target_info_t) (\n  uint64_t *device_num,\n  ompt_id_t *target_id,\n  ompt_id_t *host_op_id\n);\n\ntypedef int (*ompt_get_num_devices_t) (void);\n\ntypedef void (*ompt_finalize_tool_t) (void);\n\ntypedef int (*ompt_get_device_num_procs_t) (\n  ompt_device_t *device\n);\n\ntypedef ompt_device_time_t (*ompt_get_device_time_t) (\n  ompt_device_t *device\n);\n\ntypedef double (*ompt_translate_time_t) (\n  ompt_device_t *device,\n  ompt_device_time_t time\n);\n\ntypedef ompt_set_result_t (*ompt_set_trace_ompt_t) (\n  ompt_device_t *device,\n  unsigned int enable,\n  unsigned int etype\n);\n\ntypedef ompt_set_result_t (*ompt_set_trace_native_t) (\n  ompt_device_t *device,\n  int enable,\n  int flags\n);\n\ntypedef int (*ompt_start_trace_t) (\n  ompt_device_t *device,\n  ompt_callback_buffer_request_t request,\n  ompt_callback_buffer_complete_t complete\n);\n\ntypedef int (*ompt_pause_trace_t) (\n  ompt_device_t *device,\n  int begin_pause\n);\n\ntypedef int (*ompt_flush_trace_t) (\n  ompt_device_t *device\n);\n\ntypedef int (*ompt_stop_trace_t) (\n  ompt_device_t *device\n);\n\ntypedef int (*ompt_advance_buffer_cursor_t) (\n  ompt_device_t *device,\n  ompt_buffer_t *buffer,\n  size_t size,\n  ompt_buffer_cursor_t current,\n  ompt_buffer_cursor_t *next\n);\n\ntypedef ompt_record_t (*ompt_get_record_type_t) (\n  ompt_buffer_t *buffer,\n  ompt_buffer_cursor_t current\n);\n\ntypedef void *(*ompt_get_record_native_t) (\n  ompt_buffer_t *buffer,\n  ompt_buffer_cursor_t current,\n  ompt_id_t *host_op_id\n);\n\ntypedef ompt_record_abstract_t *\n(*ompt_get_record_abstract_t) (\n  void *native_record\n);\n\ntypedef void (*ompt_callback_thread_begin_t) (\n  ompt_thread_t thread_type,\n  ompt_data_t *thread_data\n);\n\ntypedef struct ompt_record_thread_begin_t {\n  ompt_thread_t thread_type;\n} ompt_record_thread_begin_t;\n\ntypedef void (*ompt_callback_thread_end_t) (\n  ompt_data_t *thread_data\n);\n\ntypedef void (*ompt_callback_parallel_begin_t) (\n  ompt_data_t *encountering_task_data,\n  const ompt_frame_t *encountering_task_frame,\n  ompt_data_t *parallel_data,\n  unsigned int requested_parallelism,\n  int flags,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_parallel_begin_t {\n  ompt_id_t encountering_task_id;\n  ompt_id_t parallel_id;\n  unsigned int requested_parallelism;\n  int flags;\n  const void *codeptr_ra;\n} ompt_record_parallel_begin_t;\n\ntypedef void (*ompt_callback_parallel_end_t) (\n  ompt_data_t *parallel_data,\n  ompt_data_t *encountering_task_data,\n  int flags,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_parallel_end_t {\n  ompt_id_t parallel_id;\n  ompt_id_t encountering_task_id;\n  int flags;\n  const void *codeptr_ra;\n} ompt_record_parallel_end_t;\n\ntypedef void (*ompt_callback_work_t) (\n  ompt_work_t wstype,\n  ompt_scope_endpoint_t endpoint,\n  ompt_data_t *parallel_data,\n  ompt_data_t *task_data,\n  uint64_t count,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_work_t {\n  ompt_work_t wstype;\n  ompt_scope_endpoint_t endpoint;\n  ompt_id_t parallel_id;\n  ompt_id_t task_id;\n  uint64_t count;\n  const void *codeptr_ra;\n} ompt_record_work_t;\n\ntypedef void (*ompt_callback_dispatch_t) (\n  ompt_data_t *parallel_data,\n  ompt_data_t *task_data,\n  ompt_dispatch_t kind,\n  ompt_data_t instance\n);\n\ntypedef struct ompt_record_dispatch_t {\n  ompt_id_t parallel_id;\n  ompt_id_t task_id;\n  ompt_dispatch_t kind;\n  ompt_data_t instance;\n} ompt_record_dispatch_t;\n\ntypedef void (*ompt_callback_task_create_t) (\n  ompt_data_t *encountering_task_data,\n  const ompt_frame_t *encountering_task_frame,\n  ompt_data_t *new_task_data,\n  int flags,\n  int has_dependences,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_task_create_t {\n  ompt_id_t encountering_task_id;\n  ompt_id_t new_task_id;\n  int flags;\n  int has_dependences;\n  const void *codeptr_ra;\n} ompt_record_task_create_t;\n\ntypedef void (*ompt_callback_dependences_t) (\n  ompt_data_t *task_data,\n  const ompt_dependence_t *deps,\n  int ndeps\n);\n\ntypedef struct ompt_record_dependences_t {\n  ompt_id_t task_id;\n  ompt_dependence_t dep;\n  int ndeps;\n} ompt_record_dependences_t;\n\ntypedef void (*ompt_callback_task_dependence_t) (\n  ompt_data_t *src_task_data,\n  ompt_data_t *sink_task_data\n);\n\ntypedef struct ompt_record_task_dependence_t {\n  ompt_id_t src_task_id;\n  ompt_id_t sink_task_id;\n} ompt_record_task_dependence_t;\n\ntypedef void (*ompt_callback_task_schedule_t) (\n  ompt_data_t *prior_task_data,\n  ompt_task_status_t prior_task_status,\n  ompt_data_t *next_task_data\n);\n\ntypedef struct ompt_record_task_schedule_t {\n  ompt_id_t prior_task_id;\n  ompt_task_status_t prior_task_status;\n  ompt_id_t next_task_id;\n} ompt_record_task_schedule_t;\n\ntypedef void (*ompt_callback_implicit_task_t) (\n  ompt_scope_endpoint_t endpoint,\n  ompt_data_t *parallel_data,\n  ompt_data_t *task_data,\n  unsigned int actual_parallelism,\n  unsigned int index,\n  int flags\n);\n\ntypedef struct ompt_record_implicit_task_t {\n  ompt_scope_endpoint_t endpoint;\n  ompt_id_t parallel_id;\n  ompt_id_t task_id;\n  unsigned int actual_parallelism;\n  unsigned int index;\n  int flags;\n} ompt_record_implicit_task_t;\n\ntypedef void (*ompt_callback_masked_t) (\n  ompt_scope_endpoint_t endpoint,\n  ompt_data_t *parallel_data,\n  ompt_data_t *task_data,\n  const void *codeptr_ra\n);\n\ntypedef ompt_callback_masked_t ompt_callback_master_t DEPRECATED_51;\n\ntypedef struct ompt_record_masked_t {\n  ompt_scope_endpoint_t endpoint;\n  ompt_id_t parallel_id;\n  ompt_id_t task_id;\n  const void *codeptr_ra;\n} ompt_record_masked_t;\n\ntypedef void (*ompt_callback_sync_region_t) (\n  ompt_sync_region_t kind,\n  ompt_scope_endpoint_t endpoint,\n  ompt_data_t *parallel_data,\n  ompt_data_t *task_data,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_sync_region_t {\n  ompt_sync_region_t kind;\n  ompt_scope_endpoint_t endpoint;\n  ompt_id_t parallel_id;\n  ompt_id_t task_id;\n  const void *codeptr_ra;\n} ompt_record_sync_region_t;\n\ntypedef void (*ompt_callback_mutex_acquire_t) (\n  ompt_mutex_t kind,\n  unsigned int hint,\n  unsigned int impl,\n  ompt_wait_id_t wait_id,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_mutex_acquire_t {\n  ompt_mutex_t kind;\n  unsigned int hint;\n  unsigned int impl;\n  ompt_wait_id_t wait_id;\n  const void *codeptr_ra;\n} ompt_record_mutex_acquire_t;\n\ntypedef void (*ompt_callback_mutex_t) (\n  ompt_mutex_t kind,\n  ompt_wait_id_t wait_id,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_mutex_t {\n  ompt_mutex_t kind;\n  ompt_wait_id_t wait_id;\n  const void *codeptr_ra;\n} ompt_record_mutex_t;\n\ntypedef void (*ompt_callback_nest_lock_t) (\n  ompt_scope_endpoint_t endpoint,\n  ompt_wait_id_t wait_id,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_nest_lock_t {\n  ompt_scope_endpoint_t endpoint;\n  ompt_wait_id_t wait_id;\n  const void *codeptr_ra;\n} ompt_record_nest_lock_t;\n\ntypedef void (*ompt_callback_flush_t) (\n  ompt_data_t *thread_data,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_flush_t {\n  const void *codeptr_ra;\n} ompt_record_flush_t;\n\ntypedef void (*ompt_callback_cancel_t) (\n  ompt_data_t *task_data,\n  int flags,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_cancel_t {\n  ompt_id_t task_id;\n  int flags;\n  const void *codeptr_ra;\n} ompt_record_cancel_t;\n\ntypedef void (*ompt_callback_device_initialize_t) (\n  int device_num,\n  const char *type,\n  ompt_device_t *device,\n  ompt_function_lookup_t lookup,\n  const char *documentation\n);\n\ntypedef void (*ompt_callback_device_finalize_t) (\n  int device_num\n);\n\ntypedef void (*ompt_callback_device_load_t) (\n  int device_num,\n  const char *filename,\n  int64_t offset_in_file,\n  void *vma_in_file,\n  size_t bytes,\n  void *host_addr,\n  void *device_addr,\n  uint64_t module_id\n);\n\ntypedef void (*ompt_callback_device_unload_t) (\n  int device_num,\n  uint64_t module_id\n);\n\ntypedef void (*ompt_callback_target_data_op_emi_t) (\n  ompt_scope_endpoint_t endpoint,\n  ompt_data_t *target_task_data,\n  ompt_data_t *target_data,\n  ompt_id_t *host_op_id,\n  ompt_target_data_op_t optype,\n  void *src_addr,\n  int src_device_num,\n  void *dest_addr,\n  int dest_device_num,\n  size_t bytes,\n  const void *codeptr_ra\n);\n\ntypedef void (*ompt_callback_target_data_op_t) (\n  ompt_id_t target_id,\n  ompt_id_t host_op_id,\n  ompt_target_data_op_t optype,\n  void *src_addr,\n  int src_device_num,\n  void *dest_addr,\n  int dest_device_num,\n  size_t bytes,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_target_data_op_t {\n  ompt_id_t host_op_id;\n  ompt_target_data_op_t optype;\n  void *src_addr;\n  int src_device_num;\n  void *dest_addr;\n  int dest_device_num;\n  size_t bytes;\n  ompt_device_time_t end_time;\n  const void *codeptr_ra;\n} ompt_record_target_data_op_t;\n\ntypedef void (*ompt_callback_target_emi_t) (\n  ompt_target_t kind,\n  ompt_scope_endpoint_t endpoint,\n  int device_num,\n  ompt_data_t *task_data,\n  ompt_data_t *target_task_data,\n  ompt_data_t *target_data,\n  const void *codeptr_ra\n);\n\ntypedef void (*ompt_callback_target_t) (\n  ompt_target_t kind,\n  ompt_scope_endpoint_t endpoint,\n  int device_num,\n  ompt_data_t *task_data,\n  ompt_id_t target_id,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_target_t {\n  ompt_target_t kind;\n  ompt_scope_endpoint_t endpoint;\n  int device_num;\n  ompt_id_t task_id;\n  ompt_id_t target_id;\n  const void *codeptr_ra;\n} ompt_record_target_t;\n\ntypedef void (*ompt_callback_target_map_emi_t) (\n  ompt_data_t *target_data,\n  unsigned int nitems,\n  void **host_addr,\n  void **device_addr,\n  size_t *bytes,\n  unsigned int *mapping_flags,\n  const void *codeptr_ra\n);\n\ntypedef void (*ompt_callback_target_map_t) (\n  ompt_id_t target_id,\n  unsigned int nitems,\n  void **host_addr,\n  void **device_addr,\n  size_t *bytes,\n  unsigned int *mapping_flags,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_target_map_t {\n  ompt_id_t target_id;\n  unsigned int nitems;\n  void **host_addr;\n  void **device_addr;\n  size_t *bytes;\n  unsigned int *mapping_flags;\n  const void *codeptr_ra;\n} ompt_record_target_map_t;\n\ntypedef void (*ompt_callback_target_submit_emi_t) (\n  ompt_scope_endpoint_t endpoint,\n  ompt_data_t *target_data,\n  ompt_id_t *host_op_id,\n  unsigned int requested_num_teams\n);\n\ntypedef void (*ompt_callback_target_submit_t) (\n  ompt_id_t target_id,\n  ompt_id_t host_op_id,\n  unsigned int requested_num_teams\n);\n\ntypedef struct ompt_record_target_kernel_t {\n  ompt_id_t host_op_id;\n  unsigned int requested_num_teams;\n  unsigned int granted_num_teams;\n  ompt_device_time_t end_time;\n} ompt_record_target_kernel_t;\n\ntypedef int (*ompt_callback_control_tool_t) (\n  uint64_t command,\n  uint64_t modifier,\n  void *arg,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_control_tool_t {\n  uint64_t command;\n  uint64_t modifier;\n  const void *codeptr_ra;\n} ompt_record_control_tool_t;\n\ntypedef void (*ompt_callback_error_t) (\n  ompt_severity_t severity,\n  const char *message, size_t length,\n  const void *codeptr_ra\n);\n\ntypedef struct ompt_record_error_t {\n  ompt_severity_t severity;\n  const char *message;\n  size_t length;\n  const void *codeptr_ra;\n} ompt_record_error_t;\n\ntypedef struct ompd_address_t {\n  ompd_seg_t segment;\n  ompd_addr_t address;\n} ompd_address_t;\n\ntypedef struct ompd_frame_info_t {\n  ompd_address_t frame_address;\n  ompd_word_t frame_flag;\n} ompd_frame_info_t;\n\ntypedef struct _ompd_aspace_handle ompd_address_space_handle_t;\ntypedef struct _ompd_thread_handle ompd_thread_handle_t;\ntypedef struct _ompd_parallel_handle ompd_parallel_handle_t;\ntypedef struct _ompd_task_handle ompd_task_handle_t;\n\ntypedef struct _ompd_aspace_cont ompd_address_space_context_t;\ntypedef struct _ompd_thread_cont ompd_thread_context_t;\n\ntypedef struct ompd_device_type_sizes_t {\n  uint8_t sizeof_char;\n  uint8_t sizeof_short;\n  uint8_t sizeof_int;\n  uint8_t sizeof_long;\n  uint8_t sizeof_long_long;\n  uint8_t sizeof_pointer;\n} ompd_device_type_sizes_t;\n\ntypedef struct ompt_record_ompt_t {\n  ompt_callbacks_t type;\n  ompt_device_time_t time;\n  ompt_id_t thread_id;\n  ompt_id_t target_id;\n  union {\n    ompt_record_thread_begin_t thread_begin;\n    ompt_record_parallel_begin_t parallel_begin;\n    ompt_record_parallel_end_t parallel_end;\n    ompt_record_work_t work;\n    ompt_record_dispatch_t dispatch;\n    ompt_record_task_create_t task_create;\n    ompt_record_dependences_t dependences;\n    ompt_record_task_dependence_t task_dependence;\n    ompt_record_task_schedule_t task_schedule;\n    ompt_record_implicit_task_t implicit_task;\n    ompt_record_masked_t masked;\n    ompt_record_sync_region_t sync_region;\n    ompt_record_mutex_acquire_t mutex_acquire;\n    ompt_record_mutex_t mutex;\n    ompt_record_nest_lock_t nest_lock;\n    ompt_record_flush_t flush;\n    ompt_record_cancel_t cancel;\n    ompt_record_target_t target;\n    ompt_record_target_data_op_t target_data_op;\n    ompt_record_target_map_t target_map;\n    ompt_record_target_kernel_t target_kernel;\n    ompt_record_control_tool_t control_tool;\n  } record;\n} ompt_record_ompt_t;\n\ntypedef ompt_record_ompt_t *(*ompt_get_record_ompt_t) (\n  ompt_buffer_t *buffer,\n  ompt_buffer_cursor_t current\n);\n\n#define ompt_id_none 0\n#define ompt_data_none {0}\n#define ompt_time_none 0\n#define ompt_hwid_none 0\n#define ompt_addr_none ~0\n#define ompt_mutex_impl_none 0\n#define ompt_wait_id_none 0\n\n#define ompd_segment_none 0\n\n#endif /* __OMPT__ */\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp.h", "content": "/*! \\file */\n/*\n * kmp.h -- KPTS runtime header file.\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_H\n#define KMP_H\n\n#include \"kmp_config.h\"\n\n/* #define BUILD_PARALLEL_ORDERED 1 */\n\n/* This fix replaces gettimeofday with clock_gettime for better scalability on\n   the Altix.  Requires user code to be linked with -lrt. */\n//#define FIX_SGI_CLOCK\n\n/* Defines for OpenMP 3.0 tasking and auto scheduling */\n\n#ifndef KMP_STATIC_STEAL_ENABLED\n#define KMP_STATIC_STEAL_ENABLED 1\n#endif\n\n#define TASK_CURRENT_NOT_QUEUED 0\n#define TASK_CURRENT_QUEUED 1\n\n#ifdef BUILD_TIED_TASK_STACK\n#define TASK_STACK_EMPTY 0 // entries when the stack is empty\n#define TASK_STACK_BLOCK_BITS 5 // Used in TASK_STACK_SIZE and TASK_STACK_MASK\n// Number of entries in each task stack array\n#define TASK_STACK_BLOCK_SIZE (1 << TASK_STACK_BLOCK_BITS)\n// Mask for determining index into stack block\n#define TASK_STACK_INDEX_MASK (TASK_STACK_BLOCK_SIZE - 1)\n#endif // BUILD_TIED_TASK_STACK\n\n#define TASK_NOT_PUSHED 1\n#define TASK_SUCCESSFULLY_PUSHED 0\n#define TASK_TIED 1\n#define TASK_UNTIED 0\n#define TASK_EXPLICIT 1\n#define TASK_IMPLICIT 0\n#define TASK_PROXY 1\n#define TASK_FULL 0\n#define TASK_DETACHABLE 1\n#define TASK_UNDETACHABLE 0\n\n#define KMP_CANCEL_THREADS\n#define KMP_THREAD_ATTR\n\n// Android does not have pthread_cancel.  Undefine KMP_CANCEL_THREADS if being\n// built on Android\n#if defined(__ANDROID__)\n#undef KMP_CANCEL_THREADS\n#endif\n\n#include <signal.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits>\n#include <type_traits>\n/* include <ctype.h> don't use; problems with /MD on Windows* OS NT due to bad\n   Microsoft library. Some macros provided below to replace these functions  */\n#ifndef __ABSOFT_WIN\n#include <sys/types.h>\n#endif\n#include <limits.h>\n#include <time.h>\n\n#include <errno.h>\n\n#include \"kmp_os.h\"\n\n#include \"kmp_safe_c_api.h\"\n\n#if KMP_STATS_ENABLED\nclass kmp_stats_list;\n#endif\n\n#if KMP_USE_HIER_SCHED\n// Only include hierarchical scheduling if affinity is supported\n#undef KMP_USE_HIER_SCHED\n#define KMP_USE_HIER_SCHED KMP_AFFINITY_SUPPORTED\n#endif\n\n#if KMP_USE_HWLOC && KMP_AFFINITY_SUPPORTED\n#include \"hwloc.h\"\n#ifndef HWLOC_OBJ_NUMANODE\n#define HWLOC_OBJ_NUMANODE HWLOC_OBJ_NODE\n#endif\n#ifndef HWLOC_OBJ_PACKAGE\n#define HWLOC_OBJ_PACKAGE HWLOC_OBJ_SOCKET\n#endif\n#if HWLOC_API_VERSION >= 0x00020000\n// hwloc 2.0 changed type of depth of object from unsigned to int\ntypedef int kmp_hwloc_depth_t;\n#else\ntypedef unsigned int kmp_hwloc_depth_t;\n#endif\n#endif\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n#include <xmmintrin.h>\n#endif\n\n#include \"kmp_debug.h\"\n#include \"kmp_lock.h\"\n#include \"kmp_version.h\"\n#if USE_DEBUGGER\n#include \"kmp_debugger.h\"\n#endif\n#include \"kmp_i18n.h\"\n\n#define KMP_HANDLE_SIGNALS (KMP_OS_UNIX || KMP_OS_WINDOWS)\n\n#include \"kmp_wrapper_malloc.h\"\n#if KMP_OS_UNIX\n#include <unistd.h>\n#if !defined NSIG && defined _NSIG\n#define NSIG _NSIG\n#endif\n#endif\n\n#if KMP_OS_LINUX\n#pragma weak clock_gettime\n#endif\n\n#if OMPT_SUPPORT\n#include \"ompt-internal.h\"\n#endif\n\n#ifndef UNLIKELY\n#define UNLIKELY(x) (x)\n#endif\n\n// Affinity format function\n#include \"kmp_str.h\"\n\n// 0 - no fast memory allocation, alignment: 8-byte on x86, 16-byte on x64.\n// 3 - fast allocation using sync, non-sync free lists of any size, non-self\n// free lists of limited size.\n#ifndef USE_FAST_MEMORY\n#define USE_FAST_MEMORY 3\n#endif\n\n#ifndef KMP_NESTED_HOT_TEAMS\n#define KMP_NESTED_HOT_TEAMS 0\n#define USE_NESTED_HOT_ARG(x)\n#else\n#if KMP_NESTED_HOT_TEAMS\n#define USE_NESTED_HOT_ARG(x) , x\n#else\n#define USE_NESTED_HOT_ARG(x)\n#endif\n#endif\n\n// Assume using BGET compare_exchange instruction instead of lock by default.\n#ifndef USE_CMP_XCHG_FOR_BGET\n#define USE_CMP_XCHG_FOR_BGET 1\n#endif\n\n// Test to see if queuing lock is better than bootstrap lock for bget\n// #ifndef USE_QUEUING_LOCK_FOR_BGET\n// #define USE_QUEUING_LOCK_FOR_BGET\n// #endif\n\n#define KMP_NSEC_PER_SEC 1000000000L\n#define KMP_USEC_PER_SEC 1000000L\n\n/*!\n@ingroup BASIC_TYPES\n@{\n*/\n\n/*!\nValues for bit flags used in the ident_t to describe the fields.\n*/\nenum {\n  /*! Use trampoline for internal microtasks */\n  KMP_IDENT_IMB = 0x01,\n  /*! Use c-style ident structure */\n  KMP_IDENT_KMPC = 0x02,\n  /* 0x04 is no longer used */\n  /*! Entry point generated by auto-parallelization */\n  KMP_IDENT_AUTOPAR = 0x08,\n  /*! Compiler generates atomic reduction option for kmpc_reduce* */\n  KMP_IDENT_ATOMIC_REDUCE = 0x10,\n  /*! To mark a 'barrier' directive in user code */\n  KMP_IDENT_BARRIER_EXPL = 0x20,\n  /*! To Mark implicit barriers. */\n  KMP_IDENT_BARRIER_IMPL = 0x0040,\n  KMP_IDENT_BARRIER_IMPL_MASK = 0x01C0,\n  KMP_IDENT_BARRIER_IMPL_FOR = 0x0040,\n  KMP_IDENT_BARRIER_IMPL_SECTIONS = 0x00C0,\n\n  KMP_IDENT_BARRIER_IMPL_SINGLE = 0x0140,\n  KMP_IDENT_BARRIER_IMPL_WORKSHARE = 0x01C0,\n\n  /*! To mark a static loop in OMPT callbacks */\n  KMP_IDENT_WORK_LOOP = 0x200,\n  /*! To mark a sections directive in OMPT callbacks */\n  KMP_IDENT_WORK_SECTIONS = 0x400,\n  /*! To mark a distribute construct in OMPT callbacks */\n  KMP_IDENT_WORK_DISTRIBUTE = 0x800,\n  /*! Atomic hint; bottom four bits as omp_sync_hint_t. Top four reserved and\n      not currently used. If one day we need more bits, then we can use\n      an invalid combination of hints to mean that another, larger field\n      should be used in a different flag. */\n  KMP_IDENT_ATOMIC_HINT_MASK = 0xFF0000,\n  KMP_IDENT_ATOMIC_HINT_UNCONTENDED = 0x010000,\n  KMP_IDENT_ATOMIC_HINT_CONTENDED = 0x020000,\n  KMP_IDENT_ATOMIC_HINT_NONSPECULATIVE = 0x040000,\n  KMP_IDENT_ATOMIC_HINT_SPECULATIVE = 0x080000,\n  KMP_IDENT_OPENMP_SPEC_VERSION_MASK = 0xFF000000\n};\n\n/*!\n * The ident structure that describes a source location.\n */\ntypedef struct ident {\n  kmp_int32 reserved_1; /**<  might be used in Fortran; see above  */\n  kmp_int32 flags; /**<  also f.flags; KMP_IDENT_xxx flags; KMP_IDENT_KMPC\n                      identifies this union member  */\n  kmp_int32 reserved_2; /**<  not really used in Fortran any more; see above */\n#if USE_ITT_BUILD\n/*  but currently used for storing region-specific ITT */\n/*  contextual information. */\n#endif /* USE_ITT_BUILD */\n  kmp_int32 reserved_3; /**< source[4] in Fortran, do not use for C++  */\n  char const *psource; /**< String describing the source location.\n                       The string is composed of semi-colon separated fields\n                       which describe the source file, the function and a pair\n                       of line numbers that delimit the construct. */\n  // Returns the OpenMP version in form major*10+minor (e.g., 50 for 5.0)\n  kmp_int32 get_openmp_version() {\n    return (((flags & KMP_IDENT_OPENMP_SPEC_VERSION_MASK) >> 24) & 0xFF);\n  }\n} ident_t;\n/*!\n@}\n*/\n\n// Some forward declarations.\ntypedef union kmp_team kmp_team_t;\ntypedef struct kmp_taskdata kmp_taskdata_t;\ntypedef union kmp_task_team kmp_task_team_t;\ntypedef union kmp_team kmp_team_p;\ntypedef union kmp_info kmp_info_p;\ntypedef union kmp_root kmp_root_p;\n\ntemplate <bool C = false, bool S = true> class kmp_flag_32;\ntemplate <bool C = false, bool S = true> class kmp_flag_64;\nclass kmp_flag_oncore;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* ------------------------------------------------------------------------ */\n\n/* Pack two 32-bit signed integers into a 64-bit signed integer */\n/* ToDo: Fix word ordering for big-endian machines. */\n#define KMP_PACK_64(HIGH_32, LOW_32)                                           \\\n  ((kmp_int64)((((kmp_uint64)(HIGH_32)) << 32) | (kmp_uint64)(LOW_32)))\n\n// Generic string manipulation macros. Assume that _x is of type char *\n#define SKIP_WS(_x)                                                            \\\n  {                                                                            \\\n    while (*(_x) == ' ' || *(_x) == '\\t')                                      \\\n      (_x)++;                                                                  \\\n  }\n#define SKIP_DIGITS(_x)                                                        \\\n  {                                                                            \\\n    while (*(_x) >= '0' && *(_x) <= '9')                                       \\\n      (_x)++;                                                                  \\\n  }\n#define SKIP_TOKEN(_x)                                                         \\\n  {                                                                            \\\n    while ((*(_x) >= '0' && *(_x) <= '9') || (*(_x) >= 'a' && *(_x) <= 'z') || \\\n           (*(_x) >= 'A' && *(_x) <= 'Z') || *(_x) == '_')                     \\\n      (_x)++;                                                                  \\\n  }\n#define SKIP_TO(_x, _c)                                                        \\\n  {                                                                            \\\n    while (*(_x) != '\\0' && *(_x) != (_c))                                     \\\n      (_x)++;                                                                  \\\n  }\n\n/* ------------------------------------------------------------------------ */\n\n#define KMP_MAX(x, y) ((x) > (y) ? (x) : (y))\n#define KMP_MIN(x, y) ((x) < (y) ? (x) : (y))\n\n/* ------------------------------------------------------------------------ */\n/* Enumeration types */\n\nenum kmp_state_timer {\n  ts_stop,\n  ts_start,\n  ts_pause,\n\n  ts_last_state\n};\n\nenum dynamic_mode {\n  dynamic_default,\n#ifdef USE_LOAD_BALANCE\n  dynamic_load_balance,\n#endif /* USE_LOAD_BALANCE */\n  dynamic_random,\n  dynamic_thread_limit,\n  dynamic_max\n};\n\n/* external schedule constants, duplicate enum omp_sched in omp.h in order to\n * not include it here */\n#ifndef KMP_SCHED_TYPE_DEFINED\n#define KMP_SCHED_TYPE_DEFINED\ntypedef enum kmp_sched {\n  kmp_sched_lower = 0, // lower and upper bounds are for routine parameter check\n  // Note: need to adjust __kmp_sch_map global array in case enum is changed\n  kmp_sched_static = 1, // mapped to kmp_sch_static_chunked           (33)\n  kmp_sched_dynamic = 2, // mapped to kmp_sch_dynamic_chunked          (35)\n  kmp_sched_guided = 3, // mapped to kmp_sch_guided_chunked           (36)\n  kmp_sched_auto = 4, // mapped to kmp_sch_auto                     (38)\n  kmp_sched_upper_std = 5, // upper bound for standard schedules\n  kmp_sched_lower_ext = 100, // lower bound of Intel extension schedules\n  kmp_sched_trapezoidal = 101, // mapped to kmp_sch_trapezoidal (39)\n#if KMP_STATIC_STEAL_ENABLED\n  kmp_sched_static_steal = 102, // mapped to kmp_sch_static_steal (44)\n#endif\n  kmp_sched_upper,\n  kmp_sched_default = kmp_sched_static, // default scheduling\n  kmp_sched_monotonic = 0x80000000\n} kmp_sched_t;\n#endif\n\n/*!\n @ingroup WORK_SHARING\n * Describes the loop schedule to be used for a parallel for loop.\n */\nenum sched_type : kmp_int32 {\n  kmp_sch_lower = 32, /**< lower bound for unordered values */\n  kmp_sch_static_chunked = 33,\n  kmp_sch_static = 34, /**< static unspecialized */\n  kmp_sch_dynamic_chunked = 35,\n  kmp_sch_guided_chunked = 36, /**< guided unspecialized */\n  kmp_sch_runtime = 37,\n  kmp_sch_auto = 38, /**< auto */\n  kmp_sch_trapezoidal = 39,\n\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_sch_static_greedy = 40,\n  kmp_sch_static_balanced = 41,\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_sch_guided_iterative_chunked = 42,\n  kmp_sch_guided_analytical_chunked = 43,\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_sch_static_steal = 44,\n\n  /* static with chunk adjustment (e.g., simd) */\n  kmp_sch_static_balanced_chunked = 45,\n  kmp_sch_guided_simd = 46, /**< guided with chunk adjustment */\n  kmp_sch_runtime_simd = 47, /**< runtime with chunk adjustment */\n\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_sch_upper, /**< upper bound for unordered values */\n\n  kmp_ord_lower = 64, /**< lower bound for ordered values, must be power of 2 */\n  kmp_ord_static_chunked = 65,\n  kmp_ord_static = 66, /**< ordered static unspecialized */\n  kmp_ord_dynamic_chunked = 67,\n  kmp_ord_guided_chunked = 68,\n  kmp_ord_runtime = 69,\n  kmp_ord_auto = 70, /**< ordered auto */\n  kmp_ord_trapezoidal = 71,\n  kmp_ord_upper, /**< upper bound for ordered values */\n\n  /* Schedules for Distribute construct */\n  kmp_distribute_static_chunked = 91, /**< distribute static chunked */\n  kmp_distribute_static = 92, /**< distribute static unspecialized */\n\n  /* For the \"nomerge\" versions, kmp_dispatch_next*() will always return a\n     single iteration/chunk, even if the loop is serialized. For the schedule\n     types listed above, the entire iteration vector is returned if the loop is\n     serialized. This doesn't work for gcc/gcomp sections. */\n  kmp_nm_lower = 160, /**< lower bound for nomerge values */\n\n  kmp_nm_static_chunked =\n      (kmp_sch_static_chunked - kmp_sch_lower + kmp_nm_lower),\n  kmp_nm_static = 162, /**< static unspecialized */\n  kmp_nm_dynamic_chunked = 163,\n  kmp_nm_guided_chunked = 164, /**< guided unspecialized */\n  kmp_nm_runtime = 165,\n  kmp_nm_auto = 166, /**< auto */\n  kmp_nm_trapezoidal = 167,\n\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_nm_static_greedy = 168,\n  kmp_nm_static_balanced = 169,\n  /* accessible only through KMP_SCHEDULE environment variable */\n  kmp_nm_guided_iterative_chunked = 170,\n  kmp_nm_guided_analytical_chunked = 171,\n  kmp_nm_static_steal =\n      172, /* accessible only through OMP_SCHEDULE environment variable */\n\n  kmp_nm_ord_static_chunked = 193,\n  kmp_nm_ord_static = 194, /**< ordered static unspecialized */\n  kmp_nm_ord_dynamic_chunked = 195,\n  kmp_nm_ord_guided_chunked = 196,\n  kmp_nm_ord_runtime = 197,\n  kmp_nm_ord_auto = 198, /**< auto */\n  kmp_nm_ord_trapezoidal = 199,\n  kmp_nm_upper, /**< upper bound for nomerge values */\n\n  /* Support for OpenMP 4.5 monotonic and nonmonotonic schedule modifiers. Since\n     we need to distinguish the three possible cases (no modifier, monotonic\n     modifier, nonmonotonic modifier), we need separate bits for each modifier.\n     The absence of monotonic does not imply nonmonotonic, especially since 4.5\n     says that the behaviour of the \"no modifier\" case is implementation defined\n     in 4.5, but will become \"nonmonotonic\" in 5.0.\n\n     Since we're passing a full 32 bit value, we can use a couple of high bits\n     for these flags; out of paranoia we avoid the sign bit.\n\n     These modifiers can be or-ed into non-static schedules by the compiler to\n     pass the additional information. They will be stripped early in the\n     processing in __kmp_dispatch_init when setting up schedules, so most of the\n     code won't ever see schedules with these bits set.  */\n  kmp_sch_modifier_monotonic =\n      (1 << 29), /**< Set if the monotonic schedule modifier was present */\n  kmp_sch_modifier_nonmonotonic =\n      (1 << 30), /**< Set if the nonmonotonic schedule modifier was present */\n\n#define SCHEDULE_WITHOUT_MODIFIERS(s)                                          \\\n  (enum sched_type)(                                                           \\\n      (s) & ~(kmp_sch_modifier_nonmonotonic | kmp_sch_modifier_monotonic))\n#define SCHEDULE_HAS_MONOTONIC(s) (((s)&kmp_sch_modifier_monotonic) != 0)\n#define SCHEDULE_HAS_NONMONOTONIC(s) (((s)&kmp_sch_modifier_nonmonotonic) != 0)\n#define SCHEDULE_HAS_NO_MODIFIERS(s)                                           \\\n  (((s) & (kmp_sch_modifier_nonmonotonic | kmp_sch_modifier_monotonic)) == 0)\n#define SCHEDULE_GET_MODIFIERS(s)                                              \\\n  ((enum sched_type)(                                                          \\\n      (s) & (kmp_sch_modifier_nonmonotonic | kmp_sch_modifier_monotonic)))\n#define SCHEDULE_SET_MODIFIERS(s, m)                                           \\\n  (s = (enum sched_type)((kmp_int32)s | (kmp_int32)m))\n#define SCHEDULE_NONMONOTONIC 0\n#define SCHEDULE_MONOTONIC 1\n\n  kmp_sch_default = kmp_sch_static /**< default scheduling algorithm */\n};\n\n// Apply modifiers on internal kind to standard kind\nstatic inline void\n__kmp_sched_apply_mods_stdkind(kmp_sched_t *kind,\n                               enum sched_type internal_kind) {\n  if (SCHEDULE_HAS_MONOTONIC(internal_kind)) {\n    *kind = (kmp_sched_t)((int)*kind | (int)kmp_sched_monotonic);\n  }\n}\n\n// Apply modifiers on standard kind to internal kind\nstatic inline void\n__kmp_sched_apply_mods_intkind(kmp_sched_t kind,\n                               enum sched_type *internal_kind) {\n  if ((int)kind & (int)kmp_sched_monotonic) {\n    *internal_kind = (enum sched_type)((int)*internal_kind |\n                                       (int)kmp_sch_modifier_monotonic);\n  }\n}\n\n// Get standard schedule without modifiers\nstatic inline kmp_sched_t __kmp_sched_without_mods(kmp_sched_t kind) {\n  return (kmp_sched_t)((int)kind & ~((int)kmp_sched_monotonic));\n}\n\n/* Type to keep runtime schedule set via OMP_SCHEDULE or omp_set_schedule() */\ntypedef union kmp_r_sched {\n  struct {\n    enum sched_type r_sched_type;\n    int chunk;\n  };\n  kmp_int64 sched;\n} kmp_r_sched_t;\n\nextern enum sched_type __kmp_sch_map[]; // map OMP 3.0 schedule types with our\n// internal schedule types\n\nenum library_type {\n  library_none,\n  library_serial,\n  library_turnaround,\n  library_throughput\n};\n\n#if KMP_OS_LINUX\nenum clock_function_type {\n  clock_function_gettimeofday,\n  clock_function_clock_gettime\n};\n#endif /* KMP_OS_LINUX */\n\n#if KMP_MIC_SUPPORTED\nenum mic_type { non_mic, mic1, mic2, mic3, dummy };\n#endif\n\n/* -- fast reduction stuff ------------------------------------------------ */\n\n#undef KMP_FAST_REDUCTION_BARRIER\n#define KMP_FAST_REDUCTION_BARRIER 1\n\n#undef KMP_FAST_REDUCTION_CORE_DUO\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n#define KMP_FAST_REDUCTION_CORE_DUO 1\n#endif\n\nenum _reduction_method {\n  reduction_method_not_defined = 0,\n  critical_reduce_block = (1 << 8),\n  atomic_reduce_block = (2 << 8),\n  tree_reduce_block = (3 << 8),\n  empty_reduce_block = (4 << 8)\n};\n\n// Description of the packed_reduction_method variable:\n// The packed_reduction_method variable consists of two enum types variables\n// that are packed together into 0-th byte and 1-st byte:\n// 0: (packed_reduction_method & 0x000000FF) is a 'enum barrier_type' value of\n// barrier that will be used in fast reduction: bs_plain_barrier or\n// bs_reduction_barrier\n// 1: (packed_reduction_method & 0x0000FF00) is a reduction method that will\n// be used in fast reduction;\n// Reduction method is of 'enum _reduction_method' type and it's defined the way\n// so that the bits of 0-th byte are empty, so no need to execute a shift\n// instruction while packing/unpacking\n\n#if KMP_FAST_REDUCTION_BARRIER\n#define PACK_REDUCTION_METHOD_AND_BARRIER(reduction_method, barrier_type)      \\\n  ((reduction_method) | (barrier_type))\n\n#define UNPACK_REDUCTION_METHOD(packed_reduction_method)                       \\\n  ((enum _reduction_method)((packed_reduction_method) & (0x0000FF00)))\n\n#define UNPACK_REDUCTION_BARRIER(packed_reduction_method)                      \\\n  ((enum barrier_type)((packed_reduction_method) & (0x000000FF)))\n#else\n#define PACK_REDUCTION_METHOD_AND_BARRIER(reduction_method, barrier_type)      \\\n  (reduction_method)\n\n#define UNPACK_REDUCTION_METHOD(packed_reduction_method)                       \\\n  (packed_reduction_method)\n\n#define UNPACK_REDUCTION_BARRIER(packed_reduction_method) (bs_plain_barrier)\n#endif\n\n#define TEST_REDUCTION_METHOD(packed_reduction_method, which_reduction_block)  \\\n  ((UNPACK_REDUCTION_METHOD(packed_reduction_method)) ==                       \\\n   (which_reduction_block))\n\n#if KMP_FAST_REDUCTION_BARRIER\n#define TREE_REDUCE_BLOCK_WITH_REDUCTION_BARRIER                               \\\n  (PACK_REDUCTION_METHOD_AND_BARRIER(tree_reduce_block, bs_reduction_barrier))\n\n#define TREE_REDUCE_BLOCK_WITH_PLAIN_BARRIER                                   \\\n  (PACK_REDUCTION_METHOD_AND_BARRIER(tree_reduce_block, bs_plain_barrier))\n#endif\n\ntypedef int PACKED_REDUCTION_METHOD_T;\n\n/* -- end of fast reduction stuff ----------------------------------------- */\n\n#if KMP_OS_WINDOWS\n#define USE_CBLKDATA\n#if KMP_MSVC_COMPAT\n#pragma warning(push)\n#pragma warning(disable : 271 310)\n#endif\n#include <windows.h>\n#if KMP_MSVC_COMPAT\n#pragma warning(pop)\n#endif\n#endif\n\n#if KMP_OS_UNIX\n#include <dlfcn.h>\n#include <pthread.h>\n#endif\n\nenum kmp_hw_t : int {\n  KMP_HW_UNKNOWN = -1,\n  KMP_HW_MACHINE = 0,\n  KMP_HW_SOCKET,\n  KMP_HW_PROC_GROUP,\n  KMP_HW_NUMA,\n  KMP_HW_DIE,\n  KMP_HW_L3,\n  KMP_HW_TILE,\n  KMP_HW_MODULE,\n  KMP_HW_L2,\n  KMP_HW_L1,\n  KMP_HW_CORE,\n  KMP_HW_THREAD,\n  KMP_HW_LAST\n};\n\n#define KMP_ASSERT_VALID_HW_TYPE(type)                                         \\\n  KMP_DEBUG_ASSERT(type >= (kmp_hw_t)0 && type < KMP_HW_LAST)\n\n#define KMP_FOREACH_HW_TYPE(type)                                              \\\n  for (kmp_hw_t type = (kmp_hw_t)0; type < KMP_HW_LAST;                        \\\n       type = (kmp_hw_t)((int)type + 1))\n\nconst char *__kmp_hw_get_catalog_string(kmp_hw_t type, bool plural = false);\n\n/* Only Linux* OS and Windows* OS support thread affinity. */\n#if KMP_AFFINITY_SUPPORTED\n\n// GROUP_AFFINITY is already defined for _MSC_VER>=1600 (VS2010 and later).\n#if KMP_OS_WINDOWS\n#if _MSC_VER < 1600 && KMP_MSVC_COMPAT\ntypedef struct GROUP_AFFINITY {\n  KAFFINITY Mask;\n  WORD Group;\n  WORD Reserved[3];\n} GROUP_AFFINITY;\n#endif /* _MSC_VER < 1600 */\n#if KMP_GROUP_AFFINITY\nextern int __kmp_num_proc_groups;\n#else\nstatic const int __kmp_num_proc_groups = 1;\n#endif /* KMP_GROUP_AFFINITY */\ntypedef DWORD (*kmp_GetActiveProcessorCount_t)(WORD);\nextern kmp_GetActiveProcessorCount_t __kmp_GetActiveProcessorCount;\n\ntypedef WORD (*kmp_GetActiveProcessorGroupCount_t)(void);\nextern kmp_GetActiveProcessorGroupCount_t __kmp_GetActiveProcessorGroupCount;\n\ntypedef BOOL (*kmp_GetThreadGroupAffinity_t)(HANDLE, GROUP_AFFINITY *);\nextern kmp_GetThreadGroupAffinity_t __kmp_GetThreadGroupAffinity;\n\ntypedef BOOL (*kmp_SetThreadGroupAffinity_t)(HANDLE, const GROUP_AFFINITY *,\n                                             GROUP_AFFINITY *);\nextern kmp_SetThreadGroupAffinity_t __kmp_SetThreadGroupAffinity;\n#endif /* KMP_OS_WINDOWS */\n\n#if KMP_USE_HWLOC\nextern hwloc_topology_t __kmp_hwloc_topology;\nextern int __kmp_hwloc_error;\nextern int __kmp_numa_detected;\nextern int __kmp_tile_depth;\n#endif\n\nextern size_t __kmp_affin_mask_size;\n#define KMP_AFFINITY_CAPABLE() (__kmp_affin_mask_size > 0)\n#define KMP_AFFINITY_DISABLE() (__kmp_affin_mask_size = 0)\n#define KMP_AFFINITY_ENABLE(mask_size) (__kmp_affin_mask_size = mask_size)\n#define KMP_CPU_SET_ITERATE(i, mask)                                           \\\n  for (i = (mask)->begin(); (int)i != (mask)->end(); i = (mask)->next(i))\n#define KMP_CPU_SET(i, mask) (mask)->set(i)\n#define KMP_CPU_ISSET(i, mask) (mask)->is_set(i)\n#define KMP_CPU_CLR(i, mask) (mask)->clear(i)\n#define KMP_CPU_ZERO(mask) (mask)->zero()\n#define KMP_CPU_COPY(dest, src) (dest)->copy(src)\n#define KMP_CPU_AND(dest, src) (dest)->bitwise_and(src)\n#define KMP_CPU_COMPLEMENT(max_bit_number, mask) (mask)->bitwise_not()\n#define KMP_CPU_UNION(dest, src) (dest)->bitwise_or(src)\n#define KMP_CPU_ALLOC(ptr) (ptr = __kmp_affinity_dispatch->allocate_mask())\n#define KMP_CPU_FREE(ptr) __kmp_affinity_dispatch->deallocate_mask(ptr)\n#define KMP_CPU_ALLOC_ON_STACK(ptr) KMP_CPU_ALLOC(ptr)\n#define KMP_CPU_FREE_FROM_STACK(ptr) KMP_CPU_FREE(ptr)\n#define KMP_CPU_INTERNAL_ALLOC(ptr) KMP_CPU_ALLOC(ptr)\n#define KMP_CPU_INTERNAL_FREE(ptr) KMP_CPU_FREE(ptr)\n#define KMP_CPU_INDEX(arr, i) __kmp_affinity_dispatch->index_mask_array(arr, i)\n#define KMP_CPU_ALLOC_ARRAY(arr, n)                                            \\\n  (arr = __kmp_affinity_dispatch->allocate_mask_array(n))\n#define KMP_CPU_FREE_ARRAY(arr, n)                                             \\\n  __kmp_affinity_dispatch->deallocate_mask_array(arr)\n#define KMP_CPU_INTERNAL_ALLOC_ARRAY(arr, n) KMP_CPU_ALLOC_ARRAY(arr, n)\n#define KMP_CPU_INTERNAL_FREE_ARRAY(arr, n) KMP_CPU_FREE_ARRAY(arr, n)\n#define __kmp_get_system_affinity(mask, abort_bool)                            \\\n  (mask)->get_system_affinity(abort_bool)\n#define __kmp_set_system_affinity(mask, abort_bool)                            \\\n  (mask)->set_system_affinity(abort_bool)\n#define __kmp_get_proc_group(mask) (mask)->get_proc_group()\n\nclass KMPAffinity {\npublic:\n  class Mask {\n  public:\n    void *operator new(size_t n);\n    void operator delete(void *p);\n    void *operator new[](size_t n);\n    void operator delete[](void *p);\n    virtual ~Mask() {}\n    // Set bit i to 1\n    virtual void set(int i) {}\n    // Return bit i\n    virtual bool is_set(int i) const { return false; }\n    // Set bit i to 0\n    virtual void clear(int i) {}\n    // Zero out entire mask\n    virtual void zero() {}\n    // Copy src into this mask\n    virtual void copy(const Mask *src) {}\n    // this &= rhs\n    virtual void bitwise_and(const Mask *rhs) {}\n    // this |= rhs\n    virtual void bitwise_or(const Mask *rhs) {}\n    // this = ~this\n    virtual void bitwise_not() {}\n    // API for iterating over an affinity mask\n    // for (int i = mask->begin(); i != mask->end(); i = mask->next(i))\n    virtual int begin() const { return 0; }\n    virtual int end() const { return 0; }\n    virtual int next(int previous) const { return 0; }\n#if KMP_OS_WINDOWS\n    virtual int set_process_affinity(bool abort_on_error) const { return -1; }\n#endif\n    // Set the system's affinity to this affinity mask's value\n    virtual int set_system_affinity(bool abort_on_error) const { return -1; }\n    // Set this affinity mask to the current system affinity\n    virtual int get_system_affinity(bool abort_on_error) { return -1; }\n    // Only 1 DWORD in the mask should have any procs set.\n    // Return the appropriate index, or -1 for an invalid mask.\n    virtual int get_proc_group() const { return -1; }\n  };\n  void *operator new(size_t n);\n  void operator delete(void *p);\n  // Need virtual destructor\n  virtual ~KMPAffinity() = default;\n  // Determine if affinity is capable\n  virtual void determine_capable(const char *env_var) {}\n  // Bind the current thread to os proc\n  virtual void bind_thread(int proc) {}\n  // Factory functions to allocate/deallocate a mask\n  virtual Mask *allocate_mask() { return nullptr; }\n  virtual void deallocate_mask(Mask *m) {}\n  virtual Mask *allocate_mask_array(int num) { return nullptr; }\n  virtual void deallocate_mask_array(Mask *m) {}\n  virtual Mask *index_mask_array(Mask *m, int index) { return nullptr; }\n  static void pick_api();\n  static void destroy_api();\n  enum api_type {\n    NATIVE_OS\n#if KMP_USE_HWLOC\n    ,\n    HWLOC\n#endif\n  };\n  virtual api_type get_api_type() const {\n    KMP_ASSERT(0);\n    return NATIVE_OS;\n  }\n\nprivate:\n  static bool picked_api;\n};\n\ntypedef KMPAffinity::Mask kmp_affin_mask_t;\nextern KMPAffinity *__kmp_affinity_dispatch;\n\n// Declare local char buffers with this size for printing debug and info\n// messages, using __kmp_affinity_print_mask().\n#define KMP_AFFIN_MASK_PRINT_LEN 1024\n\nenum affinity_type {\n  affinity_none = 0,\n  affinity_physical,\n  affinity_logical,\n  affinity_compact,\n  affinity_scatter,\n  affinity_explicit,\n  affinity_balanced,\n  affinity_disabled, // not used outsize the env var parser\n  affinity_default\n};\n\nenum affinity_gran {\n  affinity_gran_fine = 0,\n  affinity_gran_thread,\n  affinity_gran_core,\n  affinity_gran_tile,\n  affinity_gran_die,\n  affinity_gran_numa,\n  affinity_gran_package,\n  affinity_gran_node,\n#if KMP_GROUP_AFFINITY\n  // The \"group\" granularity isn't necesssarily coarser than all of the\n  // other levels, but we put it last in the enum.\n  affinity_gran_group,\n#endif /* KMP_GROUP_AFFINITY */\n  affinity_gran_default\n};\n\nenum affinity_top_method {\n  affinity_top_method_all = 0, // try all (supported) methods, in order\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n  affinity_top_method_apicid,\n  affinity_top_method_x2apicid,\n  affinity_top_method_x2apicid_1f,\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n  affinity_top_method_cpuinfo, // KMP_CPUINFO_FILE is usable on Windows* OS, too\n#if KMP_GROUP_AFFINITY\n  affinity_top_method_group,\n#endif /* KMP_GROUP_AFFINITY */\n  affinity_top_method_flat,\n#if KMP_USE_HWLOC\n  affinity_top_method_hwloc,\n#endif\n  affinity_top_method_default\n};\n\n#define affinity_respect_mask_default (-1)\n\nextern enum affinity_type __kmp_affinity_type; /* Affinity type */\nextern enum affinity_gran __kmp_affinity_gran; /* Affinity granularity */\nextern int __kmp_affinity_gran_levels; /* corresponding int value */\nextern int __kmp_affinity_dups; /* Affinity duplicate masks */\nextern enum affinity_top_method __kmp_affinity_top_method;\nextern int __kmp_affinity_compact; /* Affinity 'compact' value */\nextern int __kmp_affinity_offset; /* Affinity offset value  */\nextern int __kmp_affinity_verbose; /* Was verbose specified for KMP_AFFINITY? */\nextern int __kmp_affinity_warnings; /* KMP_AFFINITY warnings enabled ? */\nextern int __kmp_affinity_respect_mask; // Respect process' init affinity mask?\nextern char *__kmp_affinity_proclist; /* proc ID list */\nextern kmp_affin_mask_t *__kmp_affinity_masks;\nextern unsigned __kmp_affinity_num_masks;\nextern void __kmp_affinity_bind_thread(int which);\n\nextern kmp_affin_mask_t *__kmp_affin_fullMask;\nextern char *__kmp_cpuinfo_file;\n\n#endif /* KMP_AFFINITY_SUPPORTED */\n\n// This needs to be kept in sync with the values in omp.h !!!\ntypedef enum kmp_proc_bind_t {\n  proc_bind_false = 0,\n  proc_bind_true,\n  proc_bind_primary,\n  proc_bind_close,\n  proc_bind_spread,\n  proc_bind_intel, // use KMP_AFFINITY interface\n  proc_bind_default\n} kmp_proc_bind_t;\n\ntypedef struct kmp_nested_proc_bind_t {\n  kmp_proc_bind_t *bind_types;\n  int size;\n  int used;\n} kmp_nested_proc_bind_t;\n\nextern kmp_nested_proc_bind_t __kmp_nested_proc_bind;\n\nextern int __kmp_display_affinity;\nextern char *__kmp_affinity_format;\nstatic const size_t KMP_AFFINITY_FORMAT_SIZE = 512;\n\n#if KMP_AFFINITY_SUPPORTED\n#define KMP_PLACE_ALL (-1)\n#define KMP_PLACE_UNDEFINED (-2)\n// Is KMP_AFFINITY is being used instead of OMP_PROC_BIND/OMP_PLACES?\n#define KMP_AFFINITY_NON_PROC_BIND                                             \\\n  ((__kmp_nested_proc_bind.bind_types[0] == proc_bind_false ||                 \\\n    __kmp_nested_proc_bind.bind_types[0] == proc_bind_intel) &&                \\\n   (__kmp_affinity_num_masks > 0 || __kmp_affinity_type == affinity_balanced))\n#endif /* KMP_AFFINITY_SUPPORTED */\n\nextern int __kmp_affinity_num_places;\n\ntypedef enum kmp_cancel_kind_t {\n  cancel_noreq = 0,\n  cancel_parallel = 1,\n  cancel_loop = 2,\n  cancel_sections = 3,\n  cancel_taskgroup = 4\n} kmp_cancel_kind_t;\n\n// KMP_HW_SUBSET support:\ntypedef struct kmp_hws_item {\n  int num;\n  int offset;\n} kmp_hws_item_t;\n\nextern kmp_hws_item_t __kmp_hws_socket;\nextern kmp_hws_item_t __kmp_hws_die;\nextern kmp_hws_item_t __kmp_hws_node;\nextern kmp_hws_item_t __kmp_hws_tile;\nextern kmp_hws_item_t __kmp_hws_core;\nextern kmp_hws_item_t __kmp_hws_proc;\nextern int __kmp_hws_requested;\nextern int __kmp_hws_abs_flag; // absolute or per-item number requested\n\n/* ------------------------------------------------------------------------ */\n\n#define KMP_PAD(type, sz)                                                      \\\n  (sizeof(type) + (sz - ((sizeof(type) - 1) % (sz)) - 1))\n\n// We need to avoid using -1 as a GTID as +1 is added to the gtid\n// when storing it in a lock, and the value 0 is reserved.\n#define KMP_GTID_DNE (-2) /* Does not exist */\n#define KMP_GTID_SHUTDOWN (-3) /* Library is shutting down */\n#define KMP_GTID_MONITOR (-4) /* Monitor thread ID */\n#define KMP_GTID_UNKNOWN (-5) /* Is not known */\n#define KMP_GTID_MIN (-6) /* Minimal gtid for low bound check in DEBUG */\n\n/* OpenMP 5.0 Memory Management support */\n\n#ifndef __OMP_H\n// Duplicate type definitions from omp.h\ntypedef uintptr_t omp_uintptr_t;\n\ntypedef enum {\n  omp_atk_sync_hint = 1,\n  omp_atk_alignment = 2,\n  omp_atk_access = 3,\n  omp_atk_pool_size = 4,\n  omp_atk_fallback = 5,\n  omp_atk_fb_data = 6,\n  omp_atk_pinned = 7,\n  omp_atk_partition = 8\n} omp_alloctrait_key_t;\n\ntypedef enum {\n  omp_atv_false = 0,\n  omp_atv_true = 1,\n  omp_atv_contended = 3,\n  omp_atv_uncontended = 4,\n  omp_atv_serialized = 5,\n  omp_atv_sequential = omp_atv_serialized, // (deprecated)\n  omp_atv_private = 6,\n  omp_atv_all = 7,\n  omp_atv_thread = 8,\n  omp_atv_pteam = 9,\n  omp_atv_cgroup = 10,\n  omp_atv_default_mem_fb = 11,\n  omp_atv_null_fb = 12,\n  omp_atv_abort_fb = 13,\n  omp_atv_allocator_fb = 14,\n  omp_atv_environment = 15,\n  omp_atv_nearest = 16,\n  omp_atv_blocked = 17,\n  omp_atv_interleaved = 18\n} omp_alloctrait_value_t;\n#define omp_atv_default ((omp_uintptr_t)-1)\n\ntypedef void *omp_memspace_handle_t;\nextern omp_memspace_handle_t const omp_default_mem_space;\nextern omp_memspace_handle_t const omp_large_cap_mem_space;\nextern omp_memspace_handle_t const omp_const_mem_space;\nextern omp_memspace_handle_t const omp_high_bw_mem_space;\nextern omp_memspace_handle_t const omp_low_lat_mem_space;\n// Preview of target memory support\nextern omp_memspace_handle_t const llvm_omp_target_host_mem_space;\nextern omp_memspace_handle_t const llvm_omp_target_shared_mem_space;\nextern omp_memspace_handle_t const llvm_omp_target_device_mem_space;\n\ntypedef struct {\n  omp_alloctrait_key_t key;\n  omp_uintptr_t value;\n} omp_alloctrait_t;\n\ntypedef void *omp_allocator_handle_t;\nextern omp_allocator_handle_t const omp_null_allocator;\nextern omp_allocator_handle_t const omp_default_mem_alloc;\nextern omp_allocator_handle_t const omp_large_cap_mem_alloc;\nextern omp_allocator_handle_t const omp_const_mem_alloc;\nextern omp_allocator_handle_t const omp_high_bw_mem_alloc;\nextern omp_allocator_handle_t const omp_low_lat_mem_alloc;\nextern omp_allocator_handle_t const omp_cgroup_mem_alloc;\nextern omp_allocator_handle_t const omp_pteam_mem_alloc;\nextern omp_allocator_handle_t const omp_thread_mem_alloc;\n// Preview of target memory support\nextern omp_allocator_handle_t const llvm_omp_target_host_mem_alloc;\nextern omp_allocator_handle_t const llvm_omp_target_shared_mem_alloc;\nextern omp_allocator_handle_t const llvm_omp_target_device_mem_alloc;\nextern omp_allocator_handle_t const kmp_max_mem_alloc;\nextern omp_allocator_handle_t __kmp_def_allocator;\n\n// end of duplicate type definitions from omp.h\n#endif\n\nextern int __kmp_memkind_available;\n\ntypedef omp_memspace_handle_t kmp_memspace_t; // placeholder\n\ntypedef struct kmp_allocator_t {\n  omp_memspace_handle_t memspace;\n  void **memkind; // pointer to memkind\n  int alignment;\n  omp_alloctrait_value_t fb;\n  kmp_allocator_t *fb_data;\n  kmp_uint64 pool_size;\n  kmp_uint64 pool_used;\n} kmp_allocator_t;\n\nextern omp_allocator_handle_t __kmpc_init_allocator(int gtid,\n                                                    omp_memspace_handle_t,\n                                                    int ntraits,\n                                                    omp_alloctrait_t traits[]);\nextern void __kmpc_destroy_allocator(int gtid, omp_allocator_handle_t al);\nextern void __kmpc_set_default_allocator(int gtid, omp_allocator_handle_t al);\nextern omp_allocator_handle_t __kmpc_get_default_allocator(int gtid);\nextern void *__kmpc_alloc(int gtid, size_t sz, omp_allocator_handle_t al);\nextern void *__kmpc_calloc(int gtid, size_t nmemb, size_t sz,\n                           omp_allocator_handle_t al);\nextern void *__kmpc_realloc(int gtid, void *ptr, size_t sz,\n                            omp_allocator_handle_t al,\n                            omp_allocator_handle_t free_al);\nextern void __kmpc_free(int gtid, void *ptr, omp_allocator_handle_t al);\n\nextern void __kmp_init_memkind();\nextern void __kmp_fini_memkind();\nextern void __kmp_init_target_mem();\n\n/* ------------------------------------------------------------------------ */\n\n#define KMP_UINT64_MAX                                                         \\\n  (~((kmp_uint64)1 << ((sizeof(kmp_uint64) * (1 << 3)) - 1)))\n\n#define KMP_MIN_NTH 1\n\n#ifndef KMP_MAX_NTH\n#if defined(PTHREAD_THREADS_MAX) && PTHREAD_THREADS_MAX < INT_MAX\n#define KMP_MAX_NTH PTHREAD_THREADS_MAX\n#else\n#define KMP_MAX_NTH INT_MAX\n#endif\n#endif /* KMP_MAX_NTH */\n\n#ifdef PTHREAD_STACK_MIN\n#define KMP_MIN_STKSIZE PTHREAD_STACK_MIN\n#else\n#define KMP_MIN_STKSIZE ((size_t)(32 * 1024))\n#endif\n\n#define KMP_MAX_STKSIZE (~((size_t)1 << ((sizeof(size_t) * (1 << 3)) - 1)))\n\n#if KMP_ARCH_X86\n#define KMP_DEFAULT_STKSIZE ((size_t)(2 * 1024 * 1024))\n#elif KMP_ARCH_X86_64\n#define KMP_DEFAULT_STKSIZE ((size_t)(4 * 1024 * 1024))\n#define KMP_BACKUP_STKSIZE ((size_t)(2 * 1024 * 1024))\n#else\n#define KMP_DEFAULT_STKSIZE ((size_t)(1024 * 1024))\n#endif\n\n#define KMP_DEFAULT_MALLOC_POOL_INCR ((size_t)(1024 * 1024))\n#define KMP_MIN_MALLOC_POOL_INCR ((size_t)(4 * 1024))\n#define KMP_MAX_MALLOC_POOL_INCR                                               \\\n  (~((size_t)1 << ((sizeof(size_t) * (1 << 3)) - 1)))\n\n#define KMP_MIN_STKOFFSET (0)\n#define KMP_MAX_STKOFFSET KMP_MAX_STKSIZE\n#if KMP_OS_DARWIN\n#define KMP_DEFAULT_STKOFFSET KMP_MIN_STKOFFSET\n#else\n#define KMP_DEFAULT_STKOFFSET CACHE_LINE\n#endif\n\n#define KMP_MIN_STKPADDING (0)\n#define KMP_MAX_STKPADDING (2 * 1024 * 1024)\n\n#define KMP_BLOCKTIME_MULTIPLIER                                               \\\n  (1000) /* number of blocktime units per second */\n#define KMP_MIN_BLOCKTIME (0)\n#define KMP_MAX_BLOCKTIME                                                      \\\n  (INT_MAX) /* Must be this for \"infinite\" setting the work */\n#define KMP_DEFAULT_BLOCKTIME (200) /*  __kmp_blocktime is in milliseconds  */\n\n#if KMP_USE_MONITOR\n#define KMP_DEFAULT_MONITOR_STKSIZE ((size_t)(64 * 1024))\n#define KMP_MIN_MONITOR_WAKEUPS (1) // min times monitor wakes up per second\n#define KMP_MAX_MONITOR_WAKEUPS (1000) // max times monitor can wake up per sec\n\n/* Calculate new number of monitor wakeups for a specific block time based on\n   previous monitor_wakeups. Only allow increasing number of wakeups */\n#define KMP_WAKEUPS_FROM_BLOCKTIME(blocktime, monitor_wakeups)                 \\\n  (((blocktime) == KMP_MAX_BLOCKTIME)   ? (monitor_wakeups)                    \\\n   : ((blocktime) == KMP_MIN_BLOCKTIME) ? KMP_MAX_MONITOR_WAKEUPS              \\\n   : ((monitor_wakeups) > (KMP_BLOCKTIME_MULTIPLIER / (blocktime)))            \\\n       ? (monitor_wakeups)                                                     \\\n       : (KMP_BLOCKTIME_MULTIPLIER) / (blocktime))\n\n/* Calculate number of intervals for a specific block time based on\n   monitor_wakeups */\n#define KMP_INTERVALS_FROM_BLOCKTIME(blocktime, monitor_wakeups)               \\\n  (((blocktime) + (KMP_BLOCKTIME_MULTIPLIER / (monitor_wakeups)) - 1) /        \\\n   (KMP_BLOCKTIME_MULTIPLIER / (monitor_wakeups)))\n#else\n#define KMP_BLOCKTIME(team, tid)                                               \\\n  (get__bt_set(team, tid) ? get__blocktime(team, tid) : __kmp_dflt_blocktime)\n#if KMP_OS_UNIX && (KMP_ARCH_X86 || KMP_ARCH_X86_64)\n// HW TSC is used to reduce overhead (clock tick instead of nanosecond).\nextern kmp_uint64 __kmp_ticks_per_msec;\n#if KMP_COMPILER_ICC\n#define KMP_NOW() ((kmp_uint64)_rdtsc())\n#else\n#define KMP_NOW() __kmp_hardware_timestamp()\n#endif\n#define KMP_NOW_MSEC() (KMP_NOW() / __kmp_ticks_per_msec)\n#define KMP_BLOCKTIME_INTERVAL(team, tid)                                      \\\n  (KMP_BLOCKTIME(team, tid) * __kmp_ticks_per_msec)\n#define KMP_BLOCKING(goal, count) ((goal) > KMP_NOW())\n#else\n// System time is retrieved sporadically while blocking.\nextern kmp_uint64 __kmp_now_nsec();\n#define KMP_NOW() __kmp_now_nsec()\n#define KMP_NOW_MSEC() (KMP_NOW() / KMP_USEC_PER_SEC)\n#define KMP_BLOCKTIME_INTERVAL(team, tid)                                      \\\n  (KMP_BLOCKTIME(team, tid) * KMP_USEC_PER_SEC)\n#define KMP_BLOCKING(goal, count) ((count) % 1000 != 0 || (goal) > KMP_NOW())\n#endif\n#endif // KMP_USE_MONITOR\n\n#define KMP_MIN_STATSCOLS 40\n#define KMP_MAX_STATSCOLS 4096\n#define KMP_DEFAULT_STATSCOLS 80\n\n#define KMP_MIN_INTERVAL 0\n#define KMP_MAX_INTERVAL (INT_MAX - 1)\n#define KMP_DEFAULT_INTERVAL 0\n\n#define KMP_MIN_CHUNK 1\n#define KMP_MAX_CHUNK (INT_MAX - 1)\n#define KMP_DEFAULT_CHUNK 1\n\n#define KMP_MIN_DISP_NUM_BUFF 1\n#define KMP_DFLT_DISP_NUM_BUFF 7\n#define KMP_MAX_DISP_NUM_BUFF 4096\n\n#define KMP_MAX_ORDERED 8\n\n#define KMP_MAX_FIELDS 32\n\n#define KMP_MAX_BRANCH_BITS 31\n\n#define KMP_MAX_ACTIVE_LEVELS_LIMIT INT_MAX\n\n#define KMP_MAX_DEFAULT_DEVICE_LIMIT INT_MAX\n\n#define KMP_MAX_TASK_PRIORITY_LIMIT INT_MAX\n\n/* Minimum number of threads before switch to TLS gtid (experimentally\n   determined) */\n/* josh TODO: what about OS X* tuning? */\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n#define KMP_TLS_GTID_MIN 5\n#else\n#define KMP_TLS_GTID_MIN INT_MAX\n#endif\n\n#define KMP_MASTER_TID(tid) (0 == (tid))\n#define KMP_WORKER_TID(tid) (0 != (tid))\n\n#define KMP_MASTER_GTID(gtid) (0 == __kmp_tid_from_gtid((gtid)))\n#define KMP_WORKER_GTID(gtid) (0 != __kmp_tid_from_gtid((gtid)))\n#define KMP_INITIAL_GTID(gtid) (0 == (gtid))\n\n#ifndef TRUE\n#define FALSE 0\n#define TRUE (!FALSE)\n#endif\n\n/* NOTE: all of the following constants must be even */\n\n#if KMP_OS_WINDOWS\n#define KMP_INIT_WAIT 64U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 32U /* susequent number of spin-tests */\n#elif KMP_OS_LINUX\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_DARWIN\n/* TODO: tune for KMP_OS_DARWIN */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_DRAGONFLY\n/* TODO: tune for KMP_OS_DRAGONFLY */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_FREEBSD\n/* TODO: tune for KMP_OS_FREEBSD */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_NETBSD\n/* TODO: tune for KMP_OS_NETBSD */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_HURD\n/* TODO: tune for KMP_OS_HURD */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#elif KMP_OS_OPENBSD\n/* TODO: tune for KMP_OS_OPENBSD */\n#define KMP_INIT_WAIT 1024U /* initial number of spin-tests   */\n#define KMP_NEXT_WAIT 512U /* susequent number of spin-tests */\n#endif\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\ntypedef struct kmp_cpuid {\n  kmp_uint32 eax;\n  kmp_uint32 ebx;\n  kmp_uint32 ecx;\n  kmp_uint32 edx;\n} kmp_cpuid_t;\n\ntypedef struct kmp_cpuinfo {\n  int initialized; // If 0, other fields are not initialized.\n  int signature; // CPUID(1).EAX\n  int family; // CPUID(1).EAX[27:20]+CPUID(1).EAX[11:8] (Extended Family+Family)\n  int model; // ( CPUID(1).EAX[19:16] << 4 ) + CPUID(1).EAX[7:4] ( ( Extended\n  // Model << 4 ) + Model)\n  int stepping; // CPUID(1).EAX[3:0] ( Stepping )\n  int sse2; // 0 if SSE2 instructions are not supported, 1 otherwise.\n  int rtm; // 0 if RTM instructions are not supported, 1 otherwise.\n  int apic_id;\n  int physical_id;\n  int logical_id;\n  kmp_uint64 frequency; // Nominal CPU frequency in Hz.\n  char name[3 * sizeof(kmp_cpuid_t)]; // CPUID(0x80000002,0x80000003,0x80000004)\n} kmp_cpuinfo_t;\n\nextern void __kmp_query_cpuid(kmp_cpuinfo_t *p);\n\n#if KMP_OS_UNIX\n// subleaf is only needed for cache and topology discovery and can be set to\n// zero in most cases\nstatic inline void __kmp_x86_cpuid(int leaf, int subleaf, struct kmp_cpuid *p) {\n  __asm__ __volatile__(\"cpuid\"\n                       : \"=a\"(p->eax), \"=b\"(p->ebx), \"=c\"(p->ecx), \"=d\"(p->edx)\n                       : \"a\"(leaf), \"c\"(subleaf));\n}\n// Load p into FPU control word\nstatic inline void __kmp_load_x87_fpu_control_word(const kmp_int16 *p) {\n  __asm__ __volatile__(\"fldcw %0\" : : \"m\"(*p));\n}\n// Store FPU control word into p\nstatic inline void __kmp_store_x87_fpu_control_word(kmp_int16 *p) {\n  __asm__ __volatile__(\"fstcw %0\" : \"=m\"(*p));\n}\nstatic inline void __kmp_clear_x87_fpu_status_word() {\n#if KMP_MIC\n  // 32-bit protected mode x87 FPU state\n  struct x87_fpu_state {\n    unsigned cw;\n    unsigned sw;\n    unsigned tw;\n    unsigned fip;\n    unsigned fips;\n    unsigned fdp;\n    unsigned fds;\n  };\n  struct x87_fpu_state fpu_state = {0, 0, 0, 0, 0, 0, 0};\n  __asm__ __volatile__(\"fstenv %0\\n\\t\" // store FP env\n                       \"andw $0x7f00, %1\\n\\t\" // clear 0-7,15 bits of FP SW\n                       \"fldenv %0\\n\\t\" // load FP env back\n                       : \"+m\"(fpu_state), \"+m\"(fpu_state.sw));\n#else\n  __asm__ __volatile__(\"fnclex\");\n#endif // KMP_MIC\n}\n#if __SSE__\nstatic inline void __kmp_load_mxcsr(const kmp_uint32 *p) { _mm_setcsr(*p); }\nstatic inline void __kmp_store_mxcsr(kmp_uint32 *p) { *p = _mm_getcsr(); }\n#else\nstatic inline void __kmp_load_mxcsr(const kmp_uint32 *p) {}\nstatic inline void __kmp_store_mxcsr(kmp_uint32 *p) { *p = 0; }\n#endif\n#else\n// Windows still has these as external functions in assembly file\nextern void __kmp_x86_cpuid(int mode, int mode2, struct kmp_cpuid *p);\nextern void __kmp_load_x87_fpu_control_word(const kmp_int16 *p);\nextern void __kmp_store_x87_fpu_control_word(kmp_int16 *p);\nextern void __kmp_clear_x87_fpu_status_word();\nstatic inline void __kmp_load_mxcsr(const kmp_uint32 *p) { _mm_setcsr(*p); }\nstatic inline void __kmp_store_mxcsr(kmp_uint32 *p) { *p = _mm_getcsr(); }\n#endif // KMP_OS_UNIX\n\n#define KMP_X86_MXCSR_MASK 0xffffffc0 /* ignore status flags (6 lsb) */\n\n#if KMP_ARCH_X86\nextern void __kmp_x86_pause(void);\n#elif KMP_MIC\n// Performance testing on KNC (C0QS-7120 P/A/X/D, 61-core, 16 GB Memory) showed\n// regression after removal of extra PAUSE from spin loops. Changing\n// the delay from 100 to 300 showed even better performance than double PAUSE\n// on Spec OMP2001 and LCPC tasking tests, no regressions on EPCC.\nstatic inline void __kmp_x86_pause(void) { _mm_delay_32(300); }\n#else\nstatic inline void __kmp_x86_pause(void) { _mm_pause(); }\n#endif\n#define KMP_CPU_PAUSE() __kmp_x86_pause()\n#elif KMP_ARCH_PPC64\n#define KMP_PPC64_PRI_LOW() __asm__ volatile(\"or 1, 1, 1\")\n#define KMP_PPC64_PRI_MED() __asm__ volatile(\"or 2, 2, 2\")\n#define KMP_PPC64_PRI_LOC_MB() __asm__ volatile(\"\" : : : \"memory\")\n#define KMP_CPU_PAUSE()                                                        \\\n  do {                                                                         \\\n    KMP_PPC64_PRI_LOW();                                                       \\\n    KMP_PPC64_PRI_MED();                                                       \\\n    KMP_PPC64_PRI_LOC_MB();                                                    \\\n  } while (0)\n#else\n#define KMP_CPU_PAUSE() /* nothing to do */\n#endif\n\n#define KMP_INIT_YIELD(count)                                                  \\\n  { (count) = __kmp_yield_init; }\n\n#define KMP_OVERSUBSCRIBED                                                     \\\n  (TCR_4(__kmp_nth) > (__kmp_avail_proc ? __kmp_avail_proc : __kmp_xproc))\n\n#define KMP_TRY_YIELD                                                          \\\n  ((__kmp_use_yield == 1) || (__kmp_use_yield == 2 && (KMP_OVERSUBSCRIBED)))\n\n#define KMP_TRY_YIELD_OVERSUB                                                  \\\n  ((__kmp_use_yield == 1 || __kmp_use_yield == 2) && (KMP_OVERSUBSCRIBED))\n\n#define KMP_YIELD(cond)                                                        \\\n  {                                                                            \\\n    KMP_CPU_PAUSE();                                                           \\\n    if ((cond) && (KMP_TRY_YIELD))                                             \\\n      __kmp_yield();                                                           \\\n  }\n\n#define KMP_YIELD_OVERSUB()                                                    \\\n  {                                                                            \\\n    KMP_CPU_PAUSE();                                                           \\\n    if ((KMP_TRY_YIELD_OVERSUB))                                               \\\n      __kmp_yield();                                                           \\\n  }\n\n// Note the decrement of 2 in the following Macros. With KMP_LIBRARY=turnaround,\n// there should be no yielding since initial value from KMP_INIT_YIELD() is odd.\n#define KMP_YIELD_SPIN(count)                                                  \\\n  {                                                                            \\\n    KMP_CPU_PAUSE();                                                           \\\n    if (KMP_TRY_YIELD) {                                                       \\\n      (count) -= 2;                                                            \\\n      if (!(count)) {                                                          \\\n        __kmp_yield();                                                         \\\n        (count) = __kmp_yield_next;                                            \\\n      }                                                                        \\\n    }                                                                          \\\n  }\n\n#define KMP_YIELD_OVERSUB_ELSE_SPIN(count)                                     \\\n  {                                                                            \\\n    KMP_CPU_PAUSE();                                                           \\\n    if ((KMP_TRY_YIELD_OVERSUB))                                               \\\n      __kmp_yield();                                                           \\\n    else if (__kmp_use_yield == 1) {                                           \\\n      (count) -= 2;                                                            \\\n      if (!(count)) {                                                          \\\n        __kmp_yield();                                                         \\\n        (count) = __kmp_yield_next;                                            \\\n      }                                                                        \\\n    }                                                                          \\\n  }\n\n// User-level Monitor/Mwait\n#if KMP_HAVE_UMWAIT\n// We always try for UMWAIT first\n#if KMP_HAVE_WAITPKG_INTRINSICS\n#if KMP_HAVE_IMMINTRIN_H\n#include <immintrin.h>\n#elif KMP_HAVE_INTRIN_H\n#include <intrin.h>\n#endif\n#endif // KMP_HAVE_WAITPKG_INTRINSICS\nKMP_ATTRIBUTE_TARGET_WAITPKG\nstatic inline int __kmp_tpause(uint32_t hint, uint64_t counter) {\n#if !KMP_HAVE_WAITPKG_INTRINSICS\n  uint32_t timeHi = uint32_t(counter >> 32);\n  uint32_t timeLo = uint32_t(counter & 0xffffffff);\n  char flag;\n  __asm__ volatile(\"#tpause\\n.byte 0x66, 0x0F, 0xAE, 0xF1\\n\"\n                   \"setb   %0\"\n                   : \"=r\"(flag)\n                   : \"a\"(timeLo), \"d\"(timeHi), \"c\"(hint)\n                   :);\n  return flag;\n#else\n  return _tpause(hint, counter);\n#endif\n}\nKMP_ATTRIBUTE_TARGET_WAITPKG\nstatic inline void __kmp_umonitor(void *cacheline) {\n#if !KMP_HAVE_WAITPKG_INTRINSICS\n  __asm__ volatile(\"# umonitor\\n.byte 0xF3, 0x0F, 0xAE, 0x01 \"\n                   :\n                   : \"a\"(cacheline)\n                   :);\n#else\n  _umonitor(cacheline);\n#endif\n}\nKMP_ATTRIBUTE_TARGET_WAITPKG\nstatic inline int __kmp_umwait(uint32_t hint, uint64_t counter) {\n#if !KMP_HAVE_WAITPKG_INTRINSICS\n  uint32_t timeHi = uint32_t(counter >> 32);\n  uint32_t timeLo = uint32_t(counter & 0xffffffff);\n  char flag;\n  __asm__ volatile(\"#umwait\\n.byte 0xF2, 0x0F, 0xAE, 0xF1\\n\"\n                   \"setb   %0\"\n                   : \"=r\"(flag)\n                   : \"a\"(timeLo), \"d\"(timeHi), \"c\"(hint)\n                   :);\n  return flag;\n#else\n  return _umwait(hint, counter);\n#endif\n}\n#elif KMP_HAVE_MWAIT\n#if KMP_OS_UNIX\n#include <pmmintrin.h>\n#else\n#include <intrin.h>\n#endif\n#if KMP_OS_UNIX\n__attribute__((target(\"sse3\")))\n#endif\nstatic inline void\n__kmp_mm_monitor(void *cacheline, unsigned extensions, unsigned hints) {\n  _mm_monitor(cacheline, extensions, hints);\n}\n#if KMP_OS_UNIX\n__attribute__((target(\"sse3\")))\n#endif\nstatic inline void\n__kmp_mm_mwait(unsigned extensions, unsigned hints) {\n  _mm_mwait(extensions, hints);\n}\n#endif // KMP_HAVE_UMWAIT\n\n/* ------------------------------------------------------------------------ */\n/* Support datatypes for the orphaned construct nesting checks.             */\n/* ------------------------------------------------------------------------ */\n\nenum cons_type {\n  ct_none,\n  ct_parallel,\n  ct_pdo,\n  ct_pdo_ordered,\n  ct_psections,\n  ct_psingle,\n  ct_critical,\n  ct_ordered_in_parallel,\n  ct_ordered_in_pdo,\n  ct_master,\n  ct_reduce,\n  ct_barrier,\n  ct_masked\n};\n\n#define IS_CONS_TYPE_ORDERED(ct) ((ct) == ct_pdo_ordered)\n\nstruct cons_data {\n  ident_t const *ident;\n  enum cons_type type;\n  int prev;\n  kmp_user_lock_p\n      name; /* address exclusively for critical section name comparison */\n};\n\nstruct cons_header {\n  int p_top, w_top, s_top;\n  int stack_size, stack_top;\n  struct cons_data *stack_data;\n};\n\nstruct kmp_region_info {\n  char *text;\n  int offset[KMP_MAX_FIELDS];\n  int length[KMP_MAX_FIELDS];\n};\n\n/* ---------------------------------------------------------------------- */\n/* ---------------------------------------------------------------------- */\n\n#if KMP_OS_WINDOWS\ntypedef HANDLE kmp_thread_t;\ntypedef DWORD kmp_key_t;\n#endif /* KMP_OS_WINDOWS */\n\n#if KMP_OS_UNIX\ntypedef pthread_t kmp_thread_t;\ntypedef pthread_key_t kmp_key_t;\n#endif\n\nextern kmp_key_t __kmp_gtid_threadprivate_key;\n\ntypedef struct kmp_sys_info {\n  long maxrss; /* the maximum resident set size utilized (in kilobytes)     */\n  long minflt; /* the number of page faults serviced without any I/O        */\n  long majflt; /* the number of page faults serviced that required I/O      */\n  long nswap; /* the number of times a process was \"swapped\" out of memory */\n  long inblock; /* the number of times the file system had to perform input  */\n  long oublock; /* the number of times the file system had to perform output */\n  long nvcsw; /* the number of times a context switch was voluntarily      */\n  long nivcsw; /* the number of times a context switch was forced           */\n} kmp_sys_info_t;\n\n#if USE_ITT_BUILD\n// We cannot include \"kmp_itt.h\" due to circular dependency. Declare the only\n// required type here. Later we will check the type meets requirements.\ntypedef int kmp_itt_mark_t;\n#define KMP_ITT_DEBUG 0\n#endif /* USE_ITT_BUILD */\n\ntypedef kmp_int32 kmp_critical_name[8];\n\n/*!\n@ingroup PARALLEL\nThe type for a microtask which gets passed to @ref __kmpc_fork_call().\nThe arguments to the outlined function are\n@param global_tid the global thread identity of the thread executing the\nfunction.\n@param bound_tid  the local identity of the thread executing the function\n@param ... pointers to shared variables accessed by the function.\n*/\ntypedef void (*kmpc_micro)(kmp_int32 *global_tid, kmp_int32 *bound_tid, ...);\ntypedef void (*kmpc_micro_bound)(kmp_int32 *bound_tid, kmp_int32 *bound_nth,\n                                 ...);\n\n/*!\n@ingroup THREADPRIVATE\n@{\n*/\n/* ---------------------------------------------------------------------------\n */\n/* Threadprivate initialization/finalization function declarations */\n\n/*  for non-array objects:  __kmpc_threadprivate_register()  */\n\n/*!\n Pointer to the constructor function.\n The first argument is the <tt>this</tt> pointer\n*/\ntypedef void *(*kmpc_ctor)(void *);\n\n/*!\n Pointer to the destructor function.\n The first argument is the <tt>this</tt> pointer\n*/\ntypedef void (*kmpc_dtor)(\n    void * /*, size_t */); /* 2nd arg: magic number for KCC unused by Intel\n                              compiler */\n/*!\n Pointer to an alternate constructor.\n The first argument is the <tt>this</tt> pointer.\n*/\ntypedef void *(*kmpc_cctor)(void *, void *);\n\n/* for array objects: __kmpc_threadprivate_register_vec() */\n/* First arg: \"this\" pointer */\n/* Last arg: number of array elements */\n/*!\n Array constructor.\n First argument is the <tt>this</tt> pointer\n Second argument the number of array elements.\n*/\ntypedef void *(*kmpc_ctor_vec)(void *, size_t);\n/*!\n Pointer to the array destructor function.\n The first argument is the <tt>this</tt> pointer\n Second argument the number of array elements.\n*/\ntypedef void (*kmpc_dtor_vec)(void *, size_t);\n/*!\n Array constructor.\n First argument is the <tt>this</tt> pointer\n Third argument the number of array elements.\n*/\ntypedef void *(*kmpc_cctor_vec)(void *, void *,\n                                size_t); /* function unused by compiler */\n\n/*!\n@}\n*/\n\n/* keeps tracked of threadprivate cache allocations for cleanup later */\ntypedef struct kmp_cached_addr {\n  void **addr; /* address of allocated cache */\n  void ***compiler_cache; /* pointer to compiler's cache */\n  void *data; /* pointer to global data */\n  struct kmp_cached_addr *next; /* pointer to next cached address */\n} kmp_cached_addr_t;\n\nstruct private_data {\n  struct private_data *next; /* The next descriptor in the list      */\n  void *data; /* The data buffer for this descriptor  */\n  int more; /* The repeat count for this descriptor */\n  size_t size; /* The data size for this descriptor    */\n};\n\nstruct private_common {\n  struct private_common *next;\n  struct private_common *link;\n  void *gbl_addr;\n  void *par_addr; /* par_addr == gbl_addr for PRIMARY thread */\n  size_t cmn_size;\n};\n\nstruct shared_common {\n  struct shared_common *next;\n  struct private_data *pod_init;\n  void *obj_init;\n  void *gbl_addr;\n  union {\n    kmpc_ctor ctor;\n    kmpc_ctor_vec ctorv;\n  } ct;\n  union {\n    kmpc_cctor cctor;\n    kmpc_cctor_vec cctorv;\n  } cct;\n  union {\n    kmpc_dtor dtor;\n    kmpc_dtor_vec dtorv;\n  } dt;\n  size_t vec_len;\n  int is_vec;\n  size_t cmn_size;\n};\n\n#define KMP_HASH_TABLE_LOG2 9 /* log2 of the hash table size */\n#define KMP_HASH_TABLE_SIZE                                                    \\\n  (1 << KMP_HASH_TABLE_LOG2) /* size of the hash table */\n#define KMP_HASH_SHIFT 3 /* throw away this many low bits from the address */\n#define KMP_HASH(x)                                                            \\\n  ((((kmp_uintptr_t)x) >> KMP_HASH_SHIFT) & (KMP_HASH_TABLE_SIZE - 1))\n\nstruct common_table {\n  struct private_common *data[KMP_HASH_TABLE_SIZE];\n};\n\nstruct shared_table {\n  struct shared_common *data[KMP_HASH_TABLE_SIZE];\n};\n\n/* ------------------------------------------------------------------------ */\n\n#if KMP_USE_HIER_SCHED\n// Shared barrier data that exists inside a single unit of the scheduling\n// hierarchy\ntypedef struct kmp_hier_private_bdata_t {\n  kmp_int32 num_active;\n  kmp_uint64 index;\n  kmp_uint64 wait_val[2];\n} kmp_hier_private_bdata_t;\n#endif\n\ntypedef struct kmp_sched_flags {\n  unsigned ordered : 1;\n  unsigned nomerge : 1;\n  unsigned contains_last : 1;\n#if KMP_USE_HIER_SCHED\n  unsigned use_hier : 1;\n  unsigned unused : 28;\n#else\n  unsigned unused : 29;\n#endif\n} kmp_sched_flags_t;\n\nKMP_BUILD_ASSERT(sizeof(kmp_sched_flags_t) == 4);\n\n#if KMP_STATIC_STEAL_ENABLED\ntypedef struct KMP_ALIGN_CACHE dispatch_private_info32 {\n  kmp_int32 count;\n  kmp_int32 ub;\n  /* Adding KMP_ALIGN_CACHE here doesn't help / can hurt performance */\n  kmp_int32 lb;\n  kmp_int32 st;\n  kmp_int32 tc;\n  kmp_int32 static_steal_counter; /* for static_steal only; maybe better to put\n                                     after ub */\n  kmp_lock_t *th_steal_lock; // lock used for chunk stealing\n  // KMP_ALIGN( 16 ) ensures ( if the KMP_ALIGN macro is turned on )\n  //    a) parm3 is properly aligned and\n  //    b) all parm1-4 are in the same cache line.\n  // Because of parm1-4 are used together, performance seems to be better\n  // if they are in the same line (not measured though).\n\n  struct KMP_ALIGN(32) { // AC: changed 16 to 32 in order to simplify template\n    kmp_int32 parm1; //     structures in kmp_dispatch.cpp. This should\n    kmp_int32 parm2; //     make no real change at least while padding is off.\n    kmp_int32 parm3;\n    kmp_int32 parm4;\n  };\n\n  kmp_uint32 ordered_lower;\n  kmp_uint32 ordered_upper;\n#if KMP_OS_WINDOWS\n  // This var can be placed in the hole between 'tc' and 'parm1', instead of\n  // 'static_steal_counter'. It would be nice to measure execution times.\n  // Conditional if/endif can be removed at all.\n  kmp_int32 last_upper;\n#endif /* KMP_OS_WINDOWS */\n} dispatch_private_info32_t;\n\ntypedef struct KMP_ALIGN_CACHE dispatch_private_info64 {\n  kmp_int64 count; // current chunk number for static & static-steal scheduling\n  kmp_int64 ub; /* upper-bound */\n  /* Adding KMP_ALIGN_CACHE here doesn't help / can hurt performance */\n  kmp_int64 lb; /* lower-bound */\n  kmp_int64 st; /* stride */\n  kmp_int64 tc; /* trip count (number of iterations) */\n  kmp_int64 static_steal_counter; /* for static_steal only; maybe better to put\n                                     after ub */\n  kmp_lock_t *th_steal_lock; // lock used for chunk stealing\n  /* parm[1-4] are used in different ways by different scheduling algorithms */\n\n  // KMP_ALIGN( 32 ) ensures ( if the KMP_ALIGN macro is turned on )\n  //    a) parm3 is properly aligned and\n  //    b) all parm1-4 are in the same cache line.\n  // Because of parm1-4 are used together, performance seems to be better\n  // if they are in the same line (not measured though).\n\n  struct KMP_ALIGN(32) {\n    kmp_int64 parm1;\n    kmp_int64 parm2;\n    kmp_int64 parm3;\n    kmp_int64 parm4;\n  };\n\n  kmp_uint64 ordered_lower;\n  kmp_uint64 ordered_upper;\n#if KMP_OS_WINDOWS\n  // This var can be placed in the hole between 'tc' and 'parm1', instead of\n  // 'static_steal_counter'. It would be nice to measure execution times.\n  // Conditional if/endif can be removed at all.\n  kmp_int64 last_upper;\n#endif /* KMP_OS_WINDOWS */\n} dispatch_private_info64_t;\n#else /* KMP_STATIC_STEAL_ENABLED */\ntypedef struct KMP_ALIGN_CACHE dispatch_private_info32 {\n  kmp_int32 lb;\n  kmp_int32 ub;\n  kmp_int32 st;\n  kmp_int32 tc;\n\n  kmp_int32 parm1;\n  kmp_int32 parm2;\n  kmp_int32 parm3;\n  kmp_int32 parm4;\n\n  kmp_int32 count;\n\n  kmp_uint32 ordered_lower;\n  kmp_uint32 ordered_upper;\n#if KMP_OS_WINDOWS\n  kmp_int32 last_upper;\n#endif /* KMP_OS_WINDOWS */\n} dispatch_private_info32_t;\n\ntypedef struct KMP_ALIGN_CACHE dispatch_private_info64 {\n  kmp_int64 lb; /* lower-bound */\n  kmp_int64 ub; /* upper-bound */\n  kmp_int64 st; /* stride */\n  kmp_int64 tc; /* trip count (number of iterations) */\n\n  /* parm[1-4] are used in different ways by different scheduling algorithms */\n  kmp_int64 parm1;\n  kmp_int64 parm2;\n  kmp_int64 parm3;\n  kmp_int64 parm4;\n\n  kmp_int64 count; /* current chunk number for static scheduling */\n\n  kmp_uint64 ordered_lower;\n  kmp_uint64 ordered_upper;\n#if KMP_OS_WINDOWS\n  kmp_int64 last_upper;\n#endif /* KMP_OS_WINDOWS */\n} dispatch_private_info64_t;\n#endif /* KMP_STATIC_STEAL_ENABLED */\n\ntypedef struct KMP_ALIGN_CACHE dispatch_private_info {\n  union private_info {\n    dispatch_private_info32_t p32;\n    dispatch_private_info64_t p64;\n  } u;\n  enum sched_type schedule; /* scheduling algorithm */\n  kmp_sched_flags_t flags; /* flags (e.g., ordered, nomerge, etc.) */\n  kmp_int32 ordered_bumped;\n  // To retain the structure size after making ordered_iteration scalar\n  kmp_int32 ordered_dummy[KMP_MAX_ORDERED - 3];\n  // Stack of buffers for nest of serial regions\n  struct dispatch_private_info *next;\n  kmp_int32 type_size; /* the size of types in private_info */\n#if KMP_USE_HIER_SCHED\n  kmp_int32 hier_id;\n  void *parent; /* hierarchical scheduling parent pointer */\n#endif\n  enum cons_type pushed_ws;\n} dispatch_private_info_t;\n\ntypedef struct dispatch_shared_info32 {\n  /* chunk index under dynamic, number of idle threads under static-steal;\n     iteration index otherwise */\n  volatile kmp_uint32 iteration;\n  volatile kmp_uint32 num_done;\n  volatile kmp_uint32 ordered_iteration;\n  // Dummy to retain the structure size after making ordered_iteration scalar\n  kmp_int32 ordered_dummy[KMP_MAX_ORDERED - 1];\n} dispatch_shared_info32_t;\n\ntypedef struct dispatch_shared_info64 {\n  /* chunk index under dynamic, number of idle threads under static-steal;\n     iteration index otherwise */\n  volatile kmp_uint64 iteration;\n  volatile kmp_uint64 num_done;\n  volatile kmp_uint64 ordered_iteration;\n  // Dummy to retain the structure size after making ordered_iteration scalar\n  kmp_int64 ordered_dummy[KMP_MAX_ORDERED - 3];\n} dispatch_shared_info64_t;\n\ntypedef struct dispatch_shared_info {\n  union shared_info {\n    dispatch_shared_info32_t s32;\n    dispatch_shared_info64_t s64;\n  } u;\n  volatile kmp_uint32 buffer_index;\n  volatile kmp_int32 doacross_buf_idx; // teamwise index\n  volatile kmp_uint32 *doacross_flags; // shared array of iteration flags (0/1)\n  kmp_int32 doacross_num_done; // count finished threads\n#if KMP_USE_HIER_SCHED\n  void *hier;\n#endif\n#if KMP_USE_HWLOC\n  // When linking with libhwloc, the ORDERED EPCC test slows down on big\n  // machines (> 48 cores). Performance analysis showed that a cache thrash\n  // was occurring and this padding helps alleviate the problem.\n  char padding[64];\n#endif\n} dispatch_shared_info_t;\n\ntypedef struct kmp_disp {\n  /* Vector for ORDERED SECTION */\n  void (*th_deo_fcn)(int *gtid, int *cid, ident_t *);\n  /* Vector for END ORDERED SECTION */\n  void (*th_dxo_fcn)(int *gtid, int *cid, ident_t *);\n\n  dispatch_shared_info_t *th_dispatch_sh_current;\n  dispatch_private_info_t *th_dispatch_pr_current;\n\n  dispatch_private_info_t *th_disp_buffer;\n  kmp_int32 th_disp_index;\n  kmp_int32 th_doacross_buf_idx; // thread's doacross buffer index\n  volatile kmp_uint32 *th_doacross_flags; // pointer to shared array of flags\n  kmp_int64 *th_doacross_info; // info on loop bounds\n#if KMP_USE_INTERNODE_ALIGNMENT\n  char more_padding[INTERNODE_CACHE_LINE];\n#endif\n} kmp_disp_t;\n\n/* ------------------------------------------------------------------------ */\n/* Barrier stuff */\n\n/* constants for barrier state update */\n#define KMP_INIT_BARRIER_STATE 0 /* should probably start from zero */\n#define KMP_BARRIER_SLEEP_BIT 0 /* bit used for suspend/sleep part of state */\n#define KMP_BARRIER_UNUSED_BIT 1 // bit that must never be set for valid state\n#define KMP_BARRIER_BUMP_BIT 2 /* lsb used for bump of go/arrived state */\n\n#define KMP_BARRIER_SLEEP_STATE (1 << KMP_BARRIER_SLEEP_BIT)\n#define KMP_BARRIER_UNUSED_STATE (1 << KMP_BARRIER_UNUSED_BIT)\n#define KMP_BARRIER_STATE_BUMP (1 << KMP_BARRIER_BUMP_BIT)\n\n#if (KMP_BARRIER_SLEEP_BIT >= KMP_BARRIER_BUMP_BIT)\n#error \"Barrier sleep bit must be smaller than barrier bump bit\"\n#endif\n#if (KMP_BARRIER_UNUSED_BIT >= KMP_BARRIER_BUMP_BIT)\n#error \"Barrier unused bit must be smaller than barrier bump bit\"\n#endif\n\n// Constants for release barrier wait state: currently, hierarchical only\n#define KMP_BARRIER_NOT_WAITING 0 // Normal state; worker not in wait_sleep\n#define KMP_BARRIER_OWN_FLAG                                                   \\\n  1 // Normal state; worker waiting on own b_go flag in release\n#define KMP_BARRIER_PARENT_FLAG                                                \\\n  2 // Special state; worker waiting on parent's b_go flag in release\n#define KMP_BARRIER_SWITCH_TO_OWN_FLAG                                         \\\n  3 // Special state; tells worker to shift from parent to own b_go\n#define KMP_BARRIER_SWITCHING                                                  \\\n  4 // Special state; worker resets appropriate flag on wake-up\n\n#define KMP_NOT_SAFE_TO_REAP                                                   \\\n  0 // Thread th_reap_state: not safe to reap (tasking)\n#define KMP_SAFE_TO_REAP 1 // Thread th_reap_state: safe to reap (not tasking)\n\nenum barrier_type {\n  bs_plain_barrier = 0, /* 0, All non-fork/join barriers (except reduction\n                           barriers if enabled) */\n  bs_forkjoin_barrier, /* 1, All fork/join (parallel region) barriers */\n#if KMP_FAST_REDUCTION_BARRIER\n  bs_reduction_barrier, /* 2, All barriers that are used in reduction */\n#endif // KMP_FAST_REDUCTION_BARRIER\n  bs_last_barrier /* Just a placeholder to mark the end */\n};\n\n// to work with reduction barriers just like with plain barriers\n#if !KMP_FAST_REDUCTION_BARRIER\n#define bs_reduction_barrier bs_plain_barrier\n#endif // KMP_FAST_REDUCTION_BARRIER\n\ntypedef enum kmp_bar_pat { /* Barrier communication patterns */\n                           bp_linear_bar =\n                               0, /* Single level (degenerate) tree */\n                           bp_tree_bar =\n                               1, /* Balanced tree with branching factor 2^n */\n                           bp_hyper_bar = 2, /* Hypercube-embedded tree with min\n                                                branching factor 2^n */\n                           bp_hierarchical_bar = 3, /* Machine hierarchy tree */\n                           bp_last_bar /* Placeholder to mark the end */\n} kmp_bar_pat_e;\n\n#define KMP_BARRIER_ICV_PUSH 1\n\n/* Record for holding the values of the internal controls stack records */\ntypedef struct kmp_internal_control {\n  int serial_nesting_level; /* corresponds to the value of the\n                               th_team_serialized field */\n  kmp_int8 dynamic; /* internal control for dynamic adjustment of threads (per\n                       thread) */\n  kmp_int8\n      bt_set; /* internal control for whether blocktime is explicitly set */\n  int blocktime; /* internal control for blocktime */\n#if KMP_USE_MONITOR\n  int bt_intervals; /* internal control for blocktime intervals */\n#endif\n  int nproc; /* internal control for #threads for next parallel region (per\n                thread) */\n  int thread_limit; /* internal control for thread-limit-var */\n  int max_active_levels; /* internal control for max_active_levels */\n  kmp_r_sched_t\n      sched; /* internal control for runtime schedule {sched,chunk} pair */\n  kmp_proc_bind_t proc_bind; /* internal control for affinity  */\n  kmp_int32 default_device; /* internal control for default device */\n  struct kmp_internal_control *next;\n} kmp_internal_control_t;\n\nstatic inline void copy_icvs(kmp_internal_control_t *dst,\n                             kmp_internal_control_t *src) {\n  *dst = *src;\n}\n\n/* Thread barrier needs volatile barrier fields */\ntypedef struct KMP_ALIGN_CACHE kmp_bstate {\n  // th_fixed_icvs is aligned by virtue of kmp_bstate being aligned (and all\n  // uses of it). It is not explicitly aligned below, because we *don't* want\n  // it to be padded -- instead, we fit b_go into the same cache line with\n  // th_fixed_icvs, enabling NGO cache lines stores in the hierarchical barrier.\n  kmp_internal_control_t th_fixed_icvs; // Initial ICVs for the thread\n  // Tuck b_go into end of th_fixed_icvs cache line, so it can be stored with\n  // same NGO store\n  volatile kmp_uint64 b_go; // STATE => task should proceed (hierarchical)\n  KMP_ALIGN_CACHE volatile kmp_uint64\n      b_arrived; // STATE => task reached synch point.\n  kmp_uint32 *skip_per_level;\n  kmp_uint32 my_level;\n  kmp_int32 parent_tid;\n  kmp_int32 old_tid;\n  kmp_uint32 depth;\n  struct kmp_bstate *parent_bar;\n  kmp_team_t *team;\n  kmp_uint64 leaf_state;\n  kmp_uint32 nproc;\n  kmp_uint8 base_leaf_kids;\n  kmp_uint8 leaf_kids;\n  kmp_uint8 offset;\n  kmp_uint8 wait_flag;\n  kmp_uint8 use_oncore_barrier;\n#if USE_DEBUGGER\n  // The following field is intended for the debugger solely. Only the worker\n  // thread itself accesses this field: the worker increases it by 1 when it\n  // arrives to a barrier.\n  KMP_ALIGN_CACHE kmp_uint b_worker_arrived;\n#endif /* USE_DEBUGGER */\n} kmp_bstate_t;\n\nunion KMP_ALIGN_CACHE kmp_barrier_union {\n  double b_align; /* use worst case alignment */\n  char b_pad[KMP_PAD(kmp_bstate_t, CACHE_LINE)];\n  kmp_bstate_t bb;\n};\n\ntypedef union kmp_barrier_union kmp_balign_t;\n\n/* Team barrier needs only non-volatile arrived counter */\nunion KMP_ALIGN_CACHE kmp_barrier_team_union {\n  double b_align; /* use worst case alignment */\n  char b_pad[CACHE_LINE];\n  struct {\n    kmp_uint64 b_arrived; /* STATE => task reached synch point. */\n#if USE_DEBUGGER\n    // The following two fields are indended for the debugger solely. Only\n    // primary thread of the team accesses these fields: the first one is\n    // increased by 1 when the primary thread arrives to a barrier, the second\n    // one is increased by one when all the threads arrived.\n    kmp_uint b_master_arrived;\n    kmp_uint b_team_arrived;\n#endif\n  };\n};\n\ntypedef union kmp_barrier_team_union kmp_balign_team_t;\n\n/* Padding for Linux* OS pthreads condition variables and mutexes used to signal\n   threads when a condition changes.  This is to workaround an NPTL bug where\n   padding was added to pthread_cond_t which caused the initialization routine\n   to write outside of the structure if compiled on pre-NPTL threads.  */\n#if KMP_OS_WINDOWS\ntypedef struct kmp_win32_mutex {\n  /* The Lock */\n  CRITICAL_SECTION cs;\n} kmp_win32_mutex_t;\n\ntypedef struct kmp_win32_cond {\n  /* Count of the number of waiters. */\n  int waiters_count_;\n\n  /* Serialize access to <waiters_count_> */\n  kmp_win32_mutex_t waiters_count_lock_;\n\n  /* Number of threads to release via a <cond_broadcast> or a <cond_signal> */\n  int release_count_;\n\n  /* Keeps track of the current \"generation\" so that we don't allow */\n  /* one thread to steal all the \"releases\" from the broadcast. */\n  int wait_generation_count_;\n\n  /* A manual-reset event that's used to block and release waiting threads. */\n  HANDLE event_;\n} kmp_win32_cond_t;\n#endif\n\n#if KMP_OS_UNIX\n\nunion KMP_ALIGN_CACHE kmp_cond_union {\n  double c_align;\n  char c_pad[CACHE_LINE];\n  pthread_cond_t c_cond;\n};\n\ntypedef union kmp_cond_union kmp_cond_align_t;\n\nunion KMP_ALIGN_CACHE kmp_mutex_union {\n  double m_align;\n  char m_pad[CACHE_LINE];\n  pthread_mutex_t m_mutex;\n};\n\ntypedef union kmp_mutex_union kmp_mutex_align_t;\n\n#endif /* KMP_OS_UNIX */\n\ntypedef struct kmp_desc_base {\n  void *ds_stackbase;\n  size_t ds_stacksize;\n  int ds_stackgrow;\n  kmp_thread_t ds_thread;\n  volatile int ds_tid;\n  int ds_gtid;\n#if KMP_OS_WINDOWS\n  volatile int ds_alive;\n  DWORD ds_thread_id;\n/* ds_thread keeps thread handle on Windows* OS. It is enough for RTL purposes.\n   However, debugger support (libomp_db) cannot work with handles, because they\n   uncomparable. For example, debugger requests info about thread with handle h.\n   h is valid within debugger process, and meaningless within debugee process.\n   Even if h is duped by call to DuplicateHandle(), so the result h' is valid\n   within debugee process, but it is a *new* handle which does *not* equal to\n   any other handle in debugee... The only way to compare handles is convert\n   them to system-wide ids. GetThreadId() function is available only in\n   Longhorn and Server 2003. :-( In contrast, GetCurrentThreadId() is available\n   on all Windows* OS flavours (including Windows* 95). Thus, we have to get\n   thread id by call to GetCurrentThreadId() from within the thread and save it\n   to let libomp_db identify threads.  */\n#endif /* KMP_OS_WINDOWS */\n} kmp_desc_base_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_desc {\n  double ds_align; /* use worst case alignment */\n  char ds_pad[KMP_PAD(kmp_desc_base_t, CACHE_LINE)];\n  kmp_desc_base_t ds;\n} kmp_desc_t;\n\ntypedef struct kmp_local {\n  volatile int this_construct; /* count of single's encountered by thread */\n  void *reduce_data;\n#if KMP_USE_BGET\n  void *bget_data;\n  void *bget_list;\n#if !USE_CMP_XCHG_FOR_BGET\n#ifdef USE_QUEUING_LOCK_FOR_BGET\n  kmp_lock_t bget_lock; /* Lock for accessing bget free list */\n#else\n  kmp_bootstrap_lock_t bget_lock; // Lock for accessing bget free list. Must be\n// bootstrap lock so we can use it at library\n// shutdown.\n#endif /* USE_LOCK_FOR_BGET */\n#endif /* ! USE_CMP_XCHG_FOR_BGET */\n#endif /* KMP_USE_BGET */\n\n  PACKED_REDUCTION_METHOD_T\n  packed_reduction_method; /* stored by __kmpc_reduce*(), used by\n                              __kmpc_end_reduce*() */\n\n} kmp_local_t;\n\n#define KMP_CHECK_UPDATE(a, b)                                                 \\\n  if ((a) != (b))                                                              \\\n  (a) = (b)\n#define KMP_CHECK_UPDATE_SYNC(a, b)                                            \\\n  if ((a) != (b))                                                              \\\n  TCW_SYNC_PTR((a), (b))\n\n#define get__blocktime(xteam, xtid)                                            \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.blocktime)\n#define get__bt_set(xteam, xtid)                                               \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.bt_set)\n#if KMP_USE_MONITOR\n#define get__bt_intervals(xteam, xtid)                                         \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.bt_intervals)\n#endif\n\n#define get__dynamic_2(xteam, xtid)                                            \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.dynamic)\n#define get__nproc_2(xteam, xtid)                                              \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.nproc)\n#define get__sched_2(xteam, xtid)                                              \\\n  ((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.sched)\n\n#define set__blocktime_team(xteam, xtid, xval)                                 \\\n  (((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.blocktime) =     \\\n       (xval))\n\n#if KMP_USE_MONITOR\n#define set__bt_intervals_team(xteam, xtid, xval)                              \\\n  (((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.bt_intervals) =  \\\n       (xval))\n#endif\n\n#define set__bt_set_team(xteam, xtid, xval)                                    \\\n  (((xteam)->t.t_threads[(xtid)]->th.th_current_task->td_icvs.bt_set) = (xval))\n\n#define set__dynamic(xthread, xval)                                            \\\n  (((xthread)->th.th_current_task->td_icvs.dynamic) = (xval))\n#define get__dynamic(xthread)                                                  \\\n  (((xthread)->th.th_current_task->td_icvs.dynamic) ? (FTN_TRUE) : (FTN_FALSE))\n\n#define set__nproc(xthread, xval)                                              \\\n  (((xthread)->th.th_current_task->td_icvs.nproc) = (xval))\n\n#define set__thread_limit(xthread, xval)                                       \\\n  (((xthread)->th.th_current_task->td_icvs.thread_limit) = (xval))\n\n#define set__max_active_levels(xthread, xval)                                  \\\n  (((xthread)->th.th_current_task->td_icvs.max_active_levels) = (xval))\n\n#define get__max_active_levels(xthread)                                        \\\n  ((xthread)->th.th_current_task->td_icvs.max_active_levels)\n\n#define set__sched(xthread, xval)                                              \\\n  (((xthread)->th.th_current_task->td_icvs.sched) = (xval))\n\n#define set__proc_bind(xthread, xval)                                          \\\n  (((xthread)->th.th_current_task->td_icvs.proc_bind) = (xval))\n#define get__proc_bind(xthread)                                                \\\n  ((xthread)->th.th_current_task->td_icvs.proc_bind)\n\n// OpenMP tasking data structures\n\ntypedef enum kmp_tasking_mode {\n  tskm_immediate_exec = 0,\n  tskm_extra_barrier = 1,\n  tskm_task_teams = 2,\n  tskm_max = 2\n} kmp_tasking_mode_t;\n\nextern kmp_tasking_mode_t\n    __kmp_tasking_mode; /* determines how/when to execute tasks */\nextern int __kmp_task_stealing_constraint;\nextern int __kmp_enable_task_throttling;\nextern kmp_int32 __kmp_default_device; // Set via OMP_DEFAULT_DEVICE if\n// specified, defaults to 0 otherwise\n// Set via OMP_MAX_TASK_PRIORITY if specified, defaults to 0 otherwise\nextern kmp_int32 __kmp_max_task_priority;\n// Set via KMP_TASKLOOP_MIN_TASKS if specified, defaults to 0 otherwise\nextern kmp_uint64 __kmp_taskloop_min_tasks;\n\n/* NOTE: kmp_taskdata_t and kmp_task_t structures allocated in single block with\n   taskdata first */\n#define KMP_TASK_TO_TASKDATA(task) (((kmp_taskdata_t *)task) - 1)\n#define KMP_TASKDATA_TO_TASK(taskdata) (kmp_task_t *)(taskdata + 1)\n\n// The tt_found_tasks flag is a signal to all threads in the team that tasks\n// were spawned and queued since the previous barrier release.\n#define KMP_TASKING_ENABLED(task_team)                                         \\\n  (TRUE == TCR_SYNC_4((task_team)->tt.tt_found_tasks))\n/*!\n@ingroup BASIC_TYPES\n@{\n*/\n\n/*!\n */\ntypedef kmp_int32 (*kmp_routine_entry_t)(kmp_int32, void *);\n\ntypedef union kmp_cmplrdata {\n  kmp_int32 priority; /**< priority specified by user for the task */\n  kmp_routine_entry_t\n      destructors; /* pointer to function to invoke deconstructors of\n                      firstprivate C++ objects */\n  /* future data */\n} kmp_cmplrdata_t;\n\n/*  sizeof_kmp_task_t passed as arg to kmpc_omp_task call  */\n/*!\n */\ntypedef struct kmp_task { /* GEH: Shouldn't this be aligned somehow? */\n  void *shareds; /**< pointer to block of pointers to shared vars   */\n  kmp_routine_entry_t\n      routine; /**< pointer to routine to call for executing task */\n  kmp_int32 part_id; /**< part id for the task                          */\n  kmp_cmplrdata_t\n      data1; /* Two known optional additions: destructors and priority */\n  kmp_cmplrdata_t data2; /* Process destructors first, priority second */\n  /* future data */\n  /*  private vars  */\n} kmp_task_t;\n\n/*!\n@}\n*/\n\ntypedef struct kmp_taskgroup {\n  std::atomic<kmp_int32> count; // number of allocated and incomplete tasks\n  std::atomic<kmp_int32>\n      cancel_request; // request for cancellation of this taskgroup\n  struct kmp_taskgroup *parent; // parent taskgroup\n  // Block of data to perform task reduction\n  void *reduce_data; // reduction related info\n  kmp_int32 reduce_num_data; // number of data items to reduce\n  uintptr_t *gomp_data; // gomp reduction data\n} kmp_taskgroup_t;\n\n// forward declarations\ntypedef union kmp_depnode kmp_depnode_t;\ntypedef struct kmp_depnode_list kmp_depnode_list_t;\ntypedef struct kmp_dephash_entry kmp_dephash_entry_t;\n\n// Compiler sends us this info:\ntypedef struct kmp_depend_info {\n  kmp_intptr_t base_addr;\n  size_t len;\n  struct {\n    bool in : 1;\n    bool out : 1;\n    bool mtx : 1;\n  } flags;\n} kmp_depend_info_t;\n\n// Internal structures to work with task dependencies:\nstruct kmp_depnode_list {\n  kmp_depnode_t *node;\n  kmp_depnode_list_t *next;\n};\n\n// Max number of mutexinoutset dependencies per node\n#define MAX_MTX_DEPS 4\n\ntypedef struct kmp_base_depnode {\n  kmp_depnode_list_t *successors; /* used under lock */\n  kmp_task_t *task; /* non-NULL if depnode is active, used under lock */\n  kmp_lock_t *mtx_locks[MAX_MTX_DEPS]; /* lock mutexinoutset dependent tasks */\n  kmp_int32 mtx_num_locks; /* number of locks in mtx_locks array */\n  kmp_lock_t lock; /* guards shared fields: task, successors */\n#if KMP_SUPPORT_GRAPH_OUTPUT\n  kmp_uint32 id;\n#endif\n  std::atomic<kmp_int32> npredecessors;\n  std::atomic<kmp_int32> nrefs;\n} kmp_base_depnode_t;\n\nunion KMP_ALIGN_CACHE kmp_depnode {\n  double dn_align; /* use worst case alignment */\n  char dn_pad[KMP_PAD(kmp_base_depnode_t, CACHE_LINE)];\n  kmp_base_depnode_t dn;\n};\n\nstruct kmp_dephash_entry {\n  kmp_intptr_t addr;\n  kmp_depnode_t *last_out;\n  kmp_depnode_list_t *last_ins;\n  kmp_depnode_list_t *last_mtxs;\n  kmp_int32 last_flag;\n  kmp_lock_t *mtx_lock; /* is referenced by depnodes w/mutexinoutset dep */\n  kmp_dephash_entry_t *next_in_bucket;\n};\n\ntypedef struct kmp_dephash {\n  kmp_dephash_entry_t **buckets;\n  size_t size;\n  size_t generation;\n  kmp_uint32 nelements;\n  kmp_uint32 nconflicts;\n} kmp_dephash_t;\n\ntypedef struct kmp_task_affinity_info {\n  kmp_intptr_t base_addr;\n  size_t len;\n  struct {\n    bool flag1 : 1;\n    bool flag2 : 1;\n    kmp_int32 reserved : 30;\n  } flags;\n} kmp_task_affinity_info_t;\n\ntypedef enum kmp_event_type_t {\n  KMP_EVENT_UNINITIALIZED = 0,\n  KMP_EVENT_ALLOW_COMPLETION = 1\n} kmp_event_type_t;\n\ntypedef struct {\n  kmp_event_type_t type;\n  kmp_tas_lock_t lock;\n  union {\n    kmp_task_t *task;\n  } ed;\n} kmp_event_t;\n\n#ifdef BUILD_TIED_TASK_STACK\n\n/* Tied Task stack definitions */\ntypedef struct kmp_stack_block {\n  kmp_taskdata_t *sb_block[TASK_STACK_BLOCK_SIZE];\n  struct kmp_stack_block *sb_next;\n  struct kmp_stack_block *sb_prev;\n} kmp_stack_block_t;\n\ntypedef struct kmp_task_stack {\n  kmp_stack_block_t ts_first_block; // first block of stack entries\n  kmp_taskdata_t **ts_top; // pointer to the top of stack\n  kmp_int32 ts_entries; // number of entries on the stack\n} kmp_task_stack_t;\n\n#endif // BUILD_TIED_TASK_STACK\n\ntypedef struct kmp_tasking_flags { /* Total struct must be exactly 32 bits */\n  /* Compiler flags */ /* Total compiler flags must be 16 bits */\n  unsigned tiedness : 1; /* task is either tied (1) or untied (0) */\n  unsigned final : 1; /* task is final(1) so execute immediately */\n  unsigned merged_if0 : 1; /* no __kmpc_task_{begin/complete}_if0 calls in if0\n                              code path */\n  unsigned destructors_thunk : 1; /* set if the compiler creates a thunk to\n                                     invoke destructors from the runtime */\n  unsigned proxy : 1; /* task is a proxy task (it will be executed outside the\n                         context of the RTL) */\n  unsigned priority_specified : 1; /* set if the compiler provides priority\n                                      setting for the task */\n  unsigned detachable : 1; /* 1 == can detach */\n  unsigned hidden_helper : 1; /* 1 == hidden helper task */\n  unsigned reserved : 8; /* reserved for compiler use */\n\n  /* Library flags */ /* Total library flags must be 16 bits */\n  unsigned tasktype : 1; /* task is either explicit(1) or implicit (0) */\n  unsigned task_serial : 1; // task is executed immediately (1) or deferred (0)\n  unsigned tasking_ser : 1; // all tasks in team are either executed immediately\n  // (1) or may be deferred (0)\n  unsigned team_serial : 1; // entire team is serial (1) [1 thread] or parallel\n  // (0) [>= 2 threads]\n  /* If either team_serial or tasking_ser is set, task team may be NULL */\n  /* Task State Flags: */\n  unsigned started : 1; /* 1==started, 0==not started     */\n  unsigned executing : 1; /* 1==executing, 0==not executing */\n  unsigned complete : 1; /* 1==complete, 0==not complete   */\n  unsigned freed : 1; /* 1==freed, 0==allocated        */\n  unsigned native : 1; /* 1==gcc-compiled task, 0==intel */\n  unsigned reserved31 : 7; /* reserved for library use */\n\n} kmp_tasking_flags_t;\n\nstruct kmp_taskdata { /* aligned during dynamic allocation       */\n  kmp_int32 td_task_id; /* id, assigned by debugger                */\n  kmp_tasking_flags_t td_flags; /* task flags                              */\n  kmp_team_t *td_team; /* team for this task                      */\n  kmp_info_p *td_alloc_thread; /* thread that allocated data structures   */\n  /* Currently not used except for perhaps IDB */\n  kmp_taskdata_t *td_parent; /* parent task                             */\n  kmp_int32 td_level; /* task nesting level                      */\n  std::atomic<kmp_int32> td_untied_count; // untied task active parts counter\n  ident_t *td_ident; /* task identifier                         */\n  // Taskwait data.\n  ident_t *td_taskwait_ident;\n  kmp_uint32 td_taskwait_counter;\n  kmp_int32 td_taskwait_thread; /* gtid + 1 of thread encountered taskwait */\n  KMP_ALIGN_CACHE kmp_internal_control_t\n      td_icvs; /* Internal control variables for the task */\n  KMP_ALIGN_CACHE std::atomic<kmp_int32>\n      td_allocated_child_tasks; /* Child tasks (+ current task) not yet\n                                   deallocated */\n  std::atomic<kmp_int32>\n      td_incomplete_child_tasks; /* Child tasks not yet complete */\n  kmp_taskgroup_t\n      *td_taskgroup; // Each task keeps pointer to its current taskgroup\n  kmp_dephash_t\n      *td_dephash; // Dependencies for children tasks are tracked from here\n  kmp_depnode_t\n      *td_depnode; // Pointer to graph node if this task has dependencies\n  kmp_task_team_t *td_task_team;\n  // The global thread id of the encountering thread. We need it because when a\n  // regular task depends on a hidden helper task, and the hidden helper task\n  // is finished on a hidden helper thread, it will call __kmp_release_deps to\n  // release all dependences. If now the task is a regular task, we need to pass\n  // the encountering gtid such that the task will be picked up and executed by\n  // its encountering team instead of hidden helper team.\n  kmp_int32 encountering_gtid;\n  size_t td_size_alloc; // Size of task structure, including shareds etc.\n#if defined(KMP_GOMP_COMPAT)\n  // 4 or 8 byte integers for the loop bounds in GOMP_taskloop\n  kmp_int32 td_size_loop_bounds;\n#endif\n  kmp_taskdata_t *td_last_tied; // keep tied task for task scheduling constraint\n#if defined(KMP_GOMP_COMPAT)\n  // GOMP sends in a copy function for copy constructors\n  void (*td_copy_func)(void *, void *);\n#endif\n  kmp_event_t td_allow_completion_event;\n#if OMPT_SUPPORT\n  ompt_task_info_t ompt_task_info;\n#endif\n}; // struct kmp_taskdata\n\n// Make sure padding above worked\nKMP_BUILD_ASSERT(sizeof(kmp_taskdata_t) % sizeof(void *) == 0);\n\n// Data for task team but per thread\ntypedef struct kmp_base_thread_data {\n  kmp_info_p *td_thr; // Pointer back to thread info\n  // Used only in __kmp_execute_tasks_template, maybe not avail until task is\n  // queued?\n  kmp_bootstrap_lock_t td_deque_lock; // Lock for accessing deque\n  kmp_taskdata_t *\n      *td_deque; // Deque of tasks encountered by td_thr, dynamically allocated\n  kmp_int32 td_deque_size; // Size of deck\n  kmp_uint32 td_deque_head; // Head of deque (will wrap)\n  kmp_uint32 td_deque_tail; // Tail of deque (will wrap)\n  kmp_int32 td_deque_ntasks; // Number of tasks in deque\n  // GEH: shouldn't this be volatile since used in while-spin?\n  kmp_int32 td_deque_last_stolen; // Thread number of last successful steal\n#ifdef BUILD_TIED_TASK_STACK\n  kmp_task_stack_t td_susp_tied_tasks; // Stack of suspended tied tasks for task\n// scheduling constraint\n#endif // BUILD_TIED_TASK_STACK\n} kmp_base_thread_data_t;\n\n#define TASK_DEQUE_BITS 8 // Used solely to define INITIAL_TASK_DEQUE_SIZE\n#define INITIAL_TASK_DEQUE_SIZE (1 << TASK_DEQUE_BITS)\n\n#define TASK_DEQUE_SIZE(td) ((td).td_deque_size)\n#define TASK_DEQUE_MASK(td) ((td).td_deque_size - 1)\n\ntypedef union KMP_ALIGN_CACHE kmp_thread_data {\n  kmp_base_thread_data_t td;\n  double td_align; /* use worst case alignment */\n  char td_pad[KMP_PAD(kmp_base_thread_data_t, CACHE_LINE)];\n} kmp_thread_data_t;\n\n// Data for task teams which are used when tasking is enabled for the team\ntypedef struct kmp_base_task_team {\n  kmp_bootstrap_lock_t\n      tt_threads_lock; /* Lock used to allocate per-thread part of task team */\n  /* must be bootstrap lock since used at library shutdown*/\n  kmp_task_team_t *tt_next; /* For linking the task team free list */\n  kmp_thread_data_t\n      *tt_threads_data; /* Array of per-thread structures for task team */\n  /* Data survives task team deallocation */\n  kmp_int32 tt_found_tasks; /* Have we found tasks and queued them while\n                               executing this team? */\n  /* TRUE means tt_threads_data is set up and initialized */\n  kmp_int32 tt_nproc; /* #threads in team           */\n  kmp_int32 tt_max_threads; // # entries allocated for threads_data array\n  kmp_int32 tt_found_proxy_tasks; // found proxy tasks since last barrier\n  kmp_int32 tt_untied_task_encountered;\n  // There is hidden helper thread encountered in this task team so that we must\n  // wait when waiting on task team\n  kmp_int32 tt_hidden_helper_task_encountered;\n\n  KMP_ALIGN_CACHE\n  std::atomic<kmp_int32> tt_unfinished_threads; /* #threads still active */\n\n  KMP_ALIGN_CACHE\n  volatile kmp_uint32\n      tt_active; /* is the team still actively executing tasks */\n} kmp_base_task_team_t;\n\nunion KMP_ALIGN_CACHE kmp_task_team {\n  kmp_base_task_team_t tt;\n  double tt_align; /* use worst case alignment */\n  char tt_pad[KMP_PAD(kmp_base_task_team_t, CACHE_LINE)];\n};\n\n#if (USE_FAST_MEMORY == 3) || (USE_FAST_MEMORY == 5)\n// Free lists keep same-size free memory slots for fast memory allocation\n// routines\ntypedef struct kmp_free_list {\n  void *th_free_list_self; // Self-allocated tasks free list\n  void *th_free_list_sync; // Self-allocated tasks stolen/returned by other\n  // threads\n  void *th_free_list_other; // Non-self free list (to be returned to owner's\n  // sync list)\n} kmp_free_list_t;\n#endif\n#if KMP_NESTED_HOT_TEAMS\n// Hot teams array keeps hot teams and their sizes for given thread. Hot teams\n// are not put in teams pool, and they don't put threads in threads pool.\ntypedef struct kmp_hot_team_ptr {\n  kmp_team_p *hot_team; // pointer to hot_team of given nesting level\n  kmp_int32 hot_team_nth; // number of threads allocated for the hot_team\n} kmp_hot_team_ptr_t;\n#endif\ntypedef struct kmp_teams_size {\n  kmp_int32 nteams; // number of teams in a league\n  kmp_int32 nth; // number of threads in each team of the league\n} kmp_teams_size_t;\n\n// This struct stores a thread that acts as a \"root\" for a contention\n// group. Contention groups are rooted at kmp_root threads, but also at\n// each primary thread of each team created in the teams construct.\n// This struct therefore also stores a thread_limit associated with\n// that contention group, and a counter to track the number of threads\n// active in that contention group. Each thread has a list of these: CG\n// root threads have an entry in their list in which cg_root refers to\n// the thread itself, whereas other workers in the CG will have a\n// single entry where cg_root is same as the entry containing their CG\n// root. When a thread encounters a teams construct, it will add a new\n// entry to the front of its list, because it now roots a new CG.\ntypedef struct kmp_cg_root {\n  kmp_info_p *cg_root; // \"root\" thread for a contention group\n  // The CG root's limit comes from OMP_THREAD_LIMIT for root threads, or\n  // thread_limit clause for teams primary threads\n  kmp_int32 cg_thread_limit;\n  kmp_int32 cg_nthreads; // Count of active threads in CG rooted at cg_root\n  struct kmp_cg_root *up; // pointer to higher level CG root in list\n} kmp_cg_root_t;\n\n// OpenMP thread data structures\n\ntypedef struct KMP_ALIGN_CACHE kmp_base_info {\n  /* Start with the readonly data which is cache aligned and padded. This is\n     written before the thread starts working by the primary thread. Uber\n     masters may update themselves later. Usage does not consider serialized\n     regions.  */\n  kmp_desc_t th_info;\n  kmp_team_p *th_team; /* team we belong to */\n  kmp_root_p *th_root; /* pointer to root of task hierarchy */\n  kmp_info_p *th_next_pool; /* next available thread in the pool */\n  kmp_disp_t *th_dispatch; /* thread's dispatch data */\n  int th_in_pool; /* in thread pool (32 bits for TCR/TCW) */\n\n  /* The following are cached from the team info structure */\n  /* TODO use these in more places as determined to be needed via profiling */\n  int th_team_nproc; /* number of threads in a team */\n  kmp_info_p *th_team_master; /* the team's primary thread */\n  int th_team_serialized; /* team is serialized */\n  microtask_t th_teams_microtask; /* save entry address for teams construct */\n  int th_teams_level; /* save initial level of teams construct */\n/* it is 0 on device but may be any on host */\n\n/* The blocktime info is copied from the team struct to the thread struct */\n/* at the start of a barrier, and the values stored in the team are used  */\n/* at points in the code where the team struct is no longer guaranteed    */\n/* to exist (from the POV of worker threads).                             */\n#if KMP_USE_MONITOR\n  int th_team_bt_intervals;\n  int th_team_bt_set;\n#else\n  kmp_uint64 th_team_bt_intervals;\n#endif\n\n#if KMP_AFFINITY_SUPPORTED\n  kmp_affin_mask_t *th_affin_mask; /* thread's current affinity mask */\n#endif\n  omp_allocator_handle_t th_def_allocator; /* default allocator */\n  /* The data set by the primary thread at reinit, then R/W by the worker */\n  KMP_ALIGN_CACHE int\n      th_set_nproc; /* if > 0, then only use this request for the next fork */\n#if KMP_NESTED_HOT_TEAMS\n  kmp_hot_team_ptr_t *th_hot_teams; /* array of hot teams */\n#endif\n  kmp_proc_bind_t\n      th_set_proc_bind; /* if != proc_bind_default, use request for next fork */\n  kmp_teams_size_t\n      th_teams_size; /* number of teams/threads in teams construct */\n#if KMP_AFFINITY_SUPPORTED\n  int th_current_place; /* place currently bound to */\n  int th_new_place; /* place to bind to in par reg */\n  int th_first_place; /* first place in partition */\n  int th_last_place; /* last place in partition */\n#endif\n  int th_prev_level; /* previous level for affinity format */\n  int th_prev_num_threads; /* previous num_threads for affinity format */\n#if USE_ITT_BUILD\n  kmp_uint64 th_bar_arrive_time; /* arrival to barrier timestamp */\n  kmp_uint64 th_bar_min_time; /* minimum arrival time at the barrier */\n  kmp_uint64 th_frame_time; /* frame timestamp */\n#endif /* USE_ITT_BUILD */\n  kmp_local_t th_local;\n  struct private_common *th_pri_head;\n\n  /* Now the data only used by the worker (after initial allocation) */\n  /* TODO the first serial team should actually be stored in the info_t\n     structure.  this will help reduce initial allocation overhead */\n  KMP_ALIGN_CACHE kmp_team_p\n      *th_serial_team; /*serialized team held in reserve*/\n\n#if OMPT_SUPPORT\n  ompt_thread_info_t ompt_thread_info;\n#endif\n\n  /* The following are also read by the primary thread during reinit */\n  struct common_table *th_pri_common;\n\n  volatile kmp_uint32 th_spin_here; /* thread-local location for spinning */\n  /* while awaiting queuing lock acquire */\n\n  volatile void *th_sleep_loc; // this points at a kmp_flag<T>\n\n  ident_t *th_ident;\n  unsigned th_x; // Random number generator data\n  unsigned th_a; // Random number generator data\n\n  /* Tasking-related data for the thread */\n  kmp_task_team_t *th_task_team; // Task team struct\n  kmp_taskdata_t *th_current_task; // Innermost Task being executed\n  kmp_uint8 th_task_state; // alternating 0/1 for task team identification\n  kmp_uint8 *th_task_state_memo_stack; // Stack holding memos of th_task_state\n  // at nested levels\n  kmp_uint32 th_task_state_top; // Top element of th_task_state_memo_stack\n  kmp_uint32 th_task_state_stack_sz; // Size of th_task_state_memo_stack\n  kmp_uint32 th_reap_state; // Non-zero indicates thread is not\n  // tasking, thus safe to reap\n\n  /* More stuff for keeping track of active/sleeping threads (this part is\n     written by the worker thread) */\n  kmp_uint8 th_active_in_pool; // included in count of #active threads in pool\n  int th_active; // ! sleeping; 32 bits for TCR/TCW\n  struct cons_header *th_cons; // used for consistency check\n#if KMP_USE_HIER_SCHED\n  // used for hierarchical scheduling\n  kmp_hier_private_bdata_t *th_hier_bar_data;\n#endif\n\n  /* Add the syncronizing data which is cache aligned and padded. */\n  KMP_ALIGN_CACHE kmp_balign_t th_bar[bs_last_barrier];\n\n  KMP_ALIGN_CACHE volatile kmp_int32\n      th_next_waiting; /* gtid+1 of next thread on lock wait queue, 0 if none */\n\n#if (USE_FAST_MEMORY == 3) || (USE_FAST_MEMORY == 5)\n#define NUM_LISTS 4\n  kmp_free_list_t th_free_lists[NUM_LISTS]; // Free lists for fast memory\n// allocation routines\n#endif\n\n#if KMP_OS_WINDOWS\n  kmp_win32_cond_t th_suspend_cv;\n  kmp_win32_mutex_t th_suspend_mx;\n  std::atomic<int> th_suspend_init;\n#endif\n#if KMP_OS_UNIX\n  kmp_cond_align_t th_suspend_cv;\n  kmp_mutex_align_t th_suspend_mx;\n  std::atomic<int> th_suspend_init_count;\n#endif\n\n#if USE_ITT_BUILD\n  kmp_itt_mark_t th_itt_mark_single;\n// alignment ???\n#endif /* USE_ITT_BUILD */\n#if KMP_STATS_ENABLED\n  kmp_stats_list *th_stats;\n#endif\n#if KMP_OS_UNIX\n  std::atomic<bool> th_blocking;\n#endif\n  kmp_cg_root_t *th_cg_roots; // list of cg_roots associated with this thread\n} kmp_base_info_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_info {\n  double th_align; /* use worst case alignment */\n  char th_pad[KMP_PAD(kmp_base_info_t, CACHE_LINE)];\n  kmp_base_info_t th;\n} kmp_info_t;\n\n// OpenMP thread team data structures\n\ntypedef struct kmp_base_data {\n  volatile kmp_uint32 t_value;\n} kmp_base_data_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_sleep_team {\n  double dt_align; /* use worst case alignment */\n  char dt_pad[KMP_PAD(kmp_base_data_t, CACHE_LINE)];\n  kmp_base_data_t dt;\n} kmp_sleep_team_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_ordered_team {\n  double dt_align; /* use worst case alignment */\n  char dt_pad[KMP_PAD(kmp_base_data_t, CACHE_LINE)];\n  kmp_base_data_t dt;\n} kmp_ordered_team_t;\n\ntypedef int (*launch_t)(int gtid);\n\n/* Minimum number of ARGV entries to malloc if necessary */\n#define KMP_MIN_MALLOC_ARGV_ENTRIES 100\n\n// Set up how many argv pointers will fit in cache lines containing\n// t_inline_argv. Historically, we have supported at least 96 bytes. Using a\n// larger value for more space between the primary write/worker read section and\n// read/write by all section seems to buy more performance on EPCC PARALLEL.\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n#define KMP_INLINE_ARGV_BYTES                                                  \\\n  (4 * CACHE_LINE -                                                            \\\n   ((3 * KMP_PTR_SKIP + 2 * sizeof(int) + 2 * sizeof(kmp_int8) +               \\\n     sizeof(kmp_int16) + sizeof(kmp_uint32)) %                                 \\\n    CACHE_LINE))\n#else\n#define KMP_INLINE_ARGV_BYTES                                                  \\\n  (2 * CACHE_LINE - ((3 * KMP_PTR_SKIP + 2 * sizeof(int)) % CACHE_LINE))\n#endif\n#define KMP_INLINE_ARGV_ENTRIES (int)(KMP_INLINE_ARGV_BYTES / KMP_PTR_SKIP)\n\ntypedef struct KMP_ALIGN_CACHE kmp_base_team {\n  // Synchronization Data\n  // ---------------------------------------------------------------------------\n  KMP_ALIGN_CACHE kmp_ordered_team_t t_ordered;\n  kmp_balign_team_t t_bar[bs_last_barrier];\n  std::atomic<int> t_construct; // count of single directive encountered by team\n  char pad[sizeof(kmp_lock_t)]; // padding to maintain performance on big iron\n\n  // [0] - parallel / [1] - worksharing task reduction data shared by taskgroups\n  std::atomic<void *> t_tg_reduce_data[2]; // to support task modifier\n  std::atomic<int> t_tg_fini_counter[2]; // sync end of task reductions\n\n  // Primary thread only\n  // ---------------------------------------------------------------------------\n  KMP_ALIGN_CACHE int t_master_tid; // tid of primary thread in parent team\n  int t_master_this_cons; // \"this_construct\" single counter of primary thread\n  // in parent team\n  ident_t *t_ident; // if volatile, have to change too much other crud to\n  // volatile too\n  kmp_team_p *t_parent; // parent team\n  kmp_team_p *t_next_pool; // next free team in the team pool\n  kmp_disp_t *t_dispatch; // thread's dispatch data\n  kmp_task_team_t *t_task_team[2]; // Task team struct; switch between 2\n  kmp_proc_bind_t t_proc_bind; // bind type for par region\n#if USE_ITT_BUILD\n  kmp_uint64 t_region_time; // region begin timestamp\n#endif /* USE_ITT_BUILD */\n\n  // Primary thread write, workers read\n  // --------------------------------------------------------------------------\n  KMP_ALIGN_CACHE void **t_argv;\n  int t_argc;\n  int t_nproc; // number of threads in team\n  microtask_t t_pkfn;\n  launch_t t_invoke; // procedure to launch the microtask\n\n#if OMPT_SUPPORT\n  ompt_team_info_t ompt_team_info;\n  ompt_lw_taskteam_t *ompt_serialized_team_info;\n#endif\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n  kmp_int8 t_fp_control_saved;\n  kmp_int8 t_pad2b;\n  kmp_int16 t_x87_fpu_control_word; // FP control regs\n  kmp_uint32 t_mxcsr;\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n\n  void *t_inline_argv[KMP_INLINE_ARGV_ENTRIES];\n\n  KMP_ALIGN_CACHE kmp_info_t **t_threads;\n  kmp_taskdata_t\n      *t_implicit_task_taskdata; // Taskdata for the thread's implicit task\n  int t_level; // nested parallel level\n\n  KMP_ALIGN_CACHE int t_max_argc;\n  int t_max_nproc; // max threads this team can handle (dynamically expandable)\n  int t_serialized; // levels deep of serialized teams\n  dispatch_shared_info_t *t_disp_buffer; // buffers for dispatch system\n  int t_id; // team's id, assigned by debugger.\n  int t_active_level; // nested active parallel level\n  kmp_r_sched_t t_sched; // run-time schedule for the team\n#if KMP_AFFINITY_SUPPORTED\n  int t_first_place; // first & last place in parent thread's partition.\n  int t_last_place; // Restore these values to primary thread after par region.\n#endif // KMP_AFFINITY_SUPPORTED\n  int t_display_affinity;\n  int t_size_changed; // team size was changed?: 0: no, 1: yes, -1: changed via\n  // omp_set_num_threads() call\n  omp_allocator_handle_t t_def_allocator; /* default allocator */\n\n// Read/write by workers as well\n#if (KMP_ARCH_X86 || KMP_ARCH_X86_64)\n  // Using CACHE_LINE=64 reduces memory footprint, but causes a big perf\n  // regression of epcc 'parallel' and 'barrier' on fxe256lin01. This extra\n  // padding serves to fix the performance of epcc 'parallel' and 'barrier' when\n  // CACHE_LINE=64. TODO: investigate more and get rid if this padding.\n  char dummy_padding[1024];\n#endif\n  // Internal control stack for additional nested teams.\n  KMP_ALIGN_CACHE kmp_internal_control_t *t_control_stack_top;\n  // for SERIALIZED teams nested 2 or more levels deep\n  // typed flag to store request state of cancellation\n  std::atomic<kmp_int32> t_cancel_request;\n  int t_master_active; // save on fork, restore on join\n  void *t_copypriv_data; // team specific pointer to copyprivate data array\n#if KMP_OS_WINDOWS\n  std::atomic<kmp_uint32> t_copyin_counter;\n#endif\n#if USE_ITT_BUILD\n  void *t_stack_id; // team specific stack stitching id (for ittnotify)\n#endif /* USE_ITT_BUILD */\n} kmp_base_team_t;\n\nunion KMP_ALIGN_CACHE kmp_team {\n  kmp_base_team_t t;\n  double t_align; /* use worst case alignment */\n  char t_pad[KMP_PAD(kmp_base_team_t, CACHE_LINE)];\n};\n\ntypedef union KMP_ALIGN_CACHE kmp_time_global {\n  double dt_align; /* use worst case alignment */\n  char dt_pad[KMP_PAD(kmp_base_data_t, CACHE_LINE)];\n  kmp_base_data_t dt;\n} kmp_time_global_t;\n\ntypedef struct kmp_base_global {\n  /* cache-aligned */\n  kmp_time_global_t g_time;\n\n  /* non cache-aligned */\n  volatile int g_abort;\n  volatile int g_done;\n\n  int g_dynamic;\n  enum dynamic_mode g_dynamic_mode;\n} kmp_base_global_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_global {\n  kmp_base_global_t g;\n  double g_align; /* use worst case alignment */\n  char g_pad[KMP_PAD(kmp_base_global_t, CACHE_LINE)];\n} kmp_global_t;\n\ntypedef struct kmp_base_root {\n  // TODO: GEH - combine r_active with r_in_parallel then r_active ==\n  // (r_in_parallel>= 0)\n  // TODO: GEH - then replace r_active with t_active_levels if we can to reduce\n  // the synch overhead or keeping r_active\n  volatile int r_active; /* TRUE if some region in a nest has > 1 thread */\n  // keeps a count of active parallel regions per root\n  std::atomic<int> r_in_parallel;\n  // GEH: This is misnamed, should be r_active_levels\n  kmp_team_t *r_root_team;\n  kmp_team_t *r_hot_team;\n  kmp_info_t *r_uber_thread;\n  kmp_lock_t r_begin_lock;\n  volatile int r_begin;\n  int r_blocktime; /* blocktime for this root and descendants */\n} kmp_base_root_t;\n\ntypedef union KMP_ALIGN_CACHE kmp_root {\n  kmp_base_root_t r;\n  double r_align; /* use worst case alignment */\n  char r_pad[KMP_PAD(kmp_base_root_t, CACHE_LINE)];\n} kmp_root_t;\n\nstruct fortran_inx_info {\n  kmp_int32 data;\n};\n\n/* ------------------------------------------------------------------------ */\n\nextern int __kmp_settings;\nextern int __kmp_duplicate_library_ok;\n#if USE_ITT_BUILD\nextern int __kmp_forkjoin_frames;\nextern int __kmp_forkjoin_frames_mode;\n#endif\nextern PACKED_REDUCTION_METHOD_T __kmp_force_reduction_method;\nextern int __kmp_determ_red;\n\n#ifdef KMP_DEBUG\nextern int kmp_a_debug;\nextern int kmp_b_debug;\nextern int kmp_c_debug;\nextern int kmp_d_debug;\nextern int kmp_e_debug;\nextern int kmp_f_debug;\n#endif /* KMP_DEBUG */\n\n/* For debug information logging using rotating buffer */\n#define KMP_DEBUG_BUF_LINES_INIT 512\n#define KMP_DEBUG_BUF_LINES_MIN 1\n\n#define KMP_DEBUG_BUF_CHARS_INIT 128\n#define KMP_DEBUG_BUF_CHARS_MIN 2\n\nextern int\n    __kmp_debug_buf; /* TRUE means use buffer, FALSE means print to stderr */\nextern int __kmp_debug_buf_lines; /* How many lines of debug stored in buffer */\nextern int\n    __kmp_debug_buf_chars; /* How many characters allowed per line in buffer */\nextern int __kmp_debug_buf_atomic; /* TRUE means use atomic update of buffer\n                                      entry pointer */\n\nextern char *__kmp_debug_buffer; /* Debug buffer itself */\nextern std::atomic<int> __kmp_debug_count; /* Counter for number of lines\n                                              printed in buffer so far */\nextern int __kmp_debug_buf_warn_chars; /* Keep track of char increase\n                                          recommended in warnings */\n/* end rotating debug buffer */\n\n#ifdef KMP_DEBUG\nextern int __kmp_par_range; /* +1 => only go par for constructs in range */\n\n#define KMP_PAR_RANGE_ROUTINE_LEN 1024\nextern char __kmp_par_range_routine[KMP_PAR_RANGE_ROUTINE_LEN];\n#define KMP_PAR_RANGE_FILENAME_LEN 1024\nextern char __kmp_par_range_filename[KMP_PAR_RANGE_FILENAME_LEN];\nextern int __kmp_par_range_lb;\nextern int __kmp_par_range_ub;\n#endif\n\n/* For printing out dynamic storage map for threads and teams */\nextern int\n    __kmp_storage_map; /* True means print storage map for threads and teams */\nextern int __kmp_storage_map_verbose; /* True means storage map includes\n                                         placement info */\nextern int __kmp_storage_map_verbose_specified;\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\nextern kmp_cpuinfo_t __kmp_cpuinfo;\n#endif\n\nextern volatile int __kmp_init_serial;\nextern volatile int __kmp_init_gtid;\nextern volatile int __kmp_init_common;\nextern volatile int __kmp_init_middle;\nextern volatile int __kmp_init_parallel;\n#if KMP_USE_MONITOR\nextern volatile int __kmp_init_monitor;\n#endif\nextern volatile int __kmp_init_user_locks;\nextern volatile int __kmp_init_hidden_helper_threads;\nextern int __kmp_init_counter;\nextern int __kmp_root_counter;\nextern int __kmp_version;\n\n/* list of address of allocated caches for commons */\nextern kmp_cached_addr_t *__kmp_threadpriv_cache_list;\n\n/* Barrier algorithm types and options */\nextern kmp_uint32 __kmp_barrier_gather_bb_dflt;\nextern kmp_uint32 __kmp_barrier_release_bb_dflt;\nextern kmp_bar_pat_e __kmp_barrier_gather_pat_dflt;\nextern kmp_bar_pat_e __kmp_barrier_release_pat_dflt;\nextern kmp_uint32 __kmp_barrier_gather_branch_bits[bs_last_barrier];\nextern kmp_uint32 __kmp_barrier_release_branch_bits[bs_last_barrier];\nextern kmp_bar_pat_e __kmp_barrier_gather_pattern[bs_last_barrier];\nextern kmp_bar_pat_e __kmp_barrier_release_pattern[bs_last_barrier];\nextern char const *__kmp_barrier_branch_bit_env_name[bs_last_barrier];\nextern char const *__kmp_barrier_pattern_env_name[bs_last_barrier];\nextern char const *__kmp_barrier_type_name[bs_last_barrier];\nextern char const *__kmp_barrier_pattern_name[bp_last_bar];\n\n/* Global Locks */\nextern kmp_bootstrap_lock_t __kmp_initz_lock; /* control initialization */\nextern kmp_bootstrap_lock_t __kmp_forkjoin_lock; /* control fork/join access */\nextern kmp_bootstrap_lock_t __kmp_task_team_lock;\nextern kmp_bootstrap_lock_t\n    __kmp_exit_lock; /* exit() is not always thread-safe */\n#if KMP_USE_MONITOR\nextern kmp_bootstrap_lock_t\n    __kmp_monitor_lock; /* control monitor thread creation */\n#endif\nextern kmp_bootstrap_lock_t\n    __kmp_tp_cached_lock; /* used for the hack to allow threadprivate cache and\n                             __kmp_threads expansion to co-exist */\n\nextern kmp_lock_t __kmp_global_lock; /* control OS/global access  */\nextern kmp_queuing_lock_t __kmp_dispatch_lock; /* control dispatch access  */\nextern kmp_lock_t __kmp_debug_lock; /* control I/O access for KMP_DEBUG */\n\nextern enum library_type __kmp_library;\n\nextern enum sched_type __kmp_sched; /* default runtime scheduling */\nextern enum sched_type __kmp_static; /* default static scheduling method */\nextern enum sched_type __kmp_guided; /* default guided scheduling method */\nextern enum sched_type __kmp_auto; /* default auto scheduling method */\nextern int __kmp_chunk; /* default runtime chunk size */\nextern int __kmp_force_monotonic; /* whether monotonic scheduling forced */\n\nextern size_t __kmp_stksize; /* stack size per thread         */\n#if KMP_USE_MONITOR\nextern size_t __kmp_monitor_stksize; /* stack size for monitor thread */\n#endif\nextern size_t __kmp_stkoffset; /* stack offset per thread       */\nextern int __kmp_stkpadding; /* Should we pad root thread(s) stack */\n\nextern size_t\n    __kmp_malloc_pool_incr; /* incremental size of pool for kmp_malloc() */\nextern int __kmp_env_stksize; /* was KMP_STACKSIZE specified? */\nextern int __kmp_env_blocktime; /* was KMP_BLOCKTIME specified? */\nextern int __kmp_env_checks; /* was KMP_CHECKS specified?    */\nextern int __kmp_env_consistency_check; // was KMP_CONSISTENCY_CHECK specified?\nextern int __kmp_generate_warnings; /* should we issue warnings? */\nextern int __kmp_reserve_warn; /* have we issued reserve_threads warning? */\n\n#ifdef DEBUG_SUSPEND\nextern int __kmp_suspend_count; /* count inside __kmp_suspend_template() */\n#endif\n\nextern kmp_int32 __kmp_use_yield;\nextern kmp_int32 __kmp_use_yield_exp_set;\nextern kmp_uint32 __kmp_yield_init;\nextern kmp_uint32 __kmp_yield_next;\n\n/* ------------------------------------------------------------------------- */\nextern int __kmp_allThreadsSpecified;\n\nextern size_t __kmp_align_alloc;\n/* following data protected by initialization routines */\nextern int __kmp_xproc; /* number of processors in the system */\nextern int __kmp_avail_proc; /* number of processors available to the process */\nextern size_t __kmp_sys_min_stksize; /* system-defined minimum stack size */\nextern int __kmp_sys_max_nth; /* system-imposed maximum number of threads */\n// maximum total number of concurrently-existing threads on device\nextern int __kmp_max_nth;\n// maximum total number of concurrently-existing threads in a contention group\nextern int __kmp_cg_max_nth;\nextern int __kmp_teams_max_nth; // max threads used in a teams construct\nextern int __kmp_threads_capacity; /* capacity of the arrays __kmp_threads and\n                                      __kmp_root */\nextern int __kmp_dflt_team_nth; /* default number of threads in a parallel\n                                   region a la OMP_NUM_THREADS */\nextern int __kmp_dflt_team_nth_ub; /* upper bound on \"\" determined at serial\n                                      initialization */\nextern int __kmp_tp_capacity; /* capacity of __kmp_threads if threadprivate is\n                                 used (fixed) */\nextern int __kmp_tp_cached; /* whether threadprivate cache has been created\n                               (__kmpc_threadprivate_cached()) */\nextern int __kmp_dflt_blocktime; /* number of milliseconds to wait before\n                                    blocking (env setting) */\n#if KMP_USE_MONITOR\nextern int\n    __kmp_monitor_wakeups; /* number of times monitor wakes up per second */\nextern int __kmp_bt_intervals; /* number of monitor timestamp intervals before\n                                  blocking */\n#endif\n#ifdef KMP_ADJUST_BLOCKTIME\nextern int __kmp_zero_bt; /* whether blocktime has been forced to zero */\n#endif /* KMP_ADJUST_BLOCKTIME */\n#ifdef KMP_DFLT_NTH_CORES\nextern int __kmp_ncores; /* Total number of cores for threads placement */\n#endif\n/* Number of millisecs to delay on abort for Intel(R) VTune(TM) tools */\nextern int __kmp_abort_delay;\n\nextern int __kmp_need_register_atfork_specified;\nextern int __kmp_need_register_atfork; /* At initialization, call pthread_atfork\n                                          to install fork handler */\nextern int __kmp_gtid_mode; /* Method of getting gtid, values:\n                               0 - not set, will be set at runtime\n                               1 - using stack search\n                               2 - dynamic TLS (pthread_getspecific(Linux* OS/OS\n                                   X*) or TlsGetValue(Windows* OS))\n                               3 - static TLS (__declspec(thread) __kmp_gtid),\n                                   Linux* OS .so only.  */\nextern int\n    __kmp_adjust_gtid_mode; /* If true, adjust method based on #threads */\n#ifdef KMP_TDATA_GTID\nextern KMP_THREAD_LOCAL int __kmp_gtid;\n#endif\nextern int __kmp_tls_gtid_min; /* #threads below which use sp search for gtid */\nextern int __kmp_foreign_tp; // If true, separate TP var for each foreign thread\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\nextern int __kmp_inherit_fp_control; // copy fp creg(s) parent->workers at fork\nextern kmp_int16 __kmp_init_x87_fpu_control_word; // init thread's FP ctrl reg\nextern kmp_uint32 __kmp_init_mxcsr; /* init thread's mxscr */\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n\n// max_active_levels for nested parallelism enabled by default via\n// OMP_MAX_ACTIVE_LEVELS, OMP_NESTED, OMP_NUM_THREADS, and OMP_PROC_BIND\nextern int __kmp_dflt_max_active_levels;\n// Indicates whether value of __kmp_dflt_max_active_levels was already\n// explicitly set by OMP_MAX_ACTIVE_LEVELS or OMP_NESTED=false\nextern bool __kmp_dflt_max_active_levels_set;\nextern int __kmp_dispatch_num_buffers; /* max possible dynamic loops in\n                                          concurrent execution per team */\n#if KMP_NESTED_HOT_TEAMS\nextern int __kmp_hot_teams_mode;\nextern int __kmp_hot_teams_max_level;\n#endif\n\n#if KMP_OS_LINUX\nextern enum clock_function_type __kmp_clock_function;\nextern int __kmp_clock_function_param;\n#endif /* KMP_OS_LINUX */\n\n#if KMP_MIC_SUPPORTED\nextern enum mic_type __kmp_mic_type;\n#endif\n\n#ifdef USE_LOAD_BALANCE\nextern double __kmp_load_balance_interval; // load balance algorithm interval\n#endif /* USE_LOAD_BALANCE */\n\n// OpenMP 3.1 - Nested num threads array\ntypedef struct kmp_nested_nthreads_t {\n  int *nth;\n  int size;\n  int used;\n} kmp_nested_nthreads_t;\n\nextern kmp_nested_nthreads_t __kmp_nested_nth;\n\n#if KMP_USE_ADAPTIVE_LOCKS\n\n// Parameters for the speculative lock backoff system.\nstruct kmp_adaptive_backoff_params_t {\n  // Number of soft retries before it counts as a hard retry.\n  kmp_uint32 max_soft_retries;\n  // Badness is a bit mask : 0,1,3,7,15,... on each hard failure we move one to\n  // the right\n  kmp_uint32 max_badness;\n};\n\nextern kmp_adaptive_backoff_params_t __kmp_adaptive_backoff_params;\n\n#if KMP_DEBUG_ADAPTIVE_LOCKS\nextern const char *__kmp_speculative_statsfile;\n#endif\n\n#endif // KMP_USE_ADAPTIVE_LOCKS\n\nextern int __kmp_display_env; /* TRUE or FALSE */\nextern int __kmp_display_env_verbose; /* TRUE if OMP_DISPLAY_ENV=VERBOSE */\nextern int __kmp_omp_cancellation; /* TRUE or FALSE */\nextern int __kmp_nteams;\nextern int __kmp_teams_thread_limit;\n\n/* ------------------------------------------------------------------------- */\n\n/* the following are protected by the fork/join lock */\n/* write: lock  read: anytime */\nextern kmp_info_t **__kmp_threads; /* Descriptors for the threads */\n/* read/write: lock */\nextern volatile kmp_team_t *__kmp_team_pool;\nextern volatile kmp_info_t *__kmp_thread_pool;\nextern kmp_info_t *__kmp_thread_pool_insert_pt;\n\n// total num threads reachable from some root thread including all root threads\nextern volatile int __kmp_nth;\n/* total number of threads reachable from some root thread including all root\n   threads, and those in the thread pool */\nextern volatile int __kmp_all_nth;\nextern std::atomic<int> __kmp_thread_pool_active_nth;\n\nextern kmp_root_t **__kmp_root; /* root of thread hierarchy */\n/* end data protected by fork/join lock */\n/* ------------------------------------------------------------------------- */\n\n#define __kmp_get_gtid() __kmp_get_global_thread_id()\n#define __kmp_entry_gtid() __kmp_get_global_thread_id_reg()\n#define __kmp_get_tid() (__kmp_tid_from_gtid(__kmp_get_gtid()))\n#define __kmp_get_team() (__kmp_threads[(__kmp_get_gtid())]->th.th_team)\n#define __kmp_get_thread() (__kmp_thread_from_gtid(__kmp_get_gtid()))\n\n// AT: Which way is correct?\n// AT: 1. nproc = __kmp_threads[ ( gtid ) ] -> th.th_team -> t.t_nproc;\n// AT: 2. nproc = __kmp_threads[ ( gtid ) ] -> th.th_team_nproc;\n#define __kmp_get_team_num_threads(gtid)                                       \\\n  (__kmp_threads[(gtid)]->th.th_team->t.t_nproc)\n\nstatic inline bool KMP_UBER_GTID(int gtid) {\n  KMP_DEBUG_ASSERT(gtid >= KMP_GTID_MIN);\n  KMP_DEBUG_ASSERT(gtid < __kmp_threads_capacity);\n  return (gtid >= 0 && __kmp_root[gtid] && __kmp_threads[gtid] &&\n          __kmp_threads[gtid] == __kmp_root[gtid]->r.r_uber_thread);\n}\n\nstatic inline int __kmp_tid_from_gtid(int gtid) {\n  KMP_DEBUG_ASSERT(gtid >= 0);\n  return __kmp_threads[gtid]->th.th_info.ds.ds_tid;\n}\n\nstatic inline int __kmp_gtid_from_tid(int tid, const kmp_team_t *team) {\n  KMP_DEBUG_ASSERT(tid >= 0 && team);\n  return team->t.t_threads[tid]->th.th_info.ds.ds_gtid;\n}\n\nstatic inline int __kmp_gtid_from_thread(const kmp_info_t *thr) {\n  KMP_DEBUG_ASSERT(thr);\n  return thr->th.th_info.ds.ds_gtid;\n}\n\nstatic inline kmp_info_t *__kmp_thread_from_gtid(int gtid) {\n  KMP_DEBUG_ASSERT(gtid >= 0);\n  return __kmp_threads[gtid];\n}\n\nstatic inline kmp_team_t *__kmp_team_from_gtid(int gtid) {\n  KMP_DEBUG_ASSERT(gtid >= 0);\n  return __kmp_threads[gtid]->th.th_team;\n}\n\nstatic inline void __kmp_assert_valid_gtid(kmp_int32 gtid) {\n  if (UNLIKELY(gtid < 0 || gtid >= __kmp_threads_capacity))\n    KMP_FATAL(ThreadIdentInvalid);\n}\n\n#if KMP_HAVE_MWAIT || KMP_HAVE_UMWAIT\nextern int __kmp_user_level_mwait; // TRUE or FALSE; from KMP_USER_LEVEL_MWAIT\nextern int __kmp_umwait_enabled; // Runtime check if user-level mwait enabled\nextern int __kmp_mwait_enabled; // Runtime check if ring3 mwait is enabled\nextern int __kmp_mwait_hints; // Hints to pass in to mwait\n#endif\n\n/* ------------------------------------------------------------------------- */\n\nextern kmp_global_t __kmp_global; /* global status */\n\nextern kmp_info_t __kmp_monitor;\n// For Debugging Support Library\nextern std::atomic<kmp_int32> __kmp_team_counter;\n// For Debugging Support Library\nextern std::atomic<kmp_int32> __kmp_task_counter;\n\n#if USE_DEBUGGER\n#define _KMP_GEN_ID(counter)                                                   \\\n  (__kmp_debugging ? KMP_ATOMIC_INC(&counter) + 1 : ~0)\n#else\n#define _KMP_GEN_ID(counter) (~0)\n#endif /* USE_DEBUGGER */\n\n#define KMP_GEN_TASK_ID() _KMP_GEN_ID(__kmp_task_counter)\n#define KMP_GEN_TEAM_ID() _KMP_GEN_ID(__kmp_team_counter)\n\n/* ------------------------------------------------------------------------ */\n\nextern void __kmp_print_storage_map_gtid(int gtid, void *p1, void *p2,\n                                         size_t size, char const *format, ...);\n\nextern void __kmp_serial_initialize(void);\nextern void __kmp_middle_initialize(void);\nextern void __kmp_parallel_initialize(void);\n\nextern void __kmp_internal_begin(void);\nextern void __kmp_internal_end_library(int gtid);\nextern void __kmp_internal_end_thread(int gtid);\nextern void __kmp_internal_end_atexit(void);\nextern void __kmp_internal_end_dtor(void);\nextern void __kmp_internal_end_dest(void *);\n\nextern int __kmp_register_root(int initial_thread);\nextern void __kmp_unregister_root(int gtid);\nextern void __kmp_unregister_library(void); // called by __kmp_internal_end()\n\nextern int __kmp_ignore_mppbeg(void);\nextern int __kmp_ignore_mppend(void);\n\nextern int __kmp_enter_single(int gtid, ident_t *id_ref, int push_ws);\nextern void __kmp_exit_single(int gtid);\n\nextern void __kmp_parallel_deo(int *gtid_ref, int *cid_ref, ident_t *loc_ref);\nextern void __kmp_parallel_dxo(int *gtid_ref, int *cid_ref, ident_t *loc_ref);\n\n#ifdef USE_LOAD_BALANCE\nextern int __kmp_get_load_balance(int);\n#endif\n\nextern int __kmp_get_global_thread_id(void);\nextern int __kmp_get_global_thread_id_reg(void);\nextern void __kmp_exit_thread(int exit_status);\nextern void __kmp_abort(char const *format, ...);\nextern void __kmp_abort_thread(void);\nKMP_NORETURN extern void __kmp_abort_process(void);\nextern void __kmp_warn(char const *format, ...);\n\nextern void __kmp_set_num_threads(int new_nth, int gtid);\n\n// Returns current thread (pointer to kmp_info_t). Current thread *must* be\n// registered.\nstatic inline kmp_info_t *__kmp_entry_thread() {\n  int gtid = __kmp_entry_gtid();\n\n  return __kmp_threads[gtid];\n}\n\nextern void __kmp_set_max_active_levels(int gtid, int new_max_active_levels);\nextern int __kmp_get_max_active_levels(int gtid);\nextern int __kmp_get_ancestor_thread_num(int gtid, int level);\nextern int __kmp_get_team_size(int gtid, int level);\nextern void __kmp_set_schedule(int gtid, kmp_sched_t new_sched, int chunk);\nextern void __kmp_get_schedule(int gtid, kmp_sched_t *sched, int *chunk);\n\nextern unsigned short __kmp_get_random(kmp_info_t *thread);\nextern void __kmp_init_random(kmp_info_t *thread);\n\nextern kmp_r_sched_t __kmp_get_schedule_global(void);\nextern void __kmp_adjust_num_threads(int new_nproc);\nextern void __kmp_check_stksize(size_t *val);\n\nextern void *___kmp_allocate(size_t size KMP_SRC_LOC_DECL);\nextern void *___kmp_page_allocate(size_t size KMP_SRC_LOC_DECL);\nextern void ___kmp_free(void *ptr KMP_SRC_LOC_DECL);\n#define __kmp_allocate(size) ___kmp_allocate((size)KMP_SRC_LOC_CURR)\n#define __kmp_page_allocate(size) ___kmp_page_allocate((size)KMP_SRC_LOC_CURR)\n#define __kmp_free(ptr) ___kmp_free((ptr)KMP_SRC_LOC_CURR)\n\n#if USE_FAST_MEMORY\nextern void *___kmp_fast_allocate(kmp_info_t *this_thr,\n                                  size_t size KMP_SRC_LOC_DECL);\nextern void ___kmp_fast_free(kmp_info_t *this_thr, void *ptr KMP_SRC_LOC_DECL);\nextern void __kmp_free_fast_memory(kmp_info_t *this_thr);\nextern void __kmp_initialize_fast_memory(kmp_info_t *this_thr);\n#define __kmp_fast_allocate(this_thr, size)                                    \\\n  ___kmp_fast_allocate((this_thr), (size)KMP_SRC_LOC_CURR)\n#define __kmp_fast_free(this_thr, ptr)                                         \\\n  ___kmp_fast_free((this_thr), (ptr)KMP_SRC_LOC_CURR)\n#endif\n\nextern void *___kmp_thread_malloc(kmp_info_t *th, size_t size KMP_SRC_LOC_DECL);\nextern void *___kmp_thread_calloc(kmp_info_t *th, size_t nelem,\n                                  size_t elsize KMP_SRC_LOC_DECL);\nextern void *___kmp_thread_realloc(kmp_info_t *th, void *ptr,\n                                   size_t size KMP_SRC_LOC_DECL);\nextern void ___kmp_thread_free(kmp_info_t *th, void *ptr KMP_SRC_LOC_DECL);\n#define __kmp_thread_malloc(th, size)                                          \\\n  ___kmp_thread_malloc((th), (size)KMP_SRC_LOC_CURR)\n#define __kmp_thread_calloc(th, nelem, elsize)                                 \\\n  ___kmp_thread_calloc((th), (nelem), (elsize)KMP_SRC_LOC_CURR)\n#define __kmp_thread_realloc(th, ptr, size)                                    \\\n  ___kmp_thread_realloc((th), (ptr), (size)KMP_SRC_LOC_CURR)\n#define __kmp_thread_free(th, ptr)                                             \\\n  ___kmp_thread_free((th), (ptr)KMP_SRC_LOC_CURR)\n\n#define KMP_INTERNAL_MALLOC(sz) malloc(sz)\n#define KMP_INTERNAL_FREE(p) free(p)\n#define KMP_INTERNAL_REALLOC(p, sz) realloc((p), (sz))\n#define KMP_INTERNAL_CALLOC(n, sz) calloc((n), (sz))\n\nextern void __kmp_push_num_threads(ident_t *loc, int gtid, int num_threads);\n\nextern void __kmp_push_proc_bind(ident_t *loc, int gtid,\n                                 kmp_proc_bind_t proc_bind);\nextern void __kmp_push_num_teams(ident_t *loc, int gtid, int num_teams,\n                                 int num_threads);\nextern void __kmp_push_num_teams_51(ident_t *loc, int gtid, int num_teams_lb,\n                                    int num_teams_ub, int num_threads);\n\nextern void __kmp_yield();\n\nextern void __kmpc_dispatch_init_4(ident_t *loc, kmp_int32 gtid,\n                                   enum sched_type schedule, kmp_int32 lb,\n                                   kmp_int32 ub, kmp_int32 st, kmp_int32 chunk);\nextern void __kmpc_dispatch_init_4u(ident_t *loc, kmp_int32 gtid,\n                                    enum sched_type schedule, kmp_uint32 lb,\n                                    kmp_uint32 ub, kmp_int32 st,\n                                    kmp_int32 chunk);\nextern void __kmpc_dispatch_init_8(ident_t *loc, kmp_int32 gtid,\n                                   enum sched_type schedule, kmp_int64 lb,\n                                   kmp_int64 ub, kmp_int64 st, kmp_int64 chunk);\nextern void __kmpc_dispatch_init_8u(ident_t *loc, kmp_int32 gtid,\n                                    enum sched_type schedule, kmp_uint64 lb,\n                                    kmp_uint64 ub, kmp_int64 st,\n                                    kmp_int64 chunk);\n\nextern int __kmpc_dispatch_next_4(ident_t *loc, kmp_int32 gtid,\n                                  kmp_int32 *p_last, kmp_int32 *p_lb,\n                                  kmp_int32 *p_ub, kmp_int32 *p_st);\nextern int __kmpc_dispatch_next_4u(ident_t *loc, kmp_int32 gtid,\n                                   kmp_int32 *p_last, kmp_uint32 *p_lb,\n                                   kmp_uint32 *p_ub, kmp_int32 *p_st);\nextern int __kmpc_dispatch_next_8(ident_t *loc, kmp_int32 gtid,\n                                  kmp_int32 *p_last, kmp_int64 *p_lb,\n                                  kmp_int64 *p_ub, kmp_int64 *p_st);\nextern int __kmpc_dispatch_next_8u(ident_t *loc, kmp_int32 gtid,\n                                   kmp_int32 *p_last, kmp_uint64 *p_lb,\n                                   kmp_uint64 *p_ub, kmp_int64 *p_st);\n\nextern void __kmpc_dispatch_fini_4(ident_t *loc, kmp_int32 gtid);\nextern void __kmpc_dispatch_fini_8(ident_t *loc, kmp_int32 gtid);\nextern void __kmpc_dispatch_fini_4u(ident_t *loc, kmp_int32 gtid);\nextern void __kmpc_dispatch_fini_8u(ident_t *loc, kmp_int32 gtid);\n\n#ifdef KMP_GOMP_COMPAT\n\nextern void __kmp_aux_dispatch_init_4(ident_t *loc, kmp_int32 gtid,\n                                      enum sched_type schedule, kmp_int32 lb,\n                                      kmp_int32 ub, kmp_int32 st,\n                                      kmp_int32 chunk, int push_ws);\nextern void __kmp_aux_dispatch_init_4u(ident_t *loc, kmp_int32 gtid,\n                                       enum sched_type schedule, kmp_uint32 lb,\n                                       kmp_uint32 ub, kmp_int32 st,\n                                       kmp_int32 chunk, int push_ws);\nextern void __kmp_aux_dispatch_init_8(ident_t *loc, kmp_int32 gtid,\n                                      enum sched_type schedule, kmp_int64 lb,\n                                      kmp_int64 ub, kmp_int64 st,\n                                      kmp_int64 chunk, int push_ws);\nextern void __kmp_aux_dispatch_init_8u(ident_t *loc, kmp_int32 gtid,\n                                       enum sched_type schedule, kmp_uint64 lb,\n                                       kmp_uint64 ub, kmp_int64 st,\n                                       kmp_int64 chunk, int push_ws);\nextern void __kmp_aux_dispatch_fini_chunk_4(ident_t *loc, kmp_int32 gtid);\nextern void __kmp_aux_dispatch_fini_chunk_8(ident_t *loc, kmp_int32 gtid);\nextern void __kmp_aux_dispatch_fini_chunk_4u(ident_t *loc, kmp_int32 gtid);\nextern void __kmp_aux_dispatch_fini_chunk_8u(ident_t *loc, kmp_int32 gtid);\n\n#endif /* KMP_GOMP_COMPAT */\n\nextern kmp_uint32 __kmp_eq_4(kmp_uint32 value, kmp_uint32 checker);\nextern kmp_uint32 __kmp_neq_4(kmp_uint32 value, kmp_uint32 checker);\nextern kmp_uint32 __kmp_lt_4(kmp_uint32 value, kmp_uint32 checker);\nextern kmp_uint32 __kmp_ge_4(kmp_uint32 value, kmp_uint32 checker);\nextern kmp_uint32 __kmp_le_4(kmp_uint32 value, kmp_uint32 checker);\nextern kmp_uint32 __kmp_wait_4(kmp_uint32 volatile *spinner, kmp_uint32 checker,\n                               kmp_uint32 (*pred)(kmp_uint32, kmp_uint32),\n                               void *obj);\nextern void __kmp_wait_4_ptr(void *spinner, kmp_uint32 checker,\n                             kmp_uint32 (*pred)(void *, kmp_uint32), void *obj);\n\nextern void __kmp_wait_64(kmp_info_t *this_thr, kmp_flag_64<> *flag,\n                          int final_spin\n#if USE_ITT_BUILD\n                          ,\n                          void *itt_sync_obj\n#endif\n);\nextern void __kmp_release_64(kmp_flag_64<> *flag);\n\nextern void __kmp_infinite_loop(void);\n\nextern void __kmp_cleanup(void);\n\n#if KMP_HANDLE_SIGNALS\nextern int __kmp_handle_signals;\nextern void __kmp_install_signals(int parallel_init);\nextern void __kmp_remove_signals(void);\n#endif\n\nextern void __kmp_clear_system_time(void);\nextern void __kmp_read_system_time(double *delta);\n\nextern void __kmp_check_stack_overlap(kmp_info_t *thr);\n\nextern void __kmp_expand_host_name(char *buffer, size_t size);\nextern void __kmp_expand_file_name(char *result, size_t rlen, char *pattern);\n\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\nextern void\n__kmp_initialize_system_tick(void); /* Initialize timer tick value */\n#endif\n\nextern void\n__kmp_runtime_initialize(void); /* machine specific initialization */\nextern void __kmp_runtime_destroy(void);\n\n#if KMP_AFFINITY_SUPPORTED\nextern char *__kmp_affinity_print_mask(char *buf, int buf_len,\n                                       kmp_affin_mask_t *mask);\nextern kmp_str_buf_t *__kmp_affinity_str_buf_mask(kmp_str_buf_t *buf,\n                                                  kmp_affin_mask_t *mask);\nextern void __kmp_affinity_initialize(void);\nextern void __kmp_affinity_uninitialize(void);\nextern void __kmp_affinity_set_init_mask(\n    int gtid, int isa_root); /* set affinity according to KMP_AFFINITY */\nextern void __kmp_affinity_set_place(int gtid);\nextern void __kmp_affinity_determine_capable(const char *env_var);\nextern int __kmp_aux_set_affinity(void **mask);\nextern int __kmp_aux_get_affinity(void **mask);\nextern int __kmp_aux_get_affinity_max_proc();\nextern int __kmp_aux_set_affinity_mask_proc(int proc, void **mask);\nextern int __kmp_aux_unset_affinity_mask_proc(int proc, void **mask);\nextern int __kmp_aux_get_affinity_mask_proc(int proc, void **mask);\nextern void __kmp_balanced_affinity(kmp_info_t *th, int team_size);\n#if KMP_OS_LINUX || KMP_OS_FREEBSD\nextern int kmp_set_thread_affinity_mask_initial(void);\n#endif\n#endif /* KMP_AFFINITY_SUPPORTED */\n// No need for KMP_AFFINITY_SUPPORTED guard as only one field in the\n// format string is for affinity, so platforms that do not support\n// affinity can still use the other fields, e.g., %n for num_threads\nextern size_t __kmp_aux_capture_affinity(int gtid, const char *format,\n                                         kmp_str_buf_t *buffer);\nextern void __kmp_aux_display_affinity(int gtid, const char *format);\n\nextern void __kmp_cleanup_hierarchy();\nextern void __kmp_get_hierarchy(kmp_uint32 nproc, kmp_bstate_t *thr_bar);\n\n#if KMP_USE_FUTEX\n\nextern int __kmp_futex_determine_capable(void);\n\n#endif // KMP_USE_FUTEX\n\nextern void __kmp_gtid_set_specific(int gtid);\nextern int __kmp_gtid_get_specific(void);\n\nextern double __kmp_read_cpu_time(void);\n\nextern int __kmp_read_system_info(struct kmp_sys_info *info);\n\n#if KMP_USE_MONITOR\nextern void __kmp_create_monitor(kmp_info_t *th);\n#endif\n\nextern void *__kmp_launch_thread(kmp_info_t *thr);\n\nextern void __kmp_create_worker(int gtid, kmp_info_t *th, size_t stack_size);\n\n#if KMP_OS_WINDOWS\nextern int __kmp_still_running(kmp_info_t *th);\nextern int __kmp_is_thread_alive(kmp_info_t *th, DWORD *exit_val);\nextern void __kmp_free_handle(kmp_thread_t tHandle);\n#endif\n\n#if KMP_USE_MONITOR\nextern void __kmp_reap_monitor(kmp_info_t *th);\n#endif\nextern void __kmp_reap_worker(kmp_info_t *th);\nextern void __kmp_terminate_thread(int gtid);\n\nextern int __kmp_try_suspend_mx(kmp_info_t *th);\nextern void __kmp_lock_suspend_mx(kmp_info_t *th);\nextern void __kmp_unlock_suspend_mx(kmp_info_t *th);\n\nextern void __kmp_elapsed(double *);\nextern void __kmp_elapsed_tick(double *);\n\nextern void __kmp_enable(int old_state);\nextern void __kmp_disable(int *old_state);\n\nextern void __kmp_thread_sleep(int millis);\n\nextern void __kmp_common_initialize(void);\nextern void __kmp_common_destroy(void);\nextern void __kmp_common_destroy_gtid(int gtid);\n\n#if KMP_OS_UNIX\nextern void __kmp_register_atfork(void);\n#endif\nextern void __kmp_suspend_initialize(void);\nextern void __kmp_suspend_initialize_thread(kmp_info_t *th);\nextern void __kmp_suspend_uninitialize_thread(kmp_info_t *th);\n\nextern kmp_info_t *__kmp_allocate_thread(kmp_root_t *root, kmp_team_t *team,\n                                         int tid);\nextern kmp_team_t *\n__kmp_allocate_team(kmp_root_t *root, int new_nproc, int max_nproc,\n#if OMPT_SUPPORT\n                    ompt_data_t ompt_parallel_data,\n#endif\n                    kmp_proc_bind_t proc_bind, kmp_internal_control_t *new_icvs,\n                    int argc USE_NESTED_HOT_ARG(kmp_info_t *thr));\nextern void __kmp_free_thread(kmp_info_t *);\nextern void __kmp_free_team(kmp_root_t *,\n                            kmp_team_t *USE_NESTED_HOT_ARG(kmp_info_t *));\nextern kmp_team_t *__kmp_reap_team(kmp_team_t *);\n\n/* ------------------------------------------------------------------------ */\n\nextern void __kmp_initialize_bget(kmp_info_t *th);\nextern void __kmp_finalize_bget(kmp_info_t *th);\n\nKMP_EXPORT void *kmpc_malloc(size_t size);\nKMP_EXPORT void *kmpc_aligned_malloc(size_t size, size_t alignment);\nKMP_EXPORT void *kmpc_calloc(size_t nelem, size_t elsize);\nKMP_EXPORT void *kmpc_realloc(void *ptr, size_t size);\nKMP_EXPORT void kmpc_free(void *ptr);\n\n/* declarations for internal use */\n\nextern int __kmp_barrier(enum barrier_type bt, int gtid, int is_split,\n                         size_t reduce_size, void *reduce_data,\n                         void (*reduce)(void *, void *));\nextern void __kmp_end_split_barrier(enum barrier_type bt, int gtid);\nextern int __kmp_barrier_gomp_cancel(int gtid);\n\n/*!\n * Tell the fork call which compiler generated the fork call, and therefore how\n * to deal with the call.\n */\nenum fork_context_e {\n  fork_context_gnu, /**< Called from GNU generated code, so must not invoke the\n                       microtask internally. */\n  fork_context_intel, /**< Called from Intel generated code.  */\n  fork_context_last\n};\nextern int __kmp_fork_call(ident_t *loc, int gtid,\n                           enum fork_context_e fork_context, kmp_int32 argc,\n                           microtask_t microtask, launch_t invoker,\n                           kmp_va_list ap);\n\nextern void __kmp_join_call(ident_t *loc, int gtid\n#if OMPT_SUPPORT\n                            ,\n                            enum fork_context_e fork_context\n#endif\n                            ,\n                            int exit_teams = 0);\n\nextern void __kmp_serialized_parallel(ident_t *id, kmp_int32 gtid);\nextern void __kmp_internal_fork(ident_t *id, int gtid, kmp_team_t *team);\nextern void __kmp_internal_join(ident_t *id, int gtid, kmp_team_t *team);\nextern int __kmp_invoke_task_func(int gtid);\nextern void __kmp_run_before_invoked_task(int gtid, int tid,\n                                          kmp_info_t *this_thr,\n                                          kmp_team_t *team);\nextern void __kmp_run_after_invoked_task(int gtid, int tid,\n                                         kmp_info_t *this_thr,\n                                         kmp_team_t *team);\n\n// should never have been exported\nKMP_EXPORT int __kmpc_invoke_task_func(int gtid);\nextern int __kmp_invoke_teams_master(int gtid);\nextern void __kmp_teams_master(int gtid);\nextern int __kmp_aux_get_team_num();\nextern int __kmp_aux_get_num_teams();\nextern void __kmp_save_internal_controls(kmp_info_t *thread);\nextern void __kmp_user_set_library(enum library_type arg);\nextern void __kmp_aux_set_library(enum library_type arg);\nextern void __kmp_aux_set_stacksize(size_t arg);\nextern void __kmp_aux_set_blocktime(int arg, kmp_info_t *thread, int tid);\nextern void __kmp_aux_set_defaults(char const *str, size_t len);\n\n/* Functions called from __kmp_aux_env_initialize() in kmp_settings.cpp */\nvoid kmpc_set_blocktime(int arg);\nvoid ompc_set_nested(int flag);\nvoid ompc_set_dynamic(int flag);\nvoid ompc_set_num_threads(int arg);\n\nextern void __kmp_push_current_task_to_thread(kmp_info_t *this_thr,\n                                              kmp_team_t *team, int tid);\nextern void __kmp_pop_current_task_from_thread(kmp_info_t *this_thr);\nextern kmp_task_t *__kmp_task_alloc(ident_t *loc_ref, kmp_int32 gtid,\n                                    kmp_tasking_flags_t *flags,\n                                    size_t sizeof_kmp_task_t,\n                                    size_t sizeof_shareds,\n                                    kmp_routine_entry_t task_entry);\nextern void __kmp_init_implicit_task(ident_t *loc_ref, kmp_info_t *this_thr,\n                                     kmp_team_t *team, int tid,\n                                     int set_curr_task);\nextern void __kmp_finish_implicit_task(kmp_info_t *this_thr);\nextern void __kmp_free_implicit_task(kmp_info_t *this_thr);\n\nextern kmp_event_t *__kmpc_task_allow_completion_event(ident_t *loc_ref,\n                                                       int gtid,\n                                                       kmp_task_t *task);\nextern void __kmp_fulfill_event(kmp_event_t *event);\n\nextern void __kmp_free_task_team(kmp_info_t *thread,\n                                 kmp_task_team_t *task_team);\nextern void __kmp_reap_task_teams(void);\nextern void __kmp_wait_to_unref_task_teams(void);\nextern void __kmp_task_team_setup(kmp_info_t *this_thr, kmp_team_t *team,\n                                  int always);\nextern void __kmp_task_team_sync(kmp_info_t *this_thr, kmp_team_t *team);\nextern void __kmp_task_team_wait(kmp_info_t *this_thr, kmp_team_t *team\n#if USE_ITT_BUILD\n                                 ,\n                                 void *itt_sync_obj\n#endif /* USE_ITT_BUILD */\n                                 ,\n                                 int wait = 1);\nextern void __kmp_tasking_barrier(kmp_team_t *team, kmp_info_t *thread,\n                                  int gtid);\n\nextern int __kmp_is_address_mapped(void *addr);\nextern kmp_uint64 __kmp_hardware_timestamp(void);\n\n#if KMP_OS_UNIX\nextern int __kmp_read_from_file(char const *path, char const *format, ...);\n#endif\n\n/* ------------------------------------------------------------------------ */\n//\n// Assembly routines that have no compiler intrinsic replacement\n//\n\nextern int __kmp_invoke_microtask(microtask_t pkfn, int gtid, int npr, int argc,\n                                  void *argv[]\n#if OMPT_SUPPORT\n                                  ,\n                                  void **exit_frame_ptr\n#endif\n);\n\n/* ------------------------------------------------------------------------ */\n\nKMP_EXPORT void __kmpc_begin(ident_t *, kmp_int32 flags);\nKMP_EXPORT void __kmpc_end(ident_t *);\n\nKMP_EXPORT void __kmpc_threadprivate_register_vec(ident_t *, void *data,\n                                                  kmpc_ctor_vec ctor,\n                                                  kmpc_cctor_vec cctor,\n                                                  kmpc_dtor_vec dtor,\n                                                  size_t vector_length);\nKMP_EXPORT void __kmpc_threadprivate_register(ident_t *, void *data,\n                                              kmpc_ctor ctor, kmpc_cctor cctor,\n                                              kmpc_dtor dtor);\nKMP_EXPORT void *__kmpc_threadprivate(ident_t *, kmp_int32 global_tid,\n                                      void *data, size_t size);\n\nKMP_EXPORT kmp_int32 __kmpc_global_thread_num(ident_t *);\nKMP_EXPORT kmp_int32 __kmpc_global_num_threads(ident_t *);\nKMP_EXPORT kmp_int32 __kmpc_bound_thread_num(ident_t *);\nKMP_EXPORT kmp_int32 __kmpc_bound_num_threads(ident_t *);\n\nKMP_EXPORT kmp_int32 __kmpc_ok_to_fork(ident_t *);\nKMP_EXPORT void __kmpc_fork_call(ident_t *, kmp_int32 nargs,\n                                 kmpc_micro microtask, ...);\n\nKMP_EXPORT void __kmpc_serialized_parallel(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_end_serialized_parallel(ident_t *, kmp_int32 global_tid);\n\nKMP_EXPORT void __kmpc_flush(ident_t *);\nKMP_EXPORT void __kmpc_barrier(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT kmp_int32 __kmpc_master(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_end_master(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT kmp_int32 __kmpc_masked(ident_t *, kmp_int32 global_tid,\n                                   kmp_int32 filter);\nKMP_EXPORT void __kmpc_end_masked(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_ordered(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_end_ordered(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_critical(ident_t *, kmp_int32 global_tid,\n                                kmp_critical_name *);\nKMP_EXPORT void __kmpc_end_critical(ident_t *, kmp_int32 global_tid,\n                                    kmp_critical_name *);\nKMP_EXPORT void __kmpc_critical_with_hint(ident_t *, kmp_int32 global_tid,\n                                          kmp_critical_name *, uint32_t hint);\n\nKMP_EXPORT kmp_int32 __kmpc_barrier_master(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_end_barrier_master(ident_t *, kmp_int32 global_tid);\n\nKMP_EXPORT kmp_int32 __kmpc_barrier_master_nowait(ident_t *,\n                                                  kmp_int32 global_tid);\n\nKMP_EXPORT kmp_int32 __kmpc_single(ident_t *, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_end_single(ident_t *, kmp_int32 global_tid);\n\nKMP_EXPORT void KMPC_FOR_STATIC_INIT(ident_t *loc, kmp_int32 global_tid,\n                                     kmp_int32 schedtype, kmp_int32 *plastiter,\n                                     kmp_int *plower, kmp_int *pupper,\n                                     kmp_int *pstride, kmp_int incr,\n                                     kmp_int chunk);\n\nKMP_EXPORT void __kmpc_for_static_fini(ident_t *loc, kmp_int32 global_tid);\n\nKMP_EXPORT void __kmpc_copyprivate(ident_t *loc, kmp_int32 global_tid,\n                                   size_t cpy_size, void *cpy_data,\n                                   void (*cpy_func)(void *, void *),\n                                   kmp_int32 didit);\n\nextern void KMPC_SET_NUM_THREADS(int arg);\nextern void KMPC_SET_DYNAMIC(int flag);\nextern void KMPC_SET_NESTED(int flag);\n\n/* OMP 3.0 tasking interface routines */\nKMP_EXPORT kmp_int32 __kmpc_omp_task(ident_t *loc_ref, kmp_int32 gtid,\n                                     kmp_task_t *new_task);\nKMP_EXPORT kmp_task_t *__kmpc_omp_task_alloc(ident_t *loc_ref, kmp_int32 gtid,\n                                             kmp_int32 flags,\n                                             size_t sizeof_kmp_task_t,\n                                             size_t sizeof_shareds,\n                                             kmp_routine_entry_t task_entry);\nKMP_EXPORT kmp_task_t *__kmpc_omp_target_task_alloc(\n    ident_t *loc_ref, kmp_int32 gtid, kmp_int32 flags, size_t sizeof_kmp_task_t,\n    size_t sizeof_shareds, kmp_routine_entry_t task_entry, kmp_int64 device_id);\nKMP_EXPORT void __kmpc_omp_task_begin_if0(ident_t *loc_ref, kmp_int32 gtid,\n                                          kmp_task_t *task);\nKMP_EXPORT void __kmpc_omp_task_complete_if0(ident_t *loc_ref, kmp_int32 gtid,\n                                             kmp_task_t *task);\nKMP_EXPORT kmp_int32 __kmpc_omp_task_parts(ident_t *loc_ref, kmp_int32 gtid,\n                                           kmp_task_t *new_task);\nKMP_EXPORT kmp_int32 __kmpc_omp_taskwait(ident_t *loc_ref, kmp_int32 gtid);\n\nKMP_EXPORT kmp_int32 __kmpc_omp_taskyield(ident_t *loc_ref, kmp_int32 gtid,\n                                          int end_part);\n\n#if TASK_UNUSED\nvoid __kmpc_omp_task_begin(ident_t *loc_ref, kmp_int32 gtid, kmp_task_t *task);\nvoid __kmpc_omp_task_complete(ident_t *loc_ref, kmp_int32 gtid,\n                              kmp_task_t *task);\n#endif // TASK_UNUSED\n\n/* ------------------------------------------------------------------------ */\n\nKMP_EXPORT void __kmpc_taskgroup(ident_t *loc, int gtid);\nKMP_EXPORT void __kmpc_end_taskgroup(ident_t *loc, int gtid);\n\nKMP_EXPORT kmp_int32 __kmpc_omp_task_with_deps(\n    ident_t *loc_ref, kmp_int32 gtid, kmp_task_t *new_task, kmp_int32 ndeps,\n    kmp_depend_info_t *dep_list, kmp_int32 ndeps_noalias,\n    kmp_depend_info_t *noalias_dep_list);\nKMP_EXPORT void __kmpc_omp_wait_deps(ident_t *loc_ref, kmp_int32 gtid,\n                                     kmp_int32 ndeps,\n                                     kmp_depend_info_t *dep_list,\n                                     kmp_int32 ndeps_noalias,\n                                     kmp_depend_info_t *noalias_dep_list);\nextern kmp_int32 __kmp_omp_task(kmp_int32 gtid, kmp_task_t *new_task,\n                                bool serialize_immediate);\n\nKMP_EXPORT kmp_int32 __kmpc_cancel(ident_t *loc_ref, kmp_int32 gtid,\n                                   kmp_int32 cncl_kind);\nKMP_EXPORT kmp_int32 __kmpc_cancellationpoint(ident_t *loc_ref, kmp_int32 gtid,\n                                              kmp_int32 cncl_kind);\nKMP_EXPORT kmp_int32 __kmpc_cancel_barrier(ident_t *loc_ref, kmp_int32 gtid);\nKMP_EXPORT int __kmp_get_cancellation_status(int cancel_kind);\n\nKMP_EXPORT void __kmpc_proxy_task_completed(kmp_int32 gtid, kmp_task_t *ptask);\nKMP_EXPORT void __kmpc_proxy_task_completed_ooo(kmp_task_t *ptask);\nKMP_EXPORT void __kmpc_taskloop(ident_t *loc, kmp_int32 gtid, kmp_task_t *task,\n                                kmp_int32 if_val, kmp_uint64 *lb,\n                                kmp_uint64 *ub, kmp_int64 st, kmp_int32 nogroup,\n                                kmp_int32 sched, kmp_uint64 grainsize,\n                                void *task_dup);\nKMP_EXPORT void __kmpc_taskloop_5(ident_t *loc, kmp_int32 gtid,\n                                  kmp_task_t *task, kmp_int32 if_val,\n                                  kmp_uint64 *lb, kmp_uint64 *ub, kmp_int64 st,\n                                  kmp_int32 nogroup, kmp_int32 sched,\n                                  kmp_uint64 grainsize, kmp_int32 modifier,\n                                  void *task_dup);\nKMP_EXPORT void *__kmpc_task_reduction_init(int gtid, int num_data, void *data);\nKMP_EXPORT void *__kmpc_taskred_init(int gtid, int num_data, void *data);\nKMP_EXPORT void *__kmpc_task_reduction_get_th_data(int gtid, void *tg, void *d);\nKMP_EXPORT void *__kmpc_task_reduction_modifier_init(ident_t *loc, int gtid,\n                                                     int is_ws, int num,\n                                                     void *data);\nKMP_EXPORT void *__kmpc_taskred_modifier_init(ident_t *loc, int gtid, int is_ws,\n                                              int num, void *data);\nKMP_EXPORT void __kmpc_task_reduction_modifier_fini(ident_t *loc, int gtid,\n                                                    int is_ws);\nKMP_EXPORT kmp_int32 __kmpc_omp_reg_task_with_affinity(\n    ident_t *loc_ref, kmp_int32 gtid, kmp_task_t *new_task, kmp_int32 naffins,\n    kmp_task_affinity_info_t *affin_list);\nKMP_EXPORT void __kmp_set_num_teams(int num_teams);\nKMP_EXPORT int __kmp_get_max_teams(void);\nKMP_EXPORT void __kmp_set_teams_thread_limit(int limit);\nKMP_EXPORT int __kmp_get_teams_thread_limit(void);\n\n/* Lock interface routines (fast versions with gtid passed in) */\nKMP_EXPORT void __kmpc_init_lock(ident_t *loc, kmp_int32 gtid,\n                                 void **user_lock);\nKMP_EXPORT void __kmpc_init_nest_lock(ident_t *loc, kmp_int32 gtid,\n                                      void **user_lock);\nKMP_EXPORT void __kmpc_destroy_lock(ident_t *loc, kmp_int32 gtid,\n                                    void **user_lock);\nKMP_EXPORT void __kmpc_destroy_nest_lock(ident_t *loc, kmp_int32 gtid,\n                                         void **user_lock);\nKMP_EXPORT void __kmpc_set_lock(ident_t *loc, kmp_int32 gtid, void **user_lock);\nKMP_EXPORT void __kmpc_set_nest_lock(ident_t *loc, kmp_int32 gtid,\n                                     void **user_lock);\nKMP_EXPORT void __kmpc_unset_lock(ident_t *loc, kmp_int32 gtid,\n                                  void **user_lock);\nKMP_EXPORT void __kmpc_unset_nest_lock(ident_t *loc, kmp_int32 gtid,\n                                       void **user_lock);\nKMP_EXPORT int __kmpc_test_lock(ident_t *loc, kmp_int32 gtid, void **user_lock);\nKMP_EXPORT int __kmpc_test_nest_lock(ident_t *loc, kmp_int32 gtid,\n                                     void **user_lock);\n\nKMP_EXPORT void __kmpc_init_lock_with_hint(ident_t *loc, kmp_int32 gtid,\n                                           void **user_lock, uintptr_t hint);\nKMP_EXPORT void __kmpc_init_nest_lock_with_hint(ident_t *loc, kmp_int32 gtid,\n                                                void **user_lock,\n                                                uintptr_t hint);\n\n/* Interface to fast scalable reduce methods routines */\n\nKMP_EXPORT kmp_int32 __kmpc_reduce_nowait(\n    ident_t *loc, kmp_int32 global_tid, kmp_int32 num_vars, size_t reduce_size,\n    void *reduce_data, void (*reduce_func)(void *lhs_data, void *rhs_data),\n    kmp_critical_name *lck);\nKMP_EXPORT void __kmpc_end_reduce_nowait(ident_t *loc, kmp_int32 global_tid,\n                                         kmp_critical_name *lck);\nKMP_EXPORT kmp_int32 __kmpc_reduce(\n    ident_t *loc, kmp_int32 global_tid, kmp_int32 num_vars, size_t reduce_size,\n    void *reduce_data, void (*reduce_func)(void *lhs_data, void *rhs_data),\n    kmp_critical_name *lck);\nKMP_EXPORT void __kmpc_end_reduce(ident_t *loc, kmp_int32 global_tid,\n                                  kmp_critical_name *lck);\n\n/* Internal fast reduction routines */\n\nextern PACKED_REDUCTION_METHOD_T __kmp_determine_reduction_method(\n    ident_t *loc, kmp_int32 global_tid, kmp_int32 num_vars, size_t reduce_size,\n    void *reduce_data, void (*reduce_func)(void *lhs_data, void *rhs_data),\n    kmp_critical_name *lck);\n\n// this function is for testing set/get/determine reduce method\nKMP_EXPORT kmp_int32 __kmp_get_reduce_method(void);\n\nKMP_EXPORT kmp_uint64 __kmpc_get_taskid();\nKMP_EXPORT kmp_uint64 __kmpc_get_parent_taskid();\n\n// C++ port\n// missing 'extern \"C\"' declarations\n\nKMP_EXPORT kmp_int32 __kmpc_in_parallel(ident_t *loc);\nKMP_EXPORT void __kmpc_pop_num_threads(ident_t *loc, kmp_int32 global_tid);\nKMP_EXPORT void __kmpc_push_num_threads(ident_t *loc, kmp_int32 global_tid,\n                                        kmp_int32 num_threads);\n\nKMP_EXPORT void __kmpc_push_proc_bind(ident_t *loc, kmp_int32 global_tid,\n                                      int proc_bind);\nKMP_EXPORT void __kmpc_push_num_teams(ident_t *loc, kmp_int32 global_tid,\n                                      kmp_int32 num_teams,\n                                      kmp_int32 num_threads);\n/* Function for OpenMP 5.1 num_teams clause */\nKMP_EXPORT void __kmpc_push_num_teams_51(ident_t *loc, kmp_int32 global_tid,\n                                         kmp_int32 num_teams_lb,\n                                         kmp_int32 num_teams_ub,\n                                         kmp_int32 num_threads);\nKMP_EXPORT void __kmpc_fork_teams(ident_t *loc, kmp_int32 argc,\n                                  kmpc_micro microtask, ...);\nstruct kmp_dim { // loop bounds info casted to kmp_int64\n  kmp_int64 lo; // lower\n  kmp_int64 up; // upper\n  kmp_int64 st; // stride\n};\nKMP_EXPORT void __kmpc_doacross_init(ident_t *loc, kmp_int32 gtid,\n                                     kmp_int32 num_dims,\n                                     const struct kmp_dim *dims);\nKMP_EXPORT void __kmpc_doacross_wait(ident_t *loc, kmp_int32 gtid,\n                                     const kmp_int64 *vec);\nKMP_EXPORT void __kmpc_doacross_post(ident_t *loc, kmp_int32 gtid,\n                                     const kmp_int64 *vec);\nKMP_EXPORT void __kmpc_doacross_fini(ident_t *loc, kmp_int32 gtid);\n\nKMP_EXPORT void *__kmpc_threadprivate_cached(ident_t *loc, kmp_int32 global_tid,\n                                             void *data, size_t size,\n                                             void ***cache);\n\n// Symbols for MS mutual detection.\nextern int _You_must_link_with_exactly_one_OpenMP_library;\nextern int _You_must_link_with_Intel_OpenMP_library;\n#if KMP_OS_WINDOWS && (KMP_VERSION_MAJOR > 4)\nextern int _You_must_link_with_Microsoft_OpenMP_library;\n#endif\n\n// The routines below are not exported.\n// Consider making them 'static' in corresponding source files.\nvoid kmp_threadprivate_insert_private_data(int gtid, void *pc_addr,\n                                           void *data_addr, size_t pc_size);\nstruct private_common *kmp_threadprivate_insert(int gtid, void *pc_addr,\n                                                void *data_addr,\n                                                size_t pc_size);\nvoid __kmp_threadprivate_resize_cache(int newCapacity);\nvoid __kmp_cleanup_threadprivate_caches();\n\n// ompc_, kmpc_ entries moved from omp.h.\n#if KMP_OS_WINDOWS\n#define KMPC_CONVENTION __cdecl\n#else\n#define KMPC_CONVENTION\n#endif\n\n#ifndef __OMP_H\ntypedef enum omp_sched_t {\n  omp_sched_static = 1,\n  omp_sched_dynamic = 2,\n  omp_sched_guided = 3,\n  omp_sched_auto = 4\n} omp_sched_t;\ntypedef void *kmp_affinity_mask_t;\n#endif\n\nKMP_EXPORT void KMPC_CONVENTION ompc_set_max_active_levels(int);\nKMP_EXPORT void KMPC_CONVENTION ompc_set_schedule(omp_sched_t, int);\nKMP_EXPORT int KMPC_CONVENTION ompc_get_ancestor_thread_num(int);\nKMP_EXPORT int KMPC_CONVENTION ompc_get_team_size(int);\nKMP_EXPORT int KMPC_CONVENTION\nkmpc_set_affinity_mask_proc(int, kmp_affinity_mask_t *);\nKMP_EXPORT int KMPC_CONVENTION\nkmpc_unset_affinity_mask_proc(int, kmp_affinity_mask_t *);\nKMP_EXPORT int KMPC_CONVENTION\nkmpc_get_affinity_mask_proc(int, kmp_affinity_mask_t *);\n\nKMP_EXPORT void KMPC_CONVENTION kmpc_set_stacksize(int);\nKMP_EXPORT void KMPC_CONVENTION kmpc_set_stacksize_s(size_t);\nKMP_EXPORT void KMPC_CONVENTION kmpc_set_library(int);\nKMP_EXPORT void KMPC_CONVENTION kmpc_set_defaults(char const *);\nKMP_EXPORT void KMPC_CONVENTION kmpc_set_disp_num_buffers(int);\n\nenum kmp_target_offload_kind {\n  tgt_disabled = 0,\n  tgt_default = 1,\n  tgt_mandatory = 2\n};\ntypedef enum kmp_target_offload_kind kmp_target_offload_kind_t;\n// Set via OMP_TARGET_OFFLOAD if specified, defaults to tgt_default otherwise\nextern kmp_target_offload_kind_t __kmp_target_offload;\nextern int __kmpc_get_target_offload();\n\n// Constants used in libomptarget\n#define KMP_DEVICE_DEFAULT -1 // This is libomptarget's default device.\n#define KMP_DEVICE_ALL -11 // This is libomptarget's \"all devices\".\n\n// OMP Pause Resource\n\n// The following enum is used both to set the status in __kmp_pause_status, and\n// as the internal equivalent of the externally-visible omp_pause_resource_t.\ntypedef enum kmp_pause_status_t {\n  kmp_not_paused = 0, // status is not paused, or, requesting resume\n  kmp_soft_paused = 1, // status is soft-paused, or, requesting soft pause\n  kmp_hard_paused = 2 // status is hard-paused, or, requesting hard pause\n} kmp_pause_status_t;\n\n// This stores the pause state of the runtime\nextern kmp_pause_status_t __kmp_pause_status;\nextern int __kmpc_pause_resource(kmp_pause_status_t level);\nextern int __kmp_pause_resource(kmp_pause_status_t level);\n// Soft resume sets __kmp_pause_status, and wakes up all threads.\nextern void __kmp_resume_if_soft_paused();\n// Hard resume simply resets the status to not paused. Library will appear to\n// be uninitialized after hard pause. Let OMP constructs trigger required\n// initializations.\nstatic inline void __kmp_resume_if_hard_paused() {\n  if (__kmp_pause_status == kmp_hard_paused) {\n    __kmp_pause_status = kmp_not_paused;\n  }\n}\n\nextern void __kmp_omp_display_env(int verbose);\n\n// 1: it is initializing hidden helper team\nextern volatile int __kmp_init_hidden_helper;\n// 1: the hidden helper team is done\nextern volatile int __kmp_hidden_helper_team_done;\n// 1: enable hidden helper task\nextern kmp_int32 __kmp_enable_hidden_helper;\n// Main thread of hidden helper team\nextern kmp_info_t *__kmp_hidden_helper_main_thread;\n// Descriptors for the hidden helper threads\nextern kmp_info_t **__kmp_hidden_helper_threads;\n// Number of hidden helper threads\nextern kmp_int32 __kmp_hidden_helper_threads_num;\n// Number of hidden helper tasks that have not been executed yet\nextern std::atomic<kmp_int32> __kmp_unexecuted_hidden_helper_tasks;\n\nextern void __kmp_hidden_helper_initialize();\nextern void __kmp_hidden_helper_threads_initz_routine();\nextern void __kmp_do_initialize_hidden_helper_threads();\nextern void __kmp_hidden_helper_threads_initz_wait();\nextern void __kmp_hidden_helper_initz_release();\nextern void __kmp_hidden_helper_threads_deinitz_wait();\nextern void __kmp_hidden_helper_threads_deinitz_release();\nextern void __kmp_hidden_helper_main_thread_wait();\nextern void __kmp_hidden_helper_worker_thread_wait();\nextern void __kmp_hidden_helper_worker_thread_signal();\nextern void __kmp_hidden_helper_main_thread_release();\n\n// Check whether a given thread is a hidden helper thread\n#define KMP_HIDDEN_HELPER_THREAD(gtid)                                         \\\n  ((gtid) >= 1 && (gtid) <= __kmp_hidden_helper_threads_num)\n\n#define KMP_HIDDEN_HELPER_WORKER_THREAD(gtid)                                  \\\n  ((gtid) > 1 && (gtid) <= __kmp_hidden_helper_threads_num)\n\n// Map a gtid to a hidden helper thread. The first hidden helper thread, a.k.a\n// main thread, is skipped.\n#define KMP_GTID_TO_SHADOW_GTID(gtid)                                          \\\n  ((gtid) % (__kmp_hidden_helper_threads_num - 1) + 2)\n\n// Support for error directive\ntypedef enum kmp_severity_t {\n  severity_warning = 1,\n  severity_fatal = 2\n} kmp_severity_t;\nextern void __kmpc_error(ident_t *loc, int severity, const char *message);\n\n#ifdef __cplusplus\n}\n#endif\n\ntemplate <bool C, bool S>\nextern void __kmp_suspend_32(int th_gtid, kmp_flag_32<C, S> *flag);\ntemplate <bool C, bool S>\nextern void __kmp_suspend_64(int th_gtid, kmp_flag_64<C, S> *flag);\nextern void __kmp_suspend_oncore(int th_gtid, kmp_flag_oncore *flag);\n#if KMP_HAVE_MWAIT || KMP_HAVE_UMWAIT\ntemplate <bool C, bool S>\nextern void __kmp_mwait_32(int th_gtid, kmp_flag_32<C, S> *flag);\ntemplate <bool C, bool S>\nextern void __kmp_mwait_64(int th_gtid, kmp_flag_64<C, S> *flag);\nextern void __kmp_mwait_oncore(int th_gtid, kmp_flag_oncore *flag);\n#endif\ntemplate <bool C, bool S>\nextern void __kmp_resume_32(int target_gtid, kmp_flag_32<C, S> *flag);\ntemplate <bool C, bool S>\nextern void __kmp_resume_64(int target_gtid, kmp_flag_64<C, S> *flag);\nextern void __kmp_resume_oncore(int target_gtid, kmp_flag_oncore *flag);\n\ntemplate <bool C, bool S>\nint __kmp_execute_tasks_32(kmp_info_t *thread, kmp_int32 gtid,\n                           kmp_flag_32<C, S> *flag, int final_spin,\n                           int *thread_finished,\n#if USE_ITT_BUILD\n                           void *itt_sync_obj,\n#endif /* USE_ITT_BUILD */\n                           kmp_int32 is_constrained);\ntemplate <bool C, bool S>\nint __kmp_execute_tasks_64(kmp_info_t *thread, kmp_int32 gtid,\n                           kmp_flag_64<C, S> *flag, int final_spin,\n                           int *thread_finished,\n#if USE_ITT_BUILD\n                           void *itt_sync_obj,\n#endif /* USE_ITT_BUILD */\n                           kmp_int32 is_constrained);\nint __kmp_execute_tasks_oncore(kmp_info_t *thread, kmp_int32 gtid,\n                               kmp_flag_oncore *flag, int final_spin,\n                               int *thread_finished,\n#if USE_ITT_BUILD\n                               void *itt_sync_obj,\n#endif /* USE_ITT_BUILD */\n                               kmp_int32 is_constrained);\n\n/// This class safely opens and closes a C-style FILE* object using RAII\n/// semantics. There are also methods which allow using stdout or stderr as\n/// the underlying FILE* object. With the implicit conversion operator to\n/// FILE*, an object with this type can be used in any function which takes\n/// a FILE* object e.g., fprintf().\n/// No close method is needed at use sites.\nclass kmp_safe_raii_file_t {\n  FILE *f;\n\n  void close() {\n    if (f && f != stdout && f != stderr) {\n      fclose(f);\n      f = nullptr;\n    }\n  }\n\npublic:\n  kmp_safe_raii_file_t() : f(nullptr) {}\n  kmp_safe_raii_file_t(const char *filename, const char *mode,\n                       const char *env_var = nullptr)\n      : f(nullptr) {\n    open(filename, mode, env_var);\n  }\n  ~kmp_safe_raii_file_t() { close(); }\n\n  /// Open filename using mode. This is automatically closed in the destructor.\n  /// The env_var parameter indicates the environment variable the filename\n  /// came from if != nullptr.\n  void open(const char *filename, const char *mode,\n            const char *env_var = nullptr) {\n    KMP_ASSERT(!f);\n    f = fopen(filename, mode);\n    if (!f) {\n      int code = errno;\n      if (env_var) {\n        __kmp_fatal(KMP_MSG(CantOpenFileForReading, filename), KMP_ERR(code),\n                    KMP_HNT(CheckEnvVar, env_var, filename), __kmp_msg_null);\n      } else {\n        __kmp_fatal(KMP_MSG(CantOpenFileForReading, filename), KMP_ERR(code),\n                    __kmp_msg_null);\n      }\n    }\n  }\n  /// Set the FILE* object to stdout and output there\n  /// No open call should happen before this call.\n  void set_stdout() {\n    KMP_ASSERT(!f);\n    f = stdout;\n  }\n  /// Set the FILE* object to stderr and output there\n  /// No open call should happen before this call.\n  void set_stderr() {\n    KMP_ASSERT(!f);\n    f = stderr;\n  }\n  operator bool() { return bool(f); }\n  operator FILE *() { return f; }\n};\n\ntemplate <typename SourceType, typename TargetType,\n          bool isSourceSmaller = (sizeof(SourceType) < sizeof(TargetType)),\n          bool isSourceEqual = (sizeof(SourceType) == sizeof(TargetType)),\n          bool isSourceSigned = std::is_signed<SourceType>::value,\n          bool isTargetSigned = std::is_signed<TargetType>::value>\nstruct kmp_convert {};\n\n// Both types are signed; Source smaller\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, true, false, true, true> {\n  static TargetType to(SourceType src) { return (TargetType)src; }\n};\n// Source equal\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, true, true, true> {\n  static TargetType to(SourceType src) { return src; }\n};\n// Source bigger\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, false, true, true> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src <= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::max)()));\n    KMP_ASSERT(src >= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::min)()));\n    return (TargetType)src;\n  }\n};\n\n// Source signed, Target unsigned\n// Source smaller\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, true, false, true, false> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src >= 0);\n    return (TargetType)src;\n  }\n};\n// Source equal\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, true, true, false> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src >= 0);\n    return (TargetType)src;\n  }\n};\n// Source bigger\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, false, true, false> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src >= 0);\n    KMP_ASSERT(src <= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::max)()));\n    return (TargetType)src;\n  }\n};\n\n// Source unsigned, Target signed\n// Source smaller\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, true, false, false, true> {\n  static TargetType to(SourceType src) { return (TargetType)src; }\n};\n// Source equal\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, true, false, true> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src <= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::max)()));\n    return (TargetType)src;\n  }\n};\n// Source bigger\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, false, false, true> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src <= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::max)()));\n    return (TargetType)src;\n  }\n};\n\n// Source unsigned, Target unsigned\n// Source smaller\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, true, false, false, false> {\n  static TargetType to(SourceType src) { return (TargetType)src; }\n};\n// Source equal\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, true, false, false> {\n  static TargetType to(SourceType src) { return src; }\n};\n// Source bigger\ntemplate <typename SourceType, typename TargetType>\nstruct kmp_convert<SourceType, TargetType, false, false, false, false> {\n  static TargetType to(SourceType src) {\n    KMP_ASSERT(src <= static_cast<SourceType>(\n                          (std::numeric_limits<TargetType>::max)()));\n    return (TargetType)src;\n  }\n};\n\ntemplate <typename T1, typename T2>\nstatic inline void __kmp_type_convert(T1 src, T2 *dest) {\n  *dest = kmp_convert<T1, T2>::to(src);\n}\n\n#endif /* KMP_H */\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_debug.h", "content": "/*\n * kmp_debug.h -- debug / assertion code for Assure library\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_DEBUG_H\n#define KMP_DEBUG_H\n\n#include <stdarg.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n// -----------------------------------------------------------------------------\n// Build-time assertion.\n\n// New C++11 style build assert\n#define KMP_BUILD_ASSERT(expr) static_assert(expr, \"Build condition error\")\n\n// -----------------------------------------------------------------------------\n// Run-time assertions.\n\nextern void __kmp_dump_debug_buffer(void);\n\n#ifdef KMP_USE_ASSERT\nextern int __kmp_debug_assert(char const *expr, char const *file, int line);\n#ifdef KMP_DEBUG\n#define KMP_ASSERT(cond)                                                       \\\n  if (!(cond)) {                                                               \\\n    __kmp_debug_assert(#cond, __FILE__, __LINE__);                             \\\n  }\n#define KMP_ASSERT2(cond, msg)                                                 \\\n  if (!(cond)) {                                                               \\\n    __kmp_debug_assert((msg), __FILE__, __LINE__);                             \\\n  }\n#define KMP_DEBUG_ASSERT(cond) KMP_ASSERT(cond)\n#define KMP_DEBUG_ASSERT2(cond, msg) KMP_ASSERT2(cond, msg)\n#define KMP_DEBUG_USE_VAR(x) /* Nothing (it is used!) */\n#else\n// Do not expose condition in release build. Use \"assertion failure\".\n#define KMP_ASSERT(cond)                                                       \\\n  if (!(cond)) {                                                               \\\n    __kmp_debug_assert(\"assertion failure\", __FILE__, __LINE__);               \\\n  }\n#define KMP_ASSERT2(cond, msg) KMP_ASSERT(cond)\n#define KMP_DEBUG_ASSERT(cond) /* Nothing */\n#define KMP_DEBUG_ASSERT2(cond, msg) /* Nothing */\n#define KMP_DEBUG_USE_VAR(x) ((void)(x))\n#endif // KMP_DEBUG\n#else\n#define KMP_ASSERT(cond) /* Nothing */\n#define KMP_ASSERT2(cond, msg) /* Nothing */\n#define KMP_DEBUG_ASSERT(cond) /* Nothing */\n#define KMP_DEBUG_ASSERT2(cond, msg) /* Nothing */\n#define KMP_DEBUG_USE_VAR(x) ((void)(x))\n#endif // KMP_USE_ASSERT\n\n#ifdef KMP_DEBUG\nextern void __kmp_debug_printf_stdout(char const *format, ...);\n#endif\nextern void __kmp_debug_printf(char const *format, ...);\n\n#ifdef KMP_DEBUG\n\nextern int kmp_a_debug;\nextern int kmp_b_debug;\nextern int kmp_c_debug;\nextern int kmp_d_debug;\nextern int kmp_e_debug;\nextern int kmp_f_debug;\nextern int kmp_diag;\n\n#define KA_TRACE(d, x)                                                         \\\n  if (kmp_a_debug >= d) {                                                      \\\n    __kmp_debug_printf x;                                                      \\\n  }\n#define KB_TRACE(d, x)                                                         \\\n  if (kmp_b_debug >= d) {                                                      \\\n    __kmp_debug_printf x;                                                      \\\n  }\n#define KC_TRACE(d, x)                                                         \\\n  if (kmp_c_debug >= d) {                                                      \\\n    __kmp_debug_printf x;                                                      \\\n  }\n#define KD_TRACE(d, x)                                                         \\\n  if (kmp_d_debug >= d) {                                                      \\\n    __kmp_debug_printf x;                                                      \\\n  }\n#define KE_TRACE(d, x)                                                         \\\n  if (kmp_e_debug >= d) {                                                      \\\n    __kmp_debug_printf x;                                                      \\\n  }\n#define KF_TRACE(d, x)                                                         \\\n  if (kmp_f_debug >= d) {                                                      \\\n    __kmp_debug_printf x;                                                      \\\n  }\n#define K_DIAG(d, x)                                                           \\\n  {                                                                            \\\n    if (kmp_diag == d) {                                                       \\\n      __kmp_debug_printf_stdout x;                                             \\\n    }                                                                          \\\n  }\n\n#define KA_DUMP(d, x)                                                          \\\n  if (kmp_a_debug >= d) {                                                      \\\n    int ks;                                                                    \\\n    __kmp_disable(&ks);                                                        \\\n    (x);                                                                       \\\n    __kmp_enable(ks);                                                          \\\n  }\n#define KB_DUMP(d, x)                                                          \\\n  if (kmp_b_debug >= d) {                                                      \\\n    int ks;                                                                    \\\n    __kmp_disable(&ks);                                                        \\\n    (x);                                                                       \\\n    __kmp_enable(ks);                                                          \\\n  }\n#define KC_DUMP(d, x)                                                          \\\n  if (kmp_c_debug >= d) {                                                      \\\n    int ks;                                                                    \\\n    __kmp_disable(&ks);                                                        \\\n    (x);                                                                       \\\n    __kmp_enable(ks);                                                          \\\n  }\n#define KD_DUMP(d, x)                                                          \\\n  if (kmp_d_debug >= d) {                                                      \\\n    int ks;                                                                    \\\n    __kmp_disable(&ks);                                                        \\\n    (x);                                                                       \\\n    __kmp_enable(ks);                                                          \\\n  }\n#define KE_DUMP(d, x)                                                          \\\n  if (kmp_e_debug >= d) {                                                      \\\n    int ks;                                                                    \\\n    __kmp_disable(&ks);                                                        \\\n    (x);                                                                       \\\n    __kmp_enable(ks);                                                          \\\n  }\n#define KF_DUMP(d, x)                                                          \\\n  if (kmp_f_debug >= d) {                                                      \\\n    int ks;                                                                    \\\n    __kmp_disable(&ks);                                                        \\\n    (x);                                                                       \\\n    __kmp_enable(ks);                                                          \\\n  }\n\n#else\n\n#define KA_TRACE(d, x) /* nothing to do */\n#define KB_TRACE(d, x) /* nothing to do */\n#define KC_TRACE(d, x) /* nothing to do */\n#define KD_TRACE(d, x) /* nothing to do */\n#define KE_TRACE(d, x) /* nothing to do */\n#define KF_TRACE(d, x) /* nothing to do */\n#define K_DIAG(d, x)                                                           \\\n  {} /* nothing to do */\n\n#define KA_DUMP(d, x) /* nothing to do */\n#define KB_DUMP(d, x) /* nothing to do */\n#define KC_DUMP(d, x) /* nothing to do */\n#define KD_DUMP(d, x) /* nothing to do */\n#define KE_DUMP(d, x) /* nothing to do */\n#define KF_DUMP(d, x) /* nothing to do */\n\n#endif // KMP_DEBUG\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n\n#endif /* KMP_DEBUG_H */\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_i18n.h", "content": "/*\n * kmp_i18n.h\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_I18N_H\n#define KMP_I18N_H\n\n#include \"kmp_str.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n/* kmp_i18n_id.inc defines kmp_i18n_id_t type. It is an enumeration with\n   identifiers of all the messages in the catalog. There is one special\n   identifier: kmp_i18n_null, which denotes absence of message. */\n#include \"kmp_i18n_id.inc\" // Generated file. Do not edit it manually.\n\n/* Low-level functions handling message catalog. __kmp_i18n_open() opens message\n   catalog, __kmp_i18n_closes() it. Explicit opening is not required: if message\n   catalog is not yet open, __kmp_i18n_catgets() will open it implicitly.\n   However, catalog should be explicitly closed, otherwise resources (mamory,\n   handles) may leak.\n\n   __kmp_i18n_catgets() returns read-only string. It should not be freed.\n\n   KMP_I18N_STR macro simplifies access to strings in message catalog a bit.\n   Following two lines are equivalent:\n\n   __kmp_i18n_catgets( kmp_i18n_str_Warning )\n   KMP_I18N_STR( Warning )\n*/\n\nvoid __kmp_i18n_catopen();\nvoid __kmp_i18n_catclose();\nchar const *__kmp_i18n_catgets(kmp_i18n_id_t id);\n\n#define KMP_I18N_STR(id) __kmp_i18n_catgets(kmp_i18n_str_##id)\n\n/* High-level interface for printing strings targeted to the user.\n\n   All the strings are divided into 3 types:\n   * messages,\n   * hints,\n   * system errors.\n\n   There are 3 kind of message severities:\n   * informational messages,\n   * warnings (non-fatal errors),\n   * fatal errors.\n\n   For example:\n     OMP: Warning #2: Cannot open message catalog \"libguide.cat\":   (1)\n     OMP: System error #2: No such file or directory                (2)\n     OMP: Hint: Please check NLSPATH environment variable.          (3)\n     OMP: Info #3: Default messages will be used.                   (4)\n\n   where\n   (1) is a message of warning severity,\n   (2) is a system error caused the previous warning,\n   (3) is a hint for the user how to fix the problem,\n   (4) is a message of informational severity.\n\n   Usage in complex cases (message is accompanied with hints and system errors):\n\n   int error = errno; // We need save errno immediately, because it may\n                      // be changed.\n   __kmp_msg(\n       kmp_ms_warning,                        // Severity\n       KMP_MSG( CantOpenMessageCatalog, name ), // Primary message\n       KMP_ERR( error ),                      // System error\n       KMP_HNT( CheckNLSPATH ),               // Hint\n       __kmp_msg_null                         // Variadic argument list finisher\n   );\n\n   Usage in simple cases (just a message, no system errors or hints):\n   KMP_INFORM( WillUseDefaultMessages );\n   KMP_WARNING( CantOpenMessageCatalog, name );\n   KMP_FATAL( StackOverlap );\n   KMP_SYSFAIL( \"pthread_create\", status );\n   KMP_CHECK_SYSFAIL( \"pthread_create\", status );\n   KMP_CHECK_SYSFAIL_ERRNO( \"gettimeofday\", status );\n*/\n\nenum kmp_msg_type {\n  kmp_mt_dummy = 0, // Special type for internal purposes.\n  kmp_mt_mesg =\n      4, // Primary OpenMP message, could be information, warning, or fatal.\n  kmp_mt_hint = 5, // Hint to the user.\n  kmp_mt_syserr = -1 // System error message.\n}; // enum kmp_msg_type\ntypedef enum kmp_msg_type kmp_msg_type_t;\n\nstruct kmp_msg {\n  kmp_msg_type_t type;\n  int num;\n  char *str;\n  size_t len;\n}; // struct kmp_message\ntypedef struct kmp_msg kmp_msg_t;\n\n// Special message to denote the end of variadic list of arguments.\nextern kmp_msg_t __kmp_msg_null;\n\n// Helper functions. Creates messages either from message catalog or from\n// system. Note: these functions allocate memory. You should pass created\n// messages to __kmp_msg() function, it will print messages and destroy them.\nkmp_msg_t __kmp_msg_format(unsigned id_arg, ...);\nkmp_msg_t __kmp_msg_error_code(int code);\nkmp_msg_t __kmp_msg_error_mesg(char const *mesg);\n\n// Helper macros to make calls shorter.\n#define KMP_MSG(...) __kmp_msg_format(kmp_i18n_msg_##__VA_ARGS__)\n#define KMP_HNT(...) __kmp_msg_format(kmp_i18n_hnt_##__VA_ARGS__)\n#define KMP_SYSERRCODE(code) __kmp_msg_error_code(code)\n#define KMP_SYSERRMESG(mesg) __kmp_msg_error_mesg(mesg)\n#define KMP_ERR KMP_SYSERRCODE\n\n// Message severity.\nenum kmp_msg_severity {\n  kmp_ms_inform, // Just information for the user.\n  kmp_ms_warning, // Non-fatal error, execution continues.\n  kmp_ms_fatal // Fatal error, program aborts.\n}; // enum kmp_msg_severity\ntypedef enum kmp_msg_severity kmp_msg_severity_t;\n\n// Primary function for printing messages for the user. The first message is\n// mandatory. Any number of system errors and hints may be specified. Argument\n// list must be finished with __kmp_msg_null.\nvoid __kmp_msg(kmp_msg_severity_t severity, kmp_msg_t message, ...);\nKMP_NORETURN void __kmp_fatal(kmp_msg_t message, ...);\n\n// Helper macros to make calls shorter in simple cases.\n#define KMP_INFORM(...)                                                        \\\n  __kmp_msg(kmp_ms_inform, KMP_MSG(__VA_ARGS__), __kmp_msg_null)\n#define KMP_WARNING(...)                                                       \\\n  __kmp_msg(kmp_ms_warning, KMP_MSG(__VA_ARGS__), __kmp_msg_null)\n#define KMP_FATAL(...) __kmp_fatal(KMP_MSG(__VA_ARGS__), __kmp_msg_null)\n#define KMP_SYSFAIL(func, error)                                               \\\n  __kmp_fatal(KMP_MSG(FunctionError, func), KMP_SYSERRCODE(error),             \\\n              __kmp_msg_null)\n\n// Check error, if not zero, generate fatal error message.\n#define KMP_CHECK_SYSFAIL(func, error)                                         \\\n  {                                                                            \\\n    if (error) {                                                               \\\n      KMP_SYSFAIL(func, error);                                                \\\n    }                                                                          \\\n  }\n\n// Check status, if not zero, generate fatal error message using errno.\n#define KMP_CHECK_SYSFAIL_ERRNO(func, status)                                  \\\n  {                                                                            \\\n    if (status != 0) {                                                         \\\n      int error = errno;                                                       \\\n      KMP_SYSFAIL(func, error);                                                \\\n    }                                                                          \\\n  }\n\n#ifdef KMP_DEBUG\nvoid __kmp_i18n_dump_catalog(kmp_str_buf_t *buffer);\n#endif // KMP_DEBUG\n\n#ifdef __cplusplus\n}; // extern \"C\"\n#endif // __cplusplus\n\n#endif // KMP_I18N_H\n\n// end of file //\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_io.h", "content": "/*\n * kmp_io.h -- RTL IO header file.\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_IO_H\n#define KMP_IO_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* ------------------------------------------------------------------------ */\n\nenum kmp_io { kmp_out = 0, kmp_err };\n\nextern kmp_bootstrap_lock_t __kmp_stdio_lock; /* Control stdio functions */\nextern kmp_bootstrap_lock_t\n    __kmp_console_lock; /* Control console initialization */\n\nextern void __kmp_vprintf(enum kmp_io stream, char const *format, va_list ap);\nextern void __kmp_printf(char const *format, ...);\nextern void __kmp_printf_no_lock(char const *format, ...);\nextern void __kmp_fprintf(enum kmp_io stream, char const *format, ...);\nextern void __kmp_close_console(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* KMP_IO_H */\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_lock.h", "content": "/*\n * kmp_lock.h -- lock header file\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_LOCK_H\n#define KMP_LOCK_H\n\n#include <limits.h> // CHAR_BIT\n#include <stddef.h> // offsetof\n\n#include \"kmp_debug.h\"\n#include \"kmp_os.h\"\n\n#ifdef __cplusplus\n#include <atomic>\n\nextern \"C\" {\n#endif // __cplusplus\n\n// ----------------------------------------------------------------------------\n// Have to copy these definitions from kmp.h because kmp.h cannot be included\n// due to circular dependencies.  Will undef these at end of file.\n\n#define KMP_PAD(type, sz)                                                      \\\n  (sizeof(type) + (sz - ((sizeof(type) - 1) % (sz)) - 1))\n#define KMP_GTID_DNE (-2)\n\n// Forward declaration of ident and ident_t\n\nstruct ident;\ntypedef struct ident ident_t;\n\n// End of copied code.\n// ----------------------------------------------------------------------------\n\n// We need to know the size of the area we can assume that the compiler(s)\n// allocated for objects of type omp_lock_t and omp_nest_lock_t.  The Intel\n// compiler always allocates a pointer-sized area, as does visual studio.\n//\n// gcc however, only allocates 4 bytes for regular locks, even on 64-bit\n// intel archs.  It allocates at least 8 bytes for nested lock (more on\n// recent versions), but we are bounded by the pointer-sized chunks that\n// the Intel compiler allocates.\n\n#if KMP_OS_LINUX && defined(KMP_GOMP_COMPAT)\n#define OMP_LOCK_T_SIZE sizeof(int)\n#define OMP_NEST_LOCK_T_SIZE sizeof(void *)\n#else\n#define OMP_LOCK_T_SIZE sizeof(void *)\n#define OMP_NEST_LOCK_T_SIZE sizeof(void *)\n#endif\n\n// The Intel compiler allocates a 32-byte chunk for a critical section.\n// Both gcc and visual studio only allocate enough space for a pointer.\n// Sometimes we know that the space was allocated by the Intel compiler.\n#define OMP_CRITICAL_SIZE sizeof(void *)\n#define INTEL_CRITICAL_SIZE 32\n\n// lock flags\ntypedef kmp_uint32 kmp_lock_flags_t;\n\n#define kmp_lf_critical_section 1\n\n// When a lock table is used, the indices are of kmp_lock_index_t\ntypedef kmp_uint32 kmp_lock_index_t;\n\n// When memory allocated for locks are on the lock pool (free list),\n// it is treated as structs of this type.\nstruct kmp_lock_pool {\n  union kmp_user_lock *next;\n  kmp_lock_index_t index;\n};\n\ntypedef struct kmp_lock_pool kmp_lock_pool_t;\n\nextern void __kmp_validate_locks(void);\n\n// ----------------------------------------------------------------------------\n//  There are 5 lock implementations:\n//       1. Test and set locks.\n//       2. futex locks (Linux* OS on x86 and\n//          Intel(R) Many Integrated Core Architecture)\n//       3. Ticket (Lamport bakery) locks.\n//       4. Queuing locks (with separate spin fields).\n//       5. DRPA (Dynamically Reconfigurable Distributed Polling Area) locks\n//\n//   and 3 lock purposes:\n//       1. Bootstrap locks -- Used for a few locks available at library\n//       startup-shutdown time.\n//          These do not require non-negative global thread ID's.\n//       2. Internal RTL locks -- Used everywhere else in the RTL\n//       3. User locks (includes critical sections)\n// ----------------------------------------------------------------------------\n\n// ============================================================================\n// Lock implementations.\n//\n// Test and set locks.\n//\n// Non-nested test and set locks differ from the other lock kinds (except\n// futex) in that we use the memory allocated by the compiler for the lock,\n// rather than a pointer to it.\n//\n// On lin32, lin_32e, and win_32, the space allocated may be as small as 4\n// bytes, so we have to use a lock table for nested locks, and avoid accessing\n// the depth_locked field for non-nested locks.\n//\n// Information normally available to the tools, such as lock location, lock\n// usage (normal lock vs. critical section), etc. is not available with test and\n// set locks.\n// ----------------------------------------------------------------------------\n\nstruct kmp_base_tas_lock {\n  // KMP_LOCK_FREE(tas) => unlocked; locked: (gtid+1) of owning thread\n  std::atomic<kmp_int32> poll;\n  kmp_int32 depth_locked; // depth locked, for nested locks only\n};\n\ntypedef struct kmp_base_tas_lock kmp_base_tas_lock_t;\n\nunion kmp_tas_lock {\n  kmp_base_tas_lock_t lk;\n  kmp_lock_pool_t pool; // make certain struct is large enough\n  double lk_align; // use worst case alignment; no cache line padding\n};\n\ntypedef union kmp_tas_lock kmp_tas_lock_t;\n\n// Static initializer for test and set lock variables. Usage:\n//    kmp_tas_lock_t xlock = KMP_TAS_LOCK_INITIALIZER( xlock );\n#define KMP_TAS_LOCK_INITIALIZER(lock)                                         \\\n  {                                                                            \\\n    { ATOMIC_VAR_INIT(KMP_LOCK_FREE(tas)), 0 }                                 \\\n  }\n\nextern int __kmp_acquire_tas_lock(kmp_tas_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_test_tas_lock(kmp_tas_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_release_tas_lock(kmp_tas_lock_t *lck, kmp_int32 gtid);\nextern void __kmp_init_tas_lock(kmp_tas_lock_t *lck);\nextern void __kmp_destroy_tas_lock(kmp_tas_lock_t *lck);\n\nextern int __kmp_acquire_nested_tas_lock(kmp_tas_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_test_nested_tas_lock(kmp_tas_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_release_nested_tas_lock(kmp_tas_lock_t *lck, kmp_int32 gtid);\nextern void __kmp_init_nested_tas_lock(kmp_tas_lock_t *lck);\nextern void __kmp_destroy_nested_tas_lock(kmp_tas_lock_t *lck);\n\n#define KMP_LOCK_RELEASED 1\n#define KMP_LOCK_STILL_HELD 0\n#define KMP_LOCK_ACQUIRED_FIRST 1\n#define KMP_LOCK_ACQUIRED_NEXT 0\n#ifndef KMP_USE_FUTEX\n#define KMP_USE_FUTEX                                                          \\\n  (KMP_OS_LINUX &&                                                             \\\n   (KMP_ARCH_X86 || KMP_ARCH_X86_64 || KMP_ARCH_ARM || KMP_ARCH_AARCH64))\n#endif\n#if KMP_USE_FUTEX\n\n// ----------------------------------------------------------------------------\n// futex locks.  futex locks are only available on Linux* OS.\n//\n// Like non-nested test and set lock, non-nested futex locks use the memory\n// allocated by the compiler for the lock, rather than a pointer to it.\n//\n// Information normally available to the tools, such as lock location, lock\n// usage (normal lock vs. critical section), etc. is not available with test and\n// set locks. With non-nested futex locks, the lock owner is not even available.\n// ----------------------------------------------------------------------------\n\nstruct kmp_base_futex_lock {\n  volatile kmp_int32 poll; // KMP_LOCK_FREE(futex) => unlocked\n  // 2*(gtid+1) of owning thread, 0 if unlocked\n  // locked: (gtid+1) of owning thread\n  kmp_int32 depth_locked; // depth locked, for nested locks only\n};\n\ntypedef struct kmp_base_futex_lock kmp_base_futex_lock_t;\n\nunion kmp_futex_lock {\n  kmp_base_futex_lock_t lk;\n  kmp_lock_pool_t pool; // make certain struct is large enough\n  double lk_align; // use worst case alignment\n  // no cache line padding\n};\n\ntypedef union kmp_futex_lock kmp_futex_lock_t;\n\n// Static initializer for futex lock variables. Usage:\n//    kmp_futex_lock_t xlock = KMP_FUTEX_LOCK_INITIALIZER( xlock );\n#define KMP_FUTEX_LOCK_INITIALIZER(lock)                                       \\\n  {                                                                            \\\n    { KMP_LOCK_FREE(futex), 0 }                                                \\\n  }\n\nextern int __kmp_acquire_futex_lock(kmp_futex_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_test_futex_lock(kmp_futex_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_release_futex_lock(kmp_futex_lock_t *lck, kmp_int32 gtid);\nextern void __kmp_init_futex_lock(kmp_futex_lock_t *lck);\nextern void __kmp_destroy_futex_lock(kmp_futex_lock_t *lck);\n\nextern int __kmp_acquire_nested_futex_lock(kmp_futex_lock_t *lck,\n                                           kmp_int32 gtid);\nextern int __kmp_test_nested_futex_lock(kmp_futex_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_release_nested_futex_lock(kmp_futex_lock_t *lck,\n                                           kmp_int32 gtid);\nextern void __kmp_init_nested_futex_lock(kmp_futex_lock_t *lck);\nextern void __kmp_destroy_nested_futex_lock(kmp_futex_lock_t *lck);\n\n#endif // KMP_USE_FUTEX\n\n// ----------------------------------------------------------------------------\n// Ticket locks.\n\n#ifdef __cplusplus\n\n#ifdef _MSC_VER\n// MSVC won't allow use of std::atomic<> in a union since it has non-trivial\n// copy constructor.\n\nstruct kmp_base_ticket_lock {\n  // `initialized' must be the first entry in the lock data structure!\n  std::atomic_bool initialized;\n  volatile union kmp_ticket_lock *self; // points to the lock union\n  ident_t const *location; // Source code location of omp_init_lock().\n  std::atomic_uint\n      next_ticket; // ticket number to give to next thread which acquires\n  std::atomic_uint now_serving; // ticket number for thread which holds the lock\n  std::atomic_int owner_id; // (gtid+1) of owning thread, 0 if unlocked\n  std::atomic_int depth_locked; // depth locked, for nested locks only\n  kmp_lock_flags_t flags; // lock specifics, e.g. critical section lock\n};\n#else\nstruct kmp_base_ticket_lock {\n  // `initialized' must be the first entry in the lock data structure!\n  std::atomic<bool> initialized;\n  volatile union kmp_ticket_lock *self; // points to the lock union\n  ident_t const *location; // Source code location of omp_init_lock().\n  std::atomic<unsigned>\n      next_ticket; // ticket number to give to next thread which acquires\n  std::atomic<unsigned>\n      now_serving; // ticket number for thread which holds the lock\n  std::atomic<int> owner_id; // (gtid+1) of owning thread, 0 if unlocked\n  std::atomic<int> depth_locked; // depth locked, for nested locks only\n  kmp_lock_flags_t flags; // lock specifics, e.g. critical section lock\n};\n#endif\n\n#else // __cplusplus\n\nstruct kmp_base_ticket_lock;\n\n#endif // !__cplusplus\n\ntypedef struct kmp_base_ticket_lock kmp_base_ticket_lock_t;\n\nunion KMP_ALIGN_CACHE kmp_ticket_lock {\n  kmp_base_ticket_lock_t\n      lk; // This field must be first to allow static initializing.\n  kmp_lock_pool_t pool;\n  double lk_align; // use worst case alignment\n  char lk_pad[KMP_PAD(kmp_base_ticket_lock_t, CACHE_LINE)];\n};\n\ntypedef union kmp_ticket_lock kmp_ticket_lock_t;\n\n// Static initializer for simple ticket lock variables. Usage:\n//    kmp_ticket_lock_t xlock = KMP_TICKET_LOCK_INITIALIZER( xlock );\n// Note the macro argument. It is important to make var properly initialized.\n#define KMP_TICKET_LOCK_INITIALIZER(lock)                                      \\\n  {                                                                            \\\n    {                                                                          \\\n      ATOMIC_VAR_INIT(true)                                                    \\\n      , &(lock), NULL, ATOMIC_VAR_INIT(0U), ATOMIC_VAR_INIT(0U),               \\\n          ATOMIC_VAR_INIT(0), ATOMIC_VAR_INIT(-1)                              \\\n    }                                                                          \\\n  }\n\nextern int __kmp_acquire_ticket_lock(kmp_ticket_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_test_ticket_lock(kmp_ticket_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_test_ticket_lock_with_cheks(kmp_ticket_lock_t *lck,\n                                             kmp_int32 gtid);\nextern int __kmp_release_ticket_lock(kmp_ticket_lock_t *lck, kmp_int32 gtid);\nextern void __kmp_init_ticket_lock(kmp_ticket_lock_t *lck);\nextern void __kmp_destroy_ticket_lock(kmp_ticket_lock_t *lck);\n\nextern int __kmp_acquire_nested_ticket_lock(kmp_ticket_lock_t *lck,\n                                            kmp_int32 gtid);\nextern int __kmp_test_nested_ticket_lock(kmp_ticket_lock_t *lck,\n                                         kmp_int32 gtid);\nextern int __kmp_release_nested_ticket_lock(kmp_ticket_lock_t *lck,\n                                            kmp_int32 gtid);\nextern void __kmp_init_nested_ticket_lock(kmp_ticket_lock_t *lck);\nextern void __kmp_destroy_nested_ticket_lock(kmp_ticket_lock_t *lck);\n\n// ----------------------------------------------------------------------------\n// Queuing locks.\n\n#if KMP_USE_ADAPTIVE_LOCKS\n\nstruct kmp_adaptive_lock_info;\n\ntypedef struct kmp_adaptive_lock_info kmp_adaptive_lock_info_t;\n\n#if KMP_DEBUG_ADAPTIVE_LOCKS\n\nstruct kmp_adaptive_lock_statistics {\n  /* So we can get stats from locks that haven't been destroyed. */\n  kmp_adaptive_lock_info_t *next;\n  kmp_adaptive_lock_info_t *prev;\n\n  /* Other statistics */\n  kmp_uint32 successfulSpeculations;\n  kmp_uint32 hardFailedSpeculations;\n  kmp_uint32 softFailedSpeculations;\n  kmp_uint32 nonSpeculativeAcquires;\n  kmp_uint32 nonSpeculativeAcquireAttempts;\n  kmp_uint32 lemmingYields;\n};\n\ntypedef struct kmp_adaptive_lock_statistics kmp_adaptive_lock_statistics_t;\n\nextern void __kmp_print_speculative_stats();\nextern void __kmp_init_speculative_stats();\n\n#endif // KMP_DEBUG_ADAPTIVE_LOCKS\n\nstruct kmp_adaptive_lock_info {\n  /* Values used for adaptivity.\n     Although these are accessed from multiple threads we don't access them\n     atomically, because if we miss updates it probably doesn't matter much. (It\n     just affects our decision about whether to try speculation on the lock). */\n  kmp_uint32 volatile badness;\n  kmp_uint32 volatile acquire_attempts;\n  /* Parameters of the lock. */\n  kmp_uint32 max_badness;\n  kmp_uint32 max_soft_retries;\n\n#if KMP_DEBUG_ADAPTIVE_LOCKS\n  kmp_adaptive_lock_statistics_t volatile stats;\n#endif\n};\n\n#endif // KMP_USE_ADAPTIVE_LOCKS\n\nstruct kmp_base_queuing_lock {\n\n  //  `initialized' must be the first entry in the lock data structure!\n  volatile union kmp_queuing_lock\n      *initialized; // Points to the lock union if in initialized state.\n\n  ident_t const *location; // Source code location of omp_init_lock().\n\n  KMP_ALIGN(8) // tail_id  must be 8-byte aligned!\n\n  volatile kmp_int32\n      tail_id; // (gtid+1) of thread at tail of wait queue, 0 if empty\n  // Must be no padding here since head/tail used in 8-byte CAS\n  volatile kmp_int32\n      head_id; // (gtid+1) of thread at head of wait queue, 0 if empty\n  // Decl order assumes little endian\n  // bakery-style lock\n  volatile kmp_uint32\n      next_ticket; // ticket number to give to next thread which acquires\n  volatile kmp_uint32\n      now_serving; // ticket number for thread which holds the lock\n  volatile kmp_int32 owner_id; // (gtid+1) of owning thread, 0 if unlocked\n  kmp_int32 depth_locked; // depth locked, for nested locks only\n\n  kmp_lock_flags_t flags; // lock specifics, e.g. critical section lock\n};\n\ntypedef struct kmp_base_queuing_lock kmp_base_queuing_lock_t;\n\nKMP_BUILD_ASSERT(offsetof(kmp_base_queuing_lock_t, tail_id) % 8 == 0);\n\nunion KMP_ALIGN_CACHE kmp_queuing_lock {\n  kmp_base_queuing_lock_t\n      lk; // This field must be first to allow static initializing.\n  kmp_lock_pool_t pool;\n  double lk_align; // use worst case alignment\n  char lk_pad[KMP_PAD(kmp_base_queuing_lock_t, CACHE_LINE)];\n};\n\ntypedef union kmp_queuing_lock kmp_queuing_lock_t;\n\nextern int __kmp_acquire_queuing_lock(kmp_queuing_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_test_queuing_lock(kmp_queuing_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_release_queuing_lock(kmp_queuing_lock_t *lck, kmp_int32 gtid);\nextern void __kmp_init_queuing_lock(kmp_queuing_lock_t *lck);\nextern void __kmp_destroy_queuing_lock(kmp_queuing_lock_t *lck);\n\nextern int __kmp_acquire_nested_queuing_lock(kmp_queuing_lock_t *lck,\n                                             kmp_int32 gtid);\nextern int __kmp_test_nested_queuing_lock(kmp_queuing_lock_t *lck,\n                                          kmp_int32 gtid);\nextern int __kmp_release_nested_queuing_lock(kmp_queuing_lock_t *lck,\n                                             kmp_int32 gtid);\nextern void __kmp_init_nested_queuing_lock(kmp_queuing_lock_t *lck);\nextern void __kmp_destroy_nested_queuing_lock(kmp_queuing_lock_t *lck);\n\n#if KMP_USE_ADAPTIVE_LOCKS\n\n// ----------------------------------------------------------------------------\n// Adaptive locks.\nstruct kmp_base_adaptive_lock {\n  kmp_base_queuing_lock qlk;\n  KMP_ALIGN(CACHE_LINE)\n  kmp_adaptive_lock_info_t\n      adaptive; // Information for the speculative adaptive lock\n};\n\ntypedef struct kmp_base_adaptive_lock kmp_base_adaptive_lock_t;\n\nunion KMP_ALIGN_CACHE kmp_adaptive_lock {\n  kmp_base_adaptive_lock_t lk;\n  kmp_lock_pool_t pool;\n  double lk_align;\n  char lk_pad[KMP_PAD(kmp_base_adaptive_lock_t, CACHE_LINE)];\n};\ntypedef union kmp_adaptive_lock kmp_adaptive_lock_t;\n\n#define GET_QLK_PTR(l) ((kmp_queuing_lock_t *)&(l)->lk.qlk)\n\n#endif // KMP_USE_ADAPTIVE_LOCKS\n\n// ----------------------------------------------------------------------------\n// DRDPA ticket locks.\nstruct kmp_base_drdpa_lock {\n  // All of the fields on the first cache line are only written when\n  // initializing or reconfiguring the lock.  These are relatively rare\n  // operations, so data from the first cache line will usually stay resident in\n  // the cache of each thread trying to acquire the lock.\n  //\n  // initialized must be the first entry in the lock data structure!\n  KMP_ALIGN_CACHE\n\n  volatile union kmp_drdpa_lock\n      *initialized; // points to the lock union if in initialized state\n  ident_t const *location; // Source code location of omp_init_lock().\n  std::atomic<std::atomic<kmp_uint64> *> polls;\n  std::atomic<kmp_uint64> mask; // is 2**num_polls-1 for mod op\n  kmp_uint64 cleanup_ticket; // thread with cleanup ticket\n  std::atomic<kmp_uint64> *old_polls; // will deallocate old_polls\n  kmp_uint32 num_polls; // must be power of 2\n\n  // next_ticket it needs to exist in a separate cache line, as it is\n  // invalidated every time a thread takes a new ticket.\n  KMP_ALIGN_CACHE\n\n  std::atomic<kmp_uint64> next_ticket;\n\n  // now_serving is used to store our ticket value while we hold the lock. It\n  // has a slightly different meaning in the DRDPA ticket locks (where it is\n  // written by the acquiring thread) than it does in the simple ticket locks\n  // (where it is written by the releasing thread).\n  //\n  // Since now_serving is only read and written in the critical section,\n  // it is non-volatile, but it needs to exist on a separate cache line,\n  // as it is invalidated at every lock acquire.\n  //\n  // Likewise, the vars used for nested locks (owner_id and depth_locked) are\n  // only written by the thread owning the lock, so they are put in this cache\n  // line.  owner_id is read by other threads, so it must be declared volatile.\n  KMP_ALIGN_CACHE\n  kmp_uint64 now_serving; // doesn't have to be volatile\n  volatile kmp_uint32 owner_id; // (gtid+1) of owning thread, 0 if unlocked\n  kmp_int32 depth_locked; // depth locked\n  kmp_lock_flags_t flags; // lock specifics, e.g. critical section lock\n};\n\ntypedef struct kmp_base_drdpa_lock kmp_base_drdpa_lock_t;\n\nunion KMP_ALIGN_CACHE kmp_drdpa_lock {\n  kmp_base_drdpa_lock_t\n      lk; // This field must be first to allow static initializing. */\n  kmp_lock_pool_t pool;\n  double lk_align; // use worst case alignment\n  char lk_pad[KMP_PAD(kmp_base_drdpa_lock_t, CACHE_LINE)];\n};\n\ntypedef union kmp_drdpa_lock kmp_drdpa_lock_t;\n\nextern int __kmp_acquire_drdpa_lock(kmp_drdpa_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_test_drdpa_lock(kmp_drdpa_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_release_drdpa_lock(kmp_drdpa_lock_t *lck, kmp_int32 gtid);\nextern void __kmp_init_drdpa_lock(kmp_drdpa_lock_t *lck);\nextern void __kmp_destroy_drdpa_lock(kmp_drdpa_lock_t *lck);\n\nextern int __kmp_acquire_nested_drdpa_lock(kmp_drdpa_lock_t *lck,\n                                           kmp_int32 gtid);\nextern int __kmp_test_nested_drdpa_lock(kmp_drdpa_lock_t *lck, kmp_int32 gtid);\nextern int __kmp_release_nested_drdpa_lock(kmp_drdpa_lock_t *lck,\n                                           kmp_int32 gtid);\nextern void __kmp_init_nested_drdpa_lock(kmp_drdpa_lock_t *lck);\nextern void __kmp_destroy_nested_drdpa_lock(kmp_drdpa_lock_t *lck);\n\n// ============================================================================\n// Lock purposes.\n// ============================================================================\n\n// Bootstrap locks.\n//\n// Bootstrap locks -- very few locks used at library initialization time.\n// Bootstrap locks are currently implemented as ticket locks.\n// They could also be implemented as test and set lock, but cannot be\n// implemented with other lock kinds as they require gtids which are not\n// available at initialization time.\n\ntypedef kmp_ticket_lock_t kmp_bootstrap_lock_t;\n\n#define KMP_BOOTSTRAP_LOCK_INITIALIZER(lock) KMP_TICKET_LOCK_INITIALIZER((lock))\n#define KMP_BOOTSTRAP_LOCK_INIT(lock)                                          \\\n  kmp_bootstrap_lock_t lock = KMP_TICKET_LOCK_INITIALIZER(lock)\n\nstatic inline int __kmp_acquire_bootstrap_lock(kmp_bootstrap_lock_t *lck) {\n  return __kmp_acquire_ticket_lock(lck, KMP_GTID_DNE);\n}\n\nstatic inline int __kmp_test_bootstrap_lock(kmp_bootstrap_lock_t *lck) {\n  return __kmp_test_ticket_lock(lck, KMP_GTID_DNE);\n}\n\nstatic inline void __kmp_release_bootstrap_lock(kmp_bootstrap_lock_t *lck) {\n  __kmp_release_ticket_lock(lck, KMP_GTID_DNE);\n}\n\nstatic inline void __kmp_init_bootstrap_lock(kmp_bootstrap_lock_t *lck) {\n  __kmp_init_ticket_lock(lck);\n}\n\nstatic inline void __kmp_destroy_bootstrap_lock(kmp_bootstrap_lock_t *lck) {\n  __kmp_destroy_ticket_lock(lck);\n}\n\n// Internal RTL locks.\n//\n// Internal RTL locks are also implemented as ticket locks, for now.\n//\n// FIXME - We should go through and figure out which lock kind works best for\n// each internal lock, and use the type declaration and function calls for\n// that explicit lock kind (and get rid of this section).\n\ntypedef kmp_ticket_lock_t kmp_lock_t;\n\n#define KMP_LOCK_INIT(lock) kmp_lock_t lock = KMP_TICKET_LOCK_INITIALIZER(lock)\n\nstatic inline int __kmp_acquire_lock(kmp_lock_t *lck, kmp_int32 gtid) {\n  return __kmp_acquire_ticket_lock(lck, gtid);\n}\n\nstatic inline int __kmp_test_lock(kmp_lock_t *lck, kmp_int32 gtid) {\n  return __kmp_test_ticket_lock(lck, gtid);\n}\n\nstatic inline void __kmp_release_lock(kmp_lock_t *lck, kmp_int32 gtid) {\n  __kmp_release_ticket_lock(lck, gtid);\n}\n\nstatic inline void __kmp_init_lock(kmp_lock_t *lck) {\n  __kmp_init_ticket_lock(lck);\n}\n\nstatic inline void __kmp_destroy_lock(kmp_lock_t *lck) {\n  __kmp_destroy_ticket_lock(lck);\n}\n\n// User locks.\n//\n// Do not allocate objects of type union kmp_user_lock!!! This will waste space\n// unless __kmp_user_lock_kind == lk_drdpa. Instead, check the value of\n// __kmp_user_lock_kind and allocate objects of the type of the appropriate\n// union member, and cast their addresses to kmp_user_lock_p.\n\nenum kmp_lock_kind {\n  lk_default = 0,\n  lk_tas,\n#if KMP_USE_FUTEX\n  lk_futex,\n#endif\n#if KMP_USE_DYNAMIC_LOCK && KMP_USE_TSX\n  lk_hle,\n  lk_rtm_queuing,\n  lk_rtm_spin,\n#endif\n  lk_ticket,\n  lk_queuing,\n  lk_drdpa,\n#if KMP_USE_ADAPTIVE_LOCKS\n  lk_adaptive\n#endif // KMP_USE_ADAPTIVE_LOCKS\n};\n\ntypedef enum kmp_lock_kind kmp_lock_kind_t;\n\nextern kmp_lock_kind_t __kmp_user_lock_kind;\n\nunion kmp_user_lock {\n  kmp_tas_lock_t tas;\n#if KMP_USE_FUTEX\n  kmp_futex_lock_t futex;\n#endif\n  kmp_ticket_lock_t ticket;\n  kmp_queuing_lock_t queuing;\n  kmp_drdpa_lock_t drdpa;\n#if KMP_USE_ADAPTIVE_LOCKS\n  kmp_adaptive_lock_t adaptive;\n#endif // KMP_USE_ADAPTIVE_LOCKS\n  kmp_lock_pool_t pool;\n};\n\ntypedef union kmp_user_lock *kmp_user_lock_p;\n\n#if !KMP_USE_DYNAMIC_LOCK\n\nextern size_t __kmp_base_user_lock_size;\nextern size_t __kmp_user_lock_size;\n\nextern kmp_int32 (*__kmp_get_user_lock_owner_)(kmp_user_lock_p lck);\n\nstatic inline kmp_int32 __kmp_get_user_lock_owner(kmp_user_lock_p lck) {\n  KMP_DEBUG_ASSERT(__kmp_get_user_lock_owner_ != NULL);\n  return (*__kmp_get_user_lock_owner_)(lck);\n}\n\nextern int (*__kmp_acquire_user_lock_with_checks_)(kmp_user_lock_p lck,\n                                                   kmp_int32 gtid);\n\n#if KMP_OS_LINUX &&                                                            \\\n    (KMP_ARCH_X86 || KMP_ARCH_X86_64 || KMP_ARCH_ARM || KMP_ARCH_AARCH64)\n\n#define __kmp_acquire_user_lock_with_checks(lck, gtid)                         \\\n  if (__kmp_user_lock_kind == lk_tas) {                                        \\\n    if (__kmp_env_consistency_check) {                                         \\\n      char const *const func = \"omp_set_lock\";                                 \\\n      if ((sizeof(kmp_tas_lock_t) <= OMP_LOCK_T_SIZE) &&                       \\\n          lck->tas.lk.depth_locked != -1) {                                    \\\n        KMP_FATAL(LockNestableUsedAsSimple, func);                             \\\n      }                                                                        \\\n      if ((gtid >= 0) && (lck->tas.lk.poll - 1 == gtid)) {                     \\\n        KMP_FATAL(LockIsAlreadyOwned, func);                                   \\\n      }                                                                        \\\n    }                                                                          \\\n    if (lck->tas.lk.poll != 0 ||                                               \\\n        !__kmp_atomic_compare_store_acq(&lck->tas.lk.poll, 0, gtid + 1)) {     \\\n      kmp_uint32 spins;                                                        \\\n      KMP_FSYNC_PREPARE(lck);                                                  \\\n      KMP_INIT_YIELD(spins);                                                   \\\n      do {                                                                     \\\n        KMP_YIELD_OVERSUB_ELSE_SPIN(spins);                                    \\\n      } while (lck->tas.lk.poll != 0 || !__kmp_atomic_compare_store_acq(       \\\n                                            &lck->tas.lk.poll, 0, gtid + 1));  \\\n    }                                                                          \\\n    KMP_FSYNC_ACQUIRED(lck);                                                   \\\n  } else {                                                                     \\\n    KMP_DEBUG_ASSERT(__kmp_acquire_user_lock_with_checks_ != NULL);            \\\n    (*__kmp_acquire_user_lock_with_checks_)(lck, gtid);                        \\\n  }\n\n#else\nstatic inline int __kmp_acquire_user_lock_with_checks(kmp_user_lock_p lck,\n                                                      kmp_int32 gtid) {\n  KMP_DEBUG_ASSERT(__kmp_acquire_user_lock_with_checks_ != NULL);\n  return (*__kmp_acquire_user_lock_with_checks_)(lck, gtid);\n}\n#endif\n\nextern int (*__kmp_test_user_lock_with_checks_)(kmp_user_lock_p lck,\n                                                kmp_int32 gtid);\n\n#if KMP_OS_LINUX &&                                                            \\\n    (KMP_ARCH_X86 || KMP_ARCH_X86_64 || KMP_ARCH_ARM || KMP_ARCH_AARCH64)\n\n#include \"kmp_i18n.h\" /* AC: KMP_FATAL definition */\nextern int __kmp_env_consistency_check; /* AC: copy from kmp.h here */\nstatic inline int __kmp_test_user_lock_with_checks(kmp_user_lock_p lck,\n                                                   kmp_int32 gtid) {\n  if (__kmp_user_lock_kind == lk_tas) {\n    if (__kmp_env_consistency_check) {\n      char const *const func = \"omp_test_lock\";\n      if ((sizeof(kmp_tas_lock_t) <= OMP_LOCK_T_SIZE) &&\n          lck->tas.lk.depth_locked != -1) {\n        KMP_FATAL(LockNestableUsedAsSimple, func);\n      }\n    }\n    return ((lck->tas.lk.poll == 0) &&\n            __kmp_atomic_compare_store_acq(&lck->tas.lk.poll, 0, gtid + 1));\n  } else {\n    KMP_DEBUG_ASSERT(__kmp_test_user_lock_with_checks_ != NULL);\n    return (*__kmp_test_user_lock_with_checks_)(lck, gtid);\n  }\n}\n#else\nstatic inline int __kmp_test_user_lock_with_checks(kmp_user_lock_p lck,\n                                                   kmp_int32 gtid) {\n  KMP_DEBUG_ASSERT(__kmp_test_user_lock_with_checks_ != NULL);\n  return (*__kmp_test_user_lock_with_checks_)(lck, gtid);\n}\n#endif\n\nextern int (*__kmp_release_user_lock_with_checks_)(kmp_user_lock_p lck,\n                                                   kmp_int32 gtid);\n\nstatic inline void __kmp_release_user_lock_with_checks(kmp_user_lock_p lck,\n                                                       kmp_int32 gtid) {\n  KMP_DEBUG_ASSERT(__kmp_release_user_lock_with_checks_ != NULL);\n  (*__kmp_release_user_lock_with_checks_)(lck, gtid);\n}\n\nextern void (*__kmp_init_user_lock_with_checks_)(kmp_user_lock_p lck);\n\nstatic inline void __kmp_init_user_lock_with_checks(kmp_user_lock_p lck) {\n  KMP_DEBUG_ASSERT(__kmp_init_user_lock_with_checks_ != NULL);\n  (*__kmp_init_user_lock_with_checks_)(lck);\n}\n\n// We need a non-checking version of destroy lock for when the RTL is\n// doing the cleanup as it can't always tell if the lock is nested or not.\nextern void (*__kmp_destroy_user_lock_)(kmp_user_lock_p lck);\n\nstatic inline void __kmp_destroy_user_lock(kmp_user_lock_p lck) {\n  KMP_DEBUG_ASSERT(__kmp_destroy_user_lock_ != NULL);\n  (*__kmp_destroy_user_lock_)(lck);\n}\n\nextern void (*__kmp_destroy_user_lock_with_checks_)(kmp_user_lock_p lck);\n\nstatic inline void __kmp_destroy_user_lock_with_checks(kmp_user_lock_p lck) {\n  KMP_DEBUG_ASSERT(__kmp_destroy_user_lock_with_checks_ != NULL);\n  (*__kmp_destroy_user_lock_with_checks_)(lck);\n}\n\nextern int (*__kmp_acquire_nested_user_lock_with_checks_)(kmp_user_lock_p lck,\n                                                          kmp_int32 gtid);\n\n#if KMP_OS_LINUX && (KMP_ARCH_X86 || KMP_ARCH_X86_64)\n\n#define __kmp_acquire_nested_user_lock_with_checks(lck, gtid, depth)           \\\n  if (__kmp_user_lock_kind == lk_tas) {                                        \\\n    if (__kmp_env_consistency_check) {                                         \\\n      char const *const func = \"omp_set_nest_lock\";                            \\\n      if ((sizeof(kmp_tas_lock_t) <= OMP_NEST_LOCK_T_SIZE) &&                  \\\n          lck->tas.lk.depth_locked == -1) {                                    \\\n        KMP_FATAL(LockSimpleUsedAsNestable, func);                             \\\n      }                                                                        \\\n    }                                                                          \\\n    if (lck->tas.lk.poll - 1 == gtid) {                                        \\\n      lck->tas.lk.depth_locked += 1;                                           \\\n      *depth = KMP_LOCK_ACQUIRED_NEXT;                                         \\\n    } else {                                                                   \\\n      if ((lck->tas.lk.poll != 0) ||                                           \\\n          !__kmp_atomic_compare_store_acq(&lck->tas.lk.poll, 0, gtid + 1)) {   \\\n        kmp_uint32 spins;                                                      \\\n        KMP_FSYNC_PREPARE(lck);                                                \\\n        KMP_INIT_YIELD(spins);                                                 \\\n        do {                                                                   \\\n          KMP_YIELD_OVERSUB_ELSE_SPIN(spins);                                  \\\n        } while (                                                              \\\n            (lck->tas.lk.poll != 0) ||                                         \\\n            !__kmp_atomic_compare_store_acq(&lck->tas.lk.poll, 0, gtid + 1));  \\\n      }                                                                        \\\n      lck->tas.lk.depth_locked = 1;                                            \\\n      *depth = KMP_LOCK_ACQUIRED_FIRST;                                        \\\n    }                                                                          \\\n    KMP_FSYNC_ACQUIRED(lck);                                                   \\\n  } else {                                                                     \\\n    KMP_DEBUG_ASSERT(__kmp_acquire_nested_user_lock_with_checks_ != NULL);     \\\n    *depth = (*__kmp_acquire_nested_user_lock_with_checks_)(lck, gtid);        \\\n  }\n\n#else\nstatic inline void\n__kmp_acquire_nested_user_lock_with_checks(kmp_user_lock_p lck, kmp_int32 gtid,\n                                           int *depth) {\n  KMP_DEBUG_ASSERT(__kmp_acquire_nested_user_lock_with_checks_ != NULL);\n  *depth = (*__kmp_acquire_nested_user_lock_with_checks_)(lck, gtid);\n}\n#endif\n\nextern int (*__kmp_test_nested_user_lock_with_checks_)(kmp_user_lock_p lck,\n                                                       kmp_int32 gtid);\n\n#if KMP_OS_LINUX && (KMP_ARCH_X86 || KMP_ARCH_X86_64)\nstatic inline int __kmp_test_nested_user_lock_with_checks(kmp_user_lock_p lck,\n                                                          kmp_int32 gtid) {\n  if (__kmp_user_lock_kind == lk_tas) {\n    int retval;\n    if (__kmp_env_consistency_check) {\n      char const *const func = \"omp_test_nest_lock\";\n      if ((sizeof(kmp_tas_lock_t) <= OMP_NEST_LOCK_T_SIZE) &&\n          lck->tas.lk.depth_locked == -1) {\n        KMP_FATAL(LockSimpleUsedAsNestable, func);\n      }\n    }\n    KMP_DEBUG_ASSERT(gtid >= 0);\n    if (lck->tas.lk.poll - 1 ==\n        gtid) { /* __kmp_get_tas_lock_owner( lck ) == gtid */\n      return ++lck->tas.lk.depth_locked; /* same owner, depth increased */\n    }\n    retval = ((lck->tas.lk.poll == 0) &&\n              __kmp_atomic_compare_store_acq(&lck->tas.lk.poll, 0, gtid + 1));\n    if (retval) {\n      KMP_MB();\n      lck->tas.lk.depth_locked = 1;\n    }\n    return retval;\n  } else {\n    KMP_DEBUG_ASSERT(__kmp_test_nested_user_lock_with_checks_ != NULL);\n    return (*__kmp_test_nested_user_lock_with_checks_)(lck, gtid);\n  }\n}\n#else\nstatic inline int __kmp_test_nested_user_lock_with_checks(kmp_user_lock_p lck,\n                                                          kmp_int32 gtid) {\n  KMP_DEBUG_ASSERT(__kmp_test_nested_user_lock_with_checks_ != NULL);\n  return (*__kmp_test_nested_user_lock_with_checks_)(lck, gtid);\n}\n#endif\n\nextern int (*__kmp_release_nested_user_lock_with_checks_)(kmp_user_lock_p lck,\n                                                          kmp_int32 gtid);\n\nstatic inline int\n__kmp_release_nested_user_lock_with_checks(kmp_user_lock_p lck,\n                                           kmp_int32 gtid) {\n  KMP_DEBUG_ASSERT(__kmp_release_nested_user_lock_with_checks_ != NULL);\n  return (*__kmp_release_nested_user_lock_with_checks_)(lck, gtid);\n}\n\nextern void (*__kmp_init_nested_user_lock_with_checks_)(kmp_user_lock_p lck);\n\nstatic inline void\n__kmp_init_nested_user_lock_with_checks(kmp_user_lock_p lck) {\n  KMP_DEBUG_ASSERT(__kmp_init_nested_user_lock_with_checks_ != NULL);\n  (*__kmp_init_nested_user_lock_with_checks_)(lck);\n}\n\nextern void (*__kmp_destroy_nested_user_lock_with_checks_)(kmp_user_lock_p lck);\n\nstatic inline void\n__kmp_destroy_nested_user_lock_with_checks(kmp_user_lock_p lck) {\n  KMP_DEBUG_ASSERT(__kmp_destroy_nested_user_lock_with_checks_ != NULL);\n  (*__kmp_destroy_nested_user_lock_with_checks_)(lck);\n}\n\n// user lock functions which do not necessarily exist for all lock kinds.\n//\n// The \"set\" functions usually have wrapper routines that check for a NULL set\n// function pointer and call it if non-NULL.\n//\n// In some cases, it makes sense to have a \"get\" wrapper function check for a\n// NULL get function pointer and return NULL / invalid value / error code if\n// the function pointer is NULL.\n//\n// In other cases, the calling code really should differentiate between an\n// unimplemented function and one that is implemented but returning NULL /\n// invalid value.  If this is the case, no get function wrapper exists.\n\nextern int (*__kmp_is_user_lock_initialized_)(kmp_user_lock_p lck);\n\n// no set function; fields set during local allocation\n\nextern const ident_t *(*__kmp_get_user_lock_location_)(kmp_user_lock_p lck);\n\nstatic inline const ident_t *__kmp_get_user_lock_location(kmp_user_lock_p lck) {\n  if (__kmp_get_user_lock_location_ != NULL) {\n    return (*__kmp_get_user_lock_location_)(lck);\n  } else {\n    return NULL;\n  }\n}\n\nextern void (*__kmp_set_user_lock_location_)(kmp_user_lock_p lck,\n                                             const ident_t *loc);\n\nstatic inline void __kmp_set_user_lock_location(kmp_user_lock_p lck,\n                                                const ident_t *loc) {\n  if (__kmp_set_user_lock_location_ != NULL) {\n    (*__kmp_set_user_lock_location_)(lck, loc);\n  }\n}\n\nextern kmp_lock_flags_t (*__kmp_get_user_lock_flags_)(kmp_user_lock_p lck);\n\nextern void (*__kmp_set_user_lock_flags_)(kmp_user_lock_p lck,\n                                          kmp_lock_flags_t flags);\n\nstatic inline void __kmp_set_user_lock_flags(kmp_user_lock_p lck,\n                                             kmp_lock_flags_t flags) {\n  if (__kmp_set_user_lock_flags_ != NULL) {\n    (*__kmp_set_user_lock_flags_)(lck, flags);\n  }\n}\n\n// The function which sets up all of the vtbl pointers for kmp_user_lock_t.\nextern void __kmp_set_user_lock_vptrs(kmp_lock_kind_t user_lock_kind);\n\n// Macros for binding user lock functions.\n#define KMP_BIND_USER_LOCK_TEMPLATE(nest, kind, suffix)                        \\\n  {                                                                            \\\n    __kmp_acquire##nest##user_lock_with_checks_ = (int (*)(                    \\\n        kmp_user_lock_p, kmp_int32))__kmp_acquire##nest##kind##_##suffix;      \\\n    __kmp_release##nest##user_lock_with_checks_ = (int (*)(                    \\\n        kmp_user_lock_p, kmp_int32))__kmp_release##nest##kind##_##suffix;      \\\n    __kmp_test##nest##user_lock_with_checks_ = (int (*)(                       \\\n        kmp_user_lock_p, kmp_int32))__kmp_test##nest##kind##_##suffix;         \\\n    __kmp_init##nest##user_lock_with_checks_ =                                 \\\n        (void (*)(kmp_user_lock_p))__kmp_init##nest##kind##_##suffix;          \\\n    __kmp_destroy##nest##user_lock_with_checks_ =                              \\\n        (void (*)(kmp_user_lock_p))__kmp_destroy##nest##kind##_##suffix;       \\\n  }\n\n#define KMP_BIND_USER_LOCK(kind) KMP_BIND_USER_LOCK_TEMPLATE(_, kind, lock)\n#define KMP_BIND_USER_LOCK_WITH_CHECKS(kind)                                   \\\n  KMP_BIND_USER_LOCK_TEMPLATE(_, kind, lock_with_checks)\n#define KMP_BIND_NESTED_USER_LOCK(kind)                                        \\\n  KMP_BIND_USER_LOCK_TEMPLATE(_nested_, kind, lock)\n#define KMP_BIND_NESTED_USER_LOCK_WITH_CHECKS(kind)                            \\\n  KMP_BIND_USER_LOCK_TEMPLATE(_nested_, kind, lock_with_checks)\n\n// User lock table & lock allocation\n/* On 64-bit Linux* OS (and OS X*) GNU compiler allocates only 4 bytems memory\n   for lock variable, which is not enough to store a pointer, so we have to use\n   lock indexes instead of pointers and maintain lock table to map indexes to\n   pointers.\n\n\n   Note: The first element of the table is not a pointer to lock! It is a\n   pointer to previously allocated table (or NULL if it is the first table).\n\n   Usage:\n\n   if ( OMP_LOCK_T_SIZE < sizeof( <lock> ) ) { // or OMP_NEST_LOCK_T_SIZE\n     Lock table is fully utilized. User locks are indexes, so table is used on\n     user lock operation.\n     Note: it may be the case (lin_32) that we don't need to use a lock\n     table for regular locks, but do need the table for nested locks.\n   }\n   else {\n     Lock table initialized but not actually used.\n   }\n*/\n\nstruct kmp_lock_table {\n  kmp_lock_index_t used; // Number of used elements\n  kmp_lock_index_t allocated; // Number of allocated elements\n  kmp_user_lock_p *table; // Lock table.\n};\n\ntypedef struct kmp_lock_table kmp_lock_table_t;\n\nextern kmp_lock_table_t __kmp_user_lock_table;\nextern kmp_user_lock_p __kmp_lock_pool;\n\nstruct kmp_block_of_locks {\n  struct kmp_block_of_locks *next_block;\n  void *locks;\n};\n\ntypedef struct kmp_block_of_locks kmp_block_of_locks_t;\n\nextern kmp_block_of_locks_t *__kmp_lock_blocks;\nextern int __kmp_num_locks_in_block;\n\nextern kmp_user_lock_p __kmp_user_lock_allocate(void **user_lock,\n                                                kmp_int32 gtid,\n                                                kmp_lock_flags_t flags);\nextern void __kmp_user_lock_free(void **user_lock, kmp_int32 gtid,\n                                 kmp_user_lock_p lck);\nextern kmp_user_lock_p __kmp_lookup_user_lock(void **user_lock,\n                                              char const *func);\nextern void __kmp_cleanup_user_locks();\n\n#define KMP_CHECK_USER_LOCK_INIT()                                             \\\n  {                                                                            \\\n    if (!TCR_4(__kmp_init_user_locks)) {                                       \\\n      __kmp_acquire_bootstrap_lock(&__kmp_initz_lock);                         \\\n      if (!TCR_4(__kmp_init_user_locks)) {                                     \\\n        TCW_4(__kmp_init_user_locks, TRUE);                                    \\\n      }                                                                        \\\n      __kmp_release_bootstrap_lock(&__kmp_initz_lock);                         \\\n    }                                                                          \\\n  }\n\n#endif // KMP_USE_DYNAMIC_LOCK\n\n#undef KMP_PAD\n#undef KMP_GTID_DNE\n\n#if KMP_USE_DYNAMIC_LOCK\n// KMP_USE_DYNAMIC_LOCK enables dynamic dispatch of lock functions without\n// breaking the current compatibility. Essential functionality of this new code\n// is dynamic dispatch, but it also implements (or enables implementation of)\n// hinted user lock and critical section which will be part of OMP 4.5 soon.\n//\n// Lock type can be decided at creation time (i.e., lock initialization), and\n// subsequent lock function call on the created lock object requires type\n// extraction and call through jump table using the extracted type. This type\n// information is stored in two different ways depending on the size of the lock\n// object, and we differentiate lock types by this size requirement - direct and\n// indirect locks.\n//\n// Direct locks:\n// A direct lock object fits into the space created by the compiler for an\n// omp_lock_t object, and TAS/Futex lock falls into this category. We use low\n// one byte of the lock object as the storage for the lock type, and appropriate\n// bit operation is required to access the data meaningful to the lock\n// algorithms. Also, to differentiate direct lock from indirect lock, 1 is\n// written to LSB of the lock object. The newly introduced \"hle\" lock is also a\n// direct lock.\n//\n// Indirect locks:\n// An indirect lock object requires more space than the compiler-generated\n// space, and it should be allocated from heap. Depending on the size of the\n// compiler-generated space for the lock (i.e., size of omp_lock_t), this\n// omp_lock_t object stores either the address of the heap-allocated indirect\n// lock (void * fits in the object) or an index to the indirect lock table entry\n// that holds the address. Ticket/Queuing/DRDPA/Adaptive lock falls into this\n// category, and the newly introduced \"rtm\" lock is also an indirect lock which\n// was implemented on top of the Queuing lock. When the omp_lock_t object holds\n// an index (not lock address), 0 is written to LSB to differentiate the lock\n// from a direct lock, and the remaining part is the actual index to the\n// indirect lock table.\n\n#include <stdint.h> // for uintptr_t\n\n// Shortcuts\n#define KMP_USE_INLINED_TAS                                                    \\\n  (KMP_OS_LINUX && (KMP_ARCH_X86 || KMP_ARCH_X86_64 || KMP_ARCH_ARM)) && 1\n#define KMP_USE_INLINED_FUTEX KMP_USE_FUTEX && 0\n\n// List of lock definitions; all nested locks are indirect locks.\n// hle lock is xchg lock prefixed with XACQUIRE/XRELEASE.\n// All nested locks are indirect lock types.\n#if KMP_USE_TSX\n#if KMP_USE_FUTEX\n#define KMP_FOREACH_D_LOCK(m, a) m(tas, a) m(futex, a) m(hle, a) m(rtm_spin, a)\n#define KMP_FOREACH_I_LOCK(m, a)                                               \\\n  m(ticket, a) m(queuing, a) m(adaptive, a) m(drdpa, a) m(rtm_queuing, a)      \\\n      m(nested_tas, a) m(nested_futex, a) m(nested_ticket, a)                  \\\n          m(nested_queuing, a) m(nested_drdpa, a)\n#else\n#define KMP_FOREACH_D_LOCK(m, a) m(tas, a) m(hle, a) m(rtm_spin, a)\n#define KMP_FOREACH_I_LOCK(m, a)                                               \\\n  m(ticket, a) m(queuing, a) m(adaptive, a) m(drdpa, a) m(rtm_queuing, a)      \\\n      m(nested_tas, a) m(nested_ticket, a) m(nested_queuing, a)                \\\n          m(nested_drdpa, a)\n#endif // KMP_USE_FUTEX\n#define KMP_LAST_D_LOCK lockseq_rtm_spin\n#else\n#if KMP_USE_FUTEX\n#define KMP_FOREACH_D_LOCK(m, a) m(tas, a) m(futex, a)\n#define KMP_FOREACH_I_LOCK(m, a)                                               \\\n  m(ticket, a) m(queuing, a) m(drdpa, a) m(nested_tas, a) m(nested_futex, a)   \\\n      m(nested_ticket, a) m(nested_queuing, a) m(nested_drdpa, a)\n#define KMP_LAST_D_LOCK lockseq_futex\n#else\n#define KMP_FOREACH_D_LOCK(m, a) m(tas, a)\n#define KMP_FOREACH_I_LOCK(m, a)                                               \\\n  m(ticket, a) m(queuing, a) m(drdpa, a) m(nested_tas, a) m(nested_ticket, a)  \\\n      m(nested_queuing, a) m(nested_drdpa, a)\n#define KMP_LAST_D_LOCK lockseq_tas\n#endif // KMP_USE_FUTEX\n#endif // KMP_USE_TSX\n\n// Information used in dynamic dispatch\n#define KMP_LOCK_SHIFT                                                         \\\n  8 // number of low bits to be used as tag for direct locks\n#define KMP_FIRST_D_LOCK lockseq_tas\n#define KMP_FIRST_I_LOCK lockseq_ticket\n#define KMP_LAST_I_LOCK lockseq_nested_drdpa\n#define KMP_NUM_I_LOCKS                                                        \\\n  (locktag_nested_drdpa + 1) // number of indirect lock types\n\n// Base type for dynamic locks.\ntypedef kmp_uint32 kmp_dyna_lock_t;\n\n// Lock sequence that enumerates all lock kinds. Always make this enumeration\n// consistent with kmp_lockseq_t in the include directory.\ntypedef enum {\n  lockseq_indirect = 0,\n#define expand_seq(l, a) lockseq_##l,\n  KMP_FOREACH_D_LOCK(expand_seq, 0) KMP_FOREACH_I_LOCK(expand_seq, 0)\n#undef expand_seq\n} kmp_dyna_lockseq_t;\n\n// Enumerates indirect lock tags.\ntypedef enum {\n#define expand_tag(l, a) locktag_##l,\n  KMP_FOREACH_I_LOCK(expand_tag, 0)\n#undef expand_tag\n} kmp_indirect_locktag_t;\n\n// Utility macros that extract information from lock sequences.\n#define KMP_IS_D_LOCK(seq)                                                     \\\n  ((seq) >= KMP_FIRST_D_LOCK && (seq) <= KMP_LAST_D_LOCK)\n#define KMP_IS_I_LOCK(seq)                                                     \\\n  ((seq) >= KMP_FIRST_I_LOCK && (seq) <= KMP_LAST_I_LOCK)\n#define KMP_GET_I_TAG(seq) (kmp_indirect_locktag_t)((seq)-KMP_FIRST_I_LOCK)\n#define KMP_GET_D_TAG(seq) ((seq) << 1 | 1)\n\n// Enumerates direct lock tags starting from indirect tag.\ntypedef enum {\n#define expand_tag(l, a) locktag_##l = KMP_GET_D_TAG(lockseq_##l),\n  KMP_FOREACH_D_LOCK(expand_tag, 0)\n#undef expand_tag\n} kmp_direct_locktag_t;\n\n// Indirect lock type\ntypedef struct {\n  kmp_user_lock_p lock;\n  kmp_indirect_locktag_t type;\n} kmp_indirect_lock_t;\n\n// Function tables for direct locks. Set/unset/test differentiate functions\n// with/without consistency checking.\nextern void (*__kmp_direct_init[])(kmp_dyna_lock_t *, kmp_dyna_lockseq_t);\nextern void (**__kmp_direct_destroy)(kmp_dyna_lock_t *);\nextern int (**__kmp_direct_set)(kmp_dyna_lock_t *, kmp_int32);\nextern int (**__kmp_direct_unset)(kmp_dyna_lock_t *, kmp_int32);\nextern int (**__kmp_direct_test)(kmp_dyna_lock_t *, kmp_int32);\n\n// Function tables for indirect locks. Set/unset/test differentiate functions\n// with/without consistency checking.\nextern void (*__kmp_indirect_init[])(kmp_user_lock_p);\nextern void (**__kmp_indirect_destroy)(kmp_user_lock_p);\nextern int (**__kmp_indirect_set)(kmp_user_lock_p, kmp_int32);\nextern int (**__kmp_indirect_unset)(kmp_user_lock_p, kmp_int32);\nextern int (**__kmp_indirect_test)(kmp_user_lock_p, kmp_int32);\n\n// Extracts direct lock tag from a user lock pointer\n#define KMP_EXTRACT_D_TAG(l)                                                   \\\n  (*((kmp_dyna_lock_t *)(l)) & ((1 << KMP_LOCK_SHIFT) - 1) &                   \\\n   -(*((kmp_dyna_lock_t *)(l)) & 1))\n\n// Extracts indirect lock index from a user lock pointer\n#define KMP_EXTRACT_I_INDEX(l) (*(kmp_lock_index_t *)(l) >> 1)\n\n// Returns function pointer to the direct lock function with l (kmp_dyna_lock_t\n// *) and op (operation type).\n#define KMP_D_LOCK_FUNC(l, op) __kmp_direct_##op[KMP_EXTRACT_D_TAG(l)]\n\n// Returns function pointer to the indirect lock function with l\n// (kmp_indirect_lock_t *) and op (operation type).\n#define KMP_I_LOCK_FUNC(l, op)                                                 \\\n  __kmp_indirect_##op[((kmp_indirect_lock_t *)(l))->type]\n\n// Initializes a direct lock with the given lock pointer and lock sequence.\n#define KMP_INIT_D_LOCK(l, seq)                                                \\\n  __kmp_direct_init[KMP_GET_D_TAG(seq)]((kmp_dyna_lock_t *)l, seq)\n\n// Initializes an indirect lock with the given lock pointer and lock sequence.\n#define KMP_INIT_I_LOCK(l, seq)                                                \\\n  __kmp_direct_init[0]((kmp_dyna_lock_t *)(l), seq)\n\n// Returns \"free\" lock value for the given lock type.\n#define KMP_LOCK_FREE(type) (locktag_##type)\n\n// Returns \"busy\" lock value for the given lock teyp.\n#define KMP_LOCK_BUSY(v, type) ((v) << KMP_LOCK_SHIFT | locktag_##type)\n\n// Returns lock value after removing (shifting) lock tag.\n#define KMP_LOCK_STRIP(v) ((v) >> KMP_LOCK_SHIFT)\n\n// Initializes global states and data structures for managing dynamic user\n// locks.\nextern void __kmp_init_dynamic_user_locks();\n\n// Allocates and returns an indirect lock with the given indirect lock tag.\nextern kmp_indirect_lock_t *\n__kmp_allocate_indirect_lock(void **, kmp_int32, kmp_indirect_locktag_t);\n\n// Cleans up global states and data structures for managing dynamic user locks.\nextern void __kmp_cleanup_indirect_user_locks();\n\n// Default user lock sequence when not using hinted locks.\nextern kmp_dyna_lockseq_t __kmp_user_lock_seq;\n\n// Jump table for \"set lock location\", available only for indirect locks.\nextern void (*__kmp_indirect_set_location[KMP_NUM_I_LOCKS])(kmp_user_lock_p,\n                                                            const ident_t *);\n#define KMP_SET_I_LOCK_LOCATION(lck, loc)                                      \\\n  {                                                                            \\\n    if (__kmp_indirect_set_location[(lck)->type] != NULL)                      \\\n      __kmp_indirect_set_location[(lck)->type]((lck)->lock, loc);              \\\n  }\n\n// Jump table for \"set lock flags\", available only for indirect locks.\nextern void (*__kmp_indirect_set_flags[KMP_NUM_I_LOCKS])(kmp_user_lock_p,\n                                                         kmp_lock_flags_t);\n#define KMP_SET_I_LOCK_FLAGS(lck, flag)                                        \\\n  {                                                                            \\\n    if (__kmp_indirect_set_flags[(lck)->type] != NULL)                         \\\n      __kmp_indirect_set_flags[(lck)->type]((lck)->lock, flag);                \\\n  }\n\n// Jump table for \"get lock location\", available only for indirect locks.\nextern const ident_t *(*__kmp_indirect_get_location[KMP_NUM_I_LOCKS])(\n    kmp_user_lock_p);\n#define KMP_GET_I_LOCK_LOCATION(lck)                                           \\\n  (__kmp_indirect_get_location[(lck)->type] != NULL                            \\\n       ? __kmp_indirect_get_location[(lck)->type]((lck)->lock)                 \\\n       : NULL)\n\n// Jump table for \"get lock flags\", available only for indirect locks.\nextern kmp_lock_flags_t (*__kmp_indirect_get_flags[KMP_NUM_I_LOCKS])(\n    kmp_user_lock_p);\n#define KMP_GET_I_LOCK_FLAGS(lck)                                              \\\n  (__kmp_indirect_get_flags[(lck)->type] != NULL                               \\\n       ? __kmp_indirect_get_flags[(lck)->type]((lck)->lock)                    \\\n       : NULL)\n\n#define KMP_I_LOCK_CHUNK                                                       \\\n  1024 // number of kmp_indirect_lock_t objects to be allocated together\n\n// Lock table for indirect locks.\ntypedef struct kmp_indirect_lock_table {\n  kmp_indirect_lock_t **table; // blocks of indirect locks allocated\n  kmp_lock_index_t size; // size of the indirect lock table\n  kmp_lock_index_t next; // index to the next lock to be allocated\n} kmp_indirect_lock_table_t;\n\nextern kmp_indirect_lock_table_t __kmp_i_lock_table;\n\n// Returns the indirect lock associated with the given index.\n#define KMP_GET_I_LOCK(index)                                                  \\\n  (*(__kmp_i_lock_table.table + (index) / KMP_I_LOCK_CHUNK) +                  \\\n   (index) % KMP_I_LOCK_CHUNK)\n\n// Number of locks in a lock block, which is fixed to \"1\" now.\n// TODO: No lock block implementation now. If we do support, we need to manage\n// lock block data structure for each indirect lock type.\nextern int __kmp_num_locks_in_block;\n\n// Fast lock table lookup without consistency checking\n#define KMP_LOOKUP_I_LOCK(l)                                                   \\\n  ((OMP_LOCK_T_SIZE < sizeof(void *)) ? KMP_GET_I_LOCK(KMP_EXTRACT_I_INDEX(l)) \\\n                                      : *((kmp_indirect_lock_t **)(l)))\n\n// Used once in kmp_error.cpp\nextern kmp_int32 __kmp_get_user_lock_owner(kmp_user_lock_p, kmp_uint32);\n\n#else // KMP_USE_DYNAMIC_LOCK\n\n#define KMP_LOCK_BUSY(v, type) (v)\n#define KMP_LOCK_FREE(type) 0\n#define KMP_LOCK_STRIP(v) (v)\n\n#endif // KMP_USE_DYNAMIC_LOCK\n\n// data structure for using backoff within spin locks.\ntypedef struct {\n  kmp_uint32 step; // current step\n  kmp_uint32 max_backoff; // upper bound of outer delay loop\n  kmp_uint32 min_tick; // size of inner delay loop in ticks (machine-dependent)\n} kmp_backoff_t;\n\n// Runtime's default backoff parameters\nextern kmp_backoff_t __kmp_spin_backoff_params;\n\n// Backoff function\nextern void __kmp_spin_backoff(kmp_backoff_t *);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n\n#endif /* KMP_LOCK_H */\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_os.h", "content": "/*\n * kmp_os.h -- KPTS runtime header file.\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_OS_H\n#define KMP_OS_H\n\n#include \"kmp_config.h\"\n#include <atomic>\n#include <stdarg.h>\n#include <stdlib.h>\n\n#define KMP_FTN_PLAIN 1\n#define KMP_FTN_APPEND 2\n#define KMP_FTN_UPPER 3\n/*\n#define KMP_FTN_PREPEND 4\n#define KMP_FTN_UAPPEND 5\n*/\n\n#define KMP_PTR_SKIP (sizeof(void *))\n\n/* -------------------------- Compiler variations ------------------------ */\n\n#define KMP_OFF 0\n#define KMP_ON 1\n\n#define KMP_MEM_CONS_VOLATILE 0\n#define KMP_MEM_CONS_FENCE 1\n\n#ifndef KMP_MEM_CONS_MODEL\n#define KMP_MEM_CONS_MODEL KMP_MEM_CONS_VOLATILE\n#endif\n\n#ifndef __has_cpp_attribute\n#define __has_cpp_attribute(x) 0\n#endif\n\n#ifndef __has_attribute\n#define __has_attribute(x) 0\n#endif\n\n/* ------------------------- Compiler recognition ---------------------- */\n#define KMP_COMPILER_ICC 0\n#define KMP_COMPILER_GCC 0\n#define KMP_COMPILER_CLANG 0\n#define KMP_COMPILER_MSVC 0\n\n#if defined(__INTEL_COMPILER)\n#undef KMP_COMPILER_ICC\n#define KMP_COMPILER_ICC 1\n#elif defined(__clang__)\n#undef KMP_COMPILER_CLANG\n#define KMP_COMPILER_CLANG 1\n#elif defined(__GNUC__)\n#undef KMP_COMPILER_GCC\n#define KMP_COMPILER_GCC 1\n#elif defined(_MSC_VER)\n#undef KMP_COMPILER_MSVC\n#define KMP_COMPILER_MSVC 1\n#else\n#error Unknown compiler\n#endif\n\n#if (KMP_OS_LINUX || KMP_OS_WINDOWS || KMP_OS_FREEBSD)\n#define KMP_AFFINITY_SUPPORTED 1\n#if KMP_OS_WINDOWS && KMP_ARCH_X86_64\n#define KMP_GROUP_AFFINITY 1\n#else\n#define KMP_GROUP_AFFINITY 0\n#endif\n#else\n#define KMP_AFFINITY_SUPPORTED 0\n#define KMP_GROUP_AFFINITY 0\n#endif\n\n/* Check for quad-precision extension. */\n#define KMP_HAVE_QUAD 0\n#if KMP_ARCH_X86 || KMP_ARCH_X86_64\n#if KMP_COMPILER_ICC\n/* _Quad is already defined for icc */\n#undef KMP_HAVE_QUAD\n#define KMP_HAVE_QUAD 1\n#elif KMP_COMPILER_CLANG\n/* Clang doesn't support a software-implemented\n   128-bit extended precision type yet */\ntypedef long double _Quad;\n#elif KMP_COMPILER_GCC\n/* GCC on NetBSD lacks __multc3/__divtc3 builtins needed for quad */\n#if !KMP_OS_NETBSD\ntypedef __float128 _Quad;\n#undef KMP_HAVE_QUAD\n#define KMP_HAVE_QUAD 1\n#endif\n#elif KMP_COMPILER_MSVC\ntypedef long double _Quad;\n#endif\n#else\n#if __LDBL_MAX_EXP__ >= 16384 && KMP_COMPILER_GCC\ntypedef long double _Quad;\n#undef KMP_HAVE_QUAD\n#define KMP_HAVE_QUAD 1\n#endif\n#endif /* KMP_ARCH_X86 || KMP_ARCH_X86_64 */\n\n#define KMP_USE_X87CONTROL 0\n#if KMP_OS_WINDOWS\n#define KMP_END_OF_LINE \"\\r\\n\"\ntypedef char kmp_int8;\ntypedef unsigned char kmp_uint8;\ntypedef short kmp_int16;\ntypedef unsigned short kmp_uint16;\ntypedef int kmp_int32;\ntypedef unsigned int kmp_uint32;\n#define KMP_INT32_SPEC \"d\"\n#define KMP_UINT32_SPEC \"u\"\n#ifndef KMP_STRUCT64\ntypedef __int64 kmp_int64;\ntypedef unsigned __int64 kmp_uint64;\n#define KMP_INT64_SPEC \"I64d\"\n#define KMP_UINT64_SPEC \"I64u\"\n#else\nstruct kmp_struct64 {\n  kmp_int32 a, b;\n};\ntypedef struct kmp_struct64 kmp_int64;\ntypedef struct kmp_struct64 kmp_uint64;\n/* Not sure what to use for KMP_[U]INT64_SPEC here */\n#endif\n#if KMP_ARCH_X86 && KMP_MSVC_COMPAT\n#undef KMP_USE_X87CONTROL\n#define KMP_USE_X87CONTROL 1\n#endif\n#if KMP_ARCH_X86_64\n#define KMP_INTPTR 1\ntypedef __int64 kmp_intptr_t;\ntypedef unsigned __int64 kmp_uintptr_t;\n#define KMP_INTPTR_SPEC \"I64d\"\n#define KMP_UINTPTR_SPEC \"I64u\"\n#endif\n#endif /* KMP_OS_WINDOWS */\n\n#if KMP_OS_UNIX\n#define KMP_END_OF_LINE \"\\n\"\ntypedef char kmp_int8;\ntypedef unsigned char kmp_uint8;\ntypedef short kmp_int16;\ntypedef unsigned short kmp_uint16;\ntypedef int kmp_int32;\ntypedef unsigned int kmp_uint32;\ntypedef long long kmp_int64;\ntypedef unsigned long long kmp_uint64;\n#define KMP_INT32_SPEC \"d\"\n#define KMP_UINT32_SPEC \"u\"\n#define KMP_INT64_SPEC \"lld\"\n#define KMP_UINT64_SPEC \"llu\"\n#endif /* KMP_OS_UNIX */\n\n#if KMP_ARCH_X86 || KMP_ARCH_ARM || KMP_ARCH_MIPS\n#define KMP_SIZE_T_SPEC KMP_UINT32_SPEC\n#elif KMP_ARCH_X86_64 || KMP_ARCH_PPC64 || KMP_ARCH_AARCH64 ||                 \\\n    KMP_ARCH_MIPS64 || KMP_ARCH_RISCV64\n#define KMP_SIZE_T_SPEC KMP_UINT64_SPEC\n#else\n#error \"Can't determine size_t printf format specifier.\"\n#endif\n\n#if KMP_ARCH_X86\n#define KMP_SIZE_T_MAX (0xFFFFFFFF)\n#else\n#define KMP_SIZE_T_MAX (0xFFFFFFFFFFFFFFFF)\n#endif\n\ntypedef size_t kmp_size_t;\ntypedef float kmp_real32;\ntypedef double kmp_real64;\n\n#ifndef KMP_INTPTR\n#define KMP_INTPTR 1\ntypedef long kmp_intptr_t;\ntypedef unsigned long kmp_uintptr_t;\n#define KMP_INTPTR_SPEC \"ld\"\n#define KMP_UINTPTR_SPEC \"lu\"\n#endif\n\n#ifdef BUILD_I8\ntypedef kmp_int64 kmp_int;\ntypedef kmp_uint64 kmp_uint;\n#else\ntypedef kmp_int32 kmp_int;\ntypedef kmp_uint32 kmp_uint;\n#endif /* BUILD_I8 */\n#define KMP_INT_MAX ((kmp_int32)0x7FFFFFFF)\n#define KMP_INT_MIN ((kmp_int32)0x80000000)\n\n// stdarg handling\n#if (KMP_ARCH_ARM || KMP_ARCH_X86_64 || KMP_ARCH_AARCH64) &&                   \\\n    (KMP_OS_FREEBSD || KMP_OS_LINUX)\ntypedef va_list *kmp_va_list;\n#define kmp_va_deref(ap) (*(ap))\n#define kmp_va_addr_of(ap) (&(ap))\n#else\ntypedef va_list kmp_va_list;\n#define kmp_va_deref(ap) (ap)\n#define kmp_va_addr_of(ap) (ap)\n#endif\n\n#ifdef __cplusplus\n// macros to cast out qualifiers and to re-interpret types\n#define CCAST(type, var) const_cast<type>(var)\n#define RCAST(type, var) reinterpret_cast<type>(var)\n//-------------------------------------------------------------------------\n// template for debug prints specification ( d, u, lld, llu ), and to obtain\n// signed/unsigned flavors of a type\ntemplate <typename T> struct traits_t {};\n// int\ntemplate <> struct traits_t<signed int> {\n  typedef signed int signed_t;\n  typedef unsigned int unsigned_t;\n  typedef double floating_t;\n  static char const *spec;\n  static const signed_t max_value = 0x7fffffff;\n  static const signed_t min_value = 0x80000000;\n  static const int type_size = sizeof(signed_t);\n};\n// unsigned int\ntemplate <> struct traits_t<unsigned int> {\n  typedef signed int signed_t;\n  typedef unsigned int unsigned_t;\n  typedef double floating_t;\n  static char const *spec;\n  static const unsigned_t max_value = 0xffffffff;\n  static const unsigned_t min_value = 0x00000000;\n  static const int type_size = sizeof(unsigned_t);\n};\n// long\ntemplate <> struct traits_t<signed long> {\n  typedef signed long signed_t;\n  typedef unsigned long unsigned_t;\n  typedef long double floating_t;\n  static char const *spec;\n  static const int type_size = sizeof(signed_t);\n};\n// long long\ntemplate <> struct traits_t<signed long long> {\n  typedef signed long long signed_t;\n  typedef unsigned long long unsigned_t;\n  typedef long double floating_t;\n  static char const *spec;\n  static const signed_t max_value = 0x7fffffffffffffffLL;\n  static const signed_t min_value = 0x8000000000000000LL;\n  static const int type_size = sizeof(signed_t);\n};\n// unsigned long long\ntemplate <> struct traits_t<unsigned long long> {\n  typedef signed long long signed_t;\n  typedef unsigned long long unsigned_t;\n  typedef long double floating_t;\n  static char const *spec;\n  static const unsigned_t max_value = 0xffffffffffffffffLL;\n  static const unsigned_t min_value = 0x0000000000000000LL;\n  static const int type_size = sizeof(unsigned_t);\n};\n//-------------------------------------------------------------------------\n#else\n#define CCAST(type, var) (type)(var)\n#define RCAST(type, var) (type)(var)\n#endif // __cplusplus\n\n#define KMP_EXPORT extern /* export declaration in guide libraries */\n\n#if __GNUC__ >= 4 && !defined(__MINGW32__)\n#define __forceinline __inline\n#endif\n\n/* Check if the OS/arch can support user-level mwait */\n// All mwait code tests for UMWAIT first, so it should only fall back to ring3\n// MWAIT for KNL.\n#define KMP_HAVE_MWAIT                                                         \\\n  ((KMP_ARCH_X86 || KMP_ARCH_X86_64) && (KMP_OS_LINUX || KMP_OS_WINDOWS) &&    \\\n   !KMP_MIC2)\n#define KMP_HAVE_UMWAIT                                                        \\\n  ((KMP_ARCH_X86 || KMP_ARCH_X86_64) && (KMP_OS_LINUX || KMP_OS_WINDOWS) &&    \\\n   !KMP_MIC)\n\n#if KMP_OS_WINDOWS\n#include <windows.h>\n\nstatic inline int KMP_GET_PAGE_SIZE(void) {\n  SYSTEM_INFO si;\n  GetSystemInfo(&si);\n  return si.dwPageSize;\n}\n#else\n#define KMP_GET_PAGE_SIZE() getpagesize()\n#endif\n\n#define PAGE_ALIGNED(_addr)                                                    \\\n  (!((size_t)_addr & (size_t)(KMP_GET_PAGE_SIZE() - 1)))\n#define ALIGN_TO_PAGE(x)                                                       \\\n  (void *)(((size_t)(x)) & ~((size_t)(KMP_GET_PAGE_SIZE() - 1)))\n\n/* ---------- Support for cache alignment, padding, etc. ----------------*/\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n#define INTERNODE_CACHE_LINE 4096 /* for multi-node systems */\n\n/* Define the default size of the cache line */\n#ifndef CACHE_LINE\n#define CACHE_LINE 128 /* cache line size in bytes */\n#else\n#if (CACHE_LINE < 64) && !defined(KMP_OS_DARWIN)\n// 2006-02-13: This produces too many warnings on OS X*. Disable for now\n#warning CACHE_LINE is too small.\n#endif\n#endif /* CACHE_LINE */\n\n#define KMP_CACHE_PREFETCH(ADDR) /* nothing */\n\n// Define attribute that indicates that the fall through from the previous\n// case label is intentional and should not be diagnosed by a compiler\n//   Code from libcxx/include/__config\n// Use a function like macro to imply that it must be followed by a semicolon\n#if __cplusplus > 201402L && __has_cpp_attribute(fallthrough)\n#define KMP_FALLTHROUGH() [[fallthrough]]\n#elif __has_cpp_attribute(clang::fallthrough)\n#define KMP_FALLTHROUGH() [[clang::fallthrough]]\n#elif __has_attribute(fallthrough) || __GNUC__ >= 7\n#define KMP_FALLTHROUGH() __attribute__((__fallthrough__))\n#else\n#define KMP_FALLTHROUGH() ((void)0)\n#endif\n\n#if KMP_HAVE_ATTRIBUTE_WAITPKG\n#define KMP_ATTRIBUTE_TARGET_WAITPKG __attribute__((target(\"waitpkg\")))\n#else\n#define KMP_ATTRIBUTE_TARGET_WAITPKG /* Nothing */\n#endif\n\n#if KMP_HAVE_ATTRIBUTE_RTM\n#define KMP_ATTRIBUTE_TARGET_RTM __attribute__((target(\"rtm\")))\n#else\n#define KMP_ATTRIBUTE_TARGET_RTM /* Nothing */\n#endif\n\n// Define attribute that indicates a function does not return\n#if __cplusplus >= 201103L\n#define KMP_NORETURN [[noreturn]]\n#elif KMP_OS_WINDOWS\n#define KMP_NORETURN __declspec(noreturn)\n#else\n#define KMP_NORETURN __attribute__((noreturn))\n#endif\n\n#if KMP_OS_WINDOWS && KMP_MSVC_COMPAT\n#define KMP_ALIGN(bytes) __declspec(align(bytes))\n#define KMP_THREAD_LOCAL __declspec(thread)\n#define KMP_ALIAS /* Nothing */\n#else\n#define KMP_ALIGN(bytes) __attribute__((aligned(bytes)))\n#define KMP_THREAD_LOCAL __thread\n#define KMP_ALIAS(alias_of) __attribute__((alias(alias_of)))\n#endif\n\n#if KMP_HAVE_WEAK_ATTRIBUTE && !KMP_DYNAMIC_LIB\n#define KMP_WEAK_ATTRIBUTE_EXTERNAL __attribute__((weak))\n#else\n#define KMP_WEAK_ATTRIBUTE_EXTERNAL /* Nothing */\n#endif\n\n#if KMP_HAVE_WEAK_ATTRIBUTE\n#define KMP_WEAK_ATTRIBUTE_INTERNAL __attribute__((weak))\n#else\n#define KMP_WEAK_ATTRIBUTE_INTERNAL /* Nothing */\n#endif\n\n// Define KMP_VERSION_SYMBOL and KMP_EXPAND_NAME\n#ifndef KMP_STR\n#define KMP_STR(x) _KMP_STR(x)\n#define _KMP_STR(x) #x\n#endif\n\n#ifdef KMP_USE_VERSION_SYMBOLS\n// If using versioned symbols, KMP_EXPAND_NAME prepends\n// __kmp_api_ to the real API name\n#define KMP_EXPAND_NAME(api_name) _KMP_EXPAND_NAME(api_name)\n#define _KMP_EXPAND_NAME(api_name) __kmp_api_##api_name\n#define KMP_VERSION_SYMBOL(api_name, ver_num, ver_str)                         \\\n  _KMP_VERSION_SYMBOL(api_name, ver_num, ver_str, \"VERSION\")\n#define _KMP_VERSION_SYMBOL(api_name, ver_num, ver_str, default_ver)            \\\n  __typeof__(__kmp_api_##api_name) __kmp_api_##api_name##_##ver_num##_alias     \\\n      __attribute__((alias(KMP_STR(__kmp_api_##api_name))));                    \\\n  __asm__(                                                                      \\\n      \".symver \" KMP_STR(__kmp_api_##api_name##_##ver_num##_alias) \",\" KMP_STR( \\\n          api_name) \"@\" ver_str \"\\n\\t\");                                        \\\n  __asm__(\".symver \" KMP_STR(__kmp_api_##api_name) \",\" KMP_STR(                 \\\n      api_name) \"@@\" default_ver \"\\n\\t\")\n#else // KMP_USE_VERSION_SYMBOLS\n#define KMP_EXPAND_NAME(api_name) api_name\n#define KMP_VERSION_SYMBOL(api_name, ver_num, ver_str) /* Nothing */\n#endif // KMP_USE_VERSION_SYMBOLS\n\n/* Temporary note: if performance testing of this passes, we can remove\n   all references to KMP_DO_ALIGN and replace with KMP_ALIGN.  */\n#define KMP_DO_ALIGN(bytes) KMP_ALIGN(bytes)\n#define KMP_ALIGN_CACHE KMP_ALIGN(CACHE_LINE)\n#define KMP_ALIGN_CACHE_INTERNODE KMP_ALIGN(INTERNODE_CACHE_LINE)\n\n/* General purpose fence types for memory operations */\nenum kmp_mem_fence_type {\n  kmp_no_fence, /* No memory fence */\n  kmp_acquire_fence, /* Acquire (read) memory fence */\n  kmp_release_fence, /* Release (write) memory fence */\n  kmp_full_fence /* Full (read+write) memory fence */\n};\n\n// Synchronization primitives\n\n#if KMP_ASM_INTRINS && KMP_OS_WINDOWS\n\n#if KMP_MSVC_COMPAT && !KMP_COMPILER_CLANG\n#pragma intrinsic(InterlockedExchangeAdd)\n#pragma intrinsic(InterlockedCompareExchange)\n#pragma intrinsic(InterlockedExchange)\n#pragma intrinsic(InterlockedExchange64)\n#endif\n\n// Using InterlockedIncrement / InterlockedDecrement causes a library loading\n// ordering problem, so we use InterlockedExchangeAdd instead.\n#define KMP_TEST_THEN_INC32(p) InterlockedExchangeAdd((volatile long *)(p), 1)\n#define KMP_TEST_THEN_INC_ACQ32(p)                                             \\\n  InterlockedExchangeAdd((volatile long *)(p), 1)\n#define KMP_TEST_THEN_ADD4_32(p) InterlockedExchangeAdd((volatile long *)(p), 4)\n#define KMP_TEST_THEN_ADD4_ACQ32(p)                                            \\\n  InterlockedExchangeAdd((volatile long *)(p), 4)\n#define KMP_TEST_THEN_DEC32(p) InterlockedExchangeAdd((volatile long *)(p), -1)\n#define KMP_TEST_THEN_DEC_ACQ32(p)                                             \\\n  InterlockedExchangeAdd((volatile long *)(p), -1)\n#define KMP_TEST_THEN_ADD32(p, v)                                              \\\n  InterlockedExchangeAdd((volatile long *)(p), (v))\n\n#define KMP_COMPARE_AND_STORE_RET32(p, cv, sv)                                 \\\n  InterlockedCompareExchange((volatile long *)(p), (long)(sv), (long)(cv))\n\n#define KMP_XCHG_FIXED32(p, v)                                                 \\\n  InterlockedExchange((volatile long *)(p), (long)(v))\n#define KMP_XCHG_FIXED64(p, v)                                                 \\\n  InterlockedExchange64((volatile kmp_int64 *)(p), (kmp_int64)(v))\n\ninline kmp_real32 KMP_XCHG_REAL32(volatile kmp_real32 *p, kmp_real32 v) {\n  kmp_int32 tmp = InterlockedExchange((volatile long *)p, *(long *)&v);\n  return *(kmp_real32 *)&tmp;\n}\n\n// Routines that we still need to implement in assembly.\nextern kmp_int8 __kmp_test_then_add8(volatile kmp_int8 *p, kmp_int8 v);\nextern kmp_int8 __kmp_test_then_or8(volatile kmp_int8 *p, kmp_int8 v);\nextern kmp_int8 __kmp_test_then_and8(volatile kmp_int8 *p, kmp_int8 v);\nextern kmp_int32 __kmp_test_then_add32(volatile kmp_int32 *p, kmp_int32 v);\nextern kmp_uint32 __kmp_test_then_or32(volatile kmp_uint32 *p, kmp_uint32 v);\nextern kmp_uint32 __kmp_test_then_and32(volatile kmp_uint32 *p, kmp_uint32 v);\nextern kmp_int64 __kmp_test_then_add64(volatile kmp_int64 *p, kmp_int64 v);\nextern kmp_uint64 __kmp_test_then_or64(volatile kmp_uint64 *p, kmp_uint64 v);\nextern kmp_uint64 __kmp_test_then_and64(volatile kmp_uint64 *p, kmp_uint64 v);\n\nextern kmp_int8 __kmp_compare_and_store8(volatile kmp_int8 *p, kmp_int8 cv,\n                                         kmp_int8 sv);\nextern kmp_int16 __kmp_compare_and_store16(volatile kmp_int16 *p, kmp_int16 cv,\n                                           kmp_int16 sv);\nextern kmp_int32 __kmp_compare_and_store32(volatile kmp_int32 *p, kmp_int32 cv,\n                                           kmp_int32 sv);\nextern kmp_int32 __kmp_compare_and_store64(volatile kmp_int64 *p, kmp_int64 cv,\n                                           kmp_int64 sv);\nextern kmp_int8 __kmp_compare_and_store_ret8(volatile kmp_int8 *p, kmp_int8 cv,\n                                             kmp_int8 sv);\nextern kmp_int16 __kmp_compare_and_store_ret16(volatile kmp_int16 *p,\n                                               kmp_int16 cv, kmp_int16 sv);\nextern kmp_int32 __kmp_compare_and_store_ret32(volatile kmp_int32 *p,\n                                               kmp_int32 cv, kmp_int32 sv);\nextern kmp_int64 __kmp_compare_and_store_ret64(volatile kmp_int64 *p,\n                                               kmp_int64 cv, kmp_int64 sv);\n\nextern kmp_int8 __kmp_xchg_fixed8(volatile kmp_int8 *p, kmp_int8 v);\nextern kmp_int16 __kmp_xchg_fixed16(volatile kmp_int16 *p, kmp_int16 v);\nextern kmp_int32 __kmp_xchg_fixed32(volatile kmp_int32 *p, kmp_int32 v);\nextern kmp_int64 __kmp_xchg_fixed64(volatile kmp_int64 *p, kmp_int64 v);\nextern kmp_real32 __kmp_xchg_real32(volatile kmp_real32 *p, kmp_real32 v);\nextern kmp_real64 __kmp_xchg_real64(volatile kmp_real64 *p, kmp_real64 v);\n\n//#define KMP_TEST_THEN_INC32(p) __kmp_test_then_add32((p), 1)\n//#define KMP_TEST_THEN_INC_ACQ32(p) __kmp_test_then_add32((p), 1)\n#define KMP_TEST_THEN_INC64(p) __kmp_test_then_add64((p), 1LL)\n#define KMP_TEST_THEN_INC_ACQ64(p) __kmp_test_then_add64((p), 1LL)\n//#define KMP_TEST_THEN_ADD4_32(p) __kmp_test_then_add32((p), 4)\n//#define KMP_TEST_THEN_ADD4_ACQ32(p) __kmp_test_then_add32((p), 4)\n#define KMP_TEST_THEN_ADD4_64(p) __kmp_test_then_add64((p), 4LL)\n#define KMP_TEST_THEN_ADD4_ACQ64(p) __kmp_test_then_add64((p), 4LL)\n//#define KMP_TEST_THEN_DEC32(p) __kmp_test_then_add32((p), -1)\n//#define KMP_TEST_THEN_DEC_ACQ32(p) __kmp_test_then_add32((p), -1)\n#define KMP_TEST_THEN_DEC64(p) __kmp_test_then_add64((p), -1LL)\n#define KMP_TEST_THEN_DEC_ACQ64(p) __kmp_test_then_add64((p), -1LL)\n//#define KMP_TEST_THEN_ADD32(p, v) __kmp_test_then_add32((p), (v))\n#define KMP_TEST_THEN_ADD8(p, v) __kmp_test_then_add8((p), (v))\n#define KMP_TEST_THEN_ADD64(p, v) __kmp_test_then_add64((p), (v))\n\n#define KMP_TEST_THEN_OR8(p, v) __kmp_test_then_or8((p), (v))\n#define KMP_TEST_THEN_AND8(p, v) __kmp_test_then_and8((p), (v))\n#define KMP_TEST_THEN_OR32(p, v) __kmp_test_then_or32((p), (v))\n#define KMP_TEST_THEN_AND32(p, v) __kmp_test_then_and32((p), (v))\n#define KMP_TEST_THEN_OR64(p, v) __kmp_test_then_or64((p), (v))\n#define KMP_TEST_THEN_AND64(p, v) __kmp_test_then_and64((p), (v))\n\n#define KMP_COMPARE_AND_STORE_ACQ8(p, cv, sv)                                  \\\n  __kmp_compare_and_store8((p), (cv), (sv))\n#define KMP_COMPARE_AND_STORE_REL8(p, cv, sv)                                  \\\n  __kmp_compare_and_store8((p), (cv), (sv))\n#define KMP_COMPARE_AND_STORE_ACQ16(p, cv, sv)                                 \\\n  __kmp_compare_and_store16((p), (cv), (sv))\n#define KMP_COMPARE_AND_STORE_REL16(p, cv, sv)                                 \\\n  __kmp_compare_and_store16((p), (cv), (sv))\n#define KMP_COMPARE_AND_STORE_ACQ32(p, cv, sv)                                 \\\n  __kmp_compare_and_store32((volatile kmp_int32 *)(p), (kmp_int32)(cv),        \\\n                            (kmp_int32)(sv))\n#define KMP_COMPARE_AND_STORE_REL32(p, cv, sv)                                 \\\n  __kmp_compare_and_store32((volatile kmp_int32 *)(p), (kmp_int32)(cv),        \\\n                            (kmp_int32)(sv))\n#define KMP_COMPARE_AND_STORE_ACQ64(p, cv, sv)                                 \\\n  __kmp_compare_and_store64((volatile kmp_int64 *)(p), (kmp_int64)(cv),        \\\n                            (kmp_int64)(sv))\n#define KMP_COMPARE_AND_STORE_REL64(p, cv, sv)                                 \\\n  __kmp_compare_and_store64((volatile kmp_int64 *)(p), (kmp_int64)(cv),        \\\n                            (kmp_int64)(sv))\n\n#if KMP_ARCH_X86\n#define KMP_COMPARE_AND_STORE_PTR(p, cv, sv)                                   \\\n  __kmp_compare_and_store32((volatile kmp_int32 *)(p), (kmp_int32)(cv),        \\\n                            (kmp_int32)(sv))\n#else /* 64 bit pointers */\n#define KMP_COMPARE_AND_STORE_PTR(p, cv, sv)                                   \\\n  __kmp_compare_and_store64((volatile kmp_int64 *)(p), (kmp_int64)(cv),        \\\n                            (kmp_int64)(sv))\n#endif /* KMP_ARCH_X86 */\n\n#define KMP_COMPARE_AND_STORE_RET8(p, cv, sv)                                  \\\n  __kmp_compare_and_store_ret8((p), (cv), (sv))\n#define KMP_COMPARE_AND_STORE_RET16(p, cv, sv)                                 \\\n  __kmp_compare_and_store_ret16((p), (cv), (sv))\n#define KMP_COMPARE_AND_STORE_RET64(p, cv, sv)                                 \\\n  __kmp_compare_and_store_ret64((volatile kmp_int64 *)(p), (kmp_int64)(cv),    \\\n                                (kmp_int64)(sv))\n\n#define KMP_XCHG_FIXED8(p, v)                                                  \\\n  __kmp_xchg_fixed8((volatile kmp_int8 *)(p), (kmp_int8)(v));\n#define KMP_XCHG_FIXED16(p, v) __kmp_xchg_fixed16((p), (v));\n//#define KMP_XCHG_FIXED32(p, v) __kmp_xchg_fixed32((p), (v));\n//#define KMP_XCHG_FIXED64(p, v) __kmp_xchg_fixed64((p), (v));\n//#define KMP_XCHG_REAL32(p, v) __kmp_xchg_real32((p), (v));\n#define KMP_XCHG_REAL64(p, v) __kmp_xchg_real64((p), (v));\n\n#elif (KMP_ASM_INTRINS && KMP_OS_UNIX) || !(KMP_ARCH_X86 || KMP_ARCH_X86_64)\n\n/* cast p to correct type so that proper intrinsic will be used */\n#define KMP_TEST_THEN_INC32(p)                                                 \\\n  __sync_fetch_and_add((volatile kmp_int32 *)(p), 1)\n#define KMP_TEST_THEN_INC_ACQ32(p)                                             \\\n  __sync_fetch_and_add((volatile kmp_int32 *)(p), 1)\n#if KMP_ARCH_MIPS\n#define KMP_TEST_THEN_INC64(p)                                                 \\\n  __atomic_fetch_add((volatile kmp_int64 *)(p), 1LL, __ATOMIC_SEQ_CST)\n#define KMP_TEST_THEN_INC_ACQ64(p)                                             \\\n  __atomic_fetch_add((volatile kmp_int64 *)(p), 1LL, __ATOMIC_SEQ_CST)\n#else\n#define KMP_TEST_THEN_INC64(p)                                                 \\\n  __sync_fetch_and_add((volatile kmp_int64 *)(p), 1LL)\n#define KMP_TEST_THEN_INC_ACQ64(p)                                             \\\n  __sync_fetch_and_add((volatile kmp_int64 *)(p), 1LL)\n#endif\n#define KMP_TEST_THEN_ADD4_32(p)                                               \\\n  __sync_fetch_and_add((volatile kmp_int32 *)(p), 4)\n#define KMP_TEST_THEN_ADD4_ACQ32(p)                                            \\\n  __sync_fetch_and_add((volatile kmp_int32 *)(p), 4)\n#if KMP_ARCH_MIPS\n#define KMP_TEST_THEN_ADD4_64(p)                                               \\\n  __atomic_fetch_add((volatile kmp_int64 *)(p), 4LL, __ATOMIC_SEQ_CST)\n#define KMP_TEST_THEN_ADD4_ACQ64(p)                                            \\\n  __atomic_fetch_add((volatile kmp_int64 *)(p), 4LL, __ATOMIC_SEQ_CST)\n#define KMP_TEST_THEN_DEC64(p)                                                 \\\n  __atomic_fetch_sub((volatile kmp_int64 *)(p), 1LL, __ATOMIC_SEQ_CST)\n#define KMP_TEST_THEN_DEC_ACQ64(p)                                             \\\n  __atomic_fetch_sub((volatile kmp_int64 *)(p), 1LL, __ATOMIC_SEQ_CST)\n#else\n#define KMP_TEST_THEN_ADD4_64(p)                                               \\\n  __sync_fetch_and_add((volatile kmp_int64 *)(p), 4LL)\n#define KMP_TEST_THEN_ADD4_ACQ64(p)                                            \\\n  __sync_fetch_and_add((volatile kmp_int64 *)(p), 4LL)\n#define KMP_TEST_THEN_DEC64(p)                                                 \\\n  __sync_fetch_and_sub((volatile kmp_int64 *)(p), 1LL)\n#define KMP_TEST_THEN_DEC_ACQ64(p)                                             \\\n  __sync_fetch_and_sub((volatile kmp_int64 *)(p), 1LL)\n#endif\n#define KMP_TEST_THEN_DEC32(p)                                                 \\\n  __sync_fetch_and_sub((volatile kmp_int32 *)(p), 1)\n#define KMP_TEST_THEN_DEC_ACQ32(p)                                             \\\n  __sync_fetch_and_sub((volatile kmp_int32 *)(p), 1)\n#define KMP_TEST_THEN_ADD8(p, v)                                               \\\n  __sync_fetch_and_add((volatile kmp_int8 *)(p), (kmp_int8)(v))\n#define KMP_TEST_THEN_ADD32(p, v)                                              \\\n  __sync_fetch_and_add((volatile kmp_int32 *)(p), (kmp_int32)(v))\n#if KMP_ARCH_MIPS\n#define KMP_TEST_THEN_ADD64(p, v)                                              \\\n  __atomic_fetch_add((volatile kmp_uint64 *)(p), (kmp_uint64)(v),              \\\n                     __ATOMIC_SEQ_CST)\n#else\n#define KMP_TEST_THEN_ADD64(p, v)                                              \\\n  __sync_fetch_and_add((volatile kmp_int64 *)(p), (kmp_int64)(v))\n#endif\n\n#define KMP_TEST_THEN_OR8(p, v)                                                \\\n  __sync_fetch_and_or((volatile kmp_int8 *)(p), (kmp_int8)(v))\n#define KMP_TEST_THEN_AND8(p, v)                                               \\\n  __sync_fetch_and_and((volatile kmp_int8 *)(p), (kmp_int8)(v))\n#define KMP_TEST_THEN_OR32(p, v)                                               \\\n  __sync_fetch_and_or((volatile kmp_uint32 *)(p), (kmp_uint32)(v))\n#define KMP_TEST_THEN_AND32(p, v)                                              \\\n  __sync_fetch_and_and((volatile kmp_uint32 *)(p), (kmp_uint32)(v))\n#if KMP_ARCH_MIPS\n#define KMP_TEST_THEN_OR64(p, v)                                               \\\n  __atomic_fetch_or((volatile kmp_uint64 *)(p), (kmp_uint64)(v),               \\\n                    __ATOMIC_SEQ_CST)\n#define KMP_TEST_THEN_AND64(p, v)                                              \\\n  __atomic_fetch_and((volatile kmp_uint64 *)(p), (kmp_uint64)(v),              \\\n                     __ATOMIC_SEQ_CST)\n#else\n#define KMP_TEST_THEN_OR64(p, v)                                               \\\n  __sync_fetch_and_or((volatile kmp_uint64 *)(p), (kmp_uint64)(v))\n#define KMP_TEST_THEN_AND64(p, v)                                              \\\n  __sync_fetch_and_and((volatile kmp_uint64 *)(p), (kmp_uint64)(v))\n#endif\n\n#define KMP_COMPARE_AND_STORE_ACQ8(p, cv, sv)                                  \\\n  __sync_bool_compare_and_swap((volatile kmp_uint8 *)(p), (kmp_uint8)(cv),     \\\n                               (kmp_uint8)(sv))\n#define KMP_COMPARE_AND_STORE_REL8(p, cv, sv)                                  \\\n  __sync_bool_compare_and_swap((volatile kmp_uint8 *)(p), (kmp_uint8)(cv),     \\\n                               (kmp_uint8)(sv))\n#define KMP_COMPARE_AND_STORE_ACQ16(p, cv, sv)                                 \\\n  __sync_bool_compare_and_swap((volatile kmp_uint16 *)(p), (kmp_uint16)(cv),   \\\n                               (kmp_uint16)(sv))\n#define KMP_COMPARE_AND_STORE_REL16(p, cv, sv)                                 \\\n  __sync_bool_compare_and_swap((volatile kmp_uint16 *)(p), (kmp_uint16)(cv),   \\\n                               (kmp_uint16)(sv))\n#define KMP_COMPARE_AND_STORE_ACQ32(p, cv, sv)                                 \\\n  __sync_bool_compare_and_swap((volatile kmp_uint32 *)(p), (kmp_uint32)(cv),   \\\n                               (kmp_uint32)(sv))\n#define KMP_COMPARE_AND_STORE_REL32(p, cv, sv)                                 \\\n  __sync_bool_compare_and_swap((volatile kmp_uint32 *)(p), (kmp_uint32)(cv),   \\\n                               (kmp_uint32)(sv))\n#define KMP_COMPARE_AND_STORE_PTR(p, cv, sv)                                   \\\n  __sync_bool_compare_and_swap((void *volatile *)(p), (void *)(cv),            \\\n                               (void *)(sv))\n\n#define KMP_COMPARE_AND_STORE_RET8(p, cv, sv)                                  \\\n  __sync_val_compare_and_swap((volatile kmp_uint8 *)(p), (kmp_uint8)(cv),      \\\n                              (kmp_uint8)(sv))\n#define KMP_COMPARE_AND_STORE_RET16(p, cv, sv)                                 \\\n  __sync_val_compare_and_swap((volatile kmp_uint16 *)(p), (kmp_uint16)(cv),    \\\n                              (kmp_uint16)(sv))\n#define KMP_COMPARE_AND_STORE_RET32(p, cv, sv)                                 \\\n  __sync_val_compare_and_swap((volatile kmp_uint32 *)(p), (kmp_uint32)(cv),    \\\n                              (kmp_uint32)(sv))\n#if KMP_ARCH_MIPS\nstatic inline bool mips_sync_bool_compare_and_swap(volatile kmp_uint64 *p,\n                                                   kmp_uint64 cv,\n                                                   kmp_uint64 sv) {\n  return __atomic_compare_exchange(p, &cv, &sv, false, __ATOMIC_SEQ_CST,\n                                   __ATOMIC_SEQ_CST);\n}\nstatic inline bool mips_sync_val_compare_and_swap(volatile kmp_uint64 *p,\n                                                  kmp_uint64 cv,\n                                                  kmp_uint64 sv) {\n  __atomic_compare_exchange(p, &cv, &sv, false, __ATOMIC_SEQ_CST,\n                            __ATOMIC_SEQ_CST);\n  return cv;\n}\n#define KMP_COMPARE_AND_STORE_ACQ64(p, cv, sv)                                 \\\n  mips_sync_bool_compare_and_swap((volatile kmp_uint64 *)(p),                  \\\n                                  (kmp_uint64)(cv), (kmp_uint64)(sv))\n#define KMP_COMPARE_AND_STORE_REL64(p, cv, sv)                                 \\\n  mips_sync_bool_compare_and_swap((volatile kmp_uint64 *)(p),                  \\\n                                  (kmp_uint64)(cv), (kmp_uint64)(sv))\n#define KMP_COMPARE_AND_STORE_RET64(p, cv, sv)                                 \\\n  mips_sync_val_compare_and_swap((volatile kmp_uint64 *)(p), (kmp_uint64)(cv), \\\n                                 (kmp_uint64)(sv))\n#else\n#define KMP_COMPARE_AND_STORE_ACQ64(p, cv, sv)                                 \\\n  __sync_bool_compare_and_swap((volatile kmp_uint64 *)(p), (kmp_uint64)(cv),   \\\n                               (kmp_uint64)(sv))\n#define KMP_COMPARE_AND_STORE_REL64(p, cv, sv)                                 \\\n  __sync_bool_compare_and_swap((volatile kmp_uint64 *)(p), (kmp_uint64)(cv),   \\\n                               (kmp_uint64)(sv))\n#define KMP_COMPARE_AND_STORE_RET64(p, cv, sv)                                 \\\n  __sync_val_compare_and_swap((volatile kmp_uint64 *)(p), (kmp_uint64)(cv),    \\\n                              (kmp_uint64)(sv))\n#endif\n\n#define KMP_XCHG_FIXED8(p, v)                                                  \\\n  __sync_lock_test_and_set((volatile kmp_uint8 *)(p), (kmp_uint8)(v))\n#define KMP_XCHG_FIXED16(p, v)                                                 \\\n  __sync_lock_test_and_set((volatile kmp_uint16 *)(p), (kmp_uint16)(v))\n#define KMP_XCHG_FIXED32(p, v)                                                 \\\n  __sync_lock_test_and_set((volatile kmp_uint32 *)(p), (kmp_uint32)(v))\n#define KMP_XCHG_FIXED64(p, v)                                                 \\\n  __sync_lock_test_and_set((volatile kmp_uint64 *)(p), (kmp_uint64)(v))\n\ninline kmp_real32 KMP_XCHG_REAL32(volatile kmp_real32 *p, kmp_real32 v) {\n  kmp_int32 tmp =\n      __sync_lock_test_and_set((volatile kmp_uint32 *)(p), *(kmp_uint32 *)&v);\n  return *(kmp_real32 *)&tmp;\n}\n\ninline kmp_real64 KMP_XCHG_REAL64(volatile kmp_real64 *p, kmp_real64 v) {\n  kmp_int64 tmp =\n      __sync_lock_test_and_set((volatile kmp_uint64 *)(p), *(kmp_uint64 *)&v);\n  return *(kmp_real64 *)&tmp;\n}\n\n#else\n\nextern kmp_int8 __kmp_test_then_add8(volatile kmp_int8 *p, kmp_int8 v);\nextern kmp_int8 __kmp_test_then_or8(volatile kmp_int8 *p, kmp_int8 v);\nextern kmp_int8 __kmp_test_then_and8(volatile kmp_int8 *p, kmp_int8 v);\nextern kmp_int32 __kmp_test_then_add32(volatile kmp_int32 *p, kmp_int32 v);\nextern kmp_uint32 __kmp_test_then_or32(volatile kmp_uint32 *p, kmp_uint32 v);\nextern kmp_uint32 __kmp_test_then_and32(volatile kmp_uint32 *p, kmp_uint32 v);\nextern kmp_int64 __kmp_test_then_add64(volatile kmp_int64 *p, kmp_int64 v);\nextern kmp_uint64 __kmp_test_then_or64(volatile kmp_uint64 *p, kmp_uint64 v);\nextern kmp_uint64 __kmp_test_then_and64(volatile kmp_uint64 *p, kmp_uint64 v);\n\nextern kmp_int8 __kmp_compare_and_store8(volatile kmp_int8 *p, kmp_int8 cv,\n                                         kmp_int8 sv);\nextern kmp_int16 __kmp_compare_and_store16(volatile kmp_int16 *p, kmp_int16 cv,\n                                           kmp_int16 sv);\nextern kmp_int32 __kmp_compare_and_store32(volatile kmp_int32 *p, kmp_int32 cv,\n                                           kmp_int32 sv);\nextern kmp_int32 __kmp_compare_and_store64(volatile kmp_int64 *p, kmp_int64 cv,\n                                           kmp_int64 sv);\nextern kmp_int8 __kmp_compare_and_store_ret8(volatile kmp_int8 *p, kmp_int8 cv,\n                                             kmp_int8 sv);\nextern kmp_int16 __kmp_compare_and_store_ret16(volatile kmp_int16 *p,\n                                               kmp_int16 cv, kmp_int16 sv);\nextern kmp_int32 __kmp_compare_and_store_ret32(volatile kmp_int32 *p,\n                                               kmp_int32 cv, kmp_int32 sv);\nextern kmp_int64 __kmp_compare_and_store_ret64(volatile kmp_int64 *p,\n                                               kmp_int64 cv, kmp_int64 sv);\n\nextern kmp_int8 __kmp_xchg_fixed8(volatile kmp_int8 *p, kmp_int8 v);\nextern kmp_int16 __kmp_xchg_fixed16(volatile kmp_int16 *p, kmp_int16 v);\nextern kmp_int32 __kmp_xchg_fixed32(volatile kmp_int32 *p, kmp_int32 v);\nextern kmp_int64 __kmp_xchg_fixed64(volatile kmp_int64 *p, kmp_int64 v);\nextern kmp_real32 __kmp_xchg_real32(volatile kmp_real32 *p, kmp_real32 v);\nextern kmp_real64 __kmp_xchg_real64(volatile kmp_real64 *p, kmp_real64 v);\n\n#define KMP_TEST_THEN_INC32(p)                                                 \\\n  __kmp_test_then_add32((volatile kmp_int32 *)(p), 1)\n#define KMP_TEST_THEN_INC_ACQ32(p)                                             \\\n  __kmp_test_then_add32((volatile kmp_int32 *)(p), 1)\n#define KMP_TEST_THEN_INC64(p)                                                 \\\n  __kmp_test_then_add64((volatile kmp_int64 *)(p), 1LL)\n#define KMP_TEST_THEN_INC_ACQ64(p)                                             \\\n  __kmp_test_then_add64((volatile kmp_int64 *)(p), 1LL)\n#define KMP_TEST_THEN_ADD4_32(p)                                               \\\n  __kmp_test_then_add32((volatile kmp_int32 *)(p), 4)\n#define KMP_TEST_THEN_ADD4_ACQ32(p)                                            \\\n  __kmp_test_then_add32((volatile kmp_int32 *)(p), 4)\n#define KMP_TEST_THEN_ADD4_64(p)                                               \\\n  __kmp_test_then_add64((volatile kmp_int64 *)(p), 4LL)\n#define KMP_TEST_THEN_ADD4_ACQ64(p)                                            \\\n  __kmp_test_then_add64((volatile kmp_int64 *)(p), 4LL)\n#define KMP_TEST_THEN_DEC32(p)                                                 \\\n  __kmp_test_then_add32((volatile kmp_int32 *)(p), -1)\n#define KMP_TEST_THEN_DEC_ACQ32(p)                                             \\\n  __kmp_test_then_add32((volatile kmp_int32 *)(p), -1)\n#define KMP_TEST_THEN_DEC64(p)                                                 \\\n  __kmp_test_then_add64((volatile kmp_int64 *)(p), -1LL)\n#define KMP_TEST_THEN_DEC_ACQ64(p)                                             \\\n  __kmp_test_then_add64((volatile kmp_int64 *)(p), -1LL)\n#define KMP_TEST_THEN_ADD8(p, v)                                               \\\n  __kmp_test_then_add8((volatile kmp_int8 *)(p), (kmp_int8)(v))\n#define KMP_TEST_THEN_ADD32(p, v)                                              \\\n  __kmp_test_then_add32((volatile kmp_int32 *)(p), (kmp_int32)(v))\n#define KMP_TEST_THEN_ADD64(p, v)                                              \\\n  __kmp_test_then_add64((volatile kmp_int64 *)(p), (kmp_int64)(v))\n\n#define KMP_TEST_THEN_OR8(p, v)                                                \\\n  __kmp_test_then_or8((volatile kmp_int8 *)(p), (kmp_int8)(v))\n#define KMP_TEST_THEN_AND8(p, v)                                               \\\n  __kmp_test_then_and8((volatile kmp_int8 *)(p), (kmp_int8)(v))\n#define KMP_TEST_THEN_OR32(p, v)                                               \\\n  __kmp_test_then_or32((volatile kmp_uint32 *)(p), (kmp_uint32)(v))\n#define KMP_TEST_THEN_AND32(p, v)                                              \\\n  __kmp_test_then_and32((volatile kmp_uint32 *)(p), (kmp_uint32)(v))\n#define KMP_TEST_THEN_OR64(p, v)                                               \\\n  __kmp_test_then_or64((volatile kmp_uint64 *)(p), (kmp_uint64)(v))\n#define KMP_TEST_THEN_AND64(p, v)                                              \\\n  __kmp_test_then_and64((volatile kmp_uint64 *)(p), (kmp_uint64)(v))\n\n#define KMP_COMPARE_AND_STORE_ACQ8(p, cv, sv)                                  \\\n  __kmp_compare_and_store8((volatile kmp_int8 *)(p), (kmp_int8)(cv),           \\\n                           (kmp_int8)(sv))\n#define KMP_COMPARE_AND_STORE_REL8(p, cv, sv)                                  \\\n  __kmp_compare_and_store8((volatile kmp_int8 *)(p), (kmp_int8)(cv),           \\\n                           (kmp_int8)(sv))\n#define KMP_COMPARE_AND_STORE_ACQ16(p, cv, sv)                                 \\\n  __kmp_compare_and_store16((volatile kmp_int16 *)(p), (kmp_int16)(cv),        \\\n                            (kmp_int16)(sv))\n#define KMP_COMPARE_AND_STORE_REL16(p, cv, sv)                                 \\\n  __kmp_compare_and_store16((volatile kmp_int16 *)(p), (kmp_int16)(cv),        \\\n                            (kmp_int16)(sv))\n#define KMP_COMPARE_AND_STORE_ACQ32(p, cv, sv)                                 \\\n  __kmp_compare_and_store32((volatile kmp_int32 *)(p), (kmp_int32)(cv),        \\\n                            (kmp_int32)(sv))\n#define KMP_COMPARE_AND_STORE_REL32(p, cv, sv)                                 \\\n  __kmp_compare_and_store32((volatile kmp_int32 *)(p), (kmp_int32)(cv),        \\\n                            (kmp_int32)(sv))\n#define KMP_COMPARE_AND_STORE_ACQ64(p, cv, sv)                                 \\\n  __kmp_compare_and_store64((volatile kmp_int64 *)(p), (kmp_int64)(cv),        \\\n                            (kmp_int64)(sv))\n#define KMP_COMPARE_AND_STORE_REL64(p, cv, sv)                                 \\\n  __kmp_compare_and_store64((volatile kmp_int64 *)(p), (kmp_int64)(cv),        \\\n                            (kmp_int64)(sv))\n\n#if KMP_ARCH_X86\n#define KMP_COMPARE_AND_STORE_PTR(p, cv, sv)                                   \\\n  __kmp_compare_and_store32((volatile kmp_int32 *)(p), (kmp_int32)(cv),        \\\n                            (kmp_int32)(sv))\n#else /* 64 bit pointers */\n#define KMP_COMPARE_AND_STORE_PTR(p, cv, sv)                                   \\\n  __kmp_compare_and_store64((volatile kmp_int64 *)(p), (kmp_int64)(cv),        \\\n                            (kmp_int64)(sv))\n#endif /* KMP_ARCH_X86 */\n\n#define KMP_COMPARE_AND_STORE_RET8(p, cv, sv)                                  \\\n  __kmp_compare_and_store_ret8((p), (cv), (sv))\n#define KMP_COMPARE_AND_STORE_RET16(p, cv, sv)                                 \\\n  __kmp_compare_and_store_ret16((p), (cv), (sv))\n#define KMP_COMPARE_AND_STORE_RET32(p, cv, sv)                                 \\\n  __kmp_compare_and_store_ret32((volatile kmp_int32 *)(p), (kmp_int32)(cv),    \\\n                                (kmp_int32)(sv))\n#define KMP_COMPARE_AND_STORE_RET64(p, cv, sv)                                 \\\n  __kmp_compare_and_store_ret64((volatile kmp_int64 *)(p), (kmp_int64)(cv),    \\\n                                (kmp_int64)(sv))\n\n#define KMP_XCHG_FIXED8(p, v)                                                  \\\n  __kmp_xchg_fixed8((volatile kmp_int8 *)(p), (kmp_int8)(v));\n#define KMP_XCHG_FIXED16(p, v) __kmp_xchg_fixed16((p), (v));\n#define KMP_XCHG_FIXED32(p, v) __kmp_xchg_fixed32((p), (v));\n#define KMP_XCHG_FIXED64(p, v) __kmp_xchg_fixed64((p), (v));\n#define KMP_XCHG_REAL32(p, v) __kmp_xchg_real32((p), (v));\n#define KMP_XCHG_REAL64(p, v) __kmp_xchg_real64((p), (v));\n\n#endif /* KMP_ASM_INTRINS */\n\n/* ------------- relaxed consistency memory model stuff ------------------ */\n\n#if KMP_OS_WINDOWS\n#ifdef __ABSOFT_WIN\n#define KMP_MB() asm(\"nop\")\n#define KMP_IMB() asm(\"nop\")\n#else\n#define KMP_MB() /* _asm{ nop } */\n#define KMP_IMB() /* _asm{ nop } */\n#endif\n#endif /* KMP_OS_WINDOWS */\n\n#if KMP_ARCH_PPC64 || KMP_ARCH_ARM || KMP_ARCH_AARCH64 || KMP_ARCH_MIPS ||     \\\n    KMP_ARCH_MIPS64 || KMP_ARCH_RISCV64\n#define KMP_MB() __sync_synchronize()\n#endif\n\n#ifndef KMP_MB\n#define KMP_MB() /* nothing to do */\n#endif\n\n#ifndef KMP_IMB\n#define KMP_IMB() /* nothing to do */\n#endif\n\n#ifndef KMP_ST_REL32\n#define KMP_ST_REL32(A, D) (*(A) = (D))\n#endif\n\n#ifndef KMP_ST_REL64\n#define KMP_ST_REL64(A, D) (*(A) = (D))\n#endif\n\n#ifndef KMP_LD_ACQ32\n#define KMP_LD_ACQ32(A) (*(A))\n#endif\n\n#ifndef KMP_LD_ACQ64\n#define KMP_LD_ACQ64(A) (*(A))\n#endif\n\n/* ------------------------------------------------------------------------ */\n// FIXME - maybe this should this be\n//\n// #define TCR_4(a)    (*(volatile kmp_int32 *)(&a))\n// #define TCW_4(a,b)  (a) = (*(volatile kmp_int32 *)&(b))\n//\n// #define TCR_8(a)    (*(volatile kmp_int64 *)(a))\n// #define TCW_8(a,b)  (a) = (*(volatile kmp_int64 *)(&b))\n//\n// I'm fairly certain this is the correct thing to do, but I'm afraid\n// of performance regressions.\n\n#define TCR_1(a) (a)\n#define TCW_1(a, b) (a) = (b)\n#define TCR_4(a) (a)\n#define TCW_4(a, b) (a) = (b)\n#define TCI_4(a) (++(a))\n#define TCD_4(a) (--(a))\n#define TCR_8(a) (a)\n#define TCW_8(a, b) (a) = (b)\n#define TCI_8(a) (++(a))\n#define TCD_8(a) (--(a))\n#define TCR_SYNC_4(a) (a)\n#define TCW_SYNC_4(a, b) (a) = (b)\n#define TCX_SYNC_4(a, b, c)                                                    \\\n  KMP_COMPARE_AND_STORE_REL32((volatile kmp_int32 *)(volatile void *)&(a),     \\\n                              (kmp_int32)(b), (kmp_int32)(c))\n#define TCR_SYNC_8(a) (a)\n#define TCW_SYNC_8(a, b) (a) = (b)\n#define TCX_SYNC_8(a, b, c)                                                    \\\n  KMP_COMPARE_AND_STORE_REL64((volatile kmp_int64 *)(volatile void *)&(a),     \\\n                              (kmp_int64)(b), (kmp_int64)(c))\n\n#if KMP_ARCH_X86 || KMP_ARCH_MIPS\n// What about ARM?\n#define TCR_PTR(a) ((void *)TCR_4(a))\n#define TCW_PTR(a, b) TCW_4((a), (b))\n#define TCR_SYNC_PTR(a) ((void *)TCR_SYNC_4(a))\n#define TCW_SYNC_PTR(a, b) TCW_SYNC_4((a), (b))\n#define TCX_SYNC_PTR(a, b, c) ((void *)TCX_SYNC_4((a), (b), (c)))\n\n#else /* 64 bit pointers */\n\n#define TCR_PTR(a) ((void *)TCR_8(a))\n#define TCW_PTR(a, b) TCW_8((a), (b))\n#define TCR_SYNC_PTR(a) ((void *)TCR_SYNC_8(a))\n#define TCW_SYNC_PTR(a, b) TCW_SYNC_8((a), (b))\n#define TCX_SYNC_PTR(a, b, c) ((void *)TCX_SYNC_8((a), (b), (c)))\n\n#endif /* KMP_ARCH_X86 */\n\n/* If these FTN_{TRUE,FALSE} values change, may need to change several places\n   where they are used to check that language is Fortran, not C. */\n\n#ifndef FTN_TRUE\n#define FTN_TRUE TRUE\n#endif\n\n#ifndef FTN_FALSE\n#define FTN_FALSE FALSE\n#endif\n\ntypedef void (*microtask_t)(int *gtid, int *npr, ...);\n\n#ifdef USE_VOLATILE_CAST\n#define VOLATILE_CAST(x) (volatile x)\n#else\n#define VOLATILE_CAST(x) (x)\n#endif\n\n#define KMP_WAIT __kmp_wait_4\n#define KMP_WAIT_PTR __kmp_wait_4_ptr\n#define KMP_EQ __kmp_eq_4\n#define KMP_NEQ __kmp_neq_4\n#define KMP_LT __kmp_lt_4\n#define KMP_GE __kmp_ge_4\n#define KMP_LE __kmp_le_4\n\n/* Workaround for Intel(R) 64 code gen bug when taking address of static array\n * (Intel(R) 64 Tracker #138) */\n#if (KMP_ARCH_X86_64 || KMP_ARCH_PPC64) && KMP_OS_LINUX\n#define STATIC_EFI2_WORKAROUND\n#else\n#define STATIC_EFI2_WORKAROUND static\n#endif\n\n// Support of BGET usage\n#ifndef KMP_USE_BGET\n#define KMP_USE_BGET 1\n#endif\n\n// Switches for OSS builds\n#ifndef USE_CMPXCHG_FIX\n#define USE_CMPXCHG_FIX 1\n#endif\n\n// Enable dynamic user lock\n#define KMP_USE_DYNAMIC_LOCK 1\n\n// Enable Intel(R) Transactional Synchronization Extensions (Intel(R) TSX) if\n// dynamic user lock is turned on\n#if KMP_USE_DYNAMIC_LOCK\n// Visual studio can't handle the asm sections in this code\n#define KMP_USE_TSX (KMP_ARCH_X86 || KMP_ARCH_X86_64) && !KMP_COMPILER_MSVC\n#ifdef KMP_USE_ADAPTIVE_LOCKS\n#undef KMP_USE_ADAPTIVE_LOCKS\n#endif\n#define KMP_USE_ADAPTIVE_LOCKS KMP_USE_TSX\n#endif\n\n// Enable tick time conversion of ticks to seconds\n#if KMP_STATS_ENABLED\n#define KMP_HAVE_TICK_TIME                                                     \\\n  (KMP_OS_LINUX && (KMP_MIC || KMP_ARCH_X86 || KMP_ARCH_X86_64))\n#endif\n\n// Warning levels\nenum kmp_warnings_level {\n  kmp_warnings_off = 0, /* No warnings */\n  kmp_warnings_low, /* Minimal warnings (default) */\n  kmp_warnings_explicit = 6, /* Explicitly set to ON - more warnings */\n  kmp_warnings_verbose /* reserved */\n};\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n\n// Safe C API\n#include \"kmp_safe_c_api.h\"\n\n// Macros for C++11 atomic functions\n#define KMP_ATOMIC_LD(p, order) (p)->load(std::memory_order_##order)\n#define KMP_ATOMIC_OP(op, p, v, order) (p)->op(v, std::memory_order_##order)\n\n// For non-default load/store\n#define KMP_ATOMIC_LD_ACQ(p) KMP_ATOMIC_LD(p, acquire)\n#define KMP_ATOMIC_LD_RLX(p) KMP_ATOMIC_LD(p, relaxed)\n#define KMP_ATOMIC_ST_REL(p, v) KMP_ATOMIC_OP(store, p, v, release)\n#define KMP_ATOMIC_ST_RLX(p, v) KMP_ATOMIC_OP(store, p, v, relaxed)\n\n// For non-default fetch_<op>\n#define KMP_ATOMIC_ADD(p, v) KMP_ATOMIC_OP(fetch_add, p, v, acq_rel)\n#define KMP_ATOMIC_SUB(p, v) KMP_ATOMIC_OP(fetch_sub, p, v, acq_rel)\n#define KMP_ATOMIC_AND(p, v) KMP_ATOMIC_OP(fetch_and, p, v, acq_rel)\n#define KMP_ATOMIC_OR(p, v) KMP_ATOMIC_OP(fetch_or, p, v, acq_rel)\n#define KMP_ATOMIC_INC(p) KMP_ATOMIC_OP(fetch_add, p, 1, acq_rel)\n#define KMP_ATOMIC_DEC(p) KMP_ATOMIC_OP(fetch_sub, p, 1, acq_rel)\n#define KMP_ATOMIC_ADD_RLX(p, v) KMP_ATOMIC_OP(fetch_add, p, v, relaxed)\n#define KMP_ATOMIC_INC_RLX(p) KMP_ATOMIC_OP(fetch_add, p, 1, relaxed)\n\n// Callers of the following functions cannot see the side effect on \"expected\".\ntemplate <typename T>\nbool __kmp_atomic_compare_store(std::atomic<T> *p, T expected, T desired) {\n  return p->compare_exchange_strong(\n      expected, desired, std::memory_order_acq_rel, std::memory_order_relaxed);\n}\n\ntemplate <typename T>\nbool __kmp_atomic_compare_store_acq(std::atomic<T> *p, T expected, T desired) {\n  return p->compare_exchange_strong(\n      expected, desired, std::memory_order_acquire, std::memory_order_relaxed);\n}\n\ntemplate <typename T>\nbool __kmp_atomic_compare_store_rel(std::atomic<T> *p, T expected, T desired) {\n  return p->compare_exchange_strong(\n      expected, desired, std::memory_order_release, std::memory_order_relaxed);\n}\n\n// Symbol lookup on Linux/Windows\n#if KMP_OS_WINDOWS\nextern void *__kmp_lookup_symbol(const char *name);\n#define KMP_DLSYM(name) __kmp_lookup_symbol(name)\n#define KMP_DLSYM_NEXT(name) nullptr\n#else\n#define KMP_DLSYM(name) dlsym(RTLD_DEFAULT, name)\n#define KMP_DLSYM_NEXT(name) dlsym(RTLD_NEXT, name)\n#endif\n\n#endif /* KMP_OS_H */\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_platform.h", "content": "/*\n * kmp_platform.h -- header for determining operating system and architecture\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_PLATFORM_H\n#define KMP_PLATFORM_H\n\n/* ---------------------- Operating system recognition ------------------- */\n\n#define KMP_OS_LINUX 0\n#define KMP_OS_DRAGONFLY 0\n#define KMP_OS_FREEBSD 0\n#define KMP_OS_NETBSD 0\n#define KMP_OS_OPENBSD 0\n#define KMP_OS_DARWIN 0\n#define KMP_OS_WINDOWS 0\n#define KMP_OS_HURD 0\n#define KMP_OS_UNIX 0 /* disjunction of KMP_OS_LINUX, KMP_OS_DARWIN etc. */\n\n#ifdef _WIN32\n#undef KMP_OS_WINDOWS\n#define KMP_OS_WINDOWS 1\n#endif\n\n#if (defined __APPLE__ && defined __MACH__)\n#undef KMP_OS_DARWIN\n#define KMP_OS_DARWIN 1\n#endif\n\n// in some ppc64 linux installations, only the second condition is met\n#if (defined __linux)\n#undef KMP_OS_LINUX\n#define KMP_OS_LINUX 1\n#elif (defined __linux__)\n#undef KMP_OS_LINUX\n#define KMP_OS_LINUX 1\n#else\n#endif\n\n#if (defined __DragonFly__)\n#undef KMP_OS_DRAGONFLY\n#define KMP_OS_DRAGONFLY 1\n#endif\n\n#if (defined __FreeBSD__)\n#undef KMP_OS_FREEBSD\n#define KMP_OS_FREEBSD 1\n#endif\n\n#if (defined __NetBSD__)\n#undef KMP_OS_NETBSD\n#define KMP_OS_NETBSD 1\n#endif\n\n#if (defined __OpenBSD__)\n#undef KMP_OS_OPENBSD\n#define KMP_OS_OPENBSD 1\n#endif\n\n#if (defined __GNU__)\n#undef KMP_OS_HURD\n#define KMP_OS_HURD 1\n#endif\n\n#if (1 != KMP_OS_LINUX + KMP_OS_DRAGONFLY + KMP_OS_FREEBSD + KMP_OS_NETBSD +   \\\n              KMP_OS_OPENBSD + KMP_OS_DARWIN + KMP_OS_WINDOWS + KMP_OS_HURD)\n#error Unknown OS\n#endif\n\n#if KMP_OS_LINUX || KMP_OS_DRAGONFLY || KMP_OS_FREEBSD || KMP_OS_NETBSD ||     \\\n    KMP_OS_OPENBSD || KMP_OS_DARWIN || KMP_OS_HURD\n#undef KMP_OS_UNIX\n#define KMP_OS_UNIX 1\n#endif\n\n/* ---------------------- Architecture recognition ------------------- */\n\n#define KMP_ARCH_X86 0\n#define KMP_ARCH_X86_64 0\n#define KMP_ARCH_AARCH64 0\n#define KMP_ARCH_PPC64_ELFv1 0\n#define KMP_ARCH_PPC64_ELFv2 0\n#define KMP_ARCH_PPC64 (KMP_ARCH_PPC64_ELFv2 || KMP_ARCH_PPC64_ELFv1)\n#define KMP_ARCH_MIPS 0\n#define KMP_ARCH_MIPS64 0\n#define KMP_ARCH_RISCV64 0\n\n#if KMP_OS_WINDOWS\n#if defined(_M_AMD64) || defined(__x86_64)\n#undef KMP_ARCH_X86_64\n#define KMP_ARCH_X86_64 1\n#else\n#undef KMP_ARCH_X86\n#define KMP_ARCH_X86 1\n#endif\n#endif\n\n#if KMP_OS_UNIX\n#if defined __x86_64\n#undef KMP_ARCH_X86_64\n#define KMP_ARCH_X86_64 1\n#elif defined __i386\n#undef KMP_ARCH_X86\n#define KMP_ARCH_X86 1\n#elif defined __powerpc64__\n#if defined(_CALL_ELF) && _CALL_ELF == 2\n#undef KMP_ARCH_PPC64_ELFv2\n#define KMP_ARCH_PPC64_ELFv2 1\n#else\n#undef KMP_ARCH_PPC64_ELFv1\n#define KMP_ARCH_PPC64_ELFv1 1\n#endif\n#elif defined __aarch64__\n#undef KMP_ARCH_AARCH64\n#define KMP_ARCH_AARCH64 1\n#elif defined __mips__\n#if defined __mips64\n#undef KMP_ARCH_MIPS64\n#define KMP_ARCH_MIPS64 1\n#else\n#undef KMP_ARCH_MIPS\n#define KMP_ARCH_MIPS 1\n#endif\n#elif defined __riscv && __riscv_xlen == 64\n#undef KMP_ARCH_RISCV64\n#define KMP_ARCH_RISCV64 1\n#endif\n#endif\n\n#if defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7R__) ||                     \\\n    defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_7VE__)\n#define KMP_ARCH_ARMV7 1\n#endif\n\n#if defined(KMP_ARCH_ARMV7) || defined(__ARM_ARCH_6__) ||                      \\\n    defined(__ARM_ARCH_6J__) || defined(__ARM_ARCH_6K__) ||                    \\\n    defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6T2__) ||                   \\\n    defined(__ARM_ARCH_6ZK__)\n#define KMP_ARCH_ARMV6 1\n#endif\n\n#if defined(KMP_ARCH_ARMV6) || defined(__ARM_ARCH_5T__) ||                     \\\n    defined(__ARM_ARCH_5E__) || defined(__ARM_ARCH_5TE__) ||                   \\\n    defined(__ARM_ARCH_5TEJ__)\n#define KMP_ARCH_ARMV5 1\n#endif\n\n#if defined(KMP_ARCH_ARMV5) || defined(__ARM_ARCH_4__) ||                      \\\n    defined(__ARM_ARCH_4T__)\n#define KMP_ARCH_ARMV4 1\n#endif\n\n#if defined(KMP_ARCH_ARMV4) || defined(__ARM_ARCH_3__) ||                      \\\n    defined(__ARM_ARCH_3M__)\n#define KMP_ARCH_ARMV3 1\n#endif\n\n#if defined(KMP_ARCH_ARMV3) || defined(__ARM_ARCH_2__)\n#define KMP_ARCH_ARMV2 1\n#endif\n\n#if defined(KMP_ARCH_ARMV2)\n#define KMP_ARCH_ARM 1\n#endif\n\n#if defined(__MIC__) || defined(__MIC2__)\n#define KMP_MIC 1\n#if __MIC2__ || __KNC__\n#define KMP_MIC1 0\n#define KMP_MIC2 1\n#else\n#define KMP_MIC1 1\n#define KMP_MIC2 0\n#endif\n#else\n#define KMP_MIC 0\n#define KMP_MIC1 0\n#define KMP_MIC2 0\n#endif\n\n/* Specify 32 bit architectures here */\n#define KMP_32_BIT_ARCH (KMP_ARCH_X86 || KMP_ARCH_ARM || KMP_ARCH_MIPS)\n\n// Platforms which support Intel(R) Many Integrated Core Architecture\n#define KMP_MIC_SUPPORTED                                                      \\\n  ((KMP_ARCH_X86 || KMP_ARCH_X86_64) && (KMP_OS_LINUX || KMP_OS_WINDOWS))\n\n// TODO: Fixme - This is clever, but really fugly\n#if (1 != KMP_ARCH_X86 + KMP_ARCH_X86_64 + KMP_ARCH_ARM + KMP_ARCH_PPC64 +     \\\n              KMP_ARCH_AARCH64 + KMP_ARCH_MIPS + KMP_ARCH_MIPS64 +             \\\n              KMP_ARCH_RISCV64)\n#error Unknown or unsupported architecture\n#endif\n\n#endif // KMP_PLATFORM_H\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_safe_c_api.h", "content": "\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_SAFE_C_API_H\n#define KMP_SAFE_C_API_H\n\n#include <type_traits>\n#include \"kmp_platform.h\"\n#include <string.h>\n\n// Replacement for banned C API\n\n// Not every unsafe call listed here is handled now, but keeping everything\n// in one place should be handy for future maintenance.\n#if KMP_OS_WINDOWS && KMP_MSVC_COMPAT\n\n#define RSIZE_MAX_STR (4UL << 10) // 4KB\n\n// _malloca was suggested, but it is not a drop-in replacement for _alloca\n#define KMP_ALLOCA _alloca\n\n#define KMP_MEMCPY_S memcpy_s\n#define KMP_SNPRINTF sprintf_s\n#define KMP_SSCANF sscanf_s\n#define KMP_STRCPY_S strcpy_s\n#define KMP_STRNCPY_S strncpy_s\n\n// Use this only when buffer size is unknown\n#define KMP_MEMCPY(dst, src, cnt) memcpy_s(dst, cnt, src, cnt)\n\ntemplate <typename T, bool B = std::is_array<T>::value>\nstruct kmp_get_rmax_t {};\ntemplate <typename T> struct kmp_get_rmax_t<T, false> {\n  static const size_t value = RSIZE_MAX_STR;\n};\ntemplate <typename T> struct kmp_get_rmax_t<T, true> {\n  static const size_t value = sizeof(T);\n};\n#define KMP_STRLEN(str) strnlen_s(str, kmp_get_rmax_t<decltype(str)>::value)\n\n// Use this only when buffer size is unknown\n#define KMP_STRNCPY(dst, src, cnt) strncpy_s(dst, cnt, src, cnt)\n\n// _TRUNCATE insures buffer size > max string to print.\n#define KMP_VSNPRINTF(dst, cnt, fmt, arg)                                      \\\n  vsnprintf_s(dst, cnt, _TRUNCATE, fmt, arg)\n\n#else // KMP_OS_WINDOWS\n\n// For now, these macros use the existing API.\n\n#define KMP_ALLOCA alloca\n#define KMP_MEMCPY_S(dst, bsz, src, cnt) memcpy(dst, src, cnt)\n#define KMP_SNPRINTF snprintf\n#define KMP_SSCANF sscanf\n#define KMP_STRCPY_S(dst, bsz, src) strcpy(dst, src)\n#define KMP_STRNCPY_S(dst, bsz, src, cnt) strncpy(dst, src, cnt)\n#define KMP_VSNPRINTF vsnprintf\n#define KMP_STRNCPY strncpy\n#define KMP_STRLEN strlen\n#define KMP_MEMCPY memcpy\n\n#endif // KMP_OS_WINDOWS\n\n// Offer truncated version of strncpy\nstatic inline void __kmp_strncpy_truncate(char *buffer, size_t buf_size,\n                                          char const *src, size_t src_size) {\n  if (src_size >= buf_size) {\n    src_size = buf_size - 1;\n  }\n  KMP_STRNCPY_S(buffer, buf_size, src, src_size);\n  buffer[src_size] = '\\0';\n}\n\n#endif // KMP_SAFE_C_API_H\n"}, "10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_str.h", "content": "/*\n * kmp_str.h -- String manipulation routines.\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_STR_H\n#define KMP_STR_H\n\n#include <stdarg.h>\n#include <string.h>\n\n#include \"kmp_os.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n#if KMP_OS_WINDOWS\n#define strdup _strdup\n#endif\n\n/*  some macros to replace ctype.h functions  */\n#define TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) + 'a' - 'A') : (c))\n\nstruct kmp_str_buf {\n  char *str; // Pointer to buffer content, read only.\n  unsigned int size; // Do not change this field!\n  int used; // Number of characters printed to buffer, read only.\n  char bulk[512]; // Do not use this field!\n}; // struct kmp_str_buf\ntypedef struct kmp_str_buf kmp_str_buf_t;\n\n#define __kmp_str_buf_init(b)                                                  \\\n  {                                                                            \\\n    (b)->str = (b)->bulk;                                                      \\\n    (b)->size = sizeof((b)->bulk);                                             \\\n    (b)->used = 0;                                                             \\\n    (b)->bulk[0] = 0;                                                          \\\n  }\n\nvoid __kmp_str_buf_clear(kmp_str_buf_t *buffer);\nvoid __kmp_str_buf_reserve(kmp_str_buf_t *buffer, size_t size);\nvoid __kmp_str_buf_detach(kmp_str_buf_t *buffer);\nvoid __kmp_str_buf_free(kmp_str_buf_t *buffer);\nvoid __kmp_str_buf_cat(kmp_str_buf_t *buffer, char const *str, size_t len);\nvoid __kmp_str_buf_catbuf(kmp_str_buf_t *dest, const kmp_str_buf_t *src);\nint __kmp_str_buf_vprint(kmp_str_buf_t *buffer, char const *format,\n                         va_list args);\nint __kmp_str_buf_print(kmp_str_buf_t *buffer, char const *format, ...);\nvoid __kmp_str_buf_print_size(kmp_str_buf_t *buffer, size_t size);\n\n/* File name parser.\n   Usage:\n\n   kmp_str_fname_t fname = __kmp_str_fname_init( path );\n   // Use fname.path (copy of original path ), fname.dir, fname.base.\n   // Note fname.dir concatenated with fname.base gives exact copy of path.\n   __kmp_str_fname_free( & fname );\n*/\nstruct kmp_str_fname {\n  char *path;\n  char *dir;\n  char *base;\n}; // struct kmp_str_fname\ntypedef struct kmp_str_fname kmp_str_fname_t;\nvoid __kmp_str_fname_init(kmp_str_fname_t *fname, char const *path);\nvoid __kmp_str_fname_free(kmp_str_fname_t *fname);\n// Compares file name with specified pattern. If pattern is NULL, any fname\n// matched.\nint __kmp_str_fname_match(kmp_str_fname_t const *fname, char const *pattern);\n\n/* The compiler provides source locations in string form\n   \";file;func;line;col;;\". It is not convenient for manipulation. This\n   structure keeps source location in more convenient form.\n   Usage:\n\n   kmp_str_loc_t loc = __kmp_str_loc_init(ident->psource, false);\n   // use loc.file, loc.func, loc.line, loc.col.\n   // loc.fname is available if second argument of __kmp_str_loc_init is true.\n   __kmp_str_loc_free( & loc );\n\n   If psource is NULL or does not follow format above, file and/or func may be\n   NULL pointers.\n*/\nstruct kmp_str_loc {\n  char *_bulk; // Do not use thid field.\n  kmp_str_fname_t fname; // Will be initialized if init_fname is true.\n  char *file;\n  char *func;\n  int line;\n  int col;\n}; // struct kmp_str_loc\ntypedef struct kmp_str_loc kmp_str_loc_t;\nkmp_str_loc_t __kmp_str_loc_init(char const *psource, bool init_fname);\nvoid __kmp_str_loc_numbers(char const *Psource, int *Line, int *Col);\nvoid __kmp_str_loc_free(kmp_str_loc_t *loc);\n\nint __kmp_str_eqf(char const *lhs, char const *rhs);\nchar *__kmp_str_format(char const *format, ...);\nvoid __kmp_str_free(char **str);\nint __kmp_str_match(char const *target, int len, char const *data);\nint __kmp_str_match_false(char const *data);\nint __kmp_str_match_true(char const *data);\nvoid __kmp_str_replace(char *str, char search_for, char replace_with);\nvoid __kmp_str_split(char *str, char delim, char **head, char **tail);\nchar *__kmp_str_token(char *str, char const *delim, char **buf);\nint __kmp_str_to_int(char const *str, char sentinel);\n\nvoid __kmp_str_to_size(char const *str, size_t *out, size_t dfactor,\n                       char const **error);\nvoid __kmp_str_to_uint(char const *str, kmp_uint64 *out, char const **error);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n\n#endif // KMP_STR_H\n\n// end of file //\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_version.h", "content": "/*\n * kmp_version.h -- version number for this release\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_VERSION_H\n#define KMP_VERSION_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n#ifndef KMP_VERSION_MAJOR\n#error KMP_VERSION_MAJOR macro is not defined.\n#endif\n#define KMP_VERSION_MINOR 0\n/* Using \"magic\" prefix in all the version strings is rather convenient to get\n   static version info from binaries by using standard utilities \"strings\" and\n   \"grep\", e. g.:\n        $ strings libomp.so | grep \"@(#)\"\n   gives clean list of all version strings in the library. Leading zero helps\n   to keep version string separate from printable characters which may occurs\n   just before version string. */\n#define KMP_VERSION_MAGIC_STR \"\\x00@(#) \"\n#define KMP_VERSION_MAGIC_LEN 6 // Length of KMP_VERSION_MAGIC_STR.\n#define KMP_VERSION_PREF_STR \"LLVM OMP \"\n#define KMP_VERSION_PREFIX KMP_VERSION_MAGIC_STR KMP_VERSION_PREF_STR\n\n/* declare all the version string constants for KMP_VERSION env. variable */\nextern int const __kmp_version_major;\nextern int const __kmp_version_minor;\nextern int const __kmp_version_build;\nextern int const __kmp_openmp_version;\nextern char const\n    __kmp_copyright[]; // Old variable, kept for compatibility with ITC and ITP.\nextern char const __kmp_version_copyright[];\nextern char const __kmp_version_lib_ver[];\nextern char const __kmp_version_lib_type[];\nextern char const __kmp_version_link_type[];\nextern char const __kmp_version_build_time[];\nextern char const __kmp_version_target_env[];\nextern char const __kmp_version_build_compiler[];\nextern char const __kmp_version_alt_comp[];\nextern char const __kmp_version_omp_api[];\n// ??? extern char const __kmp_version_debug[];\nextern char const __kmp_version_lock[];\nextern char const __kmp_version_nested_stats_reporting[];\nextern char const __kmp_version_ftnstdcall[];\nextern char const __kmp_version_ftncdecl[];\nextern char const __kmp_version_ftnextra[];\n\nvoid __kmp_print_version_1(void);\nvoid __kmp_print_version_2(void);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif // __cplusplus\n\n#endif /* KMP_VERSION_H */\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_wrapper_malloc.h", "content": "/*\n * kmp_wrapper_malloc.h -- Wrappers for memory allocation routines\n *                         (malloc(), free(), and others).\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef KMP_WRAPPER_MALLOC_H\n#define KMP_WRAPPER_MALLOC_H\n\n/* This header serves for 3 purposes:\n   1. Declaring standard memory allocation routines in OS-independent way.\n   2. Passing source location info through memory allocation wrappers.\n   3. Enabling native memory debugging capabilities.\n\n   1. Declaring standard memory allocation routines in OS-independent way.\n   -----------------------------------------------------------------------\n   On Linux* OS, alloca() function is declared in <alloca.h> header, while on\n   Windows* OS there is no <alloca.h> header, function _alloca() (note\n   underscore!) is declared in <malloc.h>. This header eliminates these\n   differences, so client code including \"kmp_wrapper_malloc.h\" can rely on\n   following routines:\n\n        malloc\n        calloc\n        realloc\n        free\n        alloca\n\n   in OS-independent way. It also enables memory tracking capabilities in debug\n   build. (Currently it is available only on Windows* OS.)\n\n   2. Passing source location info through memory allocation wrappers.\n   -------------------------------------------------------------------\n   Some tools may help debugging memory errors, for example, report memory\n   leaks. However, memory allocation wrappers may hinder source location.\n   For example:\n\n   void * aligned_malloc( int size ) {\n     void * ptr = malloc( size ); // All the memory leaks will be reported at\n                                  // this line.\n     // some adjustments...\n     return ptr;\n   };\n\n   ptr = aligned_malloc( size ); // Memory leak will *not* be detected here. :-(\n\n   To overcome the problem, information about original source location should\n   be passed through all the memory allocation wrappers, for example:\n\n   void * aligned_malloc( int size, char const * file, int line ) {\n     void * ptr = _malloc_dbg( size, file, line );\n     // some adjustments...\n     return ptr;\n   };\n   void * ptr = aligned_malloc( size, __FILE__, __LINE__ );\n\n   This is a good idea for debug, but passing additional arguments impacts\n   performance. Disabling extra arguments in release version of the software\n   introduces too many conditional compilation, which makes code unreadable.\n   This header defines few macros and functions facilitating it:\n\n   void * _aligned_malloc( int size KMP_SRC_LOC_DECL ) {\n     void * ptr = malloc_src_loc( size KMP_SRC_LOC_PARM );\n     // some adjustments...\n     return ptr;\n   };\n   #define aligned_malloc( size ) _aligned_malloc( (size) KMP_SRC_LOC_CURR )\n   // Use macro instead of direct call to function.\n\n   void * ptr = aligned_malloc( size );  // Bingo! Memory leak will be\n                                         // reported at this line.\n\n   3. Enabling native memory debugging capabilities.\n   -------------------------------------------------\n   Some platforms may offer memory debugging capabilities. For example, debug\n   version of Microsoft RTL tracks all memory allocations and can report memory\n   leaks. This header enables this, and makes report more useful (see \"Passing\n   source location info through memory allocation wrappers\").\n*/\n\n#include <stdlib.h>\n\n#include \"kmp_os.h\"\n\n// Include alloca() declaration.\n#if KMP_OS_WINDOWS\n#include <malloc.h> // Windows* OS: _alloca() declared in \"malloc.h\".\n#if KMP_MSVC_COMPAT\n#define alloca _alloca // Allow to use alloca() with no underscore.\n#endif\n#elif KMP_OS_DRAGONFLY || KMP_OS_FREEBSD || KMP_OS_NETBSD || KMP_OS_OPENBSD\n// Declared in \"stdlib.h\".\n#elif KMP_OS_UNIX\n#include <alloca.h> // Linux* OS and OS X*: alloc() declared in \"alloca\".\n#else\n#error Unknown or unsupported OS.\n#endif\n\n/* KMP_SRC_LOC_DECL -- Declaring source location parameters, to be used in\n   function declaration.\n   KMP_SRC_LOC_PARM -- Source location parameters, to be used to pass\n   parameters to underlying levels.\n   KMP_SRC_LOC_CURR -- Source location arguments describing current location,\n   to be used at top-level.\n\n   Typical usage:\n   void * _aligned_malloc( int size KMP_SRC_LOC_DECL ) {\n     // Note: Comma is missed before KMP_SRC_LOC_DECL.\n     KE_TRACE( 25, ( \"called from %s:%d\\n\", KMP_SRC_LOC_PARM ) );\n     ...\n   }\n   #define aligned_malloc( size ) _aligned_malloc( (size) KMP_SRC_LOC_CURR )\n   // Use macro instead of direct call to function -- macro passes info\n   // about current source location to the func.\n*/\n#if KMP_DEBUG\n#define KMP_SRC_LOC_DECL , char const *_file_, int _line_\n#define KMP_SRC_LOC_PARM , _file_, _line_\n#define KMP_SRC_LOC_CURR , __FILE__, __LINE__\n#else\n#define KMP_SRC_LOC_DECL\n#define KMP_SRC_LOC_PARM\n#define KMP_SRC_LOC_CURR\n#endif // KMP_DEBUG\n\n/* malloc_src_loc() and free_src_loc() are pseudo-functions (really macros)\n   with accepts extra arguments (source location info) in debug mode. They\n   should be used in place of malloc() and free(), this allows enabling native\n   memory debugging capabilities (if any).\n\n   Typical usage:\n   ptr = malloc_src_loc( size KMP_SRC_LOC_PARM );\n   // Inside memory allocation wrapper, or\n   ptr = malloc_src_loc( size KMP_SRC_LOC_CURR );\n   // Outside of memory allocation wrapper.\n*/\n#define malloc_src_loc(args) _malloc_src_loc(args)\n#define free_src_loc(args) _free_src_loc(args)\n/* Depending on build mode (debug or release), malloc_src_loc is declared with\n   1 or 3 parameters, but calls to malloc_src_loc() are always the same:\n\n   ... malloc_src_loc( size KMP_SRC_LOC_PARM ); // or KMP_SRC_LOC_CURR\n\n   Compiler issues warning/error \"too few arguments in macro invocation\".\n   Declaring two macros, malloc_src_loc() and _malloc_src_loc(), overcomes the\n   problem. */\n\n#if KMP_DEBUG\n\n#if KMP_OS_WINDOWS && _DEBUG\n// KMP_DEBUG != _DEBUG. MS debug RTL is available only if _DEBUG is defined.\n\n// Windows* OS has native memory debugging capabilities. Enable them.\n\n#include <crtdbg.h>\n\n#define KMP_MEM_BLOCK _CLIENT_BLOCK\n#define malloc(size) _malloc_dbg((size), KMP_MEM_BLOCK, __FILE__, __LINE__)\n#define calloc(num, size)                                                      \\\n  _calloc_dbg((num), (size), KMP_MEM_BLOCK, __FILE__, __LINE__)\n#define realloc(ptr, size)                                                     \\\n  _realloc_dbg((ptr), (size), KMP_MEM_BLOCK, __FILE__, __LINE__)\n#define free(ptr) _free_dbg((ptr), KMP_MEM_BLOCK)\n\n#define _malloc_src_loc(size, file, line)                                      \\\n  _malloc_dbg((size), KMP_MEM_BLOCK, (file), (line))\n#define _free_src_loc(ptr, file, line) _free_dbg((ptr), KMP_MEM_BLOCK)\n\n#else\n\n// Linux* OS, OS X*, or non-debug Windows* OS.\n\n#define _malloc_src_loc(size, file, line) malloc((size))\n#define _free_src_loc(ptr, file, line) free((ptr))\n\n#endif\n\n#else\n\n// In release build malloc_src_loc() and free_src_loc() do not have extra\n// parameters.\n#define _malloc_src_loc(size) malloc((size))\n#define _free_src_loc(ptr) free((ptr))\n\n#endif // KMP_DEBUG\n\n#endif // KMP_WRAPPER_MALLOC_H\n\n// end of file //\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/ompt-event-specific.h", "content": "/******************************************************************************\n * File: ompt-event-specific.h\n *\n * Description:\n *\n *   specify which of the OMPT events are implemented by this runtime system\n *   and the level of their implementation by a runtime system.\n *****************************************************************************/\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __OMPT_EVENT_SPECIFIC_H__\n#define __OMPT_EVENT_SPECIFIC_H__\n\n#define _ompt_tokenpaste_helper(x, y) x##y\n#define _ompt_tokenpaste(x, y) _ompt_tokenpaste_helper(x, y)\n#define ompt_event_implementation_status(e) _ompt_tokenpaste(e, _implemented)\n\n/*----------------------------------------------------------------------------\n | Specify whether an event may occur or not, and whether event callbacks\n | never, sometimes, or always occur.\n |\n | The values for these constants are defined in section 6.1.2 of\n | the OMPT TR. They are exposed to tools through ompt_set_callback.\n +--------------------------------------------------------------------------*/\n\n#define ompt_event_UNIMPLEMENTED ompt_set_never\n#define ompt_event_MAY_CONVENIENT ompt_set_sometimes\n#define ompt_event_MAY_ALWAYS ompt_set_always\n\n#if OMPT_OPTIONAL\n#define ompt_event_MAY_ALWAYS_OPTIONAL ompt_event_MAY_ALWAYS\n#else\n#define ompt_event_MAY_ALWAYS_OPTIONAL ompt_event_UNIMPLEMENTED\n#endif\n\n/*----------------------------------------------------------------------------\n | Mandatory Events\n +--------------------------------------------------------------------------*/\n\n#define ompt_callback_thread_begin_implemented ompt_event_MAY_ALWAYS\n#define ompt_callback_thread_end_implemented ompt_event_MAY_ALWAYS\n\n#define ompt_callback_parallel_begin_implemented ompt_event_MAY_ALWAYS\n#define ompt_callback_parallel_end_implemented ompt_event_MAY_ALWAYS\n\n#define ompt_callback_task_create_implemented ompt_event_MAY_ALWAYS\n#define ompt_callback_task_schedule_implemented ompt_event_MAY_ALWAYS\n\n#define ompt_callback_implicit_task_implemented ompt_event_MAY_ALWAYS\n\n#define ompt_callback_target_implemented ompt_event_UNIMPLEMENTED\n#define ompt_callback_target_emi_implemented ompt_event_UNIMPLEMENTED\n#define ompt_callback_target_data_op_implemented ompt_event_UNIMPLEMENTED\n#define ompt_callback_target_data_op_emi_implemented ompt_event_UNIMPLEMENTED\n#define ompt_callback_target_submit_implemented ompt_event_UNIMPLEMENTED\n#define ompt_callback_target_submit_emi_implemented ompt_event_UNIMPLEMENTED\n\n#define ompt_callback_control_tool_implemented ompt_event_MAY_ALWAYS\n\n#define ompt_callback_device_initialize_implemented ompt_event_UNIMPLEMENTED\n#define ompt_callback_device_finalize_implemented ompt_event_UNIMPLEMENTED\n\n#define ompt_callback_device_load_implemented ompt_event_UNIMPLEMENTED\n#define ompt_callback_device_unload_implemented ompt_event_UNIMPLEMENTED\n\n/*----------------------------------------------------------------------------\n | Optional Events\n +--------------------------------------------------------------------------*/\n\n#define ompt_callback_sync_region_wait_implemented                             \\\n  ompt_event_MAY_ALWAYS_OPTIONAL\n\n#define ompt_callback_mutex_released_implemented ompt_event_MAY_ALWAYS_OPTIONAL\n\n#define ompt_callback_dependences_implemented ompt_event_MAY_ALWAYS_OPTIONAL\n#define ompt_callback_task_dependence_implemented ompt_event_MAY_ALWAYS_OPTIONAL\n\n#define ompt_callback_work_implemented ompt_event_MAY_ALWAYS_OPTIONAL\n\n#define ompt_callback_masked_implemented ompt_event_MAY_ALWAYS_OPTIONAL\n\n#define ompt_callback_target_map_implemented ompt_event_UNIMPLEMENTED\n#define ompt_callback_target_map_emi_implemented ompt_event_UNIMPLEMENTED\n\n#define ompt_callback_sync_region_implemented ompt_event_MAY_ALWAYS_OPTIONAL\n\n#define ompt_callback_lock_init_implemented ompt_event_MAY_ALWAYS_OPTIONAL\n#define ompt_callback_lock_destroy_implemented ompt_event_MAY_ALWAYS_OPTIONAL\n\n#define ompt_callback_mutex_acquire_implemented ompt_event_MAY_ALWAYS_OPTIONAL\n#define ompt_callback_mutex_acquired_implemented ompt_event_MAY_ALWAYS_OPTIONAL\n#define ompt_callback_nest_lock_implemented ompt_event_MAY_ALWAYS_OPTIONAL\n\n#define ompt_callback_flush_implemented ompt_event_MAY_ALWAYS_OPTIONAL\n\n#define ompt_callback_cancel_implemented ompt_event_MAY_ALWAYS_OPTIONAL\n\n#define ompt_callback_reduction_implemented ompt_event_MAY_ALWAYS_OPTIONAL\n\n#define ompt_callback_dispatch_implemented ompt_event_UNIMPLEMENTED\n\n#define ompt_callback_error_implemented ompt_event_MAY_ALWAYS_OPTIONAL\n\n#endif\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/ompt-internal.h", "content": "/*\n * ompt-internal.h - header of OMPT internal data structures\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __OMPT_INTERNAL_H__\n#define __OMPT_INTERNAL_H__\n\n#include \"ompt-event-specific.h\"\n#include \"omp-tools.h\"\n\n#define OMPT_VERSION 1\n\n#define _OMP_EXTERN extern \"C\"\n\n#define OMPT_INVOKER(x)                                                        \\\n  ((x == fork_context_gnu) ? ompt_parallel_invoker_program                     \\\n                           : ompt_parallel_invoker_runtime)\n\n#define ompt_callback(e) e##_callback\n\ntypedef struct ompt_callbacks_internal_s {\n#define ompt_event_macro(event, callback, eventid)                             \\\n  callback ompt_callback(event);\n\n  FOREACH_OMPT_EVENT(ompt_event_macro)\n\n#undef ompt_event_macro\n} ompt_callbacks_internal_t;\n\ntypedef struct ompt_callbacks_active_s {\n  unsigned int enabled : 1;\n#define ompt_event_macro(event, callback, eventid) unsigned int event : 1;\n\n  FOREACH_OMPT_EVENT(ompt_event_macro)\n\n#undef ompt_event_macro\n} ompt_callbacks_active_t;\n\n#define TASK_TYPE_DETAILS_FORMAT(info)                                         \\\n  ((info->td_flags.task_serial || info->td_flags.tasking_ser)                  \\\n       ? ompt_task_undeferred                                                  \\\n       : 0x0) |                                                                \\\n      ((!(info->td_flags.tiedness)) ? ompt_task_untied : 0x0) |                \\\n      (info->td_flags.final ? ompt_task_final : 0x0) |                         \\\n      (info->td_flags.merged_if0 ? ompt_task_mergeable : 0x0)\n\ntypedef struct {\n  ompt_frame_t frame;\n  ompt_data_t task_data;\n  struct kmp_taskdata *scheduling_parent;\n  int thread_num;\n} ompt_task_info_t;\n\ntypedef struct {\n  ompt_data_t parallel_data;\n  void *master_return_address;\n} ompt_team_info_t;\n\ntypedef struct ompt_lw_taskteam_s {\n  ompt_team_info_t ompt_team_info;\n  ompt_task_info_t ompt_task_info;\n  int heap;\n  struct ompt_lw_taskteam_s *parent;\n} ompt_lw_taskteam_t;\n\ntypedef struct {\n  ompt_data_t thread_data;\n  ompt_data_t task_data; /* stored here from implicit barrier-begin until\n                            implicit-task-end */\n  void *return_address; /* stored here on entry of runtime */\n  ompt_state_t state;\n  ompt_wait_id_t wait_id;\n  int ompt_task_yielded;\n  int parallel_flags; // information for the last parallel region invoked\n  void *idle_frame;\n} ompt_thread_info_t;\n\nextern ompt_callbacks_internal_t ompt_callbacks;\n\n#if OMPT_SUPPORT && OMPT_OPTIONAL\n#if USE_FAST_MEMORY\n#define KMP_OMPT_DEPS_ALLOC __kmp_fast_allocate\n#define KMP_OMPT_DEPS_FREE __kmp_fast_free\n#else\n#define KMP_OMPT_DEPS_ALLOC __kmp_thread_malloc\n#define KMP_OMPT_DEPS_FREE __kmp_thread_free\n#endif\n#endif /* OMPT_SUPPORT && OMPT_OPTIONAL */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid ompt_pre_init(void);\nvoid ompt_post_init(void);\nvoid ompt_fini(void);\n\n#define OMPT_GET_RETURN_ADDRESS(level) __builtin_return_address(level)\n#define OMPT_GET_FRAME_ADDRESS(level) __builtin_frame_address(level)\n\nint __kmp_control_tool(uint64_t command, uint64_t modifier, void *arg);\n\nextern ompt_callbacks_active_t ompt_enabled;\n\n#if KMP_OS_WINDOWS\n#define UNLIKELY(x) (x)\n#define OMPT_NOINLINE __declspec(noinline)\n#else\n#define UNLIKELY(x) __builtin_expect(!!(x), 0)\n#define OMPT_NOINLINE __attribute__((noinline))\n#endif\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/ompt-specific.h", "content": "/*\n * ompt-specific.h - header of OMPT internal functions implementation\n */\n\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef OMPT_SPECIFIC_H\n#define OMPT_SPECIFIC_H\n\n#include \"kmp.h\"\n\n#if OMPT_SUPPORT\n/*****************************************************************************\n * forward declarations\n ****************************************************************************/\n\nvoid __ompt_team_assign_id(kmp_team_t *team, ompt_data_t ompt_pid);\nvoid __ompt_thread_assign_wait_id(void *variable);\n\nvoid __ompt_lw_taskteam_init(ompt_lw_taskteam_t *lwt, kmp_info_t *thr, int gtid,\n                             ompt_data_t *ompt_pid, void *codeptr);\n\nvoid __ompt_lw_taskteam_link(ompt_lw_taskteam_t *lwt, kmp_info_t *thr,\n                             int on_heap, bool always = false);\n\nvoid __ompt_lw_taskteam_unlink(kmp_info_t *thr);\n\nompt_team_info_t *__ompt_get_teaminfo(int depth, int *size);\n\nompt_task_info_t *__ompt_get_task_info_object(int depth);\n\nint __ompt_get_parallel_info_internal(int ancestor_level,\n                                      ompt_data_t **parallel_data,\n                                      int *team_size);\n\nint __ompt_get_task_info_internal(int ancestor_level, int *type,\n                                  ompt_data_t **task_data,\n                                  ompt_frame_t **task_frame,\n                                  ompt_data_t **parallel_data, int *thread_num);\n\nompt_data_t *__ompt_get_thread_data_internal();\n\n/*\n * Unused currently\nstatic uint64_t __ompt_get_get_unique_id_internal();\n*/\n\nompt_sync_region_t __ompt_get_barrier_kind(enum barrier_type, kmp_info_t *);\n\n/*****************************************************************************\n * macros\n ****************************************************************************/\n\n#define OMPT_CUR_TASK_INFO(thr) (&(thr->th.th_current_task->ompt_task_info))\n#define OMPT_CUR_TASK_DATA(thr)                                                \\\n  (&(thr->th.th_current_task->ompt_task_info.task_data))\n#define OMPT_CUR_TEAM_INFO(thr) (&(thr->th.th_team->t.ompt_team_info))\n#define OMPT_CUR_TEAM_DATA(thr)                                                \\\n  (&(thr->th.th_team->t.ompt_team_info.parallel_data))\n\n#define OMPT_HAVE_WEAK_ATTRIBUTE KMP_HAVE_WEAK_ATTRIBUTE\n#define OMPT_HAVE_PSAPI KMP_HAVE_PSAPI\n#define OMPT_STR_MATCH(haystack, needle) __kmp_str_match(haystack, 0, needle)\n\ninline void *__ompt_load_return_address(int gtid) {\n  kmp_info_t *thr = __kmp_threads[gtid];\n  void *return_address = thr->th.ompt_thread_info.return_address;\n  thr->th.ompt_thread_info.return_address = NULL;\n  return return_address;\n}\n\n/*#define OMPT_STORE_RETURN_ADDRESS(gtid) \\\n  if (ompt_enabled.enabled && gtid >= 0 && __kmp_threads[gtid] &&              \\\n      !__kmp_threads[gtid]->th.ompt_thread_info.return_address)                \\\n  __kmp_threads[gtid]->th.ompt_thread_info.return_address =                    \\\n      __builtin_return_address(0)*/\n#define OMPT_STORE_RETURN_ADDRESS(gtid)                                        \\\n  OmptReturnAddressGuard ReturnAddressGuard{gtid, __builtin_return_address(0)};\n#define OMPT_LOAD_RETURN_ADDRESS(gtid) __ompt_load_return_address(gtid)\n#define OMPT_LOAD_OR_GET_RETURN_ADDRESS(gtid)                                  \\\n  ((ompt_enabled.enabled && gtid >= 0 && __kmp_threads[gtid] &&                \\\n    __kmp_threads[gtid]->th.ompt_thread_info.return_address)                   \\\n       ? __ompt_load_return_address(gtid)                                      \\\n       : __builtin_return_address(0))\n\n//******************************************************************************\n// inline functions\n//******************************************************************************\n\ninline kmp_info_t *ompt_get_thread_gtid(int gtid) {\n  return (gtid >= 0) ? __kmp_thread_from_gtid(gtid) : NULL;\n}\n\ninline kmp_info_t *ompt_get_thread() {\n  int gtid = __kmp_get_gtid();\n  return ompt_get_thread_gtid(gtid);\n}\n\ninline void ompt_set_thread_state(kmp_info_t *thread, ompt_state_t state) {\n  if (thread)\n    thread->th.ompt_thread_info.state = state;\n}\n\ninline const char *ompt_get_runtime_version() {\n  return &__kmp_version_lib_ver[KMP_VERSION_MAGIC_LEN];\n}\n\nclass OmptReturnAddressGuard {\nprivate:\n  bool SetAddress{false};\n  int Gtid;\n\npublic:\n  OmptReturnAddressGuard(int Gtid, void *ReturnAddress) : Gtid(Gtid) {\n    if (ompt_enabled.enabled && Gtid >= 0 && __kmp_threads[Gtid] &&\n        !__kmp_threads[Gtid]->th.ompt_thread_info.return_address) {\n      SetAddress = true;\n      __kmp_threads[Gtid]->th.ompt_thread_info.return_address = ReturnAddress;\n    }\n  }\n  ~OmptReturnAddressGuard() {\n    if (SetAddress)\n      __kmp_threads[Gtid]->th.ompt_thread_info.return_address = NULL;\n  }\n};\n\n#endif // OMPT_SUPPORT\n\n// macros providing the OMPT callbacks for reduction clause\n#if OMPT_SUPPORT && OMPT_OPTIONAL\n#define OMPT_REDUCTION_DECL(this_thr, gtid)                                    \\\n  ompt_data_t *my_task_data = OMPT_CUR_TASK_DATA(this_thr);                    \\\n  ompt_data_t *my_parallel_data = OMPT_CUR_TEAM_DATA(this_thr);                \\\n  void *return_address = OMPT_LOAD_RETURN_ADDRESS(gtid);\n#define OMPT_REDUCTION_BEGIN                                                   \\\n  if (ompt_enabled.enabled && ompt_enabled.ompt_callback_reduction) {          \\\n    ompt_callbacks.ompt_callback(ompt_callback_reduction)(                     \\\n        ompt_sync_region_reduction, ompt_scope_begin, my_parallel_data,        \\\n        my_task_data, return_address);                                         \\\n  }\n#define OMPT_REDUCTION_END                                                     \\\n  if (ompt_enabled.enabled && ompt_enabled.ompt_callback_reduction) {          \\\n    ompt_callbacks.ompt_callback(ompt_callback_reduction)(                     \\\n        ompt_sync_region_reduction, ompt_scope_end, my_parallel_data,          \\\n        my_task_data, return_address);                                         \\\n  }\n#else // OMPT_SUPPORT && OMPT_OPTIONAL\n#define OMPT_REDUCTION_DECL(this_thr, gtid)\n#define OMPT_REDUCTION_BEGIN\n#define OMPT_REDUCTION_END\n#endif // ! OMPT_SUPPORT && OMPT_OPTIONAL\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 0, "line": 11}, "message": "_HOME_VSTS_WORK_1_BUILD_PROJECTS_OPENMP_RUNTIME_SRC_KMP_CONFIG_H (fixit)"}, {"location": {"col": 9, "file": 0, "line": 11}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/build/projects/openmp/runtime/src/kmp_config.h", "reportHash": "3a97ed3305f77e1596f1ee98068f166f", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 1, "line": 13}, "message": "_HOME_VSTS_WORK_1_BUILD_PROJECTS_OPENMP_RUNTIME_SRC_OMP_TOOLS_H (fixit)"}, {"location": {"col": 9, "file": 1, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/build/projects/openmp/runtime/src/omp-tools.h", "reportHash": "672c8b71204dfc1fbbcac85fa55c2fea", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 2, "line": 14}, "message": "LLVM_OPENMP_RUNTIME_SRC_KMP_H (fixit)"}, {"location": {"col": 9, "file": 2, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp.h", "reportHash": "b7fbeebf85899c7739912f2db4d591d4", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 3, "line": 13}, "message": "LLVM_OPENMP_RUNTIME_SRC_KMP_DEBUG_H (fixit)"}, {"location": {"col": 9, "file": 3, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_debug.h", "reportHash": "d167f0966ca4b0d79faa087e2653927f", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 4, "line": 13}, "message": "LLVM_OPENMP_RUNTIME_SRC_KMP_I18N_H (fixit)"}, {"location": {"col": 9, "file": 4, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_i18n.h", "reportHash": "fb2e75f649347a77a2267cd088d2c049", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 4, "line": 25}, "message": "'kmp_i18n_id.inc' file not found"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_i18n.h", "reportHash": "6b951533a0dc70ca14d1dd8494b70722", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 9, "file": 5, "line": 13}, "message": "LLVM_OPENMP_RUNTIME_SRC_KMP_IO_H (fixit)"}, {"location": {"col": 9, "file": 5, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_io.h", "reportHash": "8a77ec712400cab24104c7cfe238f5dc", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 6, "line": 13}, "message": "LLVM_OPENMP_RUNTIME_SRC_KMP_LOCK_H (fixit)"}, {"location": {"col": 9, "file": 6, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_lock.h", "reportHash": "685bd6575b1f07a292de7ff41efffd8c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 7, "line": 13}, "message": "LLVM_OPENMP_RUNTIME_SRC_KMP_OS_H (fixit)"}, {"location": {"col": 9, "file": 7, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_os.h", "reportHash": "fb1e6615e8e39f77e5dbf811cc72ed60", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 8, "line": 13}, "message": "LLVM_OPENMP_RUNTIME_SRC_KMP_PLATFORM_H (fixit)"}, {"location": {"col": 9, "file": 8, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_platform.h", "reportHash": "58b2b03ddf5b6dae0397e7da779c1ba4", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 9, "line": 10}, "message": "LLVM_OPENMP_RUNTIME_SRC_KMP_SAFE_C_API_H (fixit)"}, {"location": {"col": 9, "file": 9, "line": 10}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_safe_c_api.h", "reportHash": "2d907bca196d3e9f2d8bc6e6fa9de4a5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 10, "line": 13}, "message": "LLVM_OPENMP_RUNTIME_SRC_KMP_STR_H (fixit)"}, {"location": {"col": 9, "file": 10, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_str.h", "reportHash": "305bbb1783c32860983d15fcc76c2d27", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 11, "line": 13}, "message": "LLVM_OPENMP_RUNTIME_SRC_KMP_VERSION_H (fixit)"}, {"location": {"col": 9, "file": 11, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_version.h", "reportHash": "57ac2f82e44caef72d2243b33b8c8de4", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 12, "line": 14}, "message": "LLVM_OPENMP_RUNTIME_SRC_KMP_WRAPPER_MALLOC_H (fixit)"}, {"location": {"col": 9, "file": 12, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/kmp_wrapper_malloc.h", "reportHash": "f588a0a9cc4d37ef24f3a4c5b0569626", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 13, "line": 18}, "message": "LLVM_OPENMP_RUNTIME_SRC_OMPT_EVENT_SPECIFIC_H (fixit)"}, {"location": {"col": 9, "file": 13, "line": 18}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/ompt-event-specific.h", "reportHash": "dd0904d8a585755048e5b1f11ebf7712", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 14, "line": 13}, "message": "LLVM_OPENMP_RUNTIME_SRC_OMPT_INTERNAL_H (fixit)"}, {"location": {"col": 9, "file": 14, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/ompt-internal.h", "reportHash": "29d751821df45067c3526150be3aee84", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 15, "line": 13}, "message": "LLVM_OPENMP_RUNTIME_SRC_OMPT_SPECIFIC_H (fixit)"}, {"location": {"col": 9, "file": 15, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/openmp/runtime/src/ompt-specific.h", "reportHash": "8772a865102cbf5b56fe85c46ce6f206", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
