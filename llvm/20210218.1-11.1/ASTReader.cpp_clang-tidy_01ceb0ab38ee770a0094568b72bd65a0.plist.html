<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang/lib/Serialization/ASTReader.cpp", "content": "//===- ASTReader.cpp - AST File Reader ------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the ASTReader class, which reads AST files.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Serialization/ASTRecordReader.h\"\n#include \"ASTCommon.h\"\n#include \"ASTReaderInternals.h\"\n#include \"clang/AST/AbstractTypeReader.h\"\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTMutationListener.h\"\n#include \"clang/AST/ASTUnresolvedSet.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclFriend.h\"\n#include \"clang/AST/DeclGroup.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/OpenMPClause.h\"\n#include \"clang/AST/ODRHash.h\"\n#include \"clang/AST/RawCommentList.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/TemplateName.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/AST/TypeLocVisitor.h\"\n#include \"clang/AST/UnresolvedSet.h\"\n#include \"clang/Basic/CommentOptions.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/DiagnosticOptions.h\"\n#include \"clang/Basic/ExceptionSpecificationType.h\"\n#include \"clang/Basic/FileManager.h\"\n#include \"clang/Basic/FileSystemOptions.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/ObjCRuntime.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/PragmaKinds.h\"\n#include \"clang/Basic/Sanitizers.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/SourceManagerInternals.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Basic/TargetOptions.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"clang/Basic/Version.h\"\n#include \"clang/Lex/HeaderSearch.h\"\n#include \"clang/Lex/HeaderSearchOptions.h\"\n#include \"clang/Lex/MacroInfo.h\"\n#include \"clang/Lex/ModuleMap.h\"\n#include \"clang/Lex/PreprocessingRecord.h\"\n#include \"clang/Lex/Preprocessor.h\"\n#include \"clang/Lex/PreprocessorOptions.h\"\n#include \"clang/Lex/Token.h\"\n#include \"clang/Sema/ObjCMethodList.h\"\n#include \"clang/Sema/Scope.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"clang/Sema/Weak.h\"\n#include \"clang/Serialization/ASTBitCodes.h\"\n#include \"clang/Serialization/ASTDeserializationListener.h\"\n#include \"clang/Serialization/ContinuousRangeMap.h\"\n#include \"clang/Serialization/GlobalModuleIndex.h\"\n#include \"clang/Serialization/InMemoryModuleCache.h\"\n#include \"clang/Serialization/ModuleFile.h\"\n#include \"clang/Serialization/ModuleFileExtension.h\"\n#include \"clang/Serialization/ModuleManager.h\"\n#include \"clang/Serialization/PCHContainerOperations.h\"\n#include \"clang/Serialization/SerializationDiagnostic.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FloatingPointMode.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/ScopeExit.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Bitstream/BitstreamReader.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Compression.h\"\n#include \"llvm/Support/DJB.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/SaveAndRestore.h\"\n#include \"llvm/Support/Timer.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <ctime>\n#include <iterator>\n#include <limits>\n#include <map>\n#include <memory>\n#include <string>\n#include <system_error>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nusing namespace clang;\nusing namespace clang::serialization;\nusing namespace clang::serialization::reader;\nusing llvm::BitstreamCursor;\nusing llvm::RoundingMode;\n\n//===----------------------------------------------------------------------===//\n// ChainedASTReaderListener implementation\n//===----------------------------------------------------------------------===//\n\nbool\nChainedASTReaderListener::ReadFullVersionInformation(StringRef FullVersion) {\n  return First->ReadFullVersionInformation(FullVersion) ||\n         Second->ReadFullVersionInformation(FullVersion);\n}\n\nvoid ChainedASTReaderListener::ReadModuleName(StringRef ModuleName) {\n  First->ReadModuleName(ModuleName);\n  Second->ReadModuleName(ModuleName);\n}\n\nvoid ChainedASTReaderListener::ReadModuleMapFile(StringRef ModuleMapPath) {\n  First->ReadModuleMapFile(ModuleMapPath);\n  Second->ReadModuleMapFile(ModuleMapPath);\n}\n\nbool\nChainedASTReaderListener::ReadLanguageOptions(const LangOptions &LangOpts,\n                                              bool Complain,\n                                              bool AllowCompatibleDifferences) {\n  return First->ReadLanguageOptions(LangOpts, Complain,\n                                    AllowCompatibleDifferences) ||\n         Second->ReadLanguageOptions(LangOpts, Complain,\n                                     AllowCompatibleDifferences);\n}\n\nbool ChainedASTReaderListener::ReadTargetOptions(\n    const TargetOptions &TargetOpts, bool Complain,\n    bool AllowCompatibleDifferences) {\n  return First->ReadTargetOptions(TargetOpts, Complain,\n                                  AllowCompatibleDifferences) ||\n         Second->ReadTargetOptions(TargetOpts, Complain,\n                                   AllowCompatibleDifferences);\n}\n\nbool ChainedASTReaderListener::ReadDiagnosticOptions(\n    IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts, bool Complain) {\n  return First->ReadDiagnosticOptions(DiagOpts, Complain) ||\n         Second->ReadDiagnosticOptions(DiagOpts, Complain);\n}\n\nbool\nChainedASTReaderListener::ReadFileSystemOptions(const FileSystemOptions &FSOpts,\n                                                bool Complain) {\n  return First->ReadFileSystemOptions(FSOpts, Complain) ||\n         Second->ReadFileSystemOptions(FSOpts, Complain);\n}\n\nbool ChainedASTReaderListener::ReadHeaderSearchOptions(\n    const HeaderSearchOptions &HSOpts, StringRef SpecificModuleCachePath,\n    bool Complain) {\n  return First->ReadHeaderSearchOptions(HSOpts, SpecificModuleCachePath,\n                                        Complain) ||\n         Second->ReadHeaderSearchOptions(HSOpts, SpecificModuleCachePath,\n                                         Complain);\n}\n\nbool ChainedASTReaderListener::ReadPreprocessorOptions(\n    const PreprocessorOptions &PPOpts, bool Complain,\n    std::string &SuggestedPredefines) {\n  return First->ReadPreprocessorOptions(PPOpts, Complain,\n                                        SuggestedPredefines) ||\n         Second->ReadPreprocessorOptions(PPOpts, Complain, SuggestedPredefines);\n}\n\nvoid ChainedASTReaderListener::ReadCounter(const serialization::ModuleFile &M,\n                                           unsigned Value) {\n  First->ReadCounter(M, Value);\n  Second->ReadCounter(M, Value);\n}\n\nbool ChainedASTReaderListener::needsInputFileVisitation() {\n  return First->needsInputFileVisitation() ||\n         Second->needsInputFileVisitation();\n}\n\nbool ChainedASTReaderListener::needsSystemInputFileVisitation() {\n  return First->needsSystemInputFileVisitation() ||\n  Second->needsSystemInputFileVisitation();\n}\n\nvoid ChainedASTReaderListener::visitModuleFile(StringRef Filename,\n                                               ModuleKind Kind) {\n  First->visitModuleFile(Filename, Kind);\n  Second->visitModuleFile(Filename, Kind);\n}\n\nbool ChainedASTReaderListener::visitInputFile(StringRef Filename,\n                                              bool isSystem,\n                                              bool isOverridden,\n                                              bool isExplicitModule) {\n  bool Continue = false;\n  if (First->needsInputFileVisitation() &&\n      (!isSystem || First->needsSystemInputFileVisitation()))\n    Continue |= First->visitInputFile(Filename, isSystem, isOverridden,\n                                      isExplicitModule);\n  if (Second->needsInputFileVisitation() &&\n      (!isSystem || Second->needsSystemInputFileVisitation()))\n    Continue |= Second->visitInputFile(Filename, isSystem, isOverridden,\n                                       isExplicitModule);\n  return Continue;\n}\n\nvoid ChainedASTReaderListener::readModuleFileExtension(\n       const ModuleFileExtensionMetadata &Metadata) {\n  First->readModuleFileExtension(Metadata);\n  Second->readModuleFileExtension(Metadata);\n}\n\n//===----------------------------------------------------------------------===//\n// PCH validator implementation\n//===----------------------------------------------------------------------===//\n\nASTReaderListener::~ASTReaderListener() = default;\n\n/// Compare the given set of language options against an existing set of\n/// language options.\n///\n/// \\param Diags If non-NULL, diagnostics will be emitted via this engine.\n/// \\param AllowCompatibleDifferences If true, differences between compatible\n///        language options will be permitted.\n///\n/// \\returns true if the languagae options mis-match, false otherwise.\nstatic bool checkLanguageOptions(const LangOptions &LangOpts,\n                                 const LangOptions &ExistingLangOpts,\n                                 DiagnosticsEngine *Diags,\n                                 bool AllowCompatibleDifferences = true) {\n#define LANGOPT(Name, Bits, Default, Description)                 \\\n  if (ExistingLangOpts.Name != LangOpts.Name) {                   \\\n    if (Diags)                                                    \\\n      Diags->Report(diag::err_pch_langopt_mismatch)               \\\n        << Description << LangOpts.Name << ExistingLangOpts.Name; \\\n    return true;                                                  \\\n  }\n\n#define VALUE_LANGOPT(Name, Bits, Default, Description)   \\\n  if (ExistingLangOpts.Name != LangOpts.Name) {           \\\n    if (Diags)                                            \\\n      Diags->Report(diag::err_pch_langopt_value_mismatch) \\\n        << Description;                                   \\\n    return true;                                          \\\n  }\n\n#define ENUM_LANGOPT(Name, Type, Bits, Default, Description)   \\\n  if (ExistingLangOpts.get##Name() != LangOpts.get##Name()) {  \\\n    if (Diags)                                                 \\\n      Diags->Report(diag::err_pch_langopt_value_mismatch)      \\\n        << Description;                                        \\\n    return true;                                               \\\n  }\n\n#define COMPATIBLE_LANGOPT(Name, Bits, Default, Description)  \\\n  if (!AllowCompatibleDifferences)                            \\\n    LANGOPT(Name, Bits, Default, Description)\n\n#define COMPATIBLE_ENUM_LANGOPT(Name, Bits, Default, Description)  \\\n  if (!AllowCompatibleDifferences)                                 \\\n    ENUM_LANGOPT(Name, Bits, Default, Description)\n\n#define COMPATIBLE_VALUE_LANGOPT(Name, Bits, Default, Description) \\\n  if (!AllowCompatibleDifferences)                                 \\\n    VALUE_LANGOPT(Name, Bits, Default, Description)\n\n#define BENIGN_LANGOPT(Name, Bits, Default, Description)\n#define BENIGN_ENUM_LANGOPT(Name, Type, Bits, Default, Description)\n#define BENIGN_VALUE_LANGOPT(Name, Type, Bits, Default, Description)\n#include \"clang/Basic/LangOptions.def\"\n\n  if (ExistingLangOpts.ModuleFeatures != LangOpts.ModuleFeatures) {\n    if (Diags)\n      Diags->Report(diag::err_pch_langopt_value_mismatch) << \"module features\";\n    return true;\n  }\n\n  if (ExistingLangOpts.ObjCRuntime != LangOpts.ObjCRuntime) {\n    if (Diags)\n      Diags->Report(diag::err_pch_langopt_value_mismatch)\n      << \"target Objective-C runtime\";\n    return true;\n  }\n\n  if (ExistingLangOpts.CommentOpts.BlockCommandNames !=\n      LangOpts.CommentOpts.BlockCommandNames) {\n    if (Diags)\n      Diags->Report(diag::err_pch_langopt_value_mismatch)\n        << \"block command names\";\n    return true;\n  }\n\n  // Sanitizer feature mismatches are treated as compatible differences. If\n  // compatible differences aren't allowed, we still only want to check for\n  // mismatches of non-modular sanitizers (the only ones which can affect AST\n  // generation).\n  if (!AllowCompatibleDifferences) {\n    SanitizerMask ModularSanitizers = getPPTransparentSanitizers();\n    SanitizerSet ExistingSanitizers = ExistingLangOpts.Sanitize;\n    SanitizerSet ImportedSanitizers = LangOpts.Sanitize;\n    ExistingSanitizers.clear(ModularSanitizers);\n    ImportedSanitizers.clear(ModularSanitizers);\n    if (ExistingSanitizers.Mask != ImportedSanitizers.Mask) {\n      const std::string Flag = \"-fsanitize=\";\n      if (Diags) {\n#define SANITIZER(NAME, ID)                                                    \\\n  {                                                                            \\\n    bool InExistingModule = ExistingSanitizers.has(SanitizerKind::ID);         \\\n    bool InImportedModule = ImportedSanitizers.has(SanitizerKind::ID);         \\\n    if (InExistingModule != InImportedModule)                                  \\\n      Diags->Report(diag::err_pch_targetopt_feature_mismatch)                  \\\n          << InExistingModule << (Flag + NAME);                                \\\n  }\n#include \"clang/Basic/Sanitizers.def\"\n      }\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/// Compare the given set of target options against an existing set of\n/// target options.\n///\n/// \\param Diags If non-NULL, diagnostics will be emitted via this engine.\n///\n/// \\returns true if the target options mis-match, false otherwise.\nstatic bool checkTargetOptions(const TargetOptions &TargetOpts,\n                               const TargetOptions &ExistingTargetOpts,\n                               DiagnosticsEngine *Diags,\n                               bool AllowCompatibleDifferences = true) {\n#define CHECK_TARGET_OPT(Field, Name)                             \\\n  if (TargetOpts.Field != ExistingTargetOpts.Field) {             \\\n    if (Diags)                                                    \\\n      Diags->Report(diag::err_pch_targetopt_mismatch)             \\\n        << Name << TargetOpts.Field << ExistingTargetOpts.Field;  \\\n    return true;                                                  \\\n  }\n\n  // The triple and ABI must match exactly.\n  CHECK_TARGET_OPT(Triple, \"target\");\n  CHECK_TARGET_OPT(ABI, \"target ABI\");\n\n  // We can tolerate different CPUs in many cases, notably when one CPU\n  // supports a strict superset of another. When allowing compatible\n  // differences skip this check.\n  if (!AllowCompatibleDifferences) {\n    CHECK_TARGET_OPT(CPU, \"target CPU\");\n    CHECK_TARGET_OPT(TuneCPU, \"tune CPU\");\n  }\n\n#undef CHECK_TARGET_OPT\n\n  // Compare feature sets.\n  SmallVector<StringRef, 4> ExistingFeatures(\n                                             ExistingTargetOpts.FeaturesAsWritten.begin(),\n                                             ExistingTargetOpts.FeaturesAsWritten.end());\n  SmallVector<StringRef, 4> ReadFeatures(TargetOpts.FeaturesAsWritten.begin(),\n                                         TargetOpts.FeaturesAsWritten.end());\n  llvm::sort(ExistingFeatures);\n  llvm::sort(ReadFeatures);\n\n  // We compute the set difference in both directions explicitly so that we can\n  // diagnose the differences differently.\n  SmallVector<StringRef, 4> UnmatchedExistingFeatures, UnmatchedReadFeatures;\n  std::set_difference(\n      ExistingFeatures.begin(), ExistingFeatures.end(), ReadFeatures.begin(),\n      ReadFeatures.end(), std::back_inserter(UnmatchedExistingFeatures));\n  std::set_difference(ReadFeatures.begin(), ReadFeatures.end(),\n                      ExistingFeatures.begin(), ExistingFeatures.end(),\n                      std::back_inserter(UnmatchedReadFeatures));\n\n  // If we are allowing compatible differences and the read feature set is\n  // a strict subset of the existing feature set, there is nothing to diagnose.\n  if (AllowCompatibleDifferences && UnmatchedReadFeatures.empty())\n    return false;\n\n  if (Diags) {\n    for (StringRef Feature : UnmatchedReadFeatures)\n      Diags->Report(diag::err_pch_targetopt_feature_mismatch)\n          << /* is-existing-feature */ false << Feature;\n    for (StringRef Feature : UnmatchedExistingFeatures)\n      Diags->Report(diag::err_pch_targetopt_feature_mismatch)\n          << /* is-existing-feature */ true << Feature;\n  }\n\n  return !UnmatchedReadFeatures.empty() || !UnmatchedExistingFeatures.empty();\n}\n\nbool\nPCHValidator::ReadLanguageOptions(const LangOptions &LangOpts,\n                                  bool Complain,\n                                  bool AllowCompatibleDifferences) {\n  const LangOptions &ExistingLangOpts = PP.getLangOpts();\n  return checkLanguageOptions(LangOpts, ExistingLangOpts,\n                              Complain ? &Reader.Diags : nullptr,\n                              AllowCompatibleDifferences);\n}\n\nbool PCHValidator::ReadTargetOptions(const TargetOptions &TargetOpts,\n                                     bool Complain,\n                                     bool AllowCompatibleDifferences) {\n  const TargetOptions &ExistingTargetOpts = PP.getTargetInfo().getTargetOpts();\n  return checkTargetOptions(TargetOpts, ExistingTargetOpts,\n                            Complain ? &Reader.Diags : nullptr,\n                            AllowCompatibleDifferences);\n}\n\nnamespace {\n\nusing MacroDefinitionsMap =\n    llvm::StringMap<std::pair<StringRef, bool /*IsUndef*/>>;\nusing DeclsMap = llvm::DenseMap<DeclarationName, SmallVector<NamedDecl *, 8>>;\n\n} // namespace\n\nstatic bool checkDiagnosticGroupMappings(DiagnosticsEngine &StoredDiags,\n                                         DiagnosticsEngine &Diags,\n                                         bool Complain) {\n  using Level = DiagnosticsEngine::Level;\n\n  // Check current mappings for new -Werror mappings, and the stored mappings\n  // for cases that were explicitly mapped to *not* be errors that are now\n  // errors because of options like -Werror.\n  DiagnosticsEngine *MappingSources[] = { &Diags, &StoredDiags };\n\n  for (DiagnosticsEngine *MappingSource : MappingSources) {\n    for (auto DiagIDMappingPair : MappingSource->getDiagnosticMappings()) {\n      diag::kind DiagID = DiagIDMappingPair.first;\n      Level CurLevel = Diags.getDiagnosticLevel(DiagID, SourceLocation());\n      if (CurLevel < DiagnosticsEngine::Error)\n        continue; // not significant\n      Level StoredLevel =\n          StoredDiags.getDiagnosticLevel(DiagID, SourceLocation());\n      if (StoredLevel < DiagnosticsEngine::Error) {\n        if (Complain)\n          Diags.Report(diag::err_pch_diagopt_mismatch) << \"-Werror=\" +\n              Diags.getDiagnosticIDs()->getWarningOptionForDiag(DiagID).str();\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nstatic bool isExtHandlingFromDiagsError(DiagnosticsEngine &Diags) {\n  diag::Severity Ext = Diags.getExtensionHandlingBehavior();\n  if (Ext == diag::Severity::Warning && Diags.getWarningsAsErrors())\n    return true;\n  return Ext >= diag::Severity::Error;\n}\n\nstatic bool checkDiagnosticMappings(DiagnosticsEngine &StoredDiags,\n                                    DiagnosticsEngine &Diags,\n                                    bool IsSystem, bool Complain) {\n  // Top-level options\n  if (IsSystem) {\n    if (Diags.getSuppressSystemWarnings())\n      return false;\n    // If -Wsystem-headers was not enabled before, be conservative\n    if (StoredDiags.getSuppressSystemWarnings()) {\n      if (Complain)\n        Diags.Report(diag::err_pch_diagopt_mismatch) << \"-Wsystem-headers\";\n      return true;\n    }\n  }\n\n  if (Diags.getWarningsAsErrors() && !StoredDiags.getWarningsAsErrors()) {\n    if (Complain)\n      Diags.Report(diag::err_pch_diagopt_mismatch) << \"-Werror\";\n    return true;\n  }\n\n  if (Diags.getWarningsAsErrors() && Diags.getEnableAllWarnings() &&\n      !StoredDiags.getEnableAllWarnings()) {\n    if (Complain)\n      Diags.Report(diag::err_pch_diagopt_mismatch) << \"-Weverything -Werror\";\n    return true;\n  }\n\n  if (isExtHandlingFromDiagsError(Diags) &&\n      !isExtHandlingFromDiagsError(StoredDiags)) {\n    if (Complain)\n      Diags.Report(diag::err_pch_diagopt_mismatch) << \"-pedantic-errors\";\n    return true;\n  }\n\n  return checkDiagnosticGroupMappings(StoredDiags, Diags, Complain);\n}\n\n/// Return the top import module if it is implicit, nullptr otherwise.\nstatic Module *getTopImportImplicitModule(ModuleManager &ModuleMgr,\n                                          Preprocessor &PP) {\n  // If the original import came from a file explicitly generated by the user,\n  // don't check the diagnostic mappings.\n  // FIXME: currently this is approximated by checking whether this is not a\n  // module import of an implicitly-loaded module file.\n  // Note: ModuleMgr.rbegin() may not be the current module, but it must be in\n  // the transitive closure of its imports, since unrelated modules cannot be\n  // imported until after this module finishes validation.\n  ModuleFile *TopImport = &*ModuleMgr.rbegin();\n  while (!TopImport->ImportedBy.empty())\n    TopImport = TopImport->ImportedBy[0];\n  if (TopImport->Kind != MK_ImplicitModule)\n    return nullptr;\n\n  StringRef ModuleName = TopImport->ModuleName;\n  assert(!ModuleName.empty() && \"diagnostic options read before module name\");\n\n  Module *M = PP.getHeaderSearchInfo().lookupModule(ModuleName);\n  assert(M && \"missing module\");\n  return M;\n}\n\nbool PCHValidator::ReadDiagnosticOptions(\n    IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts, bool Complain) {\n  DiagnosticsEngine &ExistingDiags = PP.getDiagnostics();\n  IntrusiveRefCntPtr<DiagnosticIDs> DiagIDs(ExistingDiags.getDiagnosticIDs());\n  IntrusiveRefCntPtr<DiagnosticsEngine> Diags(\n      new DiagnosticsEngine(DiagIDs, DiagOpts.get()));\n  // This should never fail, because we would have processed these options\n  // before writing them to an ASTFile.\n  ProcessWarningOptions(*Diags, *DiagOpts, /*Report*/false);\n\n  ModuleManager &ModuleMgr = Reader.getModuleManager();\n  assert(ModuleMgr.size() >= 1 && \"what ASTFile is this then\");\n\n  Module *TopM = getTopImportImplicitModule(ModuleMgr, PP);\n  if (!TopM)\n    return false;\n\n  // FIXME: if the diagnostics are incompatible, save a DiagnosticOptions that\n  // contains the union of their flags.\n  return checkDiagnosticMappings(*Diags, ExistingDiags, TopM->IsSystem,\n                                 Complain);\n}\n\n/// Collect the macro definitions provided by the given preprocessor\n/// options.\nstatic void\ncollectMacroDefinitions(const PreprocessorOptions &PPOpts,\n                        MacroDefinitionsMap &Macros,\n                        SmallVectorImpl<StringRef> *MacroNames = nullptr) {\n  for (unsigned I = 0, N = PPOpts.Macros.size(); I != N; ++I) {\n    StringRef Macro = PPOpts.Macros[I].first;\n    bool IsUndef = PPOpts.Macros[I].second;\n\n    std::pair<StringRef, StringRef> MacroPair = Macro.split('=');\n    StringRef MacroName = MacroPair.first;\n    StringRef MacroBody = MacroPair.second;\n\n    // For an #undef'd macro, we only care about the name.\n    if (IsUndef) {\n      if (MacroNames && !Macros.count(MacroName))\n        MacroNames->push_back(MacroName);\n\n      Macros[MacroName] = std::make_pair(\"\", true);\n      continue;\n    }\n\n    // For a #define'd macro, figure out the actual definition.\n    if (MacroName.size() == Macro.size())\n      MacroBody = \"1\";\n    else {\n      // Note: GCC drops anything following an end-of-line character.\n      StringRef::size_type End = MacroBody.find_first_of(\"\\n\\r\");\n      MacroBody = MacroBody.substr(0, End);\n    }\n\n    if (MacroNames && !Macros.count(MacroName))\n      MacroNames->push_back(MacroName);\n    Macros[MacroName] = std::make_pair(MacroBody, false);\n  }\n}\n\n/// Check the preprocessor options deserialized from the control block\n/// against the preprocessor options in an existing preprocessor.\n///\n/// \\param Diags If non-null, produce diagnostics for any mismatches incurred.\n/// \\param Validate If true, validate preprocessor options. If false, allow\n///        macros defined by \\p ExistingPPOpts to override those defined by\n///        \\p PPOpts in SuggestedPredefines.\nstatic bool checkPreprocessorOptions(const PreprocessorOptions &PPOpts,\n                                     const PreprocessorOptions &ExistingPPOpts,\n                                     DiagnosticsEngine *Diags,\n                                     FileManager &FileMgr,\n                                     std::string &SuggestedPredefines,\n                                     const LangOptions &LangOpts,\n                                     bool Validate = true) {\n  // Check macro definitions.\n  MacroDefinitionsMap ASTFileMacros;\n  collectMacroDefinitions(PPOpts, ASTFileMacros);\n  MacroDefinitionsMap ExistingMacros;\n  SmallVector<StringRef, 4> ExistingMacroNames;\n  collectMacroDefinitions(ExistingPPOpts, ExistingMacros, &ExistingMacroNames);\n\n  for (unsigned I = 0, N = ExistingMacroNames.size(); I != N; ++I) {\n    // Dig out the macro definition in the existing preprocessor options.\n    StringRef MacroName = ExistingMacroNames[I];\n    std::pair<StringRef, bool> Existing = ExistingMacros[MacroName];\n\n    // Check whether we know anything about this macro name or not.\n    llvm::StringMap<std::pair<StringRef, bool /*IsUndef*/>>::iterator Known =\n        ASTFileMacros.find(MacroName);\n    if (!Validate || Known == ASTFileMacros.end()) {\n      // FIXME: Check whether this identifier was referenced anywhere in the\n      // AST file. If so, we should reject the AST file. Unfortunately, this\n      // information isn't in the control block. What shall we do about it?\n\n      if (Existing.second) {\n        SuggestedPredefines += \"#undef \";\n        SuggestedPredefines += MacroName.str();\n        SuggestedPredefines += '\\n';\n      } else {\n        SuggestedPredefines += \"#define \";\n        SuggestedPredefines += MacroName.str();\n        SuggestedPredefines += ' ';\n        SuggestedPredefines += Existing.first.str();\n        SuggestedPredefines += '\\n';\n      }\n      continue;\n    }\n\n    // If the macro was defined in one but undef'd in the other, we have a\n    // conflict.\n    if (Existing.second != Known->second.second) {\n      if (Diags) {\n        Diags->Report(diag::err_pch_macro_def_undef)\n          << MacroName << Known->second.second;\n      }\n      return true;\n    }\n\n    // If the macro was #undef'd in both, or if the macro bodies are identical,\n    // it's fine.\n    if (Existing.second || Existing.first == Known->second.first)\n      continue;\n\n    // The macro bodies differ; complain.\n    if (Diags) {\n      Diags->Report(diag::err_pch_macro_def_conflict)\n        << MacroName << Known->second.first << Existing.first;\n    }\n    return true;\n  }\n\n  // Check whether we're using predefines.\n  if (PPOpts.UsePredefines != ExistingPPOpts.UsePredefines && Validate) {\n    if (Diags) {\n      Diags->Report(diag::err_pch_undef) << ExistingPPOpts.UsePredefines;\n    }\n    return true;\n  }\n\n  // Detailed record is important since it is used for the module cache hash.\n  if (LangOpts.Modules &&\n      PPOpts.DetailedRecord != ExistingPPOpts.DetailedRecord && Validate) {\n    if (Diags) {\n      Diags->Report(diag::err_pch_pp_detailed_record) << PPOpts.DetailedRecord;\n    }\n    return true;\n  }\n\n  // Compute the #include and #include_macros lines we need.\n  for (unsigned I = 0, N = ExistingPPOpts.Includes.size(); I != N; ++I) {\n    StringRef File = ExistingPPOpts.Includes[I];\n\n    if (!ExistingPPOpts.ImplicitPCHInclude.empty() &&\n        !ExistingPPOpts.PCHThroughHeader.empty()) {\n      // In case the through header is an include, we must add all the includes\n      // to the predefines so the start point can be determined.\n      SuggestedPredefines += \"#include \\\"\";\n      SuggestedPredefines += File;\n      SuggestedPredefines += \"\\\"\\n\";\n      continue;\n    }\n\n    if (File == ExistingPPOpts.ImplicitPCHInclude)\n      continue;\n\n    if (std::find(PPOpts.Includes.begin(), PPOpts.Includes.end(), File)\n          != PPOpts.Includes.end())\n      continue;\n\n    SuggestedPredefines += \"#include \\\"\";\n    SuggestedPredefines += File;\n    SuggestedPredefines += \"\\\"\\n\";\n  }\n\n  for (unsigned I = 0, N = ExistingPPOpts.MacroIncludes.size(); I != N; ++I) {\n    StringRef File = ExistingPPOpts.MacroIncludes[I];\n    if (std::find(PPOpts.MacroIncludes.begin(), PPOpts.MacroIncludes.end(),\n                  File)\n        != PPOpts.MacroIncludes.end())\n      continue;\n\n    SuggestedPredefines += \"#__include_macros \\\"\";\n    SuggestedPredefines += File;\n    SuggestedPredefines += \"\\\"\\n##\\n\";\n  }\n\n  return false;\n}\n\nbool PCHValidator::ReadPreprocessorOptions(const PreprocessorOptions &PPOpts,\n                                           bool Complain,\n                                           std::string &SuggestedPredefines) {\n  const PreprocessorOptions &ExistingPPOpts = PP.getPreprocessorOpts();\n\n  return checkPreprocessorOptions(PPOpts, ExistingPPOpts,\n                                  Complain? &Reader.Diags : nullptr,\n                                  PP.getFileManager(),\n                                  SuggestedPredefines,\n                                  PP.getLangOpts());\n}\n\nbool SimpleASTReaderListener::ReadPreprocessorOptions(\n                                  const PreprocessorOptions &PPOpts,\n                                  bool Complain,\n                                  std::string &SuggestedPredefines) {\n  return checkPreprocessorOptions(PPOpts,\n                                  PP.getPreprocessorOpts(),\n                                  nullptr,\n                                  PP.getFileManager(),\n                                  SuggestedPredefines,\n                                  PP.getLangOpts(),\n                                  false);\n}\n\n/// Check the header search options deserialized from the control block\n/// against the header search options in an existing preprocessor.\n///\n/// \\param Diags If non-null, produce diagnostics for any mismatches incurred.\nstatic bool checkHeaderSearchOptions(const HeaderSearchOptions &HSOpts,\n                                     StringRef SpecificModuleCachePath,\n                                     StringRef ExistingModuleCachePath,\n                                     DiagnosticsEngine *Diags,\n                                     const LangOptions &LangOpts) {\n  if (LangOpts.Modules) {\n    if (SpecificModuleCachePath != ExistingModuleCachePath) {\n      if (Diags)\n        Diags->Report(diag::err_pch_modulecache_mismatch)\n          << SpecificModuleCachePath << ExistingModuleCachePath;\n      return true;\n    }\n  }\n\n  return false;\n}\n\nbool PCHValidator::ReadHeaderSearchOptions(const HeaderSearchOptions &HSOpts,\n                                           StringRef SpecificModuleCachePath,\n                                           bool Complain) {\n  return checkHeaderSearchOptions(HSOpts, SpecificModuleCachePath,\n                                  PP.getHeaderSearchInfo().getModuleCachePath(),\n                                  Complain ? &Reader.Diags : nullptr,\n                                  PP.getLangOpts());\n}\n\nvoid PCHValidator::ReadCounter(const ModuleFile &M, unsigned Value) {\n  PP.setCounterValue(Value);\n}\n\n//===----------------------------------------------------------------------===//\n// AST reader implementation\n//===----------------------------------------------------------------------===//\n\nvoid ASTReader::setDeserializationListener(ASTDeserializationListener *Listener,\n                                           bool TakeOwnership) {\n  DeserializationListener = Listener;\n  OwnsDeserializationListener = TakeOwnership;\n}\n\nunsigned ASTSelectorLookupTrait::ComputeHash(Selector Sel) {\n  return serialization::ComputeHash(Sel);\n}\n\nstd::pair<unsigned, unsigned>\nASTSelectorLookupTrait::ReadKeyDataLength(const unsigned char*& d) {\n  using namespace llvm::support;\n\n  unsigned KeyLen = endian::readNext<uint16_t, little, unaligned>(d);\n  unsigned DataLen = endian::readNext<uint16_t, little, unaligned>(d);\n  return std::make_pair(KeyLen, DataLen);\n}\n\nASTSelectorLookupTrait::internal_key_type\nASTSelectorLookupTrait::ReadKey(const unsigned char* d, unsigned) {\n  using namespace llvm::support;\n\n  SelectorTable &SelTable = Reader.getContext().Selectors;\n  unsigned N = endian::readNext<uint16_t, little, unaligned>(d);\n  IdentifierInfo *FirstII = Reader.getLocalIdentifier(\n      F, endian::readNext<uint32_t, little, unaligned>(d));\n  if (N == 0)\n    return SelTable.getNullarySelector(FirstII);\n  else if (N == 1)\n    return SelTable.getUnarySelector(FirstII);\n\n  SmallVector<IdentifierInfo *, 16> Args;\n  Args.push_back(FirstII);\n  for (unsigned I = 1; I != N; ++I)\n    Args.push_back(Reader.getLocalIdentifier(\n        F, endian::readNext<uint32_t, little, unaligned>(d)));\n\n  return SelTable.getSelector(N, Args.data());\n}\n\nASTSelectorLookupTrait::data_type\nASTSelectorLookupTrait::ReadData(Selector, const unsigned char* d,\n                                 unsigned DataLen) {\n  using namespace llvm::support;\n\n  data_type Result;\n\n  Result.ID = Reader.getGlobalSelectorID(\n      F, endian::readNext<uint32_t, little, unaligned>(d));\n  unsigned FullInstanceBits = endian::readNext<uint16_t, little, unaligned>(d);\n  unsigned FullFactoryBits = endian::readNext<uint16_t, little, unaligned>(d);\n  Result.InstanceBits = FullInstanceBits & 0x3;\n  Result.InstanceHasMoreThanOneDecl = (FullInstanceBits >> 2) & 0x1;\n  Result.FactoryBits = FullFactoryBits & 0x3;\n  Result.FactoryHasMoreThanOneDecl = (FullFactoryBits >> 2) & 0x1;\n  unsigned NumInstanceMethods = FullInstanceBits >> 3;\n  unsigned NumFactoryMethods = FullFactoryBits >> 3;\n\n  // Load instance methods\n  for (unsigned I = 0; I != NumInstanceMethods; ++I) {\n    if (ObjCMethodDecl *Method = Reader.GetLocalDeclAs<ObjCMethodDecl>(\n            F, endian::readNext<uint32_t, little, unaligned>(d)))\n      Result.Instance.push_back(Method);\n  }\n\n  // Load factory methods\n  for (unsigned I = 0; I != NumFactoryMethods; ++I) {\n    if (ObjCMethodDecl *Method = Reader.GetLocalDeclAs<ObjCMethodDecl>(\n            F, endian::readNext<uint32_t, little, unaligned>(d)))\n      Result.Factory.push_back(Method);\n  }\n\n  return Result;\n}\n\nunsigned ASTIdentifierLookupTraitBase::ComputeHash(const internal_key_type& a) {\n  return llvm::djbHash(a);\n}\n\nstd::pair<unsigned, unsigned>\nASTIdentifierLookupTraitBase::ReadKeyDataLength(const unsigned char*& d) {\n  using namespace llvm::support;\n\n  unsigned DataLen = endian::readNext<uint16_t, little, unaligned>(d);\n  unsigned KeyLen = endian::readNext<uint16_t, little, unaligned>(d);\n  return std::make_pair(KeyLen, DataLen);\n}\n\nASTIdentifierLookupTraitBase::internal_key_type\nASTIdentifierLookupTraitBase::ReadKey(const unsigned char* d, unsigned n) {\n  assert(n >= 2 && d[n-1] == '\\0');\n  return StringRef((const char*) d, n-1);\n}\n\n/// Whether the given identifier is \"interesting\".\nstatic bool isInterestingIdentifier(ASTReader &Reader, IdentifierInfo &II,\n                                    bool IsModule) {\n  return II.hadMacroDefinition() || II.isPoisoned() ||\n         (!IsModule && II.getObjCOrBuiltinID()) ||\n         II.hasRevertedTokenIDToIdentifier() ||\n         (!(IsModule && Reader.getPreprocessor().getLangOpts().CPlusPlus) &&\n          II.getFETokenInfo());\n}\n\nstatic bool readBit(unsigned &Bits) {\n  bool Value = Bits & 0x1;\n  Bits >>= 1;\n  return Value;\n}\n\nIdentID ASTIdentifierLookupTrait::ReadIdentifierID(const unsigned char *d) {\n  using namespace llvm::support;\n\n  unsigned RawID = endian::readNext<uint32_t, little, unaligned>(d);\n  return Reader.getGlobalIdentifierID(F, RawID >> 1);\n}\n\nstatic void markIdentifierFromAST(ASTReader &Reader, IdentifierInfo &II) {\n  if (!II.isFromAST()) {\n    II.setIsFromAST();\n    bool IsModule = Reader.getPreprocessor().getCurrentModule() != nullptr;\n    if (isInterestingIdentifier(Reader, II, IsModule))\n      II.setChangedSinceDeserialization();\n  }\n}\n\nIdentifierInfo *ASTIdentifierLookupTrait::ReadData(const internal_key_type& k,\n                                                   const unsigned char* d,\n                                                   unsigned DataLen) {\n  using namespace llvm::support;\n\n  unsigned RawID = endian::readNext<uint32_t, little, unaligned>(d);\n  bool IsInteresting = RawID & 0x01;\n\n  // Wipe out the \"is interesting\" bit.\n  RawID = RawID >> 1;\n\n  // Build the IdentifierInfo and link the identifier ID with it.\n  IdentifierInfo *II = KnownII;\n  if (!II) {\n    II = &Reader.getIdentifierTable().getOwn(k);\n    KnownII = II;\n  }\n  markIdentifierFromAST(Reader, *II);\n  Reader.markIdentifierUpToDate(II);\n\n  IdentID ID = Reader.getGlobalIdentifierID(F, RawID);\n  if (!IsInteresting) {\n    // For uninteresting identifiers, there's nothing else to do. Just notify\n    // the reader that we've finished loading this identifier.\n    Reader.SetIdentifierInfo(ID, II);\n    return II;\n  }\n\n  unsigned ObjCOrBuiltinID = endian::readNext<uint16_t, little, unaligned>(d);\n  unsigned Bits = endian::readNext<uint16_t, little, unaligned>(d);\n  bool CPlusPlusOperatorKeyword = readBit(Bits);\n  bool HasRevertedTokenIDToIdentifier = readBit(Bits);\n  bool Poisoned = readBit(Bits);\n  bool ExtensionToken = readBit(Bits);\n  bool HadMacroDefinition = readBit(Bits);\n\n  assert(Bits == 0 && \"Extra bits in the identifier?\");\n  DataLen -= 8;\n\n  // Set or check the various bits in the IdentifierInfo structure.\n  // Token IDs are read-only.\n  if (HasRevertedTokenIDToIdentifier && II->getTokenID() != tok::identifier)\n    II->revertTokenIDToIdentifier();\n  if (!F.isModule())\n    II->setObjCOrBuiltinID(ObjCOrBuiltinID);\n  assert(II->isExtensionToken() == ExtensionToken &&\n         \"Incorrect extension token flag\");\n  (void)ExtensionToken;\n  if (Poisoned)\n    II->setIsPoisoned(true);\n  assert(II->isCPlusPlusOperatorKeyword() == CPlusPlusOperatorKeyword &&\n         \"Incorrect C++ operator keyword flag\");\n  (void)CPlusPlusOperatorKeyword;\n\n  // If this identifier is a macro, deserialize the macro\n  // definition.\n  if (HadMacroDefinition) {\n    uint32_t MacroDirectivesOffset =\n        endian::readNext<uint32_t, little, unaligned>(d);\n    DataLen -= 4;\n\n    Reader.addPendingMacro(II, &F, MacroDirectivesOffset);\n  }\n\n  Reader.SetIdentifierInfo(ID, II);\n\n  // Read all of the declarations visible at global scope with this\n  // name.\n  if (DataLen > 0) {\n    SmallVector<uint32_t, 4> DeclIDs;\n    for (; DataLen > 0; DataLen -= 4)\n      DeclIDs.push_back(Reader.getGlobalDeclID(\n          F, endian::readNext<uint32_t, little, unaligned>(d)));\n    Reader.SetGloballyVisibleDecls(II, DeclIDs);\n  }\n\n  return II;\n}\n\nDeclarationNameKey::DeclarationNameKey(DeclarationName Name)\n    : Kind(Name.getNameKind()) {\n  switch (Kind) {\n  case DeclarationName::Identifier:\n    Data = (uint64_t)Name.getAsIdentifierInfo();\n    break;\n  case DeclarationName::ObjCZeroArgSelector:\n  case DeclarationName::ObjCOneArgSelector:\n  case DeclarationName::ObjCMultiArgSelector:\n    Data = (uint64_t)Name.getObjCSelector().getAsOpaquePtr();\n    break;\n  case DeclarationName::CXXOperatorName:\n    Data = Name.getCXXOverloadedOperator();\n    break;\n  case DeclarationName::CXXLiteralOperatorName:\n    Data = (uint64_t)Name.getCXXLiteralIdentifier();\n    break;\n  case DeclarationName::CXXDeductionGuideName:\n    Data = (uint64_t)Name.getCXXDeductionGuideTemplate()\n               ->getDeclName().getAsIdentifierInfo();\n    break;\n  case DeclarationName::CXXConstructorName:\n  case DeclarationName::CXXDestructorName:\n  case DeclarationName::CXXConversionFunctionName:\n  case DeclarationName::CXXUsingDirective:\n    Data = 0;\n    break;\n  }\n}\n\nunsigned DeclarationNameKey::getHash() const {\n  llvm::FoldingSetNodeID ID;\n  ID.AddInteger(Kind);\n\n  switch (Kind) {\n  case DeclarationName::Identifier:\n  case DeclarationName::CXXLiteralOperatorName:\n  case DeclarationName::CXXDeductionGuideName:\n    ID.AddString(((IdentifierInfo*)Data)->getName());\n    break;\n  case DeclarationName::ObjCZeroArgSelector:\n  case DeclarationName::ObjCOneArgSelector:\n  case DeclarationName::ObjCMultiArgSelector:\n    ID.AddInteger(serialization::ComputeHash(Selector(Data)));\n    break;\n  case DeclarationName::CXXOperatorName:\n    ID.AddInteger((OverloadedOperatorKind)Data);\n    break;\n  case DeclarationName::CXXConstructorName:\n  case DeclarationName::CXXDestructorName:\n  case DeclarationName::CXXConversionFunctionName:\n  case DeclarationName::CXXUsingDirective:\n    break;\n  }\n\n  return ID.ComputeHash();\n}\n\nModuleFile *\nASTDeclContextNameLookupTrait::ReadFileRef(const unsigned char *&d) {\n  using namespace llvm::support;\n\n  uint32_t ModuleFileID = endian::readNext<uint32_t, little, unaligned>(d);\n  return Reader.getLocalModuleFile(F, ModuleFileID);\n}\n\nstd::pair<unsigned, unsigned>\nASTDeclContextNameLookupTrait::ReadKeyDataLength(const unsigned char *&d) {\n  using namespace llvm::support;\n\n  unsigned KeyLen = endian::readNext<uint16_t, little, unaligned>(d);\n  unsigned DataLen = endian::readNext<uint16_t, little, unaligned>(d);\n  return std::make_pair(KeyLen, DataLen);\n}\n\nASTDeclContextNameLookupTrait::internal_key_type\nASTDeclContextNameLookupTrait::ReadKey(const unsigned char *d, unsigned) {\n  using namespace llvm::support;\n\n  auto Kind = (DeclarationName::NameKind)*d++;\n  uint64_t Data;\n  switch (Kind) {\n  case DeclarationName::Identifier:\n  case DeclarationName::CXXLiteralOperatorName:\n  case DeclarationName::CXXDeductionGuideName:\n    Data = (uint64_t)Reader.getLocalIdentifier(\n        F, endian::readNext<uint32_t, little, unaligned>(d));\n    break;\n  case DeclarationName::ObjCZeroArgSelector:\n  case DeclarationName::ObjCOneArgSelector:\n  case DeclarationName::ObjCMultiArgSelector:\n    Data =\n        (uint64_t)Reader.getLocalSelector(\n                             F, endian::readNext<uint32_t, little, unaligned>(\n                                    d)).getAsOpaquePtr();\n    break;\n  case DeclarationName::CXXOperatorName:\n    Data = *d++; // OverloadedOperatorKind\n    break;\n  case DeclarationName::CXXConstructorName:\n  case DeclarationName::CXXDestructorName:\n  case DeclarationName::CXXConversionFunctionName:\n  case DeclarationName::CXXUsingDirective:\n    Data = 0;\n    break;\n  }\n\n  return DeclarationNameKey(Kind, Data);\n}\n\nvoid ASTDeclContextNameLookupTrait::ReadDataInto(internal_key_type,\n                                                 const unsigned char *d,\n                                                 unsigned DataLen,\n                                                 data_type_builder &Val) {\n  using namespace llvm::support;\n\n  for (unsigned NumDecls = DataLen / 4; NumDecls; --NumDecls) {\n    uint32_t LocalID = endian::readNext<uint32_t, little, unaligned>(d);\n    Val.insert(Reader.getGlobalDeclID(F, LocalID));\n  }\n}\n\nbool ASTReader::ReadLexicalDeclContextStorage(ModuleFile &M,\n                                              BitstreamCursor &Cursor,\n                                              uint64_t Offset,\n                                              DeclContext *DC) {\n  assert(Offset != 0);\n\n  SavedStreamPosition SavedPosition(Cursor);\n  if (llvm::Error Err = Cursor.JumpToBit(Offset)) {\n    Error(std::move(Err));\n    return true;\n  }\n\n  RecordData Record;\n  StringRef Blob;\n  Expected<unsigned> MaybeCode = Cursor.ReadCode();\n  if (!MaybeCode) {\n    Error(MaybeCode.takeError());\n    return true;\n  }\n  unsigned Code = MaybeCode.get();\n\n  Expected<unsigned> MaybeRecCode = Cursor.readRecord(Code, Record, &Blob);\n  if (!MaybeRecCode) {\n    Error(MaybeRecCode.takeError());\n    return true;\n  }\n  unsigned RecCode = MaybeRecCode.get();\n  if (RecCode != DECL_CONTEXT_LEXICAL) {\n    Error(\"Expected lexical block\");\n    return true;\n  }\n\n  assert(!isa<TranslationUnitDecl>(DC) &&\n         \"expected a TU_UPDATE_LEXICAL record for TU\");\n  // If we are handling a C++ class template instantiation, we can see multiple\n  // lexical updates for the same record. It's important that we select only one\n  // of them, so that field numbering works properly. Just pick the first one we\n  // see.\n  auto &Lex = LexicalDecls[DC];\n  if (!Lex.first) {\n    Lex = std::make_pair(\n        &M, llvm::makeArrayRef(\n                reinterpret_cast<const llvm::support::unaligned_uint32_t *>(\n                    Blob.data()),\n                Blob.size() / 4));\n  }\n  DC->setHasExternalLexicalStorage(true);\n  return false;\n}\n\nbool ASTReader::ReadVisibleDeclContextStorage(ModuleFile &M,\n                                              BitstreamCursor &Cursor,\n                                              uint64_t Offset,\n                                              DeclID ID) {\n  assert(Offset != 0);\n\n  SavedStreamPosition SavedPosition(Cursor);\n  if (llvm::Error Err = Cursor.JumpToBit(Offset)) {\n    Error(std::move(Err));\n    return true;\n  }\n\n  RecordData Record;\n  StringRef Blob;\n  Expected<unsigned> MaybeCode = Cursor.ReadCode();\n  if (!MaybeCode) {\n    Error(MaybeCode.takeError());\n    return true;\n  }\n  unsigned Code = MaybeCode.get();\n\n  Expected<unsigned> MaybeRecCode = Cursor.readRecord(Code, Record, &Blob);\n  if (!MaybeRecCode) {\n    Error(MaybeRecCode.takeError());\n    return true;\n  }\n  unsigned RecCode = MaybeRecCode.get();\n  if (RecCode != DECL_CONTEXT_VISIBLE) {\n    Error(\"Expected visible lookup table block\");\n    return true;\n  }\n\n  // We can't safely determine the primary context yet, so delay attaching the\n  // lookup table until we're done with recursive deserialization.\n  auto *Data = (const unsigned char*)Blob.data();\n  PendingVisibleUpdates[ID].push_back(PendingVisibleUpdate{&M, Data});\n  return false;\n}\n\nvoid ASTReader::Error(StringRef Msg) const {\n  Error(diag::err_fe_pch_malformed, Msg);\n  if (PP.getLangOpts().Modules && !Diags.isDiagnosticInFlight() &&\n      !PP.getHeaderSearchInfo().getModuleCachePath().empty()) {\n    Diag(diag::note_module_cache_path)\n      << PP.getHeaderSearchInfo().getModuleCachePath();\n  }\n}\n\nvoid ASTReader::Error(unsigned DiagID, StringRef Arg1, StringRef Arg2,\n                      StringRef Arg3) const {\n  if (Diags.isDiagnosticInFlight())\n    Diags.SetDelayedDiagnostic(DiagID, Arg1, Arg2, Arg3);\n  else\n    Diag(DiagID) << Arg1 << Arg2 << Arg3;\n}\n\nvoid ASTReader::Error(llvm::Error &&Err) const {\n  Error(toString(std::move(Err)));\n}\n\n//===----------------------------------------------------------------------===//\n// Source Manager Deserialization\n//===----------------------------------------------------------------------===//\n\n/// Read the line table in the source manager block.\n/// \\returns true if there was an error.\nbool ASTReader::ParseLineTable(ModuleFile &F,\n                               const RecordData &Record) {\n  unsigned Idx = 0;\n  LineTableInfo &LineTable = SourceMgr.getLineTable();\n\n  // Parse the file names\n  std::map<int, int> FileIDs;\n  FileIDs[-1] = -1; // For unspecified filenames.\n  for (unsigned I = 0; Record[Idx]; ++I) {\n    // Extract the file name\n    auto Filename = ReadPath(F, Record, Idx);\n    FileIDs[I] = LineTable.getLineTableFilenameID(Filename);\n  }\n  ++Idx;\n\n  // Parse the line entries\n  std::vector<LineEntry> Entries;\n  while (Idx < Record.size()) {\n    int FID = Record[Idx++];\n    assert(FID >= 0 && \"Serialized line entries for non-local file.\");\n    // Remap FileID from 1-based old view.\n    FID += F.SLocEntryBaseID - 1;\n\n    // Extract the line entries\n    unsigned NumEntries = Record[Idx++];\n    assert(NumEntries && \"no line entries for file ID\");\n    Entries.clear();\n    Entries.reserve(NumEntries);\n    for (unsigned I = 0; I != NumEntries; ++I) {\n      unsigned FileOffset = Record[Idx++];\n      unsigned LineNo = Record[Idx++];\n      int FilenameID = FileIDs[Record[Idx++]];\n      SrcMgr::CharacteristicKind FileKind\n        = (SrcMgr::CharacteristicKind)Record[Idx++];\n      unsigned IncludeOffset = Record[Idx++];\n      Entries.push_back(LineEntry::get(FileOffset, LineNo, FilenameID,\n                                       FileKind, IncludeOffset));\n    }\n    LineTable.AddEntry(FileID::get(FID), Entries);\n  }\n\n  return false;\n}\n\n/// Read a source manager block\nbool ASTReader::ReadSourceManagerBlock(ModuleFile &F) {\n  using namespace SrcMgr;\n\n  BitstreamCursor &SLocEntryCursor = F.SLocEntryCursor;\n\n  // Set the source-location entry cursor to the current position in\n  // the stream. This cursor will be used to read the contents of the\n  // source manager block initially, and then lazily read\n  // source-location entries as needed.\n  SLocEntryCursor = F.Stream;\n\n  // The stream itself is going to skip over the source manager block.\n  if (llvm::Error Err = F.Stream.SkipBlock()) {\n    Error(std::move(Err));\n    return true;\n  }\n\n  // Enter the source manager block.\n  if (llvm::Error Err =\n          SLocEntryCursor.EnterSubBlock(SOURCE_MANAGER_BLOCK_ID)) {\n    Error(std::move(Err));\n    return true;\n  }\n  F.SourceManagerBlockStartOffset = SLocEntryCursor.GetCurrentBitNo();\n\n  RecordData Record;\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeE =\n        SLocEntryCursor.advanceSkippingSubblocks();\n    if (!MaybeE) {\n      Error(MaybeE.takeError());\n      return true;\n    }\n    llvm::BitstreamEntry E = MaybeE.get();\n\n    switch (E.Kind) {\n    case llvm::BitstreamEntry::SubBlock: // Handled for us already.\n    case llvm::BitstreamEntry::Error:\n      Error(\"malformed block record in AST file\");\n      return true;\n    case llvm::BitstreamEntry::EndBlock:\n      return false;\n    case llvm::BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read a record.\n    Record.clear();\n    StringRef Blob;\n    Expected<unsigned> MaybeRecord =\n        SLocEntryCursor.readRecord(E.ID, Record, &Blob);\n    if (!MaybeRecord) {\n      Error(MaybeRecord.takeError());\n      return true;\n    }\n    switch (MaybeRecord.get()) {\n    default:  // Default behavior: ignore.\n      break;\n\n    case SM_SLOC_FILE_ENTRY:\n    case SM_SLOC_BUFFER_ENTRY:\n    case SM_SLOC_EXPANSION_ENTRY:\n      // Once we hit one of the source location entries, we're done.\n      return false;\n    }\n  }\n}\n\n/// If a header file is not found at the path that we expect it to be\n/// and the PCH file was moved from its original location, try to resolve the\n/// file by assuming that header+PCH were moved together and the header is in\n/// the same place relative to the PCH.\nstatic std::string\nresolveFileRelativeToOriginalDir(const std::string &Filename,\n                                 const std::string &OriginalDir,\n                                 const std::string &CurrDir) {\n  assert(OriginalDir != CurrDir &&\n         \"No point trying to resolve the file if the PCH dir didn't change\");\n\n  using namespace llvm::sys;\n\n  SmallString<128> filePath(Filename);\n  fs::make_absolute(filePath);\n  assert(path::is_absolute(OriginalDir));\n  SmallString<128> currPCHPath(CurrDir);\n\n  path::const_iterator fileDirI = path::begin(path::parent_path(filePath)),\n                       fileDirE = path::end(path::parent_path(filePath));\n  path::const_iterator origDirI = path::begin(OriginalDir),\n                       origDirE = path::end(OriginalDir);\n  // Skip the common path components from filePath and OriginalDir.\n  while (fileDirI != fileDirE && origDirI != origDirE &&\n         *fileDirI == *origDirI) {\n    ++fileDirI;\n    ++origDirI;\n  }\n  for (; origDirI != origDirE; ++origDirI)\n    path::append(currPCHPath, \"..\");\n  path::append(currPCHPath, fileDirI, fileDirE);\n  path::append(currPCHPath, path::filename(Filename));\n  return std::string(currPCHPath.str());\n}\n\nbool ASTReader::ReadSLocEntry(int ID) {\n  if (ID == 0)\n    return false;\n\n  if (unsigned(-ID) - 2 >= getTotalNumSLocs() || ID > 0) {\n    Error(\"source location entry ID out-of-range for AST file\");\n    return true;\n  }\n\n  // Local helper to read the (possibly-compressed) buffer data following the\n  // entry record.\n  auto ReadBuffer = [this](\n      BitstreamCursor &SLocEntryCursor,\n      StringRef Name) -> std::unique_ptr<llvm::MemoryBuffer> {\n    RecordData Record;\n    StringRef Blob;\n    Expected<unsigned> MaybeCode = SLocEntryCursor.ReadCode();\n    if (!MaybeCode) {\n      Error(MaybeCode.takeError());\n      return nullptr;\n    }\n    unsigned Code = MaybeCode.get();\n\n    Expected<unsigned> MaybeRecCode =\n        SLocEntryCursor.readRecord(Code, Record, &Blob);\n    if (!MaybeRecCode) {\n      Error(MaybeRecCode.takeError());\n      return nullptr;\n    }\n    unsigned RecCode = MaybeRecCode.get();\n\n    if (RecCode == SM_SLOC_BUFFER_BLOB_COMPRESSED) {\n      if (!llvm::zlib::isAvailable()) {\n        Error(\"zlib is not available\");\n        return nullptr;\n      }\n      SmallString<0> Uncompressed;\n      if (llvm::Error E =\n              llvm::zlib::uncompress(Blob, Uncompressed, Record[0])) {\n        Error(\"could not decompress embedded file contents: \" +\n              llvm::toString(std::move(E)));\n        return nullptr;\n      }\n      return llvm::MemoryBuffer::getMemBufferCopy(Uncompressed, Name);\n    } else if (RecCode == SM_SLOC_BUFFER_BLOB) {\n      return llvm::MemoryBuffer::getMemBuffer(Blob.drop_back(1), Name, true);\n    } else {\n      Error(\"AST record has invalid code\");\n      return nullptr;\n    }\n  };\n\n  ModuleFile *F = GlobalSLocEntryMap.find(-ID)->second;\n  if (llvm::Error Err = F->SLocEntryCursor.JumpToBit(\n          F->SLocEntryOffsetsBase +\n          F->SLocEntryOffsets[ID - F->SLocEntryBaseID])) {\n    Error(std::move(Err));\n    return true;\n  }\n\n  BitstreamCursor &SLocEntryCursor = F->SLocEntryCursor;\n  unsigned BaseOffset = F->SLocEntryBaseOffset;\n\n  ++NumSLocEntriesRead;\n  Expected<llvm::BitstreamEntry> MaybeEntry = SLocEntryCursor.advance();\n  if (!MaybeEntry) {\n    Error(MaybeEntry.takeError());\n    return true;\n  }\n  llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n  if (Entry.Kind != llvm::BitstreamEntry::Record) {\n    Error(\"incorrectly-formatted source location entry in AST file\");\n    return true;\n  }\n\n  RecordData Record;\n  StringRef Blob;\n  Expected<unsigned> MaybeSLOC =\n      SLocEntryCursor.readRecord(Entry.ID, Record, &Blob);\n  if (!MaybeSLOC) {\n    Error(MaybeSLOC.takeError());\n    return true;\n  }\n  switch (MaybeSLOC.get()) {\n  default:\n    Error(\"incorrectly-formatted source location entry in AST file\");\n    return true;\n\n  case SM_SLOC_FILE_ENTRY: {\n    // We will detect whether a file changed and return 'Failure' for it, but\n    // we will also try to fail gracefully by setting up the SLocEntry.\n    unsigned InputID = Record[4];\n    InputFile IF = getInputFile(*F, InputID);\n    Optional<FileEntryRef> File = IF.getFile();\n    bool OverriddenBuffer = IF.isOverridden();\n\n    // Note that we only check if a File was returned. If it was out-of-date\n    // we have complained but we will continue creating a FileID to recover\n    // gracefully.\n    if (!File)\n      return true;\n\n    SourceLocation IncludeLoc = ReadSourceLocation(*F, Record[1]);\n    if (IncludeLoc.isInvalid() && F->Kind != MK_MainFile) {\n      // This is the module's main file.\n      IncludeLoc = getImportLocation(F);\n    }\n    SrcMgr::CharacteristicKind\n      FileCharacter = (SrcMgr::CharacteristicKind)Record[2];\n    FileID FID = SourceMgr.createFileID(*File, IncludeLoc, FileCharacter, ID,\n                                        BaseOffset + Record[0]);\n    SrcMgr::FileInfo &FileInfo =\n          const_cast<SrcMgr::FileInfo&>(SourceMgr.getSLocEntry(FID).getFile());\n    FileInfo.NumCreatedFIDs = Record[5];\n    if (Record[3])\n      FileInfo.setHasLineDirectives();\n\n    unsigned NumFileDecls = Record[7];\n    if (NumFileDecls && ContextObj) {\n      const DeclID *FirstDecl = F->FileSortedDecls + Record[6];\n      assert(F->FileSortedDecls && \"FILE_SORTED_DECLS not encountered yet ?\");\n      FileDeclIDs[FID] = FileDeclsInfo(F, llvm::makeArrayRef(FirstDecl,\n                                                             NumFileDecls));\n    }\n\n    const SrcMgr::ContentCache &ContentCache =\n        SourceMgr.getOrCreateContentCache(*File, isSystem(FileCharacter));\n    if (OverriddenBuffer && !ContentCache.BufferOverridden &&\n        ContentCache.ContentsEntry == ContentCache.OrigEntry &&\n        !ContentCache.getBufferIfLoaded()) {\n      auto Buffer = ReadBuffer(SLocEntryCursor, File->getName());\n      if (!Buffer)\n        return true;\n      SourceMgr.overrideFileContents(*File, std::move(Buffer));\n    }\n\n    break;\n  }\n\n  case SM_SLOC_BUFFER_ENTRY: {\n    const char *Name = Blob.data();\n    unsigned Offset = Record[0];\n    SrcMgr::CharacteristicKind\n      FileCharacter = (SrcMgr::CharacteristicKind)Record[2];\n    SourceLocation IncludeLoc = ReadSourceLocation(*F, Record[1]);\n    if (IncludeLoc.isInvalid() && F->isModule()) {\n      IncludeLoc = getImportLocation(F);\n    }\n\n    auto Buffer = ReadBuffer(SLocEntryCursor, Name);\n    if (!Buffer)\n      return true;\n    SourceMgr.createFileID(std::move(Buffer), FileCharacter, ID,\n                           BaseOffset + Offset, IncludeLoc);\n    break;\n  }\n\n  case SM_SLOC_EXPANSION_ENTRY: {\n    SourceLocation SpellingLoc = ReadSourceLocation(*F, Record[1]);\n    SourceMgr.createExpansionLoc(SpellingLoc,\n                                     ReadSourceLocation(*F, Record[2]),\n                                     ReadSourceLocation(*F, Record[3]),\n                                     Record[5],\n                                     Record[4],\n                                     ID,\n                                     BaseOffset + Record[0]);\n    break;\n  }\n  }\n\n  return false;\n}\n\nstd::pair<SourceLocation, StringRef> ASTReader::getModuleImportLoc(int ID) {\n  if (ID == 0)\n    return std::make_pair(SourceLocation(), \"\");\n\n  if (unsigned(-ID) - 2 >= getTotalNumSLocs() || ID > 0) {\n    Error(\"source location entry ID out-of-range for AST file\");\n    return std::make_pair(SourceLocation(), \"\");\n  }\n\n  // Find which module file this entry lands in.\n  ModuleFile *M = GlobalSLocEntryMap.find(-ID)->second;\n  if (!M->isModule())\n    return std::make_pair(SourceLocation(), \"\");\n\n  // FIXME: Can we map this down to a particular submodule? That would be\n  // ideal.\n  return std::make_pair(M->ImportLoc, StringRef(M->ModuleName));\n}\n\n/// Find the location where the module F is imported.\nSourceLocation ASTReader::getImportLocation(ModuleFile *F) {\n  if (F->ImportLoc.isValid())\n    return F->ImportLoc;\n\n  // Otherwise we have a PCH. It's considered to be \"imported\" at the first\n  // location of its includer.\n  if (F->ImportedBy.empty() || !F->ImportedBy[0]) {\n    // Main file is the importer.\n    assert(SourceMgr.getMainFileID().isValid() && \"missing main file\");\n    return SourceMgr.getLocForStartOfFile(SourceMgr.getMainFileID());\n  }\n  return F->ImportedBy[0]->FirstLoc;\n}\n\n/// Enter a subblock of the specified BlockID with the specified cursor. Read\n/// the abbreviations that are at the top of the block and then leave the cursor\n/// pointing into the block.\nbool ASTReader::ReadBlockAbbrevs(BitstreamCursor &Cursor, unsigned BlockID,\n                                 uint64_t *StartOfBlockOffset) {\n  if (llvm::Error Err = Cursor.EnterSubBlock(BlockID)) {\n    // FIXME this drops errors on the floor.\n    consumeError(std::move(Err));\n    return true;\n  }\n\n  if (StartOfBlockOffset)\n    *StartOfBlockOffset = Cursor.GetCurrentBitNo();\n\n  while (true) {\n    uint64_t Offset = Cursor.GetCurrentBitNo();\n    Expected<unsigned> MaybeCode = Cursor.ReadCode();\n    if (!MaybeCode) {\n      // FIXME this drops errors on the floor.\n      consumeError(MaybeCode.takeError());\n      return true;\n    }\n    unsigned Code = MaybeCode.get();\n\n    // We expect all abbrevs to be at the start of the block.\n    if (Code != llvm::bitc::DEFINE_ABBREV) {\n      if (llvm::Error Err = Cursor.JumpToBit(Offset)) {\n        // FIXME this drops errors on the floor.\n        consumeError(std::move(Err));\n        return true;\n      }\n      return false;\n    }\n    if (llvm::Error Err = Cursor.ReadAbbrevRecord()) {\n      // FIXME this drops errors on the floor.\n      consumeError(std::move(Err));\n      return true;\n    }\n  }\n}\n\nToken ASTReader::ReadToken(ModuleFile &F, const RecordDataImpl &Record,\n                           unsigned &Idx) {\n  Token Tok;\n  Tok.startToken();\n  Tok.setLocation(ReadSourceLocation(F, Record, Idx));\n  Tok.setLength(Record[Idx++]);\n  if (IdentifierInfo *II = getLocalIdentifier(F, Record[Idx++]))\n    Tok.setIdentifierInfo(II);\n  Tok.setKind((tok::TokenKind)Record[Idx++]);\n  Tok.setFlag((Token::TokenFlags)Record[Idx++]);\n  return Tok;\n}\n\nMacroInfo *ASTReader::ReadMacroRecord(ModuleFile &F, uint64_t Offset) {\n  BitstreamCursor &Stream = F.MacroCursor;\n\n  // Keep track of where we are in the stream, then jump back there\n  // after reading this macro.\n  SavedStreamPosition SavedPosition(Stream);\n\n  if (llvm::Error Err = Stream.JumpToBit(Offset)) {\n    // FIXME this drops errors on the floor.\n    consumeError(std::move(Err));\n    return nullptr;\n  }\n  RecordData Record;\n  SmallVector<IdentifierInfo*, 16> MacroParams;\n  MacroInfo *Macro = nullptr;\n\n  while (true) {\n    // Advance to the next record, but if we get to the end of the block, don't\n    // pop it (removing all the abbreviations from the cursor) since we want to\n    // be able to reseek within the block and read entries.\n    unsigned Flags = BitstreamCursor::AF_DontPopBlockAtEnd;\n    Expected<llvm::BitstreamEntry> MaybeEntry =\n        Stream.advanceSkippingSubblocks(Flags);\n    if (!MaybeEntry) {\n      Error(MaybeEntry.takeError());\n      return Macro;\n    }\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case llvm::BitstreamEntry::SubBlock: // Handled for us already.\n    case llvm::BitstreamEntry::Error:\n      Error(\"malformed block record in AST file\");\n      return Macro;\n    case llvm::BitstreamEntry::EndBlock:\n      return Macro;\n    case llvm::BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read a record.\n    Record.clear();\n    PreprocessorRecordTypes RecType;\n    if (Expected<unsigned> MaybeRecType = Stream.readRecord(Entry.ID, Record))\n      RecType = (PreprocessorRecordTypes)MaybeRecType.get();\n    else {\n      Error(MaybeRecType.takeError());\n      return Macro;\n    }\n    switch (RecType) {\n    case PP_MODULE_MACRO:\n    case PP_MACRO_DIRECTIVE_HISTORY:\n      return Macro;\n\n    case PP_MACRO_OBJECT_LIKE:\n    case PP_MACRO_FUNCTION_LIKE: {\n      // If we already have a macro, that means that we've hit the end\n      // of the definition of the macro we were looking for. We're\n      // done.\n      if (Macro)\n        return Macro;\n\n      unsigned NextIndex = 1; // Skip identifier ID.\n      SourceLocation Loc = ReadSourceLocation(F, Record, NextIndex);\n      MacroInfo *MI = PP.AllocateMacroInfo(Loc);\n      MI->setDefinitionEndLoc(ReadSourceLocation(F, Record, NextIndex));\n      MI->setIsUsed(Record[NextIndex++]);\n      MI->setUsedForHeaderGuard(Record[NextIndex++]);\n\n      if (RecType == PP_MACRO_FUNCTION_LIKE) {\n        // Decode function-like macro info.\n        bool isC99VarArgs = Record[NextIndex++];\n        bool isGNUVarArgs = Record[NextIndex++];\n        bool hasCommaPasting = Record[NextIndex++];\n        MacroParams.clear();\n        unsigned NumArgs = Record[NextIndex++];\n        for (unsigned i = 0; i != NumArgs; ++i)\n          MacroParams.push_back(getLocalIdentifier(F, Record[NextIndex++]));\n\n        // Install function-like macro info.\n        MI->setIsFunctionLike();\n        if (isC99VarArgs) MI->setIsC99Varargs();\n        if (isGNUVarArgs) MI->setIsGNUVarargs();\n        if (hasCommaPasting) MI->setHasCommaPasting();\n        MI->setParameterList(MacroParams, PP.getPreprocessorAllocator());\n      }\n\n      // Remember that we saw this macro last so that we add the tokens that\n      // form its body to it.\n      Macro = MI;\n\n      if (NextIndex + 1 == Record.size() && PP.getPreprocessingRecord() &&\n          Record[NextIndex]) {\n        // We have a macro definition. Register the association\n        PreprocessedEntityID\n            GlobalID = getGlobalPreprocessedEntityID(F, Record[NextIndex]);\n        PreprocessingRecord &PPRec = *PP.getPreprocessingRecord();\n        PreprocessingRecord::PPEntityID PPID =\n            PPRec.getPPEntityID(GlobalID - 1, /*isLoaded=*/true);\n        MacroDefinitionRecord *PPDef = cast_or_null<MacroDefinitionRecord>(\n            PPRec.getPreprocessedEntity(PPID));\n        if (PPDef)\n          PPRec.RegisterMacroDefinition(Macro, PPDef);\n      }\n\n      ++NumMacrosRead;\n      break;\n    }\n\n    case PP_TOKEN: {\n      // If we see a TOKEN before a PP_MACRO_*, then the file is\n      // erroneous, just pretend we didn't see this.\n      if (!Macro) break;\n\n      unsigned Idx = 0;\n      Token Tok = ReadToken(F, Record, Idx);\n      Macro->AddTokenToBody(Tok);\n      break;\n    }\n    }\n  }\n}\n\nPreprocessedEntityID\nASTReader::getGlobalPreprocessedEntityID(ModuleFile &M,\n                                         unsigned LocalID) const {\n  if (!M.ModuleOffsetMap.empty())\n    ReadModuleOffsetMap(M);\n\n  ContinuousRangeMap<uint32_t, int, 2>::const_iterator\n    I = M.PreprocessedEntityRemap.find(LocalID - NUM_PREDEF_PP_ENTITY_IDS);\n  assert(I != M.PreprocessedEntityRemap.end()\n         && \"Invalid index into preprocessed entity index remap\");\n\n  return LocalID + I->second;\n}\n\nunsigned HeaderFileInfoTrait::ComputeHash(internal_key_ref ikey) {\n  return llvm::hash_combine(ikey.Size, ikey.ModTime);\n}\n\nHeaderFileInfoTrait::internal_key_type\nHeaderFileInfoTrait::GetInternalKey(const FileEntry *FE) {\n  internal_key_type ikey = {FE->getSize(),\n                            M.HasTimestamps ? FE->getModificationTime() : 0,\n                            FE->getName(), /*Imported*/ false};\n  return ikey;\n}\n\nbool HeaderFileInfoTrait::EqualKey(internal_key_ref a, internal_key_ref b) {\n  if (a.Size != b.Size || (a.ModTime && b.ModTime && a.ModTime != b.ModTime))\n    return false;\n\n  if (llvm::sys::path::is_absolute(a.Filename) && a.Filename == b.Filename)\n    return true;\n\n  // Determine whether the actual files are equivalent.\n  FileManager &FileMgr = Reader.getFileManager();\n  auto GetFile = [&](const internal_key_type &Key) -> const FileEntry* {\n    if (!Key.Imported) {\n      if (auto File = FileMgr.getFile(Key.Filename))\n        return *File;\n      return nullptr;\n    }\n\n    std::string Resolved = std::string(Key.Filename);\n    Reader.ResolveImportedPath(M, Resolved);\n    if (auto File = FileMgr.getFile(Resolved))\n      return *File;\n    return nullptr;\n  };\n\n  const FileEntry *FEA = GetFile(a);\n  const FileEntry *FEB = GetFile(b);\n  return FEA && FEA == FEB;\n}\n\nstd::pair<unsigned, unsigned>\nHeaderFileInfoTrait::ReadKeyDataLength(const unsigned char*& d) {\n  using namespace llvm::support;\n\n  unsigned KeyLen = (unsigned) endian::readNext<uint16_t, little, unaligned>(d);\n  unsigned DataLen = (unsigned) *d++;\n  return std::make_pair(KeyLen, DataLen);\n}\n\nHeaderFileInfoTrait::internal_key_type\nHeaderFileInfoTrait::ReadKey(const unsigned char *d, unsigned) {\n  using namespace llvm::support;\n\n  internal_key_type ikey;\n  ikey.Size = off_t(endian::readNext<uint64_t, little, unaligned>(d));\n  ikey.ModTime = time_t(endian::readNext<uint64_t, little, unaligned>(d));\n  ikey.Filename = (const char *)d;\n  ikey.Imported = true;\n  return ikey;\n}\n\nHeaderFileInfoTrait::data_type\nHeaderFileInfoTrait::ReadData(internal_key_ref key, const unsigned char *d,\n                              unsigned DataLen) {\n  using namespace llvm::support;\n\n  const unsigned char *End = d + DataLen;\n  HeaderFileInfo HFI;\n  unsigned Flags = *d++;\n  // FIXME: Refactor with mergeHeaderFileInfo in HeaderSearch.cpp.\n  HFI.isImport |= (Flags >> 5) & 0x01;\n  HFI.isPragmaOnce |= (Flags >> 4) & 0x01;\n  HFI.DirInfo = (Flags >> 1) & 0x07;\n  HFI.IndexHeaderMapHeader = Flags & 0x01;\n  // FIXME: Find a better way to handle this. Maybe just store a\n  // \"has been included\" flag?\n  HFI.NumIncludes = std::max(endian::readNext<uint16_t, little, unaligned>(d),\n                             HFI.NumIncludes);\n  HFI.ControllingMacroID = Reader.getGlobalIdentifierID(\n      M, endian::readNext<uint32_t, little, unaligned>(d));\n  if (unsigned FrameworkOffset =\n          endian::readNext<uint32_t, little, unaligned>(d)) {\n    // The framework offset is 1 greater than the actual offset,\n    // since 0 is used as an indicator for \"no framework name\".\n    StringRef FrameworkName(FrameworkStrings + FrameworkOffset - 1);\n    HFI.Framework = HS->getUniqueFrameworkName(FrameworkName);\n  }\n\n  assert((End - d) % 4 == 0 &&\n         \"Wrong data length in HeaderFileInfo deserialization\");\n  while (d != End) {\n    uint32_t LocalSMID = endian::readNext<uint32_t, little, unaligned>(d);\n    auto HeaderRole = static_cast<ModuleMap::ModuleHeaderRole>(LocalSMID & 3);\n    LocalSMID >>= 2;\n\n    // This header is part of a module. Associate it with the module to enable\n    // implicit module import.\n    SubmoduleID GlobalSMID = Reader.getGlobalSubmoduleID(M, LocalSMID);\n    Module *Mod = Reader.getSubmodule(GlobalSMID);\n    FileManager &FileMgr = Reader.getFileManager();\n    ModuleMap &ModMap =\n        Reader.getPreprocessor().getHeaderSearchInfo().getModuleMap();\n\n    std::string Filename = std::string(key.Filename);\n    if (key.Imported)\n      Reader.ResolveImportedPath(M, Filename);\n    // FIXME: This is not always the right filename-as-written, but we're not\n    // going to use this information to rebuild the module, so it doesn't make\n    // a lot of difference.\n    Module::Header H = {std::string(key.Filename),\n                        *FileMgr.getOptionalFileRef(Filename)};\n    ModMap.addHeader(Mod, H, HeaderRole, /*Imported*/true);\n    HFI.isModuleHeader |= !(HeaderRole & ModuleMap::TextualHeader);\n  }\n\n  // This HeaderFileInfo was externally loaded.\n  HFI.External = true;\n  HFI.IsValid = true;\n  return HFI;\n}\n\nvoid ASTReader::addPendingMacro(IdentifierInfo *II, ModuleFile *M,\n                                uint32_t MacroDirectivesOffset) {\n  assert(NumCurrentElementsDeserializing > 0 &&\"Missing deserialization guard\");\n  PendingMacroIDs[II].push_back(PendingMacroInfo(M, MacroDirectivesOffset));\n}\n\nvoid ASTReader::ReadDefinedMacros() {\n  // Note that we are loading defined macros.\n  Deserializing Macros(this);\n\n  for (ModuleFile &I : llvm::reverse(ModuleMgr)) {\n    BitstreamCursor &MacroCursor = I.MacroCursor;\n\n    // If there was no preprocessor block, skip this file.\n    if (MacroCursor.getBitcodeBytes().empty())\n      continue;\n\n    BitstreamCursor Cursor = MacroCursor;\n    if (llvm::Error Err = Cursor.JumpToBit(I.MacroStartOffset)) {\n      Error(std::move(Err));\n      return;\n    }\n\n    RecordData Record;\n    while (true) {\n      Expected<llvm::BitstreamEntry> MaybeE = Cursor.advanceSkippingSubblocks();\n      if (!MaybeE) {\n        Error(MaybeE.takeError());\n        return;\n      }\n      llvm::BitstreamEntry E = MaybeE.get();\n\n      switch (E.Kind) {\n      case llvm::BitstreamEntry::SubBlock: // Handled for us already.\n      case llvm::BitstreamEntry::Error:\n        Error(\"malformed block record in AST file\");\n        return;\n      case llvm::BitstreamEntry::EndBlock:\n        goto NextCursor;\n\n      case llvm::BitstreamEntry::Record: {\n        Record.clear();\n        Expected<unsigned> MaybeRecord = Cursor.readRecord(E.ID, Record);\n        if (!MaybeRecord) {\n          Error(MaybeRecord.takeError());\n          return;\n        }\n        switch (MaybeRecord.get()) {\n        default:  // Default behavior: ignore.\n          break;\n\n        case PP_MACRO_OBJECT_LIKE:\n        case PP_MACRO_FUNCTION_LIKE: {\n          IdentifierInfo *II = getLocalIdentifier(I, Record[0]);\n          if (II->isOutOfDate())\n            updateOutOfDateIdentifier(*II);\n          break;\n        }\n\n        case PP_TOKEN:\n          // Ignore tokens.\n          break;\n        }\n        break;\n      }\n      }\n    }\n    NextCursor:  ;\n  }\n}\n\nnamespace {\n\n  /// Visitor class used to look up identifirs in an AST file.\n  class IdentifierLookupVisitor {\n    StringRef Name;\n    unsigned NameHash;\n    unsigned PriorGeneration;\n    unsigned &NumIdentifierLookups;\n    unsigned &NumIdentifierLookupHits;\n    IdentifierInfo *Found = nullptr;\n\n  public:\n    IdentifierLookupVisitor(StringRef Name, unsigned PriorGeneration,\n                            unsigned &NumIdentifierLookups,\n                            unsigned &NumIdentifierLookupHits)\n      : Name(Name), NameHash(ASTIdentifierLookupTrait::ComputeHash(Name)),\n        PriorGeneration(PriorGeneration),\n        NumIdentifierLookups(NumIdentifierLookups),\n        NumIdentifierLookupHits(NumIdentifierLookupHits) {}\n\n    bool operator()(ModuleFile &M) {\n      // If we've already searched this module file, skip it now.\n      if (M.Generation <= PriorGeneration)\n        return true;\n\n      ASTIdentifierLookupTable *IdTable\n        = (ASTIdentifierLookupTable *)M.IdentifierLookupTable;\n      if (!IdTable)\n        return false;\n\n      ASTIdentifierLookupTrait Trait(IdTable->getInfoObj().getReader(), M,\n                                     Found);\n      ++NumIdentifierLookups;\n      ASTIdentifierLookupTable::iterator Pos =\n          IdTable->find_hashed(Name, NameHash, &Trait);\n      if (Pos == IdTable->end())\n        return false;\n\n      // Dereferencing the iterator has the effect of building the\n      // IdentifierInfo node and populating it with the various\n      // declarations it needs.\n      ++NumIdentifierLookupHits;\n      Found = *Pos;\n      return true;\n    }\n\n    // Retrieve the identifier info found within the module\n    // files.\n    IdentifierInfo *getIdentifierInfo() const { return Found; }\n  };\n\n} // namespace\n\nvoid ASTReader::updateOutOfDateIdentifier(IdentifierInfo &II) {\n  // Note that we are loading an identifier.\n  Deserializing AnIdentifier(this);\n\n  unsigned PriorGeneration = 0;\n  if (getContext().getLangOpts().Modules)\n    PriorGeneration = IdentifierGeneration[&II];\n\n  // If there is a global index, look there first to determine which modules\n  // provably do not have any results for this identifier.\n  GlobalModuleIndex::HitSet Hits;\n  GlobalModuleIndex::HitSet *HitsPtr = nullptr;\n  if (!loadGlobalIndex()) {\n    if (GlobalIndex->lookupIdentifier(II.getName(), Hits)) {\n      HitsPtr = &Hits;\n    }\n  }\n\n  IdentifierLookupVisitor Visitor(II.getName(), PriorGeneration,\n                                  NumIdentifierLookups,\n                                  NumIdentifierLookupHits);\n  ModuleMgr.visit(Visitor, HitsPtr);\n  markIdentifierUpToDate(&II);\n}\n\nvoid ASTReader::markIdentifierUpToDate(IdentifierInfo *II) {\n  if (!II)\n    return;\n\n  II->setOutOfDate(false);\n\n  // Update the generation for this identifier.\n  if (getContext().getLangOpts().Modules)\n    IdentifierGeneration[II] = getGeneration();\n}\n\nvoid ASTReader::resolvePendingMacro(IdentifierInfo *II,\n                                    const PendingMacroInfo &PMInfo) {\n  ModuleFile &M = *PMInfo.M;\n\n  BitstreamCursor &Cursor = M.MacroCursor;\n  SavedStreamPosition SavedPosition(Cursor);\n  if (llvm::Error Err =\n          Cursor.JumpToBit(M.MacroOffsetsBase + PMInfo.MacroDirectivesOffset)) {\n    Error(std::move(Err));\n    return;\n  }\n\n  struct ModuleMacroRecord {\n    SubmoduleID SubModID;\n    MacroInfo *MI;\n    SmallVector<SubmoduleID, 8> Overrides;\n  };\n  llvm::SmallVector<ModuleMacroRecord, 8> ModuleMacros;\n\n  // We expect to see a sequence of PP_MODULE_MACRO records listing exported\n  // macros, followed by a PP_MACRO_DIRECTIVE_HISTORY record with the complete\n  // macro histroy.\n  RecordData Record;\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry =\n        Cursor.advance(BitstreamCursor::AF_DontPopBlockAtEnd);\n    if (!MaybeEntry) {\n      Error(MaybeEntry.takeError());\n      return;\n    }\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    if (Entry.Kind != llvm::BitstreamEntry::Record) {\n      Error(\"malformed block record in AST file\");\n      return;\n    }\n\n    Record.clear();\n    Expected<unsigned> MaybePP = Cursor.readRecord(Entry.ID, Record);\n    if (!MaybePP) {\n      Error(MaybePP.takeError());\n      return;\n    }\n    switch ((PreprocessorRecordTypes)MaybePP.get()) {\n    case PP_MACRO_DIRECTIVE_HISTORY:\n      break;\n\n    case PP_MODULE_MACRO: {\n      ModuleMacros.push_back(ModuleMacroRecord());\n      auto &Info = ModuleMacros.back();\n      Info.SubModID = getGlobalSubmoduleID(M, Record[0]);\n      Info.MI = getMacro(getGlobalMacroID(M, Record[1]));\n      for (int I = 2, N = Record.size(); I != N; ++I)\n        Info.Overrides.push_back(getGlobalSubmoduleID(M, Record[I]));\n      continue;\n    }\n\n    default:\n      Error(\"malformed block record in AST file\");\n      return;\n    }\n\n    // We found the macro directive history; that's the last record\n    // for this macro.\n    break;\n  }\n\n  // Module macros are listed in reverse dependency order.\n  {\n    std::reverse(ModuleMacros.begin(), ModuleMacros.end());\n    llvm::SmallVector<ModuleMacro*, 8> Overrides;\n    for (auto &MMR : ModuleMacros) {\n      Overrides.clear();\n      for (unsigned ModID : MMR.Overrides) {\n        Module *Mod = getSubmodule(ModID);\n        auto *Macro = PP.getModuleMacro(Mod, II);\n        assert(Macro && \"missing definition for overridden macro\");\n        Overrides.push_back(Macro);\n      }\n\n      bool Inserted = false;\n      Module *Owner = getSubmodule(MMR.SubModID);\n      PP.addModuleMacro(Owner, II, MMR.MI, Overrides, Inserted);\n    }\n  }\n\n  // Don't read the directive history for a module; we don't have anywhere\n  // to put it.\n  if (M.isModule())\n    return;\n\n  // Deserialize the macro directives history in reverse source-order.\n  MacroDirective *Latest = nullptr, *Earliest = nullptr;\n  unsigned Idx = 0, N = Record.size();\n  while (Idx < N) {\n    MacroDirective *MD = nullptr;\n    SourceLocation Loc = ReadSourceLocation(M, Record, Idx);\n    MacroDirective::Kind K = (MacroDirective::Kind)Record[Idx++];\n    switch (K) {\n    case MacroDirective::MD_Define: {\n      MacroInfo *MI = getMacro(getGlobalMacroID(M, Record[Idx++]));\n      MD = PP.AllocateDefMacroDirective(MI, Loc);\n      break;\n    }\n    case MacroDirective::MD_Undefine:\n      MD = PP.AllocateUndefMacroDirective(Loc);\n      break;\n    case MacroDirective::MD_Visibility:\n      bool isPublic = Record[Idx++];\n      MD = PP.AllocateVisibilityMacroDirective(Loc, isPublic);\n      break;\n    }\n\n    if (!Latest)\n      Latest = MD;\n    if (Earliest)\n      Earliest->setPrevious(MD);\n    Earliest = MD;\n  }\n\n  if (Latest)\n    PP.setLoadedMacroDirective(II, Earliest, Latest);\n}\n\nbool ASTReader::shouldDisableValidationForFile(\n    const serialization::ModuleFile &M) const {\n  if (DisableValidationKind == DisableValidationForModuleKind::None)\n    return false;\n\n  // If a PCH is loaded and validation is disabled for PCH then disable\n  // validation for the PCH and the modules it loads.\n  ModuleKind K = CurrentDeserializingModuleKind.getValueOr(M.Kind);\n\n  switch (K) {\n  case MK_MainFile:\n  case MK_Preamble:\n  case MK_PCH:\n    return bool(DisableValidationKind & DisableValidationForModuleKind::PCH);\n  case MK_ImplicitModule:\n  case MK_ExplicitModule:\n  case MK_PrebuiltModule:\n    return bool(DisableValidationKind & DisableValidationForModuleKind::Module);\n  }\n\n  return false;\n}\n\nASTReader::InputFileInfo\nASTReader::readInputFileInfo(ModuleFile &F, unsigned ID) {\n  // Go find this input file.\n  BitstreamCursor &Cursor = F.InputFilesCursor;\n  SavedStreamPosition SavedPosition(Cursor);\n  if (llvm::Error Err = Cursor.JumpToBit(F.InputFileOffsets[ID - 1])) {\n    // FIXME this drops errors on the floor.\n    consumeError(std::move(Err));\n  }\n\n  Expected<unsigned> MaybeCode = Cursor.ReadCode();\n  if (!MaybeCode) {\n    // FIXME this drops errors on the floor.\n    consumeError(MaybeCode.takeError());\n  }\n  unsigned Code = MaybeCode.get();\n  RecordData Record;\n  StringRef Blob;\n\n  if (Expected<unsigned> Maybe = Cursor.readRecord(Code, Record, &Blob))\n    assert(static_cast<InputFileRecordTypes>(Maybe.get()) == INPUT_FILE &&\n           \"invalid record type for input file\");\n  else {\n    // FIXME this drops errors on the floor.\n    consumeError(Maybe.takeError());\n  }\n\n  assert(Record[0] == ID && \"Bogus stored ID or offset\");\n  InputFileInfo R;\n  R.StoredSize = static_cast<off_t>(Record[1]);\n  R.StoredTime = static_cast<time_t>(Record[2]);\n  R.Overridden = static_cast<bool>(Record[3]);\n  R.Transient = static_cast<bool>(Record[4]);\n  R.TopLevelModuleMap = static_cast<bool>(Record[5]);\n  R.Filename = std::string(Blob);\n  ResolveImportedPath(F, R.Filename);\n\n  Expected<llvm::BitstreamEntry> MaybeEntry = Cursor.advance();\n  if (!MaybeEntry) // FIXME this drops errors on the floor.\n    consumeError(MaybeEntry.takeError());\n  llvm::BitstreamEntry Entry = MaybeEntry.get();\n  assert(Entry.Kind == llvm::BitstreamEntry::Record &&\n         \"expected record type for input file hash\");\n\n  Record.clear();\n  if (Expected<unsigned> Maybe = Cursor.readRecord(Entry.ID, Record))\n    assert(static_cast<InputFileRecordTypes>(Maybe.get()) == INPUT_FILE_HASH &&\n           \"invalid record type for input file hash\");\n  else {\n    // FIXME this drops errors on the floor.\n    consumeError(Maybe.takeError());\n  }\n  R.ContentHash = (static_cast<uint64_t>(Record[1]) << 32) |\n                  static_cast<uint64_t>(Record[0]);\n  return R;\n}\n\nstatic unsigned moduleKindForDiagnostic(ModuleKind Kind);\nInputFile ASTReader::getInputFile(ModuleFile &F, unsigned ID, bool Complain) {\n  // If this ID is bogus, just return an empty input file.\n  if (ID == 0 || ID > F.InputFilesLoaded.size())\n    return InputFile();\n\n  // If we've already loaded this input file, return it.\n  if (F.InputFilesLoaded[ID-1].getFile())\n    return F.InputFilesLoaded[ID-1];\n\n  if (F.InputFilesLoaded[ID-1].isNotFound())\n    return InputFile();\n\n  // Go find this input file.\n  BitstreamCursor &Cursor = F.InputFilesCursor;\n  SavedStreamPosition SavedPosition(Cursor);\n  if (llvm::Error Err = Cursor.JumpToBit(F.InputFileOffsets[ID - 1])) {\n    // FIXME this drops errors on the floor.\n    consumeError(std::move(Err));\n  }\n\n  InputFileInfo FI = readInputFileInfo(F, ID);\n  off_t StoredSize = FI.StoredSize;\n  time_t StoredTime = FI.StoredTime;\n  bool Overridden = FI.Overridden;\n  bool Transient = FI.Transient;\n  StringRef Filename = FI.Filename;\n  uint64_t StoredContentHash = FI.ContentHash;\n\n  OptionalFileEntryRefDegradesToFileEntryPtr File =\n      expectedToOptional(FileMgr.getFileRef(Filename, /*OpenFile=*/false));\n\n  // If we didn't find the file, resolve it relative to the\n  // original directory from which this AST file was created.\n  if (!File && !F.OriginalDir.empty() && !F.BaseDirectory.empty() &&\n      F.OriginalDir != F.BaseDirectory) {\n    std::string Resolved = resolveFileRelativeToOriginalDir(\n        std::string(Filename), F.OriginalDir, F.BaseDirectory);\n    if (!Resolved.empty())\n      File = expectedToOptional(FileMgr.getFileRef(Resolved));\n  }\n\n  // For an overridden file, create a virtual file with the stored\n  // size/timestamp.\n  if ((Overridden || Transient) && !File)\n    File = FileMgr.getVirtualFileRef(Filename, StoredSize, StoredTime);\n\n  if (!File) {\n    if (Complain) {\n      std::string ErrorStr = \"could not find file '\";\n      ErrorStr += Filename;\n      ErrorStr += \"' referenced by AST file '\";\n      ErrorStr += F.FileName;\n      ErrorStr += \"'\";\n      Error(ErrorStr);\n    }\n    // Record that we didn't find the file.\n    F.InputFilesLoaded[ID-1] = InputFile::getNotFound();\n    return InputFile();\n  }\n\n  // Check if there was a request to override the contents of the file\n  // that was part of the precompiled header. Overriding such a file\n  // can lead to problems when lexing using the source locations from the\n  // PCH.\n  SourceManager &SM = getSourceManager();\n  // FIXME: Reject if the overrides are different.\n  if ((!Overridden && !Transient) && SM.isFileOverridden(File)) {\n    if (Complain)\n      Error(diag::err_fe_pch_file_overridden, Filename);\n\n    // After emitting the diagnostic, bypass the overriding file to recover\n    // (this creates a separate FileEntry).\n    File = SM.bypassFileContentsOverride(*File);\n    if (!File) {\n      F.InputFilesLoaded[ID - 1] = InputFile::getNotFound();\n      return InputFile();\n    }\n  }\n\n  enum ModificationType {\n    Size,\n    ModTime,\n    Content,\n    None,\n  };\n  auto HasInputFileChanged = [&]() {\n    if (StoredSize != File->getSize())\n      return ModificationType::Size;\n    if (!shouldDisableValidationForFile(F) && StoredTime &&\n        StoredTime != File->getModificationTime()) {\n      // In case the modification time changes but not the content,\n      // accept the cached file as legit.\n      if (ValidateASTInputFilesContent &&\n          StoredContentHash != static_cast<uint64_t>(llvm::hash_code(-1))) {\n        auto MemBuffOrError = FileMgr.getBufferForFile(File);\n        if (!MemBuffOrError) {\n          if (!Complain)\n            return ModificationType::ModTime;\n          std::string ErrorStr = \"could not get buffer for file '\";\n          ErrorStr += File->getName();\n          ErrorStr += \"'\";\n          Error(ErrorStr);\n          return ModificationType::ModTime;\n        }\n\n        auto ContentHash = hash_value(MemBuffOrError.get()->getBuffer());\n        if (StoredContentHash == static_cast<uint64_t>(ContentHash))\n          return ModificationType::None;\n        return ModificationType::Content;\n      }\n      return ModificationType::ModTime;\n    }\n    return ModificationType::None;\n  };\n\n  bool IsOutOfDate = false;\n  auto FileChange = HasInputFileChanged();\n  // For an overridden file, there is nothing to validate.\n  if (!Overridden && FileChange != ModificationType::None) {\n    if (Complain && !Diags.isDiagnosticInFlight()) {\n      // Build a list of the PCH imports that got us here (in reverse).\n      SmallVector<ModuleFile *, 4> ImportStack(1, &F);\n      while (!ImportStack.back()->ImportedBy.empty())\n        ImportStack.push_back(ImportStack.back()->ImportedBy[0]);\n\n      // The top-level PCH is stale.\n      StringRef TopLevelPCHName(ImportStack.back()->FileName);\n      Diag(diag::err_fe_ast_file_modified)\n          << Filename << moduleKindForDiagnostic(ImportStack.back()->Kind)\n          << TopLevelPCHName << FileChange;\n\n      // Print the import stack.\n      if (ImportStack.size() > 1) {\n        Diag(diag::note_pch_required_by)\n          << Filename << ImportStack[0]->FileName;\n        for (unsigned I = 1; I < ImportStack.size(); ++I)\n          Diag(diag::note_pch_required_by)\n            << ImportStack[I-1]->FileName << ImportStack[I]->FileName;\n      }\n\n      Diag(diag::note_pch_rebuild_required) << TopLevelPCHName;\n    }\n\n    IsOutOfDate = true;\n  }\n  // FIXME: If the file is overridden and we've already opened it,\n  // issue an error (or split it into a separate FileEntry).\n\n  InputFile IF = InputFile(*File, Overridden || Transient, IsOutOfDate);\n\n  // Note that we've loaded this input file.\n  F.InputFilesLoaded[ID-1] = IF;\n  return IF;\n}\n\n/// If we are loading a relocatable PCH or module file, and the filename\n/// is not an absolute path, add the system or module root to the beginning of\n/// the file name.\nvoid ASTReader::ResolveImportedPath(ModuleFile &M, std::string &Filename) {\n  // Resolve relative to the base directory, if we have one.\n  if (!M.BaseDirectory.empty())\n    return ResolveImportedPath(Filename, M.BaseDirectory);\n}\n\nvoid ASTReader::ResolveImportedPath(std::string &Filename, StringRef Prefix) {\n  if (Filename.empty() || llvm::sys::path::is_absolute(Filename))\n    return;\n\n  SmallString<128> Buffer;\n  llvm::sys::path::append(Buffer, Prefix, Filename);\n  Filename.assign(Buffer.begin(), Buffer.end());\n}\n\nstatic bool isDiagnosedResult(ASTReader::ASTReadResult ARR, unsigned Caps) {\n  switch (ARR) {\n  case ASTReader::Failure: return true;\n  case ASTReader::Missing: return !(Caps & ASTReader::ARR_Missing);\n  case ASTReader::OutOfDate: return !(Caps & ASTReader::ARR_OutOfDate);\n  case ASTReader::VersionMismatch: return !(Caps & ASTReader::ARR_VersionMismatch);\n  case ASTReader::ConfigurationMismatch:\n    return !(Caps & ASTReader::ARR_ConfigurationMismatch);\n  case ASTReader::HadErrors: return true;\n  case ASTReader::Success: return false;\n  }\n\n  llvm_unreachable(\"unknown ASTReadResult\");\n}\n\nASTReader::ASTReadResult ASTReader::ReadOptionsBlock(\n    BitstreamCursor &Stream, unsigned ClientLoadCapabilities,\n    bool AllowCompatibleConfigurationMismatch, ASTReaderListener &Listener,\n    std::string &SuggestedPredefines) {\n  if (llvm::Error Err = Stream.EnterSubBlock(OPTIONS_BLOCK_ID)) {\n    // FIXME this drops errors on the floor.\n    consumeError(std::move(Err));\n    return Failure;\n  }\n\n  // Read all of the records in the options block.\n  RecordData Record;\n  ASTReadResult Result = Success;\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry = Stream.advance();\n    if (!MaybeEntry) {\n      // FIXME this drops errors on the floor.\n      consumeError(MaybeEntry.takeError());\n      return Failure;\n    }\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case llvm::BitstreamEntry::Error:\n    case llvm::BitstreamEntry::SubBlock:\n      return Failure;\n\n    case llvm::BitstreamEntry::EndBlock:\n      return Result;\n\n    case llvm::BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read and process a record.\n    Record.clear();\n    Expected<unsigned> MaybeRecordType = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeRecordType) {\n      // FIXME this drops errors on the floor.\n      consumeError(MaybeRecordType.takeError());\n      return Failure;\n    }\n    switch ((OptionsRecordTypes)MaybeRecordType.get()) {\n    case LANGUAGE_OPTIONS: {\n      bool Complain = (ClientLoadCapabilities & ARR_ConfigurationMismatch) == 0;\n      if (ParseLanguageOptions(Record, Complain, Listener,\n                               AllowCompatibleConfigurationMismatch))\n        Result = ConfigurationMismatch;\n      break;\n    }\n\n    case TARGET_OPTIONS: {\n      bool Complain = (ClientLoadCapabilities & ARR_ConfigurationMismatch) == 0;\n      if (ParseTargetOptions(Record, Complain, Listener,\n                             AllowCompatibleConfigurationMismatch))\n        Result = ConfigurationMismatch;\n      break;\n    }\n\n    case FILE_SYSTEM_OPTIONS: {\n      bool Complain = (ClientLoadCapabilities & ARR_ConfigurationMismatch) == 0;\n      if (!AllowCompatibleConfigurationMismatch &&\n          ParseFileSystemOptions(Record, Complain, Listener))\n        Result = ConfigurationMismatch;\n      break;\n    }\n\n    case HEADER_SEARCH_OPTIONS: {\n      bool Complain = (ClientLoadCapabilities & ARR_ConfigurationMismatch) == 0;\n      if (!AllowCompatibleConfigurationMismatch &&\n          ParseHeaderSearchOptions(Record, Complain, Listener))\n        Result = ConfigurationMismatch;\n      break;\n    }\n\n    case PREPROCESSOR_OPTIONS:\n      bool Complain = (ClientLoadCapabilities & ARR_ConfigurationMismatch) == 0;\n      if (!AllowCompatibleConfigurationMismatch &&\n          ParsePreprocessorOptions(Record, Complain, Listener,\n                                   SuggestedPredefines))\n        Result = ConfigurationMismatch;\n      break;\n    }\n  }\n}\n\nASTReader::ASTReadResult\nASTReader::ReadControlBlock(ModuleFile &F,\n                            SmallVectorImpl<ImportedModule> &Loaded,\n                            const ModuleFile *ImportedBy,\n                            unsigned ClientLoadCapabilities) {\n  BitstreamCursor &Stream = F.Stream;\n\n  if (llvm::Error Err = Stream.EnterSubBlock(CONTROL_BLOCK_ID)) {\n    Error(std::move(Err));\n    return Failure;\n  }\n\n  // Lambda to read the unhashed control block the first time it's called.\n  //\n  // For PCM files, the unhashed control block cannot be read until after the\n  // MODULE_NAME record.  However, PCH files have no MODULE_NAME, and yet still\n  // need to look ahead before reading the IMPORTS record.  For consistency,\n  // this block is always read somehow (see BitstreamEntry::EndBlock).\n  bool HasReadUnhashedControlBlock = false;\n  auto readUnhashedControlBlockOnce = [&]() {\n    if (!HasReadUnhashedControlBlock) {\n      HasReadUnhashedControlBlock = true;\n      if (ASTReadResult Result =\n              readUnhashedControlBlock(F, ImportedBy, ClientLoadCapabilities))\n        return Result;\n    }\n    return Success;\n  };\n\n  bool DisableValidation = shouldDisableValidationForFile(F);\n\n  // Read all of the records and blocks in the control block.\n  RecordData Record;\n  unsigned NumInputs = 0;\n  unsigned NumUserInputs = 0;\n  StringRef BaseDirectoryAsWritten;\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry = Stream.advance();\n    if (!MaybeEntry) {\n      Error(MaybeEntry.takeError());\n      return Failure;\n    }\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case llvm::BitstreamEntry::Error:\n      Error(\"malformed block record in AST file\");\n      return Failure;\n    case llvm::BitstreamEntry::EndBlock: {\n      // Validate the module before returning.  This call catches an AST with\n      // no module name and no imports.\n      if (ASTReadResult Result = readUnhashedControlBlockOnce())\n        return Result;\n\n      // Validate input files.\n      const HeaderSearchOptions &HSOpts =\n          PP.getHeaderSearchInfo().getHeaderSearchOpts();\n\n      // All user input files reside at the index range [0, NumUserInputs), and\n      // system input files reside at [NumUserInputs, NumInputs). For explicitly\n      // loaded module files, ignore missing inputs.\n      if (!DisableValidation && F.Kind != MK_ExplicitModule &&\n          F.Kind != MK_PrebuiltModule) {\n        bool Complain = (ClientLoadCapabilities & ARR_OutOfDate) == 0;\n\n        // If we are reading a module, we will create a verification timestamp,\n        // so we verify all input files.  Otherwise, verify only user input\n        // files.\n\n        unsigned N = NumUserInputs;\n        if (ValidateSystemInputs ||\n            (HSOpts.ModulesValidateOncePerBuildSession &&\n             F.InputFilesValidationTimestamp <= HSOpts.BuildSessionTimestamp &&\n             F.Kind == MK_ImplicitModule))\n          N = NumInputs;\n\n        for (unsigned I = 0; I < N; ++I) {\n          InputFile IF = getInputFile(F, I+1, Complain);\n          if (!IF.getFile() || IF.isOutOfDate())\n            return OutOfDate;\n        }\n      }\n\n      if (Listener)\n        Listener->visitModuleFile(F.FileName, F.Kind);\n\n      if (Listener && Listener->needsInputFileVisitation()) {\n        unsigned N = Listener->needsSystemInputFileVisitation() ? NumInputs\n                                                                : NumUserInputs;\n        for (unsigned I = 0; I < N; ++I) {\n          bool IsSystem = I >= NumUserInputs;\n          InputFileInfo FI = readInputFileInfo(F, I+1);\n          Listener->visitInputFile(FI.Filename, IsSystem, FI.Overridden,\n                                   F.Kind == MK_ExplicitModule ||\n                                   F.Kind == MK_PrebuiltModule);\n        }\n      }\n\n      return Success;\n    }\n\n    case llvm::BitstreamEntry::SubBlock:\n      switch (Entry.ID) {\n      case INPUT_FILES_BLOCK_ID:\n        F.InputFilesCursor = Stream;\n        if (llvm::Error Err = Stream.SkipBlock()) {\n          Error(std::move(Err));\n          return Failure;\n        }\n        if (ReadBlockAbbrevs(F.InputFilesCursor, INPUT_FILES_BLOCK_ID)) {\n          Error(\"malformed block record in AST file\");\n          return Failure;\n        }\n        continue;\n\n      case OPTIONS_BLOCK_ID:\n        // If we're reading the first module for this group, check its options\n        // are compatible with ours. For modules it imports, no further checking\n        // is required, because we checked them when we built it.\n        if (Listener && !ImportedBy) {\n          // Should we allow the configuration of the module file to differ from\n          // the configuration of the current translation unit in a compatible\n          // way?\n          //\n          // FIXME: Allow this for files explicitly specified with -include-pch.\n          bool AllowCompatibleConfigurationMismatch =\n              F.Kind == MK_ExplicitModule || F.Kind == MK_PrebuiltModule;\n\n          ASTReadResult Result =\n              ReadOptionsBlock(Stream, ClientLoadCapabilities,\n                               AllowCompatibleConfigurationMismatch, *Listener,\n                               SuggestedPredefines);\n          if (Result == Failure) {\n            Error(\"malformed block record in AST file\");\n            return Result;\n          }\n\n          if (DisableValidation ||\n              (AllowConfigurationMismatch && Result == ConfigurationMismatch))\n            Result = Success;\n\n          // If we can't load the module, exit early since we likely\n          // will rebuild the module anyway. The stream may be in the\n          // middle of a block.\n          if (Result != Success)\n            return Result;\n        } else if (llvm::Error Err = Stream.SkipBlock()) {\n          Error(std::move(Err));\n          return Failure;\n        }\n        continue;\n\n      default:\n        if (llvm::Error Err = Stream.SkipBlock()) {\n          Error(std::move(Err));\n          return Failure;\n        }\n        continue;\n      }\n\n    case llvm::BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read and process a record.\n    Record.clear();\n    StringRef Blob;\n    Expected<unsigned> MaybeRecordType =\n        Stream.readRecord(Entry.ID, Record, &Blob);\n    if (!MaybeRecordType) {\n      Error(MaybeRecordType.takeError());\n      return Failure;\n    }\n    switch ((ControlRecordTypes)MaybeRecordType.get()) {\n    case METADATA: {\n      if (Record[0] != VERSION_MAJOR && !DisableValidation) {\n        if ((ClientLoadCapabilities & ARR_VersionMismatch) == 0)\n          Diag(Record[0] < VERSION_MAJOR? diag::err_pch_version_too_old\n                                        : diag::err_pch_version_too_new);\n        return VersionMismatch;\n      }\n\n      bool hasErrors = Record[6];\n      if (hasErrors && !DisableValidation) {\n        // If requested by the caller, mark modules on error as out-of-date.\n        if (F.Kind == MK_ImplicitModule &&\n            (ClientLoadCapabilities & ARR_TreatModuleWithErrorsAsOutOfDate))\n          return OutOfDate;\n\n        if (!AllowASTWithCompilerErrors) {\n          Diag(diag::err_pch_with_compiler_errors);\n          return HadErrors;\n        }\n      }\n      if (hasErrors) {\n        Diags.ErrorOccurred = true;\n        Diags.UncompilableErrorOccurred = true;\n        Diags.UnrecoverableErrorOccurred = true;\n      }\n\n      F.RelocatablePCH = Record[4];\n      // Relative paths in a relocatable PCH are relative to our sysroot.\n      if (F.RelocatablePCH)\n        F.BaseDirectory = isysroot.empty() ? \"/\" : isysroot;\n\n      F.HasTimestamps = Record[5];\n\n      const std::string &CurBranch = getClangFullRepositoryVersion();\n      StringRef ASTBranch = Blob;\n      if (StringRef(CurBranch) != ASTBranch && !DisableValidation) {\n        if ((ClientLoadCapabilities & ARR_VersionMismatch) == 0)\n          Diag(diag::err_pch_different_branch) << ASTBranch << CurBranch;\n        return VersionMismatch;\n      }\n      break;\n    }\n\n    case IMPORTS: {\n      // Validate the AST before processing any imports (otherwise, untangling\n      // them can be error-prone and expensive).  A module will have a name and\n      // will already have been validated, but this catches the PCH case.\n      if (ASTReadResult Result = readUnhashedControlBlockOnce())\n        return Result;\n\n      // Load each of the imported PCH files.\n      unsigned Idx = 0, N = Record.size();\n      while (Idx < N) {\n        // Read information about the AST file.\n        ModuleKind ImportedKind = (ModuleKind)Record[Idx++];\n        // The import location will be the local one for now; we will adjust\n        // all import locations of module imports after the global source\n        // location info are setup, in ReadAST.\n        SourceLocation ImportLoc =\n            ReadUntranslatedSourceLocation(Record[Idx++]);\n        off_t StoredSize = (off_t)Record[Idx++];\n        time_t StoredModTime = (time_t)Record[Idx++];\n        auto FirstSignatureByte = Record.begin() + Idx;\n        ASTFileSignature StoredSignature = ASTFileSignature::create(\n            FirstSignatureByte, FirstSignatureByte + ASTFileSignature::size);\n        Idx += ASTFileSignature::size;\n\n        std::string ImportedName = ReadString(Record, Idx);\n        std::string ImportedFile;\n\n        // For prebuilt and explicit modules first consult the file map for\n        // an override. Note that here we don't search prebuilt module\n        // directories, only the explicit name to file mappings. Also, we will\n        // still verify the size/signature making sure it is essentially the\n        // same file but perhaps in a different location.\n        if (ImportedKind == MK_PrebuiltModule || ImportedKind == MK_ExplicitModule)\n          ImportedFile = PP.getHeaderSearchInfo().getPrebuiltModuleFileName(\n            ImportedName, /*FileMapOnly*/ true);\n\n        if (ImportedFile.empty())\n          // Use BaseDirectoryAsWritten to ensure we use the same path in the\n          // ModuleCache as when writing.\n          ImportedFile = ReadPath(BaseDirectoryAsWritten, Record, Idx);\n        else\n          SkipPath(Record, Idx);\n\n        // If our client can't cope with us being out of date, we can't cope with\n        // our dependency being missing.\n        unsigned Capabilities = ClientLoadCapabilities;\n        if ((ClientLoadCapabilities & ARR_OutOfDate) == 0)\n          Capabilities &= ~ARR_Missing;\n\n        // Load the AST file.\n        auto Result = ReadASTCore(ImportedFile, ImportedKind, ImportLoc, &F,\n                                  Loaded, StoredSize, StoredModTime,\n                                  StoredSignature, Capabilities);\n\n        // If we diagnosed a problem, produce a backtrace.\n        if (isDiagnosedResult(Result, Capabilities))\n          Diag(diag::note_module_file_imported_by)\n              << F.FileName << !F.ModuleName.empty() << F.ModuleName;\n\n        switch (Result) {\n        case Failure: return Failure;\n          // If we have to ignore the dependency, we'll have to ignore this too.\n        case Missing:\n        case OutOfDate: return OutOfDate;\n        case VersionMismatch: return VersionMismatch;\n        case ConfigurationMismatch: return ConfigurationMismatch;\n        case HadErrors: return HadErrors;\n        case Success: break;\n        }\n      }\n      break;\n    }\n\n    case ORIGINAL_FILE:\n      F.OriginalSourceFileID = FileID::get(Record[0]);\n      F.ActualOriginalSourceFileName = std::string(Blob);\n      F.OriginalSourceFileName = F.ActualOriginalSourceFileName;\n      ResolveImportedPath(F, F.OriginalSourceFileName);\n      break;\n\n    case ORIGINAL_FILE_ID:\n      F.OriginalSourceFileID = FileID::get(Record[0]);\n      break;\n\n    case ORIGINAL_PCH_DIR:\n      F.OriginalDir = std::string(Blob);\n      break;\n\n    case MODULE_NAME:\n      F.ModuleName = std::string(Blob);\n      Diag(diag::remark_module_import)\n          << F.ModuleName << F.FileName << (ImportedBy ? true : false)\n          << (ImportedBy ? StringRef(ImportedBy->ModuleName) : StringRef());\n      if (Listener)\n        Listener->ReadModuleName(F.ModuleName);\n\n      // Validate the AST as soon as we have a name so we can exit early on\n      // failure.\n      if (ASTReadResult Result = readUnhashedControlBlockOnce())\n        return Result;\n\n      break;\n\n    case MODULE_DIRECTORY: {\n      // Save the BaseDirectory as written in the PCM for computing the module\n      // filename for the ModuleCache.\n      BaseDirectoryAsWritten = Blob;\n      assert(!F.ModuleName.empty() &&\n             \"MODULE_DIRECTORY found before MODULE_NAME\");\n      // If we've already loaded a module map file covering this module, we may\n      // have a better path for it (relative to the current build).\n      Module *M = PP.getHeaderSearchInfo().lookupModule(\n          F.ModuleName, /*AllowSearch*/ true,\n          /*AllowExtraModuleMapSearch*/ true);\n      if (M && M->Directory) {\n        // If we're implicitly loading a module, the base directory can't\n        // change between the build and use.\n        // Don't emit module relocation error if we have -fno-validate-pch\n        if (!bool(PP.getPreprocessorOpts().DisablePCHOrModuleValidation &\n                  DisableValidationForModuleKind::Module) &&\n            F.Kind != MK_ExplicitModule && F.Kind != MK_PrebuiltModule) {\n          auto BuildDir = PP.getFileManager().getDirectory(Blob);\n          if (!BuildDir || *BuildDir != M->Directory) {\n            if ((ClientLoadCapabilities & ARR_OutOfDate) == 0)\n              Diag(diag::err_imported_module_relocated)\n                  << F.ModuleName << Blob << M->Directory->getName();\n            return OutOfDate;\n          }\n        }\n        F.BaseDirectory = std::string(M->Directory->getName());\n      } else {\n        F.BaseDirectory = std::string(Blob);\n      }\n      break;\n    }\n\n    case MODULE_MAP_FILE:\n      if (ASTReadResult Result =\n              ReadModuleMapFileBlock(Record, F, ImportedBy, ClientLoadCapabilities))\n        return Result;\n      break;\n\n    case INPUT_FILE_OFFSETS:\n      NumInputs = Record[0];\n      NumUserInputs = Record[1];\n      F.InputFileOffsets =\n          (const llvm::support::unaligned_uint64_t *)Blob.data();\n      F.InputFilesLoaded.resize(NumInputs);\n      F.NumUserInputFiles = NumUserInputs;\n      break;\n    }\n  }\n}\n\nASTReader::ASTReadResult\nASTReader::ReadASTBlock(ModuleFile &F, unsigned ClientLoadCapabilities) {\n  BitstreamCursor &Stream = F.Stream;\n\n  if (llvm::Error Err = Stream.EnterSubBlock(AST_BLOCK_ID)) {\n    Error(std::move(Err));\n    return Failure;\n  }\n  F.ASTBlockStartOffset = Stream.GetCurrentBitNo();\n\n  // Read all of the records and blocks for the AST file.\n  RecordData Record;\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry = Stream.advance();\n    if (!MaybeEntry) {\n      Error(MaybeEntry.takeError());\n      return Failure;\n    }\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case llvm::BitstreamEntry::Error:\n      Error(\"error at end of module block in AST file\");\n      return Failure;\n    case llvm::BitstreamEntry::EndBlock:\n      // Outside of C++, we do not store a lookup map for the translation unit.\n      // Instead, mark it as needing a lookup map to be built if this module\n      // contains any declarations lexically within it (which it always does!).\n      // This usually has no cost, since we very rarely need the lookup map for\n      // the translation unit outside C++.\n      if (ASTContext *Ctx = ContextObj) {\n        DeclContext *DC = Ctx->getTranslationUnitDecl();\n        if (DC->hasExternalLexicalStorage() && !Ctx->getLangOpts().CPlusPlus)\n          DC->setMustBuildLookupTable();\n      }\n\n      return Success;\n    case llvm::BitstreamEntry::SubBlock:\n      switch (Entry.ID) {\n      case DECLTYPES_BLOCK_ID:\n        // We lazily load the decls block, but we want to set up the\n        // DeclsCursor cursor to point into it.  Clone our current bitcode\n        // cursor to it, enter the block and read the abbrevs in that block.\n        // With the main cursor, we just skip over it.\n        F.DeclsCursor = Stream;\n        if (llvm::Error Err = Stream.SkipBlock()) {\n          Error(std::move(Err));\n          return Failure;\n        }\n        if (ReadBlockAbbrevs(F.DeclsCursor, DECLTYPES_BLOCK_ID,\n                             &F.DeclsBlockStartOffset)) {\n          Error(\"malformed block record in AST file\");\n          return Failure;\n        }\n        break;\n\n      case PREPROCESSOR_BLOCK_ID:\n        F.MacroCursor = Stream;\n        if (!PP.getExternalSource())\n          PP.setExternalSource(this);\n\n        if (llvm::Error Err = Stream.SkipBlock()) {\n          Error(std::move(Err));\n          return Failure;\n        }\n        if (ReadBlockAbbrevs(F.MacroCursor, PREPROCESSOR_BLOCK_ID)) {\n          Error(\"malformed block record in AST file\");\n          return Failure;\n        }\n        F.MacroStartOffset = F.MacroCursor.GetCurrentBitNo();\n        break;\n\n      case PREPROCESSOR_DETAIL_BLOCK_ID:\n        F.PreprocessorDetailCursor = Stream;\n\n        if (llvm::Error Err = Stream.SkipBlock()) {\n          Error(std::move(Err));\n          return Failure;\n        }\n        if (ReadBlockAbbrevs(F.PreprocessorDetailCursor,\n                             PREPROCESSOR_DETAIL_BLOCK_ID)) {\n          Error(\"malformed preprocessor detail record in AST file\");\n          return Failure;\n        }\n        F.PreprocessorDetailStartOffset\n        = F.PreprocessorDetailCursor.GetCurrentBitNo();\n\n        if (!PP.getPreprocessingRecord())\n          PP.createPreprocessingRecord();\n        if (!PP.getPreprocessingRecord()->getExternalSource())\n          PP.getPreprocessingRecord()->SetExternalSource(*this);\n        break;\n\n      case SOURCE_MANAGER_BLOCK_ID:\n        if (ReadSourceManagerBlock(F))\n          return Failure;\n        break;\n\n      case SUBMODULE_BLOCK_ID:\n        if (ASTReadResult Result =\n                ReadSubmoduleBlock(F, ClientLoadCapabilities))\n          return Result;\n        break;\n\n      case COMMENTS_BLOCK_ID: {\n        BitstreamCursor C = Stream;\n\n        if (llvm::Error Err = Stream.SkipBlock()) {\n          Error(std::move(Err));\n          return Failure;\n        }\n        if (ReadBlockAbbrevs(C, COMMENTS_BLOCK_ID)) {\n          Error(\"malformed comments block in AST file\");\n          return Failure;\n        }\n        CommentsCursors.push_back(std::make_pair(C, &F));\n        break;\n      }\n\n      default:\n        if (llvm::Error Err = Stream.SkipBlock()) {\n          Error(std::move(Err));\n          return Failure;\n        }\n        break;\n      }\n      continue;\n\n    case llvm::BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read and process a record.\n    Record.clear();\n    StringRef Blob;\n    Expected<unsigned> MaybeRecordType =\n        Stream.readRecord(Entry.ID, Record, &Blob);\n    if (!MaybeRecordType) {\n      Error(MaybeRecordType.takeError());\n      return Failure;\n    }\n    ASTRecordTypes RecordType = (ASTRecordTypes)MaybeRecordType.get();\n\n    // If we're not loading an AST context, we don't care about most records.\n    if (!ContextObj) {\n      switch (RecordType) {\n      case IDENTIFIER_TABLE:\n      case IDENTIFIER_OFFSET:\n      case INTERESTING_IDENTIFIERS:\n      case STATISTICS:\n      case PP_CONDITIONAL_STACK:\n      case PP_COUNTER_VALUE:\n      case SOURCE_LOCATION_OFFSETS:\n      case MODULE_OFFSET_MAP:\n      case SOURCE_MANAGER_LINE_TABLE:\n      case SOURCE_LOCATION_PRELOADS:\n      case PPD_ENTITIES_OFFSETS:\n      case HEADER_SEARCH_TABLE:\n      case IMPORTED_MODULES:\n      case MACRO_OFFSET:\n        break;\n      default:\n        continue;\n      }\n    }\n\n    switch (RecordType) {\n    default:  // Default behavior: ignore.\n      break;\n\n    case TYPE_OFFSET: {\n      if (F.LocalNumTypes != 0) {\n        Error(\"duplicate TYPE_OFFSET record in AST file\");\n        return Failure;\n      }\n      F.TypeOffsets = reinterpret_cast<const UnderalignedInt64 *>(Blob.data());\n      F.LocalNumTypes = Record[0];\n      unsigned LocalBaseTypeIndex = Record[1];\n      F.BaseTypeIndex = getTotalNumTypes();\n\n      if (F.LocalNumTypes > 0) {\n        // Introduce the global -> local mapping for types within this module.\n        GlobalTypeMap.insert(std::make_pair(getTotalNumTypes(), &F));\n\n        // Introduce the local -> global mapping for types within this module.\n        F.TypeRemap.insertOrReplace(\n          std::make_pair(LocalBaseTypeIndex,\n                         F.BaseTypeIndex - LocalBaseTypeIndex));\n\n        TypesLoaded.resize(TypesLoaded.size() + F.LocalNumTypes);\n      }\n      break;\n    }\n\n    case DECL_OFFSET: {\n      if (F.LocalNumDecls != 0) {\n        Error(\"duplicate DECL_OFFSET record in AST file\");\n        return Failure;\n      }\n      F.DeclOffsets = (const DeclOffset *)Blob.data();\n      F.LocalNumDecls = Record[0];\n      unsigned LocalBaseDeclID = Record[1];\n      F.BaseDeclID = getTotalNumDecls();\n\n      if (F.LocalNumDecls > 0) {\n        // Introduce the global -> local mapping for declarations within this\n        // module.\n        GlobalDeclMap.insert(\n          std::make_pair(getTotalNumDecls() + NUM_PREDEF_DECL_IDS, &F));\n\n        // Introduce the local -> global mapping for declarations within this\n        // module.\n        F.DeclRemap.insertOrReplace(\n          std::make_pair(LocalBaseDeclID, F.BaseDeclID - LocalBaseDeclID));\n\n        // Introduce the global -> local mapping for declarations within this\n        // module.\n        F.GlobalToLocalDeclIDs[&F] = LocalBaseDeclID;\n\n        DeclsLoaded.resize(DeclsLoaded.size() + F.LocalNumDecls);\n      }\n      break;\n    }\n\n    case TU_UPDATE_LEXICAL: {\n      DeclContext *TU = ContextObj->getTranslationUnitDecl();\n      LexicalContents Contents(\n          reinterpret_cast<const llvm::support::unaligned_uint32_t *>(\n              Blob.data()),\n          static_cast<unsigned int>(Blob.size() / 4));\n      TULexicalDecls.push_back(std::make_pair(&F, Contents));\n      TU->setHasExternalLexicalStorage(true);\n      break;\n    }\n\n    case UPDATE_VISIBLE: {\n      unsigned Idx = 0;\n      serialization::DeclID ID = ReadDeclID(F, Record, Idx);\n      auto *Data = (const unsigned char*)Blob.data();\n      PendingVisibleUpdates[ID].push_back(PendingVisibleUpdate{&F, Data});\n      // If we've already loaded the decl, perform the updates when we finish\n      // loading this block.\n      if (Decl *D = GetExistingDecl(ID))\n        PendingUpdateRecords.push_back(\n            PendingUpdateRecord(ID, D, /*JustLoaded=*/false));\n      break;\n    }\n\n    case IDENTIFIER_TABLE:\n      F.IdentifierTableData = Blob.data();\n      if (Record[0]) {\n        F.IdentifierLookupTable = ASTIdentifierLookupTable::Create(\n            (const unsigned char *)F.IdentifierTableData + Record[0],\n            (const unsigned char *)F.IdentifierTableData + sizeof(uint32_t),\n            (const unsigned char *)F.IdentifierTableData,\n            ASTIdentifierLookupTrait(*this, F));\n\n        PP.getIdentifierTable().setExternalIdentifierLookup(this);\n      }\n      break;\n\n    case IDENTIFIER_OFFSET: {\n      if (F.LocalNumIdentifiers != 0) {\n        Error(\"duplicate IDENTIFIER_OFFSET record in AST file\");\n        return Failure;\n      }\n      F.IdentifierOffsets = (const uint32_t *)Blob.data();\n      F.LocalNumIdentifiers = Record[0];\n      unsigned LocalBaseIdentifierID = Record[1];\n      F.BaseIdentifierID = getTotalNumIdentifiers();\n\n      if (F.LocalNumIdentifiers > 0) {\n        // Introduce the global -> local mapping for identifiers within this\n        // module.\n        GlobalIdentifierMap.insert(std::make_pair(getTotalNumIdentifiers() + 1,\n                                                  &F));\n\n        // Introduce the local -> global mapping for identifiers within this\n        // module.\n        F.IdentifierRemap.insertOrReplace(\n          std::make_pair(LocalBaseIdentifierID,\n                         F.BaseIdentifierID - LocalBaseIdentifierID));\n\n        IdentifiersLoaded.resize(IdentifiersLoaded.size()\n                                 + F.LocalNumIdentifiers);\n      }\n      break;\n    }\n\n    case INTERESTING_IDENTIFIERS:\n      F.PreloadIdentifierOffsets.assign(Record.begin(), Record.end());\n      break;\n\n    case EAGERLY_DESERIALIZED_DECLS:\n      // FIXME: Skip reading this record if our ASTConsumer doesn't care\n      // about \"interesting\" decls (for instance, if we're building a module).\n      for (unsigned I = 0, N = Record.size(); I != N; ++I)\n        EagerlyDeserializedDecls.push_back(getGlobalDeclID(F, Record[I]));\n      break;\n\n    case MODULAR_CODEGEN_DECLS:\n      // FIXME: Skip reading this record if our ASTConsumer doesn't care about\n      // them (ie: if we're not codegenerating this module).\n      if (F.Kind == MK_MainFile ||\n          getContext().getLangOpts().BuildingPCHWithObjectFile)\n        for (unsigned I = 0, N = Record.size(); I != N; ++I)\n          EagerlyDeserializedDecls.push_back(getGlobalDeclID(F, Record[I]));\n      break;\n\n    case SPECIAL_TYPES:\n      if (SpecialTypes.empty()) {\n        for (unsigned I = 0, N = Record.size(); I != N; ++I)\n          SpecialTypes.push_back(getGlobalTypeID(F, Record[I]));\n        break;\n      }\n\n      if (SpecialTypes.size() != Record.size()) {\n        Error(\"invalid special-types record\");\n        return Failure;\n      }\n\n      for (unsigned I = 0, N = Record.size(); I != N; ++I) {\n        serialization::TypeID ID = getGlobalTypeID(F, Record[I]);\n        if (!SpecialTypes[I])\n          SpecialTypes[I] = ID;\n        // FIXME: If ID && SpecialTypes[I] != ID, do we need a separate\n        // merge step?\n      }\n      break;\n\n    case STATISTICS:\n      TotalNumStatements += Record[0];\n      TotalNumMacros += Record[1];\n      TotalLexicalDeclContexts += Record[2];\n      TotalVisibleDeclContexts += Record[3];\n      break;\n\n    case UNUSED_FILESCOPED_DECLS:\n      for (unsigned I = 0, N = Record.size(); I != N; ++I)\n        UnusedFileScopedDecls.push_back(getGlobalDeclID(F, Record[I]));\n      break;\n\n    case DELEGATING_CTORS:\n      for (unsigned I = 0, N = Record.size(); I != N; ++I)\n        DelegatingCtorDecls.push_back(getGlobalDeclID(F, Record[I]));\n      break;\n\n    case WEAK_UNDECLARED_IDENTIFIERS:\n      if (Record.size() % 4 != 0) {\n        Error(\"invalid weak identifiers record\");\n        return Failure;\n      }\n\n      // FIXME: Ignore weak undeclared identifiers from non-original PCH\n      // files. This isn't the way to do it :)\n      WeakUndeclaredIdentifiers.clear();\n\n      // Translate the weak, undeclared identifiers into global IDs.\n      for (unsigned I = 0, N = Record.size(); I < N; /* in loop */) {\n        WeakUndeclaredIdentifiers.push_back(\n          getGlobalIdentifierID(F, Record[I++]));\n        WeakUndeclaredIdentifiers.push_back(\n          getGlobalIdentifierID(F, Record[I++]));\n        WeakUndeclaredIdentifiers.push_back(\n          ReadSourceLocation(F, Record, I).getRawEncoding());\n        WeakUndeclaredIdentifiers.push_back(Record[I++]);\n      }\n      break;\n\n    case SELECTOR_OFFSETS: {\n      F.SelectorOffsets = (const uint32_t *)Blob.data();\n      F.LocalNumSelectors = Record[0];\n      unsigned LocalBaseSelectorID = Record[1];\n      F.BaseSelectorID = getTotalNumSelectors();\n\n      if (F.LocalNumSelectors > 0) {\n        // Introduce the global -> local mapping for selectors within this\n        // module.\n        GlobalSelectorMap.insert(std::make_pair(getTotalNumSelectors()+1, &F));\n\n        // Introduce the local -> global mapping for selectors within this\n        // module.\n        F.SelectorRemap.insertOrReplace(\n          std::make_pair(LocalBaseSelectorID,\n                         F.BaseSelectorID - LocalBaseSelectorID));\n\n        SelectorsLoaded.resize(SelectorsLoaded.size() + F.LocalNumSelectors);\n      }\n      break;\n    }\n\n    case METHOD_POOL:\n      F.SelectorLookupTableData = (const unsigned char *)Blob.data();\n      if (Record[0])\n        F.SelectorLookupTable\n          = ASTSelectorLookupTable::Create(\n                        F.SelectorLookupTableData + Record[0],\n                        F.SelectorLookupTableData,\n                        ASTSelectorLookupTrait(*this, F));\n      TotalNumMethodPoolEntries += Record[1];\n      break;\n\n    case REFERENCED_SELECTOR_POOL:\n      if (!Record.empty()) {\n        for (unsigned Idx = 0, N = Record.size() - 1; Idx < N; /* in loop */) {\n          ReferencedSelectorsData.push_back(getGlobalSelectorID(F,\n                                                                Record[Idx++]));\n          ReferencedSelectorsData.push_back(ReadSourceLocation(F, Record, Idx).\n                                              getRawEncoding());\n        }\n      }\n      break;\n\n    case PP_CONDITIONAL_STACK:\n      if (!Record.empty()) {\n        unsigned Idx = 0, End = Record.size() - 1;\n        bool ReachedEOFWhileSkipping = Record[Idx++];\n        llvm::Optional<Preprocessor::PreambleSkipInfo> SkipInfo;\n        if (ReachedEOFWhileSkipping) {\n          SourceLocation HashToken = ReadSourceLocation(F, Record, Idx);\n          SourceLocation IfTokenLoc = ReadSourceLocation(F, Record, Idx);\n          bool FoundNonSkipPortion = Record[Idx++];\n          bool FoundElse = Record[Idx++];\n          SourceLocation ElseLoc = ReadSourceLocation(F, Record, Idx);\n          SkipInfo.emplace(HashToken, IfTokenLoc, FoundNonSkipPortion,\n                           FoundElse, ElseLoc);\n        }\n        SmallVector<PPConditionalInfo, 4> ConditionalStack;\n        while (Idx < End) {\n          auto Loc = ReadSourceLocation(F, Record, Idx);\n          bool WasSkipping = Record[Idx++];\n          bool FoundNonSkip = Record[Idx++];\n          bool FoundElse = Record[Idx++];\n          ConditionalStack.push_back(\n              {Loc, WasSkipping, FoundNonSkip, FoundElse});\n        }\n        PP.setReplayablePreambleConditionalStack(ConditionalStack, SkipInfo);\n      }\n      break;\n\n    case PP_COUNTER_VALUE:\n      if (!Record.empty() && Listener)\n        Listener->ReadCounter(F, Record[0]);\n      break;\n\n    case FILE_SORTED_DECLS:\n      F.FileSortedDecls = (const DeclID *)Blob.data();\n      F.NumFileSortedDecls = Record[0];\n      break;\n\n    case SOURCE_LOCATION_OFFSETS: {\n      F.SLocEntryOffsets = (const uint32_t *)Blob.data();\n      F.LocalNumSLocEntries = Record[0];\n      unsigned SLocSpaceSize = Record[1];\n      F.SLocEntryOffsetsBase = Record[2] + F.SourceManagerBlockStartOffset;\n      std::tie(F.SLocEntryBaseID, F.SLocEntryBaseOffset) =\n          SourceMgr.AllocateLoadedSLocEntries(F.LocalNumSLocEntries,\n                                              SLocSpaceSize);\n      if (!F.SLocEntryBaseID) {\n        Error(\"ran out of source locations\");\n        break;\n      }\n      // Make our entry in the range map. BaseID is negative and growing, so\n      // we invert it. Because we invert it, though, we need the other end of\n      // the range.\n      unsigned RangeStart =\n          unsigned(-F.SLocEntryBaseID) - F.LocalNumSLocEntries + 1;\n      GlobalSLocEntryMap.insert(std::make_pair(RangeStart, &F));\n      F.FirstLoc = SourceLocation::getFromRawEncoding(F.SLocEntryBaseOffset);\n\n      // SLocEntryBaseOffset is lower than MaxLoadedOffset and decreasing.\n      assert((F.SLocEntryBaseOffset & (1U << 31U)) == 0);\n      GlobalSLocOffsetMap.insert(\n          std::make_pair(SourceManager::MaxLoadedOffset - F.SLocEntryBaseOffset\n                           - SLocSpaceSize,&F));\n\n      // Initialize the remapping table.\n      // Invalid stays invalid.\n      F.SLocRemap.insertOrReplace(std::make_pair(0U, 0));\n      // This module. Base was 2 when being compiled.\n      F.SLocRemap.insertOrReplace(std::make_pair(2U,\n                                  static_cast<int>(F.SLocEntryBaseOffset - 2)));\n\n      TotalNumSLocEntries += F.LocalNumSLocEntries;\n      break;\n    }\n\n    case MODULE_OFFSET_MAP:\n      F.ModuleOffsetMap = Blob;\n      break;\n\n    case SOURCE_MANAGER_LINE_TABLE:\n      if (ParseLineTable(F, Record)) {\n        Error(\"malformed SOURCE_MANAGER_LINE_TABLE in AST file\");\n        return Failure;\n      }\n      break;\n\n    case SOURCE_LOCATION_PRELOADS: {\n      // Need to transform from the local view (1-based IDs) to the global view,\n      // which is based off F.SLocEntryBaseID.\n      if (!F.PreloadSLocEntries.empty()) {\n        Error(\"Multiple SOURCE_LOCATION_PRELOADS records in AST file\");\n        return Failure;\n      }\n\n      F.PreloadSLocEntries.swap(Record);\n      break;\n    }\n\n    case EXT_VECTOR_DECLS:\n      for (unsigned I = 0, N = Record.size(); I != N; ++I)\n        ExtVectorDecls.push_back(getGlobalDeclID(F, Record[I]));\n      break;\n\n    case VTABLE_USES:\n      if (Record.size() % 3 != 0) {\n        Error(\"Invalid VTABLE_USES record\");\n        return Failure;\n      }\n\n      // Later tables overwrite earlier ones.\n      // FIXME: Modules will have some trouble with this. This is clearly not\n      // the right way to do this.\n      VTableUses.clear();\n\n      for (unsigned Idx = 0, N = Record.size(); Idx != N; /* In loop */) {\n        VTableUses.push_back(getGlobalDeclID(F, Record[Idx++]));\n        VTableUses.push_back(\n          ReadSourceLocation(F, Record, Idx).getRawEncoding());\n        VTableUses.push_back(Record[Idx++]);\n      }\n      break;\n\n    case PENDING_IMPLICIT_INSTANTIATIONS:\n      if (PendingInstantiations.size() % 2 != 0) {\n        Error(\"Invalid existing PendingInstantiations\");\n        return Failure;\n      }\n\n      if (Record.size() % 2 != 0) {\n        Error(\"Invalid PENDING_IMPLICIT_INSTANTIATIONS block\");\n        return Failure;\n      }\n\n      for (unsigned I = 0, N = Record.size(); I != N; /* in loop */) {\n        PendingInstantiations.push_back(getGlobalDeclID(F, Record[I++]));\n        PendingInstantiations.push_back(\n          ReadSourceLocation(F, Record, I).getRawEncoding());\n      }\n      break;\n\n    case SEMA_DECL_REFS:\n      if (Record.size() != 3) {\n        Error(\"Invalid SEMA_DECL_REFS block\");\n        return Failure;\n      }\n      for (unsigned I = 0, N = Record.size(); I != N; ++I)\n        SemaDeclRefs.push_back(getGlobalDeclID(F, Record[I]));\n      break;\n\n    case PPD_ENTITIES_OFFSETS: {\n      F.PreprocessedEntityOffsets = (const PPEntityOffset *)Blob.data();\n      assert(Blob.size() % sizeof(PPEntityOffset) == 0);\n      F.NumPreprocessedEntities = Blob.size() / sizeof(PPEntityOffset);\n\n      unsigned LocalBasePreprocessedEntityID = Record[0];\n\n      unsigned StartingID;\n      if (!PP.getPreprocessingRecord())\n        PP.createPreprocessingRecord();\n      if (!PP.getPreprocessingRecord()->getExternalSource())\n        PP.getPreprocessingRecord()->SetExternalSource(*this);\n      StartingID\n        = PP.getPreprocessingRecord()\n            ->allocateLoadedEntities(F.NumPreprocessedEntities);\n      F.BasePreprocessedEntityID = StartingID;\n\n      if (F.NumPreprocessedEntities > 0) {\n        // Introduce the global -> local mapping for preprocessed entities in\n        // this module.\n        GlobalPreprocessedEntityMap.insert(std::make_pair(StartingID, &F));\n\n        // Introduce the local -> global mapping for preprocessed entities in\n        // this module.\n        F.PreprocessedEntityRemap.insertOrReplace(\n          std::make_pair(LocalBasePreprocessedEntityID,\n            F.BasePreprocessedEntityID - LocalBasePreprocessedEntityID));\n      }\n\n      break;\n    }\n\n    case PPD_SKIPPED_RANGES: {\n      F.PreprocessedSkippedRangeOffsets = (const PPSkippedRange*)Blob.data();\n      assert(Blob.size() % sizeof(PPSkippedRange) == 0);\n      F.NumPreprocessedSkippedRanges = Blob.size() / sizeof(PPSkippedRange);\n\n      if (!PP.getPreprocessingRecord())\n        PP.createPreprocessingRecord();\n      if (!PP.getPreprocessingRecord()->getExternalSource())\n        PP.getPreprocessingRecord()->SetExternalSource(*this);\n      F.BasePreprocessedSkippedRangeID = PP.getPreprocessingRecord()\n          ->allocateSkippedRanges(F.NumPreprocessedSkippedRanges);\n\n      if (F.NumPreprocessedSkippedRanges > 0)\n        GlobalSkippedRangeMap.insert(\n            std::make_pair(F.BasePreprocessedSkippedRangeID, &F));\n      break;\n    }\n\n    case DECL_UPDATE_OFFSETS:\n      if (Record.size() % 2 != 0) {\n        Error(\"invalid DECL_UPDATE_OFFSETS block in AST file\");\n        return Failure;\n      }\n      for (unsigned I = 0, N = Record.size(); I != N; I += 2) {\n        GlobalDeclID ID = getGlobalDeclID(F, Record[I]);\n        DeclUpdateOffsets[ID].push_back(std::make_pair(&F, Record[I + 1]));\n\n        // If we've already loaded the decl, perform the updates when we finish\n        // loading this block.\n        if (Decl *D = GetExistingDecl(ID))\n          PendingUpdateRecords.push_back(\n              PendingUpdateRecord(ID, D, /*JustLoaded=*/false));\n      }\n      break;\n\n    case OBJC_CATEGORIES_MAP:\n      if (F.LocalNumObjCCategoriesInMap != 0) {\n        Error(\"duplicate OBJC_CATEGORIES_MAP record in AST file\");\n        return Failure;\n      }\n\n      F.LocalNumObjCCategoriesInMap = Record[0];\n      F.ObjCCategoriesMap = (const ObjCCategoriesInfo *)Blob.data();\n      break;\n\n    case OBJC_CATEGORIES:\n      F.ObjCCategories.swap(Record);\n      break;\n\n    case CUDA_SPECIAL_DECL_REFS:\n      // Later tables overwrite earlier ones.\n      // FIXME: Modules will have trouble with this.\n      CUDASpecialDeclRefs.clear();\n      for (unsigned I = 0, N = Record.size(); I != N; ++I)\n        CUDASpecialDeclRefs.push_back(getGlobalDeclID(F, Record[I]));\n      break;\n\n    case HEADER_SEARCH_TABLE:\n      F.HeaderFileInfoTableData = Blob.data();\n      F.LocalNumHeaderFileInfos = Record[1];\n      if (Record[0]) {\n        F.HeaderFileInfoTable\n          = HeaderFileInfoLookupTable::Create(\n                   (const unsigned char *)F.HeaderFileInfoTableData + Record[0],\n                   (const unsigned char *)F.HeaderFileInfoTableData,\n                   HeaderFileInfoTrait(*this, F,\n                                       &PP.getHeaderSearchInfo(),\n                                       Blob.data() + Record[2]));\n\n        PP.getHeaderSearchInfo().SetExternalSource(this);\n        if (!PP.getHeaderSearchInfo().getExternalLookup())\n          PP.getHeaderSearchInfo().SetExternalLookup(this);\n      }\n      break;\n\n    case FP_PRAGMA_OPTIONS:\n      // Later tables overwrite earlier ones.\n      FPPragmaOptions.swap(Record);\n      break;\n\n    case OPENCL_EXTENSIONS:\n      for (unsigned I = 0, E = Record.size(); I != E; ) {\n        auto Name = ReadString(Record, I);\n        auto &OptInfo = OpenCLExtensions.OptMap[Name];\n        OptInfo.Supported = Record[I++] != 0;\n        OptInfo.Enabled = Record[I++] != 0;\n        OptInfo.Avail = Record[I++];\n        OptInfo.Core = Record[I++];\n        OptInfo.Opt = Record[I++];\n      }\n      break;\n\n    case OPENCL_EXTENSION_TYPES:\n      for (unsigned I = 0, E = Record.size(); I != E;) {\n        auto TypeID = static_cast<::TypeID>(Record[I++]);\n        auto *Type = GetType(TypeID).getTypePtr();\n        auto NumExt = static_cast<unsigned>(Record[I++]);\n        for (unsigned II = 0; II != NumExt; ++II) {\n          auto Ext = ReadString(Record, I);\n          OpenCLTypeExtMap[Type].insert(Ext);\n        }\n      }\n      break;\n\n    case OPENCL_EXTENSION_DECLS:\n      for (unsigned I = 0, E = Record.size(); I != E;) {\n        auto DeclID = static_cast<::DeclID>(Record[I++]);\n        auto *Decl = GetDecl(DeclID);\n        auto NumExt = static_cast<unsigned>(Record[I++]);\n        for (unsigned II = 0; II != NumExt; ++II) {\n          auto Ext = ReadString(Record, I);\n          OpenCLDeclExtMap[Decl].insert(Ext);\n        }\n      }\n      break;\n\n    case TENTATIVE_DEFINITIONS:\n      for (unsigned I = 0, N = Record.size(); I != N; ++I)\n        TentativeDefinitions.push_back(getGlobalDeclID(F, Record[I]));\n      break;\n\n    case KNOWN_NAMESPACES:\n      for (unsigned I = 0, N = Record.size(); I != N; ++I)\n        KnownNamespaces.push_back(getGlobalDeclID(F, Record[I]));\n      break;\n\n    case UNDEFINED_BUT_USED:\n      if (UndefinedButUsed.size() % 2 != 0) {\n        Error(\"Invalid existing UndefinedButUsed\");\n        return Failure;\n      }\n\n      if (Record.size() % 2 != 0) {\n        Error(\"invalid undefined-but-used record\");\n        return Failure;\n      }\n      for (unsigned I = 0, N = Record.size(); I != N; /* in loop */) {\n        UndefinedButUsed.push_back(getGlobalDeclID(F, Record[I++]));\n        UndefinedButUsed.push_back(\n            ReadSourceLocation(F, Record, I).getRawEncoding());\n      }\n      break;\n\n    case DELETE_EXPRS_TO_ANALYZE:\n      for (unsigned I = 0, N = Record.size(); I != N;) {\n        DelayedDeleteExprs.push_back(getGlobalDeclID(F, Record[I++]));\n        const uint64_t Count = Record[I++];\n        DelayedDeleteExprs.push_back(Count);\n        for (uint64_t C = 0; C < Count; ++C) {\n          DelayedDeleteExprs.push_back(ReadSourceLocation(F, Record, I).getRawEncoding());\n          bool IsArrayForm = Record[I++] == 1;\n          DelayedDeleteExprs.push_back(IsArrayForm);\n        }\n      }\n      break;\n\n    case IMPORTED_MODULES:\n      if (!F.isModule()) {\n        // If we aren't loading a module (which has its own exports), make\n        // all of the imported modules visible.\n        // FIXME: Deal with macros-only imports.\n        for (unsigned I = 0, N = Record.size(); I != N; /**/) {\n          unsigned GlobalID = getGlobalSubmoduleID(F, Record[I++]);\n          SourceLocation Loc = ReadSourceLocation(F, Record, I);\n          if (GlobalID) {\n            ImportedModules.push_back(ImportedSubmodule(GlobalID, Loc));\n            if (DeserializationListener)\n              DeserializationListener->ModuleImportRead(GlobalID, Loc);\n          }\n        }\n      }\n      break;\n\n    case MACRO_OFFSET: {\n      if (F.LocalNumMacros != 0) {\n        Error(\"duplicate MACRO_OFFSET record in AST file\");\n        return Failure;\n      }\n      F.MacroOffsets = (const uint32_t *)Blob.data();\n      F.LocalNumMacros = Record[0];\n      unsigned LocalBaseMacroID = Record[1];\n      F.MacroOffsetsBase = Record[2] + F.ASTBlockStartOffset;\n      F.BaseMacroID = getTotalNumMacros();\n\n      if (F.LocalNumMacros > 0) {\n        // Introduce the global -> local mapping for macros within this module.\n        GlobalMacroMap.insert(std::make_pair(getTotalNumMacros() + 1, &F));\n\n        // Introduce the local -> global mapping for macros within this module.\n        F.MacroRemap.insertOrReplace(\n          std::make_pair(LocalBaseMacroID,\n                         F.BaseMacroID - LocalBaseMacroID));\n\n        MacrosLoaded.resize(MacrosLoaded.size() + F.LocalNumMacros);\n      }\n      break;\n    }\n\n    case LATE_PARSED_TEMPLATE:\n      LateParsedTemplates.emplace_back(\n          std::piecewise_construct, std::forward_as_tuple(&F),\n          std::forward_as_tuple(Record.begin(), Record.end()));\n      break;\n\n    case OPTIMIZE_PRAGMA_OPTIONS:\n      if (Record.size() != 1) {\n        Error(\"invalid pragma optimize record\");\n        return Failure;\n      }\n      OptimizeOffPragmaLocation = ReadSourceLocation(F, Record[0]);\n      break;\n\n    case MSSTRUCT_PRAGMA_OPTIONS:\n      if (Record.size() != 1) {\n        Error(\"invalid pragma ms_struct record\");\n        return Failure;\n      }\n      PragmaMSStructState = Record[0];\n      break;\n\n    case POINTERS_TO_MEMBERS_PRAGMA_OPTIONS:\n      if (Record.size() != 2) {\n        Error(\"invalid pragma ms_struct record\");\n        return Failure;\n      }\n      PragmaMSPointersToMembersState = Record[0];\n      PointersToMembersPragmaLocation = ReadSourceLocation(F, Record[1]);\n      break;\n\n    case UNUSED_LOCAL_TYPEDEF_NAME_CANDIDATES:\n      for (unsigned I = 0, N = Record.size(); I != N; ++I)\n        UnusedLocalTypedefNameCandidates.push_back(\n            getGlobalDeclID(F, Record[I]));\n      break;\n\n    case CUDA_PRAGMA_FORCE_HOST_DEVICE_DEPTH:\n      if (Record.size() != 1) {\n        Error(\"invalid cuda pragma options record\");\n        return Failure;\n      }\n      ForceCUDAHostDeviceDepth = Record[0];\n      break;\n\n    case ALIGN_PACK_PRAGMA_OPTIONS: {\n      if (Record.size() < 3) {\n        Error(\"invalid pragma pack record\");\n        return Failure;\n      }\n      PragmaAlignPackCurrentValue = ReadAlignPackInfo(Record[0]);\n      PragmaAlignPackCurrentLocation = ReadSourceLocation(F, Record[1]);\n      unsigned NumStackEntries = Record[2];\n      unsigned Idx = 3;\n      // Reset the stack when importing a new module.\n      PragmaAlignPackStack.clear();\n      for (unsigned I = 0; I < NumStackEntries; ++I) {\n        PragmaAlignPackStackEntry Entry;\n        Entry.Value = ReadAlignPackInfo(Record[Idx++]);\n        Entry.Location = ReadSourceLocation(F, Record[Idx++]);\n        Entry.PushLocation = ReadSourceLocation(F, Record[Idx++]);\n        PragmaAlignPackStrings.push_back(ReadString(Record, Idx));\n        Entry.SlotLabel = PragmaAlignPackStrings.back();\n        PragmaAlignPackStack.push_back(Entry);\n      }\n      break;\n    }\n\n    case FLOAT_CONTROL_PRAGMA_OPTIONS: {\n      if (Record.size() < 3) {\n        Error(\"invalid pragma pack record\");\n        return Failure;\n      }\n      FpPragmaCurrentValue = FPOptionsOverride::getFromOpaqueInt(Record[0]);\n      FpPragmaCurrentLocation = ReadSourceLocation(F, Record[1]);\n      unsigned NumStackEntries = Record[2];\n      unsigned Idx = 3;\n      // Reset the stack when importing a new module.\n      FpPragmaStack.clear();\n      for (unsigned I = 0; I < NumStackEntries; ++I) {\n        FpPragmaStackEntry Entry;\n        Entry.Value = FPOptionsOverride::getFromOpaqueInt(Record[Idx++]);\n        Entry.Location = ReadSourceLocation(F, Record[Idx++]);\n        Entry.PushLocation = ReadSourceLocation(F, Record[Idx++]);\n        FpPragmaStrings.push_back(ReadString(Record, Idx));\n        Entry.SlotLabel = FpPragmaStrings.back();\n        FpPragmaStack.push_back(Entry);\n      }\n      break;\n    }\n\n    case DECLS_TO_CHECK_FOR_DEFERRED_DIAGS:\n      for (unsigned I = 0, N = Record.size(); I != N; ++I)\n        DeclsToCheckForDeferredDiags.push_back(getGlobalDeclID(F, Record[I]));\n      break;\n    }\n  }\n}\n\nvoid ASTReader::ReadModuleOffsetMap(ModuleFile &F) const {\n  assert(!F.ModuleOffsetMap.empty() && \"no module offset map to read\");\n\n  // Additional remapping information.\n  const unsigned char *Data = (const unsigned char*)F.ModuleOffsetMap.data();\n  const unsigned char *DataEnd = Data + F.ModuleOffsetMap.size();\n  F.ModuleOffsetMap = StringRef();\n\n  // If we see this entry before SOURCE_LOCATION_OFFSETS, add placeholders.\n  if (F.SLocRemap.find(0) == F.SLocRemap.end()) {\n    F.SLocRemap.insert(std::make_pair(0U, 0));\n    F.SLocRemap.insert(std::make_pair(2U, 1));\n  }\n\n  // Continuous range maps we may be updating in our module.\n  using RemapBuilder = ContinuousRangeMap<uint32_t, int, 2>::Builder;\n  RemapBuilder SLocRemap(F.SLocRemap);\n  RemapBuilder IdentifierRemap(F.IdentifierRemap);\n  RemapBuilder MacroRemap(F.MacroRemap);\n  RemapBuilder PreprocessedEntityRemap(F.PreprocessedEntityRemap);\n  RemapBuilder SubmoduleRemap(F.SubmoduleRemap);\n  RemapBuilder SelectorRemap(F.SelectorRemap);\n  RemapBuilder DeclRemap(F.DeclRemap);\n  RemapBuilder TypeRemap(F.TypeRemap);\n\n  while (Data < DataEnd) {\n    // FIXME: Looking up dependency modules by filename is horrible. Let's\n    // start fixing this with prebuilt, explicit and implicit modules and see\n    // how it goes...\n    using namespace llvm::support;\n    ModuleKind Kind = static_cast<ModuleKind>(\n      endian::readNext<uint8_t, little, unaligned>(Data));\n    uint16_t Len = endian::readNext<uint16_t, little, unaligned>(Data);\n    StringRef Name = StringRef((const char*)Data, Len);\n    Data += Len;\n    ModuleFile *OM = (Kind == MK_PrebuiltModule || Kind == MK_ExplicitModule ||\n                              Kind == MK_ImplicitModule\n                          ? ModuleMgr.lookupByModuleName(Name)\n                          : ModuleMgr.lookupByFileName(Name));\n    if (!OM) {\n      std::string Msg =\n          \"SourceLocation remap refers to unknown module, cannot find \";\n      Msg.append(std::string(Name));\n      Error(Msg);\n      return;\n    }\n\n    uint32_t SLocOffset =\n        endian::readNext<uint32_t, little, unaligned>(Data);\n    uint32_t IdentifierIDOffset =\n        endian::readNext<uint32_t, little, unaligned>(Data);\n    uint32_t MacroIDOffset =\n        endian::readNext<uint32_t, little, unaligned>(Data);\n    uint32_t PreprocessedEntityIDOffset =\n        endian::readNext<uint32_t, little, unaligned>(Data);\n    uint32_t SubmoduleIDOffset =\n        endian::readNext<uint32_t, little, unaligned>(Data);\n    uint32_t SelectorIDOffset =\n        endian::readNext<uint32_t, little, unaligned>(Data);\n    uint32_t DeclIDOffset =\n        endian::readNext<uint32_t, little, unaligned>(Data);\n    uint32_t TypeIndexOffset =\n        endian::readNext<uint32_t, little, unaligned>(Data);\n\n    uint32_t None = std::numeric_limits<uint32_t>::max();\n\n    auto mapOffset = [&](uint32_t Offset, uint32_t BaseOffset,\n                         RemapBuilder &Remap) {\n      if (Offset != None)\n        Remap.insert(std::make_pair(Offset,\n                                    static_cast<int>(BaseOffset - Offset)));\n    };\n    mapOffset(SLocOffset, OM->SLocEntryBaseOffset, SLocRemap);\n    mapOffset(IdentifierIDOffset, OM->BaseIdentifierID, IdentifierRemap);\n    mapOffset(MacroIDOffset, OM->BaseMacroID, MacroRemap);\n    mapOffset(PreprocessedEntityIDOffset, OM->BasePreprocessedEntityID,\n              PreprocessedEntityRemap);\n    mapOffset(SubmoduleIDOffset, OM->BaseSubmoduleID, SubmoduleRemap);\n    mapOffset(SelectorIDOffset, OM->BaseSelectorID, SelectorRemap);\n    mapOffset(DeclIDOffset, OM->BaseDeclID, DeclRemap);\n    mapOffset(TypeIndexOffset, OM->BaseTypeIndex, TypeRemap);\n\n    // Global -> local mappings.\n    F.GlobalToLocalDeclIDs[OM] = DeclIDOffset;\n  }\n}\n\nASTReader::ASTReadResult\nASTReader::ReadModuleMapFileBlock(RecordData &Record, ModuleFile &F,\n                                  const ModuleFile *ImportedBy,\n                                  unsigned ClientLoadCapabilities) {\n  unsigned Idx = 0;\n  F.ModuleMapPath = ReadPath(F, Record, Idx);\n\n  // Try to resolve ModuleName in the current header search context and\n  // verify that it is found in the same module map file as we saved. If the\n  // top-level AST file is a main file, skip this check because there is no\n  // usable header search context.\n  assert(!F.ModuleName.empty() &&\n         \"MODULE_NAME should come before MODULE_MAP_FILE\");\n  if (F.Kind == MK_ImplicitModule && ModuleMgr.begin()->Kind != MK_MainFile) {\n    // An implicitly-loaded module file should have its module listed in some\n    // module map file that we've already loaded.\n    Module *M = PP.getHeaderSearchInfo().lookupModule(F.ModuleName);\n    auto &Map = PP.getHeaderSearchInfo().getModuleMap();\n    const FileEntry *ModMap = M ? Map.getModuleMapFileForUniquing(M) : nullptr;\n    // Don't emit module relocation error if we have -fno-validate-pch\n    if (!bool(PP.getPreprocessorOpts().DisablePCHOrModuleValidation &\n              DisableValidationForModuleKind::Module) &&\n        !ModMap) {\n      if ((ClientLoadCapabilities & ARR_OutOfDate) == 0) {\n        if (auto ASTFE = M ? M->getASTFile() : None) {\n          // This module was defined by an imported (explicit) module.\n          Diag(diag::err_module_file_conflict) << F.ModuleName << F.FileName\n                                               << ASTFE->getName();\n        } else {\n          // This module was built with a different module map.\n          Diag(diag::err_imported_module_not_found)\n              << F.ModuleName << F.FileName\n              << (ImportedBy ? ImportedBy->FileName : \"\") << F.ModuleMapPath\n              << !ImportedBy;\n          // In case it was imported by a PCH, there's a chance the user is\n          // just missing to include the search path to the directory containing\n          // the modulemap.\n          if (ImportedBy && ImportedBy->Kind == MK_PCH)\n            Diag(diag::note_imported_by_pch_module_not_found)\n                << llvm::sys::path::parent_path(F.ModuleMapPath);\n        }\n      }\n      return OutOfDate;\n    }\n\n    assert(M && M->Name == F.ModuleName && \"found module with different name\");\n\n    // Check the primary module map file.\n    auto StoredModMap = FileMgr.getFile(F.ModuleMapPath);\n    if (!StoredModMap || *StoredModMap != ModMap) {\n      assert(ModMap && \"found module is missing module map file\");\n      assert((ImportedBy || F.Kind == MK_ImplicitModule) &&\n             \"top-level import should be verified\");\n      bool NotImported = F.Kind == MK_ImplicitModule && !ImportedBy;\n      if ((ClientLoadCapabilities & ARR_OutOfDate) == 0)\n        Diag(diag::err_imported_module_modmap_changed)\n            << F.ModuleName << (NotImported ? F.FileName : ImportedBy->FileName)\n            << ModMap->getName() << F.ModuleMapPath << NotImported;\n      return OutOfDate;\n    }\n\n    llvm::SmallPtrSet<const FileEntry *, 1> AdditionalStoredMaps;\n    for (unsigned I = 0, N = Record[Idx++]; I < N; ++I) {\n      // FIXME: we should use input files rather than storing names.\n      std::string Filename = ReadPath(F, Record, Idx);\n      auto F = FileMgr.getFile(Filename, false, false);\n      if (!F) {\n        if ((ClientLoadCapabilities & ARR_OutOfDate) == 0)\n          Error(\"could not find file '\" + Filename +\"' referenced by AST file\");\n        return OutOfDate;\n      }\n      AdditionalStoredMaps.insert(*F);\n    }\n\n    // Check any additional module map files (e.g. module.private.modulemap)\n    // that are not in the pcm.\n    if (auto *AdditionalModuleMaps = Map.getAdditionalModuleMapFiles(M)) {\n      for (const FileEntry *ModMap : *AdditionalModuleMaps) {\n        // Remove files that match\n        // Note: SmallPtrSet::erase is really remove\n        if (!AdditionalStoredMaps.erase(ModMap)) {\n          if ((ClientLoadCapabilities & ARR_OutOfDate) == 0)\n            Diag(diag::err_module_different_modmap)\n              << F.ModuleName << /*new*/0 << ModMap->getName();\n          return OutOfDate;\n        }\n      }\n    }\n\n    // Check any additional module map files that are in the pcm, but not\n    // found in header search. Cases that match are already removed.\n    for (const FileEntry *ModMap : AdditionalStoredMaps) {\n      if ((ClientLoadCapabilities & ARR_OutOfDate) == 0)\n        Diag(diag::err_module_different_modmap)\n          << F.ModuleName << /*not new*/1 << ModMap->getName();\n      return OutOfDate;\n    }\n  }\n\n  if (Listener)\n    Listener->ReadModuleMapFile(F.ModuleMapPath);\n  return Success;\n}\n\n/// Move the given method to the back of the global list of methods.\nstatic void moveMethodToBackOfGlobalList(Sema &S, ObjCMethodDecl *Method) {\n  // Find the entry for this selector in the method pool.\n  Sema::GlobalMethodPool::iterator Known\n    = S.MethodPool.find(Method->getSelector());\n  if (Known == S.MethodPool.end())\n    return;\n\n  // Retrieve the appropriate method list.\n  ObjCMethodList &Start = Method->isInstanceMethod()? Known->second.first\n                                                    : Known->second.second;\n  bool Found = false;\n  for (ObjCMethodList *List = &Start; List; List = List->getNext()) {\n    if (!Found) {\n      if (List->getMethod() == Method) {\n        Found = true;\n      } else {\n        // Keep searching.\n        continue;\n      }\n    }\n\n    if (List->getNext())\n      List->setMethod(List->getNext()->getMethod());\n    else\n      List->setMethod(Method);\n  }\n}\n\nvoid ASTReader::makeNamesVisible(const HiddenNames &Names, Module *Owner) {\n  assert(Owner->NameVisibility != Module::Hidden && \"nothing to make visible?\");\n  for (Decl *D : Names) {\n    bool wasHidden = !D->isUnconditionallyVisible();\n    D->setVisibleDespiteOwningModule();\n\n    if (wasHidden && SemaObj) {\n      if (ObjCMethodDecl *Method = dyn_cast<ObjCMethodDecl>(D)) {\n        moveMethodToBackOfGlobalList(*SemaObj, Method);\n      }\n    }\n  }\n}\n\nvoid ASTReader::makeModuleVisible(Module *Mod,\n                                  Module::NameVisibilityKind NameVisibility,\n                                  SourceLocation ImportLoc) {\n  llvm::SmallPtrSet<Module *, 4> Visited;\n  SmallVector<Module *, 4> Stack;\n  Stack.push_back(Mod);\n  while (!Stack.empty()) {\n    Mod = Stack.pop_back_val();\n\n    if (NameVisibility <= Mod->NameVisibility) {\n      // This module already has this level of visibility (or greater), so\n      // there is nothing more to do.\n      continue;\n    }\n\n    if (Mod->isUnimportable()) {\n      // Modules that aren't importable cannot be made visible.\n      continue;\n    }\n\n    // Update the module's name visibility.\n    Mod->NameVisibility = NameVisibility;\n\n    // If we've already deserialized any names from this module,\n    // mark them as visible.\n    HiddenNamesMapType::iterator Hidden = HiddenNamesMap.find(Mod);\n    if (Hidden != HiddenNamesMap.end()) {\n      auto HiddenNames = std::move(*Hidden);\n      HiddenNamesMap.erase(Hidden);\n      makeNamesVisible(HiddenNames.second, HiddenNames.first);\n      assert(HiddenNamesMap.find(Mod) == HiddenNamesMap.end() &&\n             \"making names visible added hidden names\");\n    }\n\n    // Push any exported modules onto the stack to be marked as visible.\n    SmallVector<Module *, 16> Exports;\n    Mod->getExportedModules(Exports);\n    for (SmallVectorImpl<Module *>::iterator\n           I = Exports.begin(), E = Exports.end(); I != E; ++I) {\n      Module *Exported = *I;\n      if (Visited.insert(Exported).second)\n        Stack.push_back(Exported);\n    }\n  }\n}\n\n/// We've merged the definition \\p MergedDef into the existing definition\n/// \\p Def. Ensure that \\p Def is made visible whenever \\p MergedDef is made\n/// visible.\nvoid ASTReader::mergeDefinitionVisibility(NamedDecl *Def,\n                                          NamedDecl *MergedDef) {\n  if (!Def->isUnconditionallyVisible()) {\n    // If MergedDef is visible or becomes visible, make the definition visible.\n    if (MergedDef->isUnconditionallyVisible())\n      Def->setVisibleDespiteOwningModule();\n    else {\n      getContext().mergeDefinitionIntoModule(\n          Def, MergedDef->getImportedOwningModule(),\n          /*NotifyListeners*/ false);\n      PendingMergedDefinitionsToDeduplicate.insert(Def);\n    }\n  }\n}\n\nbool ASTReader::loadGlobalIndex() {\n  if (GlobalIndex)\n    return false;\n\n  if (TriedLoadingGlobalIndex || !UseGlobalIndex ||\n      !PP.getLangOpts().Modules)\n    return true;\n\n  // Try to load the global index.\n  TriedLoadingGlobalIndex = true;\n  StringRef ModuleCachePath\n    = getPreprocessor().getHeaderSearchInfo().getModuleCachePath();\n  std::pair<GlobalModuleIndex *, llvm::Error> Result =\n      GlobalModuleIndex::readIndex(ModuleCachePath);\n  if (llvm::Error Err = std::move(Result.second)) {\n    assert(!Result.first);\n    consumeError(std::move(Err)); // FIXME this drops errors on the floor.\n    return true;\n  }\n\n  GlobalIndex.reset(Result.first);\n  ModuleMgr.setGlobalIndex(GlobalIndex.get());\n  return false;\n}\n\nbool ASTReader::isGlobalIndexUnavailable() const {\n  return PP.getLangOpts().Modules && UseGlobalIndex &&\n         !hasGlobalIndex() && TriedLoadingGlobalIndex;\n}\n\nstatic void updateModuleTimestamp(ModuleFile &MF) {\n  // Overwrite the timestamp file contents so that file's mtime changes.\n  std::string TimestampFilename = MF.getTimestampFilename();\n  std::error_code EC;\n  llvm::raw_fd_ostream OS(TimestampFilename, EC, llvm::sys::fs::OF_Text);\n  if (EC)\n    return;\n  OS << \"Timestamp file\\n\";\n  OS.close();\n  OS.clear_error(); // Avoid triggering a fatal error.\n}\n\n/// Given a cursor at the start of an AST file, scan ahead and drop the\n/// cursor into the start of the given block ID, returning false on success and\n/// true on failure.\nstatic bool SkipCursorToBlock(BitstreamCursor &Cursor, unsigned BlockID) {\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry = Cursor.advance();\n    if (!MaybeEntry) {\n      // FIXME this drops errors on the floor.\n      consumeError(MaybeEntry.takeError());\n      return true;\n    }\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case llvm::BitstreamEntry::Error:\n    case llvm::BitstreamEntry::EndBlock:\n      return true;\n\n    case llvm::BitstreamEntry::Record:\n      // Ignore top-level records.\n      if (Expected<unsigned> Skipped = Cursor.skipRecord(Entry.ID))\n        break;\n      else {\n        // FIXME this drops errors on the floor.\n        consumeError(Skipped.takeError());\n        return true;\n      }\n\n    case llvm::BitstreamEntry::SubBlock:\n      if (Entry.ID == BlockID) {\n        if (llvm::Error Err = Cursor.EnterSubBlock(BlockID)) {\n          // FIXME this drops the error on the floor.\n          consumeError(std::move(Err));\n          return true;\n        }\n        // Found it!\n        return false;\n      }\n\n      if (llvm::Error Err = Cursor.SkipBlock()) {\n        // FIXME this drops the error on the floor.\n        consumeError(std::move(Err));\n        return true;\n      }\n    }\n  }\n}\n\nASTReader::ASTReadResult ASTReader::ReadAST(StringRef FileName,\n                                            ModuleKind Type,\n                                            SourceLocation ImportLoc,\n                                            unsigned ClientLoadCapabilities,\n                                            SmallVectorImpl<ImportedSubmodule> *Imported) {\n  llvm::SaveAndRestore<SourceLocation>\n    SetCurImportLocRAII(CurrentImportLoc, ImportLoc);\n  llvm::SaveAndRestore<Optional<ModuleKind>> SetCurModuleKindRAII(\n      CurrentDeserializingModuleKind, Type);\n\n  // Defer any pending actions until we get to the end of reading the AST file.\n  Deserializing AnASTFile(this);\n\n  // Bump the generation number.\n  unsigned PreviousGeneration = 0;\n  if (ContextObj)\n    PreviousGeneration = incrementGeneration(*ContextObj);\n\n  unsigned NumModules = ModuleMgr.size();\n  auto removeModulesAndReturn = [&](ASTReadResult ReadResult) {\n    assert(ReadResult && \"expected to return error\");\n    ModuleMgr.removeModules(ModuleMgr.begin() + NumModules,\n                            PP.getLangOpts().Modules\n                                ? &PP.getHeaderSearchInfo().getModuleMap()\n                                : nullptr);\n\n    // If we find that any modules are unusable, the global index is going\n    // to be out-of-date. Just remove it.\n    GlobalIndex.reset();\n    ModuleMgr.setGlobalIndex(nullptr);\n    return ReadResult;\n  };\n\n  SmallVector<ImportedModule, 4> Loaded;\n  switch (ASTReadResult ReadResult =\n              ReadASTCore(FileName, Type, ImportLoc,\n                          /*ImportedBy=*/nullptr, Loaded, 0, 0,\n                          ASTFileSignature(), ClientLoadCapabilities)) {\n  case Failure:\n  case Missing:\n  case OutOfDate:\n  case VersionMismatch:\n  case ConfigurationMismatch:\n  case HadErrors:\n    return removeModulesAndReturn(ReadResult);\n  case Success:\n    break;\n  }\n\n  // Here comes stuff that we only do once the entire chain is loaded.\n\n  // Load the AST blocks of all of the modules that we loaded.  We can still\n  // hit errors parsing the ASTs at this point.\n  for (ImportedModule &M : Loaded) {\n    ModuleFile &F = *M.Mod;\n\n    // Read the AST block.\n    if (ASTReadResult Result = ReadASTBlock(F, ClientLoadCapabilities))\n      return removeModulesAndReturn(Result);\n\n    // The AST block should always have a definition for the main module.\n    if (F.isModule() && !F.DidReadTopLevelSubmodule) {\n      Error(diag::err_module_file_missing_top_level_submodule, F.FileName);\n      return removeModulesAndReturn(Failure);\n    }\n\n    // Read the extension blocks.\n    while (!SkipCursorToBlock(F.Stream, EXTENSION_BLOCK_ID)) {\n      if (ASTReadResult Result = ReadExtensionBlock(F))\n        return removeModulesAndReturn(Result);\n    }\n\n    // Once read, set the ModuleFile bit base offset and update the size in\n    // bits of all files we've seen.\n    F.GlobalBitOffset = TotalModulesSizeInBits;\n    TotalModulesSizeInBits += F.SizeInBits;\n    GlobalBitOffsetsMap.insert(std::make_pair(F.GlobalBitOffset, &F));\n  }\n\n  // Preload source locations and interesting indentifiers.\n  for (ImportedModule &M : Loaded) {\n    ModuleFile &F = *M.Mod;\n\n    // Preload SLocEntries.\n    for (unsigned I = 0, N = F.PreloadSLocEntries.size(); I != N; ++I) {\n      int Index = int(F.PreloadSLocEntries[I] - 1) + F.SLocEntryBaseID;\n      // Load it through the SourceManager and don't call ReadSLocEntry()\n      // directly because the entry may have already been loaded in which case\n      // calling ReadSLocEntry() directly would trigger an assertion in\n      // SourceManager.\n      SourceMgr.getLoadedSLocEntryByID(Index);\n    }\n\n    // Map the original source file ID into the ID space of the current\n    // compilation.\n    if (F.OriginalSourceFileID.isValid()) {\n      F.OriginalSourceFileID = FileID::get(\n          F.SLocEntryBaseID + F.OriginalSourceFileID.getOpaqueValue() - 1);\n    }\n\n    // Preload all the pending interesting identifiers by marking them out of\n    // date.\n    for (auto Offset : F.PreloadIdentifierOffsets) {\n      const unsigned char *Data = reinterpret_cast<const unsigned char *>(\n          F.IdentifierTableData + Offset);\n\n      ASTIdentifierLookupTrait Trait(*this, F);\n      auto KeyDataLen = Trait.ReadKeyDataLength(Data);\n      auto Key = Trait.ReadKey(Data, KeyDataLen.first);\n      auto &II = PP.getIdentifierTable().getOwn(Key);\n      II.setOutOfDate(true);\n\n      // Mark this identifier as being from an AST file so that we can track\n      // whether we need to serialize it.\n      markIdentifierFromAST(*this, II);\n\n      // Associate the ID with the identifier so that the writer can reuse it.\n      auto ID = Trait.ReadIdentifierID(Data + KeyDataLen.first);\n      SetIdentifierInfo(ID, &II);\n    }\n  }\n\n  // Setup the import locations and notify the module manager that we've\n  // committed to these module files.\n  for (ImportedModule &M : Loaded) {\n    ModuleFile &F = *M.Mod;\n\n    ModuleMgr.moduleFileAccepted(&F);\n\n    // Set the import location.\n    F.DirectImportLoc = ImportLoc;\n    // FIXME: We assume that locations from PCH / preamble do not need\n    // any translation.\n    if (!M.ImportedBy)\n      F.ImportLoc = M.ImportLoc;\n    else\n      F.ImportLoc = TranslateSourceLocation(*M.ImportedBy, M.ImportLoc);\n  }\n\n  if (!PP.getLangOpts().CPlusPlus ||\n      (Type != MK_ImplicitModule && Type != MK_ExplicitModule &&\n       Type != MK_PrebuiltModule)) {\n    // Mark all of the identifiers in the identifier table as being out of date,\n    // so that various accessors know to check the loaded modules when the\n    // identifier is used.\n    //\n    // For C++ modules, we don't need information on many identifiers (just\n    // those that provide macros or are poisoned), so we mark all of\n    // the interesting ones via PreloadIdentifierOffsets.\n    for (IdentifierTable::iterator Id = PP.getIdentifierTable().begin(),\n                                IdEnd = PP.getIdentifierTable().end();\n         Id != IdEnd; ++Id)\n      Id->second->setOutOfDate(true);\n  }\n  // Mark selectors as out of date.\n  for (auto Sel : SelectorGeneration)\n    SelectorOutOfDate[Sel.first] = true;\n\n  // Resolve any unresolved module exports.\n  for (unsigned I = 0, N = UnresolvedModuleRefs.size(); I != N; ++I) {\n    UnresolvedModuleRef &Unresolved = UnresolvedModuleRefs[I];\n    SubmoduleID GlobalID = getGlobalSubmoduleID(*Unresolved.File,Unresolved.ID);\n    Module *ResolvedMod = getSubmodule(GlobalID);\n\n    switch (Unresolved.Kind) {\n    case UnresolvedModuleRef::Conflict:\n      if (ResolvedMod) {\n        Module::Conflict Conflict;\n        Conflict.Other = ResolvedMod;\n        Conflict.Message = Unresolved.String.str();\n        Unresolved.Mod->Conflicts.push_back(Conflict);\n      }\n      continue;\n\n    case UnresolvedModuleRef::Import:\n      if (ResolvedMod)\n        Unresolved.Mod->Imports.insert(ResolvedMod);\n      continue;\n\n    case UnresolvedModuleRef::Export:\n      if (ResolvedMod || Unresolved.IsWildcard)\n        Unresolved.Mod->Exports.push_back(\n          Module::ExportDecl(ResolvedMod, Unresolved.IsWildcard));\n      continue;\n    }\n  }\n  UnresolvedModuleRefs.clear();\n\n  if (Imported)\n    Imported->append(ImportedModules.begin(),\n                     ImportedModules.end());\n\n  // FIXME: How do we load the 'use'd modules? They may not be submodules.\n  // Might be unnecessary as use declarations are only used to build the\n  // module itself.\n\n  if (ContextObj)\n    InitializeContext();\n\n  if (SemaObj)\n    UpdateSema();\n\n  if (DeserializationListener)\n    DeserializationListener->ReaderInitialized(this);\n\n  ModuleFile &PrimaryModule = ModuleMgr.getPrimaryModule();\n  if (PrimaryModule.OriginalSourceFileID.isValid()) {\n    // If this AST file is a precompiled preamble, then set the\n    // preamble file ID of the source manager to the file source file\n    // from which the preamble was built.\n    if (Type == MK_Preamble) {\n      SourceMgr.setPreambleFileID(PrimaryModule.OriginalSourceFileID);\n    } else if (Type == MK_MainFile) {\n      SourceMgr.setMainFileID(PrimaryModule.OriginalSourceFileID);\n    }\n  }\n\n  // For any Objective-C class definitions we have already loaded, make sure\n  // that we load any additional categories.\n  if (ContextObj) {\n    for (unsigned I = 0, N = ObjCClassesLoaded.size(); I != N; ++I) {\n      loadObjCCategories(ObjCClassesLoaded[I]->getGlobalID(),\n                         ObjCClassesLoaded[I],\n                         PreviousGeneration);\n    }\n  }\n\n  if (PP.getHeaderSearchInfo()\n          .getHeaderSearchOpts()\n          .ModulesValidateOncePerBuildSession) {\n    // Now we are certain that the module and all modules it depends on are\n    // up to date.  Create or update timestamp files for modules that are\n    // located in the module cache (not for PCH files that could be anywhere\n    // in the filesystem).\n    for (unsigned I = 0, N = Loaded.size(); I != N; ++I) {\n      ImportedModule &M = Loaded[I];\n      if (M.Mod->Kind == MK_ImplicitModule) {\n        updateModuleTimestamp(*M.Mod);\n      }\n    }\n  }\n\n  return Success;\n}\n\nstatic ASTFileSignature readASTFileSignature(StringRef PCH);\n\n/// Whether \\p Stream doesn't start with the AST/PCH file magic number 'CPCH'.\nstatic llvm::Error doesntStartWithASTFileMagic(BitstreamCursor &Stream) {\n  // FIXME checking magic headers is done in other places such as\n  // SerializedDiagnosticReader and GlobalModuleIndex, but error handling isn't\n  // always done the same. Unify it all with a helper.\n  if (!Stream.canSkipToPos(4))\n    return llvm::createStringError(std::errc::illegal_byte_sequence,\n                                   \"file too small to contain AST file magic\");\n  for (unsigned C : {'C', 'P', 'C', 'H'})\n    if (Expected<llvm::SimpleBitstreamCursor::word_t> Res = Stream.Read(8)) {\n      if (Res.get() != C)\n        return llvm::createStringError(\n            std::errc::illegal_byte_sequence,\n            \"file doesn't start with AST file magic\");\n    } else\n      return Res.takeError();\n  return llvm::Error::success();\n}\n\nstatic unsigned moduleKindForDiagnostic(ModuleKind Kind) {\n  switch (Kind) {\n  case MK_PCH:\n    return 0; // PCH\n  case MK_ImplicitModule:\n  case MK_ExplicitModule:\n  case MK_PrebuiltModule:\n    return 1; // module\n  case MK_MainFile:\n  case MK_Preamble:\n    return 2; // main source file\n  }\n  llvm_unreachable(\"unknown module kind\");\n}\n\nASTReader::ASTReadResult\nASTReader::ReadASTCore(StringRef FileName,\n                       ModuleKind Type,\n                       SourceLocation ImportLoc,\n                       ModuleFile *ImportedBy,\n                       SmallVectorImpl<ImportedModule> &Loaded,\n                       off_t ExpectedSize, time_t ExpectedModTime,\n                       ASTFileSignature ExpectedSignature,\n                       unsigned ClientLoadCapabilities) {\n  ModuleFile *M;\n  std::string ErrorStr;\n  ModuleManager::AddModuleResult AddResult\n    = ModuleMgr.addModule(FileName, Type, ImportLoc, ImportedBy,\n                          getGeneration(), ExpectedSize, ExpectedModTime,\n                          ExpectedSignature, readASTFileSignature,\n                          M, ErrorStr);\n\n  switch (AddResult) {\n  case ModuleManager::AlreadyLoaded:\n    Diag(diag::remark_module_import)\n        << M->ModuleName << M->FileName << (ImportedBy ? true : false)\n        << (ImportedBy ? StringRef(ImportedBy->ModuleName) : StringRef());\n    return Success;\n\n  case ModuleManager::NewlyLoaded:\n    // Load module file below.\n    break;\n\n  case ModuleManager::Missing:\n    // The module file was missing; if the client can handle that, return\n    // it.\n    if (ClientLoadCapabilities & ARR_Missing)\n      return Missing;\n\n    // Otherwise, return an error.\n    Diag(diag::err_ast_file_not_found)\n        << moduleKindForDiagnostic(Type) << FileName << !ErrorStr.empty()\n        << ErrorStr;\n    return Failure;\n\n  case ModuleManager::OutOfDate:\n    // We couldn't load the module file because it is out-of-date. If the\n    // client can handle out-of-date, return it.\n    if (ClientLoadCapabilities & ARR_OutOfDate)\n      return OutOfDate;\n\n    // Otherwise, return an error.\n    Diag(diag::err_ast_file_out_of_date)\n        << moduleKindForDiagnostic(Type) << FileName << !ErrorStr.empty()\n        << ErrorStr;\n    return Failure;\n  }\n\n  assert(M && \"Missing module file\");\n\n  bool ShouldFinalizePCM = false;\n  auto FinalizeOrDropPCM = llvm::make_scope_exit([&]() {\n    auto &MC = getModuleManager().getModuleCache();\n    if (ShouldFinalizePCM)\n      MC.finalizePCM(FileName);\n    else\n      MC.tryToDropPCM(FileName);\n  });\n  ModuleFile &F = *M;\n  BitstreamCursor &Stream = F.Stream;\n  Stream = BitstreamCursor(PCHContainerRdr.ExtractPCH(*F.Buffer));\n  F.SizeInBits = F.Buffer->getBufferSize() * 8;\n\n  // Sniff for the signature.\n  if (llvm::Error Err = doesntStartWithASTFileMagic(Stream)) {\n    Diag(diag::err_ast_file_invalid)\n        << moduleKindForDiagnostic(Type) << FileName << std::move(Err);\n    return Failure;\n  }\n\n  // This is used for compatibility with older PCH formats.\n  bool HaveReadControlBlock = false;\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry = Stream.advance();\n    if (!MaybeEntry) {\n      Error(MaybeEntry.takeError());\n      return Failure;\n    }\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case llvm::BitstreamEntry::Error:\n    case llvm::BitstreamEntry::Record:\n    case llvm::BitstreamEntry::EndBlock:\n      Error(\"invalid record at top-level of AST file\");\n      return Failure;\n\n    case llvm::BitstreamEntry::SubBlock:\n      break;\n    }\n\n    switch (Entry.ID) {\n    case CONTROL_BLOCK_ID:\n      HaveReadControlBlock = true;\n      switch (ReadControlBlock(F, Loaded, ImportedBy, ClientLoadCapabilities)) {\n      case Success:\n        // Check that we didn't try to load a non-module AST file as a module.\n        //\n        // FIXME: Should we also perform the converse check? Loading a module as\n        // a PCH file sort of works, but it's a bit wonky.\n        if ((Type == MK_ImplicitModule || Type == MK_ExplicitModule ||\n             Type == MK_PrebuiltModule) &&\n            F.ModuleName.empty()) {\n          auto Result = (Type == MK_ImplicitModule) ? OutOfDate : Failure;\n          if (Result != OutOfDate ||\n              (ClientLoadCapabilities & ARR_OutOfDate) == 0)\n            Diag(diag::err_module_file_not_module) << FileName;\n          return Result;\n        }\n        break;\n\n      case Failure: return Failure;\n      case Missing: return Missing;\n      case OutOfDate: return OutOfDate;\n      case VersionMismatch: return VersionMismatch;\n      case ConfigurationMismatch: return ConfigurationMismatch;\n      case HadErrors: return HadErrors;\n      }\n      break;\n\n    case AST_BLOCK_ID:\n      if (!HaveReadControlBlock) {\n        if ((ClientLoadCapabilities & ARR_VersionMismatch) == 0)\n          Diag(diag::err_pch_version_too_old);\n        return VersionMismatch;\n      }\n\n      // Record that we've loaded this module.\n      Loaded.push_back(ImportedModule(M, ImportedBy, ImportLoc));\n      ShouldFinalizePCM = true;\n      return Success;\n\n    case UNHASHED_CONTROL_BLOCK_ID:\n      // This block is handled using look-ahead during ReadControlBlock.  We\n      // shouldn't get here!\n      Error(\"malformed block record in AST file\");\n      return Failure;\n\n    default:\n      if (llvm::Error Err = Stream.SkipBlock()) {\n        Error(std::move(Err));\n        return Failure;\n      }\n      break;\n    }\n  }\n\n  llvm_unreachable(\"unexpected break; expected return\");\n}\n\nASTReader::ASTReadResult\nASTReader::readUnhashedControlBlock(ModuleFile &F, bool WasImportedBy,\n                                    unsigned ClientLoadCapabilities) {\n  const HeaderSearchOptions &HSOpts =\n      PP.getHeaderSearchInfo().getHeaderSearchOpts();\n  bool AllowCompatibleConfigurationMismatch =\n      F.Kind == MK_ExplicitModule || F.Kind == MK_PrebuiltModule;\n  bool DisableValidation = shouldDisableValidationForFile(F);\n\n  ASTReadResult Result = readUnhashedControlBlockImpl(\n      &F, F.Data, ClientLoadCapabilities, AllowCompatibleConfigurationMismatch,\n      Listener.get(),\n      WasImportedBy ? false : HSOpts.ModulesValidateDiagnosticOptions);\n\n  // If F was directly imported by another module, it's implicitly validated by\n  // the importing module.\n  if (DisableValidation || WasImportedBy ||\n      (AllowConfigurationMismatch && Result == ConfigurationMismatch))\n    return Success;\n\n  if (Result == Failure) {\n    Error(\"malformed block record in AST file\");\n    return Failure;\n  }\n\n  if (Result == OutOfDate && F.Kind == MK_ImplicitModule) {\n    // If this module has already been finalized in the ModuleCache, we're stuck\n    // with it; we can only load a single version of each module.\n    //\n    // This can happen when a module is imported in two contexts: in one, as a\n    // user module; in another, as a system module (due to an import from\n    // another module marked with the [system] flag).  It usually indicates a\n    // bug in the module map: this module should also be marked with [system].\n    //\n    // If -Wno-system-headers (the default), and the first import is as a\n    // system module, then validation will fail during the as-user import,\n    // since -Werror flags won't have been validated.  However, it's reasonable\n    // to treat this consistently as a system module.\n    //\n    // If -Wsystem-headers, the PCM on disk was built with\n    // -Wno-system-headers, and the first import is as a user module, then\n    // validation will fail during the as-system import since the PCM on disk\n    // doesn't guarantee that -Werror was respected.  However, the -Werror\n    // flags were checked during the initial as-user import.\n    if (getModuleManager().getModuleCache().isPCMFinal(F.FileName)) {\n      Diag(diag::warn_module_system_bit_conflict) << F.FileName;\n      return Success;\n    }\n  }\n\n  return Result;\n}\n\nASTReader::ASTReadResult ASTReader::readUnhashedControlBlockImpl(\n    ModuleFile *F, llvm::StringRef StreamData, unsigned ClientLoadCapabilities,\n    bool AllowCompatibleConfigurationMismatch, ASTReaderListener *Listener,\n    bool ValidateDiagnosticOptions) {\n  // Initialize a stream.\n  BitstreamCursor Stream(StreamData);\n\n  // Sniff for the signature.\n  if (llvm::Error Err = doesntStartWithASTFileMagic(Stream)) {\n    // FIXME this drops the error on the floor.\n    consumeError(std::move(Err));\n    return Failure;\n  }\n\n  // Scan for the UNHASHED_CONTROL_BLOCK_ID block.\n  if (SkipCursorToBlock(Stream, UNHASHED_CONTROL_BLOCK_ID))\n    return Failure;\n\n  // Read all of the records in the options block.\n  RecordData Record;\n  ASTReadResult Result = Success;\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry = Stream.advance();\n    if (!MaybeEntry) {\n      // FIXME this drops the error on the floor.\n      consumeError(MaybeEntry.takeError());\n      return Failure;\n    }\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case llvm::BitstreamEntry::Error:\n    case llvm::BitstreamEntry::SubBlock:\n      return Failure;\n\n    case llvm::BitstreamEntry::EndBlock:\n      return Result;\n\n    case llvm::BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read and process a record.\n    Record.clear();\n    Expected<unsigned> MaybeRecordType = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeRecordType) {\n      // FIXME this drops the error.\n      return Failure;\n    }\n    switch ((UnhashedControlBlockRecordTypes)MaybeRecordType.get()) {\n    case SIGNATURE:\n      if (F)\n        F->Signature = ASTFileSignature::create(Record.begin(), Record.end());\n      break;\n    case AST_BLOCK_HASH:\n      if (F)\n        F->ASTBlockHash =\n            ASTFileSignature::create(Record.begin(), Record.end());\n      break;\n    case DIAGNOSTIC_OPTIONS: {\n      bool Complain = (ClientLoadCapabilities & ARR_OutOfDate) == 0;\n      if (Listener && ValidateDiagnosticOptions &&\n          !AllowCompatibleConfigurationMismatch &&\n          ParseDiagnosticOptions(Record, Complain, *Listener))\n        Result = OutOfDate; // Don't return early.  Read the signature.\n      break;\n    }\n    case DIAG_PRAGMA_MAPPINGS:\n      if (!F)\n        break;\n      if (F->PragmaDiagMappings.empty())\n        F->PragmaDiagMappings.swap(Record);\n      else\n        F->PragmaDiagMappings.insert(F->PragmaDiagMappings.end(),\n                                     Record.begin(), Record.end());\n      break;\n    }\n  }\n}\n\n/// Parse a record and blob containing module file extension metadata.\nstatic bool parseModuleFileExtensionMetadata(\n              const SmallVectorImpl<uint64_t> &Record,\n              StringRef Blob,\n              ModuleFileExtensionMetadata &Metadata) {\n  if (Record.size() < 4) return true;\n\n  Metadata.MajorVersion = Record[0];\n  Metadata.MinorVersion = Record[1];\n\n  unsigned BlockNameLen = Record[2];\n  unsigned UserInfoLen = Record[3];\n\n  if (BlockNameLen + UserInfoLen > Blob.size()) return true;\n\n  Metadata.BlockName = std::string(Blob.data(), Blob.data() + BlockNameLen);\n  Metadata.UserInfo = std::string(Blob.data() + BlockNameLen,\n                                  Blob.data() + BlockNameLen + UserInfoLen);\n  return false;\n}\n\nASTReader::ASTReadResult ASTReader::ReadExtensionBlock(ModuleFile &F) {\n  BitstreamCursor &Stream = F.Stream;\n\n  RecordData Record;\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry = Stream.advance();\n    if (!MaybeEntry) {\n      Error(MaybeEntry.takeError());\n      return Failure;\n    }\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case llvm::BitstreamEntry::SubBlock:\n      if (llvm::Error Err = Stream.SkipBlock()) {\n        Error(std::move(Err));\n        return Failure;\n      }\n      continue;\n\n    case llvm::BitstreamEntry::EndBlock:\n      return Success;\n\n    case llvm::BitstreamEntry::Error:\n      return HadErrors;\n\n    case llvm::BitstreamEntry::Record:\n      break;\n    }\n\n    Record.clear();\n    StringRef Blob;\n    Expected<unsigned> MaybeRecCode =\n        Stream.readRecord(Entry.ID, Record, &Blob);\n    if (!MaybeRecCode) {\n      Error(MaybeRecCode.takeError());\n      return Failure;\n    }\n    switch (MaybeRecCode.get()) {\n    case EXTENSION_METADATA: {\n      ModuleFileExtensionMetadata Metadata;\n      if (parseModuleFileExtensionMetadata(Record, Blob, Metadata)) {\n        Error(\"malformed EXTENSION_METADATA in AST file\");\n        return Failure;\n      }\n\n      // Find a module file extension with this block name.\n      auto Known = ModuleFileExtensions.find(Metadata.BlockName);\n      if (Known == ModuleFileExtensions.end()) break;\n\n      // Form a reader.\n      if (auto Reader = Known->second->createExtensionReader(Metadata, *this,\n                                                             F, Stream)) {\n        F.ExtensionReaders.push_back(std::move(Reader));\n      }\n\n      break;\n    }\n    }\n  }\n\n  return Success;\n}\n\nvoid ASTReader::InitializeContext() {\n  assert(ContextObj && \"no context to initialize\");\n  ASTContext &Context = *ContextObj;\n\n  // If there's a listener, notify them that we \"read\" the translation unit.\n  if (DeserializationListener)\n    DeserializationListener->DeclRead(PREDEF_DECL_TRANSLATION_UNIT_ID,\n                                      Context.getTranslationUnitDecl());\n\n  // FIXME: Find a better way to deal with collisions between these\n  // built-in types. Right now, we just ignore the problem.\n\n  // Load the special types.\n  if (SpecialTypes.size() >= NumSpecialTypeIDs) {\n    if (unsigned String = SpecialTypes[SPECIAL_TYPE_CF_CONSTANT_STRING]) {\n      if (!Context.CFConstantStringTypeDecl)\n        Context.setCFConstantStringType(GetType(String));\n    }\n\n    if (unsigned File = SpecialTypes[SPECIAL_TYPE_FILE]) {\n      QualType FileType = GetType(File);\n      if (FileType.isNull()) {\n        Error(\"FILE type is NULL\");\n        return;\n      }\n\n      if (!Context.FILEDecl) {\n        if (const TypedefType *Typedef = FileType->getAs<TypedefType>())\n          Context.setFILEDecl(Typedef->getDecl());\n        else {\n          const TagType *Tag = FileType->getAs<TagType>();\n          if (!Tag) {\n            Error(\"Invalid FILE type in AST file\");\n            return;\n          }\n          Context.setFILEDecl(Tag->getDecl());\n        }\n      }\n    }\n\n    if (unsigned Jmp_buf = SpecialTypes[SPECIAL_TYPE_JMP_BUF]) {\n      QualType Jmp_bufType = GetType(Jmp_buf);\n      if (Jmp_bufType.isNull()) {\n        Error(\"jmp_buf type is NULL\");\n        return;\n      }\n\n      if (!Context.jmp_bufDecl) {\n        if (const TypedefType *Typedef = Jmp_bufType->getAs<TypedefType>())\n          Context.setjmp_bufDecl(Typedef->getDecl());\n        else {\n          const TagType *Tag = Jmp_bufType->getAs<TagType>();\n          if (!Tag) {\n            Error(\"Invalid jmp_buf type in AST file\");\n            return;\n          }\n          Context.setjmp_bufDecl(Tag->getDecl());\n        }\n      }\n    }\n\n    if (unsigned Sigjmp_buf = SpecialTypes[SPECIAL_TYPE_SIGJMP_BUF]) {\n      QualType Sigjmp_bufType = GetType(Sigjmp_buf);\n      if (Sigjmp_bufType.isNull()) {\n        Error(\"sigjmp_buf type is NULL\");\n        return;\n      }\n\n      if (!Context.sigjmp_bufDecl) {\n        if (const TypedefType *Typedef = Sigjmp_bufType->getAs<TypedefType>())\n          Context.setsigjmp_bufDecl(Typedef->getDecl());\n        else {\n          const TagType *Tag = Sigjmp_bufType->getAs<TagType>();\n          assert(Tag && \"Invalid sigjmp_buf type in AST file\");\n          Context.setsigjmp_bufDecl(Tag->getDecl());\n        }\n      }\n    }\n\n    if (unsigned ObjCIdRedef\n          = SpecialTypes[SPECIAL_TYPE_OBJC_ID_REDEFINITION]) {\n      if (Context.ObjCIdRedefinitionType.isNull())\n        Context.ObjCIdRedefinitionType = GetType(ObjCIdRedef);\n    }\n\n    if (unsigned ObjCClassRedef\n          = SpecialTypes[SPECIAL_TYPE_OBJC_CLASS_REDEFINITION]) {\n      if (Context.ObjCClassRedefinitionType.isNull())\n        Context.ObjCClassRedefinitionType = GetType(ObjCClassRedef);\n    }\n\n    if (unsigned ObjCSelRedef\n          = SpecialTypes[SPECIAL_TYPE_OBJC_SEL_REDEFINITION]) {\n      if (Context.ObjCSelRedefinitionType.isNull())\n        Context.ObjCSelRedefinitionType = GetType(ObjCSelRedef);\n    }\n\n    if (unsigned Ucontext_t = SpecialTypes[SPECIAL_TYPE_UCONTEXT_T]) {\n      QualType Ucontext_tType = GetType(Ucontext_t);\n      if (Ucontext_tType.isNull()) {\n        Error(\"ucontext_t type is NULL\");\n        return;\n      }\n\n      if (!Context.ucontext_tDecl) {\n        if (const TypedefType *Typedef = Ucontext_tType->getAs<TypedefType>())\n          Context.setucontext_tDecl(Typedef->getDecl());\n        else {\n          const TagType *Tag = Ucontext_tType->getAs<TagType>();\n          assert(Tag && \"Invalid ucontext_t type in AST file\");\n          Context.setucontext_tDecl(Tag->getDecl());\n        }\n      }\n    }\n  }\n\n  ReadPragmaDiagnosticMappings(Context.getDiagnostics());\n\n  // If there were any CUDA special declarations, deserialize them.\n  if (!CUDASpecialDeclRefs.empty()) {\n    assert(CUDASpecialDeclRefs.size() == 1 && \"More decl refs than expected!\");\n    Context.setcudaConfigureCallDecl(\n                           cast<FunctionDecl>(GetDecl(CUDASpecialDeclRefs[0])));\n  }\n\n  // Re-export any modules that were imported by a non-module AST file.\n  // FIXME: This does not make macro-only imports visible again.\n  for (auto &Import : ImportedModules) {\n    if (Module *Imported = getSubmodule(Import.ID)) {\n      makeModuleVisible(Imported, Module::AllVisible,\n                        /*ImportLoc=*/Import.ImportLoc);\n      if (Import.ImportLoc.isValid())\n        PP.makeModuleVisible(Imported, Import.ImportLoc);\n      // This updates visibility for Preprocessor only. For Sema, which can be\n      // nullptr here, we do the same later, in UpdateSema().\n    }\n  }\n}\n\nvoid ASTReader::finalizeForWriting() {\n  // Nothing to do for now.\n}\n\n/// Reads and return the signature record from \\p PCH's control block, or\n/// else returns 0.\nstatic ASTFileSignature readASTFileSignature(StringRef PCH) {\n  BitstreamCursor Stream(PCH);\n  if (llvm::Error Err = doesntStartWithASTFileMagic(Stream)) {\n    // FIXME this drops the error on the floor.\n    consumeError(std::move(Err));\n    return ASTFileSignature();\n  }\n\n  // Scan for the UNHASHED_CONTROL_BLOCK_ID block.\n  if (SkipCursorToBlock(Stream, UNHASHED_CONTROL_BLOCK_ID))\n    return ASTFileSignature();\n\n  // Scan for SIGNATURE inside the diagnostic options block.\n  ASTReader::RecordData Record;\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry =\n        Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry) {\n      // FIXME this drops the error on the floor.\n      consumeError(MaybeEntry.takeError());\n      return ASTFileSignature();\n    }\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    if (Entry.Kind != llvm::BitstreamEntry::Record)\n      return ASTFileSignature();\n\n    Record.clear();\n    StringRef Blob;\n    Expected<unsigned> MaybeRecord = Stream.readRecord(Entry.ID, Record, &Blob);\n    if (!MaybeRecord) {\n      // FIXME this drops the error on the floor.\n      consumeError(MaybeRecord.takeError());\n      return ASTFileSignature();\n    }\n    if (SIGNATURE == MaybeRecord.get())\n      return ASTFileSignature::create(Record.begin(),\n                                      Record.begin() + ASTFileSignature::size);\n  }\n}\n\n/// Retrieve the name of the original source file name\n/// directly from the AST file, without actually loading the AST\n/// file.\nstd::string ASTReader::getOriginalSourceFile(\n    const std::string &ASTFileName, FileManager &FileMgr,\n    const PCHContainerReader &PCHContainerRdr, DiagnosticsEngine &Diags) {\n  // Open the AST file.\n  auto Buffer = FileMgr.getBufferForFile(ASTFileName);\n  if (!Buffer) {\n    Diags.Report(diag::err_fe_unable_to_read_pch_file)\n        << ASTFileName << Buffer.getError().message();\n    return std::string();\n  }\n\n  // Initialize the stream\n  BitstreamCursor Stream(PCHContainerRdr.ExtractPCH(**Buffer));\n\n  // Sniff for the signature.\n  if (llvm::Error Err = doesntStartWithASTFileMagic(Stream)) {\n    Diags.Report(diag::err_fe_not_a_pch_file) << ASTFileName << std::move(Err);\n    return std::string();\n  }\n\n  // Scan for the CONTROL_BLOCK_ID block.\n  if (SkipCursorToBlock(Stream, CONTROL_BLOCK_ID)) {\n    Diags.Report(diag::err_fe_pch_malformed_block) << ASTFileName;\n    return std::string();\n  }\n\n  // Scan for ORIGINAL_FILE inside the control block.\n  RecordData Record;\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry =\n        Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry) {\n      // FIXME this drops errors on the floor.\n      consumeError(MaybeEntry.takeError());\n      return std::string();\n    }\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    if (Entry.Kind == llvm::BitstreamEntry::EndBlock)\n      return std::string();\n\n    if (Entry.Kind != llvm::BitstreamEntry::Record) {\n      Diags.Report(diag::err_fe_pch_malformed_block) << ASTFileName;\n      return std::string();\n    }\n\n    Record.clear();\n    StringRef Blob;\n    Expected<unsigned> MaybeRecord = Stream.readRecord(Entry.ID, Record, &Blob);\n    if (!MaybeRecord) {\n      // FIXME this drops the errors on the floor.\n      consumeError(MaybeRecord.takeError());\n      return std::string();\n    }\n    if (ORIGINAL_FILE == MaybeRecord.get())\n      return Blob.str();\n  }\n}\n\nnamespace {\n\n  class SimplePCHValidator : public ASTReaderListener {\n    const LangOptions &ExistingLangOpts;\n    const TargetOptions &ExistingTargetOpts;\n    const PreprocessorOptions &ExistingPPOpts;\n    std::string ExistingModuleCachePath;\n    FileManager &FileMgr;\n\n  public:\n    SimplePCHValidator(const LangOptions &ExistingLangOpts,\n                       const TargetOptions &ExistingTargetOpts,\n                       const PreprocessorOptions &ExistingPPOpts,\n                       StringRef ExistingModuleCachePath, FileManager &FileMgr)\n        : ExistingLangOpts(ExistingLangOpts),\n          ExistingTargetOpts(ExistingTargetOpts),\n          ExistingPPOpts(ExistingPPOpts),\n          ExistingModuleCachePath(ExistingModuleCachePath), FileMgr(FileMgr) {}\n\n    bool ReadLanguageOptions(const LangOptions &LangOpts, bool Complain,\n                             bool AllowCompatibleDifferences) override {\n      return checkLanguageOptions(ExistingLangOpts, LangOpts, nullptr,\n                                  AllowCompatibleDifferences);\n    }\n\n    bool ReadTargetOptions(const TargetOptions &TargetOpts, bool Complain,\n                           bool AllowCompatibleDifferences) override {\n      return checkTargetOptions(ExistingTargetOpts, TargetOpts, nullptr,\n                                AllowCompatibleDifferences);\n    }\n\n    bool ReadHeaderSearchOptions(const HeaderSearchOptions &HSOpts,\n                                 StringRef SpecificModuleCachePath,\n                                 bool Complain) override {\n      return checkHeaderSearchOptions(HSOpts, SpecificModuleCachePath,\n                                      ExistingModuleCachePath,\n                                      nullptr, ExistingLangOpts);\n    }\n\n    bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts,\n                                 bool Complain,\n                                 std::string &SuggestedPredefines) override {\n      return checkPreprocessorOptions(ExistingPPOpts, PPOpts, nullptr, FileMgr,\n                                      SuggestedPredefines, ExistingLangOpts);\n    }\n  };\n\n} // namespace\n\nbool ASTReader::readASTFileControlBlock(\n    StringRef Filename, FileManager &FileMgr,\n    const PCHContainerReader &PCHContainerRdr,\n    bool FindModuleFileExtensions,\n    ASTReaderListener &Listener, bool ValidateDiagnosticOptions) {\n  // Open the AST file.\n  // FIXME: This allows use of the VFS; we do not allow use of the\n  // VFS when actually loading a module.\n  auto Buffer = FileMgr.getBufferForFile(Filename);\n  if (!Buffer) {\n    return true;\n  }\n\n  // Initialize the stream\n  StringRef Bytes = PCHContainerRdr.ExtractPCH(**Buffer);\n  BitstreamCursor Stream(Bytes);\n\n  // Sniff for the signature.\n  if (llvm::Error Err = doesntStartWithASTFileMagic(Stream)) {\n    consumeError(std::move(Err)); // FIXME this drops errors on the floor.\n    return true;\n  }\n\n  // Scan for the CONTROL_BLOCK_ID block.\n  if (SkipCursorToBlock(Stream, CONTROL_BLOCK_ID))\n    return true;\n\n  bool NeedsInputFiles = Listener.needsInputFileVisitation();\n  bool NeedsSystemInputFiles = Listener.needsSystemInputFileVisitation();\n  bool NeedsImports = Listener.needsImportVisitation();\n  BitstreamCursor InputFilesCursor;\n\n  RecordData Record;\n  std::string ModuleDir;\n  bool DoneWithControlBlock = false;\n  while (!DoneWithControlBlock) {\n    Expected<llvm::BitstreamEntry> MaybeEntry = Stream.advance();\n    if (!MaybeEntry) {\n      // FIXME this drops the error on the floor.\n      consumeError(MaybeEntry.takeError());\n      return true;\n    }\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case llvm::BitstreamEntry::SubBlock: {\n      switch (Entry.ID) {\n      case OPTIONS_BLOCK_ID: {\n        std::string IgnoredSuggestedPredefines;\n        if (ReadOptionsBlock(Stream, ARR_ConfigurationMismatch | ARR_OutOfDate,\n                             /*AllowCompatibleConfigurationMismatch*/ false,\n                             Listener, IgnoredSuggestedPredefines) != Success)\n          return true;\n        break;\n      }\n\n      case INPUT_FILES_BLOCK_ID:\n        InputFilesCursor = Stream;\n        if (llvm::Error Err = Stream.SkipBlock()) {\n          // FIXME this drops the error on the floor.\n          consumeError(std::move(Err));\n          return true;\n        }\n        if (NeedsInputFiles &&\n            ReadBlockAbbrevs(InputFilesCursor, INPUT_FILES_BLOCK_ID))\n          return true;\n        break;\n\n      default:\n        if (llvm::Error Err = Stream.SkipBlock()) {\n          // FIXME this drops the error on the floor.\n          consumeError(std::move(Err));\n          return true;\n        }\n        break;\n      }\n\n      continue;\n    }\n\n    case llvm::BitstreamEntry::EndBlock:\n      DoneWithControlBlock = true;\n      break;\n\n    case llvm::BitstreamEntry::Error:\n      return true;\n\n    case llvm::BitstreamEntry::Record:\n      break;\n    }\n\n    if (DoneWithControlBlock) break;\n\n    Record.clear();\n    StringRef Blob;\n    Expected<unsigned> MaybeRecCode =\n        Stream.readRecord(Entry.ID, Record, &Blob);\n    if (!MaybeRecCode) {\n      // FIXME this drops the error.\n      return Failure;\n    }\n    switch ((ControlRecordTypes)MaybeRecCode.get()) {\n    case METADATA:\n      if (Record[0] != VERSION_MAJOR)\n        return true;\n      if (Listener.ReadFullVersionInformation(Blob))\n        return true;\n      break;\n    case MODULE_NAME:\n      Listener.ReadModuleName(Blob);\n      break;\n    case MODULE_DIRECTORY:\n      ModuleDir = std::string(Blob);\n      break;\n    case MODULE_MAP_FILE: {\n      unsigned Idx = 0;\n      auto Path = ReadString(Record, Idx);\n      ResolveImportedPath(Path, ModuleDir);\n      Listener.ReadModuleMapFile(Path);\n      break;\n    }\n    case INPUT_FILE_OFFSETS: {\n      if (!NeedsInputFiles)\n        break;\n\n      unsigned NumInputFiles = Record[0];\n      unsigned NumUserFiles = Record[1];\n      const llvm::support::unaligned_uint64_t *InputFileOffs =\n          (const llvm::support::unaligned_uint64_t *)Blob.data();\n      for (unsigned I = 0; I != NumInputFiles; ++I) {\n        // Go find this input file.\n        bool isSystemFile = I >= NumUserFiles;\n\n        if (isSystemFile && !NeedsSystemInputFiles)\n          break; // the rest are system input files\n\n        BitstreamCursor &Cursor = InputFilesCursor;\n        SavedStreamPosition SavedPosition(Cursor);\n        if (llvm::Error Err = Cursor.JumpToBit(InputFileOffs[I])) {\n          // FIXME this drops errors on the floor.\n          consumeError(std::move(Err));\n        }\n\n        Expected<unsigned> MaybeCode = Cursor.ReadCode();\n        if (!MaybeCode) {\n          // FIXME this drops errors on the floor.\n          consumeError(MaybeCode.takeError());\n        }\n        unsigned Code = MaybeCode.get();\n\n        RecordData Record;\n        StringRef Blob;\n        bool shouldContinue = false;\n        Expected<unsigned> MaybeRecordType =\n            Cursor.readRecord(Code, Record, &Blob);\n        if (!MaybeRecordType) {\n          // FIXME this drops errors on the floor.\n          consumeError(MaybeRecordType.takeError());\n        }\n        switch ((InputFileRecordTypes)MaybeRecordType.get()) {\n        case INPUT_FILE_HASH:\n          break;\n        case INPUT_FILE:\n          bool Overridden = static_cast<bool>(Record[3]);\n          std::string Filename = std::string(Blob);\n          ResolveImportedPath(Filename, ModuleDir);\n          shouldContinue = Listener.visitInputFile(\n              Filename, isSystemFile, Overridden, /*IsExplicitModule*/false);\n          break;\n        }\n        if (!shouldContinue)\n          break;\n      }\n      break;\n    }\n\n    case IMPORTS: {\n      if (!NeedsImports)\n        break;\n\n      unsigned Idx = 0, N = Record.size();\n      while (Idx < N) {\n        // Read information about the AST file.\n        Idx +=\n            1 + 1 + 1 + 1 +\n            ASTFileSignature::size; // Kind, ImportLoc, Size, ModTime, Signature\n        std::string ModuleName = ReadString(Record, Idx);\n        std::string Filename = ReadString(Record, Idx);\n        ResolveImportedPath(Filename, ModuleDir);\n        Listener.visitImport(ModuleName, Filename);\n      }\n      break;\n    }\n\n    default:\n      // No other validation to perform.\n      break;\n    }\n  }\n\n  // Look for module file extension blocks, if requested.\n  if (FindModuleFileExtensions) {\n    BitstreamCursor SavedStream = Stream;\n    while (!SkipCursorToBlock(Stream, EXTENSION_BLOCK_ID)) {\n      bool DoneWithExtensionBlock = false;\n      while (!DoneWithExtensionBlock) {\n        Expected<llvm::BitstreamEntry> MaybeEntry = Stream.advance();\n        if (!MaybeEntry) {\n          // FIXME this drops the error.\n          return true;\n        }\n        llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n        switch (Entry.Kind) {\n        case llvm::BitstreamEntry::SubBlock:\n          if (llvm::Error Err = Stream.SkipBlock()) {\n            // FIXME this drops the error on the floor.\n            consumeError(std::move(Err));\n            return true;\n          }\n          continue;\n\n        case llvm::BitstreamEntry::EndBlock:\n          DoneWithExtensionBlock = true;\n          continue;\n\n        case llvm::BitstreamEntry::Error:\n          return true;\n\n        case llvm::BitstreamEntry::Record:\n          break;\n        }\n\n       Record.clear();\n       StringRef Blob;\n       Expected<unsigned> MaybeRecCode =\n           Stream.readRecord(Entry.ID, Record, &Blob);\n       if (!MaybeRecCode) {\n         // FIXME this drops the error.\n         return true;\n       }\n       switch (MaybeRecCode.get()) {\n       case EXTENSION_METADATA: {\n         ModuleFileExtensionMetadata Metadata;\n         if (parseModuleFileExtensionMetadata(Record, Blob, Metadata))\n           return true;\n\n         Listener.readModuleFileExtension(Metadata);\n         break;\n       }\n       }\n      }\n    }\n    Stream = SavedStream;\n  }\n\n  // Scan for the UNHASHED_CONTROL_BLOCK_ID block.\n  if (readUnhashedControlBlockImpl(\n          nullptr, Bytes, ARR_ConfigurationMismatch | ARR_OutOfDate,\n          /*AllowCompatibleConfigurationMismatch*/ false, &Listener,\n          ValidateDiagnosticOptions) != Success)\n    return true;\n\n  return false;\n}\n\nbool ASTReader::isAcceptableASTFile(StringRef Filename, FileManager &FileMgr,\n                                    const PCHContainerReader &PCHContainerRdr,\n                                    const LangOptions &LangOpts,\n                                    const TargetOptions &TargetOpts,\n                                    const PreprocessorOptions &PPOpts,\n                                    StringRef ExistingModuleCachePath) {\n  SimplePCHValidator validator(LangOpts, TargetOpts, PPOpts,\n                               ExistingModuleCachePath, FileMgr);\n  return !readASTFileControlBlock(Filename, FileMgr, PCHContainerRdr,\n                                  /*FindModuleFileExtensions=*/false,\n                                  validator,\n                                  /*ValidateDiagnosticOptions=*/true);\n}\n\nASTReader::ASTReadResult\nASTReader::ReadSubmoduleBlock(ModuleFile &F, unsigned ClientLoadCapabilities) {\n  // Enter the submodule block.\n  if (llvm::Error Err = F.Stream.EnterSubBlock(SUBMODULE_BLOCK_ID)) {\n    Error(std::move(Err));\n    return Failure;\n  }\n\n  ModuleMap &ModMap = PP.getHeaderSearchInfo().getModuleMap();\n  bool First = true;\n  Module *CurrentModule = nullptr;\n  RecordData Record;\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry =\n        F.Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry) {\n      Error(MaybeEntry.takeError());\n      return Failure;\n    }\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case llvm::BitstreamEntry::SubBlock: // Handled for us already.\n    case llvm::BitstreamEntry::Error:\n      Error(\"malformed block record in AST file\");\n      return Failure;\n    case llvm::BitstreamEntry::EndBlock:\n      return Success;\n    case llvm::BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read a record.\n    StringRef Blob;\n    Record.clear();\n    Expected<unsigned> MaybeKind = F.Stream.readRecord(Entry.ID, Record, &Blob);\n    if (!MaybeKind) {\n      Error(MaybeKind.takeError());\n      return Failure;\n    }\n    unsigned Kind = MaybeKind.get();\n\n    if ((Kind == SUBMODULE_METADATA) != First) {\n      Error(\"submodule metadata record should be at beginning of block\");\n      return Failure;\n    }\n    First = false;\n\n    // Submodule information is only valid if we have a current module.\n    // FIXME: Should we error on these cases?\n    if (!CurrentModule && Kind != SUBMODULE_METADATA &&\n        Kind != SUBMODULE_DEFINITION)\n      continue;\n\n    switch (Kind) {\n    default:  // Default behavior: ignore.\n      break;\n\n    case SUBMODULE_DEFINITION: {\n      if (Record.size() < 12) {\n        Error(\"malformed module definition\");\n        return Failure;\n      }\n\n      StringRef Name = Blob;\n      unsigned Idx = 0;\n      SubmoduleID GlobalID = getGlobalSubmoduleID(F, Record[Idx++]);\n      SubmoduleID Parent = getGlobalSubmoduleID(F, Record[Idx++]);\n      Module::ModuleKind Kind = (Module::ModuleKind)Record[Idx++];\n      bool IsFramework = Record[Idx++];\n      bool IsExplicit = Record[Idx++];\n      bool IsSystem = Record[Idx++];\n      bool IsExternC = Record[Idx++];\n      bool InferSubmodules = Record[Idx++];\n      bool InferExplicitSubmodules = Record[Idx++];\n      bool InferExportWildcard = Record[Idx++];\n      bool ConfigMacrosExhaustive = Record[Idx++];\n      bool ModuleMapIsPrivate = Record[Idx++];\n\n      Module *ParentModule = nullptr;\n      if (Parent)\n        ParentModule = getSubmodule(Parent);\n\n      // Retrieve this (sub)module from the module map, creating it if\n      // necessary.\n      CurrentModule =\n          ModMap.findOrCreateModule(Name, ParentModule, IsFramework, IsExplicit)\n              .first;\n\n      // FIXME: set the definition loc for CurrentModule, or call\n      // ModMap.setInferredModuleAllowedBy()\n\n      SubmoduleID GlobalIndex = GlobalID - NUM_PREDEF_SUBMODULE_IDS;\n      if (GlobalIndex >= SubmodulesLoaded.size() ||\n          SubmodulesLoaded[GlobalIndex]) {\n        Error(\"too many submodules\");\n        return Failure;\n      }\n\n      if (!ParentModule) {\n        if (const FileEntry *CurFile = CurrentModule->getASTFile()) {\n          // Don't emit module relocation error if we have -fno-validate-pch\n          if (!bool(PP.getPreprocessorOpts().DisablePCHOrModuleValidation &\n                    DisableValidationForModuleKind::Module) &&\n              CurFile != F.File) {\n            Error(diag::err_module_file_conflict,\n                  CurrentModule->getTopLevelModuleName(), CurFile->getName(),\n                  F.File->getName());\n            return Failure;\n          }\n        }\n\n        F.DidReadTopLevelSubmodule = true;\n        CurrentModule->setASTFile(F.File);\n        CurrentModule->PresumedModuleMapFile = F.ModuleMapPath;\n      }\n\n      CurrentModule->Kind = Kind;\n      CurrentModule->Signature = F.Signature;\n      CurrentModule->IsFromModuleFile = true;\n      CurrentModule->IsSystem = IsSystem || CurrentModule->IsSystem;\n      CurrentModule->IsExternC = IsExternC;\n      CurrentModule->InferSubmodules = InferSubmodules;\n      CurrentModule->InferExplicitSubmodules = InferExplicitSubmodules;\n      CurrentModule->InferExportWildcard = InferExportWildcard;\n      CurrentModule->ConfigMacrosExhaustive = ConfigMacrosExhaustive;\n      CurrentModule->ModuleMapIsPrivate = ModuleMapIsPrivate;\n      if (DeserializationListener)\n        DeserializationListener->ModuleRead(GlobalID, CurrentModule);\n\n      SubmodulesLoaded[GlobalIndex] = CurrentModule;\n\n      // Clear out data that will be replaced by what is in the module file.\n      CurrentModule->LinkLibraries.clear();\n      CurrentModule->ConfigMacros.clear();\n      CurrentModule->UnresolvedConflicts.clear();\n      CurrentModule->Conflicts.clear();\n\n      // The module is available unless it's missing a requirement; relevant\n      // requirements will be (re-)added by SUBMODULE_REQUIRES records.\n      // Missing headers that were present when the module was built do not\n      // make it unavailable -- if we got this far, this must be an explicitly\n      // imported module file.\n      CurrentModule->Requirements.clear();\n      CurrentModule->MissingHeaders.clear();\n      CurrentModule->IsUnimportable =\n          ParentModule && ParentModule->IsUnimportable;\n      CurrentModule->IsAvailable = !CurrentModule->IsUnimportable;\n      break;\n    }\n\n    case SUBMODULE_UMBRELLA_HEADER: {\n      std::string Filename = std::string(Blob);\n      ResolveImportedPath(F, Filename);\n      if (auto Umbrella = PP.getFileManager().getOptionalFileRef(Filename)) {\n        if (!CurrentModule->getUmbrellaHeader())\n          ModMap.setUmbrellaHeader(CurrentModule, *Umbrella, Blob);\n        else if (CurrentModule->getUmbrellaHeader().Entry != *Umbrella) {\n          if ((ClientLoadCapabilities & ARR_OutOfDate) == 0)\n            Error(\"mismatched umbrella headers in submodule\");\n          return OutOfDate;\n        }\n      }\n      break;\n    }\n\n    case SUBMODULE_HEADER:\n    case SUBMODULE_EXCLUDED_HEADER:\n    case SUBMODULE_PRIVATE_HEADER:\n      // We lazily associate headers with their modules via the HeaderInfo table.\n      // FIXME: Re-evaluate this section; maybe only store InputFile IDs instead\n      // of complete filenames or remove it entirely.\n      break;\n\n    case SUBMODULE_TEXTUAL_HEADER:\n    case SUBMODULE_PRIVATE_TEXTUAL_HEADER:\n      // FIXME: Textual headers are not marked in the HeaderInfo table. Load\n      // them here.\n      break;\n\n    case SUBMODULE_TOPHEADER:\n      CurrentModule->addTopHeaderFilename(Blob);\n      break;\n\n    case SUBMODULE_UMBRELLA_DIR: {\n      std::string Dirname = std::string(Blob);\n      ResolveImportedPath(F, Dirname);\n      if (auto Umbrella =\n              PP.getFileManager().getOptionalDirectoryRef(Dirname)) {\n        if (!CurrentModule->getUmbrellaDir())\n          ModMap.setUmbrellaDir(CurrentModule, *Umbrella, Blob);\n        else if (CurrentModule->getUmbrellaDir().Entry != *Umbrella) {\n          if ((ClientLoadCapabilities & ARR_OutOfDate) == 0)\n            Error(\"mismatched umbrella directories in submodule\");\n          return OutOfDate;\n        }\n      }\n      break;\n    }\n\n    case SUBMODULE_METADATA: {\n      F.BaseSubmoduleID = getTotalNumSubmodules();\n      F.LocalNumSubmodules = Record[0];\n      unsigned LocalBaseSubmoduleID = Record[1];\n      if (F.LocalNumSubmodules > 0) {\n        // Introduce the global -> local mapping for submodules within this\n        // module.\n        GlobalSubmoduleMap.insert(std::make_pair(getTotalNumSubmodules()+1,&F));\n\n        // Introduce the local -> global mapping for submodules within this\n        // module.\n        F.SubmoduleRemap.insertOrReplace(\n          std::make_pair(LocalBaseSubmoduleID,\n                         F.BaseSubmoduleID - LocalBaseSubmoduleID));\n\n        SubmodulesLoaded.resize(SubmodulesLoaded.size() + F.LocalNumSubmodules);\n      }\n      break;\n    }\n\n    case SUBMODULE_IMPORTS:\n      for (unsigned Idx = 0; Idx != Record.size(); ++Idx) {\n        UnresolvedModuleRef Unresolved;\n        Unresolved.File = &F;\n        Unresolved.Mod = CurrentModule;\n        Unresolved.ID = Record[Idx];\n        Unresolved.Kind = UnresolvedModuleRef::Import;\n        Unresolved.IsWildcard = false;\n        UnresolvedModuleRefs.push_back(Unresolved);\n      }\n      break;\n\n    case SUBMODULE_EXPORTS:\n      for (unsigned Idx = 0; Idx + 1 < Record.size(); Idx += 2) {\n        UnresolvedModuleRef Unresolved;\n        Unresolved.File = &F;\n        Unresolved.Mod = CurrentModule;\n        Unresolved.ID = Record[Idx];\n        Unresolved.Kind = UnresolvedModuleRef::Export;\n        Unresolved.IsWildcard = Record[Idx + 1];\n        UnresolvedModuleRefs.push_back(Unresolved);\n      }\n\n      // Once we've loaded the set of exports, there's no reason to keep\n      // the parsed, unresolved exports around.\n      CurrentModule->UnresolvedExports.clear();\n      break;\n\n    case SUBMODULE_REQUIRES:\n      CurrentModule->addRequirement(Blob, Record[0], PP.getLangOpts(),\n                                    PP.getTargetInfo());\n      break;\n\n    case SUBMODULE_LINK_LIBRARY:\n      ModMap.resolveLinkAsDependencies(CurrentModule);\n      CurrentModule->LinkLibraries.push_back(\n          Module::LinkLibrary(std::string(Blob), Record[0]));\n      break;\n\n    case SUBMODULE_CONFIG_MACRO:\n      CurrentModule->ConfigMacros.push_back(Blob.str());\n      break;\n\n    case SUBMODULE_CONFLICT: {\n      UnresolvedModuleRef Unresolved;\n      Unresolved.File = &F;\n      Unresolved.Mod = CurrentModule;\n      Unresolved.ID = Record[0];\n      Unresolved.Kind = UnresolvedModuleRef::Conflict;\n      Unresolved.IsWildcard = false;\n      Unresolved.String = Blob;\n      UnresolvedModuleRefs.push_back(Unresolved);\n      break;\n    }\n\n    case SUBMODULE_INITIALIZERS: {\n      if (!ContextObj)\n        break;\n      SmallVector<uint32_t, 16> Inits;\n      for (auto &ID : Record)\n        Inits.push_back(getGlobalDeclID(F, ID));\n      ContextObj->addLazyModuleInitializers(CurrentModule, Inits);\n      break;\n    }\n\n    case SUBMODULE_EXPORT_AS:\n      CurrentModule->ExportAsModule = Blob.str();\n      ModMap.addLinkAsDependency(CurrentModule);\n      break;\n    }\n  }\n}\n\n/// Parse the record that corresponds to a LangOptions data\n/// structure.\n///\n/// This routine parses the language options from the AST file and then gives\n/// them to the AST listener if one is set.\n///\n/// \\returns true if the listener deems the file unacceptable, false otherwise.\nbool ASTReader::ParseLanguageOptions(const RecordData &Record,\n                                     bool Complain,\n                                     ASTReaderListener &Listener,\n                                     bool AllowCompatibleDifferences) {\n  LangOptions LangOpts;\n  unsigned Idx = 0;\n#define LANGOPT(Name, Bits, Default, Description) \\\n  LangOpts.Name = Record[Idx++];\n#define ENUM_LANGOPT(Name, Type, Bits, Default, Description) \\\n  LangOpts.set##Name(static_cast<LangOptions::Type>(Record[Idx++]));\n#include \"clang/Basic/LangOptions.def\"\n#define SANITIZER(NAME, ID)                                                    \\\n  LangOpts.Sanitize.set(SanitizerKind::ID, Record[Idx++]);\n#include \"clang/Basic/Sanitizers.def\"\n\n  for (unsigned N = Record[Idx++]; N; --N)\n    LangOpts.ModuleFeatures.push_back(ReadString(Record, Idx));\n\n  ObjCRuntime::Kind runtimeKind = (ObjCRuntime::Kind) Record[Idx++];\n  VersionTuple runtimeVersion = ReadVersionTuple(Record, Idx);\n  LangOpts.ObjCRuntime = ObjCRuntime(runtimeKind, runtimeVersion);\n\n  LangOpts.CurrentModule = ReadString(Record, Idx);\n\n  // Comment options.\n  for (unsigned N = Record[Idx++]; N; --N) {\n    LangOpts.CommentOpts.BlockCommandNames.push_back(\n      ReadString(Record, Idx));\n  }\n  LangOpts.CommentOpts.ParseAllComments = Record[Idx++];\n\n  // OpenMP offloading options.\n  for (unsigned N = Record[Idx++]; N; --N) {\n    LangOpts.OMPTargetTriples.push_back(llvm::Triple(ReadString(Record, Idx)));\n  }\n\n  LangOpts.OMPHostIRFile = ReadString(Record, Idx);\n\n  return Listener.ReadLanguageOptions(LangOpts, Complain,\n                                      AllowCompatibleDifferences);\n}\n\nbool ASTReader::ParseTargetOptions(const RecordData &Record, bool Complain,\n                                   ASTReaderListener &Listener,\n                                   bool AllowCompatibleDifferences) {\n  unsigned Idx = 0;\n  TargetOptions TargetOpts;\n  TargetOpts.Triple = ReadString(Record, Idx);\n  TargetOpts.CPU = ReadString(Record, Idx);\n  TargetOpts.TuneCPU = ReadString(Record, Idx);\n  TargetOpts.ABI = ReadString(Record, Idx);\n  for (unsigned N = Record[Idx++]; N; --N) {\n    TargetOpts.FeaturesAsWritten.push_back(ReadString(Record, Idx));\n  }\n  for (unsigned N = Record[Idx++]; N; --N) {\n    TargetOpts.Features.push_back(ReadString(Record, Idx));\n  }\n\n  return Listener.ReadTargetOptions(TargetOpts, Complain,\n                                    AllowCompatibleDifferences);\n}\n\nbool ASTReader::ParseDiagnosticOptions(const RecordData &Record, bool Complain,\n                                       ASTReaderListener &Listener) {\n  IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts(new DiagnosticOptions);\n  unsigned Idx = 0;\n#define DIAGOPT(Name, Bits, Default) DiagOpts->Name = Record[Idx++];\n#define ENUM_DIAGOPT(Name, Type, Bits, Default) \\\n  DiagOpts->set##Name(static_cast<Type>(Record[Idx++]));\n#include \"clang/Basic/DiagnosticOptions.def\"\n\n  for (unsigned N = Record[Idx++]; N; --N)\n    DiagOpts->Warnings.push_back(ReadString(Record, Idx));\n  for (unsigned N = Record[Idx++]; N; --N)\n    DiagOpts->Remarks.push_back(ReadString(Record, Idx));\n\n  return Listener.ReadDiagnosticOptions(DiagOpts, Complain);\n}\n\nbool ASTReader::ParseFileSystemOptions(const RecordData &Record, bool Complain,\n                                       ASTReaderListener &Listener) {\n  FileSystemOptions FSOpts;\n  unsigned Idx = 0;\n  FSOpts.WorkingDir = ReadString(Record, Idx);\n  return Listener.ReadFileSystemOptions(FSOpts, Complain);\n}\n\nbool ASTReader::ParseHeaderSearchOptions(const RecordData &Record,\n                                         bool Complain,\n                                         ASTReaderListener &Listener) {\n  HeaderSearchOptions HSOpts;\n  unsigned Idx = 0;\n  HSOpts.Sysroot = ReadString(Record, Idx);\n\n  // Include entries.\n  for (unsigned N = Record[Idx++]; N; --N) {\n    std::string Path = ReadString(Record, Idx);\n    frontend::IncludeDirGroup Group\n      = static_cast<frontend::IncludeDirGroup>(Record[Idx++]);\n    bool IsFramework = Record[Idx++];\n    bool IgnoreSysRoot = Record[Idx++];\n    HSOpts.UserEntries.emplace_back(std::move(Path), Group, IsFramework,\n                                    IgnoreSysRoot);\n  }\n\n  // System header prefixes.\n  for (unsigned N = Record[Idx++]; N; --N) {\n    std::string Prefix = ReadString(Record, Idx);\n    bool IsSystemHeader = Record[Idx++];\n    HSOpts.SystemHeaderPrefixes.emplace_back(std::move(Prefix), IsSystemHeader);\n  }\n\n  HSOpts.ResourceDir = ReadString(Record, Idx);\n  HSOpts.ModuleCachePath = ReadString(Record, Idx);\n  HSOpts.ModuleUserBuildPath = ReadString(Record, Idx);\n  HSOpts.DisableModuleHash = Record[Idx++];\n  HSOpts.ImplicitModuleMaps = Record[Idx++];\n  HSOpts.ModuleMapFileHomeIsCwd = Record[Idx++];\n  HSOpts.EnablePrebuiltImplicitModules = Record[Idx++];\n  HSOpts.UseBuiltinIncludes = Record[Idx++];\n  HSOpts.UseStandardSystemIncludes = Record[Idx++];\n  HSOpts.UseStandardCXXIncludes = Record[Idx++];\n  HSOpts.UseLibcxx = Record[Idx++];\n  std::string SpecificModuleCachePath = ReadString(Record, Idx);\n\n  return Listener.ReadHeaderSearchOptions(HSOpts, SpecificModuleCachePath,\n                                          Complain);\n}\n\nbool ASTReader::ParsePreprocessorOptions(const RecordData &Record,\n                                         bool Complain,\n                                         ASTReaderListener &Listener,\n                                         std::string &SuggestedPredefines) {\n  PreprocessorOptions PPOpts;\n  unsigned Idx = 0;\n\n  // Macro definitions/undefs\n  for (unsigned N = Record[Idx++]; N; --N) {\n    std::string Macro = ReadString(Record, Idx);\n    bool IsUndef = Record[Idx++];\n    PPOpts.Macros.push_back(std::make_pair(Macro, IsUndef));\n  }\n\n  // Includes\n  for (unsigned N = Record[Idx++]; N; --N) {\n    PPOpts.Includes.push_back(ReadString(Record, Idx));\n  }\n\n  // Macro Includes\n  for (unsigned N = Record[Idx++]; N; --N) {\n    PPOpts.MacroIncludes.push_back(ReadString(Record, Idx));\n  }\n\n  PPOpts.UsePredefines = Record[Idx++];\n  PPOpts.DetailedRecord = Record[Idx++];\n  PPOpts.ImplicitPCHInclude = ReadString(Record, Idx);\n  PPOpts.ObjCXXARCStandardLibrary =\n    static_cast<ObjCXXARCStandardLibraryKind>(Record[Idx++]);\n  SuggestedPredefines.clear();\n  return Listener.ReadPreprocessorOptions(PPOpts, Complain,\n                                          SuggestedPredefines);\n}\n\nstd::pair<ModuleFile *, unsigned>\nASTReader::getModulePreprocessedEntity(unsigned GlobalIndex) {\n  GlobalPreprocessedEntityMapType::iterator\n  I = GlobalPreprocessedEntityMap.find(GlobalIndex);\n  assert(I != GlobalPreprocessedEntityMap.end() &&\n         \"Corrupted global preprocessed entity map\");\n  ModuleFile *M = I->second;\n  unsigned LocalIndex = GlobalIndex - M->BasePreprocessedEntityID;\n  return std::make_pair(M, LocalIndex);\n}\n\nllvm::iterator_range<PreprocessingRecord::iterator>\nASTReader::getModulePreprocessedEntities(ModuleFile &Mod) const {\n  if (PreprocessingRecord *PPRec = PP.getPreprocessingRecord())\n    return PPRec->getIteratorsForLoadedRange(Mod.BasePreprocessedEntityID,\n                                             Mod.NumPreprocessedEntities);\n\n  return llvm::make_range(PreprocessingRecord::iterator(),\n                          PreprocessingRecord::iterator());\n}\n\nllvm::iterator_range<ASTReader::ModuleDeclIterator>\nASTReader::getModuleFileLevelDecls(ModuleFile &Mod) {\n  return llvm::make_range(\n      ModuleDeclIterator(this, &Mod, Mod.FileSortedDecls),\n      ModuleDeclIterator(this, &Mod,\n                         Mod.FileSortedDecls + Mod.NumFileSortedDecls));\n}\n\nSourceRange ASTReader::ReadSkippedRange(unsigned GlobalIndex) {\n  auto I = GlobalSkippedRangeMap.find(GlobalIndex);\n  assert(I != GlobalSkippedRangeMap.end() &&\n    \"Corrupted global skipped range map\");\n  ModuleFile *M = I->second;\n  unsigned LocalIndex = GlobalIndex - M->BasePreprocessedSkippedRangeID;\n  assert(LocalIndex < M->NumPreprocessedSkippedRanges);\n  PPSkippedRange RawRange = M->PreprocessedSkippedRangeOffsets[LocalIndex];\n  SourceRange Range(TranslateSourceLocation(*M, RawRange.getBegin()),\n                    TranslateSourceLocation(*M, RawRange.getEnd()));\n  assert(Range.isValid());\n  return Range;\n}\n\nPreprocessedEntity *ASTReader::ReadPreprocessedEntity(unsigned Index) {\n  PreprocessedEntityID PPID = Index+1;\n  std::pair<ModuleFile *, unsigned> PPInfo = getModulePreprocessedEntity(Index);\n  ModuleFile &M = *PPInfo.first;\n  unsigned LocalIndex = PPInfo.second;\n  const PPEntityOffset &PPOffs = M.PreprocessedEntityOffsets[LocalIndex];\n\n  if (!PP.getPreprocessingRecord()) {\n    Error(\"no preprocessing record\");\n    return nullptr;\n  }\n\n  SavedStreamPosition SavedPosition(M.PreprocessorDetailCursor);\n  if (llvm::Error Err = M.PreprocessorDetailCursor.JumpToBit(\n          M.MacroOffsetsBase + PPOffs.BitOffset)) {\n    Error(std::move(Err));\n    return nullptr;\n  }\n\n  Expected<llvm::BitstreamEntry> MaybeEntry =\n      M.PreprocessorDetailCursor.advance(BitstreamCursor::AF_DontPopBlockAtEnd);\n  if (!MaybeEntry) {\n    Error(MaybeEntry.takeError());\n    return nullptr;\n  }\n  llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n  if (Entry.Kind != llvm::BitstreamEntry::Record)\n    return nullptr;\n\n  // Read the record.\n  SourceRange Range(TranslateSourceLocation(M, PPOffs.getBegin()),\n                    TranslateSourceLocation(M, PPOffs.getEnd()));\n  PreprocessingRecord &PPRec = *PP.getPreprocessingRecord();\n  StringRef Blob;\n  RecordData Record;\n  Expected<unsigned> MaybeRecType =\n      M.PreprocessorDetailCursor.readRecord(Entry.ID, Record, &Blob);\n  if (!MaybeRecType) {\n    Error(MaybeRecType.takeError());\n    return nullptr;\n  }\n  switch ((PreprocessorDetailRecordTypes)MaybeRecType.get()) {\n  case PPD_MACRO_EXPANSION: {\n    bool isBuiltin = Record[0];\n    IdentifierInfo *Name = nullptr;\n    MacroDefinitionRecord *Def = nullptr;\n    if (isBuiltin)\n      Name = getLocalIdentifier(M, Record[1]);\n    else {\n      PreprocessedEntityID GlobalID =\n          getGlobalPreprocessedEntityID(M, Record[1]);\n      Def = cast<MacroDefinitionRecord>(\n          PPRec.getLoadedPreprocessedEntity(GlobalID - 1));\n    }\n\n    MacroExpansion *ME;\n    if (isBuiltin)\n      ME = new (PPRec) MacroExpansion(Name, Range);\n    else\n      ME = new (PPRec) MacroExpansion(Def, Range);\n\n    return ME;\n  }\n\n  case PPD_MACRO_DEFINITION: {\n    // Decode the identifier info and then check again; if the macro is\n    // still defined and associated with the identifier,\n    IdentifierInfo *II = getLocalIdentifier(M, Record[0]);\n    MacroDefinitionRecord *MD = new (PPRec) MacroDefinitionRecord(II, Range);\n\n    if (DeserializationListener)\n      DeserializationListener->MacroDefinitionRead(PPID, MD);\n\n    return MD;\n  }\n\n  case PPD_INCLUSION_DIRECTIVE: {\n    const char *FullFileNameStart = Blob.data() + Record[0];\n    StringRef FullFileName(FullFileNameStart, Blob.size() - Record[0]);\n    const FileEntry *File = nullptr;\n    if (!FullFileName.empty())\n      if (auto FE = PP.getFileManager().getFile(FullFileName))\n        File = *FE;\n\n    // FIXME: Stable encoding\n    InclusionDirective::InclusionKind Kind\n      = static_cast<InclusionDirective::InclusionKind>(Record[2]);\n    InclusionDirective *ID\n      = new (PPRec) InclusionDirective(PPRec, Kind,\n                                       StringRef(Blob.data(), Record[0]),\n                                       Record[1], Record[3],\n                                       File,\n                                       Range);\n    return ID;\n  }\n  }\n\n  llvm_unreachable(\"Invalid PreprocessorDetailRecordTypes\");\n}\n\n/// Find the next module that contains entities and return the ID\n/// of the first entry.\n///\n/// \\param SLocMapI points at a chunk of a module that contains no\n/// preprocessed entities or the entities it contains are not the ones we are\n/// looking for.\nPreprocessedEntityID ASTReader::findNextPreprocessedEntity(\n                       GlobalSLocOffsetMapType::const_iterator SLocMapI) const {\n  ++SLocMapI;\n  for (GlobalSLocOffsetMapType::const_iterator\n         EndI = GlobalSLocOffsetMap.end(); SLocMapI != EndI; ++SLocMapI) {\n    ModuleFile &M = *SLocMapI->second;\n    if (M.NumPreprocessedEntities)\n      return M.BasePreprocessedEntityID;\n  }\n\n  return getTotalNumPreprocessedEntities();\n}\n\nnamespace {\n\nstruct PPEntityComp {\n  const ASTReader &Reader;\n  ModuleFile &M;\n\n  PPEntityComp(const ASTReader &Reader, ModuleFile &M) : Reader(Reader), M(M) {}\n\n  bool operator()(const PPEntityOffset &L, const PPEntityOffset &R) const {\n    SourceLocation LHS = getLoc(L);\n    SourceLocation RHS = getLoc(R);\n    return Reader.getSourceManager().isBeforeInTranslationUnit(LHS, RHS);\n  }\n\n  bool operator()(const PPEntityOffset &L, SourceLocation RHS) const {\n    SourceLocation LHS = getLoc(L);\n    return Reader.getSourceManager().isBeforeInTranslationUnit(LHS, RHS);\n  }\n\n  bool operator()(SourceLocation LHS, const PPEntityOffset &R) const {\n    SourceLocation RHS = getLoc(R);\n    return Reader.getSourceManager().isBeforeInTranslationUnit(LHS, RHS);\n  }\n\n  SourceLocation getLoc(const PPEntityOffset &PPE) const {\n    return Reader.TranslateSourceLocation(M, PPE.getBegin());\n  }\n};\n\n} // namespace\n\nPreprocessedEntityID ASTReader::findPreprocessedEntity(SourceLocation Loc,\n                                                       bool EndsAfter) const {\n  if (SourceMgr.isLocalSourceLocation(Loc))\n    return getTotalNumPreprocessedEntities();\n\n  GlobalSLocOffsetMapType::const_iterator SLocMapI = GlobalSLocOffsetMap.find(\n      SourceManager::MaxLoadedOffset - Loc.getOffset() - 1);\n  assert(SLocMapI != GlobalSLocOffsetMap.end() &&\n         \"Corrupted global sloc offset map\");\n\n  if (SLocMapI->second->NumPreprocessedEntities == 0)\n    return findNextPreprocessedEntity(SLocMapI);\n\n  ModuleFile &M = *SLocMapI->second;\n\n  using pp_iterator = const PPEntityOffset *;\n\n  pp_iterator pp_begin = M.PreprocessedEntityOffsets;\n  pp_iterator pp_end = pp_begin + M.NumPreprocessedEntities;\n\n  size_t Count = M.NumPreprocessedEntities;\n  size_t Half;\n  pp_iterator First = pp_begin;\n  pp_iterator PPI;\n\n  if (EndsAfter) {\n    PPI = std::upper_bound(pp_begin, pp_end, Loc,\n                           PPEntityComp(*this, M));\n  } else {\n    // Do a binary search manually instead of using std::lower_bound because\n    // The end locations of entities may be unordered (when a macro expansion\n    // is inside another macro argument), but for this case it is not important\n    // whether we get the first macro expansion or its containing macro.\n    while (Count > 0) {\n      Half = Count / 2;\n      PPI = First;\n      std::advance(PPI, Half);\n      if (SourceMgr.isBeforeInTranslationUnit(\n              TranslateSourceLocation(M, PPI->getEnd()), Loc)) {\n        First = PPI;\n        ++First;\n        Count = Count - Half - 1;\n      } else\n        Count = Half;\n    }\n  }\n\n  if (PPI == pp_end)\n    return findNextPreprocessedEntity(SLocMapI);\n\n  return M.BasePreprocessedEntityID + (PPI - pp_begin);\n}\n\n/// Returns a pair of [Begin, End) indices of preallocated\n/// preprocessed entities that \\arg Range encompasses.\nstd::pair<unsigned, unsigned>\n    ASTReader::findPreprocessedEntitiesInRange(SourceRange Range) {\n  if (Range.isInvalid())\n    return std::make_pair(0,0);\n  assert(!SourceMgr.isBeforeInTranslationUnit(Range.getEnd(),Range.getBegin()));\n\n  PreprocessedEntityID BeginID =\n      findPreprocessedEntity(Range.getBegin(), false);\n  PreprocessedEntityID EndID = findPreprocessedEntity(Range.getEnd(), true);\n  return std::make_pair(BeginID, EndID);\n}\n\n/// Optionally returns true or false if the preallocated preprocessed\n/// entity with index \\arg Index came from file \\arg FID.\nOptional<bool> ASTReader::isPreprocessedEntityInFileID(unsigned Index,\n                                                             FileID FID) {\n  if (FID.isInvalid())\n    return false;\n\n  std::pair<ModuleFile *, unsigned> PPInfo = getModulePreprocessedEntity(Index);\n  ModuleFile &M = *PPInfo.first;\n  unsigned LocalIndex = PPInfo.second;\n  const PPEntityOffset &PPOffs = M.PreprocessedEntityOffsets[LocalIndex];\n\n  SourceLocation Loc = TranslateSourceLocation(M, PPOffs.getBegin());\n  if (Loc.isInvalid())\n    return false;\n\n  if (SourceMgr.isInFileID(SourceMgr.getFileLoc(Loc), FID))\n    return true;\n  else\n    return false;\n}\n\nnamespace {\n\n  /// Visitor used to search for information about a header file.\n  class HeaderFileInfoVisitor {\n    const FileEntry *FE;\n    Optional<HeaderFileInfo> HFI;\n\n  public:\n    explicit HeaderFileInfoVisitor(const FileEntry *FE) : FE(FE) {}\n\n    bool operator()(ModuleFile &M) {\n      HeaderFileInfoLookupTable *Table\n        = static_cast<HeaderFileInfoLookupTable *>(M.HeaderFileInfoTable);\n      if (!Table)\n        return false;\n\n      // Look in the on-disk hash table for an entry for this file name.\n      HeaderFileInfoLookupTable::iterator Pos = Table->find(FE);\n      if (Pos == Table->end())\n        return false;\n\n      HFI = *Pos;\n      return true;\n    }\n\n    Optional<HeaderFileInfo> getHeaderFileInfo() const { return HFI; }\n  };\n\n} // namespace\n\nHeaderFileInfo ASTReader::GetHeaderFileInfo(const FileEntry *FE) {\n  HeaderFileInfoVisitor Visitor(FE);\n  ModuleMgr.visit(Visitor);\n  if (Optional<HeaderFileInfo> HFI = Visitor.getHeaderFileInfo())\n    return *HFI;\n\n  return HeaderFileInfo();\n}\n\nvoid ASTReader::ReadPragmaDiagnosticMappings(DiagnosticsEngine &Diag) {\n  using DiagState = DiagnosticsEngine::DiagState;\n  SmallVector<DiagState *, 32> DiagStates;\n\n  for (ModuleFile &F : ModuleMgr) {\n    unsigned Idx = 0;\n    auto &Record = F.PragmaDiagMappings;\n    if (Record.empty())\n      continue;\n\n    DiagStates.clear();\n\n    auto ReadDiagState =\n        [&](const DiagState &BasedOn, SourceLocation Loc,\n            bool IncludeNonPragmaStates) -> DiagnosticsEngine::DiagState * {\n      unsigned BackrefID = Record[Idx++];\n      if (BackrefID != 0)\n        return DiagStates[BackrefID - 1];\n\n      // A new DiagState was created here.\n      Diag.DiagStates.push_back(BasedOn);\n      DiagState *NewState = &Diag.DiagStates.back();\n      DiagStates.push_back(NewState);\n      unsigned Size = Record[Idx++];\n      assert(Idx + Size * 2 <= Record.size() &&\n             \"Invalid data, not enough diag/map pairs\");\n      while (Size--) {\n        unsigned DiagID = Record[Idx++];\n        DiagnosticMapping NewMapping =\n            DiagnosticMapping::deserialize(Record[Idx++]);\n        if (!NewMapping.isPragma() && !IncludeNonPragmaStates)\n          continue;\n\n        DiagnosticMapping &Mapping = NewState->getOrAddMapping(DiagID);\n\n        // If this mapping was specified as a warning but the severity was\n        // upgraded due to diagnostic settings, simulate the current diagnostic\n        // settings (and use a warning).\n        if (NewMapping.wasUpgradedFromWarning() && !Mapping.isErrorOrFatal()) {\n          NewMapping.setSeverity(diag::Severity::Warning);\n          NewMapping.setUpgradedFromWarning(false);\n        }\n\n        Mapping = NewMapping;\n      }\n      return NewState;\n    };\n\n    // Read the first state.\n    DiagState *FirstState;\n    if (F.Kind == MK_ImplicitModule) {\n      // Implicitly-built modules are reused with different diagnostic\n      // settings.  Use the initial diagnostic state from Diag to simulate this\n      // compilation's diagnostic settings.\n      FirstState = Diag.DiagStatesByLoc.FirstDiagState;\n      DiagStates.push_back(FirstState);\n\n      // Skip the initial diagnostic state from the serialized module.\n      assert(Record[1] == 0 &&\n             \"Invalid data, unexpected backref in initial state\");\n      Idx = 3 + Record[2] * 2;\n      assert(Idx < Record.size() &&\n             \"Invalid data, not enough state change pairs in initial state\");\n    } else if (F.isModule()) {\n      // For an explicit module, preserve the flags from the module build\n      // command line (-w, -Weverything, -Werror, ...) along with any explicit\n      // -Wblah flags.\n      unsigned Flags = Record[Idx++];\n      DiagState Initial;\n      Initial.SuppressSystemWarnings = Flags & 1; Flags >>= 1;\n      Initial.ErrorsAsFatal = Flags & 1; Flags >>= 1;\n      Initial.WarningsAsErrors = Flags & 1; Flags >>= 1;\n      Initial.EnableAllWarnings = Flags & 1; Flags >>= 1;\n      Initial.IgnoreAllWarnings = Flags & 1; Flags >>= 1;\n      Initial.ExtBehavior = (diag::Severity)Flags;\n      FirstState = ReadDiagState(Initial, SourceLocation(), true);\n\n      assert(F.OriginalSourceFileID.isValid());\n\n      // Set up the root buffer of the module to start with the initial\n      // diagnostic state of the module itself, to cover files that contain no\n      // explicit transitions (for which we did not serialize anything).\n      Diag.DiagStatesByLoc.Files[F.OriginalSourceFileID]\n          .StateTransitions.push_back({FirstState, 0});\n    } else {\n      // For prefix ASTs, start with whatever the user configured on the\n      // command line.\n      Idx++; // Skip flags.\n      FirstState = ReadDiagState(*Diag.DiagStatesByLoc.CurDiagState,\n                                 SourceLocation(), false);\n    }\n\n    // Read the state transitions.\n    unsigned NumLocations = Record[Idx++];\n    while (NumLocations--) {\n      assert(Idx < Record.size() &&\n             \"Invalid data, missing pragma diagnostic states\");\n      SourceLocation Loc = ReadSourceLocation(F, Record[Idx++]);\n      auto IDAndOffset = SourceMgr.getDecomposedLoc(Loc);\n      assert(IDAndOffset.first.isValid() && \"invalid FileID for transition\");\n      assert(IDAndOffset.second == 0 && \"not a start location for a FileID\");\n      unsigned Transitions = Record[Idx++];\n\n      // Note that we don't need to set up Parent/ParentOffset here, because\n      // we won't be changing the diagnostic state within imported FileIDs\n      // (other than perhaps appending to the main source file, which has no\n      // parent).\n      auto &F = Diag.DiagStatesByLoc.Files[IDAndOffset.first];\n      F.StateTransitions.reserve(F.StateTransitions.size() + Transitions);\n      for (unsigned I = 0; I != Transitions; ++I) {\n        unsigned Offset = Record[Idx++];\n        auto *State =\n            ReadDiagState(*FirstState, Loc.getLocWithOffset(Offset), false);\n        F.StateTransitions.push_back({State, Offset});\n      }\n    }\n\n    // Read the final state.\n    assert(Idx < Record.size() &&\n           \"Invalid data, missing final pragma diagnostic state\");\n    SourceLocation CurStateLoc =\n        ReadSourceLocation(F, F.PragmaDiagMappings[Idx++]);\n    auto *CurState = ReadDiagState(*FirstState, CurStateLoc, false);\n\n    if (!F.isModule()) {\n      Diag.DiagStatesByLoc.CurDiagState = CurState;\n      Diag.DiagStatesByLoc.CurDiagStateLoc = CurStateLoc;\n\n      // Preserve the property that the imaginary root file describes the\n      // current state.\n      FileID NullFile;\n      auto &T = Diag.DiagStatesByLoc.Files[NullFile].StateTransitions;\n      if (T.empty())\n        T.push_back({CurState, 0});\n      else\n        T[0].State = CurState;\n    }\n\n    // Don't try to read these mappings again.\n    Record.clear();\n  }\n}\n\n/// Get the correct cursor and offset for loading a type.\nASTReader::RecordLocation ASTReader::TypeCursorForIndex(unsigned Index) {\n  GlobalTypeMapType::iterator I = GlobalTypeMap.find(Index);\n  assert(I != GlobalTypeMap.end() && \"Corrupted global type map\");\n  ModuleFile *M = I->second;\n  return RecordLocation(\n      M, M->TypeOffsets[Index - M->BaseTypeIndex].getBitOffset() +\n             M->DeclsBlockStartOffset);\n}\n\nstatic llvm::Optional<Type::TypeClass> getTypeClassForCode(TypeCode code) {\n  switch (code) {\n#define TYPE_BIT_CODE(CLASS_ID, CODE_ID, CODE_VALUE) \\\n  case TYPE_##CODE_ID: return Type::CLASS_ID;\n#include \"clang/Serialization/TypeBitCodes.def\"\n  default: return llvm::None;\n  }\n}\n\n/// Read and return the type with the given index..\n///\n/// The index is the type ID, shifted and minus the number of predefs. This\n/// routine actually reads the record corresponding to the type at the given\n/// location. It is a helper routine for GetType, which deals with reading type\n/// IDs.\nQualType ASTReader::readTypeRecord(unsigned Index) {\n  assert(ContextObj && \"reading type with no AST context\");\n  ASTContext &Context = *ContextObj;\n  RecordLocation Loc = TypeCursorForIndex(Index);\n  BitstreamCursor &DeclsCursor = Loc.F->DeclsCursor;\n\n  // Keep track of where we are in the stream, then jump back there\n  // after reading this type.\n  SavedStreamPosition SavedPosition(DeclsCursor);\n\n  ReadingKindTracker ReadingKind(Read_Type, *this);\n\n  // Note that we are loading a type record.\n  Deserializing AType(this);\n\n  if (llvm::Error Err = DeclsCursor.JumpToBit(Loc.Offset)) {\n    Error(std::move(Err));\n    return QualType();\n  }\n  Expected<unsigned> RawCode = DeclsCursor.ReadCode();\n  if (!RawCode) {\n    Error(RawCode.takeError());\n    return QualType();\n  }\n\n  ASTRecordReader Record(*this, *Loc.F);\n  Expected<unsigned> Code = Record.readRecord(DeclsCursor, RawCode.get());\n  if (!Code) {\n    Error(Code.takeError());\n    return QualType();\n  }\n  if (Code.get() == TYPE_EXT_QUAL) {\n    QualType baseType = Record.readQualType();\n    Qualifiers quals = Record.readQualifiers();\n    return Context.getQualifiedType(baseType, quals);\n  }\n\n  auto maybeClass = getTypeClassForCode((TypeCode) Code.get());\n  if (!maybeClass) {\n    Error(\"Unexpected code for type\");\n    return QualType();\n  }\n\n  serialization::AbstractTypeReader<ASTRecordReader> TypeReader(Record);\n  return TypeReader.read(*maybeClass);\n}\n\nnamespace clang {\n\nclass TypeLocReader : public TypeLocVisitor<TypeLocReader> {\n  ASTRecordReader &Reader;\n\n  SourceLocation readSourceLocation() {\n    return Reader.readSourceLocation();\n  }\n\n  TypeSourceInfo *GetTypeSourceInfo() {\n    return Reader.readTypeSourceInfo();\n  }\n\n  NestedNameSpecifierLoc ReadNestedNameSpecifierLoc() {\n    return Reader.readNestedNameSpecifierLoc();\n  }\n\n  Attr *ReadAttr() {\n    return Reader.readAttr();\n  }\n\npublic:\n  TypeLocReader(ASTRecordReader &Reader) : Reader(Reader) {}\n\n  // We want compile-time assurance that we've enumerated all of\n  // these, so unfortunately we have to declare them first, then\n  // define them out-of-line.\n#define ABSTRACT_TYPELOC(CLASS, PARENT)\n#define TYPELOC(CLASS, PARENT) \\\n  void Visit##CLASS##TypeLoc(CLASS##TypeLoc TyLoc);\n#include \"clang/AST/TypeLocNodes.def\"\n\n  void VisitFunctionTypeLoc(FunctionTypeLoc);\n  void VisitArrayTypeLoc(ArrayTypeLoc);\n};\n\n} // namespace clang\n\nvoid TypeLocReader::VisitQualifiedTypeLoc(QualifiedTypeLoc TL) {\n  // nothing to do\n}\n\nvoid TypeLocReader::VisitBuiltinTypeLoc(BuiltinTypeLoc TL) {\n  TL.setBuiltinLoc(readSourceLocation());\n  if (TL.needsExtraLocalData()) {\n    TL.setWrittenTypeSpec(static_cast<DeclSpec::TST>(Reader.readInt()));\n    TL.setWrittenSignSpec(static_cast<TypeSpecifierSign>(Reader.readInt()));\n    TL.setWrittenWidthSpec(static_cast<TypeSpecifierWidth>(Reader.readInt()));\n    TL.setModeAttr(Reader.readInt());\n  }\n}\n\nvoid TypeLocReader::VisitComplexTypeLoc(ComplexTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitPointerTypeLoc(PointerTypeLoc TL) {\n  TL.setStarLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitDecayedTypeLoc(DecayedTypeLoc TL) {\n  // nothing to do\n}\n\nvoid TypeLocReader::VisitAdjustedTypeLoc(AdjustedTypeLoc TL) {\n  // nothing to do\n}\n\nvoid TypeLocReader::VisitMacroQualifiedTypeLoc(MacroQualifiedTypeLoc TL) {\n  TL.setExpansionLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitBlockPointerTypeLoc(BlockPointerTypeLoc TL) {\n  TL.setCaretLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitLValueReferenceTypeLoc(LValueReferenceTypeLoc TL) {\n  TL.setAmpLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitRValueReferenceTypeLoc(RValueReferenceTypeLoc TL) {\n  TL.setAmpAmpLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitMemberPointerTypeLoc(MemberPointerTypeLoc TL) {\n  TL.setStarLoc(readSourceLocation());\n  TL.setClassTInfo(GetTypeSourceInfo());\n}\n\nvoid TypeLocReader::VisitArrayTypeLoc(ArrayTypeLoc TL) {\n  TL.setLBracketLoc(readSourceLocation());\n  TL.setRBracketLoc(readSourceLocation());\n  if (Reader.readBool())\n    TL.setSizeExpr(Reader.readExpr());\n  else\n    TL.setSizeExpr(nullptr);\n}\n\nvoid TypeLocReader::VisitConstantArrayTypeLoc(ConstantArrayTypeLoc TL) {\n  VisitArrayTypeLoc(TL);\n}\n\nvoid TypeLocReader::VisitIncompleteArrayTypeLoc(IncompleteArrayTypeLoc TL) {\n  VisitArrayTypeLoc(TL);\n}\n\nvoid TypeLocReader::VisitVariableArrayTypeLoc(VariableArrayTypeLoc TL) {\n  VisitArrayTypeLoc(TL);\n}\n\nvoid TypeLocReader::VisitDependentSizedArrayTypeLoc(\n                                            DependentSizedArrayTypeLoc TL) {\n  VisitArrayTypeLoc(TL);\n}\n\nvoid TypeLocReader::VisitDependentAddressSpaceTypeLoc(\n    DependentAddressSpaceTypeLoc TL) {\n\n    TL.setAttrNameLoc(readSourceLocation());\n    TL.setAttrOperandParensRange(Reader.readSourceRange());\n    TL.setAttrExprOperand(Reader.readExpr());\n}\n\nvoid TypeLocReader::VisitDependentSizedExtVectorTypeLoc(\n                                        DependentSizedExtVectorTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitVectorTypeLoc(VectorTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitDependentVectorTypeLoc(\n    DependentVectorTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitExtVectorTypeLoc(ExtVectorTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitConstantMatrixTypeLoc(ConstantMatrixTypeLoc TL) {\n  TL.setAttrNameLoc(readSourceLocation());\n  TL.setAttrOperandParensRange(Reader.readSourceRange());\n  TL.setAttrRowOperand(Reader.readExpr());\n  TL.setAttrColumnOperand(Reader.readExpr());\n}\n\nvoid TypeLocReader::VisitDependentSizedMatrixTypeLoc(\n    DependentSizedMatrixTypeLoc TL) {\n  TL.setAttrNameLoc(readSourceLocation());\n  TL.setAttrOperandParensRange(Reader.readSourceRange());\n  TL.setAttrRowOperand(Reader.readExpr());\n  TL.setAttrColumnOperand(Reader.readExpr());\n}\n\nvoid TypeLocReader::VisitFunctionTypeLoc(FunctionTypeLoc TL) {\n  TL.setLocalRangeBegin(readSourceLocation());\n  TL.setLParenLoc(readSourceLocation());\n  TL.setRParenLoc(readSourceLocation());\n  TL.setExceptionSpecRange(Reader.readSourceRange());\n  TL.setLocalRangeEnd(readSourceLocation());\n  for (unsigned i = 0, e = TL.getNumParams(); i != e; ++i) {\n    TL.setParam(i, Reader.readDeclAs<ParmVarDecl>());\n  }\n}\n\nvoid TypeLocReader::VisitFunctionProtoTypeLoc(FunctionProtoTypeLoc TL) {\n  VisitFunctionTypeLoc(TL);\n}\n\nvoid TypeLocReader::VisitFunctionNoProtoTypeLoc(FunctionNoProtoTypeLoc TL) {\n  VisitFunctionTypeLoc(TL);\n}\n\nvoid TypeLocReader::VisitUnresolvedUsingTypeLoc(UnresolvedUsingTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitTypedefTypeLoc(TypedefTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitTypeOfExprTypeLoc(TypeOfExprTypeLoc TL) {\n  TL.setTypeofLoc(readSourceLocation());\n  TL.setLParenLoc(readSourceLocation());\n  TL.setRParenLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitTypeOfTypeLoc(TypeOfTypeLoc TL) {\n  TL.setTypeofLoc(readSourceLocation());\n  TL.setLParenLoc(readSourceLocation());\n  TL.setRParenLoc(readSourceLocation());\n  TL.setUnderlyingTInfo(GetTypeSourceInfo());\n}\n\nvoid TypeLocReader::VisitDecltypeTypeLoc(DecltypeTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitUnaryTransformTypeLoc(UnaryTransformTypeLoc TL) {\n  TL.setKWLoc(readSourceLocation());\n  TL.setLParenLoc(readSourceLocation());\n  TL.setRParenLoc(readSourceLocation());\n  TL.setUnderlyingTInfo(GetTypeSourceInfo());\n}\n\nvoid TypeLocReader::VisitAutoTypeLoc(AutoTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n  if (Reader.readBool()) {\n    TL.setNestedNameSpecifierLoc(ReadNestedNameSpecifierLoc());\n    TL.setTemplateKWLoc(readSourceLocation());\n    TL.setConceptNameLoc(readSourceLocation());\n    TL.setFoundDecl(Reader.readDeclAs<NamedDecl>());\n    TL.setLAngleLoc(readSourceLocation());\n    TL.setRAngleLoc(readSourceLocation());\n    for (unsigned i = 0, e = TL.getNumArgs(); i != e; ++i)\n      TL.setArgLocInfo(i, Reader.readTemplateArgumentLocInfo(\n                              TL.getTypePtr()->getArg(i).getKind()));\n  }\n}\n\nvoid TypeLocReader::VisitDeducedTemplateSpecializationTypeLoc(\n    DeducedTemplateSpecializationTypeLoc TL) {\n  TL.setTemplateNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitRecordTypeLoc(RecordTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitEnumTypeLoc(EnumTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitAttributedTypeLoc(AttributedTypeLoc TL) {\n  TL.setAttr(ReadAttr());\n}\n\nvoid TypeLocReader::VisitTemplateTypeParmTypeLoc(TemplateTypeParmTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitSubstTemplateTypeParmTypeLoc(\n                                            SubstTemplateTypeParmTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitSubstTemplateTypeParmPackTypeLoc(\n                                          SubstTemplateTypeParmPackTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitTemplateSpecializationTypeLoc(\n                                           TemplateSpecializationTypeLoc TL) {\n  TL.setTemplateKeywordLoc(readSourceLocation());\n  TL.setTemplateNameLoc(readSourceLocation());\n  TL.setLAngleLoc(readSourceLocation());\n  TL.setRAngleLoc(readSourceLocation());\n  for (unsigned i = 0, e = TL.getNumArgs(); i != e; ++i)\n    TL.setArgLocInfo(\n        i,\n        Reader.readTemplateArgumentLocInfo(\n          TL.getTypePtr()->getArg(i).getKind()));\n}\n\nvoid TypeLocReader::VisitParenTypeLoc(ParenTypeLoc TL) {\n  TL.setLParenLoc(readSourceLocation());\n  TL.setRParenLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitElaboratedTypeLoc(ElaboratedTypeLoc TL) {\n  TL.setElaboratedKeywordLoc(readSourceLocation());\n  TL.setQualifierLoc(ReadNestedNameSpecifierLoc());\n}\n\nvoid TypeLocReader::VisitInjectedClassNameTypeLoc(InjectedClassNameTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitDependentNameTypeLoc(DependentNameTypeLoc TL) {\n  TL.setElaboratedKeywordLoc(readSourceLocation());\n  TL.setQualifierLoc(ReadNestedNameSpecifierLoc());\n  TL.setNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitDependentTemplateSpecializationTypeLoc(\n       DependentTemplateSpecializationTypeLoc TL) {\n  TL.setElaboratedKeywordLoc(readSourceLocation());\n  TL.setQualifierLoc(ReadNestedNameSpecifierLoc());\n  TL.setTemplateKeywordLoc(readSourceLocation());\n  TL.setTemplateNameLoc(readSourceLocation());\n  TL.setLAngleLoc(readSourceLocation());\n  TL.setRAngleLoc(readSourceLocation());\n  for (unsigned I = 0, E = TL.getNumArgs(); I != E; ++I)\n    TL.setArgLocInfo(\n        I,\n        Reader.readTemplateArgumentLocInfo(\n            TL.getTypePtr()->getArg(I).getKind()));\n}\n\nvoid TypeLocReader::VisitPackExpansionTypeLoc(PackExpansionTypeLoc TL) {\n  TL.setEllipsisLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitObjCInterfaceTypeLoc(ObjCInterfaceTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitObjCTypeParamTypeLoc(ObjCTypeParamTypeLoc TL) {\n  if (TL.getNumProtocols()) {\n    TL.setProtocolLAngleLoc(readSourceLocation());\n    TL.setProtocolRAngleLoc(readSourceLocation());\n  }\n  for (unsigned i = 0, e = TL.getNumProtocols(); i != e; ++i)\n    TL.setProtocolLoc(i, readSourceLocation());\n}\n\nvoid TypeLocReader::VisitObjCObjectTypeLoc(ObjCObjectTypeLoc TL) {\n  TL.setHasBaseTypeAsWritten(Reader.readBool());\n  TL.setTypeArgsLAngleLoc(readSourceLocation());\n  TL.setTypeArgsRAngleLoc(readSourceLocation());\n  for (unsigned i = 0, e = TL.getNumTypeArgs(); i != e; ++i)\n    TL.setTypeArgTInfo(i, GetTypeSourceInfo());\n  TL.setProtocolLAngleLoc(readSourceLocation());\n  TL.setProtocolRAngleLoc(readSourceLocation());\n  for (unsigned i = 0, e = TL.getNumProtocols(); i != e; ++i)\n    TL.setProtocolLoc(i, readSourceLocation());\n}\n\nvoid TypeLocReader::VisitObjCObjectPointerTypeLoc(ObjCObjectPointerTypeLoc TL) {\n  TL.setStarLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitAtomicTypeLoc(AtomicTypeLoc TL) {\n  TL.setKWLoc(readSourceLocation());\n  TL.setLParenLoc(readSourceLocation());\n  TL.setRParenLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitPipeTypeLoc(PipeTypeLoc TL) {\n  TL.setKWLoc(readSourceLocation());\n}\n\nvoid TypeLocReader::VisitExtIntTypeLoc(clang::ExtIntTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\nvoid TypeLocReader::VisitDependentExtIntTypeLoc(\n    clang::DependentExtIntTypeLoc TL) {\n  TL.setNameLoc(readSourceLocation());\n}\n\n\nvoid ASTRecordReader::readTypeLoc(TypeLoc TL) {\n  TypeLocReader TLR(*this);\n  for (; !TL.isNull(); TL = TL.getNextTypeLoc())\n    TLR.Visit(TL);\n}\n\nTypeSourceInfo *ASTRecordReader::readTypeSourceInfo() {\n  QualType InfoTy = readType();\n  if (InfoTy.isNull())\n    return nullptr;\n\n  TypeSourceInfo *TInfo = getContext().CreateTypeSourceInfo(InfoTy);\n  readTypeLoc(TInfo->getTypeLoc());\n  return TInfo;\n}\n\nQualType ASTReader::GetType(TypeID ID) {\n  assert(ContextObj && \"reading type with no AST context\");\n  ASTContext &Context = *ContextObj;\n\n  unsigned FastQuals = ID & Qualifiers::FastMask;\n  unsigned Index = ID >> Qualifiers::FastWidth;\n\n  if (Index < NUM_PREDEF_TYPE_IDS) {\n    QualType T;\n    switch ((PredefinedTypeIDs)Index) {\n    case PREDEF_TYPE_NULL_ID:\n      return QualType();\n    case PREDEF_TYPE_VOID_ID:\n      T = Context.VoidTy;\n      break;\n    case PREDEF_TYPE_BOOL_ID:\n      T = Context.BoolTy;\n      break;\n    case PREDEF_TYPE_CHAR_U_ID:\n    case PREDEF_TYPE_CHAR_S_ID:\n      // FIXME: Check that the signedness of CharTy is correct!\n      T = Context.CharTy;\n      break;\n    case PREDEF_TYPE_UCHAR_ID:\n      T = Context.UnsignedCharTy;\n      break;\n    case PREDEF_TYPE_USHORT_ID:\n      T = Context.UnsignedShortTy;\n      break;\n    case PREDEF_TYPE_UINT_ID:\n      T = Context.UnsignedIntTy;\n      break;\n    case PREDEF_TYPE_ULONG_ID:\n      T = Context.UnsignedLongTy;\n      break;\n    case PREDEF_TYPE_ULONGLONG_ID:\n      T = Context.UnsignedLongLongTy;\n      break;\n    case PREDEF_TYPE_UINT128_ID:\n      T = Context.UnsignedInt128Ty;\n      break;\n    case PREDEF_TYPE_SCHAR_ID:\n      T = Context.SignedCharTy;\n      break;\n    case PREDEF_TYPE_WCHAR_ID:\n      T = Context.WCharTy;\n      break;\n    case PREDEF_TYPE_SHORT_ID:\n      T = Context.ShortTy;\n      break;\n    case PREDEF_TYPE_INT_ID:\n      T = Context.IntTy;\n      break;\n    case PREDEF_TYPE_LONG_ID:\n      T = Context.LongTy;\n      break;\n    case PREDEF_TYPE_LONGLONG_ID:\n      T = Context.LongLongTy;\n      break;\n    case PREDEF_TYPE_INT128_ID:\n      T = Context.Int128Ty;\n      break;\n    case PREDEF_TYPE_BFLOAT16_ID:\n      T = Context.BFloat16Ty;\n      break;\n    case PREDEF_TYPE_HALF_ID:\n      T = Context.HalfTy;\n      break;\n    case PREDEF_TYPE_FLOAT_ID:\n      T = Context.FloatTy;\n      break;\n    case PREDEF_TYPE_DOUBLE_ID:\n      T = Context.DoubleTy;\n      break;\n    case PREDEF_TYPE_LONGDOUBLE_ID:\n      T = Context.LongDoubleTy;\n      break;\n    case PREDEF_TYPE_SHORT_ACCUM_ID:\n      T = Context.ShortAccumTy;\n      break;\n    case PREDEF_TYPE_ACCUM_ID:\n      T = Context.AccumTy;\n      break;\n    case PREDEF_TYPE_LONG_ACCUM_ID:\n      T = Context.LongAccumTy;\n      break;\n    case PREDEF_TYPE_USHORT_ACCUM_ID:\n      T = Context.UnsignedShortAccumTy;\n      break;\n    case PREDEF_TYPE_UACCUM_ID:\n      T = Context.UnsignedAccumTy;\n      break;\n    case PREDEF_TYPE_ULONG_ACCUM_ID:\n      T = Context.UnsignedLongAccumTy;\n      break;\n    case PREDEF_TYPE_SHORT_FRACT_ID:\n      T = Context.ShortFractTy;\n      break;\n    case PREDEF_TYPE_FRACT_ID:\n      T = Context.FractTy;\n      break;\n    case PREDEF_TYPE_LONG_FRACT_ID:\n      T = Context.LongFractTy;\n      break;\n    case PREDEF_TYPE_USHORT_FRACT_ID:\n      T = Context.UnsignedShortFractTy;\n      break;\n    case PREDEF_TYPE_UFRACT_ID:\n      T = Context.UnsignedFractTy;\n      break;\n    case PREDEF_TYPE_ULONG_FRACT_ID:\n      T = Context.UnsignedLongFractTy;\n      break;\n    case PREDEF_TYPE_SAT_SHORT_ACCUM_ID:\n      T = Context.SatShortAccumTy;\n      break;\n    case PREDEF_TYPE_SAT_ACCUM_ID:\n      T = Context.SatAccumTy;\n      break;\n    case PREDEF_TYPE_SAT_LONG_ACCUM_ID:\n      T = Context.SatLongAccumTy;\n      break;\n    case PREDEF_TYPE_SAT_USHORT_ACCUM_ID:\n      T = Context.SatUnsignedShortAccumTy;\n      break;\n    case PREDEF_TYPE_SAT_UACCUM_ID:\n      T = Context.SatUnsignedAccumTy;\n      break;\n    case PREDEF_TYPE_SAT_ULONG_ACCUM_ID:\n      T = Context.SatUnsignedLongAccumTy;\n      break;\n    case PREDEF_TYPE_SAT_SHORT_FRACT_ID:\n      T = Context.SatShortFractTy;\n      break;\n    case PREDEF_TYPE_SAT_FRACT_ID:\n      T = Context.SatFractTy;\n      break;\n    case PREDEF_TYPE_SAT_LONG_FRACT_ID:\n      T = Context.SatLongFractTy;\n      break;\n    case PREDEF_TYPE_SAT_USHORT_FRACT_ID:\n      T = Context.SatUnsignedShortFractTy;\n      break;\n    case PREDEF_TYPE_SAT_UFRACT_ID:\n      T = Context.SatUnsignedFractTy;\n      break;\n    case PREDEF_TYPE_SAT_ULONG_FRACT_ID:\n      T = Context.SatUnsignedLongFractTy;\n      break;\n    case PREDEF_TYPE_FLOAT16_ID:\n      T = Context.Float16Ty;\n      break;\n    case PREDEF_TYPE_FLOAT128_ID:\n      T = Context.Float128Ty;\n      break;\n    case PREDEF_TYPE_OVERLOAD_ID:\n      T = Context.OverloadTy;\n      break;\n    case PREDEF_TYPE_BOUND_MEMBER:\n      T = Context.BoundMemberTy;\n      break;\n    case PREDEF_TYPE_PSEUDO_OBJECT:\n      T = Context.PseudoObjectTy;\n      break;\n    case PREDEF_TYPE_DEPENDENT_ID:\n      T = Context.DependentTy;\n      break;\n    case PREDEF_TYPE_UNKNOWN_ANY:\n      T = Context.UnknownAnyTy;\n      break;\n    case PREDEF_TYPE_NULLPTR_ID:\n      T = Context.NullPtrTy;\n      break;\n    case PREDEF_TYPE_CHAR8_ID:\n      T = Context.Char8Ty;\n      break;\n    case PREDEF_TYPE_CHAR16_ID:\n      T = Context.Char16Ty;\n      break;\n    case PREDEF_TYPE_CHAR32_ID:\n      T = Context.Char32Ty;\n      break;\n    case PREDEF_TYPE_OBJC_ID:\n      T = Context.ObjCBuiltinIdTy;\n      break;\n    case PREDEF_TYPE_OBJC_CLASS:\n      T = Context.ObjCBuiltinClassTy;\n      break;\n    case PREDEF_TYPE_OBJC_SEL:\n      T = Context.ObjCBuiltinSelTy;\n      break;\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n    case PREDEF_TYPE_##Id##_ID: \\\n      T = Context.SingletonId; \\\n      break;\n#include \"clang/Basic/OpenCLImageTypes.def\"\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n    case PREDEF_TYPE_##Id##_ID: \\\n      T = Context.Id##Ty; \\\n      break;\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n    case PREDEF_TYPE_SAMPLER_ID:\n      T = Context.OCLSamplerTy;\n      break;\n    case PREDEF_TYPE_EVENT_ID:\n      T = Context.OCLEventTy;\n      break;\n    case PREDEF_TYPE_CLK_EVENT_ID:\n      T = Context.OCLClkEventTy;\n      break;\n    case PREDEF_TYPE_QUEUE_ID:\n      T = Context.OCLQueueTy;\n      break;\n    case PREDEF_TYPE_RESERVE_ID_ID:\n      T = Context.OCLReserveIDTy;\n      break;\n    case PREDEF_TYPE_AUTO_DEDUCT:\n      T = Context.getAutoDeductType();\n      break;\n    case PREDEF_TYPE_AUTO_RREF_DEDUCT:\n      T = Context.getAutoRRefDeductType();\n      break;\n    case PREDEF_TYPE_ARC_UNBRIDGED_CAST:\n      T = Context.ARCUnbridgedCastTy;\n      break;\n    case PREDEF_TYPE_BUILTIN_FN:\n      T = Context.BuiltinFnTy;\n      break;\n    case PREDEF_TYPE_INCOMPLETE_MATRIX_IDX:\n      T = Context.IncompleteMatrixIdxTy;\n      break;\n    case PREDEF_TYPE_OMP_ARRAY_SECTION:\n      T = Context.OMPArraySectionTy;\n      break;\n    case PREDEF_TYPE_OMP_ARRAY_SHAPING:\n      T = Context.OMPArraySectionTy;\n      break;\n    case PREDEF_TYPE_OMP_ITERATOR:\n      T = Context.OMPIteratorTy;\n      break;\n#define SVE_TYPE(Name, Id, SingletonId) \\\n    case PREDEF_TYPE_##Id##_ID: \\\n      T = Context.SingletonId; \\\n      break;\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n#define PPC_VECTOR_TYPE(Name, Id, Size) \\\n    case PREDEF_TYPE_##Id##_ID: \\\n      T = Context.Id##Ty; \\\n      break;\n#include \"clang/Basic/PPCTypes.def\"\n#define RVV_TYPE(Name, Id, SingletonId) \\\n    case PREDEF_TYPE_##Id##_ID: \\\n      T = Context.SingletonId; \\\n      break;\n#include \"clang/Basic/RISCVVTypes.def\"\n    }\n\n    assert(!T.isNull() && \"Unknown predefined type\");\n    return T.withFastQualifiers(FastQuals);\n  }\n\n  Index -= NUM_PREDEF_TYPE_IDS;\n  assert(Index < TypesLoaded.size() && \"Type index out-of-range\");\n  if (TypesLoaded[Index].isNull()) {\n    TypesLoaded[Index] = readTypeRecord(Index);\n    if (TypesLoaded[Index].isNull())\n      return QualType();\n\n    TypesLoaded[Index]->setFromAST();\n    if (DeserializationListener)\n      DeserializationListener->TypeRead(TypeIdx::fromTypeID(ID),\n                                        TypesLoaded[Index]);\n  }\n\n  return TypesLoaded[Index].withFastQualifiers(FastQuals);\n}\n\nQualType ASTReader::getLocalType(ModuleFile &F, unsigned LocalID) {\n  return GetType(getGlobalTypeID(F, LocalID));\n}\n\nserialization::TypeID\nASTReader::getGlobalTypeID(ModuleFile &F, unsigned LocalID) const {\n  unsigned FastQuals = LocalID & Qualifiers::FastMask;\n  unsigned LocalIndex = LocalID >> Qualifiers::FastWidth;\n\n  if (LocalIndex < NUM_PREDEF_TYPE_IDS)\n    return LocalID;\n\n  if (!F.ModuleOffsetMap.empty())\n    ReadModuleOffsetMap(F);\n\n  ContinuousRangeMap<uint32_t, int, 2>::iterator I\n    = F.TypeRemap.find(LocalIndex - NUM_PREDEF_TYPE_IDS);\n  assert(I != F.TypeRemap.end() && \"Invalid index into type index remap\");\n\n  unsigned GlobalIndex = LocalIndex + I->second;\n  return (GlobalIndex << Qualifiers::FastWidth) | FastQuals;\n}\n\nTemplateArgumentLocInfo\nASTRecordReader::readTemplateArgumentLocInfo(TemplateArgument::ArgKind Kind) {\n  switch (Kind) {\n  case TemplateArgument::Expression:\n    return readExpr();\n  case TemplateArgument::Type:\n    return readTypeSourceInfo();\n  case TemplateArgument::Template: {\n    NestedNameSpecifierLoc QualifierLoc =\n      readNestedNameSpecifierLoc();\n    SourceLocation TemplateNameLoc = readSourceLocation();\n    return TemplateArgumentLocInfo(getASTContext(), QualifierLoc,\n                                   TemplateNameLoc, SourceLocation());\n  }\n  case TemplateArgument::TemplateExpansion: {\n    NestedNameSpecifierLoc QualifierLoc = readNestedNameSpecifierLoc();\n    SourceLocation TemplateNameLoc = readSourceLocation();\n    SourceLocation EllipsisLoc = readSourceLocation();\n    return TemplateArgumentLocInfo(getASTContext(), QualifierLoc,\n                                   TemplateNameLoc, EllipsisLoc);\n  }\n  case TemplateArgument::Null:\n  case TemplateArgument::Integral:\n  case TemplateArgument::Declaration:\n  case TemplateArgument::NullPtr:\n  case TemplateArgument::Pack:\n    // FIXME: Is this right?\n    return TemplateArgumentLocInfo();\n  }\n  llvm_unreachable(\"unexpected template argument loc\");\n}\n\nTemplateArgumentLoc ASTRecordReader::readTemplateArgumentLoc() {\n  TemplateArgument Arg = readTemplateArgument();\n\n  if (Arg.getKind() == TemplateArgument::Expression) {\n    if (readBool()) // bool InfoHasSameExpr.\n      return TemplateArgumentLoc(Arg, TemplateArgumentLocInfo(Arg.getAsExpr()));\n  }\n  return TemplateArgumentLoc(Arg, readTemplateArgumentLocInfo(Arg.getKind()));\n}\n\nconst ASTTemplateArgumentListInfo *\nASTRecordReader::readASTTemplateArgumentListInfo() {\n  SourceLocation LAngleLoc = readSourceLocation();\n  SourceLocation RAngleLoc = readSourceLocation();\n  unsigned NumArgsAsWritten = readInt();\n  TemplateArgumentListInfo TemplArgsInfo(LAngleLoc, RAngleLoc);\n  for (unsigned i = 0; i != NumArgsAsWritten; ++i)\n    TemplArgsInfo.addArgument(readTemplateArgumentLoc());\n  return ASTTemplateArgumentListInfo::Create(getContext(), TemplArgsInfo);\n}\n\nDecl *ASTReader::GetExternalDecl(uint32_t ID) {\n  return GetDecl(ID);\n}\n\nvoid ASTReader::CompleteRedeclChain(const Decl *D) {\n  if (NumCurrentElementsDeserializing) {\n    // We arrange to not care about the complete redeclaration chain while we're\n    // deserializing. Just remember that the AST has marked this one as complete\n    // but that it's not actually complete yet, so we know we still need to\n    // complete it later.\n    PendingIncompleteDeclChains.push_back(const_cast<Decl*>(D));\n    return;\n  }\n\n  const DeclContext *DC = D->getDeclContext()->getRedeclContext();\n\n  // If this is a named declaration, complete it by looking it up\n  // within its context.\n  //\n  // FIXME: Merging a function definition should merge\n  // all mergeable entities within it.\n  if (isa<TranslationUnitDecl>(DC) || isa<NamespaceDecl>(DC) ||\n      isa<CXXRecordDecl>(DC) || isa<EnumDecl>(DC)) {\n    if (DeclarationName Name = cast<NamedDecl>(D)->getDeclName()) {\n      if (!getContext().getLangOpts().CPlusPlus &&\n          isa<TranslationUnitDecl>(DC)) {\n        // Outside of C++, we don't have a lookup table for the TU, so update\n        // the identifier instead. (For C++ modules, we don't store decls\n        // in the serialized identifier table, so we do the lookup in the TU.)\n        auto *II = Name.getAsIdentifierInfo();\n        assert(II && \"non-identifier name in C?\");\n        if (II->isOutOfDate())\n          updateOutOfDateIdentifier(*II);\n      } else\n        DC->lookup(Name);\n    } else if (needsAnonymousDeclarationNumber(cast<NamedDecl>(D))) {\n      // Find all declarations of this kind from the relevant context.\n      for (auto *DCDecl : cast<Decl>(D->getLexicalDeclContext())->redecls()) {\n        auto *DC = cast<DeclContext>(DCDecl);\n        SmallVector<Decl*, 8> Decls;\n        FindExternalLexicalDecls(\n            DC, [&](Decl::Kind K) { return K == D->getKind(); }, Decls);\n      }\n    }\n  }\n\n  if (auto *CTSD = dyn_cast<ClassTemplateSpecializationDecl>(D))\n    CTSD->getSpecializedTemplate()->LoadLazySpecializations();\n  if (auto *VTSD = dyn_cast<VarTemplateSpecializationDecl>(D))\n    VTSD->getSpecializedTemplate()->LoadLazySpecializations();\n  if (auto *FD = dyn_cast<FunctionDecl>(D)) {\n    if (auto *Template = FD->getPrimaryTemplate())\n      Template->LoadLazySpecializations();\n  }\n}\n\nCXXCtorInitializer **\nASTReader::GetExternalCXXCtorInitializers(uint64_t Offset) {\n  RecordLocation Loc = getLocalBitOffset(Offset);\n  BitstreamCursor &Cursor = Loc.F->DeclsCursor;\n  SavedStreamPosition SavedPosition(Cursor);\n  if (llvm::Error Err = Cursor.JumpToBit(Loc.Offset)) {\n    Error(std::move(Err));\n    return nullptr;\n  }\n  ReadingKindTracker ReadingKind(Read_Decl, *this);\n\n  Expected<unsigned> MaybeCode = Cursor.ReadCode();\n  if (!MaybeCode) {\n    Error(MaybeCode.takeError());\n    return nullptr;\n  }\n  unsigned Code = MaybeCode.get();\n\n  ASTRecordReader Record(*this, *Loc.F);\n  Expected<unsigned> MaybeRecCode = Record.readRecord(Cursor, Code);\n  if (!MaybeRecCode) {\n    Error(MaybeRecCode.takeError());\n    return nullptr;\n  }\n  if (MaybeRecCode.get() != DECL_CXX_CTOR_INITIALIZERS) {\n    Error(\"malformed AST file: missing C++ ctor initializers\");\n    return nullptr;\n  }\n\n  return Record.readCXXCtorInitializers();\n}\n\nCXXBaseSpecifier *ASTReader::GetExternalCXXBaseSpecifiers(uint64_t Offset) {\n  assert(ContextObj && \"reading base specifiers with no AST context\");\n  ASTContext &Context = *ContextObj;\n\n  RecordLocation Loc = getLocalBitOffset(Offset);\n  BitstreamCursor &Cursor = Loc.F->DeclsCursor;\n  SavedStreamPosition SavedPosition(Cursor);\n  if (llvm::Error Err = Cursor.JumpToBit(Loc.Offset)) {\n    Error(std::move(Err));\n    return nullptr;\n  }\n  ReadingKindTracker ReadingKind(Read_Decl, *this);\n\n  Expected<unsigned> MaybeCode = Cursor.ReadCode();\n  if (!MaybeCode) {\n    Error(MaybeCode.takeError());\n    return nullptr;\n  }\n  unsigned Code = MaybeCode.get();\n\n  ASTRecordReader Record(*this, *Loc.F);\n  Expected<unsigned> MaybeRecCode = Record.readRecord(Cursor, Code);\n  if (!MaybeRecCode) {\n    Error(MaybeCode.takeError());\n    return nullptr;\n  }\n  unsigned RecCode = MaybeRecCode.get();\n\n  if (RecCode != DECL_CXX_BASE_SPECIFIERS) {\n    Error(\"malformed AST file: missing C++ base specifiers\");\n    return nullptr;\n  }\n\n  unsigned NumBases = Record.readInt();\n  void *Mem = Context.Allocate(sizeof(CXXBaseSpecifier) * NumBases);\n  CXXBaseSpecifier *Bases = new (Mem) CXXBaseSpecifier [NumBases];\n  for (unsigned I = 0; I != NumBases; ++I)\n    Bases[I] = Record.readCXXBaseSpecifier();\n  return Bases;\n}\n\nserialization::DeclID\nASTReader::getGlobalDeclID(ModuleFile &F, LocalDeclID LocalID) const {\n  if (LocalID < NUM_PREDEF_DECL_IDS)\n    return LocalID;\n\n  if (!F.ModuleOffsetMap.empty())\n    ReadModuleOffsetMap(F);\n\n  ContinuousRangeMap<uint32_t, int, 2>::iterator I\n    = F.DeclRemap.find(LocalID - NUM_PREDEF_DECL_IDS);\n  assert(I != F.DeclRemap.end() && \"Invalid index into decl index remap\");\n\n  return LocalID + I->second;\n}\n\nbool ASTReader::isDeclIDFromModule(serialization::GlobalDeclID ID,\n                                   ModuleFile &M) const {\n  // Predefined decls aren't from any module.\n  if (ID < NUM_PREDEF_DECL_IDS)\n    return false;\n\n  return ID - NUM_PREDEF_DECL_IDS >= M.BaseDeclID &&\n         ID - NUM_PREDEF_DECL_IDS < M.BaseDeclID + M.LocalNumDecls;\n}\n\nModuleFile *ASTReader::getOwningModuleFile(const Decl *D) {\n  if (!D->isFromASTFile())\n    return nullptr;\n  GlobalDeclMapType::const_iterator I = GlobalDeclMap.find(D->getGlobalID());\n  assert(I != GlobalDeclMap.end() && \"Corrupted global declaration map\");\n  return I->second;\n}\n\nSourceLocation ASTReader::getSourceLocationForDeclID(GlobalDeclID ID) {\n  if (ID < NUM_PREDEF_DECL_IDS)\n    return SourceLocation();\n\n  unsigned Index = ID - NUM_PREDEF_DECL_IDS;\n\n  if (Index > DeclsLoaded.size()) {\n    Error(\"declaration ID out-of-range for AST file\");\n    return SourceLocation();\n  }\n\n  if (Decl *D = DeclsLoaded[Index])\n    return D->getLocation();\n\n  SourceLocation Loc;\n  DeclCursorForID(ID, Loc);\n  return Loc;\n}\n\nstatic Decl *getPredefinedDecl(ASTContext &Context, PredefinedDeclIDs ID) {\n  switch (ID) {\n  case PREDEF_DECL_NULL_ID:\n    return nullptr;\n\n  case PREDEF_DECL_TRANSLATION_UNIT_ID:\n    return Context.getTranslationUnitDecl();\n\n  case PREDEF_DECL_OBJC_ID_ID:\n    return Context.getObjCIdDecl();\n\n  case PREDEF_DECL_OBJC_SEL_ID:\n    return Context.getObjCSelDecl();\n\n  case PREDEF_DECL_OBJC_CLASS_ID:\n    return Context.getObjCClassDecl();\n\n  case PREDEF_DECL_OBJC_PROTOCOL_ID:\n    return Context.getObjCProtocolDecl();\n\n  case PREDEF_DECL_INT_128_ID:\n    return Context.getInt128Decl();\n\n  case PREDEF_DECL_UNSIGNED_INT_128_ID:\n    return Context.getUInt128Decl();\n\n  case PREDEF_DECL_OBJC_INSTANCETYPE_ID:\n    return Context.getObjCInstanceTypeDecl();\n\n  case PREDEF_DECL_BUILTIN_VA_LIST_ID:\n    return Context.getBuiltinVaListDecl();\n\n  case PREDEF_DECL_VA_LIST_TAG:\n    return Context.getVaListTagDecl();\n\n  case PREDEF_DECL_BUILTIN_MS_VA_LIST_ID:\n    return Context.getBuiltinMSVaListDecl();\n\n  case PREDEF_DECL_BUILTIN_MS_GUID_ID:\n    return Context.getMSGuidTagDecl();\n\n  case PREDEF_DECL_EXTERN_C_CONTEXT_ID:\n    return Context.getExternCContextDecl();\n\n  case PREDEF_DECL_MAKE_INTEGER_SEQ_ID:\n    return Context.getMakeIntegerSeqDecl();\n\n  case PREDEF_DECL_CF_CONSTANT_STRING_ID:\n    return Context.getCFConstantStringDecl();\n\n  case PREDEF_DECL_CF_CONSTANT_STRING_TAG_ID:\n    return Context.getCFConstantStringTagDecl();\n\n  case PREDEF_DECL_TYPE_PACK_ELEMENT_ID:\n    return Context.getTypePackElementDecl();\n  }\n  llvm_unreachable(\"PredefinedDeclIDs unknown enum value\");\n}\n\nDecl *ASTReader::GetExistingDecl(DeclID ID) {\n  assert(ContextObj && \"reading decl with no AST context\");\n  if (ID < NUM_PREDEF_DECL_IDS) {\n    Decl *D = getPredefinedDecl(*ContextObj, (PredefinedDeclIDs)ID);\n    if (D) {\n      // Track that we have merged the declaration with ID \\p ID into the\n      // pre-existing predefined declaration \\p D.\n      auto &Merged = KeyDecls[D->getCanonicalDecl()];\n      if (Merged.empty())\n        Merged.push_back(ID);\n    }\n    return D;\n  }\n\n  unsigned Index = ID - NUM_PREDEF_DECL_IDS;\n\n  if (Index >= DeclsLoaded.size()) {\n    assert(0 && \"declaration ID out-of-range for AST file\");\n    Error(\"declaration ID out-of-range for AST file\");\n    return nullptr;\n  }\n\n  return DeclsLoaded[Index];\n}\n\nDecl *ASTReader::GetDecl(DeclID ID) {\n  if (ID < NUM_PREDEF_DECL_IDS)\n    return GetExistingDecl(ID);\n\n  unsigned Index = ID - NUM_PREDEF_DECL_IDS;\n\n  if (Index >= DeclsLoaded.size()) {\n    assert(0 && \"declaration ID out-of-range for AST file\");\n    Error(\"declaration ID out-of-range for AST file\");\n    return nullptr;\n  }\n\n  if (!DeclsLoaded[Index]) {\n    ReadDeclRecord(ID);\n    if (DeserializationListener)\n      DeserializationListener->DeclRead(ID, DeclsLoaded[Index]);\n  }\n\n  return DeclsLoaded[Index];\n}\n\nDeclID ASTReader::mapGlobalIDToModuleFileGlobalID(ModuleFile &M,\n                                                  DeclID GlobalID) {\n  if (GlobalID < NUM_PREDEF_DECL_IDS)\n    return GlobalID;\n\n  GlobalDeclMapType::const_iterator I = GlobalDeclMap.find(GlobalID);\n  assert(I != GlobalDeclMap.end() && \"Corrupted global declaration map\");\n  ModuleFile *Owner = I->second;\n\n  llvm::DenseMap<ModuleFile *, serialization::DeclID>::iterator Pos\n    = M.GlobalToLocalDeclIDs.find(Owner);\n  if (Pos == M.GlobalToLocalDeclIDs.end())\n    return 0;\n\n  return GlobalID - Owner->BaseDeclID + Pos->second;\n}\n\nserialization::DeclID ASTReader::ReadDeclID(ModuleFile &F,\n                                            const RecordData &Record,\n                                            unsigned &Idx) {\n  if (Idx >= Record.size()) {\n    Error(\"Corrupted AST file\");\n    return 0;\n  }\n\n  return getGlobalDeclID(F, Record[Idx++]);\n}\n\n/// Resolve the offset of a statement into a statement.\n///\n/// This operation will read a new statement from the external\n/// source each time it is called, and is meant to be used via a\n/// LazyOffsetPtr (which is used by Decls for the body of functions, etc).\nStmt *ASTReader::GetExternalDeclStmt(uint64_t Offset) {\n  // Switch case IDs are per Decl.\n  ClearSwitchCaseIDs();\n\n  // Offset here is a global offset across the entire chain.\n  RecordLocation Loc = getLocalBitOffset(Offset);\n  if (llvm::Error Err = Loc.F->DeclsCursor.JumpToBit(Loc.Offset)) {\n    Error(std::move(Err));\n    return nullptr;\n  }\n  assert(NumCurrentElementsDeserializing == 0 &&\n         \"should not be called while already deserializing\");\n  Deserializing D(this);\n  return ReadStmtFromStream(*Loc.F);\n}\n\nvoid ASTReader::FindExternalLexicalDecls(\n    const DeclContext *DC, llvm::function_ref<bool(Decl::Kind)> IsKindWeWant,\n    SmallVectorImpl<Decl *> &Decls) {\n  bool PredefsVisited[NUM_PREDEF_DECL_IDS] = {};\n\n  auto Visit = [&] (ModuleFile *M, LexicalContents LexicalDecls) {\n    assert(LexicalDecls.size() % 2 == 0 && \"expected an even number of entries\");\n    for (int I = 0, N = LexicalDecls.size(); I != N; I += 2) {\n      auto K = (Decl::Kind)+LexicalDecls[I];\n      if (!IsKindWeWant(K))\n        continue;\n\n      auto ID = (serialization::DeclID)+LexicalDecls[I + 1];\n\n      // Don't add predefined declarations to the lexical context more\n      // than once.\n      if (ID < NUM_PREDEF_DECL_IDS) {\n        if (PredefsVisited[ID])\n          continue;\n\n        PredefsVisited[ID] = true;\n      }\n\n      if (Decl *D = GetLocalDecl(*M, ID)) {\n        assert(D->getKind() == K && \"wrong kind for lexical decl\");\n        if (!DC->isDeclInLexicalTraversal(D))\n          Decls.push_back(D);\n      }\n    }\n  };\n\n  if (isa<TranslationUnitDecl>(DC)) {\n    for (auto Lexical : TULexicalDecls)\n      Visit(Lexical.first, Lexical.second);\n  } else {\n    auto I = LexicalDecls.find(DC);\n    if (I != LexicalDecls.end())\n      Visit(I->second.first, I->second.second);\n  }\n\n  ++NumLexicalDeclContextsRead;\n}\n\nnamespace {\n\nclass DeclIDComp {\n  ASTReader &Reader;\n  ModuleFile &Mod;\n\npublic:\n  DeclIDComp(ASTReader &Reader, ModuleFile &M) : Reader(Reader), Mod(M) {}\n\n  bool operator()(LocalDeclID L, LocalDeclID R) const {\n    SourceLocation LHS = getLocation(L);\n    SourceLocation RHS = getLocation(R);\n    return Reader.getSourceManager().isBeforeInTranslationUnit(LHS, RHS);\n  }\n\n  bool operator()(SourceLocation LHS, LocalDeclID R) const {\n    SourceLocation RHS = getLocation(R);\n    return Reader.getSourceManager().isBeforeInTranslationUnit(LHS, RHS);\n  }\n\n  bool operator()(LocalDeclID L, SourceLocation RHS) const {\n    SourceLocation LHS = getLocation(L);\n    return Reader.getSourceManager().isBeforeInTranslationUnit(LHS, RHS);\n  }\n\n  SourceLocation getLocation(LocalDeclID ID) const {\n    return Reader.getSourceManager().getFileLoc(\n            Reader.getSourceLocationForDeclID(Reader.getGlobalDeclID(Mod, ID)));\n  }\n};\n\n} // namespace\n\nvoid ASTReader::FindFileRegionDecls(FileID File,\n                                    unsigned Offset, unsigned Length,\n                                    SmallVectorImpl<Decl *> &Decls) {\n  SourceManager &SM = getSourceManager();\n\n  llvm::DenseMap<FileID, FileDeclsInfo>::iterator I = FileDeclIDs.find(File);\n  if (I == FileDeclIDs.end())\n    return;\n\n  FileDeclsInfo &DInfo = I->second;\n  if (DInfo.Decls.empty())\n    return;\n\n  SourceLocation\n    BeginLoc = SM.getLocForStartOfFile(File).getLocWithOffset(Offset);\n  SourceLocation EndLoc = BeginLoc.getLocWithOffset(Length);\n\n  DeclIDComp DIDComp(*this, *DInfo.Mod);\n  ArrayRef<serialization::LocalDeclID>::iterator BeginIt =\n      llvm::lower_bound(DInfo.Decls, BeginLoc, DIDComp);\n  if (BeginIt != DInfo.Decls.begin())\n    --BeginIt;\n\n  // If we are pointing at a top-level decl inside an objc container, we need\n  // to backtrack until we find it otherwise we will fail to report that the\n  // region overlaps with an objc container.\n  while (BeginIt != DInfo.Decls.begin() &&\n         GetDecl(getGlobalDeclID(*DInfo.Mod, *BeginIt))\n             ->isTopLevelDeclInObjCContainer())\n    --BeginIt;\n\n  ArrayRef<serialization::LocalDeclID>::iterator EndIt =\n      llvm::upper_bound(DInfo.Decls, EndLoc, DIDComp);\n  if (EndIt != DInfo.Decls.end())\n    ++EndIt;\n\n  for (ArrayRef<serialization::LocalDeclID>::iterator\n         DIt = BeginIt; DIt != EndIt; ++DIt)\n    Decls.push_back(GetDecl(getGlobalDeclID(*DInfo.Mod, *DIt)));\n}\n\nbool\nASTReader::FindExternalVisibleDeclsByName(const DeclContext *DC,\n                                          DeclarationName Name) {\n  assert(DC->hasExternalVisibleStorage() && DC == DC->getPrimaryContext() &&\n         \"DeclContext has no visible decls in storage\");\n  if (!Name)\n    return false;\n\n  auto It = Lookups.find(DC);\n  if (It == Lookups.end())\n    return false;\n\n  Deserializing LookupResults(this);\n\n  // Load the list of declarations.\n  SmallVector<NamedDecl *, 64> Decls;\n  for (DeclID ID : It->second.Table.find(Name)) {\n    NamedDecl *ND = cast<NamedDecl>(GetDecl(ID));\n    if (ND->getDeclName() == Name)\n      Decls.push_back(ND);\n  }\n\n  ++NumVisibleDeclContextsRead;\n  SetExternalVisibleDeclsForName(DC, Name, Decls);\n  return !Decls.empty();\n}\n\nvoid ASTReader::completeVisibleDeclsMap(const DeclContext *DC) {\n  if (!DC->hasExternalVisibleStorage())\n    return;\n\n  auto It = Lookups.find(DC);\n  assert(It != Lookups.end() &&\n         \"have external visible storage but no lookup tables\");\n\n  DeclsMap Decls;\n\n  for (DeclID ID : It->second.Table.findAll()) {\n    NamedDecl *ND = cast<NamedDecl>(GetDecl(ID));\n    Decls[ND->getDeclName()].push_back(ND);\n  }\n\n  ++NumVisibleDeclContextsRead;\n\n  for (DeclsMap::iterator I = Decls.begin(), E = Decls.end(); I != E; ++I) {\n    SetExternalVisibleDeclsForName(DC, I->first, I->second);\n  }\n  const_cast<DeclContext *>(DC)->setHasExternalVisibleStorage(false);\n}\n\nconst serialization::reader::DeclContextLookupTable *\nASTReader::getLoadedLookupTables(DeclContext *Primary) const {\n  auto I = Lookups.find(Primary);\n  return I == Lookups.end() ? nullptr : &I->second;\n}\n\n/// Under non-PCH compilation the consumer receives the objc methods\n/// before receiving the implementation, and codegen depends on this.\n/// We simulate this by deserializing and passing to consumer the methods of the\n/// implementation before passing the deserialized implementation decl.\nstatic void PassObjCImplDeclToConsumer(ObjCImplDecl *ImplD,\n                                       ASTConsumer *Consumer) {\n  assert(ImplD && Consumer);\n\n  for (auto *I : ImplD->methods())\n    Consumer->HandleInterestingDecl(DeclGroupRef(I));\n\n  Consumer->HandleInterestingDecl(DeclGroupRef(ImplD));\n}\n\nvoid ASTReader::PassInterestingDeclToConsumer(Decl *D) {\n  if (ObjCImplDecl *ImplD = dyn_cast<ObjCImplDecl>(D))\n    PassObjCImplDeclToConsumer(ImplD, Consumer);\n  else\n    Consumer->HandleInterestingDecl(DeclGroupRef(D));\n}\n\nvoid ASTReader::StartTranslationUnit(ASTConsumer *Consumer) {\n  this->Consumer = Consumer;\n\n  if (Consumer)\n    PassInterestingDeclsToConsumer();\n\n  if (DeserializationListener)\n    DeserializationListener->ReaderInitialized(this);\n}\n\nvoid ASTReader::PrintStats() {\n  std::fprintf(stderr, \"*** AST File Statistics:\\n\");\n\n  unsigned NumTypesLoaded\n    = TypesLoaded.size() - std::count(TypesLoaded.begin(), TypesLoaded.end(),\n                                      QualType());\n  unsigned NumDeclsLoaded\n    = DeclsLoaded.size() - std::count(DeclsLoaded.begin(), DeclsLoaded.end(),\n                                      (Decl *)nullptr);\n  unsigned NumIdentifiersLoaded\n    = IdentifiersLoaded.size() - std::count(IdentifiersLoaded.begin(),\n                                            IdentifiersLoaded.end(),\n                                            (IdentifierInfo *)nullptr);\n  unsigned NumMacrosLoaded\n    = MacrosLoaded.size() - std::count(MacrosLoaded.begin(),\n                                       MacrosLoaded.end(),\n                                       (MacroInfo *)nullptr);\n  unsigned NumSelectorsLoaded\n    = SelectorsLoaded.size() - std::count(SelectorsLoaded.begin(),\n                                          SelectorsLoaded.end(),\n                                          Selector());\n\n  if (unsigned TotalNumSLocEntries = getTotalNumSLocs())\n    std::fprintf(stderr, \"  %u/%u source location entries read (%f%%)\\n\",\n                 NumSLocEntriesRead, TotalNumSLocEntries,\n                 ((float)NumSLocEntriesRead/TotalNumSLocEntries * 100));\n  if (!TypesLoaded.empty())\n    std::fprintf(stderr, \"  %u/%u types read (%f%%)\\n\",\n                 NumTypesLoaded, (unsigned)TypesLoaded.size(),\n                 ((float)NumTypesLoaded/TypesLoaded.size() * 100));\n  if (!DeclsLoaded.empty())\n    std::fprintf(stderr, \"  %u/%u declarations read (%f%%)\\n\",\n                 NumDeclsLoaded, (unsigned)DeclsLoaded.size(),\n                 ((float)NumDeclsLoaded/DeclsLoaded.size() * 100));\n  if (!IdentifiersLoaded.empty())\n    std::fprintf(stderr, \"  %u/%u identifiers read (%f%%)\\n\",\n                 NumIdentifiersLoaded, (unsigned)IdentifiersLoaded.size(),\n                 ((float)NumIdentifiersLoaded/IdentifiersLoaded.size() * 100));\n  if (!MacrosLoaded.empty())\n    std::fprintf(stderr, \"  %u/%u macros read (%f%%)\\n\",\n                 NumMacrosLoaded, (unsigned)MacrosLoaded.size(),\n                 ((float)NumMacrosLoaded/MacrosLoaded.size() * 100));\n  if (!SelectorsLoaded.empty())\n    std::fprintf(stderr, \"  %u/%u selectors read (%f%%)\\n\",\n                 NumSelectorsLoaded, (unsigned)SelectorsLoaded.size(),\n                 ((float)NumSelectorsLoaded/SelectorsLoaded.size() * 100));\n  if (TotalNumStatements)\n    std::fprintf(stderr, \"  %u/%u statements read (%f%%)\\n\",\n                 NumStatementsRead, TotalNumStatements,\n                 ((float)NumStatementsRead/TotalNumStatements * 100));\n  if (TotalNumMacros)\n    std::fprintf(stderr, \"  %u/%u macros read (%f%%)\\n\",\n                 NumMacrosRead, TotalNumMacros,\n                 ((float)NumMacrosRead/TotalNumMacros * 100));\n  if (TotalLexicalDeclContexts)\n    std::fprintf(stderr, \"  %u/%u lexical declcontexts read (%f%%)\\n\",\n                 NumLexicalDeclContextsRead, TotalLexicalDeclContexts,\n                 ((float)NumLexicalDeclContextsRead/TotalLexicalDeclContexts\n                  * 100));\n  if (TotalVisibleDeclContexts)\n    std::fprintf(stderr, \"  %u/%u visible declcontexts read (%f%%)\\n\",\n                 NumVisibleDeclContextsRead, TotalVisibleDeclContexts,\n                 ((float)NumVisibleDeclContextsRead/TotalVisibleDeclContexts\n                  * 100));\n  if (TotalNumMethodPoolEntries)\n    std::fprintf(stderr, \"  %u/%u method pool entries read (%f%%)\\n\",\n                 NumMethodPoolEntriesRead, TotalNumMethodPoolEntries,\n                 ((float)NumMethodPoolEntriesRead/TotalNumMethodPoolEntries\n                  * 100));\n  if (NumMethodPoolLookups)\n    std::fprintf(stderr, \"  %u/%u method pool lookups succeeded (%f%%)\\n\",\n                 NumMethodPoolHits, NumMethodPoolLookups,\n                 ((float)NumMethodPoolHits/NumMethodPoolLookups * 100.0));\n  if (NumMethodPoolTableLookups)\n    std::fprintf(stderr, \"  %u/%u method pool table lookups succeeded (%f%%)\\n\",\n                 NumMethodPoolTableHits, NumMethodPoolTableLookups,\n                 ((float)NumMethodPoolTableHits/NumMethodPoolTableLookups\n                  * 100.0));\n  if (NumIdentifierLookupHits)\n    std::fprintf(stderr,\n                 \"  %u / %u identifier table lookups succeeded (%f%%)\\n\",\n                 NumIdentifierLookupHits, NumIdentifierLookups,\n                 (double)NumIdentifierLookupHits*100.0/NumIdentifierLookups);\n\n  if (GlobalIndex) {\n    std::fprintf(stderr, \"\\n\");\n    GlobalIndex->printStats();\n  }\n\n  std::fprintf(stderr, \"\\n\");\n  dump();\n  std::fprintf(stderr, \"\\n\");\n}\n\ntemplate<typename Key, typename ModuleFile, unsigned InitialCapacity>\nLLVM_DUMP_METHOD static void\ndumpModuleIDMap(StringRef Name,\n                const ContinuousRangeMap<Key, ModuleFile *,\n                                         InitialCapacity> &Map) {\n  if (Map.begin() == Map.end())\n    return;\n\n  using MapType = ContinuousRangeMap<Key, ModuleFile *, InitialCapacity>;\n\n  llvm::errs() << Name << \":\\n\";\n  for (typename MapType::const_iterator I = Map.begin(), IEnd = Map.end();\n       I != IEnd; ++I) {\n    llvm::errs() << \"  \" << I->first << \" -> \" << I->second->FileName\n      << \"\\n\";\n  }\n}\n\nLLVM_DUMP_METHOD void ASTReader::dump() {\n  llvm::errs() << \"*** PCH/ModuleFile Remappings:\\n\";\n  dumpModuleIDMap(\"Global bit offset map\", GlobalBitOffsetsMap);\n  dumpModuleIDMap(\"Global source location entry map\", GlobalSLocEntryMap);\n  dumpModuleIDMap(\"Global type map\", GlobalTypeMap);\n  dumpModuleIDMap(\"Global declaration map\", GlobalDeclMap);\n  dumpModuleIDMap(\"Global identifier map\", GlobalIdentifierMap);\n  dumpModuleIDMap(\"Global macro map\", GlobalMacroMap);\n  dumpModuleIDMap(\"Global submodule map\", GlobalSubmoduleMap);\n  dumpModuleIDMap(\"Global selector map\", GlobalSelectorMap);\n  dumpModuleIDMap(\"Global preprocessed entity map\",\n                  GlobalPreprocessedEntityMap);\n\n  llvm::errs() << \"\\n*** PCH/Modules Loaded:\";\n  for (ModuleFile &M : ModuleMgr)\n    M.dump();\n}\n\n/// Return the amount of memory used by memory buffers, breaking down\n/// by heap-backed versus mmap'ed memory.\nvoid ASTReader::getMemoryBufferSizes(MemoryBufferSizes &sizes) const {\n  for (ModuleFile &I : ModuleMgr) {\n    if (llvm::MemoryBuffer *buf = I.Buffer) {\n      size_t bytes = buf->getBufferSize();\n      switch (buf->getBufferKind()) {\n        case llvm::MemoryBuffer::MemoryBuffer_Malloc:\n          sizes.malloc_bytes += bytes;\n          break;\n        case llvm::MemoryBuffer::MemoryBuffer_MMap:\n          sizes.mmap_bytes += bytes;\n          break;\n      }\n    }\n  }\n}\n\nvoid ASTReader::InitializeSema(Sema &S) {\n  SemaObj = &S;\n  S.addExternalSource(this);\n\n  // Makes sure any declarations that were deserialized \"too early\"\n  // still get added to the identifier's declaration chains.\n  for (uint64_t ID : PreloadedDeclIDs) {\n    NamedDecl *D = cast<NamedDecl>(GetDecl(ID));\n    pushExternalDeclIntoScope(D, D->getDeclName());\n  }\n  PreloadedDeclIDs.clear();\n\n  // FIXME: What happens if these are changed by a module import?\n  if (!FPPragmaOptions.empty()) {\n    assert(FPPragmaOptions.size() == 1 && \"Wrong number of FP_PRAGMA_OPTIONS\");\n    FPOptionsOverride NewOverrides =\n        FPOptionsOverride::getFromOpaqueInt(FPPragmaOptions[0]);\n    SemaObj->CurFPFeatures =\n        NewOverrides.applyOverrides(SemaObj->getLangOpts());\n  }\n\n  SemaObj->OpenCLFeatures = OpenCLExtensions;\n  SemaObj->OpenCLTypeExtMap = OpenCLTypeExtMap;\n  SemaObj->OpenCLDeclExtMap = OpenCLDeclExtMap;\n\n  UpdateSema();\n}\n\nvoid ASTReader::UpdateSema() {\n  assert(SemaObj && \"no Sema to update\");\n\n  // Load the offsets of the declarations that Sema references.\n  // They will be lazily deserialized when needed.\n  if (!SemaDeclRefs.empty()) {\n    assert(SemaDeclRefs.size() % 3 == 0);\n    for (unsigned I = 0; I != SemaDeclRefs.size(); I += 3) {\n      if (!SemaObj->StdNamespace)\n        SemaObj->StdNamespace = SemaDeclRefs[I];\n      if (!SemaObj->StdBadAlloc)\n        SemaObj->StdBadAlloc = SemaDeclRefs[I+1];\n      if (!SemaObj->StdAlignValT)\n        SemaObj->StdAlignValT = SemaDeclRefs[I+2];\n    }\n    SemaDeclRefs.clear();\n  }\n\n  // Update the state of pragmas. Use the same API as if we had encountered the\n  // pragma in the source.\n  if(OptimizeOffPragmaLocation.isValid())\n    SemaObj->ActOnPragmaOptimize(/* On = */ false, OptimizeOffPragmaLocation);\n  if (PragmaMSStructState != -1)\n    SemaObj->ActOnPragmaMSStruct((PragmaMSStructKind)PragmaMSStructState);\n  if (PointersToMembersPragmaLocation.isValid()) {\n    SemaObj->ActOnPragmaMSPointersToMembers(\n        (LangOptions::PragmaMSPointersToMembersKind)\n            PragmaMSPointersToMembersState,\n        PointersToMembersPragmaLocation);\n  }\n  SemaObj->ForceCUDAHostDeviceDepth = ForceCUDAHostDeviceDepth;\n\n  if (PragmaAlignPackCurrentValue) {\n    // The bottom of the stack might have a default value. It must be adjusted\n    // to the current value to ensure that the packing state is preserved after\n    // popping entries that were included/imported from a PCH/module.\n    bool DropFirst = false;\n    if (!PragmaAlignPackStack.empty() &&\n        PragmaAlignPackStack.front().Location.isInvalid()) {\n      assert(PragmaAlignPackStack.front().Value ==\n                 SemaObj->AlignPackStack.DefaultValue &&\n             \"Expected a default alignment value\");\n      SemaObj->AlignPackStack.Stack.emplace_back(\n          PragmaAlignPackStack.front().SlotLabel,\n          SemaObj->AlignPackStack.CurrentValue,\n          SemaObj->AlignPackStack.CurrentPragmaLocation,\n          PragmaAlignPackStack.front().PushLocation);\n      DropFirst = true;\n    }\n    for (const auto &Entry : llvm::makeArrayRef(PragmaAlignPackStack)\n                                 .drop_front(DropFirst ? 1 : 0)) {\n      SemaObj->AlignPackStack.Stack.emplace_back(\n          Entry.SlotLabel, Entry.Value, Entry.Location, Entry.PushLocation);\n    }\n    if (PragmaAlignPackCurrentLocation.isInvalid()) {\n      assert(*PragmaAlignPackCurrentValue ==\n                 SemaObj->AlignPackStack.DefaultValue &&\n             \"Expected a default align and pack value\");\n      // Keep the current values.\n    } else {\n      SemaObj->AlignPackStack.CurrentValue = *PragmaAlignPackCurrentValue;\n      SemaObj->AlignPackStack.CurrentPragmaLocation =\n          PragmaAlignPackCurrentLocation;\n    }\n  }\n  if (FpPragmaCurrentValue) {\n    // The bottom of the stack might have a default value. It must be adjusted\n    // to the current value to ensure that fp-pragma state is preserved after\n    // popping entries that were included/imported from a PCH/module.\n    bool DropFirst = false;\n    if (!FpPragmaStack.empty() && FpPragmaStack.front().Location.isInvalid()) {\n      assert(FpPragmaStack.front().Value ==\n                 SemaObj->FpPragmaStack.DefaultValue &&\n             \"Expected a default pragma float_control value\");\n      SemaObj->FpPragmaStack.Stack.emplace_back(\n          FpPragmaStack.front().SlotLabel, SemaObj->FpPragmaStack.CurrentValue,\n          SemaObj->FpPragmaStack.CurrentPragmaLocation,\n          FpPragmaStack.front().PushLocation);\n      DropFirst = true;\n    }\n    for (const auto &Entry :\n         llvm::makeArrayRef(FpPragmaStack).drop_front(DropFirst ? 1 : 0))\n      SemaObj->FpPragmaStack.Stack.emplace_back(\n          Entry.SlotLabel, Entry.Value, Entry.Location, Entry.PushLocation);\n    if (FpPragmaCurrentLocation.isInvalid()) {\n      assert(*FpPragmaCurrentValue == SemaObj->FpPragmaStack.DefaultValue &&\n             \"Expected a default pragma float_control value\");\n      // Keep the current values.\n    } else {\n      SemaObj->FpPragmaStack.CurrentValue = *FpPragmaCurrentValue;\n      SemaObj->FpPragmaStack.CurrentPragmaLocation = FpPragmaCurrentLocation;\n    }\n  }\n\n  // For non-modular AST files, restore visiblity of modules.\n  for (auto &Import : ImportedModules) {\n    if (Import.ImportLoc.isInvalid())\n      continue;\n    if (Module *Imported = getSubmodule(Import.ID)) {\n      SemaObj->makeModuleVisible(Imported, Import.ImportLoc);\n    }\n  }\n}\n\nIdentifierInfo *ASTReader::get(StringRef Name) {\n  // Note that we are loading an identifier.\n  Deserializing AnIdentifier(this);\n\n  IdentifierLookupVisitor Visitor(Name, /*PriorGeneration=*/0,\n                                  NumIdentifierLookups,\n                                  NumIdentifierLookupHits);\n\n  // We don't need to do identifier table lookups in C++ modules (we preload\n  // all interesting declarations, and don't need to use the scope for name\n  // lookups). Perform the lookup in PCH files, though, since we don't build\n  // a complete initial identifier table if we're carrying on from a PCH.\n  if (PP.getLangOpts().CPlusPlus) {\n    for (auto F : ModuleMgr.pch_modules())\n      if (Visitor(*F))\n        break;\n  } else {\n    // If there is a global index, look there first to determine which modules\n    // provably do not have any results for this identifier.\n    GlobalModuleIndex::HitSet Hits;\n    GlobalModuleIndex::HitSet *HitsPtr = nullptr;\n    if (!loadGlobalIndex()) {\n      if (GlobalIndex->lookupIdentifier(Name, Hits)) {\n        HitsPtr = &Hits;\n      }\n    }\n\n    ModuleMgr.visit(Visitor, HitsPtr);\n  }\n\n  IdentifierInfo *II = Visitor.getIdentifierInfo();\n  markIdentifierUpToDate(II);\n  return II;\n}\n\nnamespace clang {\n\n  /// An identifier-lookup iterator that enumerates all of the\n  /// identifiers stored within a set of AST files.\n  class ASTIdentifierIterator : public IdentifierIterator {\n    /// The AST reader whose identifiers are being enumerated.\n    const ASTReader &Reader;\n\n    /// The current index into the chain of AST files stored in\n    /// the AST reader.\n    unsigned Index;\n\n    /// The current position within the identifier lookup table\n    /// of the current AST file.\n    ASTIdentifierLookupTable::key_iterator Current;\n\n    /// The end position within the identifier lookup table of\n    /// the current AST file.\n    ASTIdentifierLookupTable::key_iterator End;\n\n    /// Whether to skip any modules in the ASTReader.\n    bool SkipModules;\n\n  public:\n    explicit ASTIdentifierIterator(const ASTReader &Reader,\n                                   bool SkipModules = false);\n\n    StringRef Next() override;\n  };\n\n} // namespace clang\n\nASTIdentifierIterator::ASTIdentifierIterator(const ASTReader &Reader,\n                                             bool SkipModules)\n    : Reader(Reader), Index(Reader.ModuleMgr.size()), SkipModules(SkipModules) {\n}\n\nStringRef ASTIdentifierIterator::Next() {\n  while (Current == End) {\n    // If we have exhausted all of our AST files, we're done.\n    if (Index == 0)\n      return StringRef();\n\n    --Index;\n    ModuleFile &F = Reader.ModuleMgr[Index];\n    if (SkipModules && F.isModule())\n      continue;\n\n    ASTIdentifierLookupTable *IdTable =\n        (ASTIdentifierLookupTable *)F.IdentifierLookupTable;\n    Current = IdTable->key_begin();\n    End = IdTable->key_end();\n  }\n\n  // We have any identifiers remaining in the current AST file; return\n  // the next one.\n  StringRef Result = *Current;\n  ++Current;\n  return Result;\n}\n\nnamespace {\n\n/// A utility for appending two IdentifierIterators.\nclass ChainedIdentifierIterator : public IdentifierIterator {\n  std::unique_ptr<IdentifierIterator> Current;\n  std::unique_ptr<IdentifierIterator> Queued;\n\npublic:\n  ChainedIdentifierIterator(std::unique_ptr<IdentifierIterator> First,\n                            std::unique_ptr<IdentifierIterator> Second)\n      : Current(std::move(First)), Queued(std::move(Second)) {}\n\n  StringRef Next() override {\n    if (!Current)\n      return StringRef();\n\n    StringRef result = Current->Next();\n    if (!result.empty())\n      return result;\n\n    // Try the queued iterator, which may itself be empty.\n    Current.reset();\n    std::swap(Current, Queued);\n    return Next();\n  }\n};\n\n} // namespace\n\nIdentifierIterator *ASTReader::getIdentifiers() {\n  if (!loadGlobalIndex()) {\n    std::unique_ptr<IdentifierIterator> ReaderIter(\n        new ASTIdentifierIterator(*this, /*SkipModules=*/true));\n    std::unique_ptr<IdentifierIterator> ModulesIter(\n        GlobalIndex->createIdentifierIterator());\n    return new ChainedIdentifierIterator(std::move(ReaderIter),\n                                         std::move(ModulesIter));\n  }\n\n  return new ASTIdentifierIterator(*this);\n}\n\nnamespace clang {\nnamespace serialization {\n\n  class ReadMethodPoolVisitor {\n    ASTReader &Reader;\n    Selector Sel;\n    unsigned PriorGeneration;\n    unsigned InstanceBits = 0;\n    unsigned FactoryBits = 0;\n    bool InstanceHasMoreThanOneDecl = false;\n    bool FactoryHasMoreThanOneDecl = false;\n    SmallVector<ObjCMethodDecl *, 4> InstanceMethods;\n    SmallVector<ObjCMethodDecl *, 4> FactoryMethods;\n\n  public:\n    ReadMethodPoolVisitor(ASTReader &Reader, Selector Sel,\n                          unsigned PriorGeneration)\n        : Reader(Reader), Sel(Sel), PriorGeneration(PriorGeneration) {}\n\n    bool operator()(ModuleFile &M) {\n      if (!M.SelectorLookupTable)\n        return false;\n\n      // If we've already searched this module file, skip it now.\n      if (M.Generation <= PriorGeneration)\n        return true;\n\n      ++Reader.NumMethodPoolTableLookups;\n      ASTSelectorLookupTable *PoolTable\n        = (ASTSelectorLookupTable*)M.SelectorLookupTable;\n      ASTSelectorLookupTable::iterator Pos = PoolTable->find(Sel);\n      if (Pos == PoolTable->end())\n        return false;\n\n      ++Reader.NumMethodPoolTableHits;\n      ++Reader.NumSelectorsRead;\n      // FIXME: Not quite happy with the statistics here. We probably should\n      // disable this tracking when called via LoadSelector.\n      // Also, should entries without methods count as misses?\n      ++Reader.NumMethodPoolEntriesRead;\n      ASTSelectorLookupTrait::data_type Data = *Pos;\n      if (Reader.DeserializationListener)\n        Reader.DeserializationListener->SelectorRead(Data.ID, Sel);\n\n      InstanceMethods.append(Data.Instance.begin(), Data.Instance.end());\n      FactoryMethods.append(Data.Factory.begin(), Data.Factory.end());\n      InstanceBits = Data.InstanceBits;\n      FactoryBits = Data.FactoryBits;\n      InstanceHasMoreThanOneDecl = Data.InstanceHasMoreThanOneDecl;\n      FactoryHasMoreThanOneDecl = Data.FactoryHasMoreThanOneDecl;\n      return true;\n    }\n\n    /// Retrieve the instance methods found by this visitor.\n    ArrayRef<ObjCMethodDecl *> getInstanceMethods() const {\n      return InstanceMethods;\n    }\n\n    /// Retrieve the instance methods found by this visitor.\n    ArrayRef<ObjCMethodDecl *> getFactoryMethods() const {\n      return FactoryMethods;\n    }\n\n    unsigned getInstanceBits() const { return InstanceBits; }\n    unsigned getFactoryBits() const { return FactoryBits; }\n\n    bool instanceHasMoreThanOneDecl() const {\n      return InstanceHasMoreThanOneDecl;\n    }\n\n    bool factoryHasMoreThanOneDecl() const { return FactoryHasMoreThanOneDecl; }\n  };\n\n} // namespace serialization\n} // namespace clang\n\n/// Add the given set of methods to the method list.\nstatic void addMethodsToPool(Sema &S, ArrayRef<ObjCMethodDecl *> Methods,\n                             ObjCMethodList &List) {\n  for (unsigned I = 0, N = Methods.size(); I != N; ++I) {\n    S.addMethodToGlobalList(&List, Methods[I]);\n  }\n}\n\nvoid ASTReader::ReadMethodPool(Selector Sel) {\n  // Get the selector generation and update it to the current generation.\n  unsigned &Generation = SelectorGeneration[Sel];\n  unsigned PriorGeneration = Generation;\n  Generation = getGeneration();\n  SelectorOutOfDate[Sel] = false;\n\n  // Search for methods defined with this selector.\n  ++NumMethodPoolLookups;\n  ReadMethodPoolVisitor Visitor(*this, Sel, PriorGeneration);\n  ModuleMgr.visit(Visitor);\n\n  if (Visitor.getInstanceMethods().empty() &&\n      Visitor.getFactoryMethods().empty())\n    return;\n\n  ++NumMethodPoolHits;\n\n  if (!getSema())\n    return;\n\n  Sema &S = *getSema();\n  Sema::GlobalMethodPool::iterator Pos\n    = S.MethodPool.insert(std::make_pair(Sel, Sema::GlobalMethods())).first;\n\n  Pos->second.first.setBits(Visitor.getInstanceBits());\n  Pos->second.first.setHasMoreThanOneDecl(Visitor.instanceHasMoreThanOneDecl());\n  Pos->second.second.setBits(Visitor.getFactoryBits());\n  Pos->second.second.setHasMoreThanOneDecl(Visitor.factoryHasMoreThanOneDecl());\n\n  // Add methods to the global pool *after* setting hasMoreThanOneDecl, since\n  // when building a module we keep every method individually and may need to\n  // update hasMoreThanOneDecl as we add the methods.\n  addMethodsToPool(S, Visitor.getInstanceMethods(), Pos->second.first);\n  addMethodsToPool(S, Visitor.getFactoryMethods(), Pos->second.second);\n}\n\nvoid ASTReader::updateOutOfDateSelector(Selector Sel) {\n  if (SelectorOutOfDate[Sel])\n    ReadMethodPool(Sel);\n}\n\nvoid ASTReader::ReadKnownNamespaces(\n                          SmallVectorImpl<NamespaceDecl *> &Namespaces) {\n  Namespaces.clear();\n\n  for (unsigned I = 0, N = KnownNamespaces.size(); I != N; ++I) {\n    if (NamespaceDecl *Namespace\n                = dyn_cast_or_null<NamespaceDecl>(GetDecl(KnownNamespaces[I])))\n      Namespaces.push_back(Namespace);\n  }\n}\n\nvoid ASTReader::ReadUndefinedButUsed(\n    llvm::MapVector<NamedDecl *, SourceLocation> &Undefined) {\n  for (unsigned Idx = 0, N = UndefinedButUsed.size(); Idx != N;) {\n    NamedDecl *D = cast<NamedDecl>(GetDecl(UndefinedButUsed[Idx++]));\n    SourceLocation Loc =\n        SourceLocation::getFromRawEncoding(UndefinedButUsed[Idx++]);\n    Undefined.insert(std::make_pair(D, Loc));\n  }\n}\n\nvoid ASTReader::ReadMismatchingDeleteExpressions(llvm::MapVector<\n    FieldDecl *, llvm::SmallVector<std::pair<SourceLocation, bool>, 4>> &\n                                                     Exprs) {\n  for (unsigned Idx = 0, N = DelayedDeleteExprs.size(); Idx != N;) {\n    FieldDecl *FD = cast<FieldDecl>(GetDecl(DelayedDeleteExprs[Idx++]));\n    uint64_t Count = DelayedDeleteExprs[Idx++];\n    for (uint64_t C = 0; C < Count; ++C) {\n      SourceLocation DeleteLoc =\n          SourceLocation::getFromRawEncoding(DelayedDeleteExprs[Idx++]);\n      const bool IsArrayForm = DelayedDeleteExprs[Idx++];\n      Exprs[FD].push_back(std::make_pair(DeleteLoc, IsArrayForm));\n    }\n  }\n}\n\nvoid ASTReader::ReadTentativeDefinitions(\n                  SmallVectorImpl<VarDecl *> &TentativeDefs) {\n  for (unsigned I = 0, N = TentativeDefinitions.size(); I != N; ++I) {\n    VarDecl *Var = dyn_cast_or_null<VarDecl>(GetDecl(TentativeDefinitions[I]));\n    if (Var)\n      TentativeDefs.push_back(Var);\n  }\n  TentativeDefinitions.clear();\n}\n\nvoid ASTReader::ReadUnusedFileScopedDecls(\n                               SmallVectorImpl<const DeclaratorDecl *> &Decls) {\n  for (unsigned I = 0, N = UnusedFileScopedDecls.size(); I != N; ++I) {\n    DeclaratorDecl *D\n      = dyn_cast_or_null<DeclaratorDecl>(GetDecl(UnusedFileScopedDecls[I]));\n    if (D)\n      Decls.push_back(D);\n  }\n  UnusedFileScopedDecls.clear();\n}\n\nvoid ASTReader::ReadDelegatingConstructors(\n                                 SmallVectorImpl<CXXConstructorDecl *> &Decls) {\n  for (unsigned I = 0, N = DelegatingCtorDecls.size(); I != N; ++I) {\n    CXXConstructorDecl *D\n      = dyn_cast_or_null<CXXConstructorDecl>(GetDecl(DelegatingCtorDecls[I]));\n    if (D)\n      Decls.push_back(D);\n  }\n  DelegatingCtorDecls.clear();\n}\n\nvoid ASTReader::ReadExtVectorDecls(SmallVectorImpl<TypedefNameDecl *> &Decls) {\n  for (unsigned I = 0, N = ExtVectorDecls.size(); I != N; ++I) {\n    TypedefNameDecl *D\n      = dyn_cast_or_null<TypedefNameDecl>(GetDecl(ExtVectorDecls[I]));\n    if (D)\n      Decls.push_back(D);\n  }\n  ExtVectorDecls.clear();\n}\n\nvoid ASTReader::ReadUnusedLocalTypedefNameCandidates(\n    llvm::SmallSetVector<const TypedefNameDecl *, 4> &Decls) {\n  for (unsigned I = 0, N = UnusedLocalTypedefNameCandidates.size(); I != N;\n       ++I) {\n    TypedefNameDecl *D = dyn_cast_or_null<TypedefNameDecl>(\n        GetDecl(UnusedLocalTypedefNameCandidates[I]));\n    if (D)\n      Decls.insert(D);\n  }\n  UnusedLocalTypedefNameCandidates.clear();\n}\n\nvoid ASTReader::ReadDeclsToCheckForDeferredDiags(\n    llvm::SmallVector<Decl *, 4> &Decls) {\n  for (unsigned I = 0, N = DeclsToCheckForDeferredDiags.size(); I != N;\n       ++I) {\n    auto *D = dyn_cast_or_null<Decl>(\n        GetDecl(DeclsToCheckForDeferredDiags[I]));\n    if (D)\n      Decls.push_back(D);\n  }\n  DeclsToCheckForDeferredDiags.clear();\n}\n\n\nvoid ASTReader::ReadReferencedSelectors(\n       SmallVectorImpl<std::pair<Selector, SourceLocation>> &Sels) {\n  if (ReferencedSelectorsData.empty())\n    return;\n\n  // If there are @selector references added them to its pool. This is for\n  // implementation of -Wselector.\n  unsigned int DataSize = ReferencedSelectorsData.size()-1;\n  unsigned I = 0;\n  while (I < DataSize) {\n    Selector Sel = DecodeSelector(ReferencedSelectorsData[I++]);\n    SourceLocation SelLoc\n      = SourceLocation::getFromRawEncoding(ReferencedSelectorsData[I++]);\n    Sels.push_back(std::make_pair(Sel, SelLoc));\n  }\n  ReferencedSelectorsData.clear();\n}\n\nvoid ASTReader::ReadWeakUndeclaredIdentifiers(\n       SmallVectorImpl<std::pair<IdentifierInfo *, WeakInfo>> &WeakIDs) {\n  if (WeakUndeclaredIdentifiers.empty())\n    return;\n\n  for (unsigned I = 0, N = WeakUndeclaredIdentifiers.size(); I < N; /*none*/) {\n    IdentifierInfo *WeakId\n      = DecodeIdentifierInfo(WeakUndeclaredIdentifiers[I++]);\n    IdentifierInfo *AliasId\n      = DecodeIdentifierInfo(WeakUndeclaredIdentifiers[I++]);\n    SourceLocation Loc\n      = SourceLocation::getFromRawEncoding(WeakUndeclaredIdentifiers[I++]);\n    bool Used = WeakUndeclaredIdentifiers[I++];\n    WeakInfo WI(AliasId, Loc);\n    WI.setUsed(Used);\n    WeakIDs.push_back(std::make_pair(WeakId, WI));\n  }\n  WeakUndeclaredIdentifiers.clear();\n}\n\nvoid ASTReader::ReadUsedVTables(SmallVectorImpl<ExternalVTableUse> &VTables) {\n  for (unsigned Idx = 0, N = VTableUses.size(); Idx < N; /* In loop */) {\n    ExternalVTableUse VT;\n    VT.Record = dyn_cast_or_null<CXXRecordDecl>(GetDecl(VTableUses[Idx++]));\n    VT.Location = SourceLocation::getFromRawEncoding(VTableUses[Idx++]);\n    VT.DefinitionRequired = VTableUses[Idx++];\n    VTables.push_back(VT);\n  }\n\n  VTableUses.clear();\n}\n\nvoid ASTReader::ReadPendingInstantiations(\n       SmallVectorImpl<std::pair<ValueDecl *, SourceLocation>> &Pending) {\n  for (unsigned Idx = 0, N = PendingInstantiations.size(); Idx < N;) {\n    ValueDecl *D = cast<ValueDecl>(GetDecl(PendingInstantiations[Idx++]));\n    SourceLocation Loc\n      = SourceLocation::getFromRawEncoding(PendingInstantiations[Idx++]);\n\n    Pending.push_back(std::make_pair(D, Loc));\n  }\n  PendingInstantiations.clear();\n}\n\nvoid ASTReader::ReadLateParsedTemplates(\n    llvm::MapVector<const FunctionDecl *, std::unique_ptr<LateParsedTemplate>>\n        &LPTMap) {\n  for (auto &LPT : LateParsedTemplates) {\n    ModuleFile *FMod = LPT.first;\n    RecordDataImpl &LateParsed = LPT.second;\n    for (unsigned Idx = 0, N = LateParsed.size(); Idx < N;\n         /* In loop */) {\n      FunctionDecl *FD =\n          cast<FunctionDecl>(GetLocalDecl(*FMod, LateParsed[Idx++]));\n\n      auto LT = std::make_unique<LateParsedTemplate>();\n      LT->D = GetLocalDecl(*FMod, LateParsed[Idx++]);\n\n      ModuleFile *F = getOwningModuleFile(LT->D);\n      assert(F && \"No module\");\n\n      unsigned TokN = LateParsed[Idx++];\n      LT->Toks.reserve(TokN);\n      for (unsigned T = 0; T < TokN; ++T)\n        LT->Toks.push_back(ReadToken(*F, LateParsed, Idx));\n\n      LPTMap.insert(std::make_pair(FD, std::move(LT)));\n    }\n  }\n}\n\nvoid ASTReader::LoadSelector(Selector Sel) {\n  // It would be complicated to avoid reading the methods anyway. So don't.\n  ReadMethodPool(Sel);\n}\n\nvoid ASTReader::SetIdentifierInfo(IdentifierID ID, IdentifierInfo *II) {\n  assert(ID && \"Non-zero identifier ID required\");\n  assert(ID <= IdentifiersLoaded.size() && \"identifier ID out of range\");\n  IdentifiersLoaded[ID - 1] = II;\n  if (DeserializationListener)\n    DeserializationListener->IdentifierRead(ID, II);\n}\n\n/// Set the globally-visible declarations associated with the given\n/// identifier.\n///\n/// If the AST reader is currently in a state where the given declaration IDs\n/// cannot safely be resolved, they are queued until it is safe to resolve\n/// them.\n///\n/// \\param II an IdentifierInfo that refers to one or more globally-visible\n/// declarations.\n///\n/// \\param DeclIDs the set of declaration IDs with the name @p II that are\n/// visible at global scope.\n///\n/// \\param Decls if non-null, this vector will be populated with the set of\n/// deserialized declarations. These declarations will not be pushed into\n/// scope.\nvoid\nASTReader::SetGloballyVisibleDecls(IdentifierInfo *II,\n                              const SmallVectorImpl<uint32_t> &DeclIDs,\n                                   SmallVectorImpl<Decl *> *Decls) {\n  if (NumCurrentElementsDeserializing && !Decls) {\n    PendingIdentifierInfos[II].append(DeclIDs.begin(), DeclIDs.end());\n    return;\n  }\n\n  for (unsigned I = 0, N = DeclIDs.size(); I != N; ++I) {\n    if (!SemaObj) {\n      // Queue this declaration so that it will be added to the\n      // translation unit scope and identifier's declaration chain\n      // once a Sema object is known.\n      PreloadedDeclIDs.push_back(DeclIDs[I]);\n      continue;\n    }\n\n    NamedDecl *D = cast<NamedDecl>(GetDecl(DeclIDs[I]));\n\n    // If we're simply supposed to record the declarations, do so now.\n    if (Decls) {\n      Decls->push_back(D);\n      continue;\n    }\n\n    // Introduce this declaration into the translation-unit scope\n    // and add it to the declaration chain for this identifier, so\n    // that (unqualified) name lookup will find it.\n    pushExternalDeclIntoScope(D, II);\n  }\n}\n\nIdentifierInfo *ASTReader::DecodeIdentifierInfo(IdentifierID ID) {\n  if (ID == 0)\n    return nullptr;\n\n  if (IdentifiersLoaded.empty()) {\n    Error(\"no identifier table in AST file\");\n    return nullptr;\n  }\n\n  ID -= 1;\n  if (!IdentifiersLoaded[ID]) {\n    GlobalIdentifierMapType::iterator I = GlobalIdentifierMap.find(ID + 1);\n    assert(I != GlobalIdentifierMap.end() && \"Corrupted global identifier map\");\n    ModuleFile *M = I->second;\n    unsigned Index = ID - M->BaseIdentifierID;\n    const char *Str = M->IdentifierTableData + M->IdentifierOffsets[Index];\n\n    // All of the strings in the AST file are preceded by a 16-bit length.\n    // Extract that 16-bit length to avoid having to execute strlen().\n    // NOTE: 'StrLenPtr' is an 'unsigned char*' so that we load bytes as\n    //  unsigned integers.  This is important to avoid integer overflow when\n    //  we cast them to 'unsigned'.\n    const unsigned char *StrLenPtr = (const unsigned char*) Str - 2;\n    unsigned StrLen = (((unsigned) StrLenPtr[0])\n                       | (((unsigned) StrLenPtr[1]) << 8)) - 1;\n    auto &II = PP.getIdentifierTable().get(StringRef(Str, StrLen));\n    IdentifiersLoaded[ID] = &II;\n    markIdentifierFromAST(*this,  II);\n    if (DeserializationListener)\n      DeserializationListener->IdentifierRead(ID + 1, &II);\n  }\n\n  return IdentifiersLoaded[ID];\n}\n\nIdentifierInfo *ASTReader::getLocalIdentifier(ModuleFile &M, unsigned LocalID) {\n  return DecodeIdentifierInfo(getGlobalIdentifierID(M, LocalID));\n}\n\nIdentifierID ASTReader::getGlobalIdentifierID(ModuleFile &M, unsigned LocalID) {\n  if (LocalID < NUM_PREDEF_IDENT_IDS)\n    return LocalID;\n\n  if (!M.ModuleOffsetMap.empty())\n    ReadModuleOffsetMap(M);\n\n  ContinuousRangeMap<uint32_t, int, 2>::iterator I\n    = M.IdentifierRemap.find(LocalID - NUM_PREDEF_IDENT_IDS);\n  assert(I != M.IdentifierRemap.end()\n         && \"Invalid index into identifier index remap\");\n\n  return LocalID + I->second;\n}\n\nMacroInfo *ASTReader::getMacro(MacroID ID) {\n  if (ID == 0)\n    return nullptr;\n\n  if (MacrosLoaded.empty()) {\n    Error(\"no macro table in AST file\");\n    return nullptr;\n  }\n\n  ID -= NUM_PREDEF_MACRO_IDS;\n  if (!MacrosLoaded[ID]) {\n    GlobalMacroMapType::iterator I\n      = GlobalMacroMap.find(ID + NUM_PREDEF_MACRO_IDS);\n    assert(I != GlobalMacroMap.end() && \"Corrupted global macro map\");\n    ModuleFile *M = I->second;\n    unsigned Index = ID - M->BaseMacroID;\n    MacrosLoaded[ID] =\n        ReadMacroRecord(*M, M->MacroOffsetsBase + M->MacroOffsets[Index]);\n\n    if (DeserializationListener)\n      DeserializationListener->MacroRead(ID + NUM_PREDEF_MACRO_IDS,\n                                         MacrosLoaded[ID]);\n  }\n\n  return MacrosLoaded[ID];\n}\n\nMacroID ASTReader::getGlobalMacroID(ModuleFile &M, unsigned LocalID) {\n  if (LocalID < NUM_PREDEF_MACRO_IDS)\n    return LocalID;\n\n  if (!M.ModuleOffsetMap.empty())\n    ReadModuleOffsetMap(M);\n\n  ContinuousRangeMap<uint32_t, int, 2>::iterator I\n    = M.MacroRemap.find(LocalID - NUM_PREDEF_MACRO_IDS);\n  assert(I != M.MacroRemap.end() && \"Invalid index into macro index remap\");\n\n  return LocalID + I->second;\n}\n\nserialization::SubmoduleID\nASTReader::getGlobalSubmoduleID(ModuleFile &M, unsigned LocalID) {\n  if (LocalID < NUM_PREDEF_SUBMODULE_IDS)\n    return LocalID;\n\n  if (!M.ModuleOffsetMap.empty())\n    ReadModuleOffsetMap(M);\n\n  ContinuousRangeMap<uint32_t, int, 2>::iterator I\n    = M.SubmoduleRemap.find(LocalID - NUM_PREDEF_SUBMODULE_IDS);\n  assert(I != M.SubmoduleRemap.end()\n         && \"Invalid index into submodule index remap\");\n\n  return LocalID + I->second;\n}\n\nModule *ASTReader::getSubmodule(SubmoduleID GlobalID) {\n  if (GlobalID < NUM_PREDEF_SUBMODULE_IDS) {\n    assert(GlobalID == 0 && \"Unhandled global submodule ID\");\n    return nullptr;\n  }\n\n  if (GlobalID > SubmodulesLoaded.size()) {\n    Error(\"submodule ID out of range in AST file\");\n    return nullptr;\n  }\n\n  return SubmodulesLoaded[GlobalID - NUM_PREDEF_SUBMODULE_IDS];\n}\n\nModule *ASTReader::getModule(unsigned ID) {\n  return getSubmodule(ID);\n}\n\nModuleFile *ASTReader::getLocalModuleFile(ModuleFile &F, unsigned ID) {\n  if (ID & 1) {\n    // It's a module, look it up by submodule ID.\n    auto I = GlobalSubmoduleMap.find(getGlobalSubmoduleID(F, ID >> 1));\n    return I == GlobalSubmoduleMap.end() ? nullptr : I->second;\n  } else {\n    // It's a prefix (preamble, PCH, ...). Look it up by index.\n    unsigned IndexFromEnd = ID >> 1;\n    assert(IndexFromEnd && \"got reference to unknown module file\");\n    return getModuleManager().pch_modules().end()[-IndexFromEnd];\n  }\n}\n\nunsigned ASTReader::getModuleFileID(ModuleFile *F) {\n  if (!F)\n    return 1;\n\n  // For a file representing a module, use the submodule ID of the top-level\n  // module as the file ID. For any other kind of file, the number of such\n  // files loaded beforehand will be the same on reload.\n  // FIXME: Is this true even if we have an explicit module file and a PCH?\n  if (F->isModule())\n    return ((F->BaseSubmoduleID + NUM_PREDEF_SUBMODULE_IDS) << 1) | 1;\n\n  auto PCHModules = getModuleManager().pch_modules();\n  auto I = llvm::find(PCHModules, F);\n  assert(I != PCHModules.end() && \"emitting reference to unknown file\");\n  return (I - PCHModules.end()) << 1;\n}\n\nllvm::Optional<ASTSourceDescriptor>\nASTReader::getSourceDescriptor(unsigned ID) {\n  if (Module *M = getSubmodule(ID))\n    return ASTSourceDescriptor(*M);\n\n  // If there is only a single PCH, return it instead.\n  // Chained PCH are not supported.\n  const auto &PCHChain = ModuleMgr.pch_modules();\n  if (std::distance(std::begin(PCHChain), std::end(PCHChain))) {\n    ModuleFile &MF = ModuleMgr.getPrimaryModule();\n    StringRef ModuleName = llvm::sys::path::filename(MF.OriginalSourceFileName);\n    StringRef FileName = llvm::sys::path::filename(MF.FileName);\n    return ASTSourceDescriptor(ModuleName, MF.OriginalDir, FileName,\n                               MF.Signature);\n  }\n  return None;\n}\n\nExternalASTSource::ExtKind ASTReader::hasExternalDefinitions(const Decl *FD) {\n  auto I = DefinitionSource.find(FD);\n  if (I == DefinitionSource.end())\n    return EK_ReplyHazy;\n  return I->second ? EK_Never : EK_Always;\n}\n\nSelector ASTReader::getLocalSelector(ModuleFile &M, unsigned LocalID) {\n  return DecodeSelector(getGlobalSelectorID(M, LocalID));\n}\n\nSelector ASTReader::DecodeSelector(serialization::SelectorID ID) {\n  if (ID == 0)\n    return Selector();\n\n  if (ID > SelectorsLoaded.size()) {\n    Error(\"selector ID out of range in AST file\");\n    return Selector();\n  }\n\n  if (SelectorsLoaded[ID - 1].getAsOpaquePtr() == nullptr) {\n    // Load this selector from the selector table.\n    GlobalSelectorMapType::iterator I = GlobalSelectorMap.find(ID);\n    assert(I != GlobalSelectorMap.end() && \"Corrupted global selector map\");\n    ModuleFile &M = *I->second;\n    ASTSelectorLookupTrait Trait(*this, M);\n    unsigned Idx = ID - M.BaseSelectorID - NUM_PREDEF_SELECTOR_IDS;\n    SelectorsLoaded[ID - 1] =\n      Trait.ReadKey(M.SelectorLookupTableData + M.SelectorOffsets[Idx], 0);\n    if (DeserializationListener)\n      DeserializationListener->SelectorRead(ID, SelectorsLoaded[ID - 1]);\n  }\n\n  return SelectorsLoaded[ID - 1];\n}\n\nSelector ASTReader::GetExternalSelector(serialization::SelectorID ID) {\n  return DecodeSelector(ID);\n}\n\nuint32_t ASTReader::GetNumExternalSelectors() {\n  // ID 0 (the null selector) is considered an external selector.\n  return getTotalNumSelectors() + 1;\n}\n\nserialization::SelectorID\nASTReader::getGlobalSelectorID(ModuleFile &M, unsigned LocalID) const {\n  if (LocalID < NUM_PREDEF_SELECTOR_IDS)\n    return LocalID;\n\n  if (!M.ModuleOffsetMap.empty())\n    ReadModuleOffsetMap(M);\n\n  ContinuousRangeMap<uint32_t, int, 2>::iterator I\n    = M.SelectorRemap.find(LocalID - NUM_PREDEF_SELECTOR_IDS);\n  assert(I != M.SelectorRemap.end()\n         && \"Invalid index into selector index remap\");\n\n  return LocalID + I->second;\n}\n\nDeclarationNameLoc\nASTRecordReader::readDeclarationNameLoc(DeclarationName Name) {\n  switch (Name.getNameKind()) {\n  case DeclarationName::CXXConstructorName:\n  case DeclarationName::CXXDestructorName:\n  case DeclarationName::CXXConversionFunctionName:\n    return DeclarationNameLoc::makeNamedTypeLoc(readTypeSourceInfo());\n\n  case DeclarationName::CXXOperatorName:\n    return DeclarationNameLoc::makeCXXOperatorNameLoc(readSourceRange());\n\n  case DeclarationName::CXXLiteralOperatorName:\n    return DeclarationNameLoc::makeCXXLiteralOperatorNameLoc(\n        readSourceLocation());\n\n  case DeclarationName::Identifier:\n  case DeclarationName::ObjCZeroArgSelector:\n  case DeclarationName::ObjCOneArgSelector:\n  case DeclarationName::ObjCMultiArgSelector:\n  case DeclarationName::CXXUsingDirective:\n  case DeclarationName::CXXDeductionGuideName:\n    break;\n  }\n  return DeclarationNameLoc();\n}\n\nDeclarationNameInfo ASTRecordReader::readDeclarationNameInfo() {\n  DeclarationNameInfo NameInfo;\n  NameInfo.setName(readDeclarationName());\n  NameInfo.setLoc(readSourceLocation());\n  NameInfo.setInfo(readDeclarationNameLoc(NameInfo.getName()));\n  return NameInfo;\n}\n\nvoid ASTRecordReader::readQualifierInfo(QualifierInfo &Info) {\n  Info.QualifierLoc = readNestedNameSpecifierLoc();\n  unsigned NumTPLists = readInt();\n  Info.NumTemplParamLists = NumTPLists;\n  if (NumTPLists) {\n    Info.TemplParamLists =\n        new (getContext()) TemplateParameterList *[NumTPLists];\n    for (unsigned i = 0; i != NumTPLists; ++i)\n      Info.TemplParamLists[i] = readTemplateParameterList();\n  }\n}\n\nTemplateParameterList *\nASTRecordReader::readTemplateParameterList() {\n  SourceLocation TemplateLoc = readSourceLocation();\n  SourceLocation LAngleLoc = readSourceLocation();\n  SourceLocation RAngleLoc = readSourceLocation();\n\n  unsigned NumParams = readInt();\n  SmallVector<NamedDecl *, 16> Params;\n  Params.reserve(NumParams);\n  while (NumParams--)\n    Params.push_back(readDeclAs<NamedDecl>());\n\n  bool HasRequiresClause = readBool();\n  Expr *RequiresClause = HasRequiresClause ? readExpr() : nullptr;\n\n  TemplateParameterList *TemplateParams = TemplateParameterList::Create(\n      getContext(), TemplateLoc, LAngleLoc, Params, RAngleLoc, RequiresClause);\n  return TemplateParams;\n}\n\nvoid ASTRecordReader::readTemplateArgumentList(\n                        SmallVectorImpl<TemplateArgument> &TemplArgs,\n                        bool Canonicalize) {\n  unsigned NumTemplateArgs = readInt();\n  TemplArgs.reserve(NumTemplateArgs);\n  while (NumTemplateArgs--)\n    TemplArgs.push_back(readTemplateArgument(Canonicalize));\n}\n\n/// Read a UnresolvedSet structure.\nvoid ASTRecordReader::readUnresolvedSet(LazyASTUnresolvedSet &Set) {\n  unsigned NumDecls = readInt();\n  Set.reserve(getContext(), NumDecls);\n  while (NumDecls--) {\n    DeclID ID = readDeclID();\n    AccessSpecifier AS = (AccessSpecifier) readInt();\n    Set.addLazyDecl(getContext(), ID, AS);\n  }\n}\n\nCXXBaseSpecifier\nASTRecordReader::readCXXBaseSpecifier() {\n  bool isVirtual = readBool();\n  bool isBaseOfClass = readBool();\n  AccessSpecifier AS = static_cast<AccessSpecifier>(readInt());\n  bool inheritConstructors = readBool();\n  TypeSourceInfo *TInfo = readTypeSourceInfo();\n  SourceRange Range = readSourceRange();\n  SourceLocation EllipsisLoc = readSourceLocation();\n  CXXBaseSpecifier Result(Range, isVirtual, isBaseOfClass, AS, TInfo,\n                          EllipsisLoc);\n  Result.setInheritConstructors(inheritConstructors);\n  return Result;\n}\n\nCXXCtorInitializer **\nASTRecordReader::readCXXCtorInitializers() {\n  ASTContext &Context = getContext();\n  unsigned NumInitializers = readInt();\n  assert(NumInitializers && \"wrote ctor initializers but have no inits\");\n  auto **CtorInitializers = new (Context) CXXCtorInitializer*[NumInitializers];\n  for (unsigned i = 0; i != NumInitializers; ++i) {\n    TypeSourceInfo *TInfo = nullptr;\n    bool IsBaseVirtual = false;\n    FieldDecl *Member = nullptr;\n    IndirectFieldDecl *IndirectMember = nullptr;\n\n    CtorInitializerType Type = (CtorInitializerType) readInt();\n    switch (Type) {\n    case CTOR_INITIALIZER_BASE:\n      TInfo = readTypeSourceInfo();\n      IsBaseVirtual = readBool();\n      break;\n\n    case CTOR_INITIALIZER_DELEGATING:\n      TInfo = readTypeSourceInfo();\n      break;\n\n     case CTOR_INITIALIZER_MEMBER:\n      Member = readDeclAs<FieldDecl>();\n      break;\n\n     case CTOR_INITIALIZER_INDIRECT_MEMBER:\n      IndirectMember = readDeclAs<IndirectFieldDecl>();\n      break;\n    }\n\n    SourceLocation MemberOrEllipsisLoc = readSourceLocation();\n    Expr *Init = readExpr();\n    SourceLocation LParenLoc = readSourceLocation();\n    SourceLocation RParenLoc = readSourceLocation();\n\n    CXXCtorInitializer *BOMInit;\n    if (Type == CTOR_INITIALIZER_BASE)\n      BOMInit = new (Context)\n          CXXCtorInitializer(Context, TInfo, IsBaseVirtual, LParenLoc, Init,\n                             RParenLoc, MemberOrEllipsisLoc);\n    else if (Type == CTOR_INITIALIZER_DELEGATING)\n      BOMInit = new (Context)\n          CXXCtorInitializer(Context, TInfo, LParenLoc, Init, RParenLoc);\n    else if (Member)\n      BOMInit = new (Context)\n          CXXCtorInitializer(Context, Member, MemberOrEllipsisLoc, LParenLoc,\n                             Init, RParenLoc);\n    else\n      BOMInit = new (Context)\n          CXXCtorInitializer(Context, IndirectMember, MemberOrEllipsisLoc,\n                             LParenLoc, Init, RParenLoc);\n\n    if (/*IsWritten*/readBool()) {\n      unsigned SourceOrder = readInt();\n      BOMInit->setSourceOrder(SourceOrder);\n    }\n\n    CtorInitializers[i] = BOMInit;\n  }\n\n  return CtorInitializers;\n}\n\nNestedNameSpecifierLoc\nASTRecordReader::readNestedNameSpecifierLoc() {\n  ASTContext &Context = getContext();\n  unsigned N = readInt();\n  NestedNameSpecifierLocBuilder Builder;\n  for (unsigned I = 0; I != N; ++I) {\n    auto Kind = readNestedNameSpecifierKind();\n    switch (Kind) {\n    case NestedNameSpecifier::Identifier: {\n      IdentifierInfo *II = readIdentifier();\n      SourceRange Range = readSourceRange();\n      Builder.Extend(Context, II, Range.getBegin(), Range.getEnd());\n      break;\n    }\n\n    case NestedNameSpecifier::Namespace: {\n      NamespaceDecl *NS = readDeclAs<NamespaceDecl>();\n      SourceRange Range = readSourceRange();\n      Builder.Extend(Context, NS, Range.getBegin(), Range.getEnd());\n      break;\n    }\n\n    case NestedNameSpecifier::NamespaceAlias: {\n      NamespaceAliasDecl *Alias = readDeclAs<NamespaceAliasDecl>();\n      SourceRange Range = readSourceRange();\n      Builder.Extend(Context, Alias, Range.getBegin(), Range.getEnd());\n      break;\n    }\n\n    case NestedNameSpecifier::TypeSpec:\n    case NestedNameSpecifier::TypeSpecWithTemplate: {\n      bool Template = readBool();\n      TypeSourceInfo *T = readTypeSourceInfo();\n      if (!T)\n        return NestedNameSpecifierLoc();\n      SourceLocation ColonColonLoc = readSourceLocation();\n\n      // FIXME: 'template' keyword location not saved anywhere, so we fake it.\n      Builder.Extend(Context,\n                     Template? T->getTypeLoc().getBeginLoc() : SourceLocation(),\n                     T->getTypeLoc(), ColonColonLoc);\n      break;\n    }\n\n    case NestedNameSpecifier::Global: {\n      SourceLocation ColonColonLoc = readSourceLocation();\n      Builder.MakeGlobal(Context, ColonColonLoc);\n      break;\n    }\n\n    case NestedNameSpecifier::Super: {\n      CXXRecordDecl *RD = readDeclAs<CXXRecordDecl>();\n      SourceRange Range = readSourceRange();\n      Builder.MakeSuper(Context, RD, Range.getBegin(), Range.getEnd());\n      break;\n    }\n    }\n  }\n\n  return Builder.getWithLocInContext(Context);\n}\n\nSourceRange\nASTReader::ReadSourceRange(ModuleFile &F, const RecordData &Record,\n                           unsigned &Idx) {\n  SourceLocation beg = ReadSourceLocation(F, Record, Idx);\n  SourceLocation end = ReadSourceLocation(F, Record, Idx);\n  return SourceRange(beg, end);\n}\n\n/// Read a floating-point value\nllvm::APFloat ASTRecordReader::readAPFloat(const llvm::fltSemantics &Sem) {\n  return llvm::APFloat(Sem, readAPInt());\n}\n\n// Read a string\nstd::string ASTReader::ReadString(const RecordData &Record, unsigned &Idx) {\n  unsigned Len = Record[Idx++];\n  std::string Result(Record.data() + Idx, Record.data() + Idx + Len);\n  Idx += Len;\n  return Result;\n}\n\nstd::string ASTReader::ReadPath(ModuleFile &F, const RecordData &Record,\n                                unsigned &Idx) {\n  std::string Filename = ReadString(Record, Idx);\n  ResolveImportedPath(F, Filename);\n  return Filename;\n}\n\nstd::string ASTReader::ReadPath(StringRef BaseDirectory,\n                                const RecordData &Record, unsigned &Idx) {\n  std::string Filename = ReadString(Record, Idx);\n  if (!BaseDirectory.empty())\n    ResolveImportedPath(Filename, BaseDirectory);\n  return Filename;\n}\n\nVersionTuple ASTReader::ReadVersionTuple(const RecordData &Record,\n                                         unsigned &Idx) {\n  unsigned Major = Record[Idx++];\n  unsigned Minor = Record[Idx++];\n  unsigned Subminor = Record[Idx++];\n  if (Minor == 0)\n    return VersionTuple(Major);\n  if (Subminor == 0)\n    return VersionTuple(Major, Minor - 1);\n  return VersionTuple(Major, Minor - 1, Subminor - 1);\n}\n\nCXXTemporary *ASTReader::ReadCXXTemporary(ModuleFile &F,\n                                          const RecordData &Record,\n                                          unsigned &Idx) {\n  CXXDestructorDecl *Decl = ReadDeclAs<CXXDestructorDecl>(F, Record, Idx);\n  return CXXTemporary::Create(getContext(), Decl);\n}\n\nDiagnosticBuilder ASTReader::Diag(unsigned DiagID) const {\n  return Diag(CurrentImportLoc, DiagID);\n}\n\nDiagnosticBuilder ASTReader::Diag(SourceLocation Loc, unsigned DiagID) const {\n  return Diags.Report(Loc, DiagID);\n}\n\n/// Retrieve the identifier table associated with the\n/// preprocessor.\nIdentifierTable &ASTReader::getIdentifierTable() {\n  return PP.getIdentifierTable();\n}\n\n/// Record that the given ID maps to the given switch-case\n/// statement.\nvoid ASTReader::RecordSwitchCaseID(SwitchCase *SC, unsigned ID) {\n  assert((*CurrSwitchCaseStmts)[ID] == nullptr &&\n         \"Already have a SwitchCase with this ID\");\n  (*CurrSwitchCaseStmts)[ID] = SC;\n}\n\n/// Retrieve the switch-case statement with the given ID.\nSwitchCase *ASTReader::getSwitchCaseWithID(unsigned ID) {\n  assert((*CurrSwitchCaseStmts)[ID] != nullptr && \"No SwitchCase with this ID\");\n  return (*CurrSwitchCaseStmts)[ID];\n}\n\nvoid ASTReader::ClearSwitchCaseIDs() {\n  CurrSwitchCaseStmts->clear();\n}\n\nvoid ASTReader::ReadComments() {\n  ASTContext &Context = getContext();\n  std::vector<RawComment *> Comments;\n  for (SmallVectorImpl<std::pair<BitstreamCursor,\n                                 serialization::ModuleFile *>>::iterator\n       I = CommentsCursors.begin(),\n       E = CommentsCursors.end();\n       I != E; ++I) {\n    Comments.clear();\n    BitstreamCursor &Cursor = I->first;\n    serialization::ModuleFile &F = *I->second;\n    SavedStreamPosition SavedPosition(Cursor);\n\n    RecordData Record;\n    while (true) {\n      Expected<llvm::BitstreamEntry> MaybeEntry =\n          Cursor.advanceSkippingSubblocks(\n              BitstreamCursor::AF_DontPopBlockAtEnd);\n      if (!MaybeEntry) {\n        Error(MaybeEntry.takeError());\n        return;\n      }\n      llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n      switch (Entry.Kind) {\n      case llvm::BitstreamEntry::SubBlock: // Handled for us already.\n      case llvm::BitstreamEntry::Error:\n        Error(\"malformed block record in AST file\");\n        return;\n      case llvm::BitstreamEntry::EndBlock:\n        goto NextCursor;\n      case llvm::BitstreamEntry::Record:\n        // The interesting case.\n        break;\n      }\n\n      // Read a record.\n      Record.clear();\n      Expected<unsigned> MaybeComment = Cursor.readRecord(Entry.ID, Record);\n      if (!MaybeComment) {\n        Error(MaybeComment.takeError());\n        return;\n      }\n      switch ((CommentRecordTypes)MaybeComment.get()) {\n      case COMMENTS_RAW_COMMENT: {\n        unsigned Idx = 0;\n        SourceRange SR = ReadSourceRange(F, Record, Idx);\n        RawComment::CommentKind Kind =\n            (RawComment::CommentKind) Record[Idx++];\n        bool IsTrailingComment = Record[Idx++];\n        bool IsAlmostTrailingComment = Record[Idx++];\n        Comments.push_back(new (Context) RawComment(\n            SR, Kind, IsTrailingComment, IsAlmostTrailingComment));\n        break;\n      }\n      }\n    }\n  NextCursor:\n    llvm::DenseMap<FileID, std::map<unsigned, RawComment *>>\n        FileToOffsetToComment;\n    for (RawComment *C : Comments) {\n      SourceLocation CommentLoc = C->getBeginLoc();\n      if (CommentLoc.isValid()) {\n        std::pair<FileID, unsigned> Loc =\n            SourceMgr.getDecomposedLoc(CommentLoc);\n        if (Loc.first.isValid())\n          Context.Comments.OrderedComments[Loc.first].emplace(Loc.second, C);\n      }\n    }\n  }\n}\n\nvoid ASTReader::visitInputFiles(serialization::ModuleFile &MF,\n                                bool IncludeSystem, bool Complain,\n                    llvm::function_ref<void(const serialization::InputFile &IF,\n                                            bool isSystem)> Visitor) {\n  unsigned NumUserInputs = MF.NumUserInputFiles;\n  unsigned NumInputs = MF.InputFilesLoaded.size();\n  assert(NumUserInputs <= NumInputs);\n  unsigned N = IncludeSystem ? NumInputs : NumUserInputs;\n  for (unsigned I = 0; I < N; ++I) {\n    bool IsSystem = I >= NumUserInputs;\n    InputFile IF = getInputFile(MF, I+1, Complain);\n    Visitor(IF, IsSystem);\n  }\n}\n\nvoid ASTReader::visitTopLevelModuleMaps(\n    serialization::ModuleFile &MF,\n    llvm::function_ref<void(const FileEntry *FE)> Visitor) {\n  unsigned NumInputs = MF.InputFilesLoaded.size();\n  for (unsigned I = 0; I < NumInputs; ++I) {\n    InputFileInfo IFI = readInputFileInfo(MF, I + 1);\n    if (IFI.TopLevelModuleMap)\n      // FIXME: This unnecessarily re-reads the InputFileInfo.\n      if (auto FE = getInputFile(MF, I + 1).getFile())\n        Visitor(FE);\n  }\n}\n\nstd::string ASTReader::getOwningModuleNameForDiagnostic(const Decl *D) {\n  // If we know the owning module, use it.\n  if (Module *M = D->getImportedOwningModule())\n    return M->getFullModuleName();\n\n  // Otherwise, use the name of the top-level module the decl is within.\n  if (ModuleFile *M = getOwningModuleFile(D))\n    return M->ModuleName;\n\n  // Not from a module.\n  return {};\n}\n\nvoid ASTReader::finishPendingActions() {\n  while (!PendingIdentifierInfos.empty() || !PendingFunctionTypes.empty() ||\n         !PendingIncompleteDeclChains.empty() || !PendingDeclChains.empty() ||\n         !PendingMacroIDs.empty() || !PendingDeclContextInfos.empty() ||\n         !PendingUpdateRecords.empty()) {\n    // If any identifiers with corresponding top-level declarations have\n    // been loaded, load those declarations now.\n    using TopLevelDeclsMap =\n        llvm::DenseMap<IdentifierInfo *, SmallVector<Decl *, 2>>;\n    TopLevelDeclsMap TopLevelDecls;\n\n    while (!PendingIdentifierInfos.empty()) {\n      IdentifierInfo *II = PendingIdentifierInfos.back().first;\n      SmallVector<uint32_t, 4> DeclIDs =\n          std::move(PendingIdentifierInfos.back().second);\n      PendingIdentifierInfos.pop_back();\n\n      SetGloballyVisibleDecls(II, DeclIDs, &TopLevelDecls[II]);\n    }\n\n    // Load each function type that we deferred loading because it was a\n    // deduced type that might refer to a local type declared within itself.\n    for (unsigned I = 0; I != PendingFunctionTypes.size(); ++I) {\n      auto *FD = PendingFunctionTypes[I].first;\n      FD->setType(GetType(PendingFunctionTypes[I].second));\n\n      // If we gave a function a deduced return type, remember that we need to\n      // propagate that along the redeclaration chain.\n      auto *DT = FD->getReturnType()->getContainedDeducedType();\n      if (DT && DT->isDeduced())\n        PendingDeducedTypeUpdates.insert(\n            {FD->getCanonicalDecl(), FD->getReturnType()});\n    }\n    PendingFunctionTypes.clear();\n\n    // For each decl chain that we wanted to complete while deserializing, mark\n    // it as \"still needs to be completed\".\n    for (unsigned I = 0; I != PendingIncompleteDeclChains.size(); ++I) {\n      markIncompleteDeclChain(PendingIncompleteDeclChains[I]);\n    }\n    PendingIncompleteDeclChains.clear();\n\n    // Load pending declaration chains.\n    for (unsigned I = 0; I != PendingDeclChains.size(); ++I)\n      loadPendingDeclChain(PendingDeclChains[I].first,\n                           PendingDeclChains[I].second);\n    PendingDeclChains.clear();\n\n    // Make the most recent of the top-level declarations visible.\n    for (TopLevelDeclsMap::iterator TLD = TopLevelDecls.begin(),\n           TLDEnd = TopLevelDecls.end(); TLD != TLDEnd; ++TLD) {\n      IdentifierInfo *II = TLD->first;\n      for (unsigned I = 0, N = TLD->second.size(); I != N; ++I) {\n        pushExternalDeclIntoScope(cast<NamedDecl>(TLD->second[I]), II);\n      }\n    }\n\n    // Load any pending macro definitions.\n    for (unsigned I = 0; I != PendingMacroIDs.size(); ++I) {\n      IdentifierInfo *II = PendingMacroIDs.begin()[I].first;\n      SmallVector<PendingMacroInfo, 2> GlobalIDs;\n      GlobalIDs.swap(PendingMacroIDs.begin()[I].second);\n      // Initialize the macro history from chained-PCHs ahead of module imports.\n      for (unsigned IDIdx = 0, NumIDs = GlobalIDs.size(); IDIdx != NumIDs;\n           ++IDIdx) {\n        const PendingMacroInfo &Info = GlobalIDs[IDIdx];\n        if (!Info.M->isModule())\n          resolvePendingMacro(II, Info);\n      }\n      // Handle module imports.\n      for (unsigned IDIdx = 0, NumIDs = GlobalIDs.size(); IDIdx != NumIDs;\n           ++IDIdx) {\n        const PendingMacroInfo &Info = GlobalIDs[IDIdx];\n        if (Info.M->isModule())\n          resolvePendingMacro(II, Info);\n      }\n    }\n    PendingMacroIDs.clear();\n\n    // Wire up the DeclContexts for Decls that we delayed setting until\n    // recursive loading is completed.\n    while (!PendingDeclContextInfos.empty()) {\n      PendingDeclContextInfo Info = PendingDeclContextInfos.front();\n      PendingDeclContextInfos.pop_front();\n      DeclContext *SemaDC = cast<DeclContext>(GetDecl(Info.SemaDC));\n      DeclContext *LexicalDC = cast<DeclContext>(GetDecl(Info.LexicalDC));\n      Info.D->setDeclContextsImpl(SemaDC, LexicalDC, getContext());\n    }\n\n    // Perform any pending declaration updates.\n    while (!PendingUpdateRecords.empty()) {\n      auto Update = PendingUpdateRecords.pop_back_val();\n      ReadingKindTracker ReadingKind(Read_Decl, *this);\n      loadDeclUpdateRecords(Update);\n    }\n  }\n\n  // At this point, all update records for loaded decls are in place, so any\n  // fake class definitions should have become real.\n  assert(PendingFakeDefinitionData.empty() &&\n         \"faked up a class definition but never saw the real one\");\n\n  // If we deserialized any C++ or Objective-C class definitions, any\n  // Objective-C protocol definitions, or any redeclarable templates, make sure\n  // that all redeclarations point to the definitions. Note that this can only\n  // happen now, after the redeclaration chains have been fully wired.\n  for (Decl *D : PendingDefinitions) {\n    if (TagDecl *TD = dyn_cast<TagDecl>(D)) {\n      if (const TagType *TagT = dyn_cast<TagType>(TD->getTypeForDecl())) {\n        // Make sure that the TagType points at the definition.\n        const_cast<TagType*>(TagT)->decl = TD;\n      }\n\n      if (auto RD = dyn_cast<CXXRecordDecl>(D)) {\n        for (auto *R = getMostRecentExistingDecl(RD); R;\n             R = R->getPreviousDecl()) {\n          assert((R == D) ==\n                     cast<CXXRecordDecl>(R)->isThisDeclarationADefinition() &&\n                 \"declaration thinks it's the definition but it isn't\");\n          cast<CXXRecordDecl>(R)->DefinitionData = RD->DefinitionData;\n        }\n      }\n\n      continue;\n    }\n\n    if (auto ID = dyn_cast<ObjCInterfaceDecl>(D)) {\n      // Make sure that the ObjCInterfaceType points at the definition.\n      const_cast<ObjCInterfaceType *>(cast<ObjCInterfaceType>(ID->TypeForDecl))\n        ->Decl = ID;\n\n      for (auto *R = getMostRecentExistingDecl(ID); R; R = R->getPreviousDecl())\n        cast<ObjCInterfaceDecl>(R)->Data = ID->Data;\n\n      continue;\n    }\n\n    if (auto PD = dyn_cast<ObjCProtocolDecl>(D)) {\n      for (auto *R = getMostRecentExistingDecl(PD); R; R = R->getPreviousDecl())\n        cast<ObjCProtocolDecl>(R)->Data = PD->Data;\n\n      continue;\n    }\n\n    auto RTD = cast<RedeclarableTemplateDecl>(D)->getCanonicalDecl();\n    for (auto *R = getMostRecentExistingDecl(RTD); R; R = R->getPreviousDecl())\n      cast<RedeclarableTemplateDecl>(R)->Common = RTD->Common;\n  }\n  PendingDefinitions.clear();\n\n  // Load the bodies of any functions or methods we've encountered. We do\n  // this now (delayed) so that we can be sure that the declaration chains\n  // have been fully wired up (hasBody relies on this).\n  // FIXME: We shouldn't require complete redeclaration chains here.\n  for (PendingBodiesMap::iterator PB = PendingBodies.begin(),\n                               PBEnd = PendingBodies.end();\n       PB != PBEnd; ++PB) {\n    if (FunctionDecl *FD = dyn_cast<FunctionDecl>(PB->first)) {\n      // For a function defined inline within a class template, force the\n      // canonical definition to be the one inside the canonical definition of\n      // the template. This ensures that we instantiate from a correct view\n      // of the template.\n      //\n      // Sadly we can't do this more generally: we can't be sure that all\n      // copies of an arbitrary class definition will have the same members\n      // defined (eg, some member functions may not be instantiated, and some\n      // special members may or may not have been implicitly defined).\n      if (auto *RD = dyn_cast<CXXRecordDecl>(FD->getLexicalParent()))\n        if (RD->isDependentContext() && !RD->isThisDeclarationADefinition())\n          continue;\n\n      // FIXME: Check for =delete/=default?\n      // FIXME: Complain about ODR violations here?\n      const FunctionDecl *Defn = nullptr;\n      if (!getContext().getLangOpts().Modules || !FD->hasBody(Defn)) {\n        FD->setLazyBody(PB->second);\n      } else {\n        auto *NonConstDefn = const_cast<FunctionDecl*>(Defn);\n        mergeDefinitionVisibility(NonConstDefn, FD);\n\n        if (!FD->isLateTemplateParsed() &&\n            !NonConstDefn->isLateTemplateParsed() &&\n            FD->getODRHash() != NonConstDefn->getODRHash()) {\n          if (!isa<CXXMethodDecl>(FD)) {\n            PendingFunctionOdrMergeFailures[FD].push_back(NonConstDefn);\n          } else if (FD->getLexicalParent()->isFileContext() &&\n                     NonConstDefn->getLexicalParent()->isFileContext()) {\n            // Only diagnose out-of-line method definitions.  If they are\n            // in class definitions, then an error will be generated when\n            // processing the class bodies.\n            PendingFunctionOdrMergeFailures[FD].push_back(NonConstDefn);\n          }\n        }\n      }\n      continue;\n    }\n\n    ObjCMethodDecl *MD = cast<ObjCMethodDecl>(PB->first);\n    if (!getContext().getLangOpts().Modules || !MD->hasBody())\n      MD->setLazyBody(PB->second);\n  }\n  PendingBodies.clear();\n\n  // Do some cleanup.\n  for (auto *ND : PendingMergedDefinitionsToDeduplicate)\n    getContext().deduplicateMergedDefinitonsFor(ND);\n  PendingMergedDefinitionsToDeduplicate.clear();\n}\n\nvoid ASTReader::diagnoseOdrViolations() {\n  if (PendingOdrMergeFailures.empty() && PendingOdrMergeChecks.empty() &&\n      PendingFunctionOdrMergeFailures.empty() &&\n      PendingEnumOdrMergeFailures.empty())\n    return;\n\n  // Trigger the import of the full definition of each class that had any\n  // odr-merging problems, so we can produce better diagnostics for them.\n  // These updates may in turn find and diagnose some ODR failures, so take\n  // ownership of the set first.\n  auto OdrMergeFailures = std::move(PendingOdrMergeFailures);\n  PendingOdrMergeFailures.clear();\n  for (auto &Merge : OdrMergeFailures) {\n    Merge.first->buildLookup();\n    Merge.first->decls_begin();\n    Merge.first->bases_begin();\n    Merge.first->vbases_begin();\n    for (auto &RecordPair : Merge.second) {\n      auto *RD = RecordPair.first;\n      RD->decls_begin();\n      RD->bases_begin();\n      RD->vbases_begin();\n    }\n  }\n\n  // Trigger the import of functions.\n  auto FunctionOdrMergeFailures = std::move(PendingFunctionOdrMergeFailures);\n  PendingFunctionOdrMergeFailures.clear();\n  for (auto &Merge : FunctionOdrMergeFailures) {\n    Merge.first->buildLookup();\n    Merge.first->decls_begin();\n    Merge.first->getBody();\n    for (auto &FD : Merge.second) {\n      FD->buildLookup();\n      FD->decls_begin();\n      FD->getBody();\n    }\n  }\n\n  // Trigger the import of enums.\n  auto EnumOdrMergeFailures = std::move(PendingEnumOdrMergeFailures);\n  PendingEnumOdrMergeFailures.clear();\n  for (auto &Merge : EnumOdrMergeFailures) {\n    Merge.first->decls_begin();\n    for (auto &Enum : Merge.second) {\n      Enum->decls_begin();\n    }\n  }\n\n  // For each declaration from a merged context, check that the canonical\n  // definition of that context also contains a declaration of the same\n  // entity.\n  //\n  // Caution: this loop does things that might invalidate iterators into\n  // PendingOdrMergeChecks. Don't turn this into a range-based for loop!\n  while (!PendingOdrMergeChecks.empty()) {\n    NamedDecl *D = PendingOdrMergeChecks.pop_back_val();\n\n    // FIXME: Skip over implicit declarations for now. This matters for things\n    // like implicitly-declared special member functions. This isn't entirely\n    // correct; we can end up with multiple unmerged declarations of the same\n    // implicit entity.\n    if (D->isImplicit())\n      continue;\n\n    DeclContext *CanonDef = D->getDeclContext();\n\n    bool Found = false;\n    const Decl *DCanon = D->getCanonicalDecl();\n\n    for (auto RI : D->redecls()) {\n      if (RI->getLexicalDeclContext() == CanonDef) {\n        Found = true;\n        break;\n      }\n    }\n    if (Found)\n      continue;\n\n    // Quick check failed, time to do the slow thing. Note, we can't just\n    // look up the name of D in CanonDef here, because the member that is\n    // in CanonDef might not be found by name lookup (it might have been\n    // replaced by a more recent declaration in the lookup table), and we\n    // can't necessarily find it in the redeclaration chain because it might\n    // be merely mergeable, not redeclarable.\n    llvm::SmallVector<const NamedDecl*, 4> Candidates;\n    for (auto *CanonMember : CanonDef->decls()) {\n      if (CanonMember->getCanonicalDecl() == DCanon) {\n        // This can happen if the declaration is merely mergeable and not\n        // actually redeclarable (we looked for redeclarations earlier).\n        //\n        // FIXME: We should be able to detect this more efficiently, without\n        // pulling in all of the members of CanonDef.\n        Found = true;\n        break;\n      }\n      if (auto *ND = dyn_cast<NamedDecl>(CanonMember))\n        if (ND->getDeclName() == D->getDeclName())\n          Candidates.push_back(ND);\n    }\n\n    if (!Found) {\n      // The AST doesn't like TagDecls becoming invalid after they've been\n      // completed. We only really need to mark FieldDecls as invalid here.\n      if (!isa<TagDecl>(D))\n        D->setInvalidDecl();\n\n      // Ensure we don't accidentally recursively enter deserialization while\n      // we're producing our diagnostic.\n      Deserializing RecursionGuard(this);\n\n      std::string CanonDefModule =\n          getOwningModuleNameForDiagnostic(cast<Decl>(CanonDef));\n      Diag(D->getLocation(), diag::err_module_odr_violation_missing_decl)\n        << D << getOwningModuleNameForDiagnostic(D)\n        << CanonDef << CanonDefModule.empty() << CanonDefModule;\n\n      if (Candidates.empty())\n        Diag(cast<Decl>(CanonDef)->getLocation(),\n             diag::note_module_odr_violation_no_possible_decls) << D;\n      else {\n        for (unsigned I = 0, N = Candidates.size(); I != N; ++I)\n          Diag(Candidates[I]->getLocation(),\n               diag::note_module_odr_violation_possible_decl)\n            << Candidates[I];\n      }\n\n      DiagnosedOdrMergeFailures.insert(CanonDef);\n    }\n  }\n\n  if (OdrMergeFailures.empty() && FunctionOdrMergeFailures.empty() &&\n      EnumOdrMergeFailures.empty())\n    return;\n\n  // Ensure we don't accidentally recursively enter deserialization while\n  // we're producing our diagnostics.\n  Deserializing RecursionGuard(this);\n\n  // Common code for hashing helpers.\n  ODRHash Hash;\n  auto ComputeQualTypeODRHash = [&Hash](QualType Ty) {\n    Hash.clear();\n    Hash.AddQualType(Ty);\n    return Hash.CalculateHash();\n  };\n\n  auto ComputeODRHash = [&Hash](const Stmt *S) {\n    assert(S);\n    Hash.clear();\n    Hash.AddStmt(S);\n    return Hash.CalculateHash();\n  };\n\n  auto ComputeSubDeclODRHash = [&Hash](const Decl *D) {\n    assert(D);\n    Hash.clear();\n    Hash.AddSubDecl(D);\n    return Hash.CalculateHash();\n  };\n\n  auto ComputeTemplateArgumentODRHash = [&Hash](const TemplateArgument &TA) {\n    Hash.clear();\n    Hash.AddTemplateArgument(TA);\n    return Hash.CalculateHash();\n  };\n\n  auto ComputeTemplateParameterListODRHash =\n      [&Hash](const TemplateParameterList *TPL) {\n        assert(TPL);\n        Hash.clear();\n        Hash.AddTemplateParameterList(TPL);\n        return Hash.CalculateHash();\n      };\n\n  // Used with err_module_odr_violation_mismatch_decl and\n  // note_module_odr_violation_mismatch_decl\n  // This list should be the same Decl's as in ODRHash::isDeclToBeProcessed\n  enum ODRMismatchDecl {\n    EndOfClass,\n    PublicSpecifer,\n    PrivateSpecifer,\n    ProtectedSpecifer,\n    StaticAssert,\n    Field,\n    CXXMethod,\n    TypeAlias,\n    TypeDef,\n    Var,\n    Friend,\n    FunctionTemplate,\n    Other\n  };\n\n  // Used with err_module_odr_violation_mismatch_decl_diff and\n  // note_module_odr_violation_mismatch_decl_diff\n  enum ODRMismatchDeclDifference {\n    StaticAssertCondition,\n    StaticAssertMessage,\n    StaticAssertOnlyMessage,\n    FieldName,\n    FieldTypeName,\n    FieldSingleBitField,\n    FieldDifferentWidthBitField,\n    FieldSingleMutable,\n    FieldSingleInitializer,\n    FieldDifferentInitializers,\n    MethodName,\n    MethodDeleted,\n    MethodDefaulted,\n    MethodVirtual,\n    MethodStatic,\n    MethodVolatile,\n    MethodConst,\n    MethodInline,\n    MethodNumberParameters,\n    MethodParameterType,\n    MethodParameterName,\n    MethodParameterSingleDefaultArgument,\n    MethodParameterDifferentDefaultArgument,\n    MethodNoTemplateArguments,\n    MethodDifferentNumberTemplateArguments,\n    MethodDifferentTemplateArgument,\n    MethodSingleBody,\n    MethodDifferentBody,\n    TypedefName,\n    TypedefType,\n    VarName,\n    VarType,\n    VarSingleInitializer,\n    VarDifferentInitializer,\n    VarConstexpr,\n    FriendTypeFunction,\n    FriendType,\n    FriendFunction,\n    FunctionTemplateDifferentNumberParameters,\n    FunctionTemplateParameterDifferentKind,\n    FunctionTemplateParameterName,\n    FunctionTemplateParameterSingleDefaultArgument,\n    FunctionTemplateParameterDifferentDefaultArgument,\n    FunctionTemplateParameterDifferentType,\n    FunctionTemplatePackParameter,\n  };\n\n  // These lambdas have the common portions of the ODR diagnostics.  This\n  // has the same return as Diag(), so addition parameters can be passed\n  // in with operator<<\n  auto ODRDiagDeclError = [this](NamedDecl *FirstRecord, StringRef FirstModule,\n                                 SourceLocation Loc, SourceRange Range,\n                                 ODRMismatchDeclDifference DiffType) {\n    return Diag(Loc, diag::err_module_odr_violation_mismatch_decl_diff)\n           << FirstRecord << FirstModule.empty() << FirstModule << Range\n           << DiffType;\n  };\n  auto ODRDiagDeclNote = [this](StringRef SecondModule, SourceLocation Loc,\n                                SourceRange Range, ODRMismatchDeclDifference DiffType) {\n    return Diag(Loc, diag::note_module_odr_violation_mismatch_decl_diff)\n           << SecondModule << Range << DiffType;\n  };\n\n  auto ODRDiagField = [this, &ODRDiagDeclError, &ODRDiagDeclNote,\n                       &ComputeQualTypeODRHash, &ComputeODRHash](\n                          NamedDecl *FirstRecord, StringRef FirstModule,\n                          StringRef SecondModule, FieldDecl *FirstField,\n                          FieldDecl *SecondField) {\n    IdentifierInfo *FirstII = FirstField->getIdentifier();\n    IdentifierInfo *SecondII = SecondField->getIdentifier();\n    if (FirstII->getName() != SecondII->getName()) {\n      ODRDiagDeclError(FirstRecord, FirstModule, FirstField->getLocation(),\n                       FirstField->getSourceRange(), FieldName)\n          << FirstII;\n      ODRDiagDeclNote(SecondModule, SecondField->getLocation(),\n                      SecondField->getSourceRange(), FieldName)\n          << SecondII;\n\n      return true;\n    }\n\n    assert(getContext().hasSameType(FirstField->getType(),\n                                    SecondField->getType()));\n\n    QualType FirstType = FirstField->getType();\n    QualType SecondType = SecondField->getType();\n    if (ComputeQualTypeODRHash(FirstType) !=\n        ComputeQualTypeODRHash(SecondType)) {\n      ODRDiagDeclError(FirstRecord, FirstModule, FirstField->getLocation(),\n                       FirstField->getSourceRange(), FieldTypeName)\n          << FirstII << FirstType;\n      ODRDiagDeclNote(SecondModule, SecondField->getLocation(),\n                      SecondField->getSourceRange(), FieldTypeName)\n          << SecondII << SecondType;\n\n      return true;\n    }\n\n    const bool IsFirstBitField = FirstField->isBitField();\n    const bool IsSecondBitField = SecondField->isBitField();\n    if (IsFirstBitField != IsSecondBitField) {\n      ODRDiagDeclError(FirstRecord, FirstModule, FirstField->getLocation(),\n                       FirstField->getSourceRange(), FieldSingleBitField)\n          << FirstII << IsFirstBitField;\n      ODRDiagDeclNote(SecondModule, SecondField->getLocation(),\n                      SecondField->getSourceRange(), FieldSingleBitField)\n          << SecondII << IsSecondBitField;\n      return true;\n    }\n\n    if (IsFirstBitField && IsSecondBitField) {\n      unsigned FirstBitWidthHash =\n          ComputeODRHash(FirstField->getBitWidth());\n      unsigned SecondBitWidthHash =\n          ComputeODRHash(SecondField->getBitWidth());\n      if (FirstBitWidthHash != SecondBitWidthHash) {\n        ODRDiagDeclError(FirstRecord, FirstModule, FirstField->getLocation(),\n                         FirstField->getSourceRange(),\n                         FieldDifferentWidthBitField)\n            << FirstII << FirstField->getBitWidth()->getSourceRange();\n        ODRDiagDeclNote(SecondModule, SecondField->getLocation(),\n                        SecondField->getSourceRange(),\n                        FieldDifferentWidthBitField)\n            << SecondII << SecondField->getBitWidth()->getSourceRange();\n        return true;\n      }\n    }\n\n    if (!PP.getLangOpts().CPlusPlus)\n      return false;\n\n    const bool IsFirstMutable = FirstField->isMutable();\n    const bool IsSecondMutable = SecondField->isMutable();\n    if (IsFirstMutable != IsSecondMutable) {\n      ODRDiagDeclError(FirstRecord, FirstModule, FirstField->getLocation(),\n                       FirstField->getSourceRange(), FieldSingleMutable)\n          << FirstII << IsFirstMutable;\n      ODRDiagDeclNote(SecondModule, SecondField->getLocation(),\n                      SecondField->getSourceRange(), FieldSingleMutable)\n          << SecondII << IsSecondMutable;\n      return true;\n    }\n\n    const Expr *FirstInitializer = FirstField->getInClassInitializer();\n    const Expr *SecondInitializer = SecondField->getInClassInitializer();\n    if ((!FirstInitializer && SecondInitializer) ||\n        (FirstInitializer && !SecondInitializer)) {\n      ODRDiagDeclError(FirstRecord, FirstModule, FirstField->getLocation(),\n                       FirstField->getSourceRange(), FieldSingleInitializer)\n          << FirstII << (FirstInitializer != nullptr);\n      ODRDiagDeclNote(SecondModule, SecondField->getLocation(),\n                      SecondField->getSourceRange(), FieldSingleInitializer)\n          << SecondII << (SecondInitializer != nullptr);\n      return true;\n    }\n\n    if (FirstInitializer && SecondInitializer) {\n      unsigned FirstInitHash = ComputeODRHash(FirstInitializer);\n      unsigned SecondInitHash = ComputeODRHash(SecondInitializer);\n      if (FirstInitHash != SecondInitHash) {\n        ODRDiagDeclError(FirstRecord, FirstModule, FirstField->getLocation(),\n                         FirstField->getSourceRange(),\n                         FieldDifferentInitializers)\n            << FirstII << FirstInitializer->getSourceRange();\n        ODRDiagDeclNote(SecondModule, SecondField->getLocation(),\n                        SecondField->getSourceRange(),\n                        FieldDifferentInitializers)\n            << SecondII << SecondInitializer->getSourceRange();\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  auto ODRDiagTypeDefOrAlias =\n      [&ODRDiagDeclError, &ODRDiagDeclNote, &ComputeQualTypeODRHash](\n          NamedDecl *FirstRecord, StringRef FirstModule, StringRef SecondModule,\n          TypedefNameDecl *FirstTD, TypedefNameDecl *SecondTD,\n          bool IsTypeAlias) {\n        auto FirstName = FirstTD->getDeclName();\n        auto SecondName = SecondTD->getDeclName();\n        if (FirstName != SecondName) {\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstTD->getLocation(),\n                           FirstTD->getSourceRange(), TypedefName)\n              << IsTypeAlias << FirstName;\n          ODRDiagDeclNote(SecondModule, SecondTD->getLocation(),\n                          SecondTD->getSourceRange(), TypedefName)\n              << IsTypeAlias << SecondName;\n          return true;\n        }\n\n        QualType FirstType = FirstTD->getUnderlyingType();\n        QualType SecondType = SecondTD->getUnderlyingType();\n        if (ComputeQualTypeODRHash(FirstType) !=\n            ComputeQualTypeODRHash(SecondType)) {\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstTD->getLocation(),\n                           FirstTD->getSourceRange(), TypedefType)\n              << IsTypeAlias << FirstName << FirstType;\n          ODRDiagDeclNote(SecondModule, SecondTD->getLocation(),\n                          SecondTD->getSourceRange(), TypedefType)\n              << IsTypeAlias << SecondName << SecondType;\n          return true;\n        }\n\n        return false;\n  };\n\n  auto ODRDiagVar = [&ODRDiagDeclError, &ODRDiagDeclNote,\n                     &ComputeQualTypeODRHash, &ComputeODRHash,\n                     this](NamedDecl *FirstRecord, StringRef FirstModule,\n                           StringRef SecondModule, VarDecl *FirstVD,\n                           VarDecl *SecondVD) {\n    auto FirstName = FirstVD->getDeclName();\n    auto SecondName = SecondVD->getDeclName();\n    if (FirstName != SecondName) {\n      ODRDiagDeclError(FirstRecord, FirstModule, FirstVD->getLocation(),\n                       FirstVD->getSourceRange(), VarName)\n          << FirstName;\n      ODRDiagDeclNote(SecondModule, SecondVD->getLocation(),\n                      SecondVD->getSourceRange(), VarName)\n          << SecondName;\n      return true;\n    }\n\n    QualType FirstType = FirstVD->getType();\n    QualType SecondType = SecondVD->getType();\n    if (ComputeQualTypeODRHash(FirstType) !=\n        ComputeQualTypeODRHash(SecondType)) {\n      ODRDiagDeclError(FirstRecord, FirstModule, FirstVD->getLocation(),\n                       FirstVD->getSourceRange(), VarType)\n          << FirstName << FirstType;\n      ODRDiagDeclNote(SecondModule, SecondVD->getLocation(),\n                      SecondVD->getSourceRange(), VarType)\n          << SecondName << SecondType;\n      return true;\n    }\n\n    if (!PP.getLangOpts().CPlusPlus)\n      return false;\n\n    const Expr *FirstInit = FirstVD->getInit();\n    const Expr *SecondInit = SecondVD->getInit();\n    if ((FirstInit == nullptr) != (SecondInit == nullptr)) {\n      ODRDiagDeclError(FirstRecord, FirstModule, FirstVD->getLocation(),\n                       FirstVD->getSourceRange(), VarSingleInitializer)\n          << FirstName << (FirstInit == nullptr)\n          << (FirstInit ? FirstInit->getSourceRange() : SourceRange());\n      ODRDiagDeclNote(SecondModule, SecondVD->getLocation(),\n                      SecondVD->getSourceRange(), VarSingleInitializer)\n          << SecondName << (SecondInit == nullptr)\n          << (SecondInit ? SecondInit->getSourceRange() : SourceRange());\n      return true;\n    }\n\n    if (FirstInit && SecondInit &&\n        ComputeODRHash(FirstInit) != ComputeODRHash(SecondInit)) {\n      ODRDiagDeclError(FirstRecord, FirstModule, FirstVD->getLocation(),\n                       FirstVD->getSourceRange(), VarDifferentInitializer)\n          << FirstName << FirstInit->getSourceRange();\n      ODRDiagDeclNote(SecondModule, SecondVD->getLocation(),\n                      SecondVD->getSourceRange(), VarDifferentInitializer)\n          << SecondName << SecondInit->getSourceRange();\n      return true;\n    }\n\n    const bool FirstIsConstexpr = FirstVD->isConstexpr();\n    const bool SecondIsConstexpr = SecondVD->isConstexpr();\n    if (FirstIsConstexpr != SecondIsConstexpr) {\n      ODRDiagDeclError(FirstRecord, FirstModule, FirstVD->getLocation(),\n                       FirstVD->getSourceRange(), VarConstexpr)\n          << FirstName << FirstIsConstexpr;\n      ODRDiagDeclNote(SecondModule, SecondVD->getLocation(),\n                      SecondVD->getSourceRange(), VarConstexpr)\n          << SecondName << SecondIsConstexpr;\n      return true;\n    }\n    return false;\n  };\n\n  auto DifferenceSelector = [](Decl *D) {\n    assert(D && \"valid Decl required\");\n    switch (D->getKind()) {\n    default:\n      return Other;\n    case Decl::AccessSpec:\n      switch (D->getAccess()) {\n      case AS_public:\n        return PublicSpecifer;\n      case AS_private:\n        return PrivateSpecifer;\n      case AS_protected:\n        return ProtectedSpecifer;\n      case AS_none:\n        break;\n      }\n      llvm_unreachable(\"Invalid access specifier\");\n    case Decl::StaticAssert:\n      return StaticAssert;\n    case Decl::Field:\n      return Field;\n    case Decl::CXXMethod:\n    case Decl::CXXConstructor:\n    case Decl::CXXDestructor:\n      return CXXMethod;\n    case Decl::TypeAlias:\n      return TypeAlias;\n    case Decl::Typedef:\n      return TypeDef;\n    case Decl::Var:\n      return Var;\n    case Decl::Friend:\n      return Friend;\n    case Decl::FunctionTemplate:\n      return FunctionTemplate;\n    }\n  };\n\n  using DeclHashes = llvm::SmallVector<std::pair<Decl *, unsigned>, 4>;\n  auto PopulateHashes = [&ComputeSubDeclODRHash](DeclHashes &Hashes,\n                                                 RecordDecl *Record,\n                                                 const DeclContext *DC) {\n    for (auto *D : Record->decls()) {\n      if (!ODRHash::isDeclToBeProcessed(D, DC))\n        continue;\n      Hashes.emplace_back(D, ComputeSubDeclODRHash(D));\n    }\n  };\n\n  struct DiffResult {\n    Decl *FirstDecl = nullptr, *SecondDecl = nullptr;\n    ODRMismatchDecl FirstDiffType = Other, SecondDiffType = Other;\n  };\n\n  // If there is a diagnoseable difference, FirstDiffType and\n  // SecondDiffType will not be Other and FirstDecl and SecondDecl will be\n  // filled in if not EndOfClass.\n  auto FindTypeDiffs = [&DifferenceSelector](DeclHashes &FirstHashes,\n                                             DeclHashes &SecondHashes) {\n    DiffResult DR;\n    auto FirstIt = FirstHashes.begin();\n    auto SecondIt = SecondHashes.begin();\n    while (FirstIt != FirstHashes.end() || SecondIt != SecondHashes.end()) {\n      if (FirstIt != FirstHashes.end() && SecondIt != SecondHashes.end() &&\n          FirstIt->second == SecondIt->second) {\n        ++FirstIt;\n        ++SecondIt;\n        continue;\n      }\n\n      DR.FirstDecl = FirstIt == FirstHashes.end() ? nullptr : FirstIt->first;\n      DR.SecondDecl =\n          SecondIt == SecondHashes.end() ? nullptr : SecondIt->first;\n\n      DR.FirstDiffType =\n          DR.FirstDecl ? DifferenceSelector(DR.FirstDecl) : EndOfClass;\n      DR.SecondDiffType =\n          DR.SecondDecl ? DifferenceSelector(DR.SecondDecl) : EndOfClass;\n      return DR;\n    }\n    return DR;\n  };\n\n  // Use this to diagnose that an unexpected Decl was encountered\n  // or no difference was detected. This causes a generic error\n  // message to be emitted.\n  auto DiagnoseODRUnexpected = [this](DiffResult &DR, NamedDecl *FirstRecord,\n                                      StringRef FirstModule,\n                                      NamedDecl *SecondRecord,\n                                      StringRef SecondModule) {\n    Diag(FirstRecord->getLocation(),\n         diag::err_module_odr_violation_different_definitions)\n        << FirstRecord << FirstModule.empty() << FirstModule;\n\n    if (DR.FirstDecl) {\n      Diag(DR.FirstDecl->getLocation(), diag::note_first_module_difference)\n          << FirstRecord << DR.FirstDecl->getSourceRange();\n    }\n\n    Diag(SecondRecord->getLocation(),\n         diag::note_module_odr_violation_different_definitions)\n        << SecondModule;\n\n    if (DR.SecondDecl) {\n      Diag(DR.SecondDecl->getLocation(), diag::note_second_module_difference)\n          << DR.SecondDecl->getSourceRange();\n    }\n  };\n\n  auto DiagnoseODRMismatch =\n      [this](DiffResult &DR, NamedDecl *FirstRecord, StringRef FirstModule,\n             NamedDecl *SecondRecord, StringRef SecondModule) {\n        SourceLocation FirstLoc;\n        SourceRange FirstRange;\n        auto *FirstTag = dyn_cast<TagDecl>(FirstRecord);\n        if (DR.FirstDiffType == EndOfClass && FirstTag) {\n          FirstLoc = FirstTag->getBraceRange().getEnd();\n        } else {\n          FirstLoc = DR.FirstDecl->getLocation();\n          FirstRange = DR.FirstDecl->getSourceRange();\n        }\n        Diag(FirstLoc, diag::err_module_odr_violation_mismatch_decl)\n            << FirstRecord << FirstModule.empty() << FirstModule << FirstRange\n            << DR.FirstDiffType;\n\n        SourceLocation SecondLoc;\n        SourceRange SecondRange;\n        auto *SecondTag = dyn_cast<TagDecl>(SecondRecord);\n        if (DR.SecondDiffType == EndOfClass && SecondTag) {\n          SecondLoc = SecondTag->getBraceRange().getEnd();\n        } else {\n          SecondLoc = DR.SecondDecl->getLocation();\n          SecondRange = DR.SecondDecl->getSourceRange();\n        }\n        Diag(SecondLoc, diag::note_module_odr_violation_mismatch_decl)\n            << SecondModule << SecondRange << DR.SecondDiffType;\n      };\n\n  // Issue any pending ODR-failure diagnostics.\n  for (auto &Merge : OdrMergeFailures) {\n    // If we've already pointed out a specific problem with this class, don't\n    // bother issuing a general \"something's different\" diagnostic.\n    if (!DiagnosedOdrMergeFailures.insert(Merge.first).second)\n      continue;\n\n    bool Diagnosed = false;\n    CXXRecordDecl *FirstRecord = Merge.first;\n    std::string FirstModule = getOwningModuleNameForDiagnostic(FirstRecord);\n    for (auto &RecordPair : Merge.second) {\n      CXXRecordDecl *SecondRecord = RecordPair.first;\n      // Multiple different declarations got merged together; tell the user\n      // where they came from.\n      if (FirstRecord == SecondRecord)\n        continue;\n\n      std::string SecondModule = getOwningModuleNameForDiagnostic(SecondRecord);\n\n      auto *FirstDD = FirstRecord->DefinitionData;\n      auto *SecondDD = RecordPair.second;\n\n      assert(FirstDD && SecondDD && \"Definitions without DefinitionData\");\n\n      // Diagnostics from DefinitionData are emitted here.\n      if (FirstDD != SecondDD) {\n        enum ODRDefinitionDataDifference {\n          NumBases,\n          NumVBases,\n          BaseType,\n          BaseVirtual,\n          BaseAccess,\n        };\n        auto ODRDiagBaseError = [FirstRecord, &FirstModule,\n                                 this](SourceLocation Loc, SourceRange Range,\n                                       ODRDefinitionDataDifference DiffType) {\n          return Diag(Loc, diag::err_module_odr_violation_definition_data)\n                 << FirstRecord << FirstModule.empty() << FirstModule << Range\n                 << DiffType;\n        };\n        auto ODRDiagBaseNote = [&SecondModule,\n                                this](SourceLocation Loc, SourceRange Range,\n                                      ODRDefinitionDataDifference DiffType) {\n          return Diag(Loc, diag::note_module_odr_violation_definition_data)\n                 << SecondModule << Range << DiffType;\n        };\n\n        unsigned FirstNumBases = FirstDD->NumBases;\n        unsigned FirstNumVBases = FirstDD->NumVBases;\n        unsigned SecondNumBases = SecondDD->NumBases;\n        unsigned SecondNumVBases = SecondDD->NumVBases;\n\n        auto GetSourceRange = [](struct CXXRecordDecl::DefinitionData *DD) {\n          unsigned NumBases = DD->NumBases;\n          if (NumBases == 0) return SourceRange();\n          auto bases = DD->bases();\n          return SourceRange(bases[0].getBeginLoc(),\n                             bases[NumBases - 1].getEndLoc());\n        };\n\n        if (FirstNumBases != SecondNumBases) {\n          ODRDiagBaseError(FirstRecord->getLocation(), GetSourceRange(FirstDD),\n                           NumBases)\n              << FirstNumBases;\n          ODRDiagBaseNote(SecondRecord->getLocation(), GetSourceRange(SecondDD),\n                          NumBases)\n              << SecondNumBases;\n          Diagnosed = true;\n          break;\n        }\n\n        if (FirstNumVBases != SecondNumVBases) {\n          ODRDiagBaseError(FirstRecord->getLocation(), GetSourceRange(FirstDD),\n                           NumVBases)\n              << FirstNumVBases;\n          ODRDiagBaseNote(SecondRecord->getLocation(), GetSourceRange(SecondDD),\n                          NumVBases)\n              << SecondNumVBases;\n          Diagnosed = true;\n          break;\n        }\n\n        auto FirstBases = FirstDD->bases();\n        auto SecondBases = SecondDD->bases();\n        unsigned i = 0;\n        for (i = 0; i < FirstNumBases; ++i) {\n          auto FirstBase = FirstBases[i];\n          auto SecondBase = SecondBases[i];\n          if (ComputeQualTypeODRHash(FirstBase.getType()) !=\n              ComputeQualTypeODRHash(SecondBase.getType())) {\n            ODRDiagBaseError(FirstRecord->getLocation(),\n                             FirstBase.getSourceRange(), BaseType)\n                << (i + 1) << FirstBase.getType();\n            ODRDiagBaseNote(SecondRecord->getLocation(),\n                            SecondBase.getSourceRange(), BaseType)\n                << (i + 1) << SecondBase.getType();\n            break;\n          }\n\n          if (FirstBase.isVirtual() != SecondBase.isVirtual()) {\n            ODRDiagBaseError(FirstRecord->getLocation(),\n                             FirstBase.getSourceRange(), BaseVirtual)\n                << (i + 1) << FirstBase.isVirtual() << FirstBase.getType();\n            ODRDiagBaseNote(SecondRecord->getLocation(),\n                            SecondBase.getSourceRange(), BaseVirtual)\n                << (i + 1) << SecondBase.isVirtual() << SecondBase.getType();\n            break;\n          }\n\n          if (FirstBase.getAccessSpecifierAsWritten() !=\n              SecondBase.getAccessSpecifierAsWritten()) {\n            ODRDiagBaseError(FirstRecord->getLocation(),\n                             FirstBase.getSourceRange(), BaseAccess)\n                << (i + 1) << FirstBase.getType()\n                << (int)FirstBase.getAccessSpecifierAsWritten();\n            ODRDiagBaseNote(SecondRecord->getLocation(),\n                            SecondBase.getSourceRange(), BaseAccess)\n                << (i + 1) << SecondBase.getType()\n                << (int)SecondBase.getAccessSpecifierAsWritten();\n            break;\n          }\n        }\n\n        if (i != FirstNumBases) {\n          Diagnosed = true;\n          break;\n        }\n      }\n\n      const ClassTemplateDecl *FirstTemplate =\n          FirstRecord->getDescribedClassTemplate();\n      const ClassTemplateDecl *SecondTemplate =\n          SecondRecord->getDescribedClassTemplate();\n\n      assert(!FirstTemplate == !SecondTemplate &&\n             \"Both pointers should be null or non-null\");\n\n      enum ODRTemplateDifference {\n        ParamEmptyName,\n        ParamName,\n        ParamSingleDefaultArgument,\n        ParamDifferentDefaultArgument,\n      };\n\n      if (FirstTemplate && SecondTemplate) {\n        DeclHashes FirstTemplateHashes;\n        DeclHashes SecondTemplateHashes;\n\n        auto PopulateTemplateParameterHashs =\n            [&ComputeSubDeclODRHash](DeclHashes &Hashes,\n                                     const ClassTemplateDecl *TD) {\n              for (auto *D : TD->getTemplateParameters()->asArray()) {\n                Hashes.emplace_back(D, ComputeSubDeclODRHash(D));\n              }\n            };\n\n        PopulateTemplateParameterHashs(FirstTemplateHashes, FirstTemplate);\n        PopulateTemplateParameterHashs(SecondTemplateHashes, SecondTemplate);\n\n        assert(FirstTemplateHashes.size() == SecondTemplateHashes.size() &&\n               \"Number of template parameters should be equal.\");\n\n        auto FirstIt = FirstTemplateHashes.begin();\n        auto FirstEnd = FirstTemplateHashes.end();\n        auto SecondIt = SecondTemplateHashes.begin();\n        for (; FirstIt != FirstEnd; ++FirstIt, ++SecondIt) {\n          if (FirstIt->second == SecondIt->second)\n            continue;\n\n          auto ODRDiagTemplateError = [FirstRecord, &FirstModule, this](\n                                          SourceLocation Loc, SourceRange Range,\n                                          ODRTemplateDifference DiffType) {\n            return Diag(Loc, diag::err_module_odr_violation_template_parameter)\n                   << FirstRecord << FirstModule.empty() << FirstModule << Range\n                   << DiffType;\n          };\n          auto ODRDiagTemplateNote = [&SecondModule, this](\n                                         SourceLocation Loc, SourceRange Range,\n                                         ODRTemplateDifference DiffType) {\n            return Diag(Loc, diag::note_module_odr_violation_template_parameter)\n                   << SecondModule << Range << DiffType;\n          };\n\n          const NamedDecl* FirstDecl = cast<NamedDecl>(FirstIt->first);\n          const NamedDecl* SecondDecl = cast<NamedDecl>(SecondIt->first);\n\n          assert(FirstDecl->getKind() == SecondDecl->getKind() &&\n                 \"Parameter Decl's should be the same kind.\");\n\n          DeclarationName FirstName = FirstDecl->getDeclName();\n          DeclarationName SecondName = SecondDecl->getDeclName();\n\n          if (FirstName != SecondName) {\n            const bool FirstNameEmpty =\n                FirstName.isIdentifier() && !FirstName.getAsIdentifierInfo();\n            const bool SecondNameEmpty =\n                SecondName.isIdentifier() && !SecondName.getAsIdentifierInfo();\n            assert((!FirstNameEmpty || !SecondNameEmpty) &&\n                   \"Both template parameters cannot be unnamed.\");\n            ODRDiagTemplateError(FirstDecl->getLocation(),\n                                 FirstDecl->getSourceRange(),\n                                 FirstNameEmpty ? ParamEmptyName : ParamName)\n                << FirstName;\n            ODRDiagTemplateNote(SecondDecl->getLocation(),\n                                SecondDecl->getSourceRange(),\n                                SecondNameEmpty ? ParamEmptyName : ParamName)\n                << SecondName;\n            break;\n          }\n\n          switch (FirstDecl->getKind()) {\n          default:\n            llvm_unreachable(\"Invalid template parameter type.\");\n          case Decl::TemplateTypeParm: {\n            const auto *FirstParam = cast<TemplateTypeParmDecl>(FirstDecl);\n            const auto *SecondParam = cast<TemplateTypeParmDecl>(SecondDecl);\n            const bool HasFirstDefaultArgument =\n                FirstParam->hasDefaultArgument() &&\n                !FirstParam->defaultArgumentWasInherited();\n            const bool HasSecondDefaultArgument =\n                SecondParam->hasDefaultArgument() &&\n                !SecondParam->defaultArgumentWasInherited();\n\n            if (HasFirstDefaultArgument != HasSecondDefaultArgument) {\n              ODRDiagTemplateError(FirstDecl->getLocation(),\n                                   FirstDecl->getSourceRange(),\n                                   ParamSingleDefaultArgument)\n                  << HasFirstDefaultArgument;\n              ODRDiagTemplateNote(SecondDecl->getLocation(),\n                                  SecondDecl->getSourceRange(),\n                                  ParamSingleDefaultArgument)\n                  << HasSecondDefaultArgument;\n              break;\n            }\n\n            assert(HasFirstDefaultArgument && HasSecondDefaultArgument &&\n                   \"Expecting default arguments.\");\n\n            ODRDiagTemplateError(FirstDecl->getLocation(),\n                                 FirstDecl->getSourceRange(),\n                                 ParamDifferentDefaultArgument);\n            ODRDiagTemplateNote(SecondDecl->getLocation(),\n                                SecondDecl->getSourceRange(),\n                                ParamDifferentDefaultArgument);\n\n            break;\n          }\n          case Decl::NonTypeTemplateParm: {\n            const auto *FirstParam = cast<NonTypeTemplateParmDecl>(FirstDecl);\n            const auto *SecondParam = cast<NonTypeTemplateParmDecl>(SecondDecl);\n            const bool HasFirstDefaultArgument =\n                FirstParam->hasDefaultArgument() &&\n                !FirstParam->defaultArgumentWasInherited();\n            const bool HasSecondDefaultArgument =\n                SecondParam->hasDefaultArgument() &&\n                !SecondParam->defaultArgumentWasInherited();\n\n            if (HasFirstDefaultArgument != HasSecondDefaultArgument) {\n              ODRDiagTemplateError(FirstDecl->getLocation(),\n                                   FirstDecl->getSourceRange(),\n                                   ParamSingleDefaultArgument)\n                  << HasFirstDefaultArgument;\n              ODRDiagTemplateNote(SecondDecl->getLocation(),\n                                  SecondDecl->getSourceRange(),\n                                  ParamSingleDefaultArgument)\n                  << HasSecondDefaultArgument;\n              break;\n            }\n\n            assert(HasFirstDefaultArgument && HasSecondDefaultArgument &&\n                   \"Expecting default arguments.\");\n\n            ODRDiagTemplateError(FirstDecl->getLocation(),\n                                 FirstDecl->getSourceRange(),\n                                 ParamDifferentDefaultArgument);\n            ODRDiagTemplateNote(SecondDecl->getLocation(),\n                                SecondDecl->getSourceRange(),\n                                ParamDifferentDefaultArgument);\n\n            break;\n          }\n          case Decl::TemplateTemplateParm: {\n            const auto *FirstParam = cast<TemplateTemplateParmDecl>(FirstDecl);\n            const auto *SecondParam =\n                cast<TemplateTemplateParmDecl>(SecondDecl);\n            const bool HasFirstDefaultArgument =\n                FirstParam->hasDefaultArgument() &&\n                !FirstParam->defaultArgumentWasInherited();\n            const bool HasSecondDefaultArgument =\n                SecondParam->hasDefaultArgument() &&\n                !SecondParam->defaultArgumentWasInherited();\n\n            if (HasFirstDefaultArgument != HasSecondDefaultArgument) {\n              ODRDiagTemplateError(FirstDecl->getLocation(),\n                                   FirstDecl->getSourceRange(),\n                                   ParamSingleDefaultArgument)\n                  << HasFirstDefaultArgument;\n              ODRDiagTemplateNote(SecondDecl->getLocation(),\n                                  SecondDecl->getSourceRange(),\n                                  ParamSingleDefaultArgument)\n                  << HasSecondDefaultArgument;\n              break;\n            }\n\n            assert(HasFirstDefaultArgument && HasSecondDefaultArgument &&\n                   \"Expecting default arguments.\");\n\n            ODRDiagTemplateError(FirstDecl->getLocation(),\n                                 FirstDecl->getSourceRange(),\n                                 ParamDifferentDefaultArgument);\n            ODRDiagTemplateNote(SecondDecl->getLocation(),\n                                SecondDecl->getSourceRange(),\n                                ParamDifferentDefaultArgument);\n\n            break;\n          }\n          }\n\n          break;\n        }\n\n        if (FirstIt != FirstEnd) {\n          Diagnosed = true;\n          break;\n        }\n      }\n\n      DeclHashes FirstHashes;\n      DeclHashes SecondHashes;\n      const DeclContext *DC = FirstRecord;\n      PopulateHashes(FirstHashes, FirstRecord, DC);\n      PopulateHashes(SecondHashes, SecondRecord, DC);\n\n      auto DR = FindTypeDiffs(FirstHashes, SecondHashes);\n      ODRMismatchDecl FirstDiffType = DR.FirstDiffType;\n      ODRMismatchDecl SecondDiffType = DR.SecondDiffType;\n      Decl *FirstDecl = DR.FirstDecl;\n      Decl *SecondDecl = DR.SecondDecl;\n\n      if (FirstDiffType == Other || SecondDiffType == Other) {\n        DiagnoseODRUnexpected(DR, FirstRecord, FirstModule, SecondRecord,\n                              SecondModule);\n        Diagnosed = true;\n        break;\n      }\n\n      if (FirstDiffType != SecondDiffType) {\n        DiagnoseODRMismatch(DR, FirstRecord, FirstModule, SecondRecord,\n                            SecondModule);\n        Diagnosed = true;\n        break;\n      }\n\n      assert(FirstDiffType == SecondDiffType);\n\n      switch (FirstDiffType) {\n      case Other:\n      case EndOfClass:\n      case PublicSpecifer:\n      case PrivateSpecifer:\n      case ProtectedSpecifer:\n        llvm_unreachable(\"Invalid diff type\");\n\n      case StaticAssert: {\n        StaticAssertDecl *FirstSA = cast<StaticAssertDecl>(FirstDecl);\n        StaticAssertDecl *SecondSA = cast<StaticAssertDecl>(SecondDecl);\n\n        Expr *FirstExpr = FirstSA->getAssertExpr();\n        Expr *SecondExpr = SecondSA->getAssertExpr();\n        unsigned FirstODRHash = ComputeODRHash(FirstExpr);\n        unsigned SecondODRHash = ComputeODRHash(SecondExpr);\n        if (FirstODRHash != SecondODRHash) {\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstExpr->getBeginLoc(),\n                           FirstExpr->getSourceRange(), StaticAssertCondition);\n          ODRDiagDeclNote(SecondModule, SecondExpr->getBeginLoc(),\n                          SecondExpr->getSourceRange(), StaticAssertCondition);\n          Diagnosed = true;\n          break;\n        }\n\n        StringLiteral *FirstStr = FirstSA->getMessage();\n        StringLiteral *SecondStr = SecondSA->getMessage();\n        assert((FirstStr || SecondStr) && \"Both messages cannot be empty\");\n        if ((FirstStr && !SecondStr) || (!FirstStr && SecondStr)) {\n          SourceLocation FirstLoc, SecondLoc;\n          SourceRange FirstRange, SecondRange;\n          if (FirstStr) {\n            FirstLoc = FirstStr->getBeginLoc();\n            FirstRange = FirstStr->getSourceRange();\n          } else {\n            FirstLoc = FirstSA->getBeginLoc();\n            FirstRange = FirstSA->getSourceRange();\n          }\n          if (SecondStr) {\n            SecondLoc = SecondStr->getBeginLoc();\n            SecondRange = SecondStr->getSourceRange();\n          } else {\n            SecondLoc = SecondSA->getBeginLoc();\n            SecondRange = SecondSA->getSourceRange();\n          }\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstLoc, FirstRange,\n                           StaticAssertOnlyMessage)\n              << (FirstStr == nullptr);\n          ODRDiagDeclNote(SecondModule, SecondLoc, SecondRange,\n                          StaticAssertOnlyMessage)\n              << (SecondStr == nullptr);\n          Diagnosed = true;\n          break;\n        }\n\n        if (FirstStr && SecondStr &&\n            FirstStr->getString() != SecondStr->getString()) {\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstStr->getBeginLoc(),\n                           FirstStr->getSourceRange(), StaticAssertMessage);\n          ODRDiagDeclNote(SecondModule, SecondStr->getBeginLoc(),\n                          SecondStr->getSourceRange(), StaticAssertMessage);\n          Diagnosed = true;\n          break;\n        }\n        break;\n      }\n      case Field: {\n        Diagnosed = ODRDiagField(FirstRecord, FirstModule, SecondModule,\n                                 cast<FieldDecl>(FirstDecl),\n                                 cast<FieldDecl>(SecondDecl));\n        break;\n      }\n      case CXXMethod: {\n        enum {\n          DiagMethod,\n          DiagConstructor,\n          DiagDestructor,\n        } FirstMethodType,\n            SecondMethodType;\n        auto GetMethodTypeForDiagnostics = [](const CXXMethodDecl* D) {\n          if (isa<CXXConstructorDecl>(D)) return DiagConstructor;\n          if (isa<CXXDestructorDecl>(D)) return DiagDestructor;\n          return DiagMethod;\n        };\n        const CXXMethodDecl *FirstMethod = cast<CXXMethodDecl>(FirstDecl);\n        const CXXMethodDecl *SecondMethod = cast<CXXMethodDecl>(SecondDecl);\n        FirstMethodType = GetMethodTypeForDiagnostics(FirstMethod);\n        SecondMethodType = GetMethodTypeForDiagnostics(SecondMethod);\n        auto FirstName = FirstMethod->getDeclName();\n        auto SecondName = SecondMethod->getDeclName();\n        if (FirstMethodType != SecondMethodType || FirstName != SecondName) {\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstMethod->getLocation(),\n                           FirstMethod->getSourceRange(), MethodName)\n              << FirstMethodType << FirstName;\n          ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                          SecondMethod->getSourceRange(), MethodName)\n              << SecondMethodType << SecondName;\n\n          Diagnosed = true;\n          break;\n        }\n\n        const bool FirstDeleted = FirstMethod->isDeletedAsWritten();\n        const bool SecondDeleted = SecondMethod->isDeletedAsWritten();\n        if (FirstDeleted != SecondDeleted) {\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstMethod->getLocation(),\n                           FirstMethod->getSourceRange(), MethodDeleted)\n              << FirstMethodType << FirstName << FirstDeleted;\n\n          ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                          SecondMethod->getSourceRange(), MethodDeleted)\n              << SecondMethodType << SecondName << SecondDeleted;\n          Diagnosed = true;\n          break;\n        }\n\n        const bool FirstDefaulted = FirstMethod->isExplicitlyDefaulted();\n        const bool SecondDefaulted = SecondMethod->isExplicitlyDefaulted();\n        if (FirstDefaulted != SecondDefaulted) {\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstMethod->getLocation(),\n                           FirstMethod->getSourceRange(), MethodDefaulted)\n              << FirstMethodType << FirstName << FirstDefaulted;\n\n          ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                          SecondMethod->getSourceRange(), MethodDefaulted)\n              << SecondMethodType << SecondName << SecondDefaulted;\n          Diagnosed = true;\n          break;\n        }\n\n        const bool FirstVirtual = FirstMethod->isVirtualAsWritten();\n        const bool SecondVirtual = SecondMethod->isVirtualAsWritten();\n        const bool FirstPure = FirstMethod->isPure();\n        const bool SecondPure = SecondMethod->isPure();\n        if ((FirstVirtual || SecondVirtual) &&\n            (FirstVirtual != SecondVirtual || FirstPure != SecondPure)) {\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstMethod->getLocation(),\n                           FirstMethod->getSourceRange(), MethodVirtual)\n              << FirstMethodType << FirstName << FirstPure << FirstVirtual;\n          ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                          SecondMethod->getSourceRange(), MethodVirtual)\n              << SecondMethodType << SecondName << SecondPure << SecondVirtual;\n          Diagnosed = true;\n          break;\n        }\n\n        // CXXMethodDecl::isStatic uses the canonical Decl.  With Decl merging,\n        // FirstDecl is the canonical Decl of SecondDecl, so the storage\n        // class needs to be checked instead.\n        const auto FirstStorage = FirstMethod->getStorageClass();\n        const auto SecondStorage = SecondMethod->getStorageClass();\n        const bool FirstStatic = FirstStorage == SC_Static;\n        const bool SecondStatic = SecondStorage == SC_Static;\n        if (FirstStatic != SecondStatic) {\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstMethod->getLocation(),\n                           FirstMethod->getSourceRange(), MethodStatic)\n              << FirstMethodType << FirstName << FirstStatic;\n          ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                          SecondMethod->getSourceRange(), MethodStatic)\n              << SecondMethodType << SecondName << SecondStatic;\n          Diagnosed = true;\n          break;\n        }\n\n        const bool FirstVolatile = FirstMethod->isVolatile();\n        const bool SecondVolatile = SecondMethod->isVolatile();\n        if (FirstVolatile != SecondVolatile) {\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstMethod->getLocation(),\n                           FirstMethod->getSourceRange(), MethodVolatile)\n              << FirstMethodType << FirstName << FirstVolatile;\n          ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                          SecondMethod->getSourceRange(), MethodVolatile)\n              << SecondMethodType << SecondName << SecondVolatile;\n          Diagnosed = true;\n          break;\n        }\n\n        const bool FirstConst = FirstMethod->isConst();\n        const bool SecondConst = SecondMethod->isConst();\n        if (FirstConst != SecondConst) {\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstMethod->getLocation(),\n                           FirstMethod->getSourceRange(), MethodConst)\n              << FirstMethodType << FirstName << FirstConst;\n          ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                          SecondMethod->getSourceRange(), MethodConst)\n              << SecondMethodType << SecondName << SecondConst;\n          Diagnosed = true;\n          break;\n        }\n\n        const bool FirstInline = FirstMethod->isInlineSpecified();\n        const bool SecondInline = SecondMethod->isInlineSpecified();\n        if (FirstInline != SecondInline) {\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstMethod->getLocation(),\n                           FirstMethod->getSourceRange(), MethodInline)\n              << FirstMethodType << FirstName << FirstInline;\n          ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                          SecondMethod->getSourceRange(), MethodInline)\n              << SecondMethodType << SecondName << SecondInline;\n          Diagnosed = true;\n          break;\n        }\n\n        const unsigned FirstNumParameters = FirstMethod->param_size();\n        const unsigned SecondNumParameters = SecondMethod->param_size();\n        if (FirstNumParameters != SecondNumParameters) {\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstMethod->getLocation(),\n                           FirstMethod->getSourceRange(),\n                           MethodNumberParameters)\n              << FirstMethodType << FirstName << FirstNumParameters;\n          ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                          SecondMethod->getSourceRange(),\n                          MethodNumberParameters)\n              << SecondMethodType << SecondName << SecondNumParameters;\n          Diagnosed = true;\n          break;\n        }\n\n        // Need this status boolean to know when break out of the switch.\n        bool ParameterMismatch = false;\n        for (unsigned I = 0; I < FirstNumParameters; ++I) {\n          const ParmVarDecl *FirstParam = FirstMethod->getParamDecl(I);\n          const ParmVarDecl *SecondParam = SecondMethod->getParamDecl(I);\n\n          QualType FirstParamType = FirstParam->getType();\n          QualType SecondParamType = SecondParam->getType();\n          if (FirstParamType != SecondParamType &&\n              ComputeQualTypeODRHash(FirstParamType) !=\n                  ComputeQualTypeODRHash(SecondParamType)) {\n            if (const DecayedType *ParamDecayedType =\n                    FirstParamType->getAs<DecayedType>()) {\n              ODRDiagDeclError(\n                  FirstRecord, FirstModule, FirstMethod->getLocation(),\n                  FirstMethod->getSourceRange(), MethodParameterType)\n                  << FirstMethodType << FirstName << (I + 1) << FirstParamType\n                  << true << ParamDecayedType->getOriginalType();\n            } else {\n              ODRDiagDeclError(\n                  FirstRecord, FirstModule, FirstMethod->getLocation(),\n                  FirstMethod->getSourceRange(), MethodParameterType)\n                  << FirstMethodType << FirstName << (I + 1) << FirstParamType\n                  << false;\n            }\n\n            if (const DecayedType *ParamDecayedType =\n                    SecondParamType->getAs<DecayedType>()) {\n              ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                              SecondMethod->getSourceRange(),\n                              MethodParameterType)\n                  << SecondMethodType << SecondName << (I + 1)\n                  << SecondParamType << true\n                  << ParamDecayedType->getOriginalType();\n            } else {\n              ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                              SecondMethod->getSourceRange(),\n                              MethodParameterType)\n                  << SecondMethodType << SecondName << (I + 1)\n                  << SecondParamType << false;\n            }\n            ParameterMismatch = true;\n            break;\n          }\n\n          DeclarationName FirstParamName = FirstParam->getDeclName();\n          DeclarationName SecondParamName = SecondParam->getDeclName();\n          if (FirstParamName != SecondParamName) {\n            ODRDiagDeclError(FirstRecord, FirstModule,\n                             FirstMethod->getLocation(),\n                             FirstMethod->getSourceRange(), MethodParameterName)\n                << FirstMethodType << FirstName << (I + 1) << FirstParamName;\n            ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                            SecondMethod->getSourceRange(), MethodParameterName)\n                << SecondMethodType << SecondName << (I + 1) << SecondParamName;\n            ParameterMismatch = true;\n            break;\n          }\n\n          const Expr *FirstInit = FirstParam->getInit();\n          const Expr *SecondInit = SecondParam->getInit();\n          if ((FirstInit == nullptr) != (SecondInit == nullptr)) {\n            ODRDiagDeclError(FirstRecord, FirstModule,\n                             FirstMethod->getLocation(),\n                             FirstMethod->getSourceRange(),\n                             MethodParameterSingleDefaultArgument)\n                << FirstMethodType << FirstName << (I + 1)\n                << (FirstInit == nullptr)\n                << (FirstInit ? FirstInit->getSourceRange() : SourceRange());\n            ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                            SecondMethod->getSourceRange(),\n                            MethodParameterSingleDefaultArgument)\n                << SecondMethodType << SecondName << (I + 1)\n                << (SecondInit == nullptr)\n                << (SecondInit ? SecondInit->getSourceRange() : SourceRange());\n            ParameterMismatch = true;\n            break;\n          }\n\n          if (FirstInit && SecondInit &&\n              ComputeODRHash(FirstInit) != ComputeODRHash(SecondInit)) {\n            ODRDiagDeclError(FirstRecord, FirstModule,\n                             FirstMethod->getLocation(),\n                             FirstMethod->getSourceRange(),\n                             MethodParameterDifferentDefaultArgument)\n                << FirstMethodType << FirstName << (I + 1)\n                << FirstInit->getSourceRange();\n            ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                            SecondMethod->getSourceRange(),\n                            MethodParameterDifferentDefaultArgument)\n                << SecondMethodType << SecondName << (I + 1)\n                << SecondInit->getSourceRange();\n            ParameterMismatch = true;\n            break;\n\n          }\n        }\n\n        if (ParameterMismatch) {\n          Diagnosed = true;\n          break;\n        }\n\n        const auto *FirstTemplateArgs =\n            FirstMethod->getTemplateSpecializationArgs();\n        const auto *SecondTemplateArgs =\n            SecondMethod->getTemplateSpecializationArgs();\n\n        if ((FirstTemplateArgs && !SecondTemplateArgs) ||\n            (!FirstTemplateArgs && SecondTemplateArgs)) {\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstMethod->getLocation(),\n                           FirstMethod->getSourceRange(),\n                           MethodNoTemplateArguments)\n              << FirstMethodType << FirstName << (FirstTemplateArgs != nullptr);\n          ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                          SecondMethod->getSourceRange(),\n                          MethodNoTemplateArguments)\n              << SecondMethodType << SecondName\n              << (SecondTemplateArgs != nullptr);\n\n          Diagnosed = true;\n          break;\n        }\n\n        if (FirstTemplateArgs && SecondTemplateArgs) {\n          // Remove pack expansions from argument list.\n          auto ExpandTemplateArgumentList =\n              [](const TemplateArgumentList *TAL) {\n                llvm::SmallVector<const TemplateArgument *, 8> ExpandedList;\n                for (const TemplateArgument &TA : TAL->asArray()) {\n                  if (TA.getKind() != TemplateArgument::Pack) {\n                    ExpandedList.push_back(&TA);\n                    continue;\n                  }\n                  for (const TemplateArgument &PackTA : TA.getPackAsArray()) {\n                    ExpandedList.push_back(&PackTA);\n                  }\n                }\n                return ExpandedList;\n              };\n          llvm::SmallVector<const TemplateArgument *, 8> FirstExpandedList =\n              ExpandTemplateArgumentList(FirstTemplateArgs);\n          llvm::SmallVector<const TemplateArgument *, 8> SecondExpandedList =\n              ExpandTemplateArgumentList(SecondTemplateArgs);\n\n          if (FirstExpandedList.size() != SecondExpandedList.size()) {\n            ODRDiagDeclError(FirstRecord, FirstModule,\n                             FirstMethod->getLocation(),\n                             FirstMethod->getSourceRange(),\n                             MethodDifferentNumberTemplateArguments)\n                << FirstMethodType << FirstName\n                << (unsigned)FirstExpandedList.size();\n            ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                            SecondMethod->getSourceRange(),\n                            MethodDifferentNumberTemplateArguments)\n                << SecondMethodType << SecondName\n                << (unsigned)SecondExpandedList.size();\n\n            Diagnosed = true;\n            break;\n          }\n\n          bool TemplateArgumentMismatch = false;\n          for (unsigned i = 0, e = FirstExpandedList.size(); i != e; ++i) {\n            const TemplateArgument &FirstTA = *FirstExpandedList[i],\n                                   &SecondTA = *SecondExpandedList[i];\n            if (ComputeTemplateArgumentODRHash(FirstTA) ==\n                ComputeTemplateArgumentODRHash(SecondTA)) {\n              continue;\n            }\n\n            ODRDiagDeclError(\n                FirstRecord, FirstModule, FirstMethod->getLocation(),\n                FirstMethod->getSourceRange(), MethodDifferentTemplateArgument)\n                << FirstMethodType << FirstName << FirstTA << i + 1;\n            ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                            SecondMethod->getSourceRange(),\n                            MethodDifferentTemplateArgument)\n                << SecondMethodType << SecondName << SecondTA << i + 1;\n\n            TemplateArgumentMismatch = true;\n            break;\n          }\n\n          if (TemplateArgumentMismatch) {\n            Diagnosed = true;\n            break;\n          }\n        }\n\n        // Compute the hash of the method as if it has no body.\n        auto ComputeCXXMethodODRHash = [&Hash](const CXXMethodDecl *D) {\n          Hash.clear();\n          Hash.AddFunctionDecl(D, true /*SkipBody*/);\n          return Hash.CalculateHash();\n        };\n\n        // Compare the hash generated to the hash stored.  A difference means\n        // that a body was present in the original source.  Due to merging,\n        // the stardard way of detecting a body will not work.\n        const bool HasFirstBody =\n            ComputeCXXMethodODRHash(FirstMethod) != FirstMethod->getODRHash();\n        const bool HasSecondBody =\n            ComputeCXXMethodODRHash(SecondMethod) != SecondMethod->getODRHash();\n\n        if (HasFirstBody != HasSecondBody) {\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstMethod->getLocation(),\n                           FirstMethod->getSourceRange(), MethodSingleBody)\n              << FirstMethodType << FirstName << HasFirstBody;\n          ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                          SecondMethod->getSourceRange(), MethodSingleBody)\n              << SecondMethodType << SecondName << HasSecondBody;\n          Diagnosed = true;\n          break;\n        }\n\n        if (HasFirstBody && HasSecondBody) {\n          ODRDiagDeclError(FirstRecord, FirstModule, FirstMethod->getLocation(),\n                           FirstMethod->getSourceRange(), MethodDifferentBody)\n              << FirstMethodType << FirstName;\n          ODRDiagDeclNote(SecondModule, SecondMethod->getLocation(),\n                          SecondMethod->getSourceRange(), MethodDifferentBody)\n              << SecondMethodType << SecondName;\n          Diagnosed = true;\n          break;\n        }\n\n        break;\n      }\n      case TypeAlias:\n      case TypeDef: {\n        Diagnosed = ODRDiagTypeDefOrAlias(\n            FirstRecord, FirstModule, SecondModule,\n            cast<TypedefNameDecl>(FirstDecl), cast<TypedefNameDecl>(SecondDecl),\n            FirstDiffType == TypeAlias);\n        break;\n      }\n      case Var: {\n        Diagnosed =\n            ODRDiagVar(FirstRecord, FirstModule, SecondModule,\n                       cast<VarDecl>(FirstDecl), cast<VarDecl>(SecondDecl));\n        break;\n      }\n      case Friend: {\n        FriendDecl *FirstFriend = cast<FriendDecl>(FirstDecl);\n        FriendDecl *SecondFriend = cast<FriendDecl>(SecondDecl);\n\n        NamedDecl *FirstND = FirstFriend->getFriendDecl();\n        NamedDecl *SecondND = SecondFriend->getFriendDecl();\n\n        TypeSourceInfo *FirstTSI = FirstFriend->getFriendType();\n        TypeSourceInfo *SecondTSI = SecondFriend->getFriendType();\n\n        if (FirstND && SecondND) {\n          ODRDiagDeclError(FirstRecord, FirstModule,\n                           FirstFriend->getFriendLoc(),\n                           FirstFriend->getSourceRange(), FriendFunction)\n              << FirstND;\n          ODRDiagDeclNote(SecondModule, SecondFriend->getFriendLoc(),\n                          SecondFriend->getSourceRange(), FriendFunction)\n              << SecondND;\n\n          Diagnosed = true;\n          break;\n        }\n\n        if (FirstTSI && SecondTSI) {\n          QualType FirstFriendType = FirstTSI->getType();\n          QualType SecondFriendType = SecondTSI->getType();\n          assert(ComputeQualTypeODRHash(FirstFriendType) !=\n                 ComputeQualTypeODRHash(SecondFriendType));\n          ODRDiagDeclError(FirstRecord, FirstModule,\n                           FirstFriend->getFriendLoc(),\n                           FirstFriend->getSourceRange(), FriendType)\n              << FirstFriendType;\n          ODRDiagDeclNote(SecondModule, SecondFriend->getFriendLoc(),\n                          SecondFriend->getSourceRange(), FriendType)\n              << SecondFriendType;\n          Diagnosed = true;\n          break;\n        }\n\n        ODRDiagDeclError(FirstRecord, FirstModule, FirstFriend->getFriendLoc(),\n                         FirstFriend->getSourceRange(), FriendTypeFunction)\n            << (FirstTSI == nullptr);\n        ODRDiagDeclNote(SecondModule, SecondFriend->getFriendLoc(),\n                        SecondFriend->getSourceRange(), FriendTypeFunction)\n            << (SecondTSI == nullptr);\n\n        Diagnosed = true;\n        break;\n      }\n      case FunctionTemplate: {\n        FunctionTemplateDecl *FirstTemplate =\n            cast<FunctionTemplateDecl>(FirstDecl);\n        FunctionTemplateDecl *SecondTemplate =\n            cast<FunctionTemplateDecl>(SecondDecl);\n\n        TemplateParameterList *FirstTPL =\n            FirstTemplate->getTemplateParameters();\n        TemplateParameterList *SecondTPL =\n            SecondTemplate->getTemplateParameters();\n\n        if (FirstTPL->size() != SecondTPL->size()) {\n          ODRDiagDeclError(FirstRecord, FirstModule,\n                           FirstTemplate->getLocation(),\n                           FirstTemplate->getSourceRange(),\n                           FunctionTemplateDifferentNumberParameters)\n              << FirstTemplate << FirstTPL->size();\n          ODRDiagDeclNote(SecondModule, SecondTemplate->getLocation(),\n                          SecondTemplate->getSourceRange(),\n                          FunctionTemplateDifferentNumberParameters)\n              << SecondTemplate << SecondTPL->size();\n\n          Diagnosed = true;\n          break;\n        }\n\n        bool ParameterMismatch = false;\n        for (unsigned i = 0, e = FirstTPL->size(); i != e; ++i) {\n          NamedDecl *FirstParam = FirstTPL->getParam(i);\n          NamedDecl *SecondParam = SecondTPL->getParam(i);\n\n          if (FirstParam->getKind() != SecondParam->getKind()) {\n            enum {\n              TemplateTypeParameter,\n              NonTypeTemplateParameter,\n              TemplateTemplateParameter,\n            };\n            auto GetParamType = [](NamedDecl *D) {\n              switch (D->getKind()) {\n                default:\n                  llvm_unreachable(\"Unexpected template parameter type\");\n                case Decl::TemplateTypeParm:\n                  return TemplateTypeParameter;\n                case Decl::NonTypeTemplateParm:\n                  return NonTypeTemplateParameter;\n                case Decl::TemplateTemplateParm:\n                  return TemplateTemplateParameter;\n              }\n            };\n\n            ODRDiagDeclError(FirstRecord, FirstModule,\n                             FirstTemplate->getLocation(),\n                             FirstTemplate->getSourceRange(),\n                             FunctionTemplateParameterDifferentKind)\n                << FirstTemplate << (i + 1) << GetParamType(FirstParam);\n            ODRDiagDeclNote(SecondModule, SecondTemplate->getLocation(),\n                            SecondTemplate->getSourceRange(),\n                            FunctionTemplateParameterDifferentKind)\n                << SecondTemplate << (i + 1) << GetParamType(SecondParam);\n\n            ParameterMismatch = true;\n            break;\n          }\n\n          if (FirstParam->getName() != SecondParam->getName()) {\n            ODRDiagDeclError(\n                FirstRecord, FirstModule, FirstTemplate->getLocation(),\n                FirstTemplate->getSourceRange(), FunctionTemplateParameterName)\n                << FirstTemplate << (i + 1) << (bool)FirstParam->getIdentifier()\n                << FirstParam;\n            ODRDiagDeclNote(SecondModule, SecondTemplate->getLocation(),\n                            SecondTemplate->getSourceRange(),\n                            FunctionTemplateParameterName)\n                << SecondTemplate << (i + 1)\n                << (bool)SecondParam->getIdentifier() << SecondParam;\n            ParameterMismatch = true;\n            break;\n          }\n\n          if (isa<TemplateTypeParmDecl>(FirstParam) &&\n              isa<TemplateTypeParmDecl>(SecondParam)) {\n            TemplateTypeParmDecl *FirstTTPD =\n                cast<TemplateTypeParmDecl>(FirstParam);\n            TemplateTypeParmDecl *SecondTTPD =\n                cast<TemplateTypeParmDecl>(SecondParam);\n            bool HasFirstDefaultArgument =\n                FirstTTPD->hasDefaultArgument() &&\n                !FirstTTPD->defaultArgumentWasInherited();\n            bool HasSecondDefaultArgument =\n                SecondTTPD->hasDefaultArgument() &&\n                !SecondTTPD->defaultArgumentWasInherited();\n            if (HasFirstDefaultArgument != HasSecondDefaultArgument) {\n              ODRDiagDeclError(FirstRecord, FirstModule,\n                               FirstTemplate->getLocation(),\n                               FirstTemplate->getSourceRange(),\n                               FunctionTemplateParameterSingleDefaultArgument)\n                  << FirstTemplate << (i + 1) << HasFirstDefaultArgument;\n              ODRDiagDeclNote(SecondModule, SecondTemplate->getLocation(),\n                              SecondTemplate->getSourceRange(),\n                              FunctionTemplateParameterSingleDefaultArgument)\n                  << SecondTemplate << (i + 1) << HasSecondDefaultArgument;\n              ParameterMismatch = true;\n              break;\n            }\n\n            if (HasFirstDefaultArgument && HasSecondDefaultArgument) {\n              QualType FirstType = FirstTTPD->getDefaultArgument();\n              QualType SecondType = SecondTTPD->getDefaultArgument();\n              if (ComputeQualTypeODRHash(FirstType) !=\n                  ComputeQualTypeODRHash(SecondType)) {\n                ODRDiagDeclError(\n                    FirstRecord, FirstModule, FirstTemplate->getLocation(),\n                    FirstTemplate->getSourceRange(),\n                    FunctionTemplateParameterDifferentDefaultArgument)\n                    << FirstTemplate << (i + 1) << FirstType;\n                ODRDiagDeclNote(\n                    SecondModule, SecondTemplate->getLocation(),\n                    SecondTemplate->getSourceRange(),\n                    FunctionTemplateParameterDifferentDefaultArgument)\n                    << SecondTemplate << (i + 1) << SecondType;\n                ParameterMismatch = true;\n                break;\n              }\n            }\n\n            if (FirstTTPD->isParameterPack() !=\n                SecondTTPD->isParameterPack()) {\n              ODRDiagDeclError(FirstRecord, FirstModule,\n                               FirstTemplate->getLocation(),\n                               FirstTemplate->getSourceRange(),\n                               FunctionTemplatePackParameter)\n                  << FirstTemplate << (i + 1) << FirstTTPD->isParameterPack();\n              ODRDiagDeclNote(SecondModule, SecondTemplate->getLocation(),\n                              SecondTemplate->getSourceRange(),\n                              FunctionTemplatePackParameter)\n                  << SecondTemplate << (i + 1) << SecondTTPD->isParameterPack();\n              ParameterMismatch = true;\n              break;\n            }\n          }\n\n          if (isa<TemplateTemplateParmDecl>(FirstParam) &&\n              isa<TemplateTemplateParmDecl>(SecondParam)) {\n            TemplateTemplateParmDecl *FirstTTPD =\n                cast<TemplateTemplateParmDecl>(FirstParam);\n            TemplateTemplateParmDecl *SecondTTPD =\n                cast<TemplateTemplateParmDecl>(SecondParam);\n\n            TemplateParameterList *FirstTPL =\n                FirstTTPD->getTemplateParameters();\n            TemplateParameterList *SecondTPL =\n                SecondTTPD->getTemplateParameters();\n\n            if (ComputeTemplateParameterListODRHash(FirstTPL) !=\n                ComputeTemplateParameterListODRHash(SecondTPL)) {\n              ODRDiagDeclError(FirstRecord, FirstModule,\n                               FirstTemplate->getLocation(),\n                               FirstTemplate->getSourceRange(),\n                               FunctionTemplateParameterDifferentType)\n                  << FirstTemplate << (i + 1);\n              ODRDiagDeclNote(SecondModule, SecondTemplate->getLocation(),\n                              SecondTemplate->getSourceRange(),\n                              FunctionTemplateParameterDifferentType)\n                  << SecondTemplate << (i + 1);\n              ParameterMismatch = true;\n              break;\n            }\n\n            bool HasFirstDefaultArgument =\n                FirstTTPD->hasDefaultArgument() &&\n                !FirstTTPD->defaultArgumentWasInherited();\n            bool HasSecondDefaultArgument =\n                SecondTTPD->hasDefaultArgument() &&\n                !SecondTTPD->defaultArgumentWasInherited();\n            if (HasFirstDefaultArgument != HasSecondDefaultArgument) {\n              ODRDiagDeclError(FirstRecord, FirstModule,\n                               FirstTemplate->getLocation(),\n                               FirstTemplate->getSourceRange(),\n                               FunctionTemplateParameterSingleDefaultArgument)\n                  << FirstTemplate << (i + 1) << HasFirstDefaultArgument;\n              ODRDiagDeclNote(SecondModule, SecondTemplate->getLocation(),\n                              SecondTemplate->getSourceRange(),\n                              FunctionTemplateParameterSingleDefaultArgument)\n                  << SecondTemplate << (i + 1) << HasSecondDefaultArgument;\n              ParameterMismatch = true;\n              break;\n            }\n\n            if (HasFirstDefaultArgument && HasSecondDefaultArgument) {\n              TemplateArgument FirstTA =\n                  FirstTTPD->getDefaultArgument().getArgument();\n              TemplateArgument SecondTA =\n                  SecondTTPD->getDefaultArgument().getArgument();\n              if (ComputeTemplateArgumentODRHash(FirstTA) !=\n                  ComputeTemplateArgumentODRHash(SecondTA)) {\n                ODRDiagDeclError(\n                    FirstRecord, FirstModule, FirstTemplate->getLocation(),\n                    FirstTemplate->getSourceRange(),\n                    FunctionTemplateParameterDifferentDefaultArgument)\n                    << FirstTemplate << (i + 1) << FirstTA;\n                ODRDiagDeclNote(\n                    SecondModule, SecondTemplate->getLocation(),\n                    SecondTemplate->getSourceRange(),\n                    FunctionTemplateParameterDifferentDefaultArgument)\n                    << SecondTemplate << (i + 1) << SecondTA;\n                ParameterMismatch = true;\n                break;\n              }\n            }\n\n            if (FirstTTPD->isParameterPack() !=\n                SecondTTPD->isParameterPack()) {\n              ODRDiagDeclError(FirstRecord, FirstModule,\n                               FirstTemplate->getLocation(),\n                               FirstTemplate->getSourceRange(),\n                               FunctionTemplatePackParameter)\n                  << FirstTemplate << (i + 1) << FirstTTPD->isParameterPack();\n              ODRDiagDeclNote(SecondModule, SecondTemplate->getLocation(),\n                              SecondTemplate->getSourceRange(),\n                              FunctionTemplatePackParameter)\n                  << SecondTemplate << (i + 1) << SecondTTPD->isParameterPack();\n              ParameterMismatch = true;\n              break;\n            }\n          }\n\n          if (isa<NonTypeTemplateParmDecl>(FirstParam) &&\n              isa<NonTypeTemplateParmDecl>(SecondParam)) {\n            NonTypeTemplateParmDecl *FirstNTTPD =\n                cast<NonTypeTemplateParmDecl>(FirstParam);\n            NonTypeTemplateParmDecl *SecondNTTPD =\n                cast<NonTypeTemplateParmDecl>(SecondParam);\n\n            QualType FirstType = FirstNTTPD->getType();\n            QualType SecondType = SecondNTTPD->getType();\n            if (ComputeQualTypeODRHash(FirstType) !=\n                ComputeQualTypeODRHash(SecondType)) {\n              ODRDiagDeclError(FirstRecord, FirstModule,\n                               FirstTemplate->getLocation(),\n                               FirstTemplate->getSourceRange(),\n                               FunctionTemplateParameterDifferentType)\n                  << FirstTemplate << (i + 1);\n              ODRDiagDeclNote(SecondModule, SecondTemplate->getLocation(),\n                              SecondTemplate->getSourceRange(),\n                              FunctionTemplateParameterDifferentType)\n                  << SecondTemplate << (i + 1);\n              ParameterMismatch = true;\n              break;\n            }\n\n            bool HasFirstDefaultArgument =\n                FirstNTTPD->hasDefaultArgument() &&\n                !FirstNTTPD->defaultArgumentWasInherited();\n            bool HasSecondDefaultArgument =\n                SecondNTTPD->hasDefaultArgument() &&\n                !SecondNTTPD->defaultArgumentWasInherited();\n            if (HasFirstDefaultArgument != HasSecondDefaultArgument) {\n              ODRDiagDeclError(FirstRecord, FirstModule,\n                               FirstTemplate->getLocation(),\n                               FirstTemplate->getSourceRange(),\n                               FunctionTemplateParameterSingleDefaultArgument)\n                  << FirstTemplate << (i + 1) << HasFirstDefaultArgument;\n              ODRDiagDeclNote(SecondModule, SecondTemplate->getLocation(),\n                              SecondTemplate->getSourceRange(),\n                              FunctionTemplateParameterSingleDefaultArgument)\n                  << SecondTemplate << (i + 1) << HasSecondDefaultArgument;\n              ParameterMismatch = true;\n              break;\n            }\n\n            if (HasFirstDefaultArgument && HasSecondDefaultArgument) {\n              Expr *FirstDefaultArgument = FirstNTTPD->getDefaultArgument();\n              Expr *SecondDefaultArgument = SecondNTTPD->getDefaultArgument();\n              if (ComputeODRHash(FirstDefaultArgument) !=\n                  ComputeODRHash(SecondDefaultArgument)) {\n                ODRDiagDeclError(\n                    FirstRecord, FirstModule, FirstTemplate->getLocation(),\n                    FirstTemplate->getSourceRange(),\n                    FunctionTemplateParameterDifferentDefaultArgument)\n                    << FirstTemplate << (i + 1) << FirstDefaultArgument;\n                ODRDiagDeclNote(\n                    SecondModule, SecondTemplate->getLocation(),\n                    SecondTemplate->getSourceRange(),\n                    FunctionTemplateParameterDifferentDefaultArgument)\n                    << SecondTemplate << (i + 1) << SecondDefaultArgument;\n                ParameterMismatch = true;\n                break;\n              }\n            }\n\n            if (FirstNTTPD->isParameterPack() !=\n                SecondNTTPD->isParameterPack()) {\n              ODRDiagDeclError(FirstRecord, FirstModule,\n                               FirstTemplate->getLocation(),\n                               FirstTemplate->getSourceRange(),\n                               FunctionTemplatePackParameter)\n                  << FirstTemplate << (i + 1) << FirstNTTPD->isParameterPack();\n              ODRDiagDeclNote(SecondModule, SecondTemplate->getLocation(),\n                              SecondTemplate->getSourceRange(),\n                              FunctionTemplatePackParameter)\n                  << SecondTemplate << (i + 1)\n                  << SecondNTTPD->isParameterPack();\n              ParameterMismatch = true;\n              break;\n            }\n          }\n        }\n\n        if (ParameterMismatch) {\n          Diagnosed = true;\n          break;\n        }\n\n        break;\n      }\n      }\n\n      if (Diagnosed)\n        continue;\n\n      Diag(FirstDecl->getLocation(),\n           diag::err_module_odr_violation_mismatch_decl_unknown)\n          << FirstRecord << FirstModule.empty() << FirstModule << FirstDiffType\n          << FirstDecl->getSourceRange();\n      Diag(SecondDecl->getLocation(),\n           diag::note_module_odr_violation_mismatch_decl_unknown)\n          << SecondModule << FirstDiffType << SecondDecl->getSourceRange();\n      Diagnosed = true;\n    }\n\n    if (!Diagnosed) {\n      // All definitions are updates to the same declaration. This happens if a\n      // module instantiates the declaration of a class template specialization\n      // and two or more other modules instantiate its definition.\n      //\n      // FIXME: Indicate which modules had instantiations of this definition.\n      // FIXME: How can this even happen?\n      Diag(Merge.first->getLocation(),\n           diag::err_module_odr_violation_different_instantiations)\n        << Merge.first;\n    }\n  }\n\n  // Issue ODR failures diagnostics for functions.\n  for (auto &Merge : FunctionOdrMergeFailures) {\n    enum ODRFunctionDifference {\n      ReturnType,\n      ParameterName,\n      ParameterType,\n      ParameterSingleDefaultArgument,\n      ParameterDifferentDefaultArgument,\n      FunctionBody,\n    };\n\n    FunctionDecl *FirstFunction = Merge.first;\n    std::string FirstModule = getOwningModuleNameForDiagnostic(FirstFunction);\n\n    bool Diagnosed = false;\n    for (auto &SecondFunction : Merge.second) {\n\n      if (FirstFunction == SecondFunction)\n        continue;\n\n      std::string SecondModule =\n          getOwningModuleNameForDiagnostic(SecondFunction);\n\n      auto ODRDiagError = [FirstFunction, &FirstModule,\n                           this](SourceLocation Loc, SourceRange Range,\n                                 ODRFunctionDifference DiffType) {\n        return Diag(Loc, diag::err_module_odr_violation_function)\n               << FirstFunction << FirstModule.empty() << FirstModule << Range\n               << DiffType;\n      };\n      auto ODRDiagNote = [&SecondModule, this](SourceLocation Loc,\n                                               SourceRange Range,\n                                               ODRFunctionDifference DiffType) {\n        return Diag(Loc, diag::note_module_odr_violation_function)\n               << SecondModule << Range << DiffType;\n      };\n\n      if (ComputeQualTypeODRHash(FirstFunction->getReturnType()) !=\n          ComputeQualTypeODRHash(SecondFunction->getReturnType())) {\n        ODRDiagError(FirstFunction->getReturnTypeSourceRange().getBegin(),\n                     FirstFunction->getReturnTypeSourceRange(), ReturnType)\n            << FirstFunction->getReturnType();\n        ODRDiagNote(SecondFunction->getReturnTypeSourceRange().getBegin(),\n                    SecondFunction->getReturnTypeSourceRange(), ReturnType)\n            << SecondFunction->getReturnType();\n        Diagnosed = true;\n        break;\n      }\n\n      assert(FirstFunction->param_size() == SecondFunction->param_size() &&\n             \"Merged functions with different number of parameters\");\n\n      auto ParamSize = FirstFunction->param_size();\n      bool ParameterMismatch = false;\n      for (unsigned I = 0; I < ParamSize; ++I) {\n        auto *FirstParam = FirstFunction->getParamDecl(I);\n        auto *SecondParam = SecondFunction->getParamDecl(I);\n\n        assert(getContext().hasSameType(FirstParam->getType(),\n                                      SecondParam->getType()) &&\n               \"Merged function has different parameter types.\");\n\n        if (FirstParam->getDeclName() != SecondParam->getDeclName()) {\n          ODRDiagError(FirstParam->getLocation(), FirstParam->getSourceRange(),\n                       ParameterName)\n              << I + 1 << FirstParam->getDeclName();\n          ODRDiagNote(SecondParam->getLocation(), SecondParam->getSourceRange(),\n                      ParameterName)\n              << I + 1 << SecondParam->getDeclName();\n          ParameterMismatch = true;\n          break;\n        };\n\n        QualType FirstParamType = FirstParam->getType();\n        QualType SecondParamType = SecondParam->getType();\n        if (FirstParamType != SecondParamType &&\n            ComputeQualTypeODRHash(FirstParamType) !=\n                ComputeQualTypeODRHash(SecondParamType)) {\n          if (const DecayedType *ParamDecayedType =\n                  FirstParamType->getAs<DecayedType>()) {\n            ODRDiagError(FirstParam->getLocation(),\n                         FirstParam->getSourceRange(), ParameterType)\n                << (I + 1) << FirstParamType << true\n                << ParamDecayedType->getOriginalType();\n          } else {\n            ODRDiagError(FirstParam->getLocation(),\n                         FirstParam->getSourceRange(), ParameterType)\n                << (I + 1) << FirstParamType << false;\n          }\n\n          if (const DecayedType *ParamDecayedType =\n                  SecondParamType->getAs<DecayedType>()) {\n            ODRDiagNote(SecondParam->getLocation(),\n                        SecondParam->getSourceRange(), ParameterType)\n                << (I + 1) << SecondParamType << true\n                << ParamDecayedType->getOriginalType();\n          } else {\n            ODRDiagNote(SecondParam->getLocation(),\n                        SecondParam->getSourceRange(), ParameterType)\n                << (I + 1) << SecondParamType << false;\n          }\n          ParameterMismatch = true;\n          break;\n        }\n\n        const Expr *FirstInit = FirstParam->getInit();\n        const Expr *SecondInit = SecondParam->getInit();\n        if ((FirstInit == nullptr) != (SecondInit == nullptr)) {\n          ODRDiagError(FirstParam->getLocation(), FirstParam->getSourceRange(),\n                       ParameterSingleDefaultArgument)\n              << (I + 1) << (FirstInit == nullptr)\n              << (FirstInit ? FirstInit->getSourceRange() : SourceRange());\n          ODRDiagNote(SecondParam->getLocation(), SecondParam->getSourceRange(),\n                      ParameterSingleDefaultArgument)\n              << (I + 1) << (SecondInit == nullptr)\n              << (SecondInit ? SecondInit->getSourceRange() : SourceRange());\n          ParameterMismatch = true;\n          break;\n        }\n\n        if (FirstInit && SecondInit &&\n            ComputeODRHash(FirstInit) != ComputeODRHash(SecondInit)) {\n          ODRDiagError(FirstParam->getLocation(), FirstParam->getSourceRange(),\n                       ParameterDifferentDefaultArgument)\n              << (I + 1) << FirstInit->getSourceRange();\n          ODRDiagNote(SecondParam->getLocation(), SecondParam->getSourceRange(),\n                      ParameterDifferentDefaultArgument)\n              << (I + 1) << SecondInit->getSourceRange();\n          ParameterMismatch = true;\n          break;\n        }\n\n        assert(ComputeSubDeclODRHash(FirstParam) ==\n                   ComputeSubDeclODRHash(SecondParam) &&\n               \"Undiagnosed parameter difference.\");\n      }\n\n      if (ParameterMismatch) {\n        Diagnosed = true;\n        break;\n      }\n\n      // If no error has been generated before now, assume the problem is in\n      // the body and generate a message.\n      ODRDiagError(FirstFunction->getLocation(),\n                   FirstFunction->getSourceRange(), FunctionBody);\n      ODRDiagNote(SecondFunction->getLocation(),\n                  SecondFunction->getSourceRange(), FunctionBody);\n      Diagnosed = true;\n      break;\n    }\n    (void)Diagnosed;\n    assert(Diagnosed && \"Unable to emit ODR diagnostic.\");\n  }\n\n  // Issue ODR failures diagnostics for enums.\n  for (auto &Merge : EnumOdrMergeFailures) {\n    enum ODREnumDifference {\n      SingleScopedEnum,\n      EnumTagKeywordMismatch,\n      SingleSpecifiedType,\n      DifferentSpecifiedTypes,\n      DifferentNumberEnumConstants,\n      EnumConstantName,\n      EnumConstantSingleInitilizer,\n      EnumConstantDifferentInitilizer,\n    };\n\n    // If we've already pointed out a specific problem with this enum, don't\n    // bother issuing a general \"something's different\" diagnostic.\n    if (!DiagnosedOdrMergeFailures.insert(Merge.first).second)\n      continue;\n\n    EnumDecl *FirstEnum = Merge.first;\n    std::string FirstModule = getOwningModuleNameForDiagnostic(FirstEnum);\n\n    using DeclHashes =\n        llvm::SmallVector<std::pair<EnumConstantDecl *, unsigned>, 4>;\n    auto PopulateHashes = [&ComputeSubDeclODRHash, FirstEnum](\n                              DeclHashes &Hashes, EnumDecl *Enum) {\n      for (auto *D : Enum->decls()) {\n        // Due to decl merging, the first EnumDecl is the parent of\n        // Decls in both records.\n        if (!ODRHash::isDeclToBeProcessed(D, FirstEnum))\n          continue;\n        assert(isa<EnumConstantDecl>(D) && \"Unexpected Decl kind\");\n        Hashes.emplace_back(cast<EnumConstantDecl>(D),\n                            ComputeSubDeclODRHash(D));\n      }\n    };\n    DeclHashes FirstHashes;\n    PopulateHashes(FirstHashes, FirstEnum);\n    bool Diagnosed = false;\n    for (auto &SecondEnum : Merge.second) {\n\n      if (FirstEnum == SecondEnum)\n        continue;\n\n      std::string SecondModule =\n          getOwningModuleNameForDiagnostic(SecondEnum);\n\n      auto ODRDiagError = [FirstEnum, &FirstModule,\n                           this](SourceLocation Loc, SourceRange Range,\n                                 ODREnumDifference DiffType) {\n        return Diag(Loc, diag::err_module_odr_violation_enum)\n               << FirstEnum << FirstModule.empty() << FirstModule << Range\n               << DiffType;\n      };\n      auto ODRDiagNote = [&SecondModule, this](SourceLocation Loc,\n                                               SourceRange Range,\n                                               ODREnumDifference DiffType) {\n        return Diag(Loc, diag::note_module_odr_violation_enum)\n               << SecondModule << Range << DiffType;\n      };\n\n      if (FirstEnum->isScoped() != SecondEnum->isScoped()) {\n        ODRDiagError(FirstEnum->getLocation(), FirstEnum->getSourceRange(),\n                     SingleScopedEnum)\n            << FirstEnum->isScoped();\n        ODRDiagNote(SecondEnum->getLocation(), SecondEnum->getSourceRange(),\n                    SingleScopedEnum)\n            << SecondEnum->isScoped();\n        Diagnosed = true;\n        continue;\n      }\n\n      if (FirstEnum->isScoped() && SecondEnum->isScoped()) {\n        if (FirstEnum->isScopedUsingClassTag() !=\n            SecondEnum->isScopedUsingClassTag()) {\n          ODRDiagError(FirstEnum->getLocation(), FirstEnum->getSourceRange(),\n                       EnumTagKeywordMismatch)\n              << FirstEnum->isScopedUsingClassTag();\n          ODRDiagNote(SecondEnum->getLocation(), SecondEnum->getSourceRange(),\n                      EnumTagKeywordMismatch)\n              << SecondEnum->isScopedUsingClassTag();\n          Diagnosed = true;\n          continue;\n        }\n      }\n\n      QualType FirstUnderlyingType =\n          FirstEnum->getIntegerTypeSourceInfo()\n              ? FirstEnum->getIntegerTypeSourceInfo()->getType()\n              : QualType();\n      QualType SecondUnderlyingType =\n          SecondEnum->getIntegerTypeSourceInfo()\n              ? SecondEnum->getIntegerTypeSourceInfo()->getType()\n              : QualType();\n      if (FirstUnderlyingType.isNull() != SecondUnderlyingType.isNull()) {\n          ODRDiagError(FirstEnum->getLocation(), FirstEnum->getSourceRange(),\n                       SingleSpecifiedType)\n              << !FirstUnderlyingType.isNull();\n          ODRDiagNote(SecondEnum->getLocation(), SecondEnum->getSourceRange(),\n                      SingleSpecifiedType)\n              << !SecondUnderlyingType.isNull();\n          Diagnosed = true;\n          continue;\n      }\n\n      if (!FirstUnderlyingType.isNull() && !SecondUnderlyingType.isNull()) {\n        if (ComputeQualTypeODRHash(FirstUnderlyingType) !=\n            ComputeQualTypeODRHash(SecondUnderlyingType)) {\n          ODRDiagError(FirstEnum->getLocation(), FirstEnum->getSourceRange(),\n                       DifferentSpecifiedTypes)\n              << FirstUnderlyingType;\n          ODRDiagNote(SecondEnum->getLocation(), SecondEnum->getSourceRange(),\n                      DifferentSpecifiedTypes)\n              << SecondUnderlyingType;\n          Diagnosed = true;\n          continue;\n        }\n      }\n\n      DeclHashes SecondHashes;\n      PopulateHashes(SecondHashes, SecondEnum);\n\n      if (FirstHashes.size() != SecondHashes.size()) {\n        ODRDiagError(FirstEnum->getLocation(), FirstEnum->getSourceRange(),\n                     DifferentNumberEnumConstants)\n            << (int)FirstHashes.size();\n        ODRDiagNote(SecondEnum->getLocation(), SecondEnum->getSourceRange(),\n                    DifferentNumberEnumConstants)\n            << (int)SecondHashes.size();\n        Diagnosed = true;\n        continue;\n      }\n\n      for (unsigned I = 0; I < FirstHashes.size(); ++I) {\n        if (FirstHashes[I].second == SecondHashes[I].second)\n          continue;\n        const EnumConstantDecl *FirstEnumConstant = FirstHashes[I].first;\n        const EnumConstantDecl *SecondEnumConstant = SecondHashes[I].first;\n\n        if (FirstEnumConstant->getDeclName() !=\n            SecondEnumConstant->getDeclName()) {\n\n          ODRDiagError(FirstEnumConstant->getLocation(),\n                       FirstEnumConstant->getSourceRange(), EnumConstantName)\n              << I + 1 << FirstEnumConstant;\n          ODRDiagNote(SecondEnumConstant->getLocation(),\n                      SecondEnumConstant->getSourceRange(), EnumConstantName)\n              << I + 1 << SecondEnumConstant;\n          Diagnosed = true;\n          break;\n        }\n\n        const Expr *FirstInit = FirstEnumConstant->getInitExpr();\n        const Expr *SecondInit = SecondEnumConstant->getInitExpr();\n        if (!FirstInit && !SecondInit)\n          continue;\n\n        if (!FirstInit || !SecondInit) {\n          ODRDiagError(FirstEnumConstant->getLocation(),\n                       FirstEnumConstant->getSourceRange(),\n                       EnumConstantSingleInitilizer)\n              << I + 1 << FirstEnumConstant << (FirstInit != nullptr);\n          ODRDiagNote(SecondEnumConstant->getLocation(),\n                      SecondEnumConstant->getSourceRange(),\n                      EnumConstantSingleInitilizer)\n              << I + 1 << SecondEnumConstant << (SecondInit != nullptr);\n          Diagnosed = true;\n          break;\n        }\n\n        if (ComputeODRHash(FirstInit) != ComputeODRHash(SecondInit)) {\n          ODRDiagError(FirstEnumConstant->getLocation(),\n                       FirstEnumConstant->getSourceRange(),\n                       EnumConstantDifferentInitilizer)\n              << I + 1 << FirstEnumConstant;\n          ODRDiagNote(SecondEnumConstant->getLocation(),\n                      SecondEnumConstant->getSourceRange(),\n                      EnumConstantDifferentInitilizer)\n              << I + 1 << SecondEnumConstant;\n          Diagnosed = true;\n          break;\n        }\n      }\n    }\n\n    (void)Diagnosed;\n    assert(Diagnosed && \"Unable to emit ODR diagnostic.\");\n  }\n}\n\nvoid ASTReader::StartedDeserializing() {\n  if (++NumCurrentElementsDeserializing == 1 && ReadTimer.get())\n    ReadTimer->startTimer();\n}\n\nvoid ASTReader::FinishedDeserializing() {\n  assert(NumCurrentElementsDeserializing &&\n         \"FinishedDeserializing not paired with StartedDeserializing\");\n  if (NumCurrentElementsDeserializing == 1) {\n    // We decrease NumCurrentElementsDeserializing only after pending actions\n    // are finished, to avoid recursively re-calling finishPendingActions().\n    finishPendingActions();\n  }\n  --NumCurrentElementsDeserializing;\n\n  if (NumCurrentElementsDeserializing == 0) {\n    // Propagate exception specification and deduced type updates along\n    // redeclaration chains.\n    //\n    // We do this now rather than in finishPendingActions because we want to\n    // be able to walk the complete redeclaration chains of the updated decls.\n    while (!PendingExceptionSpecUpdates.empty() ||\n           !PendingDeducedTypeUpdates.empty()) {\n      auto ESUpdates = std::move(PendingExceptionSpecUpdates);\n      PendingExceptionSpecUpdates.clear();\n      for (auto Update : ESUpdates) {\n        ProcessingUpdatesRAIIObj ProcessingUpdates(*this);\n        auto *FPT = Update.second->getType()->castAs<FunctionProtoType>();\n        auto ESI = FPT->getExtProtoInfo().ExceptionSpec;\n        if (auto *Listener = getContext().getASTMutationListener())\n          Listener->ResolvedExceptionSpec(cast<FunctionDecl>(Update.second));\n        for (auto *Redecl : Update.second->redecls())\n          getContext().adjustExceptionSpec(cast<FunctionDecl>(Redecl), ESI);\n      }\n\n      auto DTUpdates = std::move(PendingDeducedTypeUpdates);\n      PendingDeducedTypeUpdates.clear();\n      for (auto Update : DTUpdates) {\n        ProcessingUpdatesRAIIObj ProcessingUpdates(*this);\n        // FIXME: If the return type is already deduced, check that it matches.\n        getContext().adjustDeducedFunctionResultType(Update.first,\n                                                     Update.second);\n      }\n    }\n\n    if (ReadTimer)\n      ReadTimer->stopTimer();\n\n    diagnoseOdrViolations();\n\n    // We are not in recursive loading, so it's safe to pass the \"interesting\"\n    // decls to the consumer.\n    if (Consumer)\n      PassInterestingDeclsToConsumer();\n  }\n}\n\nvoid ASTReader::pushExternalDeclIntoScope(NamedDecl *D, DeclarationName Name) {\n  if (IdentifierInfo *II = Name.getAsIdentifierInfo()) {\n    // Remove any fake results before adding any real ones.\n    auto It = PendingFakeLookupResults.find(II);\n    if (It != PendingFakeLookupResults.end()) {\n      for (auto *ND : It->second)\n        SemaObj->IdResolver.RemoveDecl(ND);\n      // FIXME: this works around module+PCH performance issue.\n      // Rather than erase the result from the map, which is O(n), just clear\n      // the vector of NamedDecls.\n      It->second.clear();\n    }\n  }\n\n  if (SemaObj->IdResolver.tryAddTopLevelDecl(D, Name) && SemaObj->TUScope) {\n    SemaObj->TUScope->AddDecl(D);\n  } else if (SemaObj->TUScope) {\n    // Adding the decl to IdResolver may have failed because it was already in\n    // (even though it was not added in scope). If it is already in, make sure\n    // it gets in the scope as well.\n    if (std::find(SemaObj->IdResolver.begin(Name),\n                  SemaObj->IdResolver.end(), D) != SemaObj->IdResolver.end())\n      SemaObj->TUScope->AddDecl(D);\n  }\n}\n\nASTReader::ASTReader(Preprocessor &PP, InMemoryModuleCache &ModuleCache,\n                     ASTContext *Context,\n                     const PCHContainerReader &PCHContainerRdr,\n                     ArrayRef<std::shared_ptr<ModuleFileExtension>> Extensions,\n                     StringRef isysroot,\n                     DisableValidationForModuleKind DisableValidationKind,\n                     bool AllowASTWithCompilerErrors,\n                     bool AllowConfigurationMismatch, bool ValidateSystemInputs,\n                     bool ValidateASTInputFilesContent, bool UseGlobalIndex,\n                     std::unique_ptr<llvm::Timer> ReadTimer)\n    : Listener(bool(DisableValidationKind &DisableValidationForModuleKind::PCH)\n                   ? cast<ASTReaderListener>(new SimpleASTReaderListener(PP))\n                   : cast<ASTReaderListener>(new PCHValidator(PP, *this))),\n      SourceMgr(PP.getSourceManager()), FileMgr(PP.getFileManager()),\n      PCHContainerRdr(PCHContainerRdr), Diags(PP.getDiagnostics()), PP(PP),\n      ContextObj(Context), ModuleMgr(PP.getFileManager(), ModuleCache,\n                                     PCHContainerRdr, PP.getHeaderSearchInfo()),\n      DummyIdResolver(PP), ReadTimer(std::move(ReadTimer)), isysroot(isysroot),\n      DisableValidationKind(DisableValidationKind),\n      AllowASTWithCompilerErrors(AllowASTWithCompilerErrors),\n      AllowConfigurationMismatch(AllowConfigurationMismatch),\n      ValidateSystemInputs(ValidateSystemInputs),\n      ValidateASTInputFilesContent(ValidateASTInputFilesContent),\n      UseGlobalIndex(UseGlobalIndex), CurrSwitchCaseStmts(&SwitchCaseStmts) {\n  SourceMgr.setExternalSLocEntrySource(this);\n\n  for (const auto &Ext : Extensions) {\n    auto BlockName = Ext->getExtensionMetadata().BlockName;\n    auto Known = ModuleFileExtensions.find(BlockName);\n    if (Known != ModuleFileExtensions.end()) {\n      Diags.Report(diag::warn_duplicate_module_file_extension)\n        << BlockName;\n      continue;\n    }\n\n    ModuleFileExtensions.insert({BlockName, Ext});\n  }\n}\n\nASTReader::~ASTReader() {\n  if (OwnsDeserializationListener)\n    delete DeserializationListener;\n}\n\nIdentifierResolver &ASTReader::getIdResolver() {\n  return SemaObj ? SemaObj->IdResolver : DummyIdResolver;\n}\n\nExpected<unsigned> ASTRecordReader::readRecord(llvm::BitstreamCursor &Cursor,\n                                               unsigned AbbrevID) {\n  Idx = 0;\n  Record.clear();\n  return Cursor.readRecord(AbbrevID, Record);\n}\n//===----------------------------------------------------------------------===//\n//// OMPClauseReader implementation\n////===----------------------------------------------------------------------===//\n\n// This has to be in namespace clang because it's friended by all\n// of the OMP clauses.\nnamespace clang {\n\nclass OMPClauseReader : public OMPClauseVisitor<OMPClauseReader> {\n  ASTRecordReader &Record;\n  ASTContext &Context;\n\npublic:\n  OMPClauseReader(ASTRecordReader &Record)\n      : Record(Record), Context(Record.getContext()) {}\n#define GEN_CLANG_CLAUSE_CLASS\n#define CLAUSE_CLASS(Enum, Str, Class) void Visit##Class(Class *C);\n#include \"llvm/Frontend/OpenMP/OMP.inc\"\n  OMPClause *readClause();\n  void VisitOMPClauseWithPreInit(OMPClauseWithPreInit *C);\n  void VisitOMPClauseWithPostUpdate(OMPClauseWithPostUpdate *C);\n};\n\n} // end namespace clang\n\nOMPClause *ASTRecordReader::readOMPClause() {\n  return OMPClauseReader(*this).readClause();\n}\n\nOMPClause *OMPClauseReader::readClause() {\n  OMPClause *C = nullptr;\n  switch (llvm::omp::Clause(Record.readInt())) {\n  case llvm::omp::OMPC_if:\n    C = new (Context) OMPIfClause();\n    break;\n  case llvm::omp::OMPC_final:\n    C = new (Context) OMPFinalClause();\n    break;\n  case llvm::omp::OMPC_num_threads:\n    C = new (Context) OMPNumThreadsClause();\n    break;\n  case llvm::omp::OMPC_safelen:\n    C = new (Context) OMPSafelenClause();\n    break;\n  case llvm::omp::OMPC_simdlen:\n    C = new (Context) OMPSimdlenClause();\n    break;\n  case llvm::omp::OMPC_sizes: {\n    unsigned NumSizes = Record.readInt();\n    C = OMPSizesClause::CreateEmpty(Context, NumSizes);\n    break;\n  }\n  case llvm::omp::OMPC_allocator:\n    C = new (Context) OMPAllocatorClause();\n    break;\n  case llvm::omp::OMPC_collapse:\n    C = new (Context) OMPCollapseClause();\n    break;\n  case llvm::omp::OMPC_default:\n    C = new (Context) OMPDefaultClause();\n    break;\n  case llvm::omp::OMPC_proc_bind:\n    C = new (Context) OMPProcBindClause();\n    break;\n  case llvm::omp::OMPC_schedule:\n    C = new (Context) OMPScheduleClause();\n    break;\n  case llvm::omp::OMPC_ordered:\n    C = OMPOrderedClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_nowait:\n    C = new (Context) OMPNowaitClause();\n    break;\n  case llvm::omp::OMPC_untied:\n    C = new (Context) OMPUntiedClause();\n    break;\n  case llvm::omp::OMPC_mergeable:\n    C = new (Context) OMPMergeableClause();\n    break;\n  case llvm::omp::OMPC_read:\n    C = new (Context) OMPReadClause();\n    break;\n  case llvm::omp::OMPC_write:\n    C = new (Context) OMPWriteClause();\n    break;\n  case llvm::omp::OMPC_update:\n    C = OMPUpdateClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_capture:\n    C = new (Context) OMPCaptureClause();\n    break;\n  case llvm::omp::OMPC_seq_cst:\n    C = new (Context) OMPSeqCstClause();\n    break;\n  case llvm::omp::OMPC_acq_rel:\n    C = new (Context) OMPAcqRelClause();\n    break;\n  case llvm::omp::OMPC_acquire:\n    C = new (Context) OMPAcquireClause();\n    break;\n  case llvm::omp::OMPC_release:\n    C = new (Context) OMPReleaseClause();\n    break;\n  case llvm::omp::OMPC_relaxed:\n    C = new (Context) OMPRelaxedClause();\n    break;\n  case llvm::omp::OMPC_threads:\n    C = new (Context) OMPThreadsClause();\n    break;\n  case llvm::omp::OMPC_simd:\n    C = new (Context) OMPSIMDClause();\n    break;\n  case llvm::omp::OMPC_nogroup:\n    C = new (Context) OMPNogroupClause();\n    break;\n  case llvm::omp::OMPC_unified_address:\n    C = new (Context) OMPUnifiedAddressClause();\n    break;\n  case llvm::omp::OMPC_unified_shared_memory:\n    C = new (Context) OMPUnifiedSharedMemoryClause();\n    break;\n  case llvm::omp::OMPC_reverse_offload:\n    C = new (Context) OMPReverseOffloadClause();\n    break;\n  case llvm::omp::OMPC_dynamic_allocators:\n    C = new (Context) OMPDynamicAllocatorsClause();\n    break;\n  case llvm::omp::OMPC_atomic_default_mem_order:\n    C = new (Context) OMPAtomicDefaultMemOrderClause();\n    break;\n case llvm::omp::OMPC_private:\n    C = OMPPrivateClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_firstprivate:\n    C = OMPFirstprivateClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_lastprivate:\n    C = OMPLastprivateClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_shared:\n    C = OMPSharedClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_reduction: {\n    unsigned N = Record.readInt();\n    auto Modifier = Record.readEnum<OpenMPReductionClauseModifier>();\n    C = OMPReductionClause::CreateEmpty(Context, N, Modifier);\n    break;\n  }\n  case llvm::omp::OMPC_task_reduction:\n    C = OMPTaskReductionClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_in_reduction:\n    C = OMPInReductionClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_linear:\n    C = OMPLinearClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_aligned:\n    C = OMPAlignedClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_copyin:\n    C = OMPCopyinClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_copyprivate:\n    C = OMPCopyprivateClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_flush:\n    C = OMPFlushClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_depobj:\n    C = OMPDepobjClause::CreateEmpty(Context);\n    break;\n  case llvm::omp::OMPC_depend: {\n    unsigned NumVars = Record.readInt();\n    unsigned NumLoops = Record.readInt();\n    C = OMPDependClause::CreateEmpty(Context, NumVars, NumLoops);\n    break;\n  }\n  case llvm::omp::OMPC_device:\n    C = new (Context) OMPDeviceClause();\n    break;\n  case llvm::omp::OMPC_map: {\n    OMPMappableExprListSizeTy Sizes;\n    Sizes.NumVars = Record.readInt();\n    Sizes.NumUniqueDeclarations = Record.readInt();\n    Sizes.NumComponentLists = Record.readInt();\n    Sizes.NumComponents = Record.readInt();\n    C = OMPMapClause::CreateEmpty(Context, Sizes);\n    break;\n  }\n  case llvm::omp::OMPC_num_teams:\n    C = new (Context) OMPNumTeamsClause();\n    break;\n  case llvm::omp::OMPC_thread_limit:\n    C = new (Context) OMPThreadLimitClause();\n    break;\n  case llvm::omp::OMPC_priority:\n    C = new (Context) OMPPriorityClause();\n    break;\n  case llvm::omp::OMPC_grainsize:\n    C = new (Context) OMPGrainsizeClause();\n    break;\n  case llvm::omp::OMPC_num_tasks:\n    C = new (Context) OMPNumTasksClause();\n    break;\n  case llvm::omp::OMPC_hint:\n    C = new (Context) OMPHintClause();\n    break;\n  case llvm::omp::OMPC_dist_schedule:\n    C = new (Context) OMPDistScheduleClause();\n    break;\n  case llvm::omp::OMPC_defaultmap:\n    C = new (Context) OMPDefaultmapClause();\n    break;\n  case llvm::omp::OMPC_to: {\n    OMPMappableExprListSizeTy Sizes;\n    Sizes.NumVars = Record.readInt();\n    Sizes.NumUniqueDeclarations = Record.readInt();\n    Sizes.NumComponentLists = Record.readInt();\n    Sizes.NumComponents = Record.readInt();\n    C = OMPToClause::CreateEmpty(Context, Sizes);\n    break;\n  }\n  case llvm::omp::OMPC_from: {\n    OMPMappableExprListSizeTy Sizes;\n    Sizes.NumVars = Record.readInt();\n    Sizes.NumUniqueDeclarations = Record.readInt();\n    Sizes.NumComponentLists = Record.readInt();\n    Sizes.NumComponents = Record.readInt();\n    C = OMPFromClause::CreateEmpty(Context, Sizes);\n    break;\n  }\n  case llvm::omp::OMPC_use_device_ptr: {\n    OMPMappableExprListSizeTy Sizes;\n    Sizes.NumVars = Record.readInt();\n    Sizes.NumUniqueDeclarations = Record.readInt();\n    Sizes.NumComponentLists = Record.readInt();\n    Sizes.NumComponents = Record.readInt();\n    C = OMPUseDevicePtrClause::CreateEmpty(Context, Sizes);\n    break;\n  }\n  case llvm::omp::OMPC_use_device_addr: {\n    OMPMappableExprListSizeTy Sizes;\n    Sizes.NumVars = Record.readInt();\n    Sizes.NumUniqueDeclarations = Record.readInt();\n    Sizes.NumComponentLists = Record.readInt();\n    Sizes.NumComponents = Record.readInt();\n    C = OMPUseDeviceAddrClause::CreateEmpty(Context, Sizes);\n    break;\n  }\n  case llvm::omp::OMPC_is_device_ptr: {\n    OMPMappableExprListSizeTy Sizes;\n    Sizes.NumVars = Record.readInt();\n    Sizes.NumUniqueDeclarations = Record.readInt();\n    Sizes.NumComponentLists = Record.readInt();\n    Sizes.NumComponents = Record.readInt();\n    C = OMPIsDevicePtrClause::CreateEmpty(Context, Sizes);\n    break;\n  }\n  case llvm::omp::OMPC_allocate:\n    C = OMPAllocateClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_nontemporal:\n    C = OMPNontemporalClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_inclusive:\n    C = OMPInclusiveClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_exclusive:\n    C = OMPExclusiveClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_order:\n    C = new (Context) OMPOrderClause();\n    break;\n  case llvm::omp::OMPC_destroy:\n    C = new (Context) OMPDestroyClause();\n    break;\n  case llvm::omp::OMPC_detach:\n    C = new (Context) OMPDetachClause();\n    break;\n  case llvm::omp::OMPC_uses_allocators:\n    C = OMPUsesAllocatorsClause::CreateEmpty(Context, Record.readInt());\n    break;\n  case llvm::omp::OMPC_affinity:\n    C = OMPAffinityClause::CreateEmpty(Context, Record.readInt());\n    break;\n#define OMP_CLAUSE_NO_CLASS(Enum, Str)                                         \\\n  case llvm::omp::Enum:                                                        \\\n    break;\n#include \"llvm/Frontend/OpenMP/OMPKinds.def\"\n  default:\n    break;\n  }\n  assert(C && \"Unknown OMPClause type\");\n\n  Visit(C);\n  C->setLocStart(Record.readSourceLocation());\n  C->setLocEnd(Record.readSourceLocation());\n\n  return C;\n}\n\nvoid OMPClauseReader::VisitOMPClauseWithPreInit(OMPClauseWithPreInit *C) {\n  C->setPreInitStmt(Record.readSubStmt(),\n                    static_cast<OpenMPDirectiveKind>(Record.readInt()));\n}\n\nvoid OMPClauseReader::VisitOMPClauseWithPostUpdate(OMPClauseWithPostUpdate *C) {\n  VisitOMPClauseWithPreInit(C);\n  C->setPostUpdateExpr(Record.readSubExpr());\n}\n\nvoid OMPClauseReader::VisitOMPIfClause(OMPIfClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  C->setNameModifier(static_cast<OpenMPDirectiveKind>(Record.readInt()));\n  C->setNameModifierLoc(Record.readSourceLocation());\n  C->setColonLoc(Record.readSourceLocation());\n  C->setCondition(Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPFinalClause(OMPFinalClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  C->setCondition(Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPNumThreadsClause(OMPNumThreadsClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  C->setNumThreads(Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPSafelenClause(OMPSafelenClause *C) {\n  C->setSafelen(Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPSimdlenClause(OMPSimdlenClause *C) {\n  C->setSimdlen(Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPSizesClause(OMPSizesClause *C) {\n  for (Expr *&E : C->getSizesRefs())\n    E = Record.readSubExpr();\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPAllocatorClause(OMPAllocatorClause *C) {\n  C->setAllocator(Record.readExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPCollapseClause(OMPCollapseClause *C) {\n  C->setNumForLoops(Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPDefaultClause(OMPDefaultClause *C) {\n  C->setDefaultKind(static_cast<llvm::omp::DefaultKind>(Record.readInt()));\n  C->setLParenLoc(Record.readSourceLocation());\n  C->setDefaultKindKwLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPProcBindClause(OMPProcBindClause *C) {\n  C->setProcBindKind(static_cast<llvm::omp::ProcBindKind>(Record.readInt()));\n  C->setLParenLoc(Record.readSourceLocation());\n  C->setProcBindKindKwLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPScheduleClause(OMPScheduleClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  C->setScheduleKind(\n       static_cast<OpenMPScheduleClauseKind>(Record.readInt()));\n  C->setFirstScheduleModifier(\n      static_cast<OpenMPScheduleClauseModifier>(Record.readInt()));\n  C->setSecondScheduleModifier(\n      static_cast<OpenMPScheduleClauseModifier>(Record.readInt()));\n  C->setChunkSize(Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n  C->setFirstScheduleModifierLoc(Record.readSourceLocation());\n  C->setSecondScheduleModifierLoc(Record.readSourceLocation());\n  C->setScheduleKindLoc(Record.readSourceLocation());\n  C->setCommaLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPOrderedClause(OMPOrderedClause *C) {\n  C->setNumForLoops(Record.readSubExpr());\n  for (unsigned I = 0, E = C->NumberOfLoops; I < E; ++I)\n    C->setLoopNumIterations(I, Record.readSubExpr());\n  for (unsigned I = 0, E = C->NumberOfLoops; I < E; ++I)\n    C->setLoopCounter(I, Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPDetachClause(OMPDetachClause *C) {\n  C->setEventHandler(Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPNowaitClause(OMPNowaitClause *) {}\n\nvoid OMPClauseReader::VisitOMPUntiedClause(OMPUntiedClause *) {}\n\nvoid OMPClauseReader::VisitOMPMergeableClause(OMPMergeableClause *) {}\n\nvoid OMPClauseReader::VisitOMPReadClause(OMPReadClause *) {}\n\nvoid OMPClauseReader::VisitOMPWriteClause(OMPWriteClause *) {}\n\nvoid OMPClauseReader::VisitOMPUpdateClause(OMPUpdateClause *C) {\n  if (C->isExtended()) {\n    C->setLParenLoc(Record.readSourceLocation());\n    C->setArgumentLoc(Record.readSourceLocation());\n    C->setDependencyKind(Record.readEnum<OpenMPDependClauseKind>());\n  }\n}\n\nvoid OMPClauseReader::VisitOMPCaptureClause(OMPCaptureClause *) {}\n\nvoid OMPClauseReader::VisitOMPSeqCstClause(OMPSeqCstClause *) {}\n\nvoid OMPClauseReader::VisitOMPAcqRelClause(OMPAcqRelClause *) {}\n\nvoid OMPClauseReader::VisitOMPAcquireClause(OMPAcquireClause *) {}\n\nvoid OMPClauseReader::VisitOMPReleaseClause(OMPReleaseClause *) {}\n\nvoid OMPClauseReader::VisitOMPRelaxedClause(OMPRelaxedClause *) {}\n\nvoid OMPClauseReader::VisitOMPThreadsClause(OMPThreadsClause *) {}\n\nvoid OMPClauseReader::VisitOMPSIMDClause(OMPSIMDClause *) {}\n\nvoid OMPClauseReader::VisitOMPNogroupClause(OMPNogroupClause *) {}\n\nvoid OMPClauseReader::VisitOMPDestroyClause(OMPDestroyClause *) {}\n\nvoid OMPClauseReader::VisitOMPUnifiedAddressClause(OMPUnifiedAddressClause *) {}\n\nvoid OMPClauseReader::VisitOMPUnifiedSharedMemoryClause(\n    OMPUnifiedSharedMemoryClause *) {}\n\nvoid OMPClauseReader::VisitOMPReverseOffloadClause(OMPReverseOffloadClause *) {}\n\nvoid\nOMPClauseReader::VisitOMPDynamicAllocatorsClause(OMPDynamicAllocatorsClause *) {\n}\n\nvoid OMPClauseReader::VisitOMPAtomicDefaultMemOrderClause(\n    OMPAtomicDefaultMemOrderClause *C) {\n  C->setAtomicDefaultMemOrderKind(\n      static_cast<OpenMPAtomicDefaultMemOrderClauseKind>(Record.readInt()));\n  C->setLParenLoc(Record.readSourceLocation());\n  C->setAtomicDefaultMemOrderKindKwLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPPrivateClause(OMPPrivateClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setPrivateCopies(Vars);\n}\n\nvoid OMPClauseReader::VisitOMPFirstprivateClause(OMPFirstprivateClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  C->setLParenLoc(Record.readSourceLocation());\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setPrivateCopies(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setInits(Vars);\n}\n\nvoid OMPClauseReader::VisitOMPLastprivateClause(OMPLastprivateClause *C) {\n  VisitOMPClauseWithPostUpdate(C);\n  C->setLParenLoc(Record.readSourceLocation());\n  C->setKind(Record.readEnum<OpenMPLastprivateModifier>());\n  C->setKindLoc(Record.readSourceLocation());\n  C->setColonLoc(Record.readSourceLocation());\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setPrivateCopies(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setSourceExprs(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setDestinationExprs(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setAssignmentOps(Vars);\n}\n\nvoid OMPClauseReader::VisitOMPSharedClause(OMPSharedClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n}\n\nvoid OMPClauseReader::VisitOMPReductionClause(OMPReductionClause *C) {\n  VisitOMPClauseWithPostUpdate(C);\n  C->setLParenLoc(Record.readSourceLocation());\n  C->setModifierLoc(Record.readSourceLocation());\n  C->setColonLoc(Record.readSourceLocation());\n  NestedNameSpecifierLoc NNSL = Record.readNestedNameSpecifierLoc();\n  DeclarationNameInfo DNI = Record.readDeclarationNameInfo();\n  C->setQualifierLoc(NNSL);\n  C->setNameInfo(DNI);\n\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setPrivates(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setLHSExprs(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setRHSExprs(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setReductionOps(Vars);\n  if (C->getModifier() == OMPC_REDUCTION_inscan) {\n    Vars.clear();\n    for (unsigned i = 0; i != NumVars; ++i)\n      Vars.push_back(Record.readSubExpr());\n    C->setInscanCopyOps(Vars);\n    Vars.clear();\n    for (unsigned i = 0; i != NumVars; ++i)\n      Vars.push_back(Record.readSubExpr());\n    C->setInscanCopyArrayTemps(Vars);\n    Vars.clear();\n    for (unsigned i = 0; i != NumVars; ++i)\n      Vars.push_back(Record.readSubExpr());\n    C->setInscanCopyArrayElems(Vars);\n  }\n}\n\nvoid OMPClauseReader::VisitOMPTaskReductionClause(OMPTaskReductionClause *C) {\n  VisitOMPClauseWithPostUpdate(C);\n  C->setLParenLoc(Record.readSourceLocation());\n  C->setColonLoc(Record.readSourceLocation());\n  NestedNameSpecifierLoc NNSL = Record.readNestedNameSpecifierLoc();\n  DeclarationNameInfo DNI = Record.readDeclarationNameInfo();\n  C->setQualifierLoc(NNSL);\n  C->setNameInfo(DNI);\n\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned I = 0; I != NumVars; ++I)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n  Vars.clear();\n  for (unsigned I = 0; I != NumVars; ++I)\n    Vars.push_back(Record.readSubExpr());\n  C->setPrivates(Vars);\n  Vars.clear();\n  for (unsigned I = 0; I != NumVars; ++I)\n    Vars.push_back(Record.readSubExpr());\n  C->setLHSExprs(Vars);\n  Vars.clear();\n  for (unsigned I = 0; I != NumVars; ++I)\n    Vars.push_back(Record.readSubExpr());\n  C->setRHSExprs(Vars);\n  Vars.clear();\n  for (unsigned I = 0; I != NumVars; ++I)\n    Vars.push_back(Record.readSubExpr());\n  C->setReductionOps(Vars);\n}\n\nvoid OMPClauseReader::VisitOMPInReductionClause(OMPInReductionClause *C) {\n  VisitOMPClauseWithPostUpdate(C);\n  C->setLParenLoc(Record.readSourceLocation());\n  C->setColonLoc(Record.readSourceLocation());\n  NestedNameSpecifierLoc NNSL = Record.readNestedNameSpecifierLoc();\n  DeclarationNameInfo DNI = Record.readDeclarationNameInfo();\n  C->setQualifierLoc(NNSL);\n  C->setNameInfo(DNI);\n\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned I = 0; I != NumVars; ++I)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n  Vars.clear();\n  for (unsigned I = 0; I != NumVars; ++I)\n    Vars.push_back(Record.readSubExpr());\n  C->setPrivates(Vars);\n  Vars.clear();\n  for (unsigned I = 0; I != NumVars; ++I)\n    Vars.push_back(Record.readSubExpr());\n  C->setLHSExprs(Vars);\n  Vars.clear();\n  for (unsigned I = 0; I != NumVars; ++I)\n    Vars.push_back(Record.readSubExpr());\n  C->setRHSExprs(Vars);\n  Vars.clear();\n  for (unsigned I = 0; I != NumVars; ++I)\n    Vars.push_back(Record.readSubExpr());\n  C->setReductionOps(Vars);\n  Vars.clear();\n  for (unsigned I = 0; I != NumVars; ++I)\n    Vars.push_back(Record.readSubExpr());\n  C->setTaskgroupDescriptors(Vars);\n}\n\nvoid OMPClauseReader::VisitOMPLinearClause(OMPLinearClause *C) {\n  VisitOMPClauseWithPostUpdate(C);\n  C->setLParenLoc(Record.readSourceLocation());\n  C->setColonLoc(Record.readSourceLocation());\n  C->setModifier(static_cast<OpenMPLinearClauseKind>(Record.readInt()));\n  C->setModifierLoc(Record.readSourceLocation());\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setPrivates(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setInits(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setUpdates(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setFinals(Vars);\n  C->setStep(Record.readSubExpr());\n  C->setCalcStep(Record.readSubExpr());\n  Vars.clear();\n  for (unsigned I = 0; I != NumVars + 1; ++I)\n    Vars.push_back(Record.readSubExpr());\n  C->setUsedExprs(Vars);\n}\n\nvoid OMPClauseReader::VisitOMPAlignedClause(OMPAlignedClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  C->setColonLoc(Record.readSourceLocation());\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n  C->setAlignment(Record.readSubExpr());\n}\n\nvoid OMPClauseReader::VisitOMPCopyinClause(OMPCopyinClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Exprs;\n  Exprs.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Exprs.push_back(Record.readSubExpr());\n  C->setVarRefs(Exprs);\n  Exprs.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Exprs.push_back(Record.readSubExpr());\n  C->setSourceExprs(Exprs);\n  Exprs.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Exprs.push_back(Record.readSubExpr());\n  C->setDestinationExprs(Exprs);\n  Exprs.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Exprs.push_back(Record.readSubExpr());\n  C->setAssignmentOps(Exprs);\n}\n\nvoid OMPClauseReader::VisitOMPCopyprivateClause(OMPCopyprivateClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Exprs;\n  Exprs.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Exprs.push_back(Record.readSubExpr());\n  C->setVarRefs(Exprs);\n  Exprs.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Exprs.push_back(Record.readSubExpr());\n  C->setSourceExprs(Exprs);\n  Exprs.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Exprs.push_back(Record.readSubExpr());\n  C->setDestinationExprs(Exprs);\n  Exprs.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Exprs.push_back(Record.readSubExpr());\n  C->setAssignmentOps(Exprs);\n}\n\nvoid OMPClauseReader::VisitOMPFlushClause(OMPFlushClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n}\n\nvoid OMPClauseReader::VisitOMPDepobjClause(OMPDepobjClause *C) {\n  C->setDepobj(Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPDependClause(OMPDependClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  C->setModifier(Record.readSubExpr());\n  C->setDependencyKind(\n      static_cast<OpenMPDependClauseKind>(Record.readInt()));\n  C->setDependencyLoc(Record.readSourceLocation());\n  C->setColonLoc(Record.readSourceLocation());\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned I = 0; I != NumVars; ++I)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n  for (unsigned I = 0, E = C->getNumLoops(); I < E; ++I)\n    C->setLoopData(I, Record.readSubExpr());\n}\n\nvoid OMPClauseReader::VisitOMPDeviceClause(OMPDeviceClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  C->setModifier(Record.readEnum<OpenMPDeviceClauseModifier>());\n  C->setDevice(Record.readSubExpr());\n  C->setModifierLoc(Record.readSourceLocation());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPMapClause(OMPMapClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  for (unsigned I = 0; I < NumberOfOMPMapClauseModifiers; ++I) {\n    C->setMapTypeModifier(\n        I, static_cast<OpenMPMapModifierKind>(Record.readInt()));\n    C->setMapTypeModifierLoc(I, Record.readSourceLocation());\n  }\n  C->setMapperQualifierLoc(Record.readNestedNameSpecifierLoc());\n  C->setMapperIdInfo(Record.readDeclarationNameInfo());\n  C->setMapType(\n     static_cast<OpenMPMapClauseKind>(Record.readInt()));\n  C->setMapLoc(Record.readSourceLocation());\n  C->setColonLoc(Record.readSourceLocation());\n  auto NumVars = C->varlist_size();\n  auto UniqueDecls = C->getUniqueDeclarationsNum();\n  auto TotalLists = C->getTotalComponentListNum();\n  auto TotalComponents = C->getTotalComponentsNum();\n\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readExpr());\n  C->setVarRefs(Vars);\n\n  SmallVector<Expr *, 16> UDMappers;\n  UDMappers.reserve(NumVars);\n  for (unsigned I = 0; I < NumVars; ++I)\n    UDMappers.push_back(Record.readExpr());\n  C->setUDMapperRefs(UDMappers);\n\n  SmallVector<ValueDecl *, 16> Decls;\n  Decls.reserve(UniqueDecls);\n  for (unsigned i = 0; i < UniqueDecls; ++i)\n    Decls.push_back(Record.readDeclAs<ValueDecl>());\n  C->setUniqueDecls(Decls);\n\n  SmallVector<unsigned, 16> ListsPerDecl;\n  ListsPerDecl.reserve(UniqueDecls);\n  for (unsigned i = 0; i < UniqueDecls; ++i)\n    ListsPerDecl.push_back(Record.readInt());\n  C->setDeclNumLists(ListsPerDecl);\n\n  SmallVector<unsigned, 32> ListSizes;\n  ListSizes.reserve(TotalLists);\n  for (unsigned i = 0; i < TotalLists; ++i)\n    ListSizes.push_back(Record.readInt());\n  C->setComponentListSizes(ListSizes);\n\n  SmallVector<OMPClauseMappableExprCommon::MappableComponent, 32> Components;\n  Components.reserve(TotalComponents);\n  for (unsigned i = 0; i < TotalComponents; ++i) {\n    Expr *AssociatedExprPr = Record.readExpr();\n    auto *AssociatedDecl = Record.readDeclAs<ValueDecl>();\n    Components.emplace_back(AssociatedExprPr, AssociatedDecl,\n                            /*IsNonContiguous=*/false);\n  }\n  C->setComponents(Components, ListSizes);\n}\n\nvoid OMPClauseReader::VisitOMPAllocateClause(OMPAllocateClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  C->setColonLoc(Record.readSourceLocation());\n  C->setAllocator(Record.readSubExpr());\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n}\n\nvoid OMPClauseReader::VisitOMPNumTeamsClause(OMPNumTeamsClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  C->setNumTeams(Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPThreadLimitClause(OMPThreadLimitClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  C->setThreadLimit(Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPPriorityClause(OMPPriorityClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  C->setPriority(Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPGrainsizeClause(OMPGrainsizeClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  C->setGrainsize(Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPNumTasksClause(OMPNumTasksClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  C->setNumTasks(Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPHintClause(OMPHintClause *C) {\n  C->setHint(Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPDistScheduleClause(OMPDistScheduleClause *C) {\n  VisitOMPClauseWithPreInit(C);\n  C->setDistScheduleKind(\n      static_cast<OpenMPDistScheduleClauseKind>(Record.readInt()));\n  C->setChunkSize(Record.readSubExpr());\n  C->setLParenLoc(Record.readSourceLocation());\n  C->setDistScheduleKindLoc(Record.readSourceLocation());\n  C->setCommaLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPDefaultmapClause(OMPDefaultmapClause *C) {\n  C->setDefaultmapKind(\n       static_cast<OpenMPDefaultmapClauseKind>(Record.readInt()));\n  C->setDefaultmapModifier(\n      static_cast<OpenMPDefaultmapClauseModifier>(Record.readInt()));\n  C->setLParenLoc(Record.readSourceLocation());\n  C->setDefaultmapModifierLoc(Record.readSourceLocation());\n  C->setDefaultmapKindLoc(Record.readSourceLocation());\n}\n\nvoid OMPClauseReader::VisitOMPToClause(OMPToClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  for (unsigned I = 0; I < NumberOfOMPMotionModifiers; ++I) {\n    C->setMotionModifier(\n        I, static_cast<OpenMPMotionModifierKind>(Record.readInt()));\n    C->setMotionModifierLoc(I, Record.readSourceLocation());\n  }\n  C->setMapperQualifierLoc(Record.readNestedNameSpecifierLoc());\n  C->setMapperIdInfo(Record.readDeclarationNameInfo());\n  C->setColonLoc(Record.readSourceLocation());\n  auto NumVars = C->varlist_size();\n  auto UniqueDecls = C->getUniqueDeclarationsNum();\n  auto TotalLists = C->getTotalComponentListNum();\n  auto TotalComponents = C->getTotalComponentsNum();\n\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n\n  SmallVector<Expr *, 16> UDMappers;\n  UDMappers.reserve(NumVars);\n  for (unsigned I = 0; I < NumVars; ++I)\n    UDMappers.push_back(Record.readSubExpr());\n  C->setUDMapperRefs(UDMappers);\n\n  SmallVector<ValueDecl *, 16> Decls;\n  Decls.reserve(UniqueDecls);\n  for (unsigned i = 0; i < UniqueDecls; ++i)\n    Decls.push_back(Record.readDeclAs<ValueDecl>());\n  C->setUniqueDecls(Decls);\n\n  SmallVector<unsigned, 16> ListsPerDecl;\n  ListsPerDecl.reserve(UniqueDecls);\n  for (unsigned i = 0; i < UniqueDecls; ++i)\n    ListsPerDecl.push_back(Record.readInt());\n  C->setDeclNumLists(ListsPerDecl);\n\n  SmallVector<unsigned, 32> ListSizes;\n  ListSizes.reserve(TotalLists);\n  for (unsigned i = 0; i < TotalLists; ++i)\n    ListSizes.push_back(Record.readInt());\n  C->setComponentListSizes(ListSizes);\n\n  SmallVector<OMPClauseMappableExprCommon::MappableComponent, 32> Components;\n  Components.reserve(TotalComponents);\n  for (unsigned i = 0; i < TotalComponents; ++i) {\n    Expr *AssociatedExprPr = Record.readSubExpr();\n    bool IsNonContiguous = Record.readBool();\n    auto *AssociatedDecl = Record.readDeclAs<ValueDecl>();\n    Components.emplace_back(AssociatedExprPr, AssociatedDecl, IsNonContiguous);\n  }\n  C->setComponents(Components, ListSizes);\n}\n\nvoid OMPClauseReader::VisitOMPFromClause(OMPFromClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  for (unsigned I = 0; I < NumberOfOMPMotionModifiers; ++I) {\n    C->setMotionModifier(\n        I, static_cast<OpenMPMotionModifierKind>(Record.readInt()));\n    C->setMotionModifierLoc(I, Record.readSourceLocation());\n  }\n  C->setMapperQualifierLoc(Record.readNestedNameSpecifierLoc());\n  C->setMapperIdInfo(Record.readDeclarationNameInfo());\n  C->setColonLoc(Record.readSourceLocation());\n  auto NumVars = C->varlist_size();\n  auto UniqueDecls = C->getUniqueDeclarationsNum();\n  auto TotalLists = C->getTotalComponentListNum();\n  auto TotalComponents = C->getTotalComponentsNum();\n\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n\n  SmallVector<Expr *, 16> UDMappers;\n  UDMappers.reserve(NumVars);\n  for (unsigned I = 0; I < NumVars; ++I)\n    UDMappers.push_back(Record.readSubExpr());\n  C->setUDMapperRefs(UDMappers);\n\n  SmallVector<ValueDecl *, 16> Decls;\n  Decls.reserve(UniqueDecls);\n  for (unsigned i = 0; i < UniqueDecls; ++i)\n    Decls.push_back(Record.readDeclAs<ValueDecl>());\n  C->setUniqueDecls(Decls);\n\n  SmallVector<unsigned, 16> ListsPerDecl;\n  ListsPerDecl.reserve(UniqueDecls);\n  for (unsigned i = 0; i < UniqueDecls; ++i)\n    ListsPerDecl.push_back(Record.readInt());\n  C->setDeclNumLists(ListsPerDecl);\n\n  SmallVector<unsigned, 32> ListSizes;\n  ListSizes.reserve(TotalLists);\n  for (unsigned i = 0; i < TotalLists; ++i)\n    ListSizes.push_back(Record.readInt());\n  C->setComponentListSizes(ListSizes);\n\n  SmallVector<OMPClauseMappableExprCommon::MappableComponent, 32> Components;\n  Components.reserve(TotalComponents);\n  for (unsigned i = 0; i < TotalComponents; ++i) {\n    Expr *AssociatedExprPr = Record.readSubExpr();\n    bool IsNonContiguous = Record.readBool();\n    auto *AssociatedDecl = Record.readDeclAs<ValueDecl>();\n    Components.emplace_back(AssociatedExprPr, AssociatedDecl, IsNonContiguous);\n  }\n  C->setComponents(Components, ListSizes);\n}\n\nvoid OMPClauseReader::VisitOMPUseDevicePtrClause(OMPUseDevicePtrClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  auto NumVars = C->varlist_size();\n  auto UniqueDecls = C->getUniqueDeclarationsNum();\n  auto TotalLists = C->getTotalComponentListNum();\n  auto TotalComponents = C->getTotalComponentsNum();\n\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setPrivateCopies(Vars);\n  Vars.clear();\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setInits(Vars);\n\n  SmallVector<ValueDecl *, 16> Decls;\n  Decls.reserve(UniqueDecls);\n  for (unsigned i = 0; i < UniqueDecls; ++i)\n    Decls.push_back(Record.readDeclAs<ValueDecl>());\n  C->setUniqueDecls(Decls);\n\n  SmallVector<unsigned, 16> ListsPerDecl;\n  ListsPerDecl.reserve(UniqueDecls);\n  for (unsigned i = 0; i < UniqueDecls; ++i)\n    ListsPerDecl.push_back(Record.readInt());\n  C->setDeclNumLists(ListsPerDecl);\n\n  SmallVector<unsigned, 32> ListSizes;\n  ListSizes.reserve(TotalLists);\n  for (unsigned i = 0; i < TotalLists; ++i)\n    ListSizes.push_back(Record.readInt());\n  C->setComponentListSizes(ListSizes);\n\n  SmallVector<OMPClauseMappableExprCommon::MappableComponent, 32> Components;\n  Components.reserve(TotalComponents);\n  for (unsigned i = 0; i < TotalComponents; ++i) {\n    auto *AssociatedExprPr = Record.readSubExpr();\n    auto *AssociatedDecl = Record.readDeclAs<ValueDecl>();\n    Components.emplace_back(AssociatedExprPr, AssociatedDecl,\n                            /*IsNonContiguous=*/false);\n  }\n  C->setComponents(Components, ListSizes);\n}\n\nvoid OMPClauseReader::VisitOMPUseDeviceAddrClause(OMPUseDeviceAddrClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  auto NumVars = C->varlist_size();\n  auto UniqueDecls = C->getUniqueDeclarationsNum();\n  auto TotalLists = C->getTotalComponentListNum();\n  auto TotalComponents = C->getTotalComponentsNum();\n\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n\n  SmallVector<ValueDecl *, 16> Decls;\n  Decls.reserve(UniqueDecls);\n  for (unsigned i = 0; i < UniqueDecls; ++i)\n    Decls.push_back(Record.readDeclAs<ValueDecl>());\n  C->setUniqueDecls(Decls);\n\n  SmallVector<unsigned, 16> ListsPerDecl;\n  ListsPerDecl.reserve(UniqueDecls);\n  for (unsigned i = 0; i < UniqueDecls; ++i)\n    ListsPerDecl.push_back(Record.readInt());\n  C->setDeclNumLists(ListsPerDecl);\n\n  SmallVector<unsigned, 32> ListSizes;\n  ListSizes.reserve(TotalLists);\n  for (unsigned i = 0; i < TotalLists; ++i)\n    ListSizes.push_back(Record.readInt());\n  C->setComponentListSizes(ListSizes);\n\n  SmallVector<OMPClauseMappableExprCommon::MappableComponent, 32> Components;\n  Components.reserve(TotalComponents);\n  for (unsigned i = 0; i < TotalComponents; ++i) {\n    Expr *AssociatedExpr = Record.readSubExpr();\n    auto *AssociatedDecl = Record.readDeclAs<ValueDecl>();\n    Components.emplace_back(AssociatedExpr, AssociatedDecl,\n                            /*IsNonContiguous*/ false);\n  }\n  C->setComponents(Components, ListSizes);\n}\n\nvoid OMPClauseReader::VisitOMPIsDevicePtrClause(OMPIsDevicePtrClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  auto NumVars = C->varlist_size();\n  auto UniqueDecls = C->getUniqueDeclarationsNum();\n  auto TotalLists = C->getTotalComponentListNum();\n  auto TotalComponents = C->getTotalComponentsNum();\n\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n  Vars.clear();\n\n  SmallVector<ValueDecl *, 16> Decls;\n  Decls.reserve(UniqueDecls);\n  for (unsigned i = 0; i < UniqueDecls; ++i)\n    Decls.push_back(Record.readDeclAs<ValueDecl>());\n  C->setUniqueDecls(Decls);\n\n  SmallVector<unsigned, 16> ListsPerDecl;\n  ListsPerDecl.reserve(UniqueDecls);\n  for (unsigned i = 0; i < UniqueDecls; ++i)\n    ListsPerDecl.push_back(Record.readInt());\n  C->setDeclNumLists(ListsPerDecl);\n\n  SmallVector<unsigned, 32> ListSizes;\n  ListSizes.reserve(TotalLists);\n  for (unsigned i = 0; i < TotalLists; ++i)\n    ListSizes.push_back(Record.readInt());\n  C->setComponentListSizes(ListSizes);\n\n  SmallVector<OMPClauseMappableExprCommon::MappableComponent, 32> Components;\n  Components.reserve(TotalComponents);\n  for (unsigned i = 0; i < TotalComponents; ++i) {\n    Expr *AssociatedExpr = Record.readSubExpr();\n    auto *AssociatedDecl = Record.readDeclAs<ValueDecl>();\n    Components.emplace_back(AssociatedExpr, AssociatedDecl,\n                            /*IsNonContiguous=*/false);\n  }\n  C->setComponents(Components, ListSizes);\n}\n\nvoid OMPClauseReader::VisitOMPNontemporalClause(OMPNontemporalClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n  Vars.clear();\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setPrivateRefs(Vars);\n}\n\nvoid OMPClauseReader::VisitOMPInclusiveClause(OMPInclusiveClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n}\n\nvoid OMPClauseReader::VisitOMPExclusiveClause(OMPExclusiveClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  unsigned NumVars = C->varlist_size();\n  SmallVector<Expr *, 16> Vars;\n  Vars.reserve(NumVars);\n  for (unsigned i = 0; i != NumVars; ++i)\n    Vars.push_back(Record.readSubExpr());\n  C->setVarRefs(Vars);\n}\n\nvoid OMPClauseReader::VisitOMPUsesAllocatorsClause(OMPUsesAllocatorsClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  unsigned NumOfAllocators = C->getNumberOfAllocators();\n  SmallVector<OMPUsesAllocatorsClause::Data, 4> Data;\n  Data.reserve(NumOfAllocators);\n  for (unsigned I = 0; I != NumOfAllocators; ++I) {\n    OMPUsesAllocatorsClause::Data &D = Data.emplace_back();\n    D.Allocator = Record.readSubExpr();\n    D.AllocatorTraits = Record.readSubExpr();\n    D.LParenLoc = Record.readSourceLocation();\n    D.RParenLoc = Record.readSourceLocation();\n  }\n  C->setAllocatorsData(Data);\n}\n\nvoid OMPClauseReader::VisitOMPAffinityClause(OMPAffinityClause *C) {\n  C->setLParenLoc(Record.readSourceLocation());\n  C->setModifier(Record.readSubExpr());\n  C->setColonLoc(Record.readSourceLocation());\n  unsigned NumOfLocators = C->varlist_size();\n  SmallVector<Expr *, 4> Locators;\n  Locators.reserve(NumOfLocators);\n  for (unsigned I = 0; I != NumOfLocators; ++I)\n    Locators.push_back(Record.readSubExpr());\n  C->setVarRefs(Locators);\n}\n\nvoid OMPClauseReader::VisitOMPOrderClause(OMPOrderClause *C) {\n  C->setKind(Record.readEnum<OpenMPOrderClauseKind>());\n  C->setLParenLoc(Record.readSourceLocation());\n  C->setKindKwLoc(Record.readSourceLocation());\n}\n\nOMPTraitInfo *ASTRecordReader::readOMPTraitInfo() {\n  OMPTraitInfo &TI = getContext().getNewOMPTraitInfo();\n  TI.Sets.resize(readUInt32());\n  for (auto &Set : TI.Sets) {\n    Set.Kind = readEnum<llvm::omp::TraitSet>();\n    Set.Selectors.resize(readUInt32());\n    for (auto &Selector : Set.Selectors) {\n      Selector.Kind = readEnum<llvm::omp::TraitSelector>();\n      Selector.ScoreOrCondition = nullptr;\n      if (readBool())\n        Selector.ScoreOrCondition = readExprRef();\n      Selector.Properties.resize(readUInt32());\n      for (auto &Property : Selector.Properties)\n        Property.Kind = readEnum<llvm::omp::TraitProperty>();\n    }\n  }\n  return &TI;\n}\n\nvoid ASTRecordReader::readOMPChildren(OMPChildren *Data) {\n  if (!Data)\n    return;\n  if (Reader->ReadingKind == ASTReader::Read_Stmt) {\n    // Skip NumClauses, NumChildren and HasAssociatedStmt fields.\n    skipInts(3);\n  }\n  SmallVector<OMPClause *, 4> Clauses(Data->getNumClauses());\n  for (unsigned I = 0, E = Data->getNumClauses(); I < E; ++I)\n    Clauses[I] = readOMPClause();\n  Data->setClauses(Clauses);\n  if (Data->hasAssociatedStmt())\n    Data->setAssociatedStmt(readStmt());\n  for (unsigned I = 0, E = Data->getNumChildren(); I < E; ++I)\n    Data->getChildren()[I] = readStmt();\n}\n"}, "0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTReader.h", "content": "//===- ASTReader.h - AST File Reader ----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the ASTReader class, which reads AST files.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SERIALIZATION_ASTREADER_H\n#define LLVM_CLANG_SERIALIZATION_ASTREADER_H\n\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/DiagnosticOptions.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/OpenCLOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Version.h\"\n#include \"clang/Lex/ExternalPreprocessorSource.h\"\n#include \"clang/Lex/HeaderSearch.h\"\n#include \"clang/Lex/PreprocessingRecord.h\"\n#include \"clang/Lex/PreprocessorOptions.h\"\n#include \"clang/Sema/ExternalSemaSource.h\"\n#include \"clang/Sema/IdentifierResolver.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"clang/Serialization/ASTBitCodes.h\"\n#include \"clang/Serialization/ContinuousRangeMap.h\"\n#include \"clang/Serialization/ModuleFile.h\"\n#include \"clang/Serialization/ModuleFileExtension.h\"\n#include \"clang/Serialization/ModuleManager.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Bitstream/BitstreamReader.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/Timer.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <ctime>\n#include <deque>\n#include <memory>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass ASTConsumer;\nclass ASTContext;\nclass ASTDeserializationListener;\nclass ASTReader;\nclass ASTRecordReader;\nclass CXXTemporary;\nclass Decl;\nclass DeclarationName;\nclass DeclaratorDecl;\nclass DeclContext;\nclass EnumDecl;\nclass Expr;\nclass FieldDecl;\nclass FileEntry;\nclass FileManager;\nclass FileSystemOptions;\nclass FunctionDecl;\nclass GlobalModuleIndex;\nstruct HeaderFileInfo;\nclass HeaderSearchOptions;\nclass LangOptions;\nclass LazyASTUnresolvedSet;\nclass MacroInfo;\nclass InMemoryModuleCache;\nclass NamedDecl;\nclass NamespaceDecl;\nclass ObjCCategoryDecl;\nclass ObjCInterfaceDecl;\nclass PCHContainerReader;\nclass Preprocessor;\nclass PreprocessorOptions;\nstruct QualifierInfo;\nclass Sema;\nclass SourceManager;\nclass Stmt;\nclass SwitchCase;\nclass TargetOptions;\nclass Token;\nclass TypedefNameDecl;\nclass ValueDecl;\nclass VarDecl;\n\n/// Abstract interface for callback invocations by the ASTReader.\n///\n/// While reading an AST file, the ASTReader will call the methods of the\n/// listener to pass on specific information. Some of the listener methods can\n/// return true to indicate to the ASTReader that the information (and\n/// consequently the AST file) is invalid.\nclass ASTReaderListener {\npublic:\n  virtual ~ASTReaderListener();\n\n  /// Receives the full Clang version information.\n  ///\n  /// \\returns true to indicate that the version is invalid. Subclasses should\n  /// generally defer to this implementation.\n  virtual bool ReadFullVersionInformation(StringRef FullVersion) {\n    return FullVersion != getClangFullRepositoryVersion();\n  }\n\n  virtual void ReadModuleName(StringRef ModuleName) {}\n  virtual void ReadModuleMapFile(StringRef ModuleMapPath) {}\n\n  /// Receives the language options.\n  ///\n  /// \\returns true to indicate the options are invalid or false otherwise.\n  virtual bool ReadLanguageOptions(const LangOptions &LangOpts,\n                                   bool Complain,\n                                   bool AllowCompatibleDifferences) {\n    return false;\n  }\n\n  /// Receives the target options.\n  ///\n  /// \\returns true to indicate the target options are invalid, or false\n  /// otherwise.\n  virtual bool ReadTargetOptions(const TargetOptions &TargetOpts, bool Complain,\n                                 bool AllowCompatibleDifferences) {\n    return false;\n  }\n\n  /// Receives the diagnostic options.\n  ///\n  /// \\returns true to indicate the diagnostic options are invalid, or false\n  /// otherwise.\n  virtual bool\n  ReadDiagnosticOptions(IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts,\n                        bool Complain) {\n    return false;\n  }\n\n  /// Receives the file system options.\n  ///\n  /// \\returns true to indicate the file system options are invalid, or false\n  /// otherwise.\n  virtual bool ReadFileSystemOptions(const FileSystemOptions &FSOpts,\n                                     bool Complain) {\n    return false;\n  }\n\n  /// Receives the header search options.\n  ///\n  /// \\returns true to indicate the header search options are invalid, or false\n  /// otherwise.\n  virtual bool ReadHeaderSearchOptions(const HeaderSearchOptions &HSOpts,\n                                       StringRef SpecificModuleCachePath,\n                                       bool Complain) {\n    return false;\n  }\n\n  /// Receives the preprocessor options.\n  ///\n  /// \\param SuggestedPredefines Can be filled in with the set of predefines\n  /// that are suggested by the preprocessor options. Typically only used when\n  /// loading a precompiled header.\n  ///\n  /// \\returns true to indicate the preprocessor options are invalid, or false\n  /// otherwise.\n  virtual bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts,\n                                       bool Complain,\n                                       std::string &SuggestedPredefines) {\n    return false;\n  }\n\n  /// Receives __COUNTER__ value.\n  virtual void ReadCounter(const serialization::ModuleFile &M,\n                           unsigned Value) {}\n\n  /// This is called for each AST file loaded.\n  virtual void visitModuleFile(StringRef Filename,\n                               serialization::ModuleKind Kind) {}\n\n  /// Returns true if this \\c ASTReaderListener wants to receive the\n  /// input files of the AST file via \\c visitInputFile, false otherwise.\n  virtual bool needsInputFileVisitation() { return false; }\n\n  /// Returns true if this \\c ASTReaderListener wants to receive the\n  /// system input files of the AST file via \\c visitInputFile, false otherwise.\n  virtual bool needsSystemInputFileVisitation() { return false; }\n\n  /// if \\c needsInputFileVisitation returns true, this is called for\n  /// each non-system input file of the AST File. If\n  /// \\c needsSystemInputFileVisitation is true, then it is called for all\n  /// system input files as well.\n  ///\n  /// \\returns true to continue receiving the next input file, false to stop.\n  virtual bool visitInputFile(StringRef Filename, bool isSystem,\n                              bool isOverridden, bool isExplicitModule) {\n    return true;\n  }\n\n  /// Returns true if this \\c ASTReaderListener wants to receive the\n  /// imports of the AST file via \\c visitImport, false otherwise.\n  virtual bool needsImportVisitation() const { return false; }\n\n  /// If needsImportVisitation returns \\c true, this is called for each\n  /// AST file imported by this AST file.\n  virtual void visitImport(StringRef ModuleName, StringRef Filename) {}\n\n  /// Indicates that a particular module file extension has been read.\n  virtual void readModuleFileExtension(\n                 const ModuleFileExtensionMetadata &Metadata) {}\n};\n\n/// Simple wrapper class for chaining listeners.\nclass ChainedASTReaderListener : public ASTReaderListener {\n  std::unique_ptr<ASTReaderListener> First;\n  std::unique_ptr<ASTReaderListener> Second;\n\npublic:\n  /// Takes ownership of \\p First and \\p Second.\n  ChainedASTReaderListener(std::unique_ptr<ASTReaderListener> First,\n                           std::unique_ptr<ASTReaderListener> Second)\n      : First(std::move(First)), Second(std::move(Second)) {}\n\n  std::unique_ptr<ASTReaderListener> takeFirst() { return std::move(First); }\n  std::unique_ptr<ASTReaderListener> takeSecond() { return std::move(Second); }\n\n  bool ReadFullVersionInformation(StringRef FullVersion) override;\n  void ReadModuleName(StringRef ModuleName) override;\n  void ReadModuleMapFile(StringRef ModuleMapPath) override;\n  bool ReadLanguageOptions(const LangOptions &LangOpts, bool Complain,\n                           bool AllowCompatibleDifferences) override;\n  bool ReadTargetOptions(const TargetOptions &TargetOpts, bool Complain,\n                         bool AllowCompatibleDifferences) override;\n  bool ReadDiagnosticOptions(IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts,\n                             bool Complain) override;\n  bool ReadFileSystemOptions(const FileSystemOptions &FSOpts,\n                             bool Complain) override;\n\n  bool ReadHeaderSearchOptions(const HeaderSearchOptions &HSOpts,\n                               StringRef SpecificModuleCachePath,\n                               bool Complain) override;\n  bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts,\n                               bool Complain,\n                               std::string &SuggestedPredefines) override;\n\n  void ReadCounter(const serialization::ModuleFile &M, unsigned Value) override;\n  bool needsInputFileVisitation() override;\n  bool needsSystemInputFileVisitation() override;\n  void visitModuleFile(StringRef Filename,\n                       serialization::ModuleKind Kind) override;\n  bool visitInputFile(StringRef Filename, bool isSystem,\n                      bool isOverridden, bool isExplicitModule) override;\n  void readModuleFileExtension(\n         const ModuleFileExtensionMetadata &Metadata) override;\n};\n\n/// ASTReaderListener implementation to validate the information of\n/// the PCH file against an initialized Preprocessor.\nclass PCHValidator : public ASTReaderListener {\n  Preprocessor &PP;\n  ASTReader &Reader;\n\npublic:\n  PCHValidator(Preprocessor &PP, ASTReader &Reader)\n      : PP(PP), Reader(Reader) {}\n\n  bool ReadLanguageOptions(const LangOptions &LangOpts, bool Complain,\n                           bool AllowCompatibleDifferences) override;\n  bool ReadTargetOptions(const TargetOptions &TargetOpts, bool Complain,\n                         bool AllowCompatibleDifferences) override;\n  bool ReadDiagnosticOptions(IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts,\n                             bool Complain) override;\n  bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts, bool Complain,\n                               std::string &SuggestedPredefines) override;\n  bool ReadHeaderSearchOptions(const HeaderSearchOptions &HSOpts,\n                               StringRef SpecificModuleCachePath,\n                               bool Complain) override;\n  void ReadCounter(const serialization::ModuleFile &M, unsigned Value) override;\n\nprivate:\n  void Error(const char *Msg);\n};\n\n/// ASTReaderListenter implementation to set SuggestedPredefines of\n/// ASTReader which is required to use a pch file. This is the replacement\n/// of PCHValidator or SimplePCHValidator when using a pch file without\n/// validating it.\nclass SimpleASTReaderListener : public ASTReaderListener {\n  Preprocessor &PP;\n\npublic:\n  SimpleASTReaderListener(Preprocessor &PP) : PP(PP) {}\n\n  bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts, bool Complain,\n                               std::string &SuggestedPredefines) override;\n};\n\nnamespace serialization {\n\nclass ReadMethodPoolVisitor;\n\nnamespace reader {\n\nclass ASTIdentifierLookupTrait;\n\n/// The on-disk hash table(s) used for DeclContext name lookup.\nstruct DeclContextLookupTable;\n\n} // namespace reader\n\n} // namespace serialization\n\n/// Reads an AST files chain containing the contents of a translation\n/// unit.\n///\n/// The ASTReader class reads bitstreams (produced by the ASTWriter\n/// class) containing the serialized representation of a given\n/// abstract syntax tree and its supporting data structures. An\n/// instance of the ASTReader can be attached to an ASTContext object,\n/// which will provide access to the contents of the AST files.\n///\n/// The AST reader provides lazy de-serialization of declarations, as\n/// required when traversing the AST. Only those AST nodes that are\n/// actually required will be de-serialized.\nclass ASTReader\n  : public ExternalPreprocessorSource,\n    public ExternalPreprocessingRecordSource,\n    public ExternalHeaderFileInfoSource,\n    public ExternalSemaSource,\n    public IdentifierInfoLookup,\n    public ExternalSLocEntrySource\n{\npublic:\n  /// Types of AST files.\n  friend class ASTDeclReader;\n  friend class ASTIdentifierIterator;\n  friend class ASTRecordReader;\n  friend class ASTUnit; // ASTUnit needs to remap source locations.\n  friend class ASTWriter;\n  friend class PCHValidator;\n  friend class serialization::reader::ASTIdentifierLookupTrait;\n  friend class serialization::ReadMethodPoolVisitor;\n  friend class TypeLocReader;\n\n  using RecordData = SmallVector<uint64_t, 64>;\n  using RecordDataImpl = SmallVectorImpl<uint64_t>;\n\n  /// The result of reading the control block of an AST file, which\n  /// can fail for various reasons.\n  enum ASTReadResult {\n    /// The control block was read successfully. Aside from failures,\n    /// the AST file is safe to read into the current context.\n    Success,\n\n    /// The AST file itself appears corrupted.\n    Failure,\n\n    /// The AST file was missing.\n    Missing,\n\n    /// The AST file is out-of-date relative to its input files,\n    /// and needs to be regenerated.\n    OutOfDate,\n\n    /// The AST file was written by a different version of Clang.\n    VersionMismatch,\n\n    /// The AST file was writtten with a different language/target\n    /// configuration.\n    ConfigurationMismatch,\n\n    /// The AST file has errors.\n    HadErrors\n  };\n\n  using ModuleFile = serialization::ModuleFile;\n  using ModuleKind = serialization::ModuleKind;\n  using ModuleManager = serialization::ModuleManager;\n  using ModuleIterator = ModuleManager::ModuleIterator;\n  using ModuleConstIterator = ModuleManager::ModuleConstIterator;\n  using ModuleReverseIterator = ModuleManager::ModuleReverseIterator;\n\nprivate:\n  /// The receiver of some callbacks invoked by ASTReader.\n  std::unique_ptr<ASTReaderListener> Listener;\n\n  /// The receiver of deserialization events.\n  ASTDeserializationListener *DeserializationListener = nullptr;\n\n  bool OwnsDeserializationListener = false;\n\n  SourceManager &SourceMgr;\n  FileManager &FileMgr;\n  const PCHContainerReader &PCHContainerRdr;\n  DiagnosticsEngine &Diags;\n\n  /// The semantic analysis object that will be processing the\n  /// AST files and the translation unit that uses it.\n  Sema *SemaObj = nullptr;\n\n  /// The preprocessor that will be loading the source file.\n  Preprocessor &PP;\n\n  /// The AST context into which we'll read the AST files.\n  ASTContext *ContextObj = nullptr;\n\n  /// The AST consumer.\n  ASTConsumer *Consumer = nullptr;\n\n  /// The module manager which manages modules and their dependencies\n  ModuleManager ModuleMgr;\n\n  /// A dummy identifier resolver used to merge TU-scope declarations in\n  /// C, for the cases where we don't have a Sema object to provide a real\n  /// identifier resolver.\n  IdentifierResolver DummyIdResolver;\n\n  /// A mapping from extension block names to module file extensions.\n  llvm::StringMap<std::shared_ptr<ModuleFileExtension>> ModuleFileExtensions;\n\n  /// A timer used to track the time spent deserializing.\n  std::unique_ptr<llvm::Timer> ReadTimer;\n\n  /// The location where the module file will be considered as\n  /// imported from. For non-module AST types it should be invalid.\n  SourceLocation CurrentImportLoc;\n\n  /// The module kind that is currently deserializing.\n  Optional<ModuleKind> CurrentDeserializingModuleKind;\n\n  /// The global module index, if loaded.\n  std::unique_ptr<GlobalModuleIndex> GlobalIndex;\n\n  /// A map of global bit offsets to the module that stores entities\n  /// at those bit offsets.\n  ContinuousRangeMap<uint64_t, ModuleFile*, 4> GlobalBitOffsetsMap;\n\n  /// A map of negated SLocEntryIDs to the modules containing them.\n  ContinuousRangeMap<unsigned, ModuleFile*, 64> GlobalSLocEntryMap;\n\n  using GlobalSLocOffsetMapType =\n      ContinuousRangeMap<unsigned, ModuleFile *, 64>;\n\n  /// A map of reversed (SourceManager::MaxLoadedOffset - SLocOffset)\n  /// SourceLocation offsets to the modules containing them.\n  GlobalSLocOffsetMapType GlobalSLocOffsetMap;\n\n  /// Types that have already been loaded from the chain.\n  ///\n  /// When the pointer at index I is non-NULL, the type with\n  /// ID = (I + 1) << FastQual::Width has already been loaded\n  std::vector<QualType> TypesLoaded;\n\n  using GlobalTypeMapType =\n      ContinuousRangeMap<serialization::TypeID, ModuleFile *, 4>;\n\n  /// Mapping from global type IDs to the module in which the\n  /// type resides along with the offset that should be added to the\n  /// global type ID to produce a local ID.\n  GlobalTypeMapType GlobalTypeMap;\n\n  /// Declarations that have already been loaded from the chain.\n  ///\n  /// When the pointer at index I is non-NULL, the declaration with ID\n  /// = I + 1 has already been loaded.\n  std::vector<Decl *> DeclsLoaded;\n\n  using GlobalDeclMapType =\n      ContinuousRangeMap<serialization::DeclID, ModuleFile *, 4>;\n\n  /// Mapping from global declaration IDs to the module in which the\n  /// declaration resides.\n  GlobalDeclMapType GlobalDeclMap;\n\n  using FileOffset = std::pair<ModuleFile *, uint64_t>;\n  using FileOffsetsTy = SmallVector<FileOffset, 2>;\n  using DeclUpdateOffsetsMap =\n      llvm::DenseMap<serialization::DeclID, FileOffsetsTy>;\n\n  /// Declarations that have modifications residing in a later file\n  /// in the chain.\n  DeclUpdateOffsetsMap DeclUpdateOffsets;\n\n  struct PendingUpdateRecord {\n    Decl *D;\n    serialization::GlobalDeclID ID;\n\n    // Whether the declaration was just deserialized.\n    bool JustLoaded;\n\n    PendingUpdateRecord(serialization::GlobalDeclID ID, Decl *D,\n                        bool JustLoaded)\n        : D(D), ID(ID), JustLoaded(JustLoaded) {}\n  };\n\n  /// Declaration updates for already-loaded declarations that we need\n  /// to apply once we finish processing an import.\n  llvm::SmallVector<PendingUpdateRecord, 16> PendingUpdateRecords;\n\n  enum class PendingFakeDefinitionKind { NotFake, Fake, FakeLoaded };\n\n  /// The DefinitionData pointers that we faked up for class definitions\n  /// that we needed but hadn't loaded yet.\n  llvm::DenseMap<void *, PendingFakeDefinitionKind> PendingFakeDefinitionData;\n\n  /// Exception specification updates that have been loaded but not yet\n  /// propagated across the relevant redeclaration chain. The map key is the\n  /// canonical declaration (used only for deduplication) and the value is a\n  /// declaration that has an exception specification.\n  llvm::SmallMapVector<Decl *, FunctionDecl *, 4> PendingExceptionSpecUpdates;\n\n  /// Deduced return type updates that have been loaded but not yet propagated\n  /// across the relevant redeclaration chain. The map key is the canonical\n  /// declaration and the value is the deduced return type.\n  llvm::SmallMapVector<FunctionDecl *, QualType, 4> PendingDeducedTypeUpdates;\n\n  /// Declarations that have been imported and have typedef names for\n  /// linkage purposes.\n  llvm::DenseMap<std::pair<DeclContext *, IdentifierInfo *>, NamedDecl *>\n      ImportedTypedefNamesForLinkage;\n\n  /// Mergeable declaration contexts that have anonymous declarations\n  /// within them, and those anonymous declarations.\n  llvm::DenseMap<Decl*, llvm::SmallVector<NamedDecl*, 2>>\n    AnonymousDeclarationsForMerging;\n\n  /// Key used to identify LifetimeExtendedTemporaryDecl for merging,\n  /// containing the lifetime-extending declaration and the mangling number.\n  using LETemporaryKey = std::pair<Decl *, unsigned>;\n\n  /// Map of already deserialiazed temporaries.\n  llvm::DenseMap<LETemporaryKey, LifetimeExtendedTemporaryDecl *>\n      LETemporaryForMerging;\n\n  struct FileDeclsInfo {\n    ModuleFile *Mod = nullptr;\n    ArrayRef<serialization::LocalDeclID> Decls;\n\n    FileDeclsInfo() = default;\n    FileDeclsInfo(ModuleFile *Mod, ArrayRef<serialization::LocalDeclID> Decls)\n        : Mod(Mod), Decls(Decls) {}\n  };\n\n  /// Map from a FileID to the file-level declarations that it contains.\n  llvm::DenseMap<FileID, FileDeclsInfo> FileDeclIDs;\n\n  /// An array of lexical contents of a declaration context, as a sequence of\n  /// Decl::Kind, DeclID pairs.\n  using LexicalContents = ArrayRef<llvm::support::unaligned_uint32_t>;\n\n  /// Map from a DeclContext to its lexical contents.\n  llvm::DenseMap<const DeclContext*, std::pair<ModuleFile*, LexicalContents>>\n      LexicalDecls;\n\n  /// Map from the TU to its lexical contents from each module file.\n  std::vector<std::pair<ModuleFile*, LexicalContents>> TULexicalDecls;\n\n  /// Map from a DeclContext to its lookup tables.\n  llvm::DenseMap<const DeclContext *,\n                 serialization::reader::DeclContextLookupTable> Lookups;\n\n  // Updates for visible decls can occur for other contexts than just the\n  // TU, and when we read those update records, the actual context may not\n  // be available yet, so have this pending map using the ID as a key. It\n  // will be realized when the context is actually loaded.\n  struct PendingVisibleUpdate {\n    ModuleFile *Mod;\n    const unsigned char *Data;\n  };\n  using DeclContextVisibleUpdates = SmallVector<PendingVisibleUpdate, 1>;\n\n  /// Updates to the visible declarations of declaration contexts that\n  /// haven't been loaded yet.\n  llvm::DenseMap<serialization::DeclID, DeclContextVisibleUpdates>\n      PendingVisibleUpdates;\n\n  /// The set of C++ or Objective-C classes that have forward\n  /// declarations that have not yet been linked to their definitions.\n  llvm::SmallPtrSet<Decl *, 4> PendingDefinitions;\n\n  using PendingBodiesMap =\n      llvm::MapVector<Decl *, uint64_t,\n                      llvm::SmallDenseMap<Decl *, unsigned, 4>,\n                      SmallVector<std::pair<Decl *, uint64_t>, 4>>;\n\n  /// Functions or methods that have bodies that will be attached.\n  PendingBodiesMap PendingBodies;\n\n  /// Definitions for which we have added merged definitions but not yet\n  /// performed deduplication.\n  llvm::SetVector<NamedDecl *> PendingMergedDefinitionsToDeduplicate;\n\n  /// Read the record that describes the lexical contents of a DC.\n  bool ReadLexicalDeclContextStorage(ModuleFile &M,\n                                     llvm::BitstreamCursor &Cursor,\n                                     uint64_t Offset, DeclContext *DC);\n\n  /// Read the record that describes the visible contents of a DC.\n  bool ReadVisibleDeclContextStorage(ModuleFile &M,\n                                     llvm::BitstreamCursor &Cursor,\n                                     uint64_t Offset, serialization::DeclID ID);\n\n  /// A vector containing identifiers that have already been\n  /// loaded.\n  ///\n  /// If the pointer at index I is non-NULL, then it refers to the\n  /// IdentifierInfo for the identifier with ID=I+1 that has already\n  /// been loaded.\n  std::vector<IdentifierInfo *> IdentifiersLoaded;\n\n  using GlobalIdentifierMapType =\n      ContinuousRangeMap<serialization::IdentID, ModuleFile *, 4>;\n\n  /// Mapping from global identifier IDs to the module in which the\n  /// identifier resides along with the offset that should be added to the\n  /// global identifier ID to produce a local ID.\n  GlobalIdentifierMapType GlobalIdentifierMap;\n\n  /// A vector containing macros that have already been\n  /// loaded.\n  ///\n  /// If the pointer at index I is non-NULL, then it refers to the\n  /// MacroInfo for the identifier with ID=I+1 that has already\n  /// been loaded.\n  std::vector<MacroInfo *> MacrosLoaded;\n\n  using LoadedMacroInfo =\n      std::pair<IdentifierInfo *, serialization::SubmoduleID>;\n\n  /// A set of #undef directives that we have loaded; used to\n  /// deduplicate the same #undef information coming from multiple module\n  /// files.\n  llvm::DenseSet<LoadedMacroInfo> LoadedUndefs;\n\n  using GlobalMacroMapType =\n      ContinuousRangeMap<serialization::MacroID, ModuleFile *, 4>;\n\n  /// Mapping from global macro IDs to the module in which the\n  /// macro resides along with the offset that should be added to the\n  /// global macro ID to produce a local ID.\n  GlobalMacroMapType GlobalMacroMap;\n\n  /// A vector containing submodules that have already been loaded.\n  ///\n  /// This vector is indexed by the Submodule ID (-1). NULL submodule entries\n  /// indicate that the particular submodule ID has not yet been loaded.\n  SmallVector<Module *, 2> SubmodulesLoaded;\n\n  using GlobalSubmoduleMapType =\n      ContinuousRangeMap<serialization::SubmoduleID, ModuleFile *, 4>;\n\n  /// Mapping from global submodule IDs to the module file in which the\n  /// submodule resides along with the offset that should be added to the\n  /// global submodule ID to produce a local ID.\n  GlobalSubmoduleMapType GlobalSubmoduleMap;\n\n  /// A set of hidden declarations.\n  using HiddenNames = SmallVector<Decl *, 2>;\n  using HiddenNamesMapType = llvm::DenseMap<Module *, HiddenNames>;\n\n  /// A mapping from each of the hidden submodules to the deserialized\n  /// declarations in that submodule that could be made visible.\n  HiddenNamesMapType HiddenNamesMap;\n\n  /// A module import, export, or conflict that hasn't yet been resolved.\n  struct UnresolvedModuleRef {\n    /// The file in which this module resides.\n    ModuleFile *File;\n\n    /// The module that is importing or exporting.\n    Module *Mod;\n\n    /// The kind of module reference.\n    enum { Import, Export, Conflict } Kind;\n\n    /// The local ID of the module that is being exported.\n    unsigned ID;\n\n    /// Whether this is a wildcard export.\n    unsigned IsWildcard : 1;\n\n    /// String data.\n    StringRef String;\n  };\n\n  /// The set of module imports and exports that still need to be\n  /// resolved.\n  SmallVector<UnresolvedModuleRef, 2> UnresolvedModuleRefs;\n\n  /// A vector containing selectors that have already been loaded.\n  ///\n  /// This vector is indexed by the Selector ID (-1). NULL selector\n  /// entries indicate that the particular selector ID has not yet\n  /// been loaded.\n  SmallVector<Selector, 16> SelectorsLoaded;\n\n  using GlobalSelectorMapType =\n      ContinuousRangeMap<serialization::SelectorID, ModuleFile *, 4>;\n\n  /// Mapping from global selector IDs to the module in which the\n  /// global selector ID to produce a local ID.\n  GlobalSelectorMapType GlobalSelectorMap;\n\n  /// The generation number of the last time we loaded data from the\n  /// global method pool for this selector.\n  llvm::DenseMap<Selector, unsigned> SelectorGeneration;\n\n  /// Whether a selector is out of date. We mark a selector as out of date\n  /// if we load another module after the method pool entry was pulled in.\n  llvm::DenseMap<Selector, bool> SelectorOutOfDate;\n\n  struct PendingMacroInfo {\n    ModuleFile *M;\n    /// Offset relative to ModuleFile::MacroOffsetsBase.\n    uint32_t MacroDirectivesOffset;\n\n    PendingMacroInfo(ModuleFile *M, uint32_t MacroDirectivesOffset)\n        : M(M), MacroDirectivesOffset(MacroDirectivesOffset) {}\n  };\n\n  using PendingMacroIDsMap =\n      llvm::MapVector<IdentifierInfo *, SmallVector<PendingMacroInfo, 2>>;\n\n  /// Mapping from identifiers that have a macro history to the global\n  /// IDs have not yet been deserialized to the global IDs of those macros.\n  PendingMacroIDsMap PendingMacroIDs;\n\n  using GlobalPreprocessedEntityMapType =\n      ContinuousRangeMap<unsigned, ModuleFile *, 4>;\n\n  /// Mapping from global preprocessing entity IDs to the module in\n  /// which the preprocessed entity resides along with the offset that should be\n  /// added to the global preprocessing entity ID to produce a local ID.\n  GlobalPreprocessedEntityMapType GlobalPreprocessedEntityMap;\n\n  using GlobalSkippedRangeMapType =\n      ContinuousRangeMap<unsigned, ModuleFile *, 4>;\n\n  /// Mapping from global skipped range base IDs to the module in which\n  /// the skipped ranges reside.\n  GlobalSkippedRangeMapType GlobalSkippedRangeMap;\n\n  /// \\name CodeGen-relevant special data\n  /// Fields containing data that is relevant to CodeGen.\n  //@{\n\n  /// The IDs of all declarations that fulfill the criteria of\n  /// \"interesting\" decls.\n  ///\n  /// This contains the data loaded from all EAGERLY_DESERIALIZED_DECLS blocks\n  /// in the chain. The referenced declarations are deserialized and passed to\n  /// the consumer eagerly.\n  SmallVector<uint64_t, 16> EagerlyDeserializedDecls;\n\n  /// The IDs of all tentative definitions stored in the chain.\n  ///\n  /// Sema keeps track of all tentative definitions in a TU because it has to\n  /// complete them and pass them on to CodeGen. Thus, tentative definitions in\n  /// the PCH chain must be eagerly deserialized.\n  SmallVector<uint64_t, 16> TentativeDefinitions;\n\n  /// The IDs of all CXXRecordDecls stored in the chain whose VTables are\n  /// used.\n  ///\n  /// CodeGen has to emit VTables for these records, so they have to be eagerly\n  /// deserialized.\n  SmallVector<uint64_t, 64> VTableUses;\n\n  /// A snapshot of the pending instantiations in the chain.\n  ///\n  /// This record tracks the instantiations that Sema has to perform at the\n  /// end of the TU. It consists of a pair of values for every pending\n  /// instantiation where the first value is the ID of the decl and the second\n  /// is the instantiation location.\n  SmallVector<uint64_t, 64> PendingInstantiations;\n\n  //@}\n\n  /// \\name DiagnosticsEngine-relevant special data\n  /// Fields containing data that is used for generating diagnostics\n  //@{\n\n  /// A snapshot of Sema's unused file-scoped variable tracking, for\n  /// generating warnings.\n  SmallVector<uint64_t, 16> UnusedFileScopedDecls;\n\n  /// A list of all the delegating constructors we've seen, to diagnose\n  /// cycles.\n  SmallVector<uint64_t, 4> DelegatingCtorDecls;\n\n  /// Method selectors used in a @selector expression. Used for\n  /// implementation of -Wselector.\n  SmallVector<uint64_t, 64> ReferencedSelectorsData;\n\n  /// A snapshot of Sema's weak undeclared identifier tracking, for\n  /// generating warnings.\n  SmallVector<uint64_t, 64> WeakUndeclaredIdentifiers;\n\n  /// The IDs of type aliases for ext_vectors that exist in the chain.\n  ///\n  /// Used by Sema for finding sugared names for ext_vectors in diagnostics.\n  SmallVector<uint64_t, 4> ExtVectorDecls;\n\n  //@}\n\n  /// \\name Sema-relevant special data\n  /// Fields containing data that is used for semantic analysis\n  //@{\n\n  /// The IDs of all potentially unused typedef names in the chain.\n  ///\n  /// Sema tracks these to emit warnings.\n  SmallVector<uint64_t, 16> UnusedLocalTypedefNameCandidates;\n\n  /// Our current depth in #pragma cuda force_host_device begin/end\n  /// macros.\n  unsigned ForceCUDAHostDeviceDepth = 0;\n\n  /// The IDs of the declarations Sema stores directly.\n  ///\n  /// Sema tracks a few important decls, such as namespace std, directly.\n  SmallVector<uint64_t, 4> SemaDeclRefs;\n\n  /// The IDs of the types ASTContext stores directly.\n  ///\n  /// The AST context tracks a few important types, such as va_list, directly.\n  SmallVector<uint64_t, 16> SpecialTypes;\n\n  /// The IDs of CUDA-specific declarations ASTContext stores directly.\n  ///\n  /// The AST context tracks a few important decls, currently cudaConfigureCall,\n  /// directly.\n  SmallVector<uint64_t, 2> CUDASpecialDeclRefs;\n\n  /// The floating point pragma option settings.\n  SmallVector<uint64_t, 1> FPPragmaOptions;\n\n  /// The pragma clang optimize location (if the pragma state is \"off\").\n  SourceLocation OptimizeOffPragmaLocation;\n\n  /// The PragmaMSStructKind pragma ms_struct state if set, or -1.\n  int PragmaMSStructState = -1;\n\n  /// The PragmaMSPointersToMembersKind pragma pointers_to_members state.\n  int PragmaMSPointersToMembersState = -1;\n  SourceLocation PointersToMembersPragmaLocation;\n\n  /// The pragma float_control state.\n  Optional<FPOptionsOverride> FpPragmaCurrentValue;\n  SourceLocation FpPragmaCurrentLocation;\n  struct FpPragmaStackEntry {\n    FPOptionsOverride Value;\n    SourceLocation Location;\n    SourceLocation PushLocation;\n    StringRef SlotLabel;\n  };\n  llvm::SmallVector<FpPragmaStackEntry, 2> FpPragmaStack;\n  llvm::SmallVector<std::string, 2> FpPragmaStrings;\n\n  /// The pragma align/pack state.\n  Optional<Sema::AlignPackInfo> PragmaAlignPackCurrentValue;\n  SourceLocation PragmaAlignPackCurrentLocation;\n  struct PragmaAlignPackStackEntry {\n    Sema::AlignPackInfo Value;\n    SourceLocation Location;\n    SourceLocation PushLocation;\n    StringRef SlotLabel;\n  };\n  llvm::SmallVector<PragmaAlignPackStackEntry, 2> PragmaAlignPackStack;\n  llvm::SmallVector<std::string, 2> PragmaAlignPackStrings;\n\n  /// The OpenCL extension settings.\n  OpenCLOptions OpenCLExtensions;\n\n  /// Extensions required by an OpenCL type.\n  llvm::DenseMap<const Type *, std::set<std::string>> OpenCLTypeExtMap;\n\n  /// Extensions required by an OpenCL declaration.\n  llvm::DenseMap<const Decl *, std::set<std::string>> OpenCLDeclExtMap;\n\n  /// A list of the namespaces we've seen.\n  SmallVector<uint64_t, 4> KnownNamespaces;\n\n  /// A list of undefined decls with internal linkage followed by the\n  /// SourceLocation of a matching ODR-use.\n  SmallVector<uint64_t, 8> UndefinedButUsed;\n\n  /// Delete expressions to analyze at the end of translation unit.\n  SmallVector<uint64_t, 8> DelayedDeleteExprs;\n\n  // A list of late parsed template function data with their module files.\n  SmallVector<std::pair<ModuleFile *, SmallVector<uint64_t, 1>>, 4>\n      LateParsedTemplates;\n\n  /// The IDs of all decls to be checked for deferred diags.\n  ///\n  /// Sema tracks these to emit deferred diags.\n  SmallVector<uint64_t, 4> DeclsToCheckForDeferredDiags;\n\n\npublic:\n  struct ImportedSubmodule {\n    serialization::SubmoduleID ID;\n    SourceLocation ImportLoc;\n\n    ImportedSubmodule(serialization::SubmoduleID ID, SourceLocation ImportLoc)\n        : ID(ID), ImportLoc(ImportLoc) {}\n  };\n\nprivate:\n  /// A list of modules that were imported by precompiled headers or\n  /// any other non-module AST file.\n  SmallVector<ImportedSubmodule, 2> ImportedModules;\n  //@}\n\n  /// The system include root to be used when loading the\n  /// precompiled header.\n  std::string isysroot;\n\n  /// Whether to disable the normal validation performed on precompiled\n  /// headers and module files when they are loaded.\n  DisableValidationForModuleKind DisableValidationKind;\n\n  /// Whether to accept an AST file with compiler errors.\n  bool AllowASTWithCompilerErrors;\n\n  /// Whether to accept an AST file that has a different configuration\n  /// from the current compiler instance.\n  bool AllowConfigurationMismatch;\n\n  /// Whether validate system input files.\n  bool ValidateSystemInputs;\n\n  /// Whether validate headers and module maps using hash based on contents.\n  bool ValidateASTInputFilesContent;\n\n  /// Whether we are allowed to use the global module index.\n  bool UseGlobalIndex;\n\n  /// Whether we have tried loading the global module index yet.\n  bool TriedLoadingGlobalIndex = false;\n\n  ///Whether we are currently processing update records.\n  bool ProcessingUpdateRecords = false;\n\n  using SwitchCaseMapTy = llvm::DenseMap<unsigned, SwitchCase *>;\n\n  /// Mapping from switch-case IDs in the chain to switch-case statements\n  ///\n  /// Statements usually don't have IDs, but switch cases need them, so that the\n  /// switch statement can refer to them.\n  SwitchCaseMapTy SwitchCaseStmts;\n\n  SwitchCaseMapTy *CurrSwitchCaseStmts;\n\n  /// The number of source location entries de-serialized from\n  /// the PCH file.\n  unsigned NumSLocEntriesRead = 0;\n\n  /// The number of source location entries in the chain.\n  unsigned TotalNumSLocEntries = 0;\n\n  /// The number of statements (and expressions) de-serialized\n  /// from the chain.\n  unsigned NumStatementsRead = 0;\n\n  /// The total number of statements (and expressions) stored\n  /// in the chain.\n  unsigned TotalNumStatements = 0;\n\n  /// The number of macros de-serialized from the chain.\n  unsigned NumMacrosRead = 0;\n\n  /// The total number of macros stored in the chain.\n  unsigned TotalNumMacros = 0;\n\n  /// The number of lookups into identifier tables.\n  unsigned NumIdentifierLookups = 0;\n\n  /// The number of lookups into identifier tables that succeed.\n  unsigned NumIdentifierLookupHits = 0;\n\n  /// The number of selectors that have been read.\n  unsigned NumSelectorsRead = 0;\n\n  /// The number of method pool entries that have been read.\n  unsigned NumMethodPoolEntriesRead = 0;\n\n  /// The number of times we have looked up a selector in the method\n  /// pool.\n  unsigned NumMethodPoolLookups = 0;\n\n  /// The number of times we have looked up a selector in the method\n  /// pool and found something.\n  unsigned NumMethodPoolHits = 0;\n\n  /// The number of times we have looked up a selector in the method\n  /// pool within a specific module.\n  unsigned NumMethodPoolTableLookups = 0;\n\n  /// The number of times we have looked up a selector in the method\n  /// pool within a specific module and found something.\n  unsigned NumMethodPoolTableHits = 0;\n\n  /// The total number of method pool entries in the selector table.\n  unsigned TotalNumMethodPoolEntries = 0;\n\n  /// Number of lexical decl contexts read/total.\n  unsigned NumLexicalDeclContextsRead = 0, TotalLexicalDeclContexts = 0;\n\n  /// Number of visible decl contexts read/total.\n  unsigned NumVisibleDeclContextsRead = 0, TotalVisibleDeclContexts = 0;\n\n  /// Total size of modules, in bits, currently loaded\n  uint64_t TotalModulesSizeInBits = 0;\n\n  /// Number of Decl/types that are currently deserializing.\n  unsigned NumCurrentElementsDeserializing = 0;\n\n  /// Set true while we are in the process of passing deserialized\n  /// \"interesting\" decls to consumer inside FinishedDeserializing().\n  /// This is used as a guard to avoid recursively repeating the process of\n  /// passing decls to consumer.\n  bool PassingDeclsToConsumer = false;\n\n  /// The set of identifiers that were read while the AST reader was\n  /// (recursively) loading declarations.\n  ///\n  /// The declarations on the identifier chain for these identifiers will be\n  /// loaded once the recursive loading has completed.\n  llvm::MapVector<IdentifierInfo *, SmallVector<uint32_t, 4>>\n    PendingIdentifierInfos;\n\n  /// The set of lookup results that we have faked in order to support\n  /// merging of partially deserialized decls but that we have not yet removed.\n  llvm::SmallMapVector<IdentifierInfo *, SmallVector<NamedDecl*, 2>, 16>\n    PendingFakeLookupResults;\n\n  /// The generation number of each identifier, which keeps track of\n  /// the last time we loaded information about this identifier.\n  llvm::DenseMap<IdentifierInfo *, unsigned> IdentifierGeneration;\n\n  class InterestingDecl {\n    Decl *D;\n    bool DeclHasPendingBody;\n\n  public:\n    InterestingDecl(Decl *D, bool HasBody)\n        : D(D), DeclHasPendingBody(HasBody) {}\n\n    Decl *getDecl() { return D; }\n\n    /// Whether the declaration has a pending body.\n    bool hasPendingBody() { return DeclHasPendingBody; }\n  };\n\n  /// Contains declarations and definitions that could be\n  /// \"interesting\" to the ASTConsumer, when we get that AST consumer.\n  ///\n  /// \"Interesting\" declarations are those that have data that may\n  /// need to be emitted, such as inline function definitions or\n  /// Objective-C protocols.\n  std::deque<InterestingDecl> PotentiallyInterestingDecls;\n\n  /// The list of deduced function types that we have not yet read, because\n  /// they might contain a deduced return type that refers to a local type\n  /// declared within the function.\n  SmallVector<std::pair<FunctionDecl *, serialization::TypeID>, 16>\n      PendingFunctionTypes;\n\n  /// The list of redeclaration chains that still need to be\n  /// reconstructed, and the local offset to the corresponding list\n  /// of redeclarations.\n  SmallVector<std::pair<Decl *, uint64_t>, 16> PendingDeclChains;\n\n  /// The list of canonical declarations whose redeclaration chains\n  /// need to be marked as incomplete once we're done deserializing things.\n  SmallVector<Decl *, 16> PendingIncompleteDeclChains;\n\n  /// The Decl IDs for the Sema/Lexical DeclContext of a Decl that has\n  /// been loaded but its DeclContext was not set yet.\n  struct PendingDeclContextInfo {\n    Decl *D;\n    serialization::GlobalDeclID SemaDC;\n    serialization::GlobalDeclID LexicalDC;\n  };\n\n  /// The set of Decls that have been loaded but their DeclContexts are\n  /// not set yet.\n  ///\n  /// The DeclContexts for these Decls will be set once recursive loading has\n  /// been completed.\n  std::deque<PendingDeclContextInfo> PendingDeclContextInfos;\n\n  /// The set of NamedDecls that have been loaded, but are members of a\n  /// context that has been merged into another context where the corresponding\n  /// declaration is either missing or has not yet been loaded.\n  ///\n  /// We will check whether the corresponding declaration is in fact missing\n  /// once recursing loading has been completed.\n  llvm::SmallVector<NamedDecl *, 16> PendingOdrMergeChecks;\n\n  using DataPointers =\n      std::pair<CXXRecordDecl *, struct CXXRecordDecl::DefinitionData *>;\n\n  /// Record definitions in which we found an ODR violation.\n  llvm::SmallDenseMap<CXXRecordDecl *, llvm::SmallVector<DataPointers, 2>, 2>\n      PendingOdrMergeFailures;\n\n  /// Function definitions in which we found an ODR violation.\n  llvm::SmallDenseMap<FunctionDecl *, llvm::SmallVector<FunctionDecl *, 2>, 2>\n      PendingFunctionOdrMergeFailures;\n\n  /// Enum definitions in which we found an ODR violation.\n  llvm::SmallDenseMap<EnumDecl *, llvm::SmallVector<EnumDecl *, 2>, 2>\n      PendingEnumOdrMergeFailures;\n\n  /// DeclContexts in which we have diagnosed an ODR violation.\n  llvm::SmallPtrSet<DeclContext*, 2> DiagnosedOdrMergeFailures;\n\n  /// The set of Objective-C categories that have been deserialized\n  /// since the last time the declaration chains were linked.\n  llvm::SmallPtrSet<ObjCCategoryDecl *, 16> CategoriesDeserialized;\n\n  /// The set of Objective-C class definitions that have already been\n  /// loaded, for which we will need to check for categories whenever a new\n  /// module is loaded.\n  SmallVector<ObjCInterfaceDecl *, 16> ObjCClassesLoaded;\n\n  using KeyDeclsMap =\n      llvm::DenseMap<Decl *, SmallVector<serialization::DeclID, 2>>;\n\n  /// A mapping from canonical declarations to the set of global\n  /// declaration IDs for key declaration that have been merged with that\n  /// canonical declaration. A key declaration is a formerly-canonical\n  /// declaration whose module did not import any other key declaration for that\n  /// entity. These are the IDs that we use as keys when finding redecl chains.\n  KeyDeclsMap KeyDecls;\n\n  /// A mapping from DeclContexts to the semantic DeclContext that we\n  /// are treating as the definition of the entity. This is used, for instance,\n  /// when merging implicit instantiations of class templates across modules.\n  llvm::DenseMap<DeclContext *, DeclContext *> MergedDeclContexts;\n\n  /// A mapping from canonical declarations of enums to their canonical\n  /// definitions. Only populated when using modules in C++.\n  llvm::DenseMap<EnumDecl *, EnumDecl *> EnumDefinitions;\n\n  /// When reading a Stmt tree, Stmt operands are placed in this stack.\n  SmallVector<Stmt *, 16> StmtStack;\n\n  /// What kind of records we are reading.\n  enum ReadingKind {\n    Read_None, Read_Decl, Read_Type, Read_Stmt\n  };\n\n  /// What kind of records we are reading.\n  ReadingKind ReadingKind = Read_None;\n\n  /// RAII object to change the reading kind.\n  class ReadingKindTracker {\n    ASTReader &Reader;\n    enum ReadingKind PrevKind;\n\n  public:\n    ReadingKindTracker(enum ReadingKind newKind, ASTReader &reader)\n        : Reader(reader), PrevKind(Reader.ReadingKind) {\n      Reader.ReadingKind = newKind;\n    }\n\n    ReadingKindTracker(const ReadingKindTracker &) = delete;\n    ReadingKindTracker &operator=(const ReadingKindTracker &) = delete;\n    ~ReadingKindTracker() { Reader.ReadingKind = PrevKind; }\n  };\n\n  /// RAII object to mark the start of processing updates.\n  class ProcessingUpdatesRAIIObj {\n    ASTReader &Reader;\n    bool PrevState;\n\n  public:\n    ProcessingUpdatesRAIIObj(ASTReader &reader)\n        : Reader(reader), PrevState(Reader.ProcessingUpdateRecords) {\n      Reader.ProcessingUpdateRecords = true;\n    }\n\n    ProcessingUpdatesRAIIObj(const ProcessingUpdatesRAIIObj &) = delete;\n    ProcessingUpdatesRAIIObj &\n    operator=(const ProcessingUpdatesRAIIObj &) = delete;\n    ~ProcessingUpdatesRAIIObj() { Reader.ProcessingUpdateRecords = PrevState; }\n  };\n\n  /// Suggested contents of the predefines buffer, after this\n  /// PCH file has been processed.\n  ///\n  /// In most cases, this string will be empty, because the predefines\n  /// buffer computed to build the PCH file will be identical to the\n  /// predefines buffer computed from the command line. However, when\n  /// there are differences that the PCH reader can work around, this\n  /// predefines buffer may contain additional definitions.\n  std::string SuggestedPredefines;\n\n  llvm::DenseMap<const Decl *, bool> DefinitionSource;\n\n  bool shouldDisableValidationForFile(const serialization::ModuleFile &M) const;\n\n  /// Reads a statement from the specified cursor.\n  Stmt *ReadStmtFromStream(ModuleFile &F);\n\n  struct InputFileInfo {\n    std::string Filename;\n    uint64_t ContentHash;\n    off_t StoredSize;\n    time_t StoredTime;\n    bool Overridden;\n    bool Transient;\n    bool TopLevelModuleMap;\n  };\n\n  /// Reads the stored information about an input file.\n  InputFileInfo readInputFileInfo(ModuleFile &F, unsigned ID);\n\n  /// Retrieve the file entry and 'overridden' bit for an input\n  /// file in the given module file.\n  serialization::InputFile getInputFile(ModuleFile &F, unsigned ID,\n                                        bool Complain = true);\n\npublic:\n  void ResolveImportedPath(ModuleFile &M, std::string &Filename);\n  static void ResolveImportedPath(std::string &Filename, StringRef Prefix);\n\n  /// Returns the first key declaration for the given declaration. This\n  /// is one that is formerly-canonical (or still canonical) and whose module\n  /// did not import any other key declaration of the entity.\n  Decl *getKeyDeclaration(Decl *D) {\n    D = D->getCanonicalDecl();\n    if (D->isFromASTFile())\n      return D;\n\n    auto I = KeyDecls.find(D);\n    if (I == KeyDecls.end() || I->second.empty())\n      return D;\n    return GetExistingDecl(I->second[0]);\n  }\n  const Decl *getKeyDeclaration(const Decl *D) {\n    return getKeyDeclaration(const_cast<Decl*>(D));\n  }\n\n  /// Run a callback on each imported key declaration of \\p D.\n  template <typename Fn>\n  void forEachImportedKeyDecl(const Decl *D, Fn Visit) {\n    D = D->getCanonicalDecl();\n    if (D->isFromASTFile())\n      Visit(D);\n\n    auto It = KeyDecls.find(const_cast<Decl*>(D));\n    if (It != KeyDecls.end())\n      for (auto ID : It->second)\n        Visit(GetExistingDecl(ID));\n  }\n\n  /// Get the loaded lookup tables for \\p Primary, if any.\n  const serialization::reader::DeclContextLookupTable *\n  getLoadedLookupTables(DeclContext *Primary) const;\n\nprivate:\n  struct ImportedModule {\n    ModuleFile *Mod;\n    ModuleFile *ImportedBy;\n    SourceLocation ImportLoc;\n\n    ImportedModule(ModuleFile *Mod,\n                   ModuleFile *ImportedBy,\n                   SourceLocation ImportLoc)\n        : Mod(Mod), ImportedBy(ImportedBy), ImportLoc(ImportLoc) {}\n  };\n\n  ASTReadResult ReadASTCore(StringRef FileName, ModuleKind Type,\n                            SourceLocation ImportLoc, ModuleFile *ImportedBy,\n                            SmallVectorImpl<ImportedModule> &Loaded,\n                            off_t ExpectedSize, time_t ExpectedModTime,\n                            ASTFileSignature ExpectedSignature,\n                            unsigned ClientLoadCapabilities);\n  ASTReadResult ReadControlBlock(ModuleFile &F,\n                                 SmallVectorImpl<ImportedModule> &Loaded,\n                                 const ModuleFile *ImportedBy,\n                                 unsigned ClientLoadCapabilities);\n  static ASTReadResult ReadOptionsBlock(\n      llvm::BitstreamCursor &Stream, unsigned ClientLoadCapabilities,\n      bool AllowCompatibleConfigurationMismatch, ASTReaderListener &Listener,\n      std::string &SuggestedPredefines);\n\n  /// Read the unhashed control block.\n  ///\n  /// This has no effect on \\c F.Stream, instead creating a fresh cursor from\n  /// \\c F.Data and reading ahead.\n  ASTReadResult readUnhashedControlBlock(ModuleFile &F, bool WasImportedBy,\n                                         unsigned ClientLoadCapabilities);\n\n  static ASTReadResult\n  readUnhashedControlBlockImpl(ModuleFile *F, llvm::StringRef StreamData,\n                               unsigned ClientLoadCapabilities,\n                               bool AllowCompatibleConfigurationMismatch,\n                               ASTReaderListener *Listener,\n                               bool ValidateDiagnosticOptions);\n\n  ASTReadResult ReadASTBlock(ModuleFile &F, unsigned ClientLoadCapabilities);\n  ASTReadResult ReadExtensionBlock(ModuleFile &F);\n  void ReadModuleOffsetMap(ModuleFile &F) const;\n  bool ParseLineTable(ModuleFile &F, const RecordData &Record);\n  bool ReadSourceManagerBlock(ModuleFile &F);\n  llvm::BitstreamCursor &SLocCursorForID(int ID);\n  SourceLocation getImportLocation(ModuleFile *F);\n  ASTReadResult ReadModuleMapFileBlock(RecordData &Record, ModuleFile &F,\n                                       const ModuleFile *ImportedBy,\n                                       unsigned ClientLoadCapabilities);\n  ASTReadResult ReadSubmoduleBlock(ModuleFile &F,\n                                   unsigned ClientLoadCapabilities);\n  static bool ParseLanguageOptions(const RecordData &Record, bool Complain,\n                                   ASTReaderListener &Listener,\n                                   bool AllowCompatibleDifferences);\n  static bool ParseTargetOptions(const RecordData &Record, bool Complain,\n                                 ASTReaderListener &Listener,\n                                 bool AllowCompatibleDifferences);\n  static bool ParseDiagnosticOptions(const RecordData &Record, bool Complain,\n                                     ASTReaderListener &Listener);\n  static bool ParseFileSystemOptions(const RecordData &Record, bool Complain,\n                                     ASTReaderListener &Listener);\n  static bool ParseHeaderSearchOptions(const RecordData &Record, bool Complain,\n                                       ASTReaderListener &Listener);\n  static bool ParsePreprocessorOptions(const RecordData &Record, bool Complain,\n                                       ASTReaderListener &Listener,\n                                       std::string &SuggestedPredefines);\n\n  struct RecordLocation {\n    ModuleFile *F;\n    uint64_t Offset;\n\n    RecordLocation(ModuleFile *M, uint64_t O) : F(M), Offset(O) {}\n  };\n\n  QualType readTypeRecord(unsigned Index);\n  RecordLocation TypeCursorForIndex(unsigned Index);\n  void LoadedDecl(unsigned Index, Decl *D);\n  Decl *ReadDeclRecord(serialization::DeclID ID);\n  void markIncompleteDeclChain(Decl *Canon);\n\n  /// Returns the most recent declaration of a declaration (which must be\n  /// of a redeclarable kind) that is either local or has already been loaded\n  /// merged into its redecl chain.\n  Decl *getMostRecentExistingDecl(Decl *D);\n\n  RecordLocation DeclCursorForID(serialization::DeclID ID,\n                                 SourceLocation &Location);\n  void loadDeclUpdateRecords(PendingUpdateRecord &Record);\n  void loadPendingDeclChain(Decl *D, uint64_t LocalOffset);\n  void loadObjCCategories(serialization::GlobalDeclID ID, ObjCInterfaceDecl *D,\n                          unsigned PreviousGeneration = 0);\n\n  RecordLocation getLocalBitOffset(uint64_t GlobalOffset);\n  uint64_t getGlobalBitOffset(ModuleFile &M, uint64_t LocalOffset);\n\n  /// Returns the first preprocessed entity ID that begins or ends after\n  /// \\arg Loc.\n  serialization::PreprocessedEntityID\n  findPreprocessedEntity(SourceLocation Loc, bool EndsAfter) const;\n\n  /// Find the next module that contains entities and return the ID\n  /// of the first entry.\n  ///\n  /// \\param SLocMapI points at a chunk of a module that contains no\n  /// preprocessed entities or the entities it contains are not the\n  /// ones we are looking for.\n  serialization::PreprocessedEntityID\n    findNextPreprocessedEntity(\n                        GlobalSLocOffsetMapType::const_iterator SLocMapI) const;\n\n  /// Returns (ModuleFile, Local index) pair for \\p GlobalIndex of a\n  /// preprocessed entity.\n  std::pair<ModuleFile *, unsigned>\n    getModulePreprocessedEntity(unsigned GlobalIndex);\n\n  /// Returns (begin, end) pair for the preprocessed entities of a\n  /// particular module.\n  llvm::iterator_range<PreprocessingRecord::iterator>\n  getModulePreprocessedEntities(ModuleFile &Mod) const;\n\npublic:\n  class ModuleDeclIterator\n      : public llvm::iterator_adaptor_base<\n            ModuleDeclIterator, const serialization::LocalDeclID *,\n            std::random_access_iterator_tag, const Decl *, ptrdiff_t,\n            const Decl *, const Decl *> {\n    ASTReader *Reader = nullptr;\n    ModuleFile *Mod = nullptr;\n\n  public:\n    ModuleDeclIterator() : iterator_adaptor_base(nullptr) {}\n\n    ModuleDeclIterator(ASTReader *Reader, ModuleFile *Mod,\n                       const serialization::LocalDeclID *Pos)\n        : iterator_adaptor_base(Pos), Reader(Reader), Mod(Mod) {}\n\n    value_type operator*() const {\n      return Reader->GetDecl(Reader->getGlobalDeclID(*Mod, *I));\n    }\n\n    value_type operator->() const { return **this; }\n\n    bool operator==(const ModuleDeclIterator &RHS) const {\n      assert(Reader == RHS.Reader && Mod == RHS.Mod);\n      return I == RHS.I;\n    }\n  };\n\n  llvm::iterator_range<ModuleDeclIterator>\n  getModuleFileLevelDecls(ModuleFile &Mod);\n\nprivate:\n  void PassInterestingDeclsToConsumer();\n  void PassInterestingDeclToConsumer(Decl *D);\n\n  void finishPendingActions();\n  void diagnoseOdrViolations();\n\n  void pushExternalDeclIntoScope(NamedDecl *D, DeclarationName Name);\n\n  void addPendingDeclContextInfo(Decl *D,\n                                 serialization::GlobalDeclID SemaDC,\n                                 serialization::GlobalDeclID LexicalDC) {\n    assert(D);\n    PendingDeclContextInfo Info = { D, SemaDC, LexicalDC };\n    PendingDeclContextInfos.push_back(Info);\n  }\n\n  /// Produce an error diagnostic and return true.\n  ///\n  /// This routine should only be used for fatal errors that have to\n  /// do with non-routine failures (e.g., corrupted AST file).\n  void Error(StringRef Msg) const;\n  void Error(unsigned DiagID, StringRef Arg1 = StringRef(),\n             StringRef Arg2 = StringRef(), StringRef Arg3 = StringRef()) const;\n  void Error(llvm::Error &&Err) const;\n\npublic:\n  /// Load the AST file and validate its contents against the given\n  /// Preprocessor.\n  ///\n  /// \\param PP the preprocessor associated with the context in which this\n  /// precompiled header will be loaded.\n  ///\n  /// \\param Context the AST context that this precompiled header will be\n  /// loaded into, if any.\n  ///\n  /// \\param PCHContainerRdr the PCHContainerOperations to use for loading and\n  /// creating modules.\n  ///\n  /// \\param Extensions the list of module file extensions that can be loaded\n  /// from the AST files.\n  ///\n  /// \\param isysroot If non-NULL, the system include path specified by the\n  /// user. This is only used with relocatable PCH files. If non-NULL,\n  /// a relocatable PCH file will use the default path \"/\".\n  ///\n  /// \\param DisableValidationKind If set, the AST reader will suppress most\n  /// of its regular consistency checking, allowing the use of precompiled\n  /// headers and module files that cannot be determined to be compatible.\n  ///\n  /// \\param AllowASTWithCompilerErrors If true, the AST reader will accept an\n  /// AST file the was created out of an AST with compiler errors,\n  /// otherwise it will reject it.\n  ///\n  /// \\param AllowConfigurationMismatch If true, the AST reader will not check\n  /// for configuration differences between the AST file and the invocation.\n  ///\n  /// \\param ValidateSystemInputs If true, the AST reader will validate\n  /// system input files in addition to user input files. This is only\n  /// meaningful if \\p DisableValidation is false.\n  ///\n  /// \\param UseGlobalIndex If true, the AST reader will try to load and use\n  /// the global module index.\n  ///\n  /// \\param ReadTimer If non-null, a timer used to track the time spent\n  /// deserializing.\n  ASTReader(Preprocessor &PP, InMemoryModuleCache &ModuleCache,\n            ASTContext *Context, const PCHContainerReader &PCHContainerRdr,\n            ArrayRef<std::shared_ptr<ModuleFileExtension>> Extensions,\n            StringRef isysroot = \"\",\n            DisableValidationForModuleKind DisableValidationKind =\n                DisableValidationForModuleKind::None,\n            bool AllowASTWithCompilerErrors = false,\n            bool AllowConfigurationMismatch = false,\n            bool ValidateSystemInputs = false,\n            bool ValidateASTInputFilesContent = false,\n            bool UseGlobalIndex = true,\n            std::unique_ptr<llvm::Timer> ReadTimer = {});\n  ASTReader(const ASTReader &) = delete;\n  ASTReader &operator=(const ASTReader &) = delete;\n  ~ASTReader() override;\n\n  SourceManager &getSourceManager() const { return SourceMgr; }\n  FileManager &getFileManager() const { return FileMgr; }\n  DiagnosticsEngine &getDiags() const { return Diags; }\n\n  /// Flags that indicate what kind of AST loading failures the client\n  /// of the AST reader can directly handle.\n  ///\n  /// When a client states that it can handle a particular kind of failure,\n  /// the AST reader will not emit errors when producing that kind of failure.\n  enum LoadFailureCapabilities {\n    /// The client can't handle any AST loading failures.\n    ARR_None = 0,\n\n    /// The client can handle an AST file that cannot load because it\n    /// is missing.\n    ARR_Missing = 0x1,\n\n    /// The client can handle an AST file that cannot load because it\n    /// is out-of-date relative to its input files.\n    ARR_OutOfDate = 0x2,\n\n    /// The client can handle an AST file that cannot load because it\n    /// was built with a different version of Clang.\n    ARR_VersionMismatch = 0x4,\n\n    /// The client can handle an AST file that cannot load because it's\n    /// compiled configuration doesn't match that of the context it was\n    /// loaded into.\n    ARR_ConfigurationMismatch = 0x8,\n\n    /// If a module file is marked with errors treat it as out-of-date so the\n    /// caller can rebuild it.\n    ARR_TreatModuleWithErrorsAsOutOfDate = 0x10\n  };\n\n  /// Load the AST file designated by the given file name.\n  ///\n  /// \\param FileName The name of the AST file to load.\n  ///\n  /// \\param Type The kind of AST being loaded, e.g., PCH, module, main file,\n  /// or preamble.\n  ///\n  /// \\param ImportLoc the location where the module file will be considered as\n  /// imported from. For non-module AST types it should be invalid.\n  ///\n  /// \\param ClientLoadCapabilities The set of client load-failure\n  /// capabilities, represented as a bitset of the enumerators of\n  /// LoadFailureCapabilities.\n  ///\n  /// \\param Imported optional out-parameter to append the list of modules\n  /// that were imported by precompiled headers or any other non-module AST file\n  ASTReadResult ReadAST(StringRef FileName, ModuleKind Type,\n                        SourceLocation ImportLoc,\n                        unsigned ClientLoadCapabilities,\n                        SmallVectorImpl<ImportedSubmodule> *Imported = nullptr);\n\n  /// Make the entities in the given module and any of its (non-explicit)\n  /// submodules visible to name lookup.\n  ///\n  /// \\param Mod The module whose names should be made visible.\n  ///\n  /// \\param NameVisibility The level of visibility to give the names in the\n  /// module.  Visibility can only be increased over time.\n  ///\n  /// \\param ImportLoc The location at which the import occurs.\n  void makeModuleVisible(Module *Mod,\n                         Module::NameVisibilityKind NameVisibility,\n                         SourceLocation ImportLoc);\n\n  /// Make the names within this set of hidden names visible.\n  void makeNamesVisible(const HiddenNames &Names, Module *Owner);\n\n  /// Note that MergedDef is a redefinition of the canonical definition\n  /// Def, so Def should be visible whenever MergedDef is.\n  void mergeDefinitionVisibility(NamedDecl *Def, NamedDecl *MergedDef);\n\n  /// Take the AST callbacks listener.\n  std::unique_ptr<ASTReaderListener> takeListener() {\n    return std::move(Listener);\n  }\n\n  /// Set the AST callbacks listener.\n  void setListener(std::unique_ptr<ASTReaderListener> Listener) {\n    this->Listener = std::move(Listener);\n  }\n\n  /// Add an AST callback listener.\n  ///\n  /// Takes ownership of \\p L.\n  void addListener(std::unique_ptr<ASTReaderListener> L) {\n    if (Listener)\n      L = std::make_unique<ChainedASTReaderListener>(std::move(L),\n                                                      std::move(Listener));\n    Listener = std::move(L);\n  }\n\n  /// RAII object to temporarily add an AST callback listener.\n  class ListenerScope {\n    ASTReader &Reader;\n    bool Chained = false;\n\n  public:\n    ListenerScope(ASTReader &Reader, std::unique_ptr<ASTReaderListener> L)\n        : Reader(Reader) {\n      auto Old = Reader.takeListener();\n      if (Old) {\n        Chained = true;\n        L = std::make_unique<ChainedASTReaderListener>(std::move(L),\n                                                        std::move(Old));\n      }\n      Reader.setListener(std::move(L));\n    }\n\n    ~ListenerScope() {\n      auto New = Reader.takeListener();\n      if (Chained)\n        Reader.setListener(static_cast<ChainedASTReaderListener *>(New.get())\n                               ->takeSecond());\n    }\n  };\n\n  /// Set the AST deserialization listener.\n  void setDeserializationListener(ASTDeserializationListener *Listener,\n                                  bool TakeOwnership = false);\n\n  /// Get the AST deserialization listener.\n  ASTDeserializationListener *getDeserializationListener() {\n    return DeserializationListener;\n  }\n\n  /// Determine whether this AST reader has a global index.\n  bool hasGlobalIndex() const { return (bool)GlobalIndex; }\n\n  /// Return global module index.\n  GlobalModuleIndex *getGlobalIndex() { return GlobalIndex.get(); }\n\n  /// Reset reader for a reload try.\n  void resetForReload() { TriedLoadingGlobalIndex = false; }\n\n  /// Attempts to load the global index.\n  ///\n  /// \\returns true if loading the global index has failed for any reason.\n  bool loadGlobalIndex();\n\n  /// Determine whether we tried to load the global index, but failed,\n  /// e.g., because it is out-of-date or does not exist.\n  bool isGlobalIndexUnavailable() const;\n\n  /// Initializes the ASTContext\n  void InitializeContext();\n\n  /// Update the state of Sema after loading some additional modules.\n  void UpdateSema();\n\n  /// Add in-memory (virtual file) buffer.\n  void addInMemoryBuffer(StringRef &FileName,\n                         std::unique_ptr<llvm::MemoryBuffer> Buffer) {\n    ModuleMgr.addInMemoryBuffer(FileName, std::move(Buffer));\n  }\n\n  /// Finalizes the AST reader's state before writing an AST file to\n  /// disk.\n  ///\n  /// This operation may undo temporary state in the AST that should not be\n  /// emitted.\n  void finalizeForWriting();\n\n  /// Retrieve the module manager.\n  ModuleManager &getModuleManager() { return ModuleMgr; }\n\n  /// Retrieve the preprocessor.\n  Preprocessor &getPreprocessor() const { return PP; }\n\n  /// Retrieve the name of the original source file name for the primary\n  /// module file.\n  StringRef getOriginalSourceFile() {\n    return ModuleMgr.getPrimaryModule().OriginalSourceFileName;\n  }\n\n  /// Retrieve the name of the original source file name directly from\n  /// the AST file, without actually loading the AST file.\n  static std::string\n  getOriginalSourceFile(const std::string &ASTFileName, FileManager &FileMgr,\n                        const PCHContainerReader &PCHContainerRdr,\n                        DiagnosticsEngine &Diags);\n\n  /// Read the control block for the named AST file.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  static bool\n  readASTFileControlBlock(StringRef Filename, FileManager &FileMgr,\n                          const PCHContainerReader &PCHContainerRdr,\n                          bool FindModuleFileExtensions,\n                          ASTReaderListener &Listener,\n                          bool ValidateDiagnosticOptions);\n\n  /// Determine whether the given AST file is acceptable to load into a\n  /// translation unit with the given language and target options.\n  static bool isAcceptableASTFile(StringRef Filename, FileManager &FileMgr,\n                                  const PCHContainerReader &PCHContainerRdr,\n                                  const LangOptions &LangOpts,\n                                  const TargetOptions &TargetOpts,\n                                  const PreprocessorOptions &PPOpts,\n                                  StringRef ExistingModuleCachePath);\n\n  /// Returns the suggested contents of the predefines buffer,\n  /// which contains a (typically-empty) subset of the predefines\n  /// build prior to including the precompiled header.\n  const std::string &getSuggestedPredefines() { return SuggestedPredefines; }\n\n  /// Read a preallocated preprocessed entity from the external source.\n  ///\n  /// \\returns null if an error occurred that prevented the preprocessed\n  /// entity from being loaded.\n  PreprocessedEntity *ReadPreprocessedEntity(unsigned Index) override;\n\n  /// Returns a pair of [Begin, End) indices of preallocated\n  /// preprocessed entities that \\p Range encompasses.\n  std::pair<unsigned, unsigned>\n      findPreprocessedEntitiesInRange(SourceRange Range) override;\n\n  /// Optionally returns true or false if the preallocated preprocessed\n  /// entity with index \\p Index came from file \\p FID.\n  Optional<bool> isPreprocessedEntityInFileID(unsigned Index,\n                                              FileID FID) override;\n\n  /// Read a preallocated skipped range from the external source.\n  SourceRange ReadSkippedRange(unsigned Index) override;\n\n  /// Read the header file information for the given file entry.\n  HeaderFileInfo GetHeaderFileInfo(const FileEntry *FE) override;\n\n  void ReadPragmaDiagnosticMappings(DiagnosticsEngine &Diag);\n\n  /// Returns the number of source locations found in the chain.\n  unsigned getTotalNumSLocs() const {\n    return TotalNumSLocEntries;\n  }\n\n  /// Returns the number of identifiers found in the chain.\n  unsigned getTotalNumIdentifiers() const {\n    return static_cast<unsigned>(IdentifiersLoaded.size());\n  }\n\n  /// Returns the number of macros found in the chain.\n  unsigned getTotalNumMacros() const {\n    return static_cast<unsigned>(MacrosLoaded.size());\n  }\n\n  /// Returns the number of types found in the chain.\n  unsigned getTotalNumTypes() const {\n    return static_cast<unsigned>(TypesLoaded.size());\n  }\n\n  /// Returns the number of declarations found in the chain.\n  unsigned getTotalNumDecls() const {\n    return static_cast<unsigned>(DeclsLoaded.size());\n  }\n\n  /// Returns the number of submodules known.\n  unsigned getTotalNumSubmodules() const {\n    return static_cast<unsigned>(SubmodulesLoaded.size());\n  }\n\n  /// Returns the number of selectors found in the chain.\n  unsigned getTotalNumSelectors() const {\n    return static_cast<unsigned>(SelectorsLoaded.size());\n  }\n\n  /// Returns the number of preprocessed entities known to the AST\n  /// reader.\n  unsigned getTotalNumPreprocessedEntities() const {\n    unsigned Result = 0;\n    for (const auto &M : ModuleMgr)\n      Result += M.NumPreprocessedEntities;\n    return Result;\n  }\n\n  /// Resolve a type ID into a type, potentially building a new\n  /// type.\n  QualType GetType(serialization::TypeID ID);\n\n  /// Resolve a local type ID within a given AST file into a type.\n  QualType getLocalType(ModuleFile &F, unsigned LocalID);\n\n  /// Map a local type ID within a given AST file into a global type ID.\n  serialization::TypeID getGlobalTypeID(ModuleFile &F, unsigned LocalID) const;\n\n  /// Read a type from the current position in the given record, which\n  /// was read from the given AST file.\n  QualType readType(ModuleFile &F, const RecordData &Record, unsigned &Idx) {\n    if (Idx >= Record.size())\n      return {};\n\n    return getLocalType(F, Record[Idx++]);\n  }\n\n  /// Map from a local declaration ID within a given module to a\n  /// global declaration ID.\n  serialization::DeclID getGlobalDeclID(ModuleFile &F,\n                                      serialization::LocalDeclID LocalID) const;\n\n  /// Returns true if global DeclID \\p ID originated from module \\p M.\n  bool isDeclIDFromModule(serialization::GlobalDeclID ID, ModuleFile &M) const;\n\n  /// Retrieve the module file that owns the given declaration, or NULL\n  /// if the declaration is not from a module file.\n  ModuleFile *getOwningModuleFile(const Decl *D);\n\n  /// Get the best name we know for the module that owns the given\n  /// declaration, or an empty string if the declaration is not from a module.\n  std::string getOwningModuleNameForDiagnostic(const Decl *D);\n\n  /// Returns the source location for the decl \\p ID.\n  SourceLocation getSourceLocationForDeclID(serialization::GlobalDeclID ID);\n\n  /// Resolve a declaration ID into a declaration, potentially\n  /// building a new declaration.\n  Decl *GetDecl(serialization::DeclID ID);\n  Decl *GetExternalDecl(uint32_t ID) override;\n\n  /// Resolve a declaration ID into a declaration. Return 0 if it's not\n  /// been loaded yet.\n  Decl *GetExistingDecl(serialization::DeclID ID);\n\n  /// Reads a declaration with the given local ID in the given module.\n  Decl *GetLocalDecl(ModuleFile &F, uint32_t LocalID) {\n    return GetDecl(getGlobalDeclID(F, LocalID));\n  }\n\n  /// Reads a declaration with the given local ID in the given module.\n  ///\n  /// \\returns The requested declaration, casted to the given return type.\n  template<typename T>\n  T *GetLocalDeclAs(ModuleFile &F, uint32_t LocalID) {\n    return cast_or_null<T>(GetLocalDecl(F, LocalID));\n  }\n\n  /// Map a global declaration ID into the declaration ID used to\n  /// refer to this declaration within the given module fule.\n  ///\n  /// \\returns the global ID of the given declaration as known in the given\n  /// module file.\n  serialization::DeclID\n  mapGlobalIDToModuleFileGlobalID(ModuleFile &M,\n                                  serialization::DeclID GlobalID);\n\n  /// Reads a declaration ID from the given position in a record in the\n  /// given module.\n  ///\n  /// \\returns The declaration ID read from the record, adjusted to a global ID.\n  serialization::DeclID ReadDeclID(ModuleFile &F, const RecordData &Record,\n                                   unsigned &Idx);\n\n  /// Reads a declaration from the given position in a record in the\n  /// given module.\n  Decl *ReadDecl(ModuleFile &F, const RecordData &R, unsigned &I) {\n    return GetDecl(ReadDeclID(F, R, I));\n  }\n\n  /// Reads a declaration from the given position in a record in the\n  /// given module.\n  ///\n  /// \\returns The declaration read from this location, casted to the given\n  /// result type.\n  template<typename T>\n  T *ReadDeclAs(ModuleFile &F, const RecordData &R, unsigned &I) {\n    return cast_or_null<T>(GetDecl(ReadDeclID(F, R, I)));\n  }\n\n  /// If any redeclarations of \\p D have been imported since it was\n  /// last checked, this digs out those redeclarations and adds them to the\n  /// redeclaration chain for \\p D.\n  void CompleteRedeclChain(const Decl *D) override;\n\n  CXXBaseSpecifier *GetExternalCXXBaseSpecifiers(uint64_t Offset) override;\n\n  /// Resolve the offset of a statement into a statement.\n  ///\n  /// This operation will read a new statement from the external\n  /// source each time it is called, and is meant to be used via a\n  /// LazyOffsetPtr (which is used by Decls for the body of functions, etc).\n  Stmt *GetExternalDeclStmt(uint64_t Offset) override;\n\n  /// ReadBlockAbbrevs - Enter a subblock of the specified BlockID with the\n  /// specified cursor.  Read the abbreviations that are at the top of the block\n  /// and then leave the cursor pointing into the block.\n  static bool ReadBlockAbbrevs(llvm::BitstreamCursor &Cursor, unsigned BlockID,\n                               uint64_t *StartOfBlockOffset = nullptr);\n\n  /// Finds all the visible declarations with a given name.\n  /// The current implementation of this method just loads the entire\n  /// lookup table as unmaterialized references.\n  bool FindExternalVisibleDeclsByName(const DeclContext *DC,\n                                      DeclarationName Name) override;\n\n  /// Read all of the declarations lexically stored in a\n  /// declaration context.\n  ///\n  /// \\param DC The declaration context whose declarations will be\n  /// read.\n  ///\n  /// \\param IsKindWeWant A predicate indicating which declaration kinds\n  /// we are interested in.\n  ///\n  /// \\param Decls Vector that will contain the declarations loaded\n  /// from the external source. The caller is responsible for merging\n  /// these declarations with any declarations already stored in the\n  /// declaration context.\n  void\n  FindExternalLexicalDecls(const DeclContext *DC,\n                           llvm::function_ref<bool(Decl::Kind)> IsKindWeWant,\n                           SmallVectorImpl<Decl *> &Decls) override;\n\n  /// Get the decls that are contained in a file in the Offset/Length\n  /// range. \\p Length can be 0 to indicate a point at \\p Offset instead of\n  /// a range.\n  void FindFileRegionDecls(FileID File, unsigned Offset, unsigned Length,\n                           SmallVectorImpl<Decl *> &Decls) override;\n\n  /// Notify ASTReader that we started deserialization of\n  /// a decl or type so until FinishedDeserializing is called there may be\n  /// decls that are initializing. Must be paired with FinishedDeserializing.\n  void StartedDeserializing() override;\n\n  /// Notify ASTReader that we finished the deserialization of\n  /// a decl or type. Must be paired with StartedDeserializing.\n  void FinishedDeserializing() override;\n\n  /// Function that will be invoked when we begin parsing a new\n  /// translation unit involving this external AST source.\n  ///\n  /// This function will provide all of the external definitions to\n  /// the ASTConsumer.\n  void StartTranslationUnit(ASTConsumer *Consumer) override;\n\n  /// Print some statistics about AST usage.\n  void PrintStats() override;\n\n  /// Dump information about the AST reader to standard error.\n  void dump();\n\n  /// Return the amount of memory used by memory buffers, breaking down\n  /// by heap-backed versus mmap'ed memory.\n  void getMemoryBufferSizes(MemoryBufferSizes &sizes) const override;\n\n  /// Initialize the semantic source with the Sema instance\n  /// being used to perform semantic analysis on the abstract syntax\n  /// tree.\n  void InitializeSema(Sema &S) override;\n\n  /// Inform the semantic consumer that Sema is no longer available.\n  void ForgetSema() override { SemaObj = nullptr; }\n\n  /// Retrieve the IdentifierInfo for the named identifier.\n  ///\n  /// This routine builds a new IdentifierInfo for the given identifier. If any\n  /// declarations with this name are visible from translation unit scope, their\n  /// declarations will be deserialized and introduced into the declaration\n  /// chain of the identifier.\n  IdentifierInfo *get(StringRef Name) override;\n\n  /// Retrieve an iterator into the set of all identifiers\n  /// in all loaded AST files.\n  IdentifierIterator *getIdentifiers() override;\n\n  /// Load the contents of the global method pool for a given\n  /// selector.\n  void ReadMethodPool(Selector Sel) override;\n\n  /// Load the contents of the global method pool for a given\n  /// selector if necessary.\n  void updateOutOfDateSelector(Selector Sel) override;\n\n  /// Load the set of namespaces that are known to the external source,\n  /// which will be used during typo correction.\n  void ReadKnownNamespaces(\n                         SmallVectorImpl<NamespaceDecl *> &Namespaces) override;\n\n  void ReadUndefinedButUsed(\n      llvm::MapVector<NamedDecl *, SourceLocation> &Undefined) override;\n\n  void ReadMismatchingDeleteExpressions(llvm::MapVector<\n      FieldDecl *, llvm::SmallVector<std::pair<SourceLocation, bool>, 4>> &\n                                            Exprs) override;\n\n  void ReadTentativeDefinitions(\n                            SmallVectorImpl<VarDecl *> &TentativeDefs) override;\n\n  void ReadUnusedFileScopedDecls(\n                       SmallVectorImpl<const DeclaratorDecl *> &Decls) override;\n\n  void ReadDelegatingConstructors(\n                         SmallVectorImpl<CXXConstructorDecl *> &Decls) override;\n\n  void ReadExtVectorDecls(SmallVectorImpl<TypedefNameDecl *> &Decls) override;\n\n  void ReadUnusedLocalTypedefNameCandidates(\n      llvm::SmallSetVector<const TypedefNameDecl *, 4> &Decls) override;\n\n  void ReadDeclsToCheckForDeferredDiags(\n      llvm::SmallVector<Decl *, 4> &Decls) override;\n\n  void ReadReferencedSelectors(\n           SmallVectorImpl<std::pair<Selector, SourceLocation>> &Sels) override;\n\n  void ReadWeakUndeclaredIdentifiers(\n           SmallVectorImpl<std::pair<IdentifierInfo *, WeakInfo>> &WI) override;\n\n  void ReadUsedVTables(SmallVectorImpl<ExternalVTableUse> &VTables) override;\n\n  void ReadPendingInstantiations(\n                  SmallVectorImpl<std::pair<ValueDecl *,\n                                            SourceLocation>> &Pending) override;\n\n  void ReadLateParsedTemplates(\n      llvm::MapVector<const FunctionDecl *, std::unique_ptr<LateParsedTemplate>>\n          &LPTMap) override;\n\n  /// Load a selector from disk, registering its ID if it exists.\n  void LoadSelector(Selector Sel);\n\n  void SetIdentifierInfo(unsigned ID, IdentifierInfo *II);\n  void SetGloballyVisibleDecls(IdentifierInfo *II,\n                               const SmallVectorImpl<uint32_t> &DeclIDs,\n                               SmallVectorImpl<Decl *> *Decls = nullptr);\n\n  /// Report a diagnostic.\n  DiagnosticBuilder Diag(unsigned DiagID) const;\n\n  /// Report a diagnostic.\n  DiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID) const;\n\n  IdentifierInfo *DecodeIdentifierInfo(serialization::IdentifierID ID);\n\n  IdentifierInfo *readIdentifier(ModuleFile &M, const RecordData &Record,\n                                 unsigned &Idx) {\n    return DecodeIdentifierInfo(getGlobalIdentifierID(M, Record[Idx++]));\n  }\n\n  IdentifierInfo *GetIdentifier(serialization::IdentifierID ID) override {\n    // Note that we are loading an identifier.\n    Deserializing AnIdentifier(this);\n\n    return DecodeIdentifierInfo(ID);\n  }\n\n  IdentifierInfo *getLocalIdentifier(ModuleFile &M, unsigned LocalID);\n\n  serialization::IdentifierID getGlobalIdentifierID(ModuleFile &M,\n                                                    unsigned LocalID);\n\n  void resolvePendingMacro(IdentifierInfo *II, const PendingMacroInfo &PMInfo);\n\n  /// Retrieve the macro with the given ID.\n  MacroInfo *getMacro(serialization::MacroID ID);\n\n  /// Retrieve the global macro ID corresponding to the given local\n  /// ID within the given module file.\n  serialization::MacroID getGlobalMacroID(ModuleFile &M, unsigned LocalID);\n\n  /// Read the source location entry with index ID.\n  bool ReadSLocEntry(int ID) override;\n\n  /// Retrieve the module import location and module name for the\n  /// given source manager entry ID.\n  std::pair<SourceLocation, StringRef> getModuleImportLoc(int ID) override;\n\n  /// Retrieve the global submodule ID given a module and its local ID\n  /// number.\n  serialization::SubmoduleID\n  getGlobalSubmoduleID(ModuleFile &M, unsigned LocalID);\n\n  /// Retrieve the submodule that corresponds to a global submodule ID.\n  ///\n  Module *getSubmodule(serialization::SubmoduleID GlobalID);\n\n  /// Retrieve the module that corresponds to the given module ID.\n  ///\n  /// Note: overrides method in ExternalASTSource\n  Module *getModule(unsigned ID) override;\n\n  /// Retrieve the module file with a given local ID within the specified\n  /// ModuleFile.\n  ModuleFile *getLocalModuleFile(ModuleFile &M, unsigned ID);\n\n  /// Get an ID for the given module file.\n  unsigned getModuleFileID(ModuleFile *M);\n\n  /// Return a descriptor for the corresponding module.\n  llvm::Optional<ASTSourceDescriptor> getSourceDescriptor(unsigned ID) override;\n\n  ExtKind hasExternalDefinitions(const Decl *D) override;\n\n  /// Retrieve a selector from the given module with its local ID\n  /// number.\n  Selector getLocalSelector(ModuleFile &M, unsigned LocalID);\n\n  Selector DecodeSelector(serialization::SelectorID Idx);\n\n  Selector GetExternalSelector(serialization::SelectorID ID) override;\n  uint32_t GetNumExternalSelectors() override;\n\n  Selector ReadSelector(ModuleFile &M, const RecordData &Record, unsigned &Idx) {\n    return getLocalSelector(M, Record[Idx++]);\n  }\n\n  /// Retrieve the global selector ID that corresponds to this\n  /// the local selector ID in a given module.\n  serialization::SelectorID getGlobalSelectorID(ModuleFile &F,\n                                                unsigned LocalID) const;\n\n  /// Read the contents of a CXXCtorInitializer array.\n  CXXCtorInitializer **GetExternalCXXCtorInitializers(uint64_t Offset) override;\n\n  /// Read a AlignPackInfo from raw form.\n  Sema::AlignPackInfo ReadAlignPackInfo(uint32_t Raw) const {\n    return Sema::AlignPackInfo::getFromRawEncoding(Raw);\n  }\n\n  /// Read a source location from raw form and return it in its\n  /// originating module file's source location space.\n  SourceLocation ReadUntranslatedSourceLocation(uint32_t Raw) const {\n    return SourceLocation::getFromRawEncoding((Raw >> 1) | (Raw << 31));\n  }\n\n  /// Read a source location from raw form.\n  SourceLocation ReadSourceLocation(ModuleFile &ModuleFile, uint32_t Raw) const {\n    SourceLocation Loc = ReadUntranslatedSourceLocation(Raw);\n    return TranslateSourceLocation(ModuleFile, Loc);\n  }\n\n  /// Translate a source location from another module file's source\n  /// location space into ours.\n  SourceLocation TranslateSourceLocation(ModuleFile &ModuleFile,\n                                         SourceLocation Loc) const {\n    if (!ModuleFile.ModuleOffsetMap.empty())\n      ReadModuleOffsetMap(ModuleFile);\n    assert(ModuleFile.SLocRemap.find(Loc.getOffset()) !=\n               ModuleFile.SLocRemap.end() &&\n           \"Cannot find offset to remap.\");\n    int Remap = ModuleFile.SLocRemap.find(Loc.getOffset())->second;\n    return Loc.getLocWithOffset(Remap);\n  }\n\n  /// Read a source location.\n  SourceLocation ReadSourceLocation(ModuleFile &ModuleFile,\n                                    const RecordDataImpl &Record,\n                                    unsigned &Idx) {\n    return ReadSourceLocation(ModuleFile, Record[Idx++]);\n  }\n\n  /// Read a source range.\n  SourceRange ReadSourceRange(ModuleFile &F,\n                              const RecordData &Record, unsigned &Idx);\n\n  // Read a string\n  static std::string ReadString(const RecordData &Record, unsigned &Idx);\n\n  // Skip a string\n  static void SkipString(const RecordData &Record, unsigned &Idx) {\n    Idx += Record[Idx] + 1;\n  }\n\n  // Read a path\n  std::string ReadPath(ModuleFile &F, const RecordData &Record, unsigned &Idx);\n\n  // Read a path\n  std::string ReadPath(StringRef BaseDirectory, const RecordData &Record,\n                       unsigned &Idx);\n\n  // Skip a path\n  static void SkipPath(const RecordData &Record, unsigned &Idx) {\n    SkipString(Record, Idx);\n  }\n\n  /// Read a version tuple.\n  static VersionTuple ReadVersionTuple(const RecordData &Record, unsigned &Idx);\n\n  CXXTemporary *ReadCXXTemporary(ModuleFile &F, const RecordData &Record,\n                                 unsigned &Idx);\n\n  /// Reads a statement.\n  Stmt *ReadStmt(ModuleFile &F);\n\n  /// Reads an expression.\n  Expr *ReadExpr(ModuleFile &F);\n\n  /// Reads a sub-statement operand during statement reading.\n  Stmt *ReadSubStmt() {\n    assert(ReadingKind == Read_Stmt &&\n           \"Should be called only during statement reading!\");\n    // Subexpressions are stored from last to first, so the next Stmt we need\n    // is at the back of the stack.\n    assert(!StmtStack.empty() && \"Read too many sub-statements!\");\n    return StmtStack.pop_back_val();\n  }\n\n  /// Reads a sub-expression operand during statement reading.\n  Expr *ReadSubExpr();\n\n  /// Reads a token out of a record.\n  Token ReadToken(ModuleFile &M, const RecordDataImpl &Record, unsigned &Idx);\n\n  /// Reads the macro record located at the given offset.\n  MacroInfo *ReadMacroRecord(ModuleFile &F, uint64_t Offset);\n\n  /// Determine the global preprocessed entity ID that corresponds to\n  /// the given local ID within the given module.\n  serialization::PreprocessedEntityID\n  getGlobalPreprocessedEntityID(ModuleFile &M, unsigned LocalID) const;\n\n  /// Add a macro to deserialize its macro directive history.\n  ///\n  /// \\param II The name of the macro.\n  /// \\param M The module file.\n  /// \\param MacroDirectivesOffset Offset of the serialized macro directive\n  /// history.\n  void addPendingMacro(IdentifierInfo *II, ModuleFile *M,\n                       uint32_t MacroDirectivesOffset);\n\n  /// Read the set of macros defined by this external macro source.\n  void ReadDefinedMacros() override;\n\n  /// Update an out-of-date identifier.\n  void updateOutOfDateIdentifier(IdentifierInfo &II) override;\n\n  /// Note that this identifier is up-to-date.\n  void markIdentifierUpToDate(IdentifierInfo *II);\n\n  /// Load all external visible decls in the given DeclContext.\n  void completeVisibleDeclsMap(const DeclContext *DC) override;\n\n  /// Retrieve the AST context that this AST reader supplements.\n  ASTContext &getContext() {\n    assert(ContextObj && \"requested AST context when not loading AST\");\n    return *ContextObj;\n  }\n\n  // Contains the IDs for declarations that were requested before we have\n  // access to a Sema object.\n  SmallVector<uint64_t, 16> PreloadedDeclIDs;\n\n  /// Retrieve the semantic analysis object used to analyze the\n  /// translation unit in which the precompiled header is being\n  /// imported.\n  Sema *getSema() { return SemaObj; }\n\n  /// Get the identifier resolver used for name lookup / updates\n  /// in the translation unit scope. We have one of these even if we don't\n  /// have a Sema object.\n  IdentifierResolver &getIdResolver();\n\n  /// Retrieve the identifier table associated with the\n  /// preprocessor.\n  IdentifierTable &getIdentifierTable();\n\n  /// Record that the given ID maps to the given switch-case\n  /// statement.\n  void RecordSwitchCaseID(SwitchCase *SC, unsigned ID);\n\n  /// Retrieve the switch-case statement with the given ID.\n  SwitchCase *getSwitchCaseWithID(unsigned ID);\n\n  void ClearSwitchCaseIDs();\n\n  /// Cursors for comments blocks.\n  SmallVector<std::pair<llvm::BitstreamCursor,\n                        serialization::ModuleFile *>, 8> CommentsCursors;\n\n  /// Loads comments ranges.\n  void ReadComments() override;\n\n  /// Visit all the input files of the given module file.\n  void visitInputFiles(serialization::ModuleFile &MF,\n                       bool IncludeSystem, bool Complain,\n          llvm::function_ref<void(const serialization::InputFile &IF,\n                                  bool isSystem)> Visitor);\n\n  /// Visit all the top-level module maps loaded when building the given module\n  /// file.\n  void visitTopLevelModuleMaps(serialization::ModuleFile &MF,\n                               llvm::function_ref<\n                                   void(const FileEntry *)> Visitor);\n\n  bool isProcessingUpdateRecords() { return ProcessingUpdateRecords; }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SERIALIZATION_ASTREADER_H\n"}}, "reports": [{"events": [{"location": {"col": 17, "file": 1, "line": 8379}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 0, "line": 2024}, "message": "differing parameters are named here: ('WI'), in definition: ('WeakIDs')"}, {"location": {"col": 8, "file": 0, "line": 2024}, "message": "function 'clang::ASTReader::ReadWeakUndeclaredIdentifiers' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTReader.h", "reportHash": "ba4786510327ceed38395be516f0f8c0", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 1, "line": 8641}, "message": "the definition seen here"}, {"location": {"col": 15, "file": 0, "line": 2102}, "message": "differing parameters are named here: ('M'), in definition: ('F')"}, {"location": {"col": 15, "file": 0, "line": 2102}, "message": "function 'clang::ASTReader::getLocalModuleFile' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTReader.h", "reportHash": "25e10ae9369dbd9094de5027caa2c8a6", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 21, "file": 1, "line": 8654}, "message": "the definition seen here"}, {"location": {"col": 12, "file": 0, "line": 2105}, "message": "differing parameters are named here: ('M'), in definition: ('F')"}, {"location": {"col": 12, "file": 0, "line": 2105}, "message": "function 'clang::ASTReader::getModuleFileID' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTReader.h", "reportHash": "7dd441db98bb7ed0935cf24abe09fb62", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 12, "file": 1, "line": 8735}, "message": "the definition seen here"}, {"location": {"col": 29, "file": 0, "line": 2127}, "message": "differing parameters are named here: ('F'), in definition: ('M')"}, {"location": {"col": 29, "file": 0, "line": 2127}, "message": "function 'clang::ASTReader::getGlobalSelectorID' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTReader.h", "reportHash": "facc5cc2178d435c677e3d3b2fed6beb", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 1, "line": 1657}, "message": "the definition seen here"}, {"location": {"col": 9, "file": 0, "line": 2220}, "message": "differing parameters are named here: ('M'), in definition: ('F')"}, {"location": {"col": 9, "file": 0, "line": 2220}, "message": "function 'clang::ASTReader::ReadToken' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTReader.h", "reportHash": "c21ecfeae24e544a09b29630eafd5943", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
