<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp", "content": "//===- InstructionCombining.cpp - Combine multiple instructions -----------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// InstructionCombining - Combine instructions to form fewer, simple\n// instructions.  This pass does not modify the CFG.  This pass is where\n// algebraic simplification happens.\n//\n// This pass combines things like:\n//    %Y = add i32 %X, 1\n//    %Z = add i32 %Y, 1\n// into:\n//    %Z = add i32 %X, 2\n//\n// This is a simple worklist driven algorithm.\n//\n// This pass guarantees that the following canonicalizations are performed on\n// the program:\n//    1. If a binary operator has a constant operand, it is moved to the RHS\n//    2. Bitwise operators with constant operands are always grouped so that\n//       shifts are performed first, then or's, then and's, then xor's.\n//    3. Compare instructions are converted from <,>,<=,>= to ==,!= if possible\n//    4. All cmp instructions on boolean values are replaced with logical ops\n//    5. add X, X is represented as (X*2) => (X << 1)\n//    6. Multiplies with a power-of-two constant argument are transformed into\n//       shifts.\n//   ... etc.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"InstCombineInternal.h\"\n#include \"llvm-c/Initialization.h\"\n#include \"llvm-c/Transforms/InstCombine.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/Analysis/AliasAnalysis.h\"\n#include \"llvm/Analysis/AssumptionCache.h\"\n#include \"llvm/Analysis/BasicAliasAnalysis.h\"\n#include \"llvm/Analysis/BlockFrequencyInfo.h\"\n#include \"llvm/Analysis/CFG.h\"\n#include \"llvm/Analysis/ConstantFolding.h\"\n#include \"llvm/Analysis/EHPersonalities.h\"\n#include \"llvm/Analysis/GlobalsModRef.h\"\n#include \"llvm/Analysis/InstructionSimplify.h\"\n#include \"llvm/Analysis/LazyBlockFrequencyInfo.h\"\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/Analysis/MemoryBuiltins.h\"\n#include \"llvm/Analysis/OptimizationRemarkEmitter.h\"\n#include \"llvm/Analysis/ProfileSummaryInfo.h\"\n#include \"llvm/Analysis/TargetFolder.h\"\n#include \"llvm/Analysis/TargetLibraryInfo.h\"\n#include \"llvm/Analysis/TargetTransformInfo.h\"\n#include \"llvm/Analysis/ValueTracking.h\"\n#include \"llvm/Analysis/VectorUtils.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/CFG.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DIBuilder.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GetElementPtrTypeIterator.h\"\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/LegacyPassManager.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/InitializePasses.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/CBindingWrapping.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/DebugCounter.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/KnownBits.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Transforms/InstCombine/InstCombine.h\"\n#include \"llvm/Transforms/InstCombine/InstCombineWorklist.h\"\n#include \"llvm/Transforms/Utils/Local.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <utility>\n\nusing namespace llvm;\nusing namespace llvm::PatternMatch;\n\n#define DEBUG_TYPE \"instcombine\"\n\nSTATISTIC(NumWorklistIterations,\n          \"Number of instruction combining iterations performed\");\n\nSTATISTIC(NumCombined , \"Number of insts combined\");\nSTATISTIC(NumConstProp, \"Number of constant folds\");\nSTATISTIC(NumDeadInst , \"Number of dead inst eliminated\");\nSTATISTIC(NumSunkInst , \"Number of instructions sunk\");\nSTATISTIC(NumExpand,    \"Number of expansions\");\nSTATISTIC(NumFactor   , \"Number of factorizations\");\nSTATISTIC(NumReassoc  , \"Number of reassociations\");\nDEBUG_COUNTER(VisitCounter, \"instcombine-visit\",\n              \"Controls which instructions are visited\");\n\n// FIXME: these limits eventually should be as low as 2.\nstatic constexpr unsigned InstCombineDefaultMaxIterations = 1000;\n#ifndef NDEBUG\nstatic constexpr unsigned InstCombineDefaultInfiniteLoopThreshold = 100;\n#else\nstatic constexpr unsigned InstCombineDefaultInfiniteLoopThreshold = 1000;\n#endif\n\nstatic cl::opt<bool>\nEnableCodeSinking(\"instcombine-code-sinking\", cl::desc(\"Enable code sinking\"),\n                                              cl::init(true));\n\nstatic cl::opt<unsigned> LimitMaxIterations(\n    \"instcombine-max-iterations\",\n    cl::desc(\"Limit the maximum number of instruction combining iterations\"),\n    cl::init(InstCombineDefaultMaxIterations));\n\nstatic cl::opt<unsigned> InfiniteLoopDetectionThreshold(\n    \"instcombine-infinite-loop-threshold\",\n    cl::desc(\"Number of instruction combining iterations considered an \"\n             \"infinite loop\"),\n    cl::init(InstCombineDefaultInfiniteLoopThreshold), cl::Hidden);\n\nstatic cl::opt<unsigned>\nMaxArraySize(\"instcombine-maxarray-size\", cl::init(1024),\n             cl::desc(\"Maximum array size considered when doing a combine\"));\n\n// FIXME: Remove this flag when it is no longer necessary to convert\n// llvm.dbg.declare to avoid inaccurate debug info. Setting this to false\n// increases variable availability at the cost of accuracy. Variables that\n// cannot be promoted by mem2reg or SROA will be described as living in memory\n// for their entire lifetime. However, passes like DSE and instcombine can\n// delete stores to the alloca, leading to misleading and inaccurate debug\n// information. This flag can be removed when those passes are fixed.\nstatic cl::opt<unsigned> ShouldLowerDbgDeclare(\"instcombine-lower-dbg-declare\",\n                                               cl::Hidden, cl::init(true));\n\nOptional<Instruction *>\nInstCombiner::targetInstCombineIntrinsic(IntrinsicInst &II) {\n  // Handle target specific intrinsics\n  if (II.getCalledFunction()->isTargetIntrinsic()) {\n    return TTI.instCombineIntrinsic(*this, II);\n  }\n  return None;\n}\n\nOptional<Value *> InstCombiner::targetSimplifyDemandedUseBitsIntrinsic(\n    IntrinsicInst &II, APInt DemandedMask, KnownBits &Known,\n    bool &KnownBitsComputed) {\n  // Handle target specific intrinsics\n  if (II.getCalledFunction()->isTargetIntrinsic()) {\n    return TTI.simplifyDemandedUseBitsIntrinsic(*this, II, DemandedMask, Known,\n                                                KnownBitsComputed);\n  }\n  return None;\n}\n\nOptional<Value *> InstCombiner::targetSimplifyDemandedVectorEltsIntrinsic(\n    IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts, APInt &UndefElts2,\n    APInt &UndefElts3,\n    std::function<void(Instruction *, unsigned, APInt, APInt &)>\n        SimplifyAndSetOp) {\n  // Handle target specific intrinsics\n  if (II.getCalledFunction()->isTargetIntrinsic()) {\n    return TTI.simplifyDemandedVectorEltsIntrinsic(\n        *this, II, DemandedElts, UndefElts, UndefElts2, UndefElts3,\n        SimplifyAndSetOp);\n  }\n  return None;\n}\n\nValue *InstCombinerImpl::EmitGEPOffset(User *GEP) {\n  return llvm::EmitGEPOffset(&Builder, DL, GEP);\n}\n\n/// Return true if it is desirable to convert an integer computation from a\n/// given bit width to a new bit width.\n/// We don't want to convert from a legal to an illegal type or from a smaller\n/// to a larger illegal type. A width of '1' is always treated as a legal type\n/// because i1 is a fundamental type in IR, and there are many specialized\n/// optimizations for i1 types. Widths of 8, 16 or 32 are equally treated as\n/// legal to convert to, in order to open up more combining opportunities.\n/// NOTE: this treats i8, i16 and i32 specially, due to them being so common\n/// from frontend languages.\nbool InstCombinerImpl::shouldChangeType(unsigned FromWidth,\n                                        unsigned ToWidth) const {\n  bool FromLegal = FromWidth == 1 || DL.isLegalInteger(FromWidth);\n  bool ToLegal = ToWidth == 1 || DL.isLegalInteger(ToWidth);\n\n  // Convert to widths of 8, 16 or 32 even if they are not legal types. Only\n  // shrink types, to prevent infinite loops.\n  if (ToWidth < FromWidth && (ToWidth == 8 || ToWidth == 16 || ToWidth == 32))\n    return true;\n\n  // If this is a legal integer from type, and the result would be an illegal\n  // type, don't do the transformation.\n  if (FromLegal && !ToLegal)\n    return false;\n\n  // Otherwise, if both are illegal, do not increase the size of the result. We\n  // do allow things like i160 -> i64, but not i64 -> i160.\n  if (!FromLegal && !ToLegal && ToWidth > FromWidth)\n    return false;\n\n  return true;\n}\n\n/// Return true if it is desirable to convert a computation from 'From' to 'To'.\n/// We don't want to convert from a legal to an illegal type or from a smaller\n/// to a larger illegal type. i1 is always treated as a legal type because it is\n/// a fundamental type in IR, and there are many specialized optimizations for\n/// i1 types.\nbool InstCombinerImpl::shouldChangeType(Type *From, Type *To) const {\n  // TODO: This could be extended to allow vectors. Datalayout changes might be\n  // needed to properly support that.\n  if (!From->isIntegerTy() || !To->isIntegerTy())\n    return false;\n\n  unsigned FromWidth = From->getPrimitiveSizeInBits();\n  unsigned ToWidth = To->getPrimitiveSizeInBits();\n  return shouldChangeType(FromWidth, ToWidth);\n}\n\n// Return true, if No Signed Wrap should be maintained for I.\n// The No Signed Wrap flag can be kept if the operation \"B (I.getOpcode) C\",\n// where both B and C should be ConstantInts, results in a constant that does\n// not overflow. This function only handles the Add and Sub opcodes. For\n// all other opcodes, the function conservatively returns false.\nstatic bool maintainNoSignedWrap(BinaryOperator &I, Value *B, Value *C) {\n  auto *OBO = dyn_cast<OverflowingBinaryOperator>(&I);\n  if (!OBO || !OBO->hasNoSignedWrap())\n    return false;\n\n  // We reason about Add and Sub Only.\n  Instruction::BinaryOps Opcode = I.getOpcode();\n  if (Opcode != Instruction::Add && Opcode != Instruction::Sub)\n    return false;\n\n  const APInt *BVal, *CVal;\n  if (!match(B, m_APInt(BVal)) || !match(C, m_APInt(CVal)))\n    return false;\n\n  bool Overflow = false;\n  if (Opcode == Instruction::Add)\n    (void)BVal->sadd_ov(*CVal, Overflow);\n  else\n    (void)BVal->ssub_ov(*CVal, Overflow);\n\n  return !Overflow;\n}\n\nstatic bool hasNoUnsignedWrap(BinaryOperator &I) {\n  auto *OBO = dyn_cast<OverflowingBinaryOperator>(&I);\n  return OBO && OBO->hasNoUnsignedWrap();\n}\n\nstatic bool hasNoSignedWrap(BinaryOperator &I) {\n  auto *OBO = dyn_cast<OverflowingBinaryOperator>(&I);\n  return OBO && OBO->hasNoSignedWrap();\n}\n\n/// Conservatively clears subclassOptionalData after a reassociation or\n/// commutation. We preserve fast-math flags when applicable as they can be\n/// preserved.\nstatic void ClearSubclassDataAfterReassociation(BinaryOperator &I) {\n  FPMathOperator *FPMO = dyn_cast<FPMathOperator>(&I);\n  if (!FPMO) {\n    I.clearSubclassOptionalData();\n    return;\n  }\n\n  FastMathFlags FMF = I.getFastMathFlags();\n  I.clearSubclassOptionalData();\n  I.setFastMathFlags(FMF);\n}\n\n/// Combine constant operands of associative operations either before or after a\n/// cast to eliminate one of the associative operations:\n/// (op (cast (op X, C2)), C1) --> (cast (op X, op (C1, C2)))\n/// (op (cast (op X, C2)), C1) --> (op (cast X), op (C1, C2))\nstatic bool simplifyAssocCastAssoc(BinaryOperator *BinOp1,\n                                   InstCombinerImpl &IC) {\n  auto *Cast = dyn_cast<CastInst>(BinOp1->getOperand(0));\n  if (!Cast || !Cast->hasOneUse())\n    return false;\n\n  // TODO: Enhance logic for other casts and remove this check.\n  auto CastOpcode = Cast->getOpcode();\n  if (CastOpcode != Instruction::ZExt)\n    return false;\n\n  // TODO: Enhance logic for other BinOps and remove this check.\n  if (!BinOp1->isBitwiseLogicOp())\n    return false;\n\n  auto AssocOpcode = BinOp1->getOpcode();\n  auto *BinOp2 = dyn_cast<BinaryOperator>(Cast->getOperand(0));\n  if (!BinOp2 || !BinOp2->hasOneUse() || BinOp2->getOpcode() != AssocOpcode)\n    return false;\n\n  Constant *C1, *C2;\n  if (!match(BinOp1->getOperand(1), m_Constant(C1)) ||\n      !match(BinOp2->getOperand(1), m_Constant(C2)))\n    return false;\n\n  // TODO: This assumes a zext cast.\n  // Eg, if it was a trunc, we'd cast C1 to the source type because casting C2\n  // to the destination type might lose bits.\n\n  // Fold the constants together in the destination type:\n  // (op (cast (op X, C2)), C1) --> (op (cast X), FoldedC)\n  Type *DestTy = C1->getType();\n  Constant *CastC2 = ConstantExpr::getCast(CastOpcode, C2, DestTy);\n  Constant *FoldedC = ConstantExpr::get(AssocOpcode, C1, CastC2);\n  IC.replaceOperand(*Cast, 0, BinOp2->getOperand(0));\n  IC.replaceOperand(*BinOp1, 1, FoldedC);\n  return true;\n}\n\n/// This performs a few simplifications for operators that are associative or\n/// commutative:\n///\n///  Commutative operators:\n///\n///  1. Order operands such that they are listed from right (least complex) to\n///     left (most complex).  This puts constants before unary operators before\n///     binary operators.\n///\n///  Associative operators:\n///\n///  2. Transform: \"(A op B) op C\" ==> \"A op (B op C)\" if \"B op C\" simplifies.\n///  3. Transform: \"A op (B op C)\" ==> \"(A op B) op C\" if \"A op B\" simplifies.\n///\n///  Associative and commutative operators:\n///\n///  4. Transform: \"(A op B) op C\" ==> \"(C op A) op B\" if \"C op A\" simplifies.\n///  5. Transform: \"A op (B op C)\" ==> \"B op (C op A)\" if \"C op A\" simplifies.\n///  6. Transform: \"(A op C1) op (B op C2)\" ==> \"(A op B) op (C1 op C2)\"\n///     if C1 and C2 are constants.\nbool InstCombinerImpl::SimplifyAssociativeOrCommutative(BinaryOperator &I) {\n  Instruction::BinaryOps Opcode = I.getOpcode();\n  bool Changed = false;\n\n  do {\n    // Order operands such that they are listed from right (least complex) to\n    // left (most complex).  This puts constants before unary operators before\n    // binary operators.\n    if (I.isCommutative() && getComplexity(I.getOperand(0)) <\n        getComplexity(I.getOperand(1)))\n      Changed = !I.swapOperands();\n\n    BinaryOperator *Op0 = dyn_cast<BinaryOperator>(I.getOperand(0));\n    BinaryOperator *Op1 = dyn_cast<BinaryOperator>(I.getOperand(1));\n\n    if (I.isAssociative()) {\n      // Transform: \"(A op B) op C\" ==> \"A op (B op C)\" if \"B op C\" simplifies.\n      if (Op0 && Op0->getOpcode() == Opcode) {\n        Value *A = Op0->getOperand(0);\n        Value *B = Op0->getOperand(1);\n        Value *C = I.getOperand(1);\n\n        // Does \"B op C\" simplify?\n        if (Value *V = SimplifyBinOp(Opcode, B, C, SQ.getWithInstruction(&I))) {\n          // It simplifies to V.  Form \"A op V\".\n          replaceOperand(I, 0, A);\n          replaceOperand(I, 1, V);\n          bool IsNUW = hasNoUnsignedWrap(I) && hasNoUnsignedWrap(*Op0);\n          bool IsNSW = maintainNoSignedWrap(I, B, C) && hasNoSignedWrap(*Op0);\n\n          // Conservatively clear all optional flags since they may not be\n          // preserved by the reassociation. Reset nsw/nuw based on the above\n          // analysis.\n          ClearSubclassDataAfterReassociation(I);\n\n          // Note: this is only valid because SimplifyBinOp doesn't look at\n          // the operands to Op0.\n          if (IsNUW)\n            I.setHasNoUnsignedWrap(true);\n\n          if (IsNSW)\n            I.setHasNoSignedWrap(true);\n\n          Changed = true;\n          ++NumReassoc;\n          continue;\n        }\n      }\n\n      // Transform: \"A op (B op C)\" ==> \"(A op B) op C\" if \"A op B\" simplifies.\n      if (Op1 && Op1->getOpcode() == Opcode) {\n        Value *A = I.getOperand(0);\n        Value *B = Op1->getOperand(0);\n        Value *C = Op1->getOperand(1);\n\n        // Does \"A op B\" simplify?\n        if (Value *V = SimplifyBinOp(Opcode, A, B, SQ.getWithInstruction(&I))) {\n          // It simplifies to V.  Form \"V op C\".\n          replaceOperand(I, 0, V);\n          replaceOperand(I, 1, C);\n          // Conservatively clear the optional flags, since they may not be\n          // preserved by the reassociation.\n          ClearSubclassDataAfterReassociation(I);\n          Changed = true;\n          ++NumReassoc;\n          continue;\n        }\n      }\n    }\n\n    if (I.isAssociative() && I.isCommutative()) {\n      if (simplifyAssocCastAssoc(&I, *this)) {\n        Changed = true;\n        ++NumReassoc;\n        continue;\n      }\n\n      // Transform: \"(A op B) op C\" ==> \"(C op A) op B\" if \"C op A\" simplifies.\n      if (Op0 && Op0->getOpcode() == Opcode) {\n        Value *A = Op0->getOperand(0);\n        Value *B = Op0->getOperand(1);\n        Value *C = I.getOperand(1);\n\n        // Does \"C op A\" simplify?\n        if (Value *V = SimplifyBinOp(Opcode, C, A, SQ.getWithInstruction(&I))) {\n          // It simplifies to V.  Form \"V op B\".\n          replaceOperand(I, 0, V);\n          replaceOperand(I, 1, B);\n          // Conservatively clear the optional flags, since they may not be\n          // preserved by the reassociation.\n          ClearSubclassDataAfterReassociation(I);\n          Changed = true;\n          ++NumReassoc;\n          continue;\n        }\n      }\n\n      // Transform: \"A op (B op C)\" ==> \"B op (C op A)\" if \"C op A\" simplifies.\n      if (Op1 && Op1->getOpcode() == Opcode) {\n        Value *A = I.getOperand(0);\n        Value *B = Op1->getOperand(0);\n        Value *C = Op1->getOperand(1);\n\n        // Does \"C op A\" simplify?\n        if (Value *V = SimplifyBinOp(Opcode, C, A, SQ.getWithInstruction(&I))) {\n          // It simplifies to V.  Form \"B op V\".\n          replaceOperand(I, 0, B);\n          replaceOperand(I, 1, V);\n          // Conservatively clear the optional flags, since they may not be\n          // preserved by the reassociation.\n          ClearSubclassDataAfterReassociation(I);\n          Changed = true;\n          ++NumReassoc;\n          continue;\n        }\n      }\n\n      // Transform: \"(A op C1) op (B op C2)\" ==> \"(A op B) op (C1 op C2)\"\n      // if C1 and C2 are constants.\n      Value *A, *B;\n      Constant *C1, *C2;\n      if (Op0 && Op1 &&\n          Op0->getOpcode() == Opcode && Op1->getOpcode() == Opcode &&\n          match(Op0, m_OneUse(m_BinOp(m_Value(A), m_Constant(C1)))) &&\n          match(Op1, m_OneUse(m_BinOp(m_Value(B), m_Constant(C2))))) {\n        bool IsNUW = hasNoUnsignedWrap(I) &&\n           hasNoUnsignedWrap(*Op0) &&\n           hasNoUnsignedWrap(*Op1);\n         BinaryOperator *NewBO = (IsNUW && Opcode == Instruction::Add) ?\n           BinaryOperator::CreateNUW(Opcode, A, B) :\n           BinaryOperator::Create(Opcode, A, B);\n\n         if (isa<FPMathOperator>(NewBO)) {\n          FastMathFlags Flags = I.getFastMathFlags();\n          Flags &= Op0->getFastMathFlags();\n          Flags &= Op1->getFastMathFlags();\n          NewBO->setFastMathFlags(Flags);\n        }\n        InsertNewInstWith(NewBO, I);\n        NewBO->takeName(Op1);\n        replaceOperand(I, 0, NewBO);\n        replaceOperand(I, 1, ConstantExpr::get(Opcode, C1, C2));\n        // Conservatively clear the optional flags, since they may not be\n        // preserved by the reassociation.\n        ClearSubclassDataAfterReassociation(I);\n        if (IsNUW)\n          I.setHasNoUnsignedWrap(true);\n\n        Changed = true;\n        continue;\n      }\n    }\n\n    // No further simplifications.\n    return Changed;\n  } while (true);\n}\n\n/// Return whether \"X LOp (Y ROp Z)\" is always equal to\n/// \"(X LOp Y) ROp (X LOp Z)\".\nstatic bool leftDistributesOverRight(Instruction::BinaryOps LOp,\n                                     Instruction::BinaryOps ROp) {\n  // X & (Y | Z) <--> (X & Y) | (X & Z)\n  // X & (Y ^ Z) <--> (X & Y) ^ (X & Z)\n  if (LOp == Instruction::And)\n    return ROp == Instruction::Or || ROp == Instruction::Xor;\n\n  // X | (Y & Z) <--> (X | Y) & (X | Z)\n  if (LOp == Instruction::Or)\n    return ROp == Instruction::And;\n\n  // X * (Y + Z) <--> (X * Y) + (X * Z)\n  // X * (Y - Z) <--> (X * Y) - (X * Z)\n  if (LOp == Instruction::Mul)\n    return ROp == Instruction::Add || ROp == Instruction::Sub;\n\n  return false;\n}\n\n/// Return whether \"(X LOp Y) ROp Z\" is always equal to\n/// \"(X ROp Z) LOp (Y ROp Z)\".\nstatic bool rightDistributesOverLeft(Instruction::BinaryOps LOp,\n                                     Instruction::BinaryOps ROp) {\n  if (Instruction::isCommutative(ROp))\n    return leftDistributesOverRight(ROp, LOp);\n\n  // (X {&|^} Y) >> Z <--> (X >> Z) {&|^} (Y >> Z) for all shifts.\n  return Instruction::isBitwiseLogicOp(LOp) && Instruction::isShift(ROp);\n\n  // TODO: It would be nice to handle division, aka \"(X + Y)/Z = X/Z + Y/Z\",\n  // but this requires knowing that the addition does not overflow and other\n  // such subtleties.\n}\n\n/// This function returns identity value for given opcode, which can be used to\n/// factor patterns like (X * 2) + X ==> (X * 2) + (X * 1) ==> X * (2 + 1).\nstatic Value *getIdentityValue(Instruction::BinaryOps Opcode, Value *V) {\n  if (isa<Constant>(V))\n    return nullptr;\n\n  return ConstantExpr::getBinOpIdentity(Opcode, V->getType());\n}\n\n/// This function predicates factorization using distributive laws. By default,\n/// it just returns the 'Op' inputs. But for special-cases like\n/// 'add(shl(X, 5), ...)', this function will have TopOpcode == Instruction::Add\n/// and Op = shl(X, 5). The 'shl' is treated as the more general 'mul X, 32' to\n/// allow more factorization opportunities.\nstatic Instruction::BinaryOps\ngetBinOpsForFactorization(Instruction::BinaryOps TopOpcode, BinaryOperator *Op,\n                          Value *&LHS, Value *&RHS) {\n  assert(Op && \"Expected a binary operator\");\n  LHS = Op->getOperand(0);\n  RHS = Op->getOperand(1);\n  if (TopOpcode == Instruction::Add || TopOpcode == Instruction::Sub) {\n    Constant *C;\n    if (match(Op, m_Shl(m_Value(), m_Constant(C)))) {\n      // X << C --> X * (1 << C)\n      RHS = ConstantExpr::getShl(ConstantInt::get(Op->getType(), 1), C);\n      return Instruction::Mul;\n    }\n    // TODO: We can add other conversions e.g. shr => div etc.\n  }\n  return Op->getOpcode();\n}\n\n/// This tries to simplify binary operations by factorizing out common terms\n/// (e. g. \"(A*B)+(A*C)\" -> \"A*(B+C)\").\nValue *InstCombinerImpl::tryFactorization(BinaryOperator &I,\n                                          Instruction::BinaryOps InnerOpcode,\n                                          Value *A, Value *B, Value *C,\n                                          Value *D) {\n  assert(A && B && C && D && \"All values must be provided\");\n\n  Value *V = nullptr;\n  Value *SimplifiedInst = nullptr;\n  Value *LHS = I.getOperand(0), *RHS = I.getOperand(1);\n  Instruction::BinaryOps TopLevelOpcode = I.getOpcode();\n\n  // Does \"X op' Y\" always equal \"Y op' X\"?\n  bool InnerCommutative = Instruction::isCommutative(InnerOpcode);\n\n  // Does \"X op' (Y op Z)\" always equal \"(X op' Y) op (X op' Z)\"?\n  if (leftDistributesOverRight(InnerOpcode, TopLevelOpcode))\n    // Does the instruction have the form \"(A op' B) op (A op' D)\" or, in the\n    // commutative case, \"(A op' B) op (C op' A)\"?\n    if (A == C || (InnerCommutative && A == D)) {\n      if (A != C)\n        std::swap(C, D);\n      // Consider forming \"A op' (B op D)\".\n      // If \"B op D\" simplifies then it can be formed with no cost.\n      V = SimplifyBinOp(TopLevelOpcode, B, D, SQ.getWithInstruction(&I));\n      // If \"B op D\" doesn't simplify then only go on if both of the existing\n      // operations \"A op' B\" and \"C op' D\" will be zapped as no longer used.\n      if (!V && LHS->hasOneUse() && RHS->hasOneUse())\n        V = Builder.CreateBinOp(TopLevelOpcode, B, D, RHS->getName());\n      if (V) {\n        SimplifiedInst = Builder.CreateBinOp(InnerOpcode, A, V);\n      }\n    }\n\n  // Does \"(X op Y) op' Z\" always equal \"(X op' Z) op (Y op' Z)\"?\n  if (!SimplifiedInst && rightDistributesOverLeft(TopLevelOpcode, InnerOpcode))\n    // Does the instruction have the form \"(A op' B) op (C op' B)\" or, in the\n    // commutative case, \"(A op' B) op (B op' D)\"?\n    if (B == D || (InnerCommutative && B == C)) {\n      if (B != D)\n        std::swap(C, D);\n      // Consider forming \"(A op C) op' B\".\n      // If \"A op C\" simplifies then it can be formed with no cost.\n      V = SimplifyBinOp(TopLevelOpcode, A, C, SQ.getWithInstruction(&I));\n\n      // If \"A op C\" doesn't simplify then only go on if both of the existing\n      // operations \"A op' B\" and \"C op' D\" will be zapped as no longer used.\n      if (!V && LHS->hasOneUse() && RHS->hasOneUse())\n        V = Builder.CreateBinOp(TopLevelOpcode, A, C, LHS->getName());\n      if (V) {\n        SimplifiedInst = Builder.CreateBinOp(InnerOpcode, V, B);\n      }\n    }\n\n  if (SimplifiedInst) {\n    ++NumFactor;\n    SimplifiedInst->takeName(&I);\n\n    // Check if we can add NSW/NUW flags to SimplifiedInst. If so, set them.\n    if (BinaryOperator *BO = dyn_cast<BinaryOperator>(SimplifiedInst)) {\n      if (isa<OverflowingBinaryOperator>(SimplifiedInst)) {\n        bool HasNSW = false;\n        bool HasNUW = false;\n        if (isa<OverflowingBinaryOperator>(&I)) {\n          HasNSW = I.hasNoSignedWrap();\n          HasNUW = I.hasNoUnsignedWrap();\n        }\n\n        if (auto *LOBO = dyn_cast<OverflowingBinaryOperator>(LHS)) {\n          HasNSW &= LOBO->hasNoSignedWrap();\n          HasNUW &= LOBO->hasNoUnsignedWrap();\n        }\n\n        if (auto *ROBO = dyn_cast<OverflowingBinaryOperator>(RHS)) {\n          HasNSW &= ROBO->hasNoSignedWrap();\n          HasNUW &= ROBO->hasNoUnsignedWrap();\n        }\n\n        if (TopLevelOpcode == Instruction::Add &&\n            InnerOpcode == Instruction::Mul) {\n          // We can propagate 'nsw' if we know that\n          //  %Y = mul nsw i16 %X, C\n          //  %Z = add nsw i16 %Y, %X\n          // =>\n          //  %Z = mul nsw i16 %X, C+1\n          //\n          // iff C+1 isn't INT_MIN\n          const APInt *CInt;\n          if (match(V, m_APInt(CInt))) {\n            if (!CInt->isMinSignedValue())\n              BO->setHasNoSignedWrap(HasNSW);\n          }\n\n          // nuw can be propagated with any constant or nuw value.\n          BO->setHasNoUnsignedWrap(HasNUW);\n        }\n      }\n    }\n  }\n  return SimplifiedInst;\n}\n\n/// This tries to simplify binary operations which some other binary operation\n/// distributes over either by factorizing out common terms\n/// (eg \"(A*B)+(A*C)\" -> \"A*(B+C)\") or expanding out if this results in\n/// simplifications (eg: \"A & (B | C) -> (A&B) | (A&C)\" if this is a win).\n/// Returns the simplified value, or null if it didn't simplify.\nValue *InstCombinerImpl::SimplifyUsingDistributiveLaws(BinaryOperator &I) {\n  Value *LHS = I.getOperand(0), *RHS = I.getOperand(1);\n  BinaryOperator *Op0 = dyn_cast<BinaryOperator>(LHS);\n  BinaryOperator *Op1 = dyn_cast<BinaryOperator>(RHS);\n  Instruction::BinaryOps TopLevelOpcode = I.getOpcode();\n\n  {\n    // Factorization.\n    Value *A, *B, *C, *D;\n    Instruction::BinaryOps LHSOpcode, RHSOpcode;\n    if (Op0)\n      LHSOpcode = getBinOpsForFactorization(TopLevelOpcode, Op0, A, B);\n    if (Op1)\n      RHSOpcode = getBinOpsForFactorization(TopLevelOpcode, Op1, C, D);\n\n    // The instruction has the form \"(A op' B) op (C op' D)\".  Try to factorize\n    // a common term.\n    if (Op0 && Op1 && LHSOpcode == RHSOpcode)\n      if (Value *V = tryFactorization(I, LHSOpcode, A, B, C, D))\n        return V;\n\n    // The instruction has the form \"(A op' B) op (C)\".  Try to factorize common\n    // term.\n    if (Op0)\n      if (Value *Ident = getIdentityValue(LHSOpcode, RHS))\n        if (Value *V = tryFactorization(I, LHSOpcode, A, B, RHS, Ident))\n          return V;\n\n    // The instruction has the form \"(B) op (C op' D)\".  Try to factorize common\n    // term.\n    if (Op1)\n      if (Value *Ident = getIdentityValue(RHSOpcode, LHS))\n        if (Value *V = tryFactorization(I, RHSOpcode, LHS, Ident, C, D))\n          return V;\n  }\n\n  // Expansion.\n  if (Op0 && rightDistributesOverLeft(Op0->getOpcode(), TopLevelOpcode)) {\n    // The instruction has the form \"(A op' B) op C\".  See if expanding it out\n    // to \"(A op C) op' (B op C)\" results in simplifications.\n    Value *A = Op0->getOperand(0), *B = Op0->getOperand(1), *C = RHS;\n    Instruction::BinaryOps InnerOpcode = Op0->getOpcode(); // op'\n\n    // Disable the use of undef because it's not safe to distribute undef.\n    auto SQDistributive = SQ.getWithInstruction(&I).getWithoutUndef();\n    Value *L = SimplifyBinOp(TopLevelOpcode, A, C, SQDistributive);\n    Value *R = SimplifyBinOp(TopLevelOpcode, B, C, SQDistributive);\n\n    // Do \"A op C\" and \"B op C\" both simplify?\n    if (L && R) {\n      // They do! Return \"L op' R\".\n      ++NumExpand;\n      C = Builder.CreateBinOp(InnerOpcode, L, R);\n      C->takeName(&I);\n      return C;\n    }\n\n    // Does \"A op C\" simplify to the identity value for the inner opcode?\n    if (L && L == ConstantExpr::getBinOpIdentity(InnerOpcode, L->getType())) {\n      // They do! Return \"B op C\".\n      ++NumExpand;\n      C = Builder.CreateBinOp(TopLevelOpcode, B, C);\n      C->takeName(&I);\n      return C;\n    }\n\n    // Does \"B op C\" simplify to the identity value for the inner opcode?\n    if (R && R == ConstantExpr::getBinOpIdentity(InnerOpcode, R->getType())) {\n      // They do! Return \"A op C\".\n      ++NumExpand;\n      C = Builder.CreateBinOp(TopLevelOpcode, A, C);\n      C->takeName(&I);\n      return C;\n    }\n  }\n\n  if (Op1 && leftDistributesOverRight(TopLevelOpcode, Op1->getOpcode())) {\n    // The instruction has the form \"A op (B op' C)\".  See if expanding it out\n    // to \"(A op B) op' (A op C)\" results in simplifications.\n    Value *A = LHS, *B = Op1->getOperand(0), *C = Op1->getOperand(1);\n    Instruction::BinaryOps InnerOpcode = Op1->getOpcode(); // op'\n\n    // Disable the use of undef because it's not safe to distribute undef.\n    auto SQDistributive = SQ.getWithInstruction(&I).getWithoutUndef();\n    Value *L = SimplifyBinOp(TopLevelOpcode, A, B, SQDistributive);\n    Value *R = SimplifyBinOp(TopLevelOpcode, A, C, SQDistributive);\n\n    // Do \"A op B\" and \"A op C\" both simplify?\n    if (L && R) {\n      // They do! Return \"L op' R\".\n      ++NumExpand;\n      A = Builder.CreateBinOp(InnerOpcode, L, R);\n      A->takeName(&I);\n      return A;\n    }\n\n    // Does \"A op B\" simplify to the identity value for the inner opcode?\n    if (L && L == ConstantExpr::getBinOpIdentity(InnerOpcode, L->getType())) {\n      // They do! Return \"A op C\".\n      ++NumExpand;\n      A = Builder.CreateBinOp(TopLevelOpcode, A, C);\n      A->takeName(&I);\n      return A;\n    }\n\n    // Does \"A op C\" simplify to the identity value for the inner opcode?\n    if (R && R == ConstantExpr::getBinOpIdentity(InnerOpcode, R->getType())) {\n      // They do! Return \"A op B\".\n      ++NumExpand;\n      A = Builder.CreateBinOp(TopLevelOpcode, A, B);\n      A->takeName(&I);\n      return A;\n    }\n  }\n\n  return SimplifySelectsFeedingBinaryOp(I, LHS, RHS);\n}\n\nValue *InstCombinerImpl::SimplifySelectsFeedingBinaryOp(BinaryOperator &I,\n                                                        Value *LHS,\n                                                        Value *RHS) {\n  Value *A, *B, *C, *D, *E, *F;\n  bool LHSIsSelect = match(LHS, m_Select(m_Value(A), m_Value(B), m_Value(C)));\n  bool RHSIsSelect = match(RHS, m_Select(m_Value(D), m_Value(E), m_Value(F)));\n  if (!LHSIsSelect && !RHSIsSelect)\n    return nullptr;\n\n  FastMathFlags FMF;\n  BuilderTy::FastMathFlagGuard Guard(Builder);\n  if (isa<FPMathOperator>(&I)) {\n    FMF = I.getFastMathFlags();\n    Builder.setFastMathFlags(FMF);\n  }\n\n  Instruction::BinaryOps Opcode = I.getOpcode();\n  SimplifyQuery Q = SQ.getWithInstruction(&I);\n\n  Value *Cond, *True = nullptr, *False = nullptr;\n  if (LHSIsSelect && RHSIsSelect && A == D) {\n    // (A ? B : C) op (A ? E : F) -> A ? (B op E) : (C op F)\n    Cond = A;\n    True = SimplifyBinOp(Opcode, B, E, FMF, Q);\n    False = SimplifyBinOp(Opcode, C, F, FMF, Q);\n\n    if (LHS->hasOneUse() && RHS->hasOneUse()) {\n      if (False && !True)\n        True = Builder.CreateBinOp(Opcode, B, E);\n      else if (True && !False)\n        False = Builder.CreateBinOp(Opcode, C, F);\n    }\n  } else if (LHSIsSelect && LHS->hasOneUse()) {\n    // (A ? B : C) op Y -> A ? (B op Y) : (C op Y)\n    Cond = A;\n    True = SimplifyBinOp(Opcode, B, RHS, FMF, Q);\n    False = SimplifyBinOp(Opcode, C, RHS, FMF, Q);\n  } else if (RHSIsSelect && RHS->hasOneUse()) {\n    // X op (D ? E : F) -> D ? (X op E) : (X op F)\n    Cond = D;\n    True = SimplifyBinOp(Opcode, LHS, E, FMF, Q);\n    False = SimplifyBinOp(Opcode, LHS, F, FMF, Q);\n  }\n\n  if (!True || !False)\n    return nullptr;\n\n  Value *SI = Builder.CreateSelect(Cond, True, False);\n  SI->takeName(&I);\n  return SI;\n}\n\n/// Freely adapt every user of V as-if V was changed to !V.\n/// WARNING: only if canFreelyInvertAllUsersOf() said this can be done.\nvoid InstCombinerImpl::freelyInvertAllUsersOf(Value *I) {\n  for (User *U : I->users()) {\n    switch (cast<Instruction>(U)->getOpcode()) {\n    case Instruction::Select: {\n      auto *SI = cast<SelectInst>(U);\n      SI->swapValues();\n      SI->swapProfMetadata();\n      break;\n    }\n    case Instruction::Br:\n      cast<BranchInst>(U)->swapSuccessors(); // swaps prof metadata too\n      break;\n    case Instruction::Xor:\n      replaceInstUsesWith(cast<Instruction>(*U), I);\n      break;\n    default:\n      llvm_unreachable(\"Got unexpected user - out of sync with \"\n                       \"canFreelyInvertAllUsersOf() ?\");\n    }\n  }\n}\n\n/// Given a 'sub' instruction, return the RHS of the instruction if the LHS is a\n/// constant zero (which is the 'negate' form).\nValue *InstCombinerImpl::dyn_castNegVal(Value *V) const {\n  Value *NegV;\n  if (match(V, m_Neg(m_Value(NegV))))\n    return NegV;\n\n  // Constants can be considered to be negated values if they can be folded.\n  if (ConstantInt *C = dyn_cast<ConstantInt>(V))\n    return ConstantExpr::getNeg(C);\n\n  if (ConstantDataVector *C = dyn_cast<ConstantDataVector>(V))\n    if (C->getType()->getElementType()->isIntegerTy())\n      return ConstantExpr::getNeg(C);\n\n  if (ConstantVector *CV = dyn_cast<ConstantVector>(V)) {\n    for (unsigned i = 0, e = CV->getNumOperands(); i != e; ++i) {\n      Constant *Elt = CV->getAggregateElement(i);\n      if (!Elt)\n        return nullptr;\n\n      if (isa<UndefValue>(Elt))\n        continue;\n\n      if (!isa<ConstantInt>(Elt))\n        return nullptr;\n    }\n    return ConstantExpr::getNeg(CV);\n  }\n\n  return nullptr;\n}\n\nstatic Value *foldOperationIntoSelectOperand(Instruction &I, Value *SO,\n                                             InstCombiner::BuilderTy &Builder) {\n  if (auto *Cast = dyn_cast<CastInst>(&I))\n    return Builder.CreateCast(Cast->getOpcode(), SO, I.getType());\n\n  assert(I.isBinaryOp() && \"Unexpected opcode for select folding\");\n\n  // Figure out if the constant is the left or the right argument.\n  bool ConstIsRHS = isa<Constant>(I.getOperand(1));\n  Constant *ConstOperand = cast<Constant>(I.getOperand(ConstIsRHS));\n\n  if (auto *SOC = dyn_cast<Constant>(SO)) {\n    if (ConstIsRHS)\n      return ConstantExpr::get(I.getOpcode(), SOC, ConstOperand);\n    return ConstantExpr::get(I.getOpcode(), ConstOperand, SOC);\n  }\n\n  Value *Op0 = SO, *Op1 = ConstOperand;\n  if (!ConstIsRHS)\n    std::swap(Op0, Op1);\n\n  auto *BO = cast<BinaryOperator>(&I);\n  Value *RI = Builder.CreateBinOp(BO->getOpcode(), Op0, Op1,\n                                  SO->getName() + \".op\");\n  auto *FPInst = dyn_cast<Instruction>(RI);\n  if (FPInst && isa<FPMathOperator>(FPInst))\n    FPInst->copyFastMathFlags(BO);\n  return RI;\n}\n\nInstruction *InstCombinerImpl::FoldOpIntoSelect(Instruction &Op,\n                                                SelectInst *SI) {\n  // Don't modify shared select instructions.\n  if (!SI->hasOneUse())\n    return nullptr;\n\n  Value *TV = SI->getTrueValue();\n  Value *FV = SI->getFalseValue();\n  if (!(isa<Constant>(TV) || isa<Constant>(FV)))\n    return nullptr;\n\n  // Bool selects with constant operands can be folded to logical ops.\n  if (SI->getType()->isIntOrIntVectorTy(1))\n    return nullptr;\n\n  // If it's a bitcast involving vectors, make sure it has the same number of\n  // elements on both sides.\n  if (auto *BC = dyn_cast<BitCastInst>(&Op)) {\n    VectorType *DestTy = dyn_cast<VectorType>(BC->getDestTy());\n    VectorType *SrcTy = dyn_cast<VectorType>(BC->getSrcTy());\n\n    // Verify that either both or neither are vectors.\n    if ((SrcTy == nullptr) != (DestTy == nullptr))\n      return nullptr;\n\n    // If vectors, verify that they have the same number of elements.\n    if (SrcTy && SrcTy->getElementCount() != DestTy->getElementCount())\n      return nullptr;\n  }\n\n  // Test if a CmpInst instruction is used exclusively by a select as\n  // part of a minimum or maximum operation. If so, refrain from doing\n  // any other folding. This helps out other analyses which understand\n  // non-obfuscated minimum and maximum idioms, such as ScalarEvolution\n  // and CodeGen. And in this case, at least one of the comparison\n  // operands has at least one user besides the compare (the select),\n  // which would often largely negate the benefit of folding anyway.\n  if (auto *CI = dyn_cast<CmpInst>(SI->getCondition())) {\n    if (CI->hasOneUse()) {\n      Value *Op0 = CI->getOperand(0), *Op1 = CI->getOperand(1);\n\n      // FIXME: This is a hack to avoid infinite looping with min/max patterns.\n      //        We have to ensure that vector constants that only differ with\n      //        undef elements are treated as equivalent.\n      auto areLooselyEqual = [](Value *A, Value *B) {\n        if (A == B)\n          return true;\n\n        // Test for vector constants.\n        Constant *ConstA, *ConstB;\n        if (!match(A, m_Constant(ConstA)) || !match(B, m_Constant(ConstB)))\n          return false;\n\n        // TODO: Deal with FP constants?\n        if (!A->getType()->isIntOrIntVectorTy() || A->getType() != B->getType())\n          return false;\n\n        // Compare for equality including undefs as equal.\n        auto *Cmp = ConstantExpr::getCompare(ICmpInst::ICMP_EQ, ConstA, ConstB);\n        const APInt *C;\n        return match(Cmp, m_APIntAllowUndef(C)) && C->isOneValue();\n      };\n\n      if ((areLooselyEqual(TV, Op0) && areLooselyEqual(FV, Op1)) ||\n          (areLooselyEqual(FV, Op0) && areLooselyEqual(TV, Op1)))\n        return nullptr;\n    }\n  }\n\n  Value *NewTV = foldOperationIntoSelectOperand(Op, TV, Builder);\n  Value *NewFV = foldOperationIntoSelectOperand(Op, FV, Builder);\n  return SelectInst::Create(SI->getCondition(), NewTV, NewFV, \"\", nullptr, SI);\n}\n\nstatic Value *foldOperationIntoPhiValue(BinaryOperator *I, Value *InV,\n                                        InstCombiner::BuilderTy &Builder) {\n  bool ConstIsRHS = isa<Constant>(I->getOperand(1));\n  Constant *C = cast<Constant>(I->getOperand(ConstIsRHS));\n\n  if (auto *InC = dyn_cast<Constant>(InV)) {\n    if (ConstIsRHS)\n      return ConstantExpr::get(I->getOpcode(), InC, C);\n    return ConstantExpr::get(I->getOpcode(), C, InC);\n  }\n\n  Value *Op0 = InV, *Op1 = C;\n  if (!ConstIsRHS)\n    std::swap(Op0, Op1);\n\n  Value *RI = Builder.CreateBinOp(I->getOpcode(), Op0, Op1, \"phi.bo\");\n  auto *FPInst = dyn_cast<Instruction>(RI);\n  if (FPInst && isa<FPMathOperator>(FPInst))\n    FPInst->copyFastMathFlags(I);\n  return RI;\n}\n\nInstruction *InstCombinerImpl::foldOpIntoPhi(Instruction &I, PHINode *PN) {\n  unsigned NumPHIValues = PN->getNumIncomingValues();\n  if (NumPHIValues == 0)\n    return nullptr;\n\n  // We normally only transform phis with a single use.  However, if a PHI has\n  // multiple uses and they are all the same operation, we can fold *all* of the\n  // uses into the PHI.\n  if (!PN->hasOneUse()) {\n    // Walk the use list for the instruction, comparing them to I.\n    for (User *U : PN->users()) {\n      Instruction *UI = cast<Instruction>(U);\n      if (UI != &I && !I.isIdenticalTo(UI))\n        return nullptr;\n    }\n    // Otherwise, we can replace *all* users with the new PHI we form.\n  }\n\n  // Check to see if all of the operands of the PHI are simple constants\n  // (constantint/constantfp/undef).  If there is one non-constant value,\n  // remember the BB it is in.  If there is more than one or if *it* is a PHI,\n  // bail out.  We don't do arbitrary constant expressions here because moving\n  // their computation can be expensive without a cost model.\n  BasicBlock *NonConstBB = nullptr;\n  for (unsigned i = 0; i != NumPHIValues; ++i) {\n    Value *InVal = PN->getIncomingValue(i);\n    // If I is a freeze instruction, count undef as a non-constant.\n    if (match(InVal, m_ImmConstant()) &&\n        (!isa<FreezeInst>(I) || isGuaranteedNotToBeUndefOrPoison(InVal)))\n      continue;\n\n    if (isa<PHINode>(InVal)) return nullptr;  // Itself a phi.\n    if (NonConstBB) return nullptr;  // More than one non-const value.\n\n    NonConstBB = PN->getIncomingBlock(i);\n\n    // If the InVal is an invoke at the end of the pred block, then we can't\n    // insert a computation after it without breaking the edge.\n    if (isa<InvokeInst>(InVal))\n      if (cast<Instruction>(InVal)->getParent() == NonConstBB)\n        return nullptr;\n\n    // If the incoming non-constant value is in I's block, we will remove one\n    // instruction, but insert another equivalent one, leading to infinite\n    // instcombine.\n    if (isPotentiallyReachable(I.getParent(), NonConstBB, &DT, LI))\n      return nullptr;\n  }\n\n  // If there is exactly one non-constant value, we can insert a copy of the\n  // operation in that block.  However, if this is a critical edge, we would be\n  // inserting the computation on some other paths (e.g. inside a loop).  Only\n  // do this if the pred block is unconditionally branching into the phi block.\n  // Also, make sure that the pred block is not dead code.\n  if (NonConstBB != nullptr) {\n    BranchInst *BI = dyn_cast<BranchInst>(NonConstBB->getTerminator());\n    if (!BI || !BI->isUnconditional() || !DT.isReachableFromEntry(NonConstBB))\n      return nullptr;\n  }\n\n  // Okay, we can do the transformation: create the new PHI node.\n  PHINode *NewPN = PHINode::Create(I.getType(), PN->getNumIncomingValues());\n  InsertNewInstBefore(NewPN, *PN);\n  NewPN->takeName(PN);\n\n  // If we are going to have to insert a new computation, do so right before the\n  // predecessor's terminator.\n  if (NonConstBB)\n    Builder.SetInsertPoint(NonConstBB->getTerminator());\n\n  // Next, add all of the operands to the PHI.\n  if (SelectInst *SI = dyn_cast<SelectInst>(&I)) {\n    // We only currently try to fold the condition of a select when it is a phi,\n    // not the true/false values.\n    Value *TrueV = SI->getTrueValue();\n    Value *FalseV = SI->getFalseValue();\n    BasicBlock *PhiTransBB = PN->getParent();\n    for (unsigned i = 0; i != NumPHIValues; ++i) {\n      BasicBlock *ThisBB = PN->getIncomingBlock(i);\n      Value *TrueVInPred = TrueV->DoPHITranslation(PhiTransBB, ThisBB);\n      Value *FalseVInPred = FalseV->DoPHITranslation(PhiTransBB, ThisBB);\n      Value *InV = nullptr;\n      // Beware of ConstantExpr:  it may eventually evaluate to getNullValue,\n      // even if currently isNullValue gives false.\n      Constant *InC = dyn_cast<Constant>(PN->getIncomingValue(i));\n      // For vector constants, we cannot use isNullValue to fold into\n      // FalseVInPred versus TrueVInPred. When we have individual nonzero\n      // elements in the vector, we will incorrectly fold InC to\n      // `TrueVInPred`.\n      if (InC && isa<ConstantInt>(InC))\n        InV = InC->isNullValue() ? FalseVInPred : TrueVInPred;\n      else {\n        // Generate the select in the same block as PN's current incoming block.\n        // Note: ThisBB need not be the NonConstBB because vector constants\n        // which are constants by definition are handled here.\n        // FIXME: This can lead to an increase in IR generation because we might\n        // generate selects for vector constant phi operand, that could not be\n        // folded to TrueVInPred or FalseVInPred as done for ConstantInt. For\n        // non-vector phis, this transformation was always profitable because\n        // the select would be generated exactly once in the NonConstBB.\n        Builder.SetInsertPoint(ThisBB->getTerminator());\n        InV = Builder.CreateSelect(PN->getIncomingValue(i), TrueVInPred,\n                                   FalseVInPred, \"phi.sel\");\n      }\n      NewPN->addIncoming(InV, ThisBB);\n    }\n  } else if (CmpInst *CI = dyn_cast<CmpInst>(&I)) {\n    Constant *C = cast<Constant>(I.getOperand(1));\n    for (unsigned i = 0; i != NumPHIValues; ++i) {\n      Value *InV = nullptr;\n      if (auto *InC = dyn_cast<Constant>(PN->getIncomingValue(i)))\n        InV = ConstantExpr::getCompare(CI->getPredicate(), InC, C);\n      else\n        InV = Builder.CreateCmp(CI->getPredicate(), PN->getIncomingValue(i),\n                                C, \"phi.cmp\");\n      NewPN->addIncoming(InV, PN->getIncomingBlock(i));\n    }\n  } else if (auto *BO = dyn_cast<BinaryOperator>(&I)) {\n    for (unsigned i = 0; i != NumPHIValues; ++i) {\n      Value *InV = foldOperationIntoPhiValue(BO, PN->getIncomingValue(i),\n                                             Builder);\n      NewPN->addIncoming(InV, PN->getIncomingBlock(i));\n    }\n  } else if (isa<FreezeInst>(&I)) {\n    for (unsigned i = 0; i != NumPHIValues; ++i) {\n      Value *InV;\n      if (NonConstBB == PN->getIncomingBlock(i))\n        InV = Builder.CreateFreeze(PN->getIncomingValue(i), \"phi.fr\");\n      else\n        InV = PN->getIncomingValue(i);\n      NewPN->addIncoming(InV, PN->getIncomingBlock(i));\n    }\n  } else {\n    CastInst *CI = cast<CastInst>(&I);\n    Type *RetTy = CI->getType();\n    for (unsigned i = 0; i != NumPHIValues; ++i) {\n      Value *InV;\n      if (Constant *InC = dyn_cast<Constant>(PN->getIncomingValue(i)))\n        InV = ConstantExpr::getCast(CI->getOpcode(), InC, RetTy);\n      else\n        InV = Builder.CreateCast(CI->getOpcode(), PN->getIncomingValue(i),\n                                 I.getType(), \"phi.cast\");\n      NewPN->addIncoming(InV, PN->getIncomingBlock(i));\n    }\n  }\n\n  for (User *U : make_early_inc_range(PN->users())) {\n    Instruction *User = cast<Instruction>(U);\n    if (User == &I) continue;\n    replaceInstUsesWith(*User, NewPN);\n    eraseInstFromFunction(*User);\n  }\n  return replaceInstUsesWith(I, NewPN);\n}\n\nInstruction *InstCombinerImpl::foldBinOpIntoSelectOrPhi(BinaryOperator &I) {\n  if (!isa<Constant>(I.getOperand(1)))\n    return nullptr;\n\n  if (auto *Sel = dyn_cast<SelectInst>(I.getOperand(0))) {\n    if (Instruction *NewSel = FoldOpIntoSelect(I, Sel))\n      return NewSel;\n  } else if (auto *PN = dyn_cast<PHINode>(I.getOperand(0))) {\n    if (Instruction *NewPhi = foldOpIntoPhi(I, PN))\n      return NewPhi;\n  }\n  return nullptr;\n}\n\n/// Given a pointer type and a constant offset, determine whether or not there\n/// is a sequence of GEP indices into the pointed type that will land us at the\n/// specified offset. If so, fill them into NewIndices and return the resultant\n/// element type, otherwise return null.\nType *\nInstCombinerImpl::FindElementAtOffset(PointerType *PtrTy, int64_t Offset,\n                                      SmallVectorImpl<Value *> &NewIndices) {\n  Type *Ty = PtrTy->getElementType();\n  if (!Ty->isSized())\n    return nullptr;\n\n  // Start with the index over the outer type.  Note that the type size\n  // might be zero (even if the offset isn't zero) if the indexed type\n  // is something like [0 x {int, int}]\n  Type *IndexTy = DL.getIndexType(PtrTy);\n  int64_t FirstIdx = 0;\n  if (int64_t TySize = DL.getTypeAllocSize(Ty)) {\n    FirstIdx = Offset/TySize;\n    Offset -= FirstIdx*TySize;\n\n    // Handle hosts where % returns negative instead of values [0..TySize).\n    if (Offset < 0) {\n      --FirstIdx;\n      Offset += TySize;\n      assert(Offset >= 0);\n    }\n    assert((uint64_t)Offset < (uint64_t)TySize && \"Out of range offset\");\n  }\n\n  NewIndices.push_back(ConstantInt::get(IndexTy, FirstIdx));\n\n  // Index into the types.  If we fail, set OrigBase to null.\n  while (Offset) {\n    // Indexing into tail padding between struct/array elements.\n    if (uint64_t(Offset * 8) >= DL.getTypeSizeInBits(Ty))\n      return nullptr;\n\n    if (StructType *STy = dyn_cast<StructType>(Ty)) {\n      const StructLayout *SL = DL.getStructLayout(STy);\n      assert(Offset < (int64_t)SL->getSizeInBytes() &&\n             \"Offset must stay within the indexed type\");\n\n      unsigned Elt = SL->getElementContainingOffset(Offset);\n      NewIndices.push_back(ConstantInt::get(Type::getInt32Ty(Ty->getContext()),\n                                            Elt));\n\n      Offset -= SL->getElementOffset(Elt);\n      Ty = STy->getElementType(Elt);\n    } else if (ArrayType *AT = dyn_cast<ArrayType>(Ty)) {\n      uint64_t EltSize = DL.getTypeAllocSize(AT->getElementType());\n      assert(EltSize && \"Cannot index into a zero-sized array\");\n      NewIndices.push_back(ConstantInt::get(IndexTy,Offset/EltSize));\n      Offset %= EltSize;\n      Ty = AT->getElementType();\n    } else {\n      // Otherwise, we can't index into the middle of this atomic type, bail.\n      return nullptr;\n    }\n  }\n\n  return Ty;\n}\n\nstatic bool shouldMergeGEPs(GEPOperator &GEP, GEPOperator &Src) {\n  // If this GEP has only 0 indices, it is the same pointer as\n  // Src. If Src is not a trivial GEP too, don't combine\n  // the indices.\n  if (GEP.hasAllZeroIndices() && !Src.hasAllZeroIndices() &&\n      !Src.hasOneUse())\n    return false;\n  return true;\n}\n\n/// Return a value X such that Val = X * Scale, or null if none.\n/// If the multiplication is known not to overflow, then NoSignedWrap is set.\nValue *InstCombinerImpl::Descale(Value *Val, APInt Scale, bool &NoSignedWrap) {\n  assert(isa<IntegerType>(Val->getType()) && \"Can only descale integers!\");\n  assert(cast<IntegerType>(Val->getType())->getBitWidth() ==\n         Scale.getBitWidth() && \"Scale not compatible with value!\");\n\n  // If Val is zero or Scale is one then Val = Val * Scale.\n  if (match(Val, m_Zero()) || Scale == 1) {\n    NoSignedWrap = true;\n    return Val;\n  }\n\n  // If Scale is zero then it does not divide Val.\n  if (Scale.isMinValue())\n    return nullptr;\n\n  // Look through chains of multiplications, searching for a constant that is\n  // divisible by Scale.  For example, descaling X*(Y*(Z*4)) by a factor of 4\n  // will find the constant factor 4 and produce X*(Y*Z).  Descaling X*(Y*8) by\n  // a factor of 4 will produce X*(Y*2).  The principle of operation is to bore\n  // down from Val:\n  //\n  //     Val = M1 * X          ||   Analysis starts here and works down\n  //      M1 = M2 * Y          ||   Doesn't descend into terms with more\n  //      M2 =  Z * 4          \\/   than one use\n  //\n  // Then to modify a term at the bottom:\n  //\n  //     Val = M1 * X\n  //      M1 =  Z * Y          ||   Replaced M2 with Z\n  //\n  // Then to work back up correcting nsw flags.\n\n  // Op - the term we are currently analyzing.  Starts at Val then drills down.\n  // Replaced with its descaled value before exiting from the drill down loop.\n  Value *Op = Val;\n\n  // Parent - initially null, but after drilling down notes where Op came from.\n  // In the example above, Parent is (Val, 0) when Op is M1, because M1 is the\n  // 0'th operand of Val.\n  std::pair<Instruction *, unsigned> Parent;\n\n  // Set if the transform requires a descaling at deeper levels that doesn't\n  // overflow.\n  bool RequireNoSignedWrap = false;\n\n  // Log base 2 of the scale. Negative if not a power of 2.\n  int32_t logScale = Scale.exactLogBase2();\n\n  for (;; Op = Parent.first->getOperand(Parent.second)) { // Drill down\n    if (ConstantInt *CI = dyn_cast<ConstantInt>(Op)) {\n      // If Op is a constant divisible by Scale then descale to the quotient.\n      APInt Quotient(Scale), Remainder(Scale); // Init ensures right bitwidth.\n      APInt::sdivrem(CI->getValue(), Scale, Quotient, Remainder);\n      if (!Remainder.isMinValue())\n        // Not divisible by Scale.\n        return nullptr;\n      // Replace with the quotient in the parent.\n      Op = ConstantInt::get(CI->getType(), Quotient);\n      NoSignedWrap = true;\n      break;\n    }\n\n    if (BinaryOperator *BO = dyn_cast<BinaryOperator>(Op)) {\n      if (BO->getOpcode() == Instruction::Mul) {\n        // Multiplication.\n        NoSignedWrap = BO->hasNoSignedWrap();\n        if (RequireNoSignedWrap && !NoSignedWrap)\n          return nullptr;\n\n        // There are three cases for multiplication: multiplication by exactly\n        // the scale, multiplication by a constant different to the scale, and\n        // multiplication by something else.\n        Value *LHS = BO->getOperand(0);\n        Value *RHS = BO->getOperand(1);\n\n        if (ConstantInt *CI = dyn_cast<ConstantInt>(RHS)) {\n          // Multiplication by a constant.\n          if (CI->getValue() == Scale) {\n            // Multiplication by exactly the scale, replace the multiplication\n            // by its left-hand side in the parent.\n            Op = LHS;\n            break;\n          }\n\n          // Otherwise drill down into the constant.\n          if (!Op->hasOneUse())\n            return nullptr;\n\n          Parent = std::make_pair(BO, 1);\n          continue;\n        }\n\n        // Multiplication by something else. Drill down into the left-hand side\n        // since that's where the reassociate pass puts the good stuff.\n        if (!Op->hasOneUse())\n          return nullptr;\n\n        Parent = std::make_pair(BO, 0);\n        continue;\n      }\n\n      if (logScale > 0 && BO->getOpcode() == Instruction::Shl &&\n          isa<ConstantInt>(BO->getOperand(1))) {\n        // Multiplication by a power of 2.\n        NoSignedWrap = BO->hasNoSignedWrap();\n        if (RequireNoSignedWrap && !NoSignedWrap)\n          return nullptr;\n\n        Value *LHS = BO->getOperand(0);\n        int32_t Amt = cast<ConstantInt>(BO->getOperand(1))->\n          getLimitedValue(Scale.getBitWidth());\n        // Op = LHS << Amt.\n\n        if (Amt == logScale) {\n          // Multiplication by exactly the scale, replace the multiplication\n          // by its left-hand side in the parent.\n          Op = LHS;\n          break;\n        }\n        if (Amt < logScale || !Op->hasOneUse())\n          return nullptr;\n\n        // Multiplication by more than the scale.  Reduce the multiplying amount\n        // by the scale in the parent.\n        Parent = std::make_pair(BO, 1);\n        Op = ConstantInt::get(BO->getType(), Amt - logScale);\n        break;\n      }\n    }\n\n    if (!Op->hasOneUse())\n      return nullptr;\n\n    if (CastInst *Cast = dyn_cast<CastInst>(Op)) {\n      if (Cast->getOpcode() == Instruction::SExt) {\n        // Op is sign-extended from a smaller type, descale in the smaller type.\n        unsigned SmallSize = Cast->getSrcTy()->getPrimitiveSizeInBits();\n        APInt SmallScale = Scale.trunc(SmallSize);\n        // Suppose Op = sext X, and we descale X as Y * SmallScale.  We want to\n        // descale Op as (sext Y) * Scale.  In order to have\n        //   sext (Y * SmallScale) = (sext Y) * Scale\n        // some conditions need to hold however: SmallScale must sign-extend to\n        // Scale and the multiplication Y * SmallScale should not overflow.\n        if (SmallScale.sext(Scale.getBitWidth()) != Scale)\n          // SmallScale does not sign-extend to Scale.\n          return nullptr;\n        assert(SmallScale.exactLogBase2() == logScale);\n        // Require that Y * SmallScale must not overflow.\n        RequireNoSignedWrap = true;\n\n        // Drill down through the cast.\n        Parent = std::make_pair(Cast, 0);\n        Scale = SmallScale;\n        continue;\n      }\n\n      if (Cast->getOpcode() == Instruction::Trunc) {\n        // Op is truncated from a larger type, descale in the larger type.\n        // Suppose Op = trunc X, and we descale X as Y * sext Scale.  Then\n        //   trunc (Y * sext Scale) = (trunc Y) * Scale\n        // always holds.  However (trunc Y) * Scale may overflow even if\n        // trunc (Y * sext Scale) does not, so nsw flags need to be cleared\n        // from this point up in the expression (see later).\n        if (RequireNoSignedWrap)\n          return nullptr;\n\n        // Drill down through the cast.\n        unsigned LargeSize = Cast->getSrcTy()->getPrimitiveSizeInBits();\n        Parent = std::make_pair(Cast, 0);\n        Scale = Scale.sext(LargeSize);\n        if (logScale + 1 == (int32_t)Cast->getType()->getPrimitiveSizeInBits())\n          logScale = -1;\n        assert(Scale.exactLogBase2() == logScale);\n        continue;\n      }\n    }\n\n    // Unsupported expression, bail out.\n    return nullptr;\n  }\n\n  // If Op is zero then Val = Op * Scale.\n  if (match(Op, m_Zero())) {\n    NoSignedWrap = true;\n    return Op;\n  }\n\n  // We know that we can successfully descale, so from here on we can safely\n  // modify the IR.  Op holds the descaled version of the deepest term in the\n  // expression.  NoSignedWrap is 'true' if multiplying Op by Scale is known\n  // not to overflow.\n\n  if (!Parent.first)\n    // The expression only had one term.\n    return Op;\n\n  // Rewrite the parent using the descaled version of its operand.\n  assert(Parent.first->hasOneUse() && \"Drilled down when more than one use!\");\n  assert(Op != Parent.first->getOperand(Parent.second) &&\n         \"Descaling was a no-op?\");\n  replaceOperand(*Parent.first, Parent.second, Op);\n  Worklist.push(Parent.first);\n\n  // Now work back up the expression correcting nsw flags.  The logic is based\n  // on the following observation: if X * Y is known not to overflow as a signed\n  // multiplication, and Y is replaced by a value Z with smaller absolute value,\n  // then X * Z will not overflow as a signed multiplication either.  As we work\n  // our way up, having NoSignedWrap 'true' means that the descaled value at the\n  // current level has strictly smaller absolute value than the original.\n  Instruction *Ancestor = Parent.first;\n  do {\n    if (BinaryOperator *BO = dyn_cast<BinaryOperator>(Ancestor)) {\n      // If the multiplication wasn't nsw then we can't say anything about the\n      // value of the descaled multiplication, and we have to clear nsw flags\n      // from this point on up.\n      bool OpNoSignedWrap = BO->hasNoSignedWrap();\n      NoSignedWrap &= OpNoSignedWrap;\n      if (NoSignedWrap != OpNoSignedWrap) {\n        BO->setHasNoSignedWrap(NoSignedWrap);\n        Worklist.push(Ancestor);\n      }\n    } else if (Ancestor->getOpcode() == Instruction::Trunc) {\n      // The fact that the descaled input to the trunc has smaller absolute\n      // value than the original input doesn't tell us anything useful about\n      // the absolute values of the truncations.\n      NoSignedWrap = false;\n    }\n    assert((Ancestor->getOpcode() != Instruction::SExt || NoSignedWrap) &&\n           \"Failed to keep proper track of nsw flags while drilling down?\");\n\n    if (Ancestor == Val)\n      // Got to the top, all done!\n      return Val;\n\n    // Move up one level in the expression.\n    assert(Ancestor->hasOneUse() && \"Drilled down when more than one use!\");\n    Ancestor = Ancestor->user_back();\n  } while (true);\n}\n\nInstruction *InstCombinerImpl::foldVectorBinop(BinaryOperator &Inst) {\n  if (!isa<VectorType>(Inst.getType()))\n    return nullptr;\n\n  BinaryOperator::BinaryOps Opcode = Inst.getOpcode();\n  Value *LHS = Inst.getOperand(0), *RHS = Inst.getOperand(1);\n  assert(cast<VectorType>(LHS->getType())->getElementCount() ==\n         cast<VectorType>(Inst.getType())->getElementCount());\n  assert(cast<VectorType>(RHS->getType())->getElementCount() ==\n         cast<VectorType>(Inst.getType())->getElementCount());\n\n  // If both operands of the binop are vector concatenations, then perform the\n  // narrow binop on each pair of the source operands followed by concatenation\n  // of the results.\n  Value *L0, *L1, *R0, *R1;\n  ArrayRef<int> Mask;\n  if (match(LHS, m_Shuffle(m_Value(L0), m_Value(L1), m_Mask(Mask))) &&\n      match(RHS, m_Shuffle(m_Value(R0), m_Value(R1), m_SpecificMask(Mask))) &&\n      LHS->hasOneUse() && RHS->hasOneUse() &&\n      cast<ShuffleVectorInst>(LHS)->isConcat() &&\n      cast<ShuffleVectorInst>(RHS)->isConcat()) {\n    // This transform does not have the speculative execution constraint as\n    // below because the shuffle is a concatenation. The new binops are\n    // operating on exactly the same elements as the existing binop.\n    // TODO: We could ease the mask requirement to allow different undef lanes,\n    //       but that requires an analysis of the binop-with-undef output value.\n    Value *NewBO0 = Builder.CreateBinOp(Opcode, L0, R0);\n    if (auto *BO = dyn_cast<BinaryOperator>(NewBO0))\n      BO->copyIRFlags(&Inst);\n    Value *NewBO1 = Builder.CreateBinOp(Opcode, L1, R1);\n    if (auto *BO = dyn_cast<BinaryOperator>(NewBO1))\n      BO->copyIRFlags(&Inst);\n    return new ShuffleVectorInst(NewBO0, NewBO1, Mask);\n  }\n\n  // It may not be safe to reorder shuffles and things like div, urem, etc.\n  // because we may trap when executing those ops on unknown vector elements.\n  // See PR20059.\n  if (!isSafeToSpeculativelyExecute(&Inst))\n    return nullptr;\n\n  auto createBinOpShuffle = [&](Value *X, Value *Y, ArrayRef<int> M) {\n    Value *XY = Builder.CreateBinOp(Opcode, X, Y);\n    if (auto *BO = dyn_cast<BinaryOperator>(XY))\n      BO->copyIRFlags(&Inst);\n    return new ShuffleVectorInst(XY, UndefValue::get(XY->getType()), M);\n  };\n\n  // If both arguments of the binary operation are shuffles that use the same\n  // mask and shuffle within a single vector, move the shuffle after the binop.\n  Value *V1, *V2;\n  if (match(LHS, m_Shuffle(m_Value(V1), m_Undef(), m_Mask(Mask))) &&\n      match(RHS, m_Shuffle(m_Value(V2), m_Undef(), m_SpecificMask(Mask))) &&\n      V1->getType() == V2->getType() &&\n      (LHS->hasOneUse() || RHS->hasOneUse() || LHS == RHS)) {\n    // Op(shuffle(V1, Mask), shuffle(V2, Mask)) -> shuffle(Op(V1, V2), Mask)\n    return createBinOpShuffle(V1, V2, Mask);\n  }\n\n  // If both arguments of a commutative binop are select-shuffles that use the\n  // same mask with commuted operands, the shuffles are unnecessary.\n  if (Inst.isCommutative() &&\n      match(LHS, m_Shuffle(m_Value(V1), m_Value(V2), m_Mask(Mask))) &&\n      match(RHS,\n            m_Shuffle(m_Specific(V2), m_Specific(V1), m_SpecificMask(Mask)))) {\n    auto *LShuf = cast<ShuffleVectorInst>(LHS);\n    auto *RShuf = cast<ShuffleVectorInst>(RHS);\n    // TODO: Allow shuffles that contain undefs in the mask?\n    //       That is legal, but it reduces undef knowledge.\n    // TODO: Allow arbitrary shuffles by shuffling after binop?\n    //       That might be legal, but we have to deal with poison.\n    if (LShuf->isSelect() &&\n        !is_contained(LShuf->getShuffleMask(), UndefMaskElem) &&\n        RShuf->isSelect() &&\n        !is_contained(RShuf->getShuffleMask(), UndefMaskElem)) {\n      // Example:\n      // LHS = shuffle V1, V2, <0, 5, 6, 3>\n      // RHS = shuffle V2, V1, <0, 5, 6, 3>\n      // LHS + RHS --> (V10+V20, V21+V11, V22+V12, V13+V23) --> V1 + V2\n      Instruction *NewBO = BinaryOperator::Create(Opcode, V1, V2);\n      NewBO->copyIRFlags(&Inst);\n      return NewBO;\n    }\n  }\n\n  // If one argument is a shuffle within one vector and the other is a constant,\n  // try moving the shuffle after the binary operation. This canonicalization\n  // intends to move shuffles closer to other shuffles and binops closer to\n  // other binops, so they can be folded. It may also enable demanded elements\n  // transforms.\n  Constant *C;\n  auto *InstVTy = dyn_cast<FixedVectorType>(Inst.getType());\n  if (InstVTy &&\n      match(&Inst,\n            m_c_BinOp(m_OneUse(m_Shuffle(m_Value(V1), m_Undef(), m_Mask(Mask))),\n                      m_ImmConstant(C))) &&\n      cast<FixedVectorType>(V1->getType())->getNumElements() <=\n          InstVTy->getNumElements()) {\n    assert(InstVTy->getScalarType() == V1->getType()->getScalarType() &&\n           \"Shuffle should not change scalar type\");\n\n    // Find constant NewC that has property:\n    //   shuffle(NewC, ShMask) = C\n    // If such constant does not exist (example: ShMask=<0,0> and C=<1,2>)\n    // reorder is not possible. A 1-to-1 mapping is not required. Example:\n    // ShMask = <1,1,2,2> and C = <5,5,6,6> --> NewC = <undef,5,6,undef>\n    bool ConstOp1 = isa<Constant>(RHS);\n    ArrayRef<int> ShMask = Mask;\n    unsigned SrcVecNumElts =\n        cast<FixedVectorType>(V1->getType())->getNumElements();\n    UndefValue *UndefScalar = UndefValue::get(C->getType()->getScalarType());\n    SmallVector<Constant *, 16> NewVecC(SrcVecNumElts, UndefScalar);\n    bool MayChange = true;\n    unsigned NumElts = InstVTy->getNumElements();\n    for (unsigned I = 0; I < NumElts; ++I) {\n      Constant *CElt = C->getAggregateElement(I);\n      if (ShMask[I] >= 0) {\n        assert(ShMask[I] < (int)NumElts && \"Not expecting narrowing shuffle\");\n        Constant *NewCElt = NewVecC[ShMask[I]];\n        // Bail out if:\n        // 1. The constant vector contains a constant expression.\n        // 2. The shuffle needs an element of the constant vector that can't\n        //    be mapped to a new constant vector.\n        // 3. This is a widening shuffle that copies elements of V1 into the\n        //    extended elements (extending with undef is allowed).\n        if (!CElt || (!isa<UndefValue>(NewCElt) && NewCElt != CElt) ||\n            I >= SrcVecNumElts) {\n          MayChange = false;\n          break;\n        }\n        NewVecC[ShMask[I]] = CElt;\n      }\n      // If this is a widening shuffle, we must be able to extend with undef\n      // elements. If the original binop does not produce an undef in the high\n      // lanes, then this transform is not safe.\n      // Similarly for undef lanes due to the shuffle mask, we can only\n      // transform binops that preserve undef.\n      // TODO: We could shuffle those non-undef constant values into the\n      //       result by using a constant vector (rather than an undef vector)\n      //       as operand 1 of the new binop, but that might be too aggressive\n      //       for target-independent shuffle creation.\n      if (I >= SrcVecNumElts || ShMask[I] < 0) {\n        Constant *MaybeUndef =\n            ConstOp1 ? ConstantExpr::get(Opcode, UndefScalar, CElt)\n                     : ConstantExpr::get(Opcode, CElt, UndefScalar);\n        if (!isa<UndefValue>(MaybeUndef)) {\n          MayChange = false;\n          break;\n        }\n      }\n    }\n    if (MayChange) {\n      Constant *NewC = ConstantVector::get(NewVecC);\n      // It may not be safe to execute a binop on a vector with undef elements\n      // because the entire instruction can be folded to undef or create poison\n      // that did not exist in the original code.\n      if (Inst.isIntDivRem() || (Inst.isShift() && ConstOp1))\n        NewC = getSafeVectorConstantForBinop(Opcode, NewC, ConstOp1);\n\n      // Op(shuffle(V1, Mask), C) -> shuffle(Op(V1, NewC), Mask)\n      // Op(C, shuffle(V1, Mask)) -> shuffle(Op(NewC, V1), Mask)\n      Value *NewLHS = ConstOp1 ? V1 : NewC;\n      Value *NewRHS = ConstOp1 ? NewC : V1;\n      return createBinOpShuffle(NewLHS, NewRHS, Mask);\n    }\n  }\n\n  // Try to reassociate to sink a splat shuffle after a binary operation.\n  if (Inst.isAssociative() && Inst.isCommutative()) {\n    // Canonicalize shuffle operand as LHS.\n    if (isa<ShuffleVectorInst>(RHS))\n      std::swap(LHS, RHS);\n\n    Value *X;\n    ArrayRef<int> MaskC;\n    int SplatIndex;\n    BinaryOperator *BO;\n    if (!match(LHS,\n               m_OneUse(m_Shuffle(m_Value(X), m_Undef(), m_Mask(MaskC)))) ||\n        !match(MaskC, m_SplatOrUndefMask(SplatIndex)) ||\n        X->getType() != Inst.getType() || !match(RHS, m_OneUse(m_BinOp(BO))) ||\n        BO->getOpcode() != Opcode)\n      return nullptr;\n\n    // FIXME: This may not be safe if the analysis allows undef elements. By\n    //        moving 'Y' before the splat shuffle, we are implicitly assuming\n    //        that it is not undef/poison at the splat index.\n    Value *Y, *OtherOp;\n    if (isSplatValue(BO->getOperand(0), SplatIndex)) {\n      Y = BO->getOperand(0);\n      OtherOp = BO->getOperand(1);\n    } else if (isSplatValue(BO->getOperand(1), SplatIndex)) {\n      Y = BO->getOperand(1);\n      OtherOp = BO->getOperand(0);\n    } else {\n      return nullptr;\n    }\n\n    // X and Y are splatted values, so perform the binary operation on those\n    // values followed by a splat followed by the 2nd binary operation:\n    // bo (splat X), (bo Y, OtherOp) --> bo (splat (bo X, Y)), OtherOp\n    Value *NewBO = Builder.CreateBinOp(Opcode, X, Y);\n    SmallVector<int, 8> NewMask(MaskC.size(), SplatIndex);\n    Value *NewSplat = Builder.CreateShuffleVector(NewBO, NewMask);\n    Instruction *R = BinaryOperator::Create(Opcode, NewSplat, OtherOp);\n\n    // Intersect FMF on both new binops. Other (poison-generating) flags are\n    // dropped to be safe.\n    if (isa<FPMathOperator>(R)) {\n      R->copyFastMathFlags(&Inst);\n      R->andIRFlags(BO);\n    }\n    if (auto *NewInstBO = dyn_cast<BinaryOperator>(NewBO))\n      NewInstBO->copyIRFlags(R);\n    return R;\n  }\n\n  return nullptr;\n}\n\n/// Try to narrow the width of a binop if at least 1 operand is an extend of\n/// of a value. This requires a potentially expensive known bits check to make\n/// sure the narrow op does not overflow.\nInstruction *InstCombinerImpl::narrowMathIfNoOverflow(BinaryOperator &BO) {\n  // We need at least one extended operand.\n  Value *Op0 = BO.getOperand(0), *Op1 = BO.getOperand(1);\n\n  // If this is a sub, we swap the operands since we always want an extension\n  // on the RHS. The LHS can be an extension or a constant.\n  if (BO.getOpcode() == Instruction::Sub)\n    std::swap(Op0, Op1);\n\n  Value *X;\n  bool IsSext = match(Op0, m_SExt(m_Value(X)));\n  if (!IsSext && !match(Op0, m_ZExt(m_Value(X))))\n    return nullptr;\n\n  // If both operands are the same extension from the same source type and we\n  // can eliminate at least one (hasOneUse), this might work.\n  CastInst::CastOps CastOpc = IsSext ? Instruction::SExt : Instruction::ZExt;\n  Value *Y;\n  if (!(match(Op1, m_ZExtOrSExt(m_Value(Y))) && X->getType() == Y->getType() &&\n        cast<Operator>(Op1)->getOpcode() == CastOpc &&\n        (Op0->hasOneUse() || Op1->hasOneUse()))) {\n    // If that did not match, see if we have a suitable constant operand.\n    // Truncating and extending must produce the same constant.\n    Constant *WideC;\n    if (!Op0->hasOneUse() || !match(Op1, m_Constant(WideC)))\n      return nullptr;\n    Constant *NarrowC = ConstantExpr::getTrunc(WideC, X->getType());\n    if (ConstantExpr::getCast(CastOpc, NarrowC, BO.getType()) != WideC)\n      return nullptr;\n    Y = NarrowC;\n  }\n\n  // Swap back now that we found our operands.\n  if (BO.getOpcode() == Instruction::Sub)\n    std::swap(X, Y);\n\n  // Both operands have narrow versions. Last step: the math must not overflow\n  // in the narrow width.\n  if (!willNotOverflow(BO.getOpcode(), X, Y, BO, IsSext))\n    return nullptr;\n\n  // bo (ext X), (ext Y) --> ext (bo X, Y)\n  // bo (ext X), C       --> ext (bo X, C')\n  Value *NarrowBO = Builder.CreateBinOp(BO.getOpcode(), X, Y, \"narrow\");\n  if (auto *NewBinOp = dyn_cast<BinaryOperator>(NarrowBO)) {\n    if (IsSext)\n      NewBinOp->setHasNoSignedWrap();\n    else\n      NewBinOp->setHasNoUnsignedWrap();\n  }\n  return CastInst::Create(CastOpc, NarrowBO, BO.getType());\n}\n\nstatic bool isMergedGEPInBounds(GEPOperator &GEP1, GEPOperator &GEP2) {\n  // At least one GEP must be inbounds.\n  if (!GEP1.isInBounds() && !GEP2.isInBounds())\n    return false;\n\n  return (GEP1.isInBounds() || GEP1.hasAllZeroIndices()) &&\n         (GEP2.isInBounds() || GEP2.hasAllZeroIndices());\n}\n\n/// Thread a GEP operation with constant indices through the constant true/false\n/// arms of a select.\nstatic Instruction *foldSelectGEP(GetElementPtrInst &GEP,\n                                  InstCombiner::BuilderTy &Builder) {\n  if (!GEP.hasAllConstantIndices())\n    return nullptr;\n\n  Instruction *Sel;\n  Value *Cond;\n  Constant *TrueC, *FalseC;\n  if (!match(GEP.getPointerOperand(), m_Instruction(Sel)) ||\n      !match(Sel,\n             m_Select(m_Value(Cond), m_Constant(TrueC), m_Constant(FalseC))))\n    return nullptr;\n\n  // gep (select Cond, TrueC, FalseC), IndexC --> select Cond, TrueC', FalseC'\n  // Propagate 'inbounds' and metadata from existing instructions.\n  // Note: using IRBuilder to create the constants for efficiency.\n  SmallVector<Value *, 4> IndexC(GEP.indices());\n  bool IsInBounds = GEP.isInBounds();\n  Value *NewTrueC = IsInBounds ? Builder.CreateInBoundsGEP(TrueC, IndexC)\n                               : Builder.CreateGEP(TrueC, IndexC);\n  Value *NewFalseC = IsInBounds ? Builder.CreateInBoundsGEP(FalseC, IndexC)\n                                : Builder.CreateGEP(FalseC, IndexC);\n  return SelectInst::Create(Cond, NewTrueC, NewFalseC, \"\", nullptr, Sel);\n}\n\nInstruction *InstCombinerImpl::visitGetElementPtrInst(GetElementPtrInst &GEP) {\n  SmallVector<Value *, 8> Ops(GEP.operands());\n  Type *GEPType = GEP.getType();\n  Type *GEPEltType = GEP.getSourceElementType();\n  bool IsGEPSrcEleScalable = isa<ScalableVectorType>(GEPEltType);\n  if (Value *V = SimplifyGEPInst(GEPEltType, Ops, SQ.getWithInstruction(&GEP)))\n    return replaceInstUsesWith(GEP, V);\n\n  // For vector geps, use the generic demanded vector support.\n  // Skip if GEP return type is scalable. The number of elements is unknown at\n  // compile-time.\n  if (auto *GEPFVTy = dyn_cast<FixedVectorType>(GEPType)) {\n    auto VWidth = GEPFVTy->getNumElements();\n    APInt UndefElts(VWidth, 0);\n    APInt AllOnesEltMask(APInt::getAllOnesValue(VWidth));\n    if (Value *V = SimplifyDemandedVectorElts(&GEP, AllOnesEltMask,\n                                              UndefElts)) {\n      if (V != &GEP)\n        return replaceInstUsesWith(GEP, V);\n      return &GEP;\n    }\n\n    // TODO: 1) Scalarize splat operands, 2) scalarize entire instruction if\n    // possible (decide on canonical form for pointer broadcast), 3) exploit\n    // undef elements to decrease demanded bits\n  }\n\n  Value *PtrOp = GEP.getOperand(0);\n\n  // Eliminate unneeded casts for indices, and replace indices which displace\n  // by multiples of a zero size type with zero.\n  bool MadeChange = false;\n\n  // Index width may not be the same width as pointer width.\n  // Data layout chooses the right type based on supported integer types.\n  Type *NewScalarIndexTy =\n      DL.getIndexType(GEP.getPointerOperandType()->getScalarType());\n\n  gep_type_iterator GTI = gep_type_begin(GEP);\n  for (User::op_iterator I = GEP.op_begin() + 1, E = GEP.op_end(); I != E;\n       ++I, ++GTI) {\n    // Skip indices into struct types.\n    if (GTI.isStruct())\n      continue;\n\n    Type *IndexTy = (*I)->getType();\n    Type *NewIndexType =\n        IndexTy->isVectorTy()\n            ? VectorType::get(NewScalarIndexTy,\n                              cast<VectorType>(IndexTy)->getElementCount())\n            : NewScalarIndexTy;\n\n    // If the element type has zero size then any index over it is equivalent\n    // to an index of zero, so replace it with zero if it is not zero already.\n    Type *EltTy = GTI.getIndexedType();\n    if (EltTy->isSized() && DL.getTypeAllocSize(EltTy).isZero())\n      if (!isa<Constant>(*I) || !match(I->get(), m_Zero())) {\n        *I = Constant::getNullValue(NewIndexType);\n        MadeChange = true;\n      }\n\n    if (IndexTy != NewIndexType) {\n      // If we are using a wider index than needed for this platform, shrink\n      // it to what we need.  If narrower, sign-extend it to what we need.\n      // This explicit cast can make subsequent optimizations more obvious.\n      *I = Builder.CreateIntCast(*I, NewIndexType, true);\n      MadeChange = true;\n    }\n  }\n  if (MadeChange)\n    return &GEP;\n\n  // Check to see if the inputs to the PHI node are getelementptr instructions.\n  if (auto *PN = dyn_cast<PHINode>(PtrOp)) {\n    auto *Op1 = dyn_cast<GetElementPtrInst>(PN->getOperand(0));\n    if (!Op1)\n      return nullptr;\n\n    // Don't fold a GEP into itself through a PHI node. This can only happen\n    // through the back-edge of a loop. Folding a GEP into itself means that\n    // the value of the previous iteration needs to be stored in the meantime,\n    // thus requiring an additional register variable to be live, but not\n    // actually achieving anything (the GEP still needs to be executed once per\n    // loop iteration).\n    if (Op1 == &GEP)\n      return nullptr;\n\n    int DI = -1;\n\n    for (auto I = PN->op_begin()+1, E = PN->op_end(); I !=E; ++I) {\n      auto *Op2 = dyn_cast<GetElementPtrInst>(*I);\n      if (!Op2 || Op1->getNumOperands() != Op2->getNumOperands())\n        return nullptr;\n\n      // As for Op1 above, don't try to fold a GEP into itself.\n      if (Op2 == &GEP)\n        return nullptr;\n\n      // Keep track of the type as we walk the GEP.\n      Type *CurTy = nullptr;\n\n      for (unsigned J = 0, F = Op1->getNumOperands(); J != F; ++J) {\n        if (Op1->getOperand(J)->getType() != Op2->getOperand(J)->getType())\n          return nullptr;\n\n        if (Op1->getOperand(J) != Op2->getOperand(J)) {\n          if (DI == -1) {\n            // We have not seen any differences yet in the GEPs feeding the\n            // PHI yet, so we record this one if it is allowed to be a\n            // variable.\n\n            // The first two arguments can vary for any GEP, the rest have to be\n            // static for struct slots\n            if (J > 1) {\n              assert(CurTy && \"No current type?\");\n              if (CurTy->isStructTy())\n                return nullptr;\n            }\n\n            DI = J;\n          } else {\n            // The GEP is different by more than one input. While this could be\n            // extended to support GEPs that vary by more than one variable it\n            // doesn't make sense since it greatly increases the complexity and\n            // would result in an R+R+R addressing mode which no backend\n            // directly supports and would need to be broken into several\n            // simpler instructions anyway.\n            return nullptr;\n          }\n        }\n\n        // Sink down a layer of the type for the next iteration.\n        if (J > 0) {\n          if (J == 1) {\n            CurTy = Op1->getSourceElementType();\n          } else {\n            CurTy =\n                GetElementPtrInst::getTypeAtIndex(CurTy, Op1->getOperand(J));\n          }\n        }\n      }\n    }\n\n    // If not all GEPs are identical we'll have to create a new PHI node.\n    // Check that the old PHI node has only one use so that it will get\n    // removed.\n    if (DI != -1 && !PN->hasOneUse())\n      return nullptr;\n\n    auto *NewGEP = cast<GetElementPtrInst>(Op1->clone());\n    if (DI == -1) {\n      // All the GEPs feeding the PHI are identical. Clone one down into our\n      // BB so that it can be merged with the current GEP.\n    } else {\n      // All the GEPs feeding the PHI differ at a single offset. Clone a GEP\n      // into the current block so it can be merged, and create a new PHI to\n      // set that index.\n      PHINode *NewPN;\n      {\n        IRBuilderBase::InsertPointGuard Guard(Builder);\n        Builder.SetInsertPoint(PN);\n        NewPN = Builder.CreatePHI(Op1->getOperand(DI)->getType(),\n                                  PN->getNumOperands());\n      }\n\n      for (auto &I : PN->operands())\n        NewPN->addIncoming(cast<GEPOperator>(I)->getOperand(DI),\n                           PN->getIncomingBlock(I));\n\n      NewGEP->setOperand(DI, NewPN);\n    }\n\n    GEP.getParent()->getInstList().insert(\n        GEP.getParent()->getFirstInsertionPt(), NewGEP);\n    replaceOperand(GEP, 0, NewGEP);\n    PtrOp = NewGEP;\n  }\n\n  // Combine Indices - If the source pointer to this getelementptr instruction\n  // is a getelementptr instruction, combine the indices of the two\n  // getelementptr instructions into a single instruction.\n  if (auto *Src = dyn_cast<GEPOperator>(PtrOp)) {\n    if (!shouldMergeGEPs(*cast<GEPOperator>(&GEP), *Src))\n      return nullptr;\n\n    // Try to reassociate loop invariant GEP chains to enable LICM.\n    if (LI && Src->getNumOperands() == 2 && GEP.getNumOperands() == 2 &&\n        Src->hasOneUse()) {\n      if (Loop *L = LI->getLoopFor(GEP.getParent())) {\n        Value *GO1 = GEP.getOperand(1);\n        Value *SO1 = Src->getOperand(1);\n        // Reassociate the two GEPs if SO1 is variant in the loop and GO1 is\n        // invariant: this breaks the dependence between GEPs and allows LICM\n        // to hoist the invariant part out of the loop.\n        if (L->isLoopInvariant(GO1) && !L->isLoopInvariant(SO1)) {\n          // We have to be careful here.\n          // We have something like:\n          //  %src = getelementptr <ty>, <ty>* %base, <ty> %idx\n          //  %gep = getelementptr <ty>, <ty>* %src, <ty> %idx2\n          // If we just swap idx & idx2 then we could inadvertantly\n          // change %src from a vector to a scalar, or vice versa.\n          // Cases:\n          //  1) %base a scalar & idx a scalar & idx2 a vector\n          //      => Swapping idx & idx2 turns %src into a vector type.\n          //  2) %base a scalar & idx a vector & idx2 a scalar\n          //      => Swapping idx & idx2 turns %src in a scalar type\n          //  3) %base, %idx, and %idx2 are scalars\n          //      => %src & %gep are scalars\n          //      => swapping idx & idx2 is safe\n          //  4) %base a vector\n          //      => %src is a vector\n          //      => swapping idx & idx2 is safe.\n          auto *SO0 = Src->getOperand(0);\n          auto *SO0Ty = SO0->getType();\n          if (!isa<VectorType>(GEPType) || // case 3\n              isa<VectorType>(SO0Ty)) {    // case 4\n            Src->setOperand(1, GO1);\n            GEP.setOperand(1, SO1);\n            return &GEP;\n          } else {\n            // Case 1 or 2\n            // -- have to recreate %src & %gep\n            // put NewSrc at same location as %src\n            Builder.SetInsertPoint(cast<Instruction>(PtrOp));\n            auto *NewSrc = cast<GetElementPtrInst>(\n                Builder.CreateGEP(GEPEltType, SO0, GO1, Src->getName()));\n            NewSrc->setIsInBounds(Src->isInBounds());\n            auto *NewGEP = GetElementPtrInst::Create(GEPEltType, NewSrc, {SO1});\n            NewGEP->setIsInBounds(GEP.isInBounds());\n            return NewGEP;\n          }\n        }\n      }\n    }\n\n    // Note that if our source is a gep chain itself then we wait for that\n    // chain to be resolved before we perform this transformation.  This\n    // avoids us creating a TON of code in some cases.\n    if (auto *SrcGEP = dyn_cast<GEPOperator>(Src->getOperand(0)))\n      if (SrcGEP->getNumOperands() == 2 && shouldMergeGEPs(*Src, *SrcGEP))\n        return nullptr;   // Wait until our source is folded to completion.\n\n    SmallVector<Value*, 8> Indices;\n\n    // Find out whether the last index in the source GEP is a sequential idx.\n    bool EndsWithSequential = false;\n    for (gep_type_iterator I = gep_type_begin(*Src), E = gep_type_end(*Src);\n         I != E; ++I)\n      EndsWithSequential = I.isSequential();\n\n    // Can we combine the two pointer arithmetics offsets?\n    if (EndsWithSequential) {\n      // Replace: gep (gep %P, long B), long A, ...\n      // With:    T = long A+B; gep %P, T, ...\n      Value *SO1 = Src->getOperand(Src->getNumOperands()-1);\n      Value *GO1 = GEP.getOperand(1);\n\n      // If they aren't the same type, then the input hasn't been processed\n      // by the loop above yet (which canonicalizes sequential index types to\n      // intptr_t).  Just avoid transforming this until the input has been\n      // normalized.\n      if (SO1->getType() != GO1->getType())\n        return nullptr;\n\n      Value *Sum =\n          SimplifyAddInst(GO1, SO1, false, false, SQ.getWithInstruction(&GEP));\n      // Only do the combine when we are sure the cost after the\n      // merge is never more than that before the merge.\n      if (Sum == nullptr)\n        return nullptr;\n\n      // Update the GEP in place if possible.\n      if (Src->getNumOperands() == 2) {\n        GEP.setIsInBounds(isMergedGEPInBounds(*Src, *cast<GEPOperator>(&GEP)));\n        replaceOperand(GEP, 0, Src->getOperand(0));\n        replaceOperand(GEP, 1, Sum);\n        return &GEP;\n      }\n      Indices.append(Src->op_begin()+1, Src->op_end()-1);\n      Indices.push_back(Sum);\n      Indices.append(GEP.op_begin()+2, GEP.op_end());\n    } else if (isa<Constant>(*GEP.idx_begin()) &&\n               cast<Constant>(*GEP.idx_begin())->isNullValue() &&\n               Src->getNumOperands() != 1) {\n      // Otherwise we can do the fold if the first index of the GEP is a zero\n      Indices.append(Src->op_begin()+1, Src->op_end());\n      Indices.append(GEP.idx_begin()+1, GEP.idx_end());\n    }\n\n    if (!Indices.empty())\n      return isMergedGEPInBounds(*Src, *cast<GEPOperator>(&GEP))\n                 ? GetElementPtrInst::CreateInBounds(\n                       Src->getSourceElementType(), Src->getOperand(0), Indices,\n                       GEP.getName())\n                 : GetElementPtrInst::Create(Src->getSourceElementType(),\n                                             Src->getOperand(0), Indices,\n                                             GEP.getName());\n  }\n\n  // Skip if GEP source element type is scalable. The type alloc size is unknown\n  // at compile-time.\n  if (GEP.getNumIndices() == 1 && !IsGEPSrcEleScalable) {\n    unsigned AS = GEP.getPointerAddressSpace();\n    if (GEP.getOperand(1)->getType()->getScalarSizeInBits() ==\n        DL.getIndexSizeInBits(AS)) {\n      uint64_t TyAllocSize = DL.getTypeAllocSize(GEPEltType).getFixedSize();\n\n      bool Matched = false;\n      uint64_t C;\n      Value *V = nullptr;\n      if (TyAllocSize == 1) {\n        V = GEP.getOperand(1);\n        Matched = true;\n      } else if (match(GEP.getOperand(1),\n                       m_AShr(m_Value(V), m_ConstantInt(C)))) {\n        if (TyAllocSize == 1ULL << C)\n          Matched = true;\n      } else if (match(GEP.getOperand(1),\n                       m_SDiv(m_Value(V), m_ConstantInt(C)))) {\n        if (TyAllocSize == C)\n          Matched = true;\n      }\n\n      if (Matched) {\n        // Canonicalize (gep i8* X, -(ptrtoint Y))\n        // to (inttoptr (sub (ptrtoint X), (ptrtoint Y)))\n        // The GEP pattern is emitted by the SCEV expander for certain kinds of\n        // pointer arithmetic.\n        if (match(V, m_Neg(m_PtrToInt(m_Value())))) {\n          Operator *Index = cast<Operator>(V);\n          Value *PtrToInt = Builder.CreatePtrToInt(PtrOp, Index->getType());\n          Value *NewSub = Builder.CreateSub(PtrToInt, Index->getOperand(1));\n          return CastInst::Create(Instruction::IntToPtr, NewSub, GEPType);\n        }\n        // Canonicalize (gep i8* X, (ptrtoint Y)-(ptrtoint X))\n        // to (bitcast Y)\n        Value *Y;\n        if (match(V, m_Sub(m_PtrToInt(m_Value(Y)),\n                           m_PtrToInt(m_Specific(GEP.getOperand(0))))))\n          return CastInst::CreatePointerBitCastOrAddrSpaceCast(Y, GEPType);\n      }\n    }\n  }\n\n  // We do not handle pointer-vector geps here.\n  if (GEPType->isVectorTy())\n    return nullptr;\n\n  // Handle gep(bitcast x) and gep(gep x, 0, 0, 0).\n  Value *StrippedPtr = PtrOp->stripPointerCasts();\n  PointerType *StrippedPtrTy = cast<PointerType>(StrippedPtr->getType());\n\n  if (StrippedPtr != PtrOp) {\n    bool HasZeroPointerIndex = false;\n    Type *StrippedPtrEltTy = StrippedPtrTy->getElementType();\n\n    if (auto *C = dyn_cast<ConstantInt>(GEP.getOperand(1)))\n      HasZeroPointerIndex = C->isZero();\n\n    // Transform: GEP (bitcast [10 x i8]* X to [0 x i8]*), i32 0, ...\n    // into     : GEP [10 x i8]* X, i32 0, ...\n    //\n    // Likewise, transform: GEP (bitcast i8* X to [0 x i8]*), i32 0, ...\n    //           into     : GEP i8* X, ...\n    //\n    // This occurs when the program declares an array extern like \"int X[];\"\n    if (HasZeroPointerIndex) {\n      if (auto *CATy = dyn_cast<ArrayType>(GEPEltType)) {\n        // GEP (bitcast i8* X to [0 x i8]*), i32 0, ... ?\n        if (CATy->getElementType() == StrippedPtrEltTy) {\n          // -> GEP i8* X, ...\n          SmallVector<Value *, 8> Idx(drop_begin(GEP.indices()));\n          GetElementPtrInst *Res = GetElementPtrInst::Create(\n              StrippedPtrEltTy, StrippedPtr, Idx, GEP.getName());\n          Res->setIsInBounds(GEP.isInBounds());\n          if (StrippedPtrTy->getAddressSpace() == GEP.getAddressSpace())\n            return Res;\n          // Insert Res, and create an addrspacecast.\n          // e.g.,\n          // GEP (addrspacecast i8 addrspace(1)* X to [0 x i8]*), i32 0, ...\n          // ->\n          // %0 = GEP i8 addrspace(1)* X, ...\n          // addrspacecast i8 addrspace(1)* %0 to i8*\n          return new AddrSpaceCastInst(Builder.Insert(Res), GEPType);\n        }\n\n        if (auto *XATy = dyn_cast<ArrayType>(StrippedPtrEltTy)) {\n          // GEP (bitcast [10 x i8]* X to [0 x i8]*), i32 0, ... ?\n          if (CATy->getElementType() == XATy->getElementType()) {\n            // -> GEP [10 x i8]* X, i32 0, ...\n            // At this point, we know that the cast source type is a pointer\n            // to an array of the same type as the destination pointer\n            // array.  Because the array type is never stepped over (there\n            // is a leading zero) we can fold the cast into this GEP.\n            if (StrippedPtrTy->getAddressSpace() == GEP.getAddressSpace()) {\n              GEP.setSourceElementType(XATy);\n              return replaceOperand(GEP, 0, StrippedPtr);\n            }\n            // Cannot replace the base pointer directly because StrippedPtr's\n            // address space is different. Instead, create a new GEP followed by\n            // an addrspacecast.\n            // e.g.,\n            // GEP (addrspacecast [10 x i8] addrspace(1)* X to [0 x i8]*),\n            //   i32 0, ...\n            // ->\n            // %0 = GEP [10 x i8] addrspace(1)* X, ...\n            // addrspacecast i8 addrspace(1)* %0 to i8*\n            SmallVector<Value *, 8> Idx(GEP.indices());\n            Value *NewGEP =\n                GEP.isInBounds()\n                    ? Builder.CreateInBoundsGEP(StrippedPtrEltTy, StrippedPtr,\n                                                Idx, GEP.getName())\n                    : Builder.CreateGEP(StrippedPtrEltTy, StrippedPtr, Idx,\n                                        GEP.getName());\n            return new AddrSpaceCastInst(NewGEP, GEPType);\n          }\n        }\n      }\n    } else if (GEP.getNumOperands() == 2 && !IsGEPSrcEleScalable) {\n      // Skip if GEP source element type is scalable. The type alloc size is\n      // unknown at compile-time.\n      // Transform things like: %t = getelementptr i32*\n      // bitcast ([2 x i32]* %str to i32*), i32 %V into:  %t1 = getelementptr [2\n      // x i32]* %str, i32 0, i32 %V; bitcast\n      if (StrippedPtrEltTy->isArrayTy() &&\n          DL.getTypeAllocSize(StrippedPtrEltTy->getArrayElementType()) ==\n              DL.getTypeAllocSize(GEPEltType)) {\n        Type *IdxType = DL.getIndexType(GEPType);\n        Value *Idx[2] = { Constant::getNullValue(IdxType), GEP.getOperand(1) };\n        Value *NewGEP =\n            GEP.isInBounds()\n                ? Builder.CreateInBoundsGEP(StrippedPtrEltTy, StrippedPtr, Idx,\n                                            GEP.getName())\n                : Builder.CreateGEP(StrippedPtrEltTy, StrippedPtr, Idx,\n                                    GEP.getName());\n\n        // V and GEP are both pointer types --> BitCast\n        return CastInst::CreatePointerBitCastOrAddrSpaceCast(NewGEP, GEPType);\n      }\n\n      // Transform things like:\n      // %V = mul i64 %N, 4\n      // %t = getelementptr i8* bitcast (i32* %arr to i8*), i32 %V\n      // into:  %t1 = getelementptr i32* %arr, i32 %N; bitcast\n      if (GEPEltType->isSized() && StrippedPtrEltTy->isSized()) {\n        // Check that changing the type amounts to dividing the index by a scale\n        // factor.\n        uint64_t ResSize = DL.getTypeAllocSize(GEPEltType).getFixedSize();\n        uint64_t SrcSize = DL.getTypeAllocSize(StrippedPtrEltTy).getFixedSize();\n        if (ResSize && SrcSize % ResSize == 0) {\n          Value *Idx = GEP.getOperand(1);\n          unsigned BitWidth = Idx->getType()->getPrimitiveSizeInBits();\n          uint64_t Scale = SrcSize / ResSize;\n\n          // Earlier transforms ensure that the index has the right type\n          // according to Data Layout, which considerably simplifies the\n          // logic by eliminating implicit casts.\n          assert(Idx->getType() == DL.getIndexType(GEPType) &&\n                 \"Index type does not match the Data Layout preferences\");\n\n          bool NSW;\n          if (Value *NewIdx = Descale(Idx, APInt(BitWidth, Scale), NSW)) {\n            // Successfully decomposed Idx as NewIdx * Scale, form a new GEP.\n            // If the multiplication NewIdx * Scale may overflow then the new\n            // GEP may not be \"inbounds\".\n            Value *NewGEP =\n                GEP.isInBounds() && NSW\n                    ? Builder.CreateInBoundsGEP(StrippedPtrEltTy, StrippedPtr,\n                                                NewIdx, GEP.getName())\n                    : Builder.CreateGEP(StrippedPtrEltTy, StrippedPtr, NewIdx,\n                                        GEP.getName());\n\n            // The NewGEP must be pointer typed, so must the old one -> BitCast\n            return CastInst::CreatePointerBitCastOrAddrSpaceCast(NewGEP,\n                                                                 GEPType);\n          }\n        }\n      }\n\n      // Similarly, transform things like:\n      // getelementptr i8* bitcast ([100 x double]* X to i8*), i32 %tmp\n      //   (where tmp = 8*tmp2) into:\n      // getelementptr [100 x double]* %arr, i32 0, i32 %tmp2; bitcast\n      if (GEPEltType->isSized() && StrippedPtrEltTy->isSized() &&\n          StrippedPtrEltTy->isArrayTy()) {\n        // Check that changing to the array element type amounts to dividing the\n        // index by a scale factor.\n        uint64_t ResSize = DL.getTypeAllocSize(GEPEltType).getFixedSize();\n        uint64_t ArrayEltSize =\n            DL.getTypeAllocSize(StrippedPtrEltTy->getArrayElementType())\n                .getFixedSize();\n        if (ResSize && ArrayEltSize % ResSize == 0) {\n          Value *Idx = GEP.getOperand(1);\n          unsigned BitWidth = Idx->getType()->getPrimitiveSizeInBits();\n          uint64_t Scale = ArrayEltSize / ResSize;\n\n          // Earlier transforms ensure that the index has the right type\n          // according to the Data Layout, which considerably simplifies\n          // the logic by eliminating implicit casts.\n          assert(Idx->getType() == DL.getIndexType(GEPType) &&\n                 \"Index type does not match the Data Layout preferences\");\n\n          bool NSW;\n          if (Value *NewIdx = Descale(Idx, APInt(BitWidth, Scale), NSW)) {\n            // Successfully decomposed Idx as NewIdx * Scale, form a new GEP.\n            // If the multiplication NewIdx * Scale may overflow then the new\n            // GEP may not be \"inbounds\".\n            Type *IndTy = DL.getIndexType(GEPType);\n            Value *Off[2] = {Constant::getNullValue(IndTy), NewIdx};\n\n            Value *NewGEP =\n                GEP.isInBounds() && NSW\n                    ? Builder.CreateInBoundsGEP(StrippedPtrEltTy, StrippedPtr,\n                                                Off, GEP.getName())\n                    : Builder.CreateGEP(StrippedPtrEltTy, StrippedPtr, Off,\n                                        GEP.getName());\n            // The NewGEP must be pointer typed, so must the old one -> BitCast\n            return CastInst::CreatePointerBitCastOrAddrSpaceCast(NewGEP,\n                                                                 GEPType);\n          }\n        }\n      }\n    }\n  }\n\n  // addrspacecast between types is canonicalized as a bitcast, then an\n  // addrspacecast. To take advantage of the below bitcast + struct GEP, look\n  // through the addrspacecast.\n  Value *ASCStrippedPtrOp = PtrOp;\n  if (auto *ASC = dyn_cast<AddrSpaceCastInst>(PtrOp)) {\n    //   X = bitcast A addrspace(1)* to B addrspace(1)*\n    //   Y = addrspacecast A addrspace(1)* to B addrspace(2)*\n    //   Z = gep Y, <...constant indices...>\n    // Into an addrspacecasted GEP of the struct.\n    if (auto *BC = dyn_cast<BitCastInst>(ASC->getOperand(0)))\n      ASCStrippedPtrOp = BC;\n  }\n\n  if (auto *BCI = dyn_cast<BitCastInst>(ASCStrippedPtrOp)) {\n    Value *SrcOp = BCI->getOperand(0);\n    PointerType *SrcType = cast<PointerType>(BCI->getSrcTy());\n    Type *SrcEltType = SrcType->getElementType();\n\n    // GEP directly using the source operand if this GEP is accessing an element\n    // of a bitcasted pointer to vector or array of the same dimensions:\n    // gep (bitcast <c x ty>* X to [c x ty]*), Y, Z --> gep X, Y, Z\n    // gep (bitcast [c x ty]* X to <c x ty>*), Y, Z --> gep X, Y, Z\n    auto areMatchingArrayAndVecTypes = [](Type *ArrTy, Type *VecTy,\n                                          const DataLayout &DL) {\n      auto *VecVTy = cast<FixedVectorType>(VecTy);\n      return ArrTy->getArrayElementType() == VecVTy->getElementType() &&\n             ArrTy->getArrayNumElements() == VecVTy->getNumElements() &&\n             DL.getTypeAllocSize(ArrTy) == DL.getTypeAllocSize(VecTy);\n    };\n    if (GEP.getNumOperands() == 3 &&\n        ((GEPEltType->isArrayTy() && isa<FixedVectorType>(SrcEltType) &&\n          areMatchingArrayAndVecTypes(GEPEltType, SrcEltType, DL)) ||\n         (isa<FixedVectorType>(GEPEltType) && SrcEltType->isArrayTy() &&\n          areMatchingArrayAndVecTypes(SrcEltType, GEPEltType, DL)))) {\n\n      // Create a new GEP here, as using `setOperand()` followed by\n      // `setSourceElementType()` won't actually update the type of the\n      // existing GEP Value. Causing issues if this Value is accessed when\n      // constructing an AddrSpaceCastInst\n      Value *NGEP =\n          GEP.isInBounds()\n              ? Builder.CreateInBoundsGEP(SrcEltType, SrcOp, {Ops[1], Ops[2]})\n              : Builder.CreateGEP(SrcEltType, SrcOp, {Ops[1], Ops[2]});\n      NGEP->takeName(&GEP);\n\n      // Preserve GEP address space to satisfy users\n      if (NGEP->getType()->getPointerAddressSpace() != GEP.getAddressSpace())\n        return new AddrSpaceCastInst(NGEP, GEPType);\n\n      return replaceInstUsesWith(GEP, NGEP);\n    }\n\n    // See if we can simplify:\n    //   X = bitcast A* to B*\n    //   Y = gep X, <...constant indices...>\n    // into a gep of the original struct. This is important for SROA and alias\n    // analysis of unions. If \"A\" is also a bitcast, wait for A/X to be merged.\n    unsigned OffsetBits = DL.getIndexTypeSizeInBits(GEPType);\n    APInt Offset(OffsetBits, 0);\n    if (!isa<BitCastInst>(SrcOp) && GEP.accumulateConstantOffset(DL, Offset)) {\n      // If this GEP instruction doesn't move the pointer, just replace the GEP\n      // with a bitcast of the real input to the dest type.\n      if (!Offset) {\n        // If the bitcast is of an allocation, and the allocation will be\n        // converted to match the type of the cast, don't touch this.\n        if (isa<AllocaInst>(SrcOp) || isAllocationFn(SrcOp, &TLI)) {\n          // See if the bitcast simplifies, if so, don't nuke this GEP yet.\n          if (Instruction *I = visitBitCast(*BCI)) {\n            if (I != BCI) {\n              I->takeName(BCI);\n              BCI->getParent()->getInstList().insert(BCI->getIterator(), I);\n              replaceInstUsesWith(*BCI, I);\n            }\n            return &GEP;\n          }\n        }\n\n        if (SrcType->getPointerAddressSpace() != GEP.getAddressSpace())\n          return new AddrSpaceCastInst(SrcOp, GEPType);\n        return new BitCastInst(SrcOp, GEPType);\n      }\n\n      // Otherwise, if the offset is non-zero, we need to find out if there is a\n      // field at Offset in 'A's type.  If so, we can pull the cast through the\n      // GEP.\n      SmallVector<Value*, 8> NewIndices;\n      if (FindElementAtOffset(SrcType, Offset.getSExtValue(), NewIndices)) {\n        Value *NGEP =\n            GEP.isInBounds()\n                ? Builder.CreateInBoundsGEP(SrcEltType, SrcOp, NewIndices)\n                : Builder.CreateGEP(SrcEltType, SrcOp, NewIndices);\n\n        if (NGEP->getType() == GEPType)\n          return replaceInstUsesWith(GEP, NGEP);\n        NGEP->takeName(&GEP);\n\n        if (NGEP->getType()->getPointerAddressSpace() != GEP.getAddressSpace())\n          return new AddrSpaceCastInst(NGEP, GEPType);\n        return new BitCastInst(NGEP, GEPType);\n      }\n    }\n  }\n\n  if (!GEP.isInBounds()) {\n    unsigned IdxWidth =\n        DL.getIndexSizeInBits(PtrOp->getType()->getPointerAddressSpace());\n    APInt BasePtrOffset(IdxWidth, 0);\n    Value *UnderlyingPtrOp =\n            PtrOp->stripAndAccumulateInBoundsConstantOffsets(DL,\n                                                             BasePtrOffset);\n    if (auto *AI = dyn_cast<AllocaInst>(UnderlyingPtrOp)) {\n      if (GEP.accumulateConstantOffset(DL, BasePtrOffset) &&\n          BasePtrOffset.isNonNegative()) {\n        APInt AllocSize(\n            IdxWidth,\n            DL.getTypeAllocSize(AI->getAllocatedType()).getKnownMinSize());\n        if (BasePtrOffset.ule(AllocSize)) {\n          return GetElementPtrInst::CreateInBounds(\n              GEP.getSourceElementType(), PtrOp, makeArrayRef(Ops).slice(1),\n              GEP.getName());\n        }\n      }\n    }\n  }\n\n  if (Instruction *R = foldSelectGEP(GEP, Builder))\n    return R;\n\n  return nullptr;\n}\n\nstatic bool isNeverEqualToUnescapedAlloc(Value *V, const TargetLibraryInfo *TLI,\n                                         Instruction *AI) {\n  if (isa<ConstantPointerNull>(V))\n    return true;\n  if (auto *LI = dyn_cast<LoadInst>(V))\n    return isa<GlobalVariable>(LI->getPointerOperand());\n  // Two distinct allocations will never be equal.\n  // We rely on LookThroughBitCast in isAllocLikeFn being false, since looking\n  // through bitcasts of V can cause\n  // the result statement below to be true, even when AI and V (ex:\n  // i8* ->i32* ->i8* of AI) are the same allocations.\n  return isAllocLikeFn(V, TLI) && V != AI;\n}\n\nstatic bool isAllocSiteRemovable(Instruction *AI,\n                                 SmallVectorImpl<WeakTrackingVH> &Users,\n                                 const TargetLibraryInfo *TLI) {\n  SmallVector<Instruction*, 4> Worklist;\n  Worklist.push_back(AI);\n\n  do {\n    Instruction *PI = Worklist.pop_back_val();\n    for (User *U : PI->users()) {\n      Instruction *I = cast<Instruction>(U);\n      switch (I->getOpcode()) {\n      default:\n        // Give up the moment we see something we can't handle.\n        return false;\n\n      case Instruction::AddrSpaceCast:\n      case Instruction::BitCast:\n      case Instruction::GetElementPtr:\n        Users.emplace_back(I);\n        Worklist.push_back(I);\n        continue;\n\n      case Instruction::ICmp: {\n        ICmpInst *ICI = cast<ICmpInst>(I);\n        // We can fold eq/ne comparisons with null to false/true, respectively.\n        // We also fold comparisons in some conditions provided the alloc has\n        // not escaped (see isNeverEqualToUnescapedAlloc).\n        if (!ICI->isEquality())\n          return false;\n        unsigned OtherIndex = (ICI->getOperand(0) == PI) ? 1 : 0;\n        if (!isNeverEqualToUnescapedAlloc(ICI->getOperand(OtherIndex), TLI, AI))\n          return false;\n        Users.emplace_back(I);\n        continue;\n      }\n\n      case Instruction::Call:\n        // Ignore no-op and store intrinsics.\n        if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(I)) {\n          switch (II->getIntrinsicID()) {\n          default:\n            return false;\n\n          case Intrinsic::memmove:\n          case Intrinsic::memcpy:\n          case Intrinsic::memset: {\n            MemIntrinsic *MI = cast<MemIntrinsic>(II);\n            if (MI->isVolatile() || MI->getRawDest() != PI)\n              return false;\n            LLVM_FALLTHROUGH;\n          }\n          case Intrinsic::assume:\n          case Intrinsic::invariant_start:\n          case Intrinsic::invariant_end:\n          case Intrinsic::lifetime_start:\n          case Intrinsic::lifetime_end:\n          case Intrinsic::objectsize:\n            Users.emplace_back(I);\n            continue;\n          }\n        }\n\n        if (isFreeCall(I, TLI)) {\n          Users.emplace_back(I);\n          continue;\n        }\n        return false;\n\n      case Instruction::Store: {\n        StoreInst *SI = cast<StoreInst>(I);\n        if (SI->isVolatile() || SI->getPointerOperand() != PI)\n          return false;\n        Users.emplace_back(I);\n        continue;\n      }\n      }\n      llvm_unreachable(\"missing a return?\");\n    }\n  } while (!Worklist.empty());\n  return true;\n}\n\nInstruction *InstCombinerImpl::visitAllocSite(Instruction &MI) {\n  // If we have a malloc call which is only used in any amount of comparisons to\n  // null and free calls, delete the calls and replace the comparisons with true\n  // or false as appropriate.\n\n  // This is based on the principle that we can substitute our own allocation\n  // function (which will never return null) rather than knowledge of the\n  // specific function being called. In some sense this can change the permitted\n  // outputs of a program (when we convert a malloc to an alloca, the fact that\n  // the allocation is now on the stack is potentially visible, for example),\n  // but we believe in a permissible manner.\n  SmallVector<WeakTrackingVH, 64> Users;\n\n  // If we are removing an alloca with a dbg.declare, insert dbg.value calls\n  // before each store.\n  SmallVector<DbgVariableIntrinsic *, 8> DVIs;\n  std::unique_ptr<DIBuilder> DIB;\n  if (isa<AllocaInst>(MI)) {\n    findDbgUsers(DVIs, &MI);\n    DIB.reset(new DIBuilder(*MI.getModule(), /*AllowUnresolved=*/false));\n  }\n\n  if (isAllocSiteRemovable(&MI, Users, &TLI)) {\n    for (unsigned i = 0, e = Users.size(); i != e; ++i) {\n      // Lowering all @llvm.objectsize calls first because they may\n      // use a bitcast/GEP of the alloca we are removing.\n      if (!Users[i])\n       continue;\n\n      Instruction *I = cast<Instruction>(&*Users[i]);\n\n      if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(I)) {\n        if (II->getIntrinsicID() == Intrinsic::objectsize) {\n          Value *Result =\n              lowerObjectSizeCall(II, DL, &TLI, /*MustSucceed=*/true);\n          replaceInstUsesWith(*I, Result);\n          eraseInstFromFunction(*I);\n          Users[i] = nullptr; // Skip examining in the next loop.\n        }\n      }\n    }\n    for (unsigned i = 0, e = Users.size(); i != e; ++i) {\n      if (!Users[i])\n        continue;\n\n      Instruction *I = cast<Instruction>(&*Users[i]);\n\n      if (ICmpInst *C = dyn_cast<ICmpInst>(I)) {\n        replaceInstUsesWith(*C,\n                            ConstantInt::get(Type::getInt1Ty(C->getContext()),\n                                             C->isFalseWhenEqual()));\n      } else if (auto *SI = dyn_cast<StoreInst>(I)) {\n        for (auto *DVI : DVIs)\n          if (DVI->isAddressOfVariable())\n            ConvertDebugDeclareToDebugValue(DVI, SI, *DIB);\n      } else {\n        // Casts, GEP, or anything else: we're about to delete this instruction,\n        // so it can not have any valid uses.\n        replaceInstUsesWith(*I, UndefValue::get(I->getType()));\n      }\n      eraseInstFromFunction(*I);\n    }\n\n    if (InvokeInst *II = dyn_cast<InvokeInst>(&MI)) {\n      // Replace invoke with a NOP intrinsic to maintain the original CFG\n      Module *M = II->getModule();\n      Function *F = Intrinsic::getDeclaration(M, Intrinsic::donothing);\n      InvokeInst::Create(F, II->getNormalDest(), II->getUnwindDest(),\n                         None, \"\", II->getParent());\n    }\n\n    // Remove debug intrinsics which describe the value contained within the\n    // alloca. In addition to removing dbg.{declare,addr} which simply point to\n    // the alloca, remove dbg.value(<alloca>, ..., DW_OP_deref)'s as well, e.g.:\n    //\n    // ```\n    //   define void @foo(i32 %0) {\n    //     %a = alloca i32                              ; Deleted.\n    //     store i32 %0, i32* %a\n    //     dbg.value(i32 %0, \"arg0\")                    ; Not deleted.\n    //     dbg.value(i32* %a, \"arg0\", DW_OP_deref)      ; Deleted.\n    //     call void @trivially_inlinable_no_op(i32* %a)\n    //     ret void\n    //  }\n    // ```\n    //\n    // This may not be required if we stop describing the contents of allocas\n    // using dbg.value(<alloca>, ..., DW_OP_deref), but we currently do this in\n    // the LowerDbgDeclare utility.\n    //\n    // If there is a dead store to `%a` in @trivially_inlinable_no_op, the\n    // \"arg0\" dbg.value may be stale after the call. However, failing to remove\n    // the DW_OP_deref dbg.value causes large gaps in location coverage.\n    for (auto *DVI : DVIs)\n      if (DVI->isAddressOfVariable() || DVI->getExpression()->startsWithDeref())\n        DVI->eraseFromParent();\n\n    return eraseInstFromFunction(MI);\n  }\n  return nullptr;\n}\n\n/// Move the call to free before a NULL test.\n///\n/// Check if this free is accessed after its argument has been test\n/// against NULL (property 0).\n/// If yes, it is legal to move this call in its predecessor block.\n///\n/// The move is performed only if the block containing the call to free\n/// will be removed, i.e.:\n/// 1. it has only one predecessor P, and P has two successors\n/// 2. it contains the call, noops, and an unconditional branch\n/// 3. its successor is the same as its predecessor's successor\n///\n/// The profitability is out-of concern here and this function should\n/// be called only if the caller knows this transformation would be\n/// profitable (e.g., for code size).\nstatic Instruction *tryToMoveFreeBeforeNullTest(CallInst &FI,\n                                                const DataLayout &DL) {\n  Value *Op = FI.getArgOperand(0);\n  BasicBlock *FreeInstrBB = FI.getParent();\n  BasicBlock *PredBB = FreeInstrBB->getSinglePredecessor();\n\n  // Validate part of constraint #1: Only one predecessor\n  // FIXME: We can extend the number of predecessor, but in that case, we\n  //        would duplicate the call to free in each predecessor and it may\n  //        not be profitable even for code size.\n  if (!PredBB)\n    return nullptr;\n\n  // Validate constraint #2: Does this block contains only the call to\n  //                         free, noops, and an unconditional branch?\n  BasicBlock *SuccBB;\n  Instruction *FreeInstrBBTerminator = FreeInstrBB->getTerminator();\n  if (!match(FreeInstrBBTerminator, m_UnconditionalBr(SuccBB)))\n    return nullptr;\n\n  // If there are only 2 instructions in the block, at this point,\n  // this is the call to free and unconditional.\n  // If there are more than 2 instructions, check that they are noops\n  // i.e., they won't hurt the performance of the generated code.\n  if (FreeInstrBB->size() != 2) {\n    for (const Instruction &Inst : FreeInstrBB->instructionsWithoutDebug()) {\n      if (&Inst == &FI || &Inst == FreeInstrBBTerminator)\n        continue;\n      auto *Cast = dyn_cast<CastInst>(&Inst);\n      if (!Cast || !Cast->isNoopCast(DL))\n        return nullptr;\n    }\n  }\n  // Validate the rest of constraint #1 by matching on the pred branch.\n  Instruction *TI = PredBB->getTerminator();\n  BasicBlock *TrueBB, *FalseBB;\n  ICmpInst::Predicate Pred;\n  if (!match(TI, m_Br(m_ICmp(Pred,\n                             m_CombineOr(m_Specific(Op),\n                                         m_Specific(Op->stripPointerCasts())),\n                             m_Zero()),\n                      TrueBB, FalseBB)))\n    return nullptr;\n  if (Pred != ICmpInst::ICMP_EQ && Pred != ICmpInst::ICMP_NE)\n    return nullptr;\n\n  // Validate constraint #3: Ensure the null case just falls through.\n  if (SuccBB != (Pred == ICmpInst::ICMP_EQ ? TrueBB : FalseBB))\n    return nullptr;\n  assert(FreeInstrBB == (Pred == ICmpInst::ICMP_EQ ? FalseBB : TrueBB) &&\n         \"Broken CFG: missing edge from predecessor to successor\");\n\n  // At this point, we know that everything in FreeInstrBB can be moved\n  // before TI.\n  for (BasicBlock::iterator It = FreeInstrBB->begin(), End = FreeInstrBB->end();\n       It != End;) {\n    Instruction &Instr = *It++;\n    if (&Instr == FreeInstrBBTerminator)\n      break;\n    Instr.moveBefore(TI);\n  }\n  assert(FreeInstrBB->size() == 1 &&\n         \"Only the branch instruction should remain\");\n  return &FI;\n}\n\nInstruction *InstCombinerImpl::visitFree(CallInst &FI) {\n  Value *Op = FI.getArgOperand(0);\n\n  // free undef -> unreachable.\n  if (isa<UndefValue>(Op)) {\n    // Leave a marker since we can't modify the CFG here.\n    CreateNonTerminatorUnreachable(&FI);\n    return eraseInstFromFunction(FI);\n  }\n\n  // If we have 'free null' delete the instruction.  This can happen in stl code\n  // when lots of inlining happens.\n  if (isa<ConstantPointerNull>(Op))\n    return eraseInstFromFunction(FI);\n\n  // If we optimize for code size, try to move the call to free before the null\n  // test so that simplify cfg can remove the empty block and dead code\n  // elimination the branch. I.e., helps to turn something like:\n  // if (foo) free(foo);\n  // into\n  // free(foo);\n  //\n  // Note that we can only do this for 'free' and not for any flavor of\n  // 'operator delete'; there is no 'operator delete' symbol for which we are\n  // permitted to invent a call, even if we're passing in a null pointer.\n  if (MinimizeSize) {\n    LibFunc Func;\n    if (TLI.getLibFunc(FI, Func) && TLI.has(Func) && Func == LibFunc_free)\n      if (Instruction *I = tryToMoveFreeBeforeNullTest(FI, DL))\n        return I;\n  }\n\n  return nullptr;\n}\n\nstatic bool isMustTailCall(Value *V) {\n  if (auto *CI = dyn_cast<CallInst>(V))\n    return CI->isMustTailCall();\n  return false;\n}\n\nInstruction *InstCombinerImpl::visitReturnInst(ReturnInst &RI) {\n  if (RI.getNumOperands() == 0) // ret void\n    return nullptr;\n\n  Value *ResultOp = RI.getOperand(0);\n  Type *VTy = ResultOp->getType();\n  if (!VTy->isIntegerTy() || isa<Constant>(ResultOp))\n    return nullptr;\n\n  // Don't replace result of musttail calls.\n  if (isMustTailCall(ResultOp))\n    return nullptr;\n\n  // There might be assume intrinsics dominating this return that completely\n  // determine the value. If so, constant fold it.\n  KnownBits Known = computeKnownBits(ResultOp, 0, &RI);\n  if (Known.isConstant())\n    return replaceOperand(RI, 0,\n        Constant::getIntegerValue(VTy, Known.getConstant()));\n\n  return nullptr;\n}\n\nInstruction *InstCombinerImpl::visitUnreachableInst(UnreachableInst &I) {\n  // Try to remove the previous instruction if it must lead to unreachable.\n  // This includes instructions like stores and \"llvm.assume\" that may not get\n  // removed by simple dead code elimination.\n  Instruction *Prev = I.getPrevNonDebugInstruction();\n  if (Prev && !Prev->isEHPad() &&\n      isGuaranteedToTransferExecutionToSuccessor(Prev)) {\n    // Temporarily disable removal of volatile stores preceding unreachable,\n    // pending a potential LangRef change permitting volatile stores to trap.\n    // TODO: Either remove this code, or properly integrate the check into\n    // isGuaranteedToTransferExecutionToSuccessor().\n    if (auto *SI = dyn_cast<StoreInst>(Prev))\n      if (SI->isVolatile())\n        return nullptr;\n\n    // A value may still have uses before we process it here (for example, in\n    // another unreachable block), so convert those to undef.\n    replaceInstUsesWith(*Prev, UndefValue::get(Prev->getType()));\n    eraseInstFromFunction(*Prev);\n    return &I;\n  }\n  return nullptr;\n}\n\nInstruction *InstCombinerImpl::visitUnconditionalBranchInst(BranchInst &BI) {\n  assert(BI.isUnconditional() && \"Only for unconditional branches.\");\n\n  // If this store is the second-to-last instruction in the basic block\n  // (excluding debug info and bitcasts of pointers) and if the block ends with\n  // an unconditional branch, try to move the store to the successor block.\n\n  auto GetLastSinkableStore = [](BasicBlock::iterator BBI) {\n    auto IsNoopInstrForStoreMerging = [](BasicBlock::iterator BBI) {\n      return isa<DbgInfoIntrinsic>(BBI) ||\n             (isa<BitCastInst>(BBI) && BBI->getType()->isPointerTy());\n    };\n\n    BasicBlock::iterator FirstInstr = BBI->getParent()->begin();\n    do {\n      if (BBI != FirstInstr)\n        --BBI;\n    } while (BBI != FirstInstr && IsNoopInstrForStoreMerging(BBI));\n\n    return dyn_cast<StoreInst>(BBI);\n  };\n\n  if (StoreInst *SI = GetLastSinkableStore(BasicBlock::iterator(BI)))\n    if (mergeStoreIntoSuccessor(*SI))\n      return &BI;\n\n  return nullptr;\n}\n\nInstruction *InstCombinerImpl::visitBranchInst(BranchInst &BI) {\n  if (BI.isUnconditional())\n    return visitUnconditionalBranchInst(BI);\n\n  // Change br (not X), label True, label False to: br X, label False, True\n  Value *X = nullptr;\n  if (match(&BI, m_Br(m_Not(m_Value(X)), m_BasicBlock(), m_BasicBlock())) &&\n      !isa<Constant>(X)) {\n    // Swap Destinations and condition...\n    BI.swapSuccessors();\n    return replaceOperand(BI, 0, X);\n  }\n\n  // If the condition is irrelevant, remove the use so that other\n  // transforms on the condition become more effective.\n  if (!isa<ConstantInt>(BI.getCondition()) &&\n      BI.getSuccessor(0) == BI.getSuccessor(1))\n    return replaceOperand(\n        BI, 0, ConstantInt::getFalse(BI.getCondition()->getType()));\n\n  // Canonicalize, for example, fcmp_one -> fcmp_oeq.\n  CmpInst::Predicate Pred;\n  if (match(&BI, m_Br(m_OneUse(m_FCmp(Pred, m_Value(), m_Value())),\n                      m_BasicBlock(), m_BasicBlock())) &&\n      !isCanonicalPredicate(Pred)) {\n    // Swap destinations and condition.\n    CmpInst *Cond = cast<CmpInst>(BI.getCondition());\n    Cond->setPredicate(CmpInst::getInversePredicate(Pred));\n    BI.swapSuccessors();\n    Worklist.push(Cond);\n    return &BI;\n  }\n\n  return nullptr;\n}\n\nInstruction *InstCombinerImpl::visitSwitchInst(SwitchInst &SI) {\n  Value *Cond = SI.getCondition();\n  Value *Op0;\n  ConstantInt *AddRHS;\n  if (match(Cond, m_Add(m_Value(Op0), m_ConstantInt(AddRHS)))) {\n    // Change 'switch (X+4) case 1:' into 'switch (X) case -3'.\n    for (auto Case : SI.cases()) {\n      Constant *NewCase = ConstantExpr::getSub(Case.getCaseValue(), AddRHS);\n      assert(isa<ConstantInt>(NewCase) &&\n             \"Result of expression should be constant\");\n      Case.setValue(cast<ConstantInt>(NewCase));\n    }\n    return replaceOperand(SI, 0, Op0);\n  }\n\n  KnownBits Known = computeKnownBits(Cond, 0, &SI);\n  unsigned LeadingKnownZeros = Known.countMinLeadingZeros();\n  unsigned LeadingKnownOnes = Known.countMinLeadingOnes();\n\n  // Compute the number of leading bits we can ignore.\n  // TODO: A better way to determine this would use ComputeNumSignBits().\n  for (auto &C : SI.cases()) {\n    LeadingKnownZeros = std::min(\n        LeadingKnownZeros, C.getCaseValue()->getValue().countLeadingZeros());\n    LeadingKnownOnes = std::min(\n        LeadingKnownOnes, C.getCaseValue()->getValue().countLeadingOnes());\n  }\n\n  unsigned NewWidth = Known.getBitWidth() - std::max(LeadingKnownZeros, LeadingKnownOnes);\n\n  // Shrink the condition operand if the new type is smaller than the old type.\n  // But do not shrink to a non-standard type, because backend can't generate\n  // good code for that yet.\n  // TODO: We can make it aggressive again after fixing PR39569.\n  if (NewWidth > 0 && NewWidth < Known.getBitWidth() &&\n      shouldChangeType(Known.getBitWidth(), NewWidth)) {\n    IntegerType *Ty = IntegerType::get(SI.getContext(), NewWidth);\n    Builder.SetInsertPoint(&SI);\n    Value *NewCond = Builder.CreateTrunc(Cond, Ty, \"trunc\");\n\n    for (auto Case : SI.cases()) {\n      APInt TruncatedCase = Case.getCaseValue()->getValue().trunc(NewWidth);\n      Case.setValue(ConstantInt::get(SI.getContext(), TruncatedCase));\n    }\n    return replaceOperand(SI, 0, NewCond);\n  }\n\n  return nullptr;\n}\n\nInstruction *InstCombinerImpl::visitExtractValueInst(ExtractValueInst &EV) {\n  Value *Agg = EV.getAggregateOperand();\n\n  if (!EV.hasIndices())\n    return replaceInstUsesWith(EV, Agg);\n\n  if (Value *V = SimplifyExtractValueInst(Agg, EV.getIndices(),\n                                          SQ.getWithInstruction(&EV)))\n    return replaceInstUsesWith(EV, V);\n\n  if (InsertValueInst *IV = dyn_cast<InsertValueInst>(Agg)) {\n    // We're extracting from an insertvalue instruction, compare the indices\n    const unsigned *exti, *exte, *insi, *inse;\n    for (exti = EV.idx_begin(), insi = IV->idx_begin(),\n         exte = EV.idx_end(), inse = IV->idx_end();\n         exti != exte && insi != inse;\n         ++exti, ++insi) {\n      if (*insi != *exti)\n        // The insert and extract both reference distinctly different elements.\n        // This means the extract is not influenced by the insert, and we can\n        // replace the aggregate operand of the extract with the aggregate\n        // operand of the insert. i.e., replace\n        // %I = insertvalue { i32, { i32 } } %A, { i32 } { i32 42 }, 1\n        // %E = extractvalue { i32, { i32 } } %I, 0\n        // with\n        // %E = extractvalue { i32, { i32 } } %A, 0\n        return ExtractValueInst::Create(IV->getAggregateOperand(),\n                                        EV.getIndices());\n    }\n    if (exti == exte && insi == inse)\n      // Both iterators are at the end: Index lists are identical. Replace\n      // %B = insertvalue { i32, { i32 } } %A, i32 42, 1, 0\n      // %C = extractvalue { i32, { i32 } } %B, 1, 0\n      // with \"i32 42\"\n      return replaceInstUsesWith(EV, IV->getInsertedValueOperand());\n    if (exti == exte) {\n      // The extract list is a prefix of the insert list. i.e. replace\n      // %I = insertvalue { i32, { i32 } } %A, i32 42, 1, 0\n      // %E = extractvalue { i32, { i32 } } %I, 1\n      // with\n      // %X = extractvalue { i32, { i32 } } %A, 1\n      // %E = insertvalue { i32 } %X, i32 42, 0\n      // by switching the order of the insert and extract (though the\n      // insertvalue should be left in, since it may have other uses).\n      Value *NewEV = Builder.CreateExtractValue(IV->getAggregateOperand(),\n                                                EV.getIndices());\n      return InsertValueInst::Create(NewEV, IV->getInsertedValueOperand(),\n                                     makeArrayRef(insi, inse));\n    }\n    if (insi == inse)\n      // The insert list is a prefix of the extract list\n      // We can simply remove the common indices from the extract and make it\n      // operate on the inserted value instead of the insertvalue result.\n      // i.e., replace\n      // %I = insertvalue { i32, { i32 } } %A, { i32 } { i32 42 }, 1\n      // %E = extractvalue { i32, { i32 } } %I, 1, 0\n      // with\n      // %E extractvalue { i32 } { i32 42 }, 0\n      return ExtractValueInst::Create(IV->getInsertedValueOperand(),\n                                      makeArrayRef(exti, exte));\n  }\n  if (WithOverflowInst *WO = dyn_cast<WithOverflowInst>(Agg)) {\n    // We're extracting from an overflow intrinsic, see if we're the only user,\n    // which allows us to simplify multiple result intrinsics to simpler\n    // things that just get one value.\n    if (WO->hasOneUse()) {\n      // Check if we're grabbing only the result of a 'with overflow' intrinsic\n      // and replace it with a traditional binary instruction.\n      if (*EV.idx_begin() == 0) {\n        Instruction::BinaryOps BinOp = WO->getBinaryOp();\n        Value *LHS = WO->getLHS(), *RHS = WO->getRHS();\n        replaceInstUsesWith(*WO, UndefValue::get(WO->getType()));\n        eraseInstFromFunction(*WO);\n        return BinaryOperator::Create(BinOp, LHS, RHS);\n      }\n\n      // If the normal result of the add is dead, and the RHS is a constant,\n      // we can transform this into a range comparison.\n      // overflow = uadd a, -4  -->  overflow = icmp ugt a, 3\n      if (WO->getIntrinsicID() == Intrinsic::uadd_with_overflow)\n        if (ConstantInt *CI = dyn_cast<ConstantInt>(WO->getRHS()))\n          return new ICmpInst(ICmpInst::ICMP_UGT, WO->getLHS(),\n                              ConstantExpr::getNot(CI));\n    }\n  }\n  if (LoadInst *L = dyn_cast<LoadInst>(Agg))\n    // If the (non-volatile) load only has one use, we can rewrite this to a\n    // load from a GEP. This reduces the size of the load. If a load is used\n    // only by extractvalue instructions then this either must have been\n    // optimized before, or it is a struct with padding, in which case we\n    // don't want to do the transformation as it loses padding knowledge.\n    if (L->isSimple() && L->hasOneUse()) {\n      // extractvalue has integer indices, getelementptr has Value*s. Convert.\n      SmallVector<Value*, 4> Indices;\n      // Prefix an i32 0 since we need the first element.\n      Indices.push_back(Builder.getInt32(0));\n      for (unsigned Idx : EV.indices())\n        Indices.push_back(Builder.getInt32(Idx));\n\n      // We need to insert these at the location of the old load, not at that of\n      // the extractvalue.\n      Builder.SetInsertPoint(L);\n      Value *GEP = Builder.CreateInBoundsGEP(L->getType(),\n                                             L->getPointerOperand(), Indices);\n      Instruction *NL = Builder.CreateLoad(EV.getType(), GEP);\n      // Whatever aliasing information we had for the orignal load must also\n      // hold for the smaller load, so propagate the annotations.\n      AAMDNodes Nodes;\n      L->getAAMetadata(Nodes);\n      NL->setAAMetadata(Nodes);\n      // Returning the load directly will cause the main loop to insert it in\n      // the wrong spot, so use replaceInstUsesWith().\n      return replaceInstUsesWith(EV, NL);\n    }\n  // We could simplify extracts from other values. Note that nested extracts may\n  // already be simplified implicitly by the above: extract (extract (insert) )\n  // will be translated into extract ( insert ( extract ) ) first and then just\n  // the value inserted, if appropriate. Similarly for extracts from single-use\n  // loads: extract (extract (load)) will be translated to extract (load (gep))\n  // and if again single-use then via load (gep (gep)) to load (gep).\n  // However, double extracts from e.g. function arguments or return values\n  // aren't handled yet.\n  return nullptr;\n}\n\n/// Return 'true' if the given typeinfo will match anything.\nstatic bool isCatchAll(EHPersonality Personality, Constant *TypeInfo) {\n  switch (Personality) {\n  case EHPersonality::GNU_C:\n  case EHPersonality::GNU_C_SjLj:\n  case EHPersonality::Rust:\n    // The GCC C EH and Rust personality only exists to support cleanups, so\n    // it's not clear what the semantics of catch clauses are.\n    return false;\n  case EHPersonality::Unknown:\n    return false;\n  case EHPersonality::GNU_Ada:\n    // While __gnat_all_others_value will match any Ada exception, it doesn't\n    // match foreign exceptions (or didn't, before gcc-4.7).\n    return false;\n  case EHPersonality::GNU_CXX:\n  case EHPersonality::GNU_CXX_SjLj:\n  case EHPersonality::GNU_ObjC:\n  case EHPersonality::MSVC_X86SEH:\n  case EHPersonality::MSVC_TableSEH:\n  case EHPersonality::MSVC_CXX:\n  case EHPersonality::CoreCLR:\n  case EHPersonality::Wasm_CXX:\n  case EHPersonality::XL_CXX:\n    return TypeInfo->isNullValue();\n  }\n  llvm_unreachable(\"invalid enum\");\n}\n\nstatic bool shorter_filter(const Value *LHS, const Value *RHS) {\n  return\n    cast<ArrayType>(LHS->getType())->getNumElements()\n  <\n    cast<ArrayType>(RHS->getType())->getNumElements();\n}\n\nInstruction *InstCombinerImpl::visitLandingPadInst(LandingPadInst &LI) {\n  // The logic here should be correct for any real-world personality function.\n  // However if that turns out not to be true, the offending logic can always\n  // be conditioned on the personality function, like the catch-all logic is.\n  EHPersonality Personality =\n      classifyEHPersonality(LI.getParent()->getParent()->getPersonalityFn());\n\n  // Simplify the list of clauses, eg by removing repeated catch clauses\n  // (these are often created by inlining).\n  bool MakeNewInstruction = false; // If true, recreate using the following:\n  SmallVector<Constant *, 16> NewClauses; // - Clauses for the new instruction;\n  bool CleanupFlag = LI.isCleanup();   // - The new instruction is a cleanup.\n\n  SmallPtrSet<Value *, 16> AlreadyCaught; // Typeinfos known caught already.\n  for (unsigned i = 0, e = LI.getNumClauses(); i != e; ++i) {\n    bool isLastClause = i + 1 == e;\n    if (LI.isCatch(i)) {\n      // A catch clause.\n      Constant *CatchClause = LI.getClause(i);\n      Constant *TypeInfo = CatchClause->stripPointerCasts();\n\n      // If we already saw this clause, there is no point in having a second\n      // copy of it.\n      if (AlreadyCaught.insert(TypeInfo).second) {\n        // This catch clause was not already seen.\n        NewClauses.push_back(CatchClause);\n      } else {\n        // Repeated catch clause - drop the redundant copy.\n        MakeNewInstruction = true;\n      }\n\n      // If this is a catch-all then there is no point in keeping any following\n      // clauses or marking the landingpad as having a cleanup.\n      if (isCatchAll(Personality, TypeInfo)) {\n        if (!isLastClause)\n          MakeNewInstruction = true;\n        CleanupFlag = false;\n        break;\n      }\n    } else {\n      // A filter clause.  If any of the filter elements were already caught\n      // then they can be dropped from the filter.  It is tempting to try to\n      // exploit the filter further by saying that any typeinfo that does not\n      // occur in the filter can't be caught later (and thus can be dropped).\n      // However this would be wrong, since typeinfos can match without being\n      // equal (for example if one represents a C++ class, and the other some\n      // class derived from it).\n      assert(LI.isFilter(i) && \"Unsupported landingpad clause!\");\n      Constant *FilterClause = LI.getClause(i);\n      ArrayType *FilterType = cast<ArrayType>(FilterClause->getType());\n      unsigned NumTypeInfos = FilterType->getNumElements();\n\n      // An empty filter catches everything, so there is no point in keeping any\n      // following clauses or marking the landingpad as having a cleanup.  By\n      // dealing with this case here the following code is made a bit simpler.\n      if (!NumTypeInfos) {\n        NewClauses.push_back(FilterClause);\n        if (!isLastClause)\n          MakeNewInstruction = true;\n        CleanupFlag = false;\n        break;\n      }\n\n      bool MakeNewFilter = false; // If true, make a new filter.\n      SmallVector<Constant *, 16> NewFilterElts; // New elements.\n      if (isa<ConstantAggregateZero>(FilterClause)) {\n        // Not an empty filter - it contains at least one null typeinfo.\n        assert(NumTypeInfos > 0 && \"Should have handled empty filter already!\");\n        Constant *TypeInfo =\n          Constant::getNullValue(FilterType->getElementType());\n        // If this typeinfo is a catch-all then the filter can never match.\n        if (isCatchAll(Personality, TypeInfo)) {\n          // Throw the filter away.\n          MakeNewInstruction = true;\n          continue;\n        }\n\n        // There is no point in having multiple copies of this typeinfo, so\n        // discard all but the first copy if there is more than one.\n        NewFilterElts.push_back(TypeInfo);\n        if (NumTypeInfos > 1)\n          MakeNewFilter = true;\n      } else {\n        ConstantArray *Filter = cast<ConstantArray>(FilterClause);\n        SmallPtrSet<Value *, 16> SeenInFilter; // For uniquing the elements.\n        NewFilterElts.reserve(NumTypeInfos);\n\n        // Remove any filter elements that were already caught or that already\n        // occurred in the filter.  While there, see if any of the elements are\n        // catch-alls.  If so, the filter can be discarded.\n        bool SawCatchAll = false;\n        for (unsigned j = 0; j != NumTypeInfos; ++j) {\n          Constant *Elt = Filter->getOperand(j);\n          Constant *TypeInfo = Elt->stripPointerCasts();\n          if (isCatchAll(Personality, TypeInfo)) {\n            // This element is a catch-all.  Bail out, noting this fact.\n            SawCatchAll = true;\n            break;\n          }\n\n          // Even if we've seen a type in a catch clause, we don't want to\n          // remove it from the filter.  An unexpected type handler may be\n          // set up for a call site which throws an exception of the same\n          // type caught.  In order for the exception thrown by the unexpected\n          // handler to propagate correctly, the filter must be correctly\n          // described for the call site.\n          //\n          // Example:\n          //\n          // void unexpected() { throw 1;}\n          // void foo() throw (int) {\n          //   std::set_unexpected(unexpected);\n          //   try {\n          //     throw 2.0;\n          //   } catch (int i) {}\n          // }\n\n          // There is no point in having multiple copies of the same typeinfo in\n          // a filter, so only add it if we didn't already.\n          if (SeenInFilter.insert(TypeInfo).second)\n            NewFilterElts.push_back(cast<Constant>(Elt));\n        }\n        // A filter containing a catch-all cannot match anything by definition.\n        if (SawCatchAll) {\n          // Throw the filter away.\n          MakeNewInstruction = true;\n          continue;\n        }\n\n        // If we dropped something from the filter, make a new one.\n        if (NewFilterElts.size() < NumTypeInfos)\n          MakeNewFilter = true;\n      }\n      if (MakeNewFilter) {\n        FilterType = ArrayType::get(FilterType->getElementType(),\n                                    NewFilterElts.size());\n        FilterClause = ConstantArray::get(FilterType, NewFilterElts);\n        MakeNewInstruction = true;\n      }\n\n      NewClauses.push_back(FilterClause);\n\n      // If the new filter is empty then it will catch everything so there is\n      // no point in keeping any following clauses or marking the landingpad\n      // as having a cleanup.  The case of the original filter being empty was\n      // already handled above.\n      if (MakeNewFilter && !NewFilterElts.size()) {\n        assert(MakeNewInstruction && \"New filter but not a new instruction!\");\n        CleanupFlag = false;\n        break;\n      }\n    }\n  }\n\n  // If several filters occur in a row then reorder them so that the shortest\n  // filters come first (those with the smallest number of elements).  This is\n  // advantageous because shorter filters are more likely to match, speeding up\n  // unwinding, but mostly because it increases the effectiveness of the other\n  // filter optimizations below.\n  for (unsigned i = 0, e = NewClauses.size(); i + 1 < e; ) {\n    unsigned j;\n    // Find the maximal 'j' s.t. the range [i, j) consists entirely of filters.\n    for (j = i; j != e; ++j)\n      if (!isa<ArrayType>(NewClauses[j]->getType()))\n        break;\n\n    // Check whether the filters are already sorted by length.  We need to know\n    // if sorting them is actually going to do anything so that we only make a\n    // new landingpad instruction if it does.\n    for (unsigned k = i; k + 1 < j; ++k)\n      if (shorter_filter(NewClauses[k+1], NewClauses[k])) {\n        // Not sorted, so sort the filters now.  Doing an unstable sort would be\n        // correct too but reordering filters pointlessly might confuse users.\n        std::stable_sort(NewClauses.begin() + i, NewClauses.begin() + j,\n                         shorter_filter);\n        MakeNewInstruction = true;\n        break;\n      }\n\n    // Look for the next batch of filters.\n    i = j + 1;\n  }\n\n  // If typeinfos matched if and only if equal, then the elements of a filter L\n  // that occurs later than a filter F could be replaced by the intersection of\n  // the elements of F and L.  In reality two typeinfos can match without being\n  // equal (for example if one represents a C++ class, and the other some class\n  // derived from it) so it would be wrong to perform this transform in general.\n  // However the transform is correct and useful if F is a subset of L.  In that\n  // case L can be replaced by F, and thus removed altogether since repeating a\n  // filter is pointless.  So here we look at all pairs of filters F and L where\n  // L follows F in the list of clauses, and remove L if every element of F is\n  // an element of L.  This can occur when inlining C++ functions with exception\n  // specifications.\n  for (unsigned i = 0; i + 1 < NewClauses.size(); ++i) {\n    // Examine each filter in turn.\n    Value *Filter = NewClauses[i];\n    ArrayType *FTy = dyn_cast<ArrayType>(Filter->getType());\n    if (!FTy)\n      // Not a filter - skip it.\n      continue;\n    unsigned FElts = FTy->getNumElements();\n    // Examine each filter following this one.  Doing this backwards means that\n    // we don't have to worry about filters disappearing under us when removed.\n    for (unsigned j = NewClauses.size() - 1; j != i; --j) {\n      Value *LFilter = NewClauses[j];\n      ArrayType *LTy = dyn_cast<ArrayType>(LFilter->getType());\n      if (!LTy)\n        // Not a filter - skip it.\n        continue;\n      // If Filter is a subset of LFilter, i.e. every element of Filter is also\n      // an element of LFilter, then discard LFilter.\n      SmallVectorImpl<Constant *>::iterator J = NewClauses.begin() + j;\n      // If Filter is empty then it is a subset of LFilter.\n      if (!FElts) {\n        // Discard LFilter.\n        NewClauses.erase(J);\n        MakeNewInstruction = true;\n        // Move on to the next filter.\n        continue;\n      }\n      unsigned LElts = LTy->getNumElements();\n      // If Filter is longer than LFilter then it cannot be a subset of it.\n      if (FElts > LElts)\n        // Move on to the next filter.\n        continue;\n      // At this point we know that LFilter has at least one element.\n      if (isa<ConstantAggregateZero>(LFilter)) { // LFilter only contains zeros.\n        // Filter is a subset of LFilter iff Filter contains only zeros (as we\n        // already know that Filter is not longer than LFilter).\n        if (isa<ConstantAggregateZero>(Filter)) {\n          assert(FElts <= LElts && \"Should have handled this case earlier!\");\n          // Discard LFilter.\n          NewClauses.erase(J);\n          MakeNewInstruction = true;\n        }\n        // Move on to the next filter.\n        continue;\n      }\n      ConstantArray *LArray = cast<ConstantArray>(LFilter);\n      if (isa<ConstantAggregateZero>(Filter)) { // Filter only contains zeros.\n        // Since Filter is non-empty and contains only zeros, it is a subset of\n        // LFilter iff LFilter contains a zero.\n        assert(FElts > 0 && \"Should have eliminated the empty filter earlier!\");\n        for (unsigned l = 0; l != LElts; ++l)\n          if (LArray->getOperand(l)->isNullValue()) {\n            // LFilter contains a zero - discard it.\n            NewClauses.erase(J);\n            MakeNewInstruction = true;\n            break;\n          }\n        // Move on to the next filter.\n        continue;\n      }\n      // At this point we know that both filters are ConstantArrays.  Loop over\n      // operands to see whether every element of Filter is also an element of\n      // LFilter.  Since filters tend to be short this is probably faster than\n      // using a method that scales nicely.\n      ConstantArray *FArray = cast<ConstantArray>(Filter);\n      bool AllFound = true;\n      for (unsigned f = 0; f != FElts; ++f) {\n        Value *FTypeInfo = FArray->getOperand(f)->stripPointerCasts();\n        AllFound = false;\n        for (unsigned l = 0; l != LElts; ++l) {\n          Value *LTypeInfo = LArray->getOperand(l)->stripPointerCasts();\n          if (LTypeInfo == FTypeInfo) {\n            AllFound = true;\n            break;\n          }\n        }\n        if (!AllFound)\n          break;\n      }\n      if (AllFound) {\n        // Discard LFilter.\n        NewClauses.erase(J);\n        MakeNewInstruction = true;\n      }\n      // Move on to the next filter.\n    }\n  }\n\n  // If we changed any of the clauses, replace the old landingpad instruction\n  // with a new one.\n  if (MakeNewInstruction) {\n    LandingPadInst *NLI = LandingPadInst::Create(LI.getType(),\n                                                 NewClauses.size());\n    for (unsigned i = 0, e = NewClauses.size(); i != e; ++i)\n      NLI->addClause(NewClauses[i]);\n    // A landing pad with no clauses must have the cleanup flag set.  It is\n    // theoretically possible, though highly unlikely, that we eliminated all\n    // clauses.  If so, force the cleanup flag to true.\n    if (NewClauses.empty())\n      CleanupFlag = true;\n    NLI->setCleanup(CleanupFlag);\n    return NLI;\n  }\n\n  // Even if none of the clauses changed, we may nonetheless have understood\n  // that the cleanup flag is pointless.  Clear it if so.\n  if (LI.isCleanup() != CleanupFlag) {\n    assert(!CleanupFlag && \"Adding a cleanup, not removing one?!\");\n    LI.setCleanup(CleanupFlag);\n    return &LI;\n  }\n\n  return nullptr;\n}\n\nInstruction *InstCombinerImpl::visitFreeze(FreezeInst &I) {\n  Value *Op0 = I.getOperand(0);\n\n  if (Value *V = SimplifyFreezeInst(Op0, SQ.getWithInstruction(&I)))\n    return replaceInstUsesWith(I, V);\n\n  // freeze (phi const, x) --> phi const, (freeze x)\n  if (auto *PN = dyn_cast<PHINode>(Op0)) {\n    if (Instruction *NV = foldOpIntoPhi(I, PN))\n      return NV;\n  }\n\n  if (match(Op0, m_Undef())) {\n    // If I is freeze(undef), see its uses and fold it to the best constant.\n    // - or: pick -1\n    // - select's condition: pick the value that leads to choosing a constant\n    // - other ops: pick 0\n    Constant *BestValue = nullptr;\n    Constant *NullValue = Constant::getNullValue(I.getType());\n    for (const auto *U : I.users()) {\n      Constant *C = NullValue;\n\n      if (match(U, m_Or(m_Value(), m_Value())))\n        C = Constant::getAllOnesValue(I.getType());\n      else if (const auto *SI = dyn_cast<SelectInst>(U)) {\n        if (SI->getCondition() == &I) {\n          APInt CondVal(1, isa<Constant>(SI->getFalseValue()) ? 0 : 1);\n          C = Constant::getIntegerValue(I.getType(), CondVal);\n        }\n      }\n\n      if (!BestValue)\n        BestValue = C;\n      else if (BestValue != C)\n        BestValue = NullValue;\n    }\n\n    return replaceInstUsesWith(I, BestValue);\n  }\n\n  return nullptr;\n}\n\n/// Try to move the specified instruction from its current block into the\n/// beginning of DestBlock, which can only happen if it's safe to move the\n/// instruction past all of the instructions between it and the end of its\n/// block.\nstatic bool TryToSinkInstruction(Instruction *I, BasicBlock *DestBlock) {\n  assert(I->getSingleUndroppableUse() && \"Invariants didn't hold!\");\n  BasicBlock *SrcBlock = I->getParent();\n\n  // Cannot move control-flow-involving, volatile loads, vaarg, etc.\n  if (isa<PHINode>(I) || I->isEHPad() || I->mayHaveSideEffects() ||\n      I->isTerminator())\n    return false;\n\n  // Do not sink static or dynamic alloca instructions. Static allocas must\n  // remain in the entry block, and dynamic allocas must not be sunk in between\n  // a stacksave / stackrestore pair, which would incorrectly shorten its\n  // lifetime.\n  if (isa<AllocaInst>(I))\n    return false;\n\n  // Do not sink into catchswitch blocks.\n  if (isa<CatchSwitchInst>(DestBlock->getTerminator()))\n    return false;\n\n  // Do not sink convergent call instructions.\n  if (auto *CI = dyn_cast<CallInst>(I)) {\n    if (CI->isConvergent())\n      return false;\n  }\n  // We can only sink load instructions if there is nothing between the load and\n  // the end of block that could change the value.\n  if (I->mayReadFromMemory()) {\n    // We don't want to do any sophisticated alias analysis, so we only check\n    // the instructions after I in I's parent block if we try to sink to its\n    // successor block.\n    if (DestBlock->getUniquePredecessor() != I->getParent())\n      return false;\n    for (BasicBlock::iterator Scan = I->getIterator(),\n                              E = I->getParent()->end();\n         Scan != E; ++Scan)\n      if (Scan->mayWriteToMemory())\n        return false;\n  }\n\n  I->dropDroppableUses([DestBlock](const Use *U) {\n    if (auto *I = dyn_cast<Instruction>(U->getUser()))\n      return I->getParent() != DestBlock;\n    return true;\n  });\n  /// FIXME: We could remove droppable uses that are not dominated by\n  /// the new position.\n\n  BasicBlock::iterator InsertPos = DestBlock->getFirstInsertionPt();\n  I->moveBefore(&*InsertPos);\n  ++NumSunkInst;\n\n  // Also sink all related debug uses from the source basic block. Otherwise we\n  // get debug use before the def. Attempt to salvage debug uses first, to\n  // maximise the range variables have location for. If we cannot salvage, then\n  // mark the location undef: we know it was supposed to receive a new location\n  // here, but that computation has been sunk.\n  SmallVector<DbgVariableIntrinsic *, 2> DbgUsers;\n  findDbgUsers(DbgUsers, I);\n\n  // Update the arguments of a dbg.declare instruction, so that it\n  // does not point into a sunk instruction.\n  auto updateDbgDeclare = [&I](DbgVariableIntrinsic *DII) {\n    if (!isa<DbgDeclareInst>(DII))\n      return false;\n\n    if (isa<CastInst>(I))\n      DII->setOperand(\n          0, MetadataAsValue::get(I->getContext(),\n                                  ValueAsMetadata::get(I->getOperand(0))));\n    return true;\n  };\n\n  SmallVector<DbgVariableIntrinsic *, 2> DIIClones;\n  for (auto User : DbgUsers) {\n    // A dbg.declare instruction should not be cloned, since there can only be\n    // one per variable fragment. It should be left in the original place\n    // because the sunk instruction is not an alloca (otherwise we could not be\n    // here).\n    if (User->getParent() != SrcBlock || updateDbgDeclare(User))\n      continue;\n\n    DIIClones.emplace_back(cast<DbgVariableIntrinsic>(User->clone()));\n    LLVM_DEBUG(dbgs() << \"CLONE: \" << *DIIClones.back() << '\\n');\n  }\n\n  // Perform salvaging without the clones, then sink the clones.\n  if (!DIIClones.empty()) {\n    salvageDebugInfoForDbgValues(*I, DbgUsers);\n    for (auto &DIIClone : DIIClones) {\n      DIIClone->insertBefore(&*InsertPos);\n      LLVM_DEBUG(dbgs() << \"SINK: \" << *DIIClone << '\\n');\n    }\n  }\n\n  return true;\n}\n\nbool InstCombinerImpl::run() {\n  while (!Worklist.isEmpty()) {\n    // Walk deferred instructions in reverse order, and push them to the\n    // worklist, which means they'll end up popped from the worklist in-order.\n    while (Instruction *I = Worklist.popDeferred()) {\n      // Check to see if we can DCE the instruction. We do this already here to\n      // reduce the number of uses and thus allow other folds to trigger.\n      // Note that eraseInstFromFunction() may push additional instructions on\n      // the deferred worklist, so this will DCE whole instruction chains.\n      if (isInstructionTriviallyDead(I, &TLI)) {\n        eraseInstFromFunction(*I);\n        ++NumDeadInst;\n        continue;\n      }\n\n      Worklist.push(I);\n    }\n\n    Instruction *I = Worklist.removeOne();\n    if (I == nullptr) continue;  // skip null values.\n\n    // Check to see if we can DCE the instruction.\n    if (isInstructionTriviallyDead(I, &TLI)) {\n      eraseInstFromFunction(*I);\n      ++NumDeadInst;\n      continue;\n    }\n\n    if (!DebugCounter::shouldExecute(VisitCounter))\n      continue;\n\n    // Instruction isn't dead, see if we can constant propagate it.\n    if (!I->use_empty() &&\n        (I->getNumOperands() == 0 || isa<Constant>(I->getOperand(0)))) {\n      if (Constant *C = ConstantFoldInstruction(I, DL, &TLI)) {\n        LLVM_DEBUG(dbgs() << \"IC: ConstFold to: \" << *C << \" from: \" << *I\n                          << '\\n');\n\n        // Add operands to the worklist.\n        replaceInstUsesWith(*I, C);\n        ++NumConstProp;\n        if (isInstructionTriviallyDead(I, &TLI))\n          eraseInstFromFunction(*I);\n        MadeIRChange = true;\n        continue;\n      }\n    }\n\n    // See if we can trivially sink this instruction to its user if we can\n    // prove that the successor is not executed more frequently than our block.\n    if (EnableCodeSinking)\n      if (Use *SingleUse = I->getSingleUndroppableUse()) {\n        BasicBlock *BB = I->getParent();\n        Instruction *UserInst = cast<Instruction>(SingleUse->getUser());\n        BasicBlock *UserParent;\n\n        // Get the block the use occurs in.\n        if (PHINode *PN = dyn_cast<PHINode>(UserInst))\n          UserParent = PN->getIncomingBlock(*SingleUse);\n        else\n          UserParent = UserInst->getParent();\n\n        // Try sinking to another block. If that block is unreachable, then do\n        // not bother. SimplifyCFG should handle it.\n        if (UserParent != BB && DT.isReachableFromEntry(UserParent)) {\n          // See if the user is one of our successors that has only one\n          // predecessor, so that we don't have to split the critical edge.\n          bool ShouldSink = UserParent->getUniquePredecessor() == BB;\n          // Another option where we can sink is a block that ends with a\n          // terminator that does not pass control to other block (such as\n          // return or unreachable). In this case:\n          //   - I dominates the User (by SSA form);\n          //   - the User will be executed at most once.\n          // So sinking I down to User is always profitable or neutral.\n          if (!ShouldSink) {\n            auto *Term = UserParent->getTerminator();\n            ShouldSink = isa<ReturnInst>(Term) || isa<UnreachableInst>(Term);\n          }\n          if (ShouldSink) {\n            assert(DT.dominates(BB, UserParent) &&\n                   \"Dominance relation broken?\");\n            // Okay, the CFG is simple enough, try to sink this instruction.\n            if (TryToSinkInstruction(I, UserParent)) {\n              LLVM_DEBUG(dbgs() << \"IC: Sink: \" << *I << '\\n');\n              MadeIRChange = true;\n              // We'll add uses of the sunk instruction below, but since sinking\n              // can expose opportunities for it's *operands* add them to the\n              // worklist\n              for (Use &U : I->operands())\n                if (Instruction *OpI = dyn_cast<Instruction>(U.get()))\n                  Worklist.push(OpI);\n            }\n          }\n        }\n      }\n\n    // Now that we have an instruction, try combining it to simplify it.\n    Builder.SetInsertPoint(I);\n    Builder.CollectMetadataToCopy(\n        I, {LLVMContext::MD_dbg, LLVMContext::MD_annotation});\n\n#ifndef NDEBUG\n    std::string OrigI;\n#endif\n    LLVM_DEBUG(raw_string_ostream SS(OrigI); I->print(SS); OrigI = SS.str(););\n    LLVM_DEBUG(dbgs() << \"IC: Visiting: \" << OrigI << '\\n');\n\n    if (Instruction *Result = visit(*I)) {\n      ++NumCombined;\n      // Should we replace the old instruction with a new one?\n      if (Result != I) {\n        LLVM_DEBUG(dbgs() << \"IC: Old = \" << *I << '\\n'\n                          << \"    New = \" << *Result << '\\n');\n\n        Result->copyMetadata(*I,\n                             {LLVMContext::MD_dbg, LLVMContext::MD_annotation});\n        // Everything uses the new instruction now.\n        I->replaceAllUsesWith(Result);\n\n        // Move the name to the new instruction first.\n        Result->takeName(I);\n\n        // Insert the new instruction into the basic block...\n        BasicBlock *InstParent = I->getParent();\n        BasicBlock::iterator InsertPos = I->getIterator();\n\n        // Are we replace a PHI with something that isn't a PHI, or vice versa?\n        if (isa<PHINode>(Result) != isa<PHINode>(I)) {\n          // We need to fix up the insertion point.\n          if (isa<PHINode>(I)) // PHI -> Non-PHI\n            InsertPos = InstParent->getFirstInsertionPt();\n          else // Non-PHI -> PHI\n            InsertPos = InstParent->getFirstNonPHI()->getIterator();\n        }\n\n        InstParent->getInstList().insert(InsertPos, Result);\n\n        // Push the new instruction and any users onto the worklist.\n        Worklist.pushUsersToWorkList(*Result);\n        Worklist.push(Result);\n\n        eraseInstFromFunction(*I);\n      } else {\n        LLVM_DEBUG(dbgs() << \"IC: Mod = \" << OrigI << '\\n'\n                          << \"    New = \" << *I << '\\n');\n\n        // If the instruction was modified, it's possible that it is now dead.\n        // if so, remove it.\n        if (isInstructionTriviallyDead(I, &TLI)) {\n          eraseInstFromFunction(*I);\n        } else {\n          Worklist.pushUsersToWorkList(*I);\n          Worklist.push(I);\n        }\n      }\n      MadeIRChange = true;\n    }\n  }\n\n  Worklist.zap();\n  return MadeIRChange;\n}\n\n// Track the scopes used by !alias.scope and !noalias. In a function, a\n// @llvm.experimental.noalias.scope.decl is only useful if that scope is used\n// by both sets. If not, the declaration of the scope can be safely omitted.\n// The MDNode of the scope can be omitted as well for the instructions that are\n// part of this function. We do not do that at this point, as this might become\n// too time consuming to do.\nclass AliasScopeTracker {\n  SmallPtrSet<const MDNode *, 8> UsedAliasScopesAndLists;\n  SmallPtrSet<const MDNode *, 8> UsedNoAliasScopesAndLists;\n\npublic:\n  void analyse(Instruction *I) {\n    // This seems to be faster than checking 'mayReadOrWriteMemory()'.\n    if (!I->hasMetadataOtherThanDebugLoc())\n      return;\n\n    auto Track = [](Metadata *ScopeList, auto &Container) {\n      const auto *MDScopeList = dyn_cast_or_null<MDNode>(ScopeList);\n      if (!MDScopeList || !Container.insert(MDScopeList).second)\n        return;\n      for (auto &MDOperand : MDScopeList->operands())\n        if (auto *MDScope = dyn_cast<MDNode>(MDOperand))\n          Container.insert(MDScope);\n    };\n\n    Track(I->getMetadata(LLVMContext::MD_alias_scope), UsedAliasScopesAndLists);\n    Track(I->getMetadata(LLVMContext::MD_noalias), UsedNoAliasScopesAndLists);\n  }\n\n  bool isNoAliasScopeDeclDead(Instruction *Inst) {\n    NoAliasScopeDeclInst *Decl = dyn_cast<NoAliasScopeDeclInst>(Inst);\n    if (!Decl)\n      return false;\n\n    assert(Decl->use_empty() &&\n           \"llvm.experimental.noalias.scope.decl in use ?\");\n    const MDNode *MDSL = Decl->getScopeList();\n    assert(MDSL->getNumOperands() == 1 &&\n           \"llvm.experimental.noalias.scope should refer to a single scope\");\n    auto &MDOperand = MDSL->getOperand(0);\n    if (auto *MD = dyn_cast<MDNode>(MDOperand))\n      return !UsedAliasScopesAndLists.contains(MD) ||\n             !UsedNoAliasScopesAndLists.contains(MD);\n\n    // Not an MDNode ? throw away.\n    return true;\n  }\n};\n\n/// Populate the IC worklist from a function, by walking it in depth-first\n/// order and adding all reachable code to the worklist.\n///\n/// This has a couple of tricks to make the code faster and more powerful.  In\n/// particular, we constant fold and DCE instructions as we go, to avoid adding\n/// them to the worklist (this significantly speeds up instcombine on code where\n/// many instructions are dead or constant).  Additionally, if we find a branch\n/// whose condition is a known constant, we only visit the reachable successors.\nstatic bool prepareICWorklistFromFunction(Function &F, const DataLayout &DL,\n                                          const TargetLibraryInfo *TLI,\n                                          InstCombineWorklist &ICWorklist) {\n  bool MadeIRChange = false;\n  SmallPtrSet<BasicBlock *, 32> Visited;\n  SmallVector<BasicBlock*, 256> Worklist;\n  Worklist.push_back(&F.front());\n\n  SmallVector<Instruction*, 128> InstrsForInstCombineWorklist;\n  DenseMap<Constant *, Constant *> FoldedConstants;\n  AliasScopeTracker SeenAliasScopes;\n\n  do {\n    BasicBlock *BB = Worklist.pop_back_val();\n\n    // We have now visited this block!  If we've already been here, ignore it.\n    if (!Visited.insert(BB).second)\n      continue;\n\n    for (BasicBlock::iterator BBI = BB->begin(), E = BB->end(); BBI != E; ) {\n      Instruction *Inst = &*BBI++;\n\n      // ConstantProp instruction if trivially constant.\n      if (!Inst->use_empty() &&\n          (Inst->getNumOperands() == 0 || isa<Constant>(Inst->getOperand(0))))\n        if (Constant *C = ConstantFoldInstruction(Inst, DL, TLI)) {\n          LLVM_DEBUG(dbgs() << \"IC: ConstFold to: \" << *C << \" from: \" << *Inst\n                            << '\\n');\n          Inst->replaceAllUsesWith(C);\n          ++NumConstProp;\n          if (isInstructionTriviallyDead(Inst, TLI))\n            Inst->eraseFromParent();\n          MadeIRChange = true;\n          continue;\n        }\n\n      // See if we can constant fold its operands.\n      for (Use &U : Inst->operands()) {\n        if (!isa<ConstantVector>(U) && !isa<ConstantExpr>(U))\n          continue;\n\n        auto *C = cast<Constant>(U);\n        Constant *&FoldRes = FoldedConstants[C];\n        if (!FoldRes)\n          FoldRes = ConstantFoldConstant(C, DL, TLI);\n\n        if (FoldRes != C) {\n          LLVM_DEBUG(dbgs() << \"IC: ConstFold operand of: \" << *Inst\n                            << \"\\n    Old = \" << *C\n                            << \"\\n    New = \" << *FoldRes << '\\n');\n          U = FoldRes;\n          MadeIRChange = true;\n        }\n      }\n\n      // Skip processing debug and pseudo intrinsics in InstCombine. Processing\n      // these call instructions consumes non-trivial amount of time and\n      // provides no value for the optimization.\n      if (!Inst->isDebugOrPseudoInst()) {\n        InstrsForInstCombineWorklist.push_back(Inst);\n        SeenAliasScopes.analyse(Inst);\n      }\n    }\n\n    // Recursively visit successors.  If this is a branch or switch on a\n    // constant, only visit the reachable successor.\n    Instruction *TI = BB->getTerminator();\n    if (BranchInst *BI = dyn_cast<BranchInst>(TI)) {\n      if (BI->isConditional() && isa<ConstantInt>(BI->getCondition())) {\n        bool CondVal = cast<ConstantInt>(BI->getCondition())->getZExtValue();\n        BasicBlock *ReachableBB = BI->getSuccessor(!CondVal);\n        Worklist.push_back(ReachableBB);\n        continue;\n      }\n    } else if (SwitchInst *SI = dyn_cast<SwitchInst>(TI)) {\n      if (ConstantInt *Cond = dyn_cast<ConstantInt>(SI->getCondition())) {\n        Worklist.push_back(SI->findCaseValue(Cond)->getCaseSuccessor());\n        continue;\n      }\n    }\n\n    append_range(Worklist, successors(TI));\n  } while (!Worklist.empty());\n\n  // Remove instructions inside unreachable blocks. This prevents the\n  // instcombine code from having to deal with some bad special cases, and\n  // reduces use counts of instructions.\n  for (BasicBlock &BB : F) {\n    if (Visited.count(&BB))\n      continue;\n\n    unsigned NumDeadInstInBB;\n    unsigned NumDeadDbgInstInBB;\n    std::tie(NumDeadInstInBB, NumDeadDbgInstInBB) =\n        removeAllNonTerminatorAndEHPadInstructions(&BB);\n\n    MadeIRChange |= NumDeadInstInBB + NumDeadDbgInstInBB > 0;\n    NumDeadInst += NumDeadInstInBB;\n  }\n\n  // Once we've found all of the instructions to add to instcombine's worklist,\n  // add them in reverse order.  This way instcombine will visit from the top\n  // of the function down.  This jives well with the way that it adds all uses\n  // of instructions to the worklist after doing a transformation, thus avoiding\n  // some N^2 behavior in pathological cases.\n  ICWorklist.reserve(InstrsForInstCombineWorklist.size());\n  for (Instruction *Inst : reverse(InstrsForInstCombineWorklist)) {\n    // DCE instruction if trivially dead. As we iterate in reverse program\n    // order here, we will clean up whole chains of dead instructions.\n    if (isInstructionTriviallyDead(Inst, TLI) ||\n        SeenAliasScopes.isNoAliasScopeDeclDead(Inst)) {\n      ++NumDeadInst;\n      LLVM_DEBUG(dbgs() << \"IC: DCE: \" << *Inst << '\\n');\n      salvageDebugInfo(*Inst);\n      Inst->eraseFromParent();\n      MadeIRChange = true;\n      continue;\n    }\n\n    ICWorklist.push(Inst);\n  }\n\n  return MadeIRChange;\n}\n\nstatic bool combineInstructionsOverFunction(\n    Function &F, InstCombineWorklist &Worklist, AliasAnalysis *AA,\n    AssumptionCache &AC, TargetLibraryInfo &TLI, TargetTransformInfo &TTI,\n    DominatorTree &DT, OptimizationRemarkEmitter &ORE, BlockFrequencyInfo *BFI,\n    ProfileSummaryInfo *PSI, unsigned MaxIterations, LoopInfo *LI) {\n  auto &DL = F.getParent()->getDataLayout();\n  MaxIterations = std::min(MaxIterations, LimitMaxIterations.getValue());\n\n  /// Builder - This is an IRBuilder that automatically inserts new\n  /// instructions into the worklist when they are created.\n  IRBuilder<TargetFolder, IRBuilderCallbackInserter> Builder(\n      F.getContext(), TargetFolder(DL),\n      IRBuilderCallbackInserter([&Worklist, &AC](Instruction *I) {\n        Worklist.add(I);\n        if (match(I, m_Intrinsic<Intrinsic::assume>()))\n          AC.registerAssumption(cast<CallInst>(I));\n      }));\n\n  // Lower dbg.declare intrinsics otherwise their value may be clobbered\n  // by instcombiner.\n  bool MadeIRChange = false;\n  if (ShouldLowerDbgDeclare)\n    MadeIRChange = LowerDbgDeclare(F);\n\n  // Iterate while there is work to do.\n  unsigned Iteration = 0;\n  while (true) {\n    ++NumWorklistIterations;\n    ++Iteration;\n\n    if (Iteration > InfiniteLoopDetectionThreshold) {\n      report_fatal_error(\n          \"Instruction Combining seems stuck in an infinite loop after \" +\n          Twine(InfiniteLoopDetectionThreshold) + \" iterations.\");\n    }\n\n    if (Iteration > MaxIterations) {\n      LLVM_DEBUG(dbgs() << \"\\n\\n[IC] Iteration limit #\" << MaxIterations\n                        << \" on \" << F.getName()\n                        << \" reached; stopping before reaching a fixpoint\\n\");\n      break;\n    }\n\n    LLVM_DEBUG(dbgs() << \"\\n\\nINSTCOMBINE ITERATION #\" << Iteration << \" on \"\n                      << F.getName() << \"\\n\");\n\n    MadeIRChange |= prepareICWorklistFromFunction(F, DL, &TLI, Worklist);\n\n    InstCombinerImpl IC(Worklist, Builder, F.hasMinSize(), AA, AC, TLI, TTI, DT,\n                        ORE, BFI, PSI, DL, LI);\n    IC.MaxArraySizeForCombine = MaxArraySize;\n\n    if (!IC.run())\n      break;\n\n    MadeIRChange = true;\n  }\n\n  return MadeIRChange;\n}\n\nInstCombinePass::InstCombinePass() : MaxIterations(LimitMaxIterations) {}\n\nInstCombinePass::InstCombinePass(unsigned MaxIterations)\n    : MaxIterations(MaxIterations) {}\n\nPreservedAnalyses InstCombinePass::run(Function &F,\n                                       FunctionAnalysisManager &AM) {\n  auto &AC = AM.getResult<AssumptionAnalysis>(F);\n  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);\n  auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);\n  auto &ORE = AM.getResult<OptimizationRemarkEmitterAnalysis>(F);\n  auto &TTI = AM.getResult<TargetIRAnalysis>(F);\n\n  auto *LI = AM.getCachedResult<LoopAnalysis>(F);\n\n  auto *AA = &AM.getResult<AAManager>(F);\n  auto &MAMProxy = AM.getResult<ModuleAnalysisManagerFunctionProxy>(F);\n  ProfileSummaryInfo *PSI =\n      MAMProxy.getCachedResult<ProfileSummaryAnalysis>(*F.getParent());\n  auto *BFI = (PSI && PSI->hasProfileSummary()) ?\n      &AM.getResult<BlockFrequencyAnalysis>(F) : nullptr;\n\n  if (!combineInstructionsOverFunction(F, Worklist, AA, AC, TLI, TTI, DT, ORE,\n                                       BFI, PSI, MaxIterations, LI))\n    // No changes, all analyses are preserved.\n    return PreservedAnalyses::all();\n\n  // Mark all the analyses that instcombine updates as preserved.\n  PreservedAnalyses PA;\n  PA.preserveSet<CFGAnalyses>();\n  PA.preserve<AAManager>();\n  PA.preserve<BasicAA>();\n  PA.preserve<GlobalsAA>();\n  return PA;\n}\n\nvoid InstructionCombiningPass::getAnalysisUsage(AnalysisUsage &AU) const {\n  AU.setPreservesCFG();\n  AU.addRequired<AAResultsWrapperPass>();\n  AU.addRequired<AssumptionCacheTracker>();\n  AU.addRequired<TargetLibraryInfoWrapperPass>();\n  AU.addRequired<TargetTransformInfoWrapperPass>();\n  AU.addRequired<DominatorTreeWrapperPass>();\n  AU.addRequired<OptimizationRemarkEmitterWrapperPass>();\n  AU.addPreserved<DominatorTreeWrapperPass>();\n  AU.addPreserved<AAResultsWrapperPass>();\n  AU.addPreserved<BasicAAWrapperPass>();\n  AU.addPreserved<GlobalsAAWrapperPass>();\n  AU.addRequired<ProfileSummaryInfoWrapperPass>();\n  LazyBlockFrequencyInfoPass::getLazyBFIAnalysisUsage(AU);\n}\n\nbool InstructionCombiningPass::runOnFunction(Function &F) {\n  if (skipFunction(F))\n    return false;\n\n  // Required analyses.\n  auto AA = &getAnalysis<AAResultsWrapperPass>().getAAResults();\n  auto &AC = getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F);\n  auto &TLI = getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(F);\n  auto &TTI = getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);\n  auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();\n  auto &ORE = getAnalysis<OptimizationRemarkEmitterWrapperPass>().getORE();\n\n  // Optional analyses.\n  auto *LIWP = getAnalysisIfAvailable<LoopInfoWrapperPass>();\n  auto *LI = LIWP ? &LIWP->getLoopInfo() : nullptr;\n  ProfileSummaryInfo *PSI =\n      &getAnalysis<ProfileSummaryInfoWrapperPass>().getPSI();\n  BlockFrequencyInfo *BFI =\n      (PSI && PSI->hasProfileSummary()) ?\n      &getAnalysis<LazyBlockFrequencyInfoPass>().getBFI() :\n      nullptr;\n\n  return combineInstructionsOverFunction(F, Worklist, AA, AC, TLI, TTI, DT, ORE,\n                                         BFI, PSI, MaxIterations, LI);\n}\n\nchar InstructionCombiningPass::ID = 0;\n\nInstructionCombiningPass::InstructionCombiningPass()\n    : FunctionPass(ID), MaxIterations(InstCombineDefaultMaxIterations) {\n  initializeInstructionCombiningPassPass(*PassRegistry::getPassRegistry());\n}\n\nInstructionCombiningPass::InstructionCombiningPass(unsigned MaxIterations)\n    : FunctionPass(ID), MaxIterations(MaxIterations) {\n  initializeInstructionCombiningPassPass(*PassRegistry::getPassRegistry());\n}\n\nINITIALIZE_PASS_BEGIN(InstructionCombiningPass, \"instcombine\",\n                      \"Combine redundant instructions\", false, false)\nINITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)\nINITIALIZE_PASS_DEPENDENCY(TargetLibraryInfoWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(AAResultsWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(GlobalsAAWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(OptimizationRemarkEmitterWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(LazyBlockFrequencyInfoPass)\nINITIALIZE_PASS_DEPENDENCY(ProfileSummaryInfoWrapperPass)\nINITIALIZE_PASS_END(InstructionCombiningPass, \"instcombine\",\n                    \"Combine redundant instructions\", false, false)\n\n// Initialization Routines\nvoid llvm::initializeInstCombine(PassRegistry &Registry) {\n  initializeInstructionCombiningPassPass(Registry);\n}\n\nvoid LLVMInitializeInstCombine(LLVMPassRegistryRef R) {\n  initializeInstructionCombiningPassPass(*unwrap(R));\n}\n\nFunctionPass *llvm::createInstructionCombiningPass() {\n  return new InstructionCombiningPass();\n}\n\nFunctionPass *llvm::createInstructionCombiningPass(unsigned MaxIterations) {\n  return new InstructionCombiningPass(MaxIterations);\n}\n\nvoid LLVMAddInstructionCombiningPass(LLVMPassManagerRef PM) {\n  unwrap(PM)->add(createInstructionCombiningPass());\n}\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "content": "//===- InstCombineInternal.h - InstCombine pass internals -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n///\n/// This file provides internal interfaces used to implement the InstCombine.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_TRANSFORMS_INSTCOMBINE_INSTCOMBINEINTERNAL_H\n#define LLVM_LIB_TRANSFORMS_INSTCOMBINE_INSTCOMBINEINTERNAL_H\n\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/Analysis/InstructionSimplify.h\"\n#include \"llvm/Analysis/TargetFolder.h\"\n#include \"llvm/Analysis/ValueTracking.h\"\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/InstVisitor.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/KnownBits.h\"\n#include \"llvm/Transforms/InstCombine/InstCombineWorklist.h\"\n#include \"llvm/Transforms/InstCombine/InstCombiner.h\"\n#include \"llvm/Transforms/Utils/Local.h\"\n#include <cassert>\n\n#define DEBUG_TYPE \"instcombine\"\n\nusing namespace llvm::PatternMatch;\n\n// As a default, let's assume that we want to be aggressive,\n// and attempt to traverse with no limits in attempt to sink negation.\nstatic constexpr unsigned NegatorDefaultMaxDepth = ~0U;\n\n// Let's guesstimate that most often we will end up visiting/producing\n// fairly small number of new instructions.\nstatic constexpr unsigned NegatorMaxNodesSSO = 16;\n\nnamespace llvm {\n\nclass AAResults;\nclass APInt;\nclass AssumptionCache;\nclass BlockFrequencyInfo;\nclass DataLayout;\nclass DominatorTree;\nclass GEPOperator;\nclass GlobalVariable;\nclass LoopInfo;\nclass OptimizationRemarkEmitter;\nclass ProfileSummaryInfo;\nclass TargetLibraryInfo;\nclass User;\n\nclass LLVM_LIBRARY_VISIBILITY InstCombinerImpl final\n    : public InstCombiner,\n      public InstVisitor<InstCombinerImpl, Instruction *> {\npublic:\n  InstCombinerImpl(InstCombineWorklist &Worklist, BuilderTy &Builder,\n                   bool MinimizeSize, AAResults *AA, AssumptionCache &AC,\n                   TargetLibraryInfo &TLI, TargetTransformInfo &TTI,\n                   DominatorTree &DT, OptimizationRemarkEmitter &ORE,\n                   BlockFrequencyInfo *BFI, ProfileSummaryInfo *PSI,\n                   const DataLayout &DL, LoopInfo *LI)\n      : InstCombiner(Worklist, Builder, MinimizeSize, AA, AC, TLI, TTI, DT, ORE,\n                     BFI, PSI, DL, LI) {}\n\n  virtual ~InstCombinerImpl() {}\n\n  /// Run the combiner over the entire worklist until it is empty.\n  ///\n  /// \\returns true if the IR is changed.\n  bool run();\n\n  // Visitation implementation - Implement instruction combining for different\n  // instruction types.  The semantics are as follows:\n  // Return Value:\n  //    null        - No change was made\n  //     I          - Change was made, I is still valid, I may be dead though\n  //   otherwise    - Change was made, replace I with returned instruction\n  //\n  Instruction *visitFNeg(UnaryOperator &I);\n  Instruction *visitAdd(BinaryOperator &I);\n  Instruction *visitFAdd(BinaryOperator &I);\n  Value *OptimizePointerDifference(\n      Value *LHS, Value *RHS, Type *Ty, bool isNUW);\n  Instruction *visitSub(BinaryOperator &I);\n  Instruction *visitFSub(BinaryOperator &I);\n  Instruction *visitMul(BinaryOperator &I);\n  Instruction *visitFMul(BinaryOperator &I);\n  Instruction *visitURem(BinaryOperator &I);\n  Instruction *visitSRem(BinaryOperator &I);\n  Instruction *visitFRem(BinaryOperator &I);\n  bool simplifyDivRemOfSelectWithZeroOp(BinaryOperator &I);\n  Instruction *commonIRemTransforms(BinaryOperator &I);\n  Instruction *commonIDivTransforms(BinaryOperator &I);\n  Instruction *visitUDiv(BinaryOperator &I);\n  Instruction *visitSDiv(BinaryOperator &I);\n  Instruction *visitFDiv(BinaryOperator &I);\n  Value *simplifyRangeCheck(ICmpInst *Cmp0, ICmpInst *Cmp1, bool Inverted);\n  Instruction *visitAnd(BinaryOperator &I);\n  Instruction *visitOr(BinaryOperator &I);\n  bool sinkNotIntoOtherHandOfAndOrOr(BinaryOperator &I);\n  Instruction *visitXor(BinaryOperator &I);\n  Instruction *visitShl(BinaryOperator &I);\n  Value *reassociateShiftAmtsOfTwoSameDirectionShifts(\n      BinaryOperator *Sh0, const SimplifyQuery &SQ,\n      bool AnalyzeForSignBitExtraction = false);\n  Instruction *canonicalizeCondSignextOfHighBitExtractToSignextHighBitExtract(\n      BinaryOperator &I);\n  Instruction *foldVariableSignZeroExtensionOfVariableHighBitExtract(\n      BinaryOperator &OldAShr);\n  Instruction *visitAShr(BinaryOperator &I);\n  Instruction *visitLShr(BinaryOperator &I);\n  Instruction *commonShiftTransforms(BinaryOperator &I);\n  Instruction *visitFCmpInst(FCmpInst &I);\n  CmpInst *canonicalizeICmpPredicate(CmpInst &I);\n  Instruction *visitICmpInst(ICmpInst &I);\n  Instruction *FoldShiftByConstant(Value *Op0, Constant *Op1,\n                                   BinaryOperator &I);\n  Instruction *commonCastTransforms(CastInst &CI);\n  Instruction *commonPointerCastTransforms(CastInst &CI);\n  Instruction *visitTrunc(TruncInst &CI);\n  Instruction *visitZExt(ZExtInst &CI);\n  Instruction *visitSExt(SExtInst &CI);\n  Instruction *visitFPTrunc(FPTruncInst &CI);\n  Instruction *visitFPExt(CastInst &CI);\n  Instruction *visitFPToUI(FPToUIInst &FI);\n  Instruction *visitFPToSI(FPToSIInst &FI);\n  Instruction *visitUIToFP(CastInst &CI);\n  Instruction *visitSIToFP(CastInst &CI);\n  Instruction *visitPtrToInt(PtrToIntInst &CI);\n  Instruction *visitIntToPtr(IntToPtrInst &CI);\n  Instruction *visitBitCast(BitCastInst &CI);\n  Instruction *visitAddrSpaceCast(AddrSpaceCastInst &CI);\n  Instruction *foldItoFPtoI(CastInst &FI);\n  Instruction *visitSelectInst(SelectInst &SI);\n  Instruction *visitCallInst(CallInst &CI);\n  Instruction *visitInvokeInst(InvokeInst &II);\n  Instruction *visitCallBrInst(CallBrInst &CBI);\n\n  Instruction *SliceUpIllegalIntegerPHI(PHINode &PN);\n  Instruction *visitPHINode(PHINode &PN);\n  Instruction *visitGetElementPtrInst(GetElementPtrInst &GEP);\n  Instruction *visitAllocaInst(AllocaInst &AI);\n  Instruction *visitAllocSite(Instruction &FI);\n  Instruction *visitFree(CallInst &FI);\n  Instruction *visitLoadInst(LoadInst &LI);\n  Instruction *visitStoreInst(StoreInst &SI);\n  Instruction *visitAtomicRMWInst(AtomicRMWInst &SI);\n  Instruction *visitUnconditionalBranchInst(BranchInst &BI);\n  Instruction *visitBranchInst(BranchInst &BI);\n  Instruction *visitFenceInst(FenceInst &FI);\n  Instruction *visitSwitchInst(SwitchInst &SI);\n  Instruction *visitReturnInst(ReturnInst &RI);\n  Instruction *visitUnreachableInst(UnreachableInst &I);\n  Instruction *\n  foldAggregateConstructionIntoAggregateReuse(InsertValueInst &OrigIVI);\n  Instruction *visitInsertValueInst(InsertValueInst &IV);\n  Instruction *visitInsertElementInst(InsertElementInst &IE);\n  Instruction *visitExtractElementInst(ExtractElementInst &EI);\n  Instruction *visitShuffleVectorInst(ShuffleVectorInst &SVI);\n  Instruction *visitExtractValueInst(ExtractValueInst &EV);\n  Instruction *visitLandingPadInst(LandingPadInst &LI);\n  Instruction *visitVAEndInst(VAEndInst &I);\n  Instruction *visitFreeze(FreezeInst &I);\n\n  /// Specify what to return for unhandled instructions.\n  Instruction *visitInstruction(Instruction &I) { return nullptr; }\n\n  /// True when DB dominates all uses of DI except UI.\n  /// UI must be in the same block as DI.\n  /// The routine checks that the DI parent and DB are different.\n  bool dominatesAllUses(const Instruction *DI, const Instruction *UI,\n                        const BasicBlock *DB) const;\n\n  /// Try to replace select with select operand SIOpd in SI-ICmp sequence.\n  bool replacedSelectWithOperand(SelectInst *SI, const ICmpInst *Icmp,\n                                 const unsigned SIOpd);\n\n  LoadInst *combineLoadToNewType(LoadInst &LI, Type *NewTy,\n                                 const Twine &Suffix = \"\");\n\nprivate:\n  bool shouldChangeType(unsigned FromBitWidth, unsigned ToBitWidth) const;\n  bool shouldChangeType(Type *From, Type *To) const;\n  Value *dyn_castNegVal(Value *V) const;\n  Type *FindElementAtOffset(PointerType *PtrTy, int64_t Offset,\n                            SmallVectorImpl<Value *> &NewIndices);\n\n  /// Classify whether a cast is worth optimizing.\n  ///\n  /// This is a helper to decide whether the simplification of\n  /// logic(cast(A), cast(B)) to cast(logic(A, B)) should be performed.\n  ///\n  /// \\param CI The cast we are interested in.\n  ///\n  /// \\return true if this cast actually results in any code being generated and\n  /// if it cannot already be eliminated by some other transformation.\n  bool shouldOptimizeCast(CastInst *CI);\n\n  /// Try to optimize a sequence of instructions checking if an operation\n  /// on LHS and RHS overflows.\n  ///\n  /// If this overflow check is done via one of the overflow check intrinsics,\n  /// then CtxI has to be the call instruction calling that intrinsic.  If this\n  /// overflow check is done by arithmetic followed by a compare, then CtxI has\n  /// to be the arithmetic instruction.\n  ///\n  /// If a simplification is possible, stores the simplified result of the\n  /// operation in OperationResult and result of the overflow check in\n  /// OverflowResult, and return true.  If no simplification is possible,\n  /// returns false.\n  bool OptimizeOverflowCheck(Instruction::BinaryOps BinaryOp, bool IsSigned,\n                             Value *LHS, Value *RHS,\n                             Instruction &CtxI, Value *&OperationResult,\n                             Constant *&OverflowResult);\n\n  Instruction *visitCallBase(CallBase &Call);\n  Instruction *tryOptimizeCall(CallInst *CI);\n  bool transformConstExprCastCall(CallBase &Call);\n  Instruction *transformCallThroughTrampoline(CallBase &Call,\n                                              IntrinsicInst &Tramp);\n\n  Value *simplifyMaskedLoad(IntrinsicInst &II);\n  Instruction *simplifyMaskedStore(IntrinsicInst &II);\n  Instruction *simplifyMaskedGather(IntrinsicInst &II);\n  Instruction *simplifyMaskedScatter(IntrinsicInst &II);\n\n  /// Transform (zext icmp) to bitwise / integer operations in order to\n  /// eliminate it.\n  ///\n  /// \\param ICI The icmp of the (zext icmp) pair we are interested in.\n  /// \\parem CI The zext of the (zext icmp) pair we are interested in.\n  /// \\param DoTransform Pass false to just test whether the given (zext icmp)\n  /// would be transformed. Pass true to actually perform the transformation.\n  ///\n  /// \\return null if the transformation cannot be performed. If the\n  /// transformation can be performed the new instruction that replaces the\n  /// (zext icmp) pair will be returned (if \\p DoTransform is false the\n  /// unmodified \\p ICI will be returned in this case).\n  Instruction *transformZExtICmp(ICmpInst *ICI, ZExtInst &CI,\n                                 bool DoTransform = true);\n\n  Instruction *transformSExtICmp(ICmpInst *ICI, Instruction &CI);\n\n  bool willNotOverflowSignedAdd(const Value *LHS, const Value *RHS,\n                                const Instruction &CxtI) const {\n    return computeOverflowForSignedAdd(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowUnsignedAdd(const Value *LHS, const Value *RHS,\n                                  const Instruction &CxtI) const {\n    return computeOverflowForUnsignedAdd(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowAdd(const Value *LHS, const Value *RHS,\n                          const Instruction &CxtI, bool IsSigned) const {\n    return IsSigned ? willNotOverflowSignedAdd(LHS, RHS, CxtI)\n                    : willNotOverflowUnsignedAdd(LHS, RHS, CxtI);\n  }\n\n  bool willNotOverflowSignedSub(const Value *LHS, const Value *RHS,\n                                const Instruction &CxtI) const {\n    return computeOverflowForSignedSub(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowUnsignedSub(const Value *LHS, const Value *RHS,\n                                  const Instruction &CxtI) const {\n    return computeOverflowForUnsignedSub(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowSub(const Value *LHS, const Value *RHS,\n                          const Instruction &CxtI, bool IsSigned) const {\n    return IsSigned ? willNotOverflowSignedSub(LHS, RHS, CxtI)\n                    : willNotOverflowUnsignedSub(LHS, RHS, CxtI);\n  }\n\n  bool willNotOverflowSignedMul(const Value *LHS, const Value *RHS,\n                                const Instruction &CxtI) const {\n    return computeOverflowForSignedMul(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowUnsignedMul(const Value *LHS, const Value *RHS,\n                                  const Instruction &CxtI) const {\n    return computeOverflowForUnsignedMul(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowMul(const Value *LHS, const Value *RHS,\n                          const Instruction &CxtI, bool IsSigned) const {\n    return IsSigned ? willNotOverflowSignedMul(LHS, RHS, CxtI)\n                    : willNotOverflowUnsignedMul(LHS, RHS, CxtI);\n  }\n\n  bool willNotOverflow(BinaryOperator::BinaryOps Opcode, const Value *LHS,\n                       const Value *RHS, const Instruction &CxtI,\n                       bool IsSigned) const {\n    switch (Opcode) {\n    case Instruction::Add: return willNotOverflowAdd(LHS, RHS, CxtI, IsSigned);\n    case Instruction::Sub: return willNotOverflowSub(LHS, RHS, CxtI, IsSigned);\n    case Instruction::Mul: return willNotOverflowMul(LHS, RHS, CxtI, IsSigned);\n    default: llvm_unreachable(\"Unexpected opcode for overflow query\");\n    }\n  }\n\n  Value *EmitGEPOffset(User *GEP);\n  Instruction *scalarizePHI(ExtractElementInst &EI, PHINode *PN);\n  Instruction *foldCastedBitwiseLogic(BinaryOperator &I);\n  Instruction *narrowBinOp(TruncInst &Trunc);\n  Instruction *narrowMaskedBinOp(BinaryOperator &And);\n  Instruction *narrowMathIfNoOverflow(BinaryOperator &I);\n  Instruction *narrowFunnelShift(TruncInst &Trunc);\n  Instruction *optimizeBitCastFromPhi(CastInst &CI, PHINode *PN);\n  Instruction *matchSAddSubSat(SelectInst &MinMax1);\n\n  void freelyInvertAllUsersOf(Value *V);\n\n  /// Determine if a pair of casts can be replaced by a single cast.\n  ///\n  /// \\param CI1 The first of a pair of casts.\n  /// \\param CI2 The second of a pair of casts.\n  ///\n  /// \\return 0 if the cast pair cannot be eliminated, otherwise returns an\n  /// Instruction::CastOps value for a cast that can replace the pair, casting\n  /// CI1->getSrcTy() to CI2->getDstTy().\n  ///\n  /// \\see CastInst::isEliminableCastPair\n  Instruction::CastOps isEliminableCastPair(const CastInst *CI1,\n                                            const CastInst *CI2);\n\n  Value *foldAndOfICmps(ICmpInst *LHS, ICmpInst *RHS, BinaryOperator &And);\n  Value *foldOrOfICmps(ICmpInst *LHS, ICmpInst *RHS, BinaryOperator &Or);\n  Value *foldXorOfICmps(ICmpInst *LHS, ICmpInst *RHS, BinaryOperator &Xor);\n\n  /// Optimize (fcmp)&(fcmp) or (fcmp)|(fcmp).\n  /// NOTE: Unlike most of instcombine, this returns a Value which should\n  /// already be inserted into the function.\n  Value *foldLogicOfFCmps(FCmpInst *LHS, FCmpInst *RHS, bool IsAnd);\n\n  Value *foldAndOrOfICmpsOfAndWithPow2(ICmpInst *LHS, ICmpInst *RHS,\n                                       BinaryOperator &Logic);\n  Value *matchSelectFromAndOr(Value *A, Value *B, Value *C, Value *D);\n  Value *getSelectCondition(Value *A, Value *B);\n\n  Instruction *foldIntrinsicWithOverflowCommon(IntrinsicInst *II);\n  Instruction *foldFPSignBitOps(BinaryOperator &I);\n\npublic:\n  /// Inserts an instruction \\p New before instruction \\p Old\n  ///\n  /// Also adds the new instruction to the worklist and returns \\p New so that\n  /// it is suitable for use as the return from the visitation patterns.\n  Instruction *InsertNewInstBefore(Instruction *New, Instruction &Old) {\n    assert(New && !New->getParent() &&\n           \"New instruction already inserted into a basic block!\");\n    BasicBlock *BB = Old.getParent();\n    BB->getInstList().insert(Old.getIterator(), New); // Insert inst\n    Worklist.add(New);\n    return New;\n  }\n\n  /// Same as InsertNewInstBefore, but also sets the debug loc.\n  Instruction *InsertNewInstWith(Instruction *New, Instruction &Old) {\n    New->setDebugLoc(Old.getDebugLoc());\n    return InsertNewInstBefore(New, Old);\n  }\n\n  /// A combiner-aware RAUW-like routine.\n  ///\n  /// This method is to be used when an instruction is found to be dead,\n  /// replaceable with another preexisting expression. Here we add all uses of\n  /// I to the worklist, replace all uses of I with the new value, then return\n  /// I, so that the inst combiner will know that I was modified.\n  Instruction *replaceInstUsesWith(Instruction &I, Value *V) {\n    // If there are no uses to replace, then we return nullptr to indicate that\n    // no changes were made to the program.\n    if (I.use_empty()) return nullptr;\n\n    Worklist.pushUsersToWorkList(I); // Add all modified instrs to worklist.\n\n    // If we are replacing the instruction with itself, this must be in a\n    // segment of unreachable code, so just clobber the instruction.\n    if (&I == V)\n      V = UndefValue::get(I.getType());\n\n    LLVM_DEBUG(dbgs() << \"IC: Replacing \" << I << \"\\n\"\n                      << \"    with \" << *V << '\\n');\n\n    I.replaceAllUsesWith(V);\n    MadeIRChange = true;\n    return &I;\n  }\n\n  /// Replace operand of instruction and add old operand to the worklist.\n  Instruction *replaceOperand(Instruction &I, unsigned OpNum, Value *V) {\n    Worklist.addValue(I.getOperand(OpNum));\n    I.setOperand(OpNum, V);\n    return &I;\n  }\n\n  /// Replace use and add the previously used value to the worklist.\n  void replaceUse(Use &U, Value *NewValue) {\n    Worklist.addValue(U);\n    U = NewValue;\n  }\n\n  /// Creates a result tuple for an overflow intrinsic \\p II with a given\n  /// \\p Result and a constant \\p Overflow value.\n  Instruction *CreateOverflowTuple(IntrinsicInst *II, Value *Result,\n                                   Constant *Overflow) {\n    Constant *V[] = {UndefValue::get(Result->getType()), Overflow};\n    StructType *ST = cast<StructType>(II->getType());\n    Constant *Struct = ConstantStruct::get(ST, V);\n    return InsertValueInst::Create(Struct, Result, 0);\n  }\n\n  /// Create and insert the idiom we use to indicate a block is unreachable\n  /// without having to rewrite the CFG from within InstCombine.\n  void CreateNonTerminatorUnreachable(Instruction *InsertAt) {\n    auto &Ctx = InsertAt->getContext();\n    new StoreInst(ConstantInt::getTrue(Ctx),\n                  UndefValue::get(Type::getInt1PtrTy(Ctx)),\n                  InsertAt);\n  }\n\n\n  /// Combiner aware instruction erasure.\n  ///\n  /// When dealing with an instruction that has side effects or produces a void\n  /// value, we can't rely on DCE to delete the instruction. Instead, visit\n  /// methods should return the value returned by this function.\n  Instruction *eraseInstFromFunction(Instruction &I) override {\n    LLVM_DEBUG(dbgs() << \"IC: ERASE \" << I << '\\n');\n    assert(I.use_empty() && \"Cannot erase instruction that is used!\");\n    salvageDebugInfo(I);\n\n    // Make sure that we reprocess all operands now that we reduced their\n    // use counts.\n    for (Use &Operand : I.operands())\n      if (auto *Inst = dyn_cast<Instruction>(Operand))\n        Worklist.add(Inst);\n\n    Worklist.remove(&I);\n    I.eraseFromParent();\n    MadeIRChange = true;\n    return nullptr; // Don't do anything with FI\n  }\n\n  void computeKnownBits(const Value *V, KnownBits &Known,\n                        unsigned Depth, const Instruction *CxtI) const {\n    llvm::computeKnownBits(V, Known, DL, Depth, &AC, CxtI, &DT);\n  }\n\n  KnownBits computeKnownBits(const Value *V, unsigned Depth,\n                             const Instruction *CxtI) const {\n    return llvm::computeKnownBits(V, DL, Depth, &AC, CxtI, &DT);\n  }\n\n  bool isKnownToBeAPowerOfTwo(const Value *V, bool OrZero = false,\n                              unsigned Depth = 0,\n                              const Instruction *CxtI = nullptr) {\n    return llvm::isKnownToBeAPowerOfTwo(V, DL, OrZero, Depth, &AC, CxtI, &DT);\n  }\n\n  bool MaskedValueIsZero(const Value *V, const APInt &Mask, unsigned Depth = 0,\n                         const Instruction *CxtI = nullptr) const {\n    return llvm::MaskedValueIsZero(V, Mask, DL, Depth, &AC, CxtI, &DT);\n  }\n\n  unsigned ComputeNumSignBits(const Value *Op, unsigned Depth = 0,\n                              const Instruction *CxtI = nullptr) const {\n    return llvm::ComputeNumSignBits(Op, DL, Depth, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForUnsignedMul(const Value *LHS,\n                                               const Value *RHS,\n                                               const Instruction *CxtI) const {\n    return llvm::computeOverflowForUnsignedMul(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForSignedMul(const Value *LHS,\n                                             const Value *RHS,\n                                             const Instruction *CxtI) const {\n    return llvm::computeOverflowForSignedMul(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForUnsignedAdd(const Value *LHS,\n                                               const Value *RHS,\n                                               const Instruction *CxtI) const {\n    return llvm::computeOverflowForUnsignedAdd(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForSignedAdd(const Value *LHS,\n                                             const Value *RHS,\n                                             const Instruction *CxtI) const {\n    return llvm::computeOverflowForSignedAdd(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForUnsignedSub(const Value *LHS,\n                                               const Value *RHS,\n                                               const Instruction *CxtI) const {\n    return llvm::computeOverflowForUnsignedSub(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForSignedSub(const Value *LHS, const Value *RHS,\n                                             const Instruction *CxtI) const {\n    return llvm::computeOverflowForSignedSub(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflow(\n      Instruction::BinaryOps BinaryOp, bool IsSigned,\n      Value *LHS, Value *RHS, Instruction *CxtI) const;\n\n  /// Performs a few simplifications for operators which are associative\n  /// or commutative.\n  bool SimplifyAssociativeOrCommutative(BinaryOperator &I);\n\n  /// Tries to simplify binary operations which some other binary\n  /// operation distributes over.\n  ///\n  /// It does this by either by factorizing out common terms (eg \"(A*B)+(A*C)\"\n  /// -> \"A*(B+C)\") or expanding out if this results in simplifications (eg: \"A\n  /// & (B | C) -> (A&B) | (A&C)\" if this is a win).  Returns the simplified\n  /// value, or null if it didn't simplify.\n  Value *SimplifyUsingDistributiveLaws(BinaryOperator &I);\n\n  /// Tries to simplify add operations using the definition of remainder.\n  ///\n  /// The definition of remainder is X % C = X - (X / C ) * C. The add\n  /// expression X % C0 + (( X / C0 ) % C1) * C0 can be simplified to\n  /// X % (C0 * C1)\n  Value *SimplifyAddWithRemainder(BinaryOperator &I);\n\n  // Binary Op helper for select operations where the expression can be\n  // efficiently reorganized.\n  Value *SimplifySelectsFeedingBinaryOp(BinaryOperator &I, Value *LHS,\n                                        Value *RHS);\n\n  /// This tries to simplify binary operations by factorizing out common terms\n  /// (e. g. \"(A*B)+(A*C)\" -> \"A*(B+C)\").\n  Value *tryFactorization(BinaryOperator &, Instruction::BinaryOps, Value *,\n                          Value *, Value *, Value *);\n\n  /// Match a select chain which produces one of three values based on whether\n  /// the LHS is less than, equal to, or greater than RHS respectively.\n  /// Return true if we matched a three way compare idiom. The LHS, RHS, Less,\n  /// Equal and Greater values are saved in the matching process and returned to\n  /// the caller.\n  bool matchThreeWayIntCompare(SelectInst *SI, Value *&LHS, Value *&RHS,\n                               ConstantInt *&Less, ConstantInt *&Equal,\n                               ConstantInt *&Greater);\n\n  /// Attempts to replace V with a simpler value based on the demanded\n  /// bits.\n  Value *SimplifyDemandedUseBits(Value *V, APInt DemandedMask, KnownBits &Known,\n                                 unsigned Depth, Instruction *CxtI);\n  bool SimplifyDemandedBits(Instruction *I, unsigned Op,\n                            const APInt &DemandedMask, KnownBits &Known,\n                            unsigned Depth = 0) override;\n\n  /// Helper routine of SimplifyDemandedUseBits. It computes KnownZero/KnownOne\n  /// bits. It also tries to handle simplifications that can be done based on\n  /// DemandedMask, but without modifying the Instruction.\n  Value *SimplifyMultipleUseDemandedBits(Instruction *I,\n                                         const APInt &DemandedMask,\n                                         KnownBits &Known,\n                                         unsigned Depth, Instruction *CxtI);\n\n  /// Helper routine of SimplifyDemandedUseBits. It tries to simplify demanded\n  /// bit for \"r1 = shr x, c1; r2 = shl r1, c2\" instruction sequence.\n  Value *simplifyShrShlDemandedBits(\n      Instruction *Shr, const APInt &ShrOp1, Instruction *Shl,\n      const APInt &ShlOp1, const APInt &DemandedMask, KnownBits &Known);\n\n  /// Tries to simplify operands to an integer instruction based on its\n  /// demanded bits.\n  bool SimplifyDemandedInstructionBits(Instruction &Inst);\n\n  virtual Value *\n  SimplifyDemandedVectorElts(Value *V, APInt DemandedElts, APInt &UndefElts,\n                             unsigned Depth = 0,\n                             bool AllowMultipleUsers = false) override;\n\n  /// Canonicalize the position of binops relative to shufflevector.\n  Instruction *foldVectorBinop(BinaryOperator &Inst);\n  Instruction *foldVectorSelect(SelectInst &Sel);\n\n  /// Given a binary operator, cast instruction, or select which has a PHI node\n  /// as operand #0, see if we can fold the instruction into the PHI (which is\n  /// only possible if all operands to the PHI are constants).\n  Instruction *foldOpIntoPhi(Instruction &I, PHINode *PN);\n\n  /// Given an instruction with a select as one operand and a constant as the\n  /// other operand, try to fold the binary operator into the select arguments.\n  /// This also works for Cast instructions, which obviously do not have a\n  /// second operand.\n  Instruction *FoldOpIntoSelect(Instruction &Op, SelectInst *SI);\n\n  /// This is a convenience wrapper function for the above two functions.\n  Instruction *foldBinOpIntoSelectOrPhi(BinaryOperator &I);\n\n  Instruction *foldAddWithConstant(BinaryOperator &Add);\n\n  /// Try to rotate an operation below a PHI node, using PHI nodes for\n  /// its operands.\n  Instruction *foldPHIArgOpIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgBinOpIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgInsertValueInstructionIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgExtractValueInstructionIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgGEPIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgLoadIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgZextsIntoPHI(PHINode &PN);\n\n  /// If an integer typed PHI has only one use which is an IntToPtr operation,\n  /// replace the PHI with an existing pointer typed PHI if it exists. Otherwise\n  /// insert a new pointer typed PHI and replace the original one.\n  Instruction *foldIntegerTypedPHI(PHINode &PN);\n\n  /// Helper function for FoldPHIArgXIntoPHI() to set debug location for the\n  /// folded operation.\n  void PHIArgMergedDebugLoc(Instruction *Inst, PHINode &PN);\n\n  Instruction *foldGEPICmp(GEPOperator *GEPLHS, Value *RHS,\n                           ICmpInst::Predicate Cond, Instruction &I);\n  Instruction *foldAllocaCmp(ICmpInst &ICI, const AllocaInst *Alloca,\n                             const Value *Other);\n  Instruction *foldCmpLoadFromIndexedGlobal(GetElementPtrInst *GEP,\n                                            GlobalVariable *GV, CmpInst &ICI,\n                                            ConstantInt *AndCst = nullptr);\n  Instruction *foldFCmpIntToFPConst(FCmpInst &I, Instruction *LHSI,\n                                    Constant *RHSC);\n  Instruction *foldICmpAddOpConst(Value *X, const APInt &C,\n                                  ICmpInst::Predicate Pred);\n  Instruction *foldICmpWithCastOp(ICmpInst &ICI);\n\n  Instruction *foldICmpUsingKnownBits(ICmpInst &Cmp);\n  Instruction *foldICmpWithDominatingICmp(ICmpInst &Cmp);\n  Instruction *foldICmpWithConstant(ICmpInst &Cmp);\n  Instruction *foldICmpInstWithConstant(ICmpInst &Cmp);\n  Instruction *foldICmpInstWithConstantNotInt(ICmpInst &Cmp);\n  Instruction *foldICmpBinOp(ICmpInst &Cmp, const SimplifyQuery &SQ);\n  Instruction *foldICmpEquality(ICmpInst &Cmp);\n  Instruction *foldIRemByPowerOfTwoToBitTest(ICmpInst &I);\n  Instruction *foldSignBitTest(ICmpInst &I);\n  Instruction *foldICmpWithZero(ICmpInst &Cmp);\n\n  Value *foldUnsignedMultiplicationOverflowCheck(ICmpInst &Cmp);\n\n  Instruction *foldICmpSelectConstant(ICmpInst &Cmp, SelectInst *Select,\n                                      ConstantInt *C);\n  Instruction *foldICmpTruncConstant(ICmpInst &Cmp, TruncInst *Trunc,\n                                     const APInt &C);\n  Instruction *foldICmpAndConstant(ICmpInst &Cmp, BinaryOperator *And,\n                                   const APInt &C);\n  Instruction *foldICmpXorConstant(ICmpInst &Cmp, BinaryOperator *Xor,\n                                   const APInt &C);\n  Instruction *foldICmpOrConstant(ICmpInst &Cmp, BinaryOperator *Or,\n                                  const APInt &C);\n  Instruction *foldICmpMulConstant(ICmpInst &Cmp, BinaryOperator *Mul,\n                                   const APInt &C);\n  Instruction *foldICmpShlConstant(ICmpInst &Cmp, BinaryOperator *Shl,\n                                   const APInt &C);\n  Instruction *foldICmpShrConstant(ICmpInst &Cmp, BinaryOperator *Shr,\n                                   const APInt &C);\n  Instruction *foldICmpSRemConstant(ICmpInst &Cmp, BinaryOperator *UDiv,\n                                    const APInt &C);\n  Instruction *foldICmpUDivConstant(ICmpInst &Cmp, BinaryOperator *UDiv,\n                                    const APInt &C);\n  Instruction *foldICmpDivConstant(ICmpInst &Cmp, BinaryOperator *Div,\n                                   const APInt &C);\n  Instruction *foldICmpSubConstant(ICmpInst &Cmp, BinaryOperator *Sub,\n                                   const APInt &C);\n  Instruction *foldICmpAddConstant(ICmpInst &Cmp, BinaryOperator *Add,\n                                   const APInt &C);\n  Instruction *foldICmpAndConstConst(ICmpInst &Cmp, BinaryOperator *And,\n                                     const APInt &C1);\n  Instruction *foldICmpAndShift(ICmpInst &Cmp, BinaryOperator *And,\n                                const APInt &C1, const APInt &C2);\n  Instruction *foldICmpShrConstConst(ICmpInst &I, Value *ShAmt, const APInt &C1,\n                                     const APInt &C2);\n  Instruction *foldICmpShlConstConst(ICmpInst &I, Value *ShAmt, const APInt &C1,\n                                     const APInt &C2);\n\n  Instruction *foldICmpBinOpEqualityWithConstant(ICmpInst &Cmp,\n                                                 BinaryOperator *BO,\n                                                 const APInt &C);\n  Instruction *foldICmpIntrinsicWithConstant(ICmpInst &ICI, IntrinsicInst *II,\n                                             const APInt &C);\n  Instruction *foldICmpEqIntrinsicWithConstant(ICmpInst &ICI, IntrinsicInst *II,\n                                               const APInt &C);\n\n  // Helpers of visitSelectInst().\n  Instruction *foldSelectExtConst(SelectInst &Sel);\n  Instruction *foldSelectOpOp(SelectInst &SI, Instruction *TI, Instruction *FI);\n  Instruction *foldSelectIntoOp(SelectInst &SI, Value *, Value *);\n  Instruction *foldSPFofSPF(Instruction *Inner, SelectPatternFlavor SPF1,\n                            Value *A, Value *B, Instruction &Outer,\n                            SelectPatternFlavor SPF2, Value *C);\n  Instruction *foldSelectInstWithICmp(SelectInst &SI, ICmpInst *ICI);\n  Instruction *foldSelectValueEquivalence(SelectInst &SI, ICmpInst &ICI);\n\n  Value *insertRangeTest(Value *V, const APInt &Lo, const APInt &Hi,\n                         bool isSigned, bool Inside);\n  Instruction *PromoteCastOfAllocation(BitCastInst &CI, AllocaInst &AI);\n  bool mergeStoreIntoSuccessor(StoreInst &SI);\n\n  /// Given an 'or' instruction, check to see if it is part of a\n  /// bswap/bitreverse idiom. If so, return the equivalent bswap/bitreverse\n  /// intrinsic.\n  Instruction *matchBSwapOrBitReverse(BinaryOperator &Or, bool MatchBSwaps,\n                                      bool MatchBitReversals);\n\n  Instruction *SimplifyAnyMemTransfer(AnyMemTransferInst *MI);\n  Instruction *SimplifyAnyMemSet(AnyMemSetInst *MI);\n\n  Value *EvaluateInDifferentType(Value *V, Type *Ty, bool isSigned);\n\n  /// Returns a value X such that Val = X * Scale, or null if none.\n  ///\n  /// If the multiplication is known not to overflow then NoSignedWrap is set.\n  Value *Descale(Value *Val, APInt Scale, bool &NoSignedWrap);\n};\n\nclass Negator final {\n  /// Top-to-bottom, def-to-use negated instruction tree we produced.\n  SmallVector<Instruction *, NegatorMaxNodesSSO> NewInstructions;\n\n  using BuilderTy = IRBuilder<TargetFolder, IRBuilderCallbackInserter>;\n  BuilderTy Builder;\n\n  const DataLayout &DL;\n  AssumptionCache &AC;\n  const DominatorTree &DT;\n\n  const bool IsTrulyNegation;\n\n  SmallDenseMap<Value *, Value *> NegationsCache;\n\n  Negator(LLVMContext &C, const DataLayout &DL, AssumptionCache &AC,\n          const DominatorTree &DT, bool IsTrulyNegation);\n\n#if LLVM_ENABLE_STATS\n  unsigned NumValuesVisitedInThisNegator = 0;\n  ~Negator();\n#endif\n\n  using Result = std::pair<ArrayRef<Instruction *> /*NewInstructions*/,\n                           Value * /*NegatedRoot*/>;\n\n  std::array<Value *, 2> getSortedOperandsOfBinOp(Instruction *I);\n\n  LLVM_NODISCARD Value *visitImpl(Value *V, unsigned Depth);\n\n  LLVM_NODISCARD Value *negate(Value *V, unsigned Depth);\n\n  /// Recurse depth-first and attempt to sink the negation.\n  /// FIXME: use worklist?\n  LLVM_NODISCARD Optional<Result> run(Value *Root);\n\n  Negator(const Negator &) = delete;\n  Negator(Negator &&) = delete;\n  Negator &operator=(const Negator &) = delete;\n  Negator &operator=(Negator &&) = delete;\n\npublic:\n  /// Attempt to negate \\p Root. Retuns nullptr if negation can't be performed,\n  /// otherwise returns negated value.\n  LLVM_NODISCARD static Value *Negate(bool LHSIsZero, Value *Root,\n                                      InstCombinerImpl &IC);\n};\n\n} // end namespace llvm\n\n#undef DEBUG_TYPE\n\n#endif // LLVM_LIB_TRANSFORMS_INSTCOMBINE_INSTCOMBINEINTERNAL_H\n"}}, "reports": [{"events": [{"location": {"col": 32, "file": 4, "line": 2604}, "message": "the definition seen here"}, {"location": {"col": 16, "file": 3, "line": 151}, "message": "differing parameters are named here: ('FI'), in definition: ('MI')"}, {"location": {"col": 16, "file": 3, "line": 151}, "message": "function 'llvm::InstCombinerImpl::visitAllocSite' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "89015e39abda9811b87e1b899e47cca4", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 4, "line": 214}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 3, "line": 190}, "message": "differing parameters are named here: ('FromBitWidth', 'ToBitWidth'), in definition: ('FromWidth', 'ToWidth')"}, {"location": {"col": 8, "file": 3, "line": 190}, "message": "function 'llvm::InstCombinerImpl::shouldChangeType' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "46b15af88ecc66548af12c8498159038", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 32, "file": 4, "line": 1763}, "message": "the definition seen here"}, {"location": {"col": 16, "file": 3, "line": 322}, "message": "differing parameters are named here: ('I'), in definition: ('BO')"}, {"location": {"col": 16, "file": 3, "line": 322}, "message": "function 'llvm::InstCombinerImpl::narrowMathIfNoOverflow' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "bbcf2fae14297859ede0cb199ba1a076", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 24, "file": 4, "line": 875}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 3, "line": 327}, "message": "differing parameters are named here: ('V'), in definition: ('I')"}, {"location": {"col": 8, "file": 3, "line": 327}, "message": "function 'llvm::InstCombinerImpl::freelyInvertAllUsersOf' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "c4b55235a7760d5af416e6c50e6461f3", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
