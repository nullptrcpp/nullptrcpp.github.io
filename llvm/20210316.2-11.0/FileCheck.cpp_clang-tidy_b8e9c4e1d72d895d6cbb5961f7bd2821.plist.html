<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "content": "//===-- llvm/ADT/APInt.h - For Arbitrary Precision Integer -----*- C++ -*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file implements a class to represent arbitrary precision\n/// integral constant values and operations on them.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APINT_H\n#define LLVM_ADT_APINT_H\n\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <string>\n\nnamespace llvm {\nclass FoldingSetNodeID;\nclass StringRef;\nclass hash_code;\nclass raw_ostream;\n\ntemplate <typename T> class SmallVectorImpl;\ntemplate <typename T> class ArrayRef;\ntemplate <typename T> class Optional;\ntemplate <typename T> struct DenseMapInfo;\n\nclass APInt;\n\ninline APInt operator-(APInt);\n\n//===----------------------------------------------------------------------===//\n//                              APInt Class\n//===----------------------------------------------------------------------===//\n\n/// Class for arbitrary precision integers.\n///\n/// APInt is a functional replacement for common case unsigned integer type like\n/// \"unsigned\", \"unsigned long\" or \"uint64_t\", but also allows non-byte-width\n/// integer sizes and large integer value types such as 3-bits, 15-bits, or more\n/// than 64-bits of precision. APInt provides a variety of arithmetic operators\n/// and methods to manipulate integer values of any bit-width. It supports both\n/// the typical integer arithmetic and comparison operations as well as bitwise\n/// manipulation.\n///\n/// The class has several invariants worth noting:\n///   * All bit, byte, and word positions are zero-based.\n///   * Once the bit width is set, it doesn't change except by the Truncate,\n///     SignExtend, or ZeroExtend operations.\n///   * All binary operators must be on APInt instances of the same bit width.\n///     Attempting to use these operators on instances with different bit\n///     widths will yield an assertion.\n///   * The value is stored canonically as an unsigned value. For operations\n///     where it makes a difference, there are both signed and unsigned variants\n///     of the operation. For example, sdiv and udiv. However, because the bit\n///     widths must be the same, operations such as Mul and Add produce the same\n///     results regardless of whether the values are interpreted as signed or\n///     not.\n///   * In general, the class tries to follow the style of computation that LLVM\n///     uses in its IR. This simplifies its use for LLVM.\n///\nclass LLVM_NODISCARD APInt {\npublic:\n  typedef uint64_t WordType;\n\n  /// This enum is used to hold the constants we needed for APInt.\n  enum : unsigned {\n    /// Byte size of a word.\n    APINT_WORD_SIZE = sizeof(WordType),\n    /// Bits in a word.\n    APINT_BITS_PER_WORD = APINT_WORD_SIZE * CHAR_BIT\n  };\n\n  enum class Rounding {\n    DOWN,\n    TOWARD_ZERO,\n    UP,\n  };\n\n  static constexpr WordType WORDTYPE_MAX = ~WordType(0);\n\nprivate:\n  /// This union is used to store the integer value. When the\n  /// integer bit-width <= 64, it uses VAL, otherwise it uses pVal.\n  union {\n    uint64_t VAL;   ///< Used to store the <= 64 bits integer value.\n    uint64_t *pVal; ///< Used to store the >64 bits integer value.\n  } U;\n\n  unsigned BitWidth; ///< The number of bits in this APInt.\n\n  friend struct DenseMapInfo<APInt>;\n\n  friend class APSInt;\n\n  /// Fast internal constructor\n  ///\n  /// This constructor is used only internally for speed of construction of\n  /// temporaries. It is unsafe for general use so it is not public.\n  APInt(uint64_t *val, unsigned bits) : BitWidth(bits) {\n    U.pVal = val;\n  }\n\n  /// Determine if this APInt just has one word to store value.\n  ///\n  /// \\returns true if the number of bits <= 64, false otherwise.\n  bool isSingleWord() const { return BitWidth <= APINT_BITS_PER_WORD; }\n\n  /// Determine which word a bit is in.\n  ///\n  /// \\returns the word position for the specified bit position.\n  static unsigned whichWord(unsigned bitPosition) {\n    return bitPosition / APINT_BITS_PER_WORD;\n  }\n\n  /// Determine which bit in a word a bit is in.\n  ///\n  /// \\returns the bit position in a word for the specified bit position\n  /// in the APInt.\n  static unsigned whichBit(unsigned bitPosition) {\n    return bitPosition % APINT_BITS_PER_WORD;\n  }\n\n  /// Get a single bit mask.\n  ///\n  /// \\returns a uint64_t with only bit at \"whichBit(bitPosition)\" set\n  /// This method generates and returns a uint64_t (word) mask for a single\n  /// bit at a specific bit position. This is used to mask the bit in the\n  /// corresponding word.\n  static uint64_t maskBit(unsigned bitPosition) {\n    return 1ULL << whichBit(bitPosition);\n  }\n\n  /// Clear unused high order bits\n  ///\n  /// This method is used internally to clear the top \"N\" bits in the high order\n  /// word that are not used by the APInt. This is needed after the most\n  /// significant word is assigned a value to ensure that those bits are\n  /// zero'd out.\n  APInt &clearUnusedBits() {\n    // Compute how many bits are used in the final word\n    unsigned WordBits = ((BitWidth-1) % APINT_BITS_PER_WORD) + 1;\n\n    // Mask out the high bits.\n    uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - WordBits);\n    if (isSingleWord())\n      U.VAL &= mask;\n    else\n      U.pVal[getNumWords() - 1] &= mask;\n    return *this;\n  }\n\n  /// Get the word corresponding to a bit position\n  /// \\returns the corresponding word for the specified bit position.\n  uint64_t getWord(unsigned bitPosition) const {\n    return isSingleWord() ? U.VAL : U.pVal[whichWord(bitPosition)];\n  }\n\n  /// Utility method to change the bit width of this APInt to new bit width,\n  /// allocating and/or deallocating as necessary. There is no guarantee on the\n  /// value of any bits upon return. Caller should populate the bits after.\n  void reallocate(unsigned NewBitWidth);\n\n  /// Convert a char array into an APInt\n  ///\n  /// \\param radix 2, 8, 10, 16, or 36\n  /// Converts a string into a number.  The string must be non-empty\n  /// and well-formed as a number of the given base. The bit-width\n  /// must be sufficient to hold the result.\n  ///\n  /// This is used by the constructors that take string arguments.\n  ///\n  /// StringRef::getAsInteger is superficially similar but (1) does\n  /// not assume that the string is well-formed and (2) grows the\n  /// result to hold the input.\n  void fromString(unsigned numBits, StringRef str, uint8_t radix);\n\n  /// An internal division function for dividing APInts.\n  ///\n  /// This is used by the toString method to divide by the radix. It simply\n  /// provides a more convenient form of divide for internal use since KnuthDiv\n  /// has specific constraints on its inputs. If those constraints are not met\n  /// then it provides a simpler form of divide.\n  static void divide(const WordType *LHS, unsigned lhsWords,\n                     const WordType *RHS, unsigned rhsWords, WordType *Quotient,\n                     WordType *Remainder);\n\n  /// out-of-line slow case for inline constructor\n  void initSlowCase(uint64_t val, bool isSigned);\n\n  /// shared code between two array constructors\n  void initFromArray(ArrayRef<uint64_t> array);\n\n  /// out-of-line slow case for inline copy constructor\n  void initSlowCase(const APInt &that);\n\n  /// out-of-line slow case for shl\n  void shlSlowCase(unsigned ShiftAmt);\n\n  /// out-of-line slow case for lshr.\n  void lshrSlowCase(unsigned ShiftAmt);\n\n  /// out-of-line slow case for ashr.\n  void ashrSlowCase(unsigned ShiftAmt);\n\n  /// out-of-line slow case for operator=\n  void AssignSlowCase(const APInt &RHS);\n\n  /// out-of-line slow case for operator==\n  bool EqualSlowCase(const APInt &RHS) const LLVM_READONLY;\n\n  /// out-of-line slow case for countLeadingZeros\n  unsigned countLeadingZerosSlowCase() const LLVM_READONLY;\n\n  /// out-of-line slow case for countLeadingOnes.\n  unsigned countLeadingOnesSlowCase() const LLVM_READONLY;\n\n  /// out-of-line slow case for countTrailingZeros.\n  unsigned countTrailingZerosSlowCase() const LLVM_READONLY;\n\n  /// out-of-line slow case for countTrailingOnes\n  unsigned countTrailingOnesSlowCase() const LLVM_READONLY;\n\n  /// out-of-line slow case for countPopulation\n  unsigned countPopulationSlowCase() const LLVM_READONLY;\n\n  /// out-of-line slow case for intersects.\n  bool intersectsSlowCase(const APInt &RHS) const LLVM_READONLY;\n\n  /// out-of-line slow case for isSubsetOf.\n  bool isSubsetOfSlowCase(const APInt &RHS) const LLVM_READONLY;\n\n  /// out-of-line slow case for setBits.\n  void setBitsSlowCase(unsigned loBit, unsigned hiBit);\n\n  /// out-of-line slow case for flipAllBits.\n  void flipAllBitsSlowCase();\n\n  /// out-of-line slow case for operator&=.\n  void AndAssignSlowCase(const APInt& RHS);\n\n  /// out-of-line slow case for operator|=.\n  void OrAssignSlowCase(const APInt& RHS);\n\n  /// out-of-line slow case for operator^=.\n  void XorAssignSlowCase(const APInt& RHS);\n\n  /// Unsigned comparison. Returns -1, 0, or 1 if this APInt is less than, equal\n  /// to, or greater than RHS.\n  int compare(const APInt &RHS) const LLVM_READONLY;\n\n  /// Signed comparison. Returns -1, 0, or 1 if this APInt is less than, equal\n  /// to, or greater than RHS.\n  int compareSigned(const APInt &RHS) const LLVM_READONLY;\n\npublic:\n  /// \\name Constructors\n  /// @{\n\n  /// Create a new APInt of numBits width, initialized as val.\n  ///\n  /// If isSigned is true then val is treated as if it were a signed value\n  /// (i.e. as an int64_t) and the appropriate sign extension to the bit width\n  /// will be done. Otherwise, no sign extension occurs (high order bits beyond\n  /// the range of val are zero filled).\n  ///\n  /// \\param numBits the bit width of the constructed APInt\n  /// \\param val the initial value of the APInt\n  /// \\param isSigned how to treat signedness of val\n  APInt(unsigned numBits, uint64_t val, bool isSigned = false)\n      : BitWidth(numBits) {\n    assert(BitWidth && \"bitwidth too small\");\n    if (isSingleWord()) {\n      U.VAL = val;\n      clearUnusedBits();\n    } else {\n      initSlowCase(val, isSigned);\n    }\n  }\n\n  /// Construct an APInt of numBits width, initialized as bigVal[].\n  ///\n  /// Note that bigVal.size() can be smaller or larger than the corresponding\n  /// bit width but any extraneous bits will be dropped.\n  ///\n  /// \\param numBits the bit width of the constructed APInt\n  /// \\param bigVal a sequence of words to form the initial value of the APInt\n  APInt(unsigned numBits, ArrayRef<uint64_t> bigVal);\n\n  /// Equivalent to APInt(numBits, ArrayRef<uint64_t>(bigVal, numWords)), but\n  /// deprecated because this constructor is prone to ambiguity with the\n  /// APInt(unsigned, uint64_t, bool) constructor.\n  ///\n  /// If this overload is ever deleted, care should be taken to prevent calls\n  /// from being incorrectly captured by the APInt(unsigned, uint64_t, bool)\n  /// constructor.\n  APInt(unsigned numBits, unsigned numWords, const uint64_t bigVal[]);\n\n  /// Construct an APInt from a string representation.\n  ///\n  /// This constructor interprets the string \\p str in the given radix. The\n  /// interpretation stops when the first character that is not suitable for the\n  /// radix is encountered, or the end of the string. Acceptable radix values\n  /// are 2, 8, 10, 16, and 36. It is an error for the value implied by the\n  /// string to require more bits than numBits.\n  ///\n  /// \\param numBits the bit width of the constructed APInt\n  /// \\param str the string to be interpreted\n  /// \\param radix the radix to use for the conversion\n  APInt(unsigned numBits, StringRef str, uint8_t radix);\n\n  /// Simply makes *this a copy of that.\n  /// Copy Constructor.\n  APInt(const APInt &that) : BitWidth(that.BitWidth) {\n    if (isSingleWord())\n      U.VAL = that.U.VAL;\n    else\n      initSlowCase(that);\n  }\n\n  /// Move Constructor.\n  APInt(APInt &&that) : BitWidth(that.BitWidth) {\n    memcpy(&U, &that.U, sizeof(U));\n    that.BitWidth = 0;\n  }\n\n  /// Destructor.\n  ~APInt() {\n    if (needsCleanup())\n      delete[] U.pVal;\n  }\n\n  /// Default constructor that creates an uninteresting APInt\n  /// representing a 1-bit zero value.\n  ///\n  /// This is useful for object deserialization (pair this with the static\n  ///  method Read).\n  explicit APInt() : BitWidth(1) { U.VAL = 0; }\n\n  /// Returns whether this instance allocated memory.\n  bool needsCleanup() const { return !isSingleWord(); }\n\n  /// Used to insert APInt objects, or objects that contain APInt objects, into\n  ///  FoldingSets.\n  void Profile(FoldingSetNodeID &id) const;\n\n  /// @}\n  /// \\name Value Tests\n  /// @{\n\n  /// Determine sign of this APInt.\n  ///\n  /// This tests the high bit of this APInt to determine if it is set.\n  ///\n  /// \\returns true if this APInt is negative, false otherwise\n  bool isNegative() const { return (*this)[BitWidth - 1]; }\n\n  /// Determine if this APInt Value is non-negative (>= 0)\n  ///\n  /// This tests the high bit of the APInt to determine if it is unset.\n  bool isNonNegative() const { return !isNegative(); }\n\n  /// Determine if sign bit of this APInt is set.\n  ///\n  /// This tests the high bit of this APInt to determine if it is set.\n  ///\n  /// \\returns true if this APInt has its sign bit set, false otherwise.\n  bool isSignBitSet() const { return (*this)[BitWidth-1]; }\n\n  /// Determine if sign bit of this APInt is clear.\n  ///\n  /// This tests the high bit of this APInt to determine if it is clear.\n  ///\n  /// \\returns true if this APInt has its sign bit clear, false otherwise.\n  bool isSignBitClear() const { return !isSignBitSet(); }\n\n  /// Determine if this APInt Value is positive.\n  ///\n  /// This tests if the value of this APInt is positive (> 0). Note\n  /// that 0 is not a positive value.\n  ///\n  /// \\returns true if this APInt is positive.\n  bool isStrictlyPositive() const { return isNonNegative() && !isNullValue(); }\n\n  /// Determine if this APInt Value is non-positive (<= 0).\n  ///\n  /// \\returns true if this APInt is non-positive.\n  bool isNonPositive() const { return !isStrictlyPositive(); }\n\n  /// Determine if all bits are set\n  ///\n  /// This checks to see if the value has all bits of the APInt are set or not.\n  bool isAllOnesValue() const {\n    if (isSingleWord())\n      return U.VAL == WORDTYPE_MAX >> (APINT_BITS_PER_WORD - BitWidth);\n    return countTrailingOnesSlowCase() == BitWidth;\n  }\n\n  /// Determine if all bits are clear\n  ///\n  /// This checks to see if the value has all bits of the APInt are clear or\n  /// not.\n  bool isNullValue() const { return !*this; }\n\n  /// Determine if this is a value of 1.\n  ///\n  /// This checks to see if the value of this APInt is one.\n  bool isOneValue() const {\n    if (isSingleWord())\n      return U.VAL == 1;\n    return countLeadingZerosSlowCase() == BitWidth - 1;\n  }\n\n  /// Determine if this is the largest unsigned value.\n  ///\n  /// This checks to see if the value of this APInt is the maximum unsigned\n  /// value for the APInt's bit width.\n  bool isMaxValue() const { return isAllOnesValue(); }\n\n  /// Determine if this is the largest signed value.\n  ///\n  /// This checks to see if the value of this APInt is the maximum signed\n  /// value for the APInt's bit width.\n  bool isMaxSignedValue() const {\n    if (isSingleWord())\n      return U.VAL == ((WordType(1) << (BitWidth - 1)) - 1);\n    return !isNegative() && countTrailingOnesSlowCase() == BitWidth - 1;\n  }\n\n  /// Determine if this is the smallest unsigned value.\n  ///\n  /// This checks to see if the value of this APInt is the minimum unsigned\n  /// value for the APInt's bit width.\n  bool isMinValue() const { return isNullValue(); }\n\n  /// Determine if this is the smallest signed value.\n  ///\n  /// This checks to see if the value of this APInt is the minimum signed\n  /// value for the APInt's bit width.\n  bool isMinSignedValue() const {\n    if (isSingleWord())\n      return U.VAL == (WordType(1) << (BitWidth - 1));\n    return isNegative() && countTrailingZerosSlowCase() == BitWidth - 1;\n  }\n\n  /// Check if this APInt has an N-bits unsigned integer value.\n  bool isIntN(unsigned N) const {\n    assert(N && \"N == 0 ???\");\n    return getActiveBits() <= N;\n  }\n\n  /// Check if this APInt has an N-bits signed integer value.\n  bool isSignedIntN(unsigned N) const {\n    assert(N && \"N == 0 ???\");\n    return getMinSignedBits() <= N;\n  }\n\n  /// Check if this APInt's value is a power of two greater than zero.\n  ///\n  /// \\returns true if the argument APInt value is a power of two > 0.\n  bool isPowerOf2() const {\n    if (isSingleWord())\n      return isPowerOf2_64(U.VAL);\n    return countPopulationSlowCase() == 1;\n  }\n\n  /// Check if the APInt's value is returned by getSignMask.\n  ///\n  /// \\returns true if this is the value returned by getSignMask.\n  bool isSignMask() const { return isMinSignedValue(); }\n\n  /// Convert APInt to a boolean value.\n  ///\n  /// This converts the APInt to a boolean value as a test against zero.\n  bool getBoolValue() const { return !!*this; }\n\n  /// If this value is smaller than the specified limit, return it, otherwise\n  /// return the limit value.  This causes the value to saturate to the limit.\n  uint64_t getLimitedValue(uint64_t Limit = UINT64_MAX) const {\n    return ugt(Limit) ? Limit : getZExtValue();\n  }\n\n  /// Check if the APInt consists of a repeated bit pattern.\n  ///\n  /// e.g. 0x01010101 satisfies isSplat(8).\n  /// \\param SplatSizeInBits The size of the pattern in bits. Must divide bit\n  /// width without remainder.\n  bool isSplat(unsigned SplatSizeInBits) const;\n\n  /// \\returns true if this APInt value is a sequence of \\param numBits ones\n  /// starting at the least significant bit with the remainder zero.\n  bool isMask(unsigned numBits) const {\n    assert(numBits != 0 && \"numBits must be non-zero\");\n    assert(numBits <= BitWidth && \"numBits out of range\");\n    if (isSingleWord())\n      return U.VAL == (WORDTYPE_MAX >> (APINT_BITS_PER_WORD - numBits));\n    unsigned Ones = countTrailingOnesSlowCase();\n    return (numBits == Ones) &&\n           ((Ones + countLeadingZerosSlowCase()) == BitWidth);\n  }\n\n  /// \\returns true if this APInt is a non-empty sequence of ones starting at\n  /// the least significant bit with the remainder zero.\n  /// Ex. isMask(0x0000FFFFU) == true.\n  bool isMask() const {\n    if (isSingleWord())\n      return isMask_64(U.VAL);\n    unsigned Ones = countTrailingOnesSlowCase();\n    return (Ones > 0) && ((Ones + countLeadingZerosSlowCase()) == BitWidth);\n  }\n\n  /// Return true if this APInt value contains a sequence of ones with\n  /// the remainder zero.\n  bool isShiftedMask() const {\n    if (isSingleWord())\n      return isShiftedMask_64(U.VAL);\n    unsigned Ones = countPopulationSlowCase();\n    unsigned LeadZ = countLeadingZerosSlowCase();\n    return (Ones + LeadZ + countTrailingZeros()) == BitWidth;\n  }\n\n  /// @}\n  /// \\name Value Generators\n  /// @{\n\n  /// Gets maximum unsigned value of APInt for specific bit width.\n  static APInt getMaxValue(unsigned numBits) {\n    return getAllOnesValue(numBits);\n  }\n\n  /// Gets maximum signed value of APInt for a specific bit width.\n  static APInt getSignedMaxValue(unsigned numBits) {\n    APInt API = getAllOnesValue(numBits);\n    API.clearBit(numBits - 1);\n    return API;\n  }\n\n  /// Gets minimum unsigned value of APInt for a specific bit width.\n  static APInt getMinValue(unsigned numBits) { return APInt(numBits, 0); }\n\n  /// Gets minimum signed value of APInt for a specific bit width.\n  static APInt getSignedMinValue(unsigned numBits) {\n    APInt API(numBits, 0);\n    API.setBit(numBits - 1);\n    return API;\n  }\n\n  /// Get the SignMask for a specific bit width.\n  ///\n  /// This is just a wrapper function of getSignedMinValue(), and it helps code\n  /// readability when we want to get a SignMask.\n  static APInt getSignMask(unsigned BitWidth) {\n    return getSignedMinValue(BitWidth);\n  }\n\n  /// Get the all-ones value.\n  ///\n  /// \\returns the all-ones value for an APInt of the specified bit-width.\n  static APInt getAllOnesValue(unsigned numBits) {\n    return APInt(numBits, WORDTYPE_MAX, true);\n  }\n\n  /// Get the '0' value.\n  ///\n  /// \\returns the '0' value for an APInt of the specified bit-width.\n  static APInt getNullValue(unsigned numBits) { return APInt(numBits, 0); }\n\n  /// Compute an APInt containing numBits highbits from this APInt.\n  ///\n  /// Get an APInt with the same BitWidth as this APInt, just zero mask\n  /// the low bits and right shift to the least significant bit.\n  ///\n  /// \\returns the high \"numBits\" bits of this APInt.\n  APInt getHiBits(unsigned numBits) const;\n\n  /// Compute an APInt containing numBits lowbits from this APInt.\n  ///\n  /// Get an APInt with the same BitWidth as this APInt, just zero mask\n  /// the high bits.\n  ///\n  /// \\returns the low \"numBits\" bits of this APInt.\n  APInt getLoBits(unsigned numBits) const;\n\n  /// Return an APInt with exactly one bit set in the result.\n  static APInt getOneBitSet(unsigned numBits, unsigned BitNo) {\n    APInt Res(numBits, 0);\n    Res.setBit(BitNo);\n    return Res;\n  }\n\n  /// Get a value with a block of bits set.\n  ///\n  /// Constructs an APInt value that has a contiguous range of bits set. The\n  /// bits from loBit (inclusive) to hiBit (exclusive) will be set. All other\n  /// bits will be zero. For example, with parameters(32, 0, 16) you would get\n  /// 0x0000FFFF. Please call getBitsSetWithWrap if \\p loBit may be greater than\n  /// \\p hiBit.\n  ///\n  /// \\param numBits the intended bit width of the result\n  /// \\param loBit the index of the lowest bit set.\n  /// \\param hiBit the index of the highest bit set.\n  ///\n  /// \\returns An APInt value with the requested bits set.\n  static APInt getBitsSet(unsigned numBits, unsigned loBit, unsigned hiBit) {\n    assert(loBit <= hiBit && \"loBit greater than hiBit\");\n    APInt Res(numBits, 0);\n    Res.setBits(loBit, hiBit);\n    return Res;\n  }\n\n  /// Wrap version of getBitsSet.\n  /// If \\p hiBit is bigger than \\p loBit, this is same with getBitsSet.\n  /// If \\p hiBit is not bigger than \\p loBit, the set bits \"wrap\". For example,\n  /// with parameters (32, 28, 4), you would get 0xF000000F.\n  /// If \\p hiBit is equal to \\p loBit, you would get a result with all bits\n  /// set.\n  static APInt getBitsSetWithWrap(unsigned numBits, unsigned loBit,\n                                  unsigned hiBit) {\n    APInt Res(numBits, 0);\n    Res.setBitsWithWrap(loBit, hiBit);\n    return Res;\n  }\n\n  /// Get a value with upper bits starting at loBit set.\n  ///\n  /// Constructs an APInt value that has a contiguous range of bits set. The\n  /// bits from loBit (inclusive) to numBits (exclusive) will be set. All other\n  /// bits will be zero. For example, with parameters(32, 12) you would get\n  /// 0xFFFFF000.\n  ///\n  /// \\param numBits the intended bit width of the result\n  /// \\param loBit the index of the lowest bit to set.\n  ///\n  /// \\returns An APInt value with the requested bits set.\n  static APInt getBitsSetFrom(unsigned numBits, unsigned loBit) {\n    APInt Res(numBits, 0);\n    Res.setBitsFrom(loBit);\n    return Res;\n  }\n\n  /// Get a value with high bits set\n  ///\n  /// Constructs an APInt value that has the top hiBitsSet bits set.\n  ///\n  /// \\param numBits the bitwidth of the result\n  /// \\param hiBitsSet the number of high-order bits set in the result.\n  static APInt getHighBitsSet(unsigned numBits, unsigned hiBitsSet) {\n    APInt Res(numBits, 0);\n    Res.setHighBits(hiBitsSet);\n    return Res;\n  }\n\n  /// Get a value with low bits set\n  ///\n  /// Constructs an APInt value that has the bottom loBitsSet bits set.\n  ///\n  /// \\param numBits the bitwidth of the result\n  /// \\param loBitsSet the number of low-order bits set in the result.\n  static APInt getLowBitsSet(unsigned numBits, unsigned loBitsSet) {\n    APInt Res(numBits, 0);\n    Res.setLowBits(loBitsSet);\n    return Res;\n  }\n\n  /// Return a value containing V broadcasted over NewLen bits.\n  static APInt getSplat(unsigned NewLen, const APInt &V);\n\n  /// Determine if two APInts have the same value, after zero-extending\n  /// one of them (if needed!) to ensure that the bit-widths match.\n  static bool isSameValue(const APInt &I1, const APInt &I2) {\n    if (I1.getBitWidth() == I2.getBitWidth())\n      return I1 == I2;\n\n    if (I1.getBitWidth() > I2.getBitWidth())\n      return I1 == I2.zext(I1.getBitWidth());\n\n    return I1.zext(I2.getBitWidth()) == I2;\n  }\n\n  /// Overload to compute a hash_code for an APInt value.\n  friend hash_code hash_value(const APInt &Arg);\n\n  /// This function returns a pointer to the internal storage of the APInt.\n  /// This is useful for writing out the APInt in binary form without any\n  /// conversions.\n  const uint64_t *getRawData() const {\n    if (isSingleWord())\n      return &U.VAL;\n    return &U.pVal[0];\n  }\n\n  /// @}\n  /// \\name Unary Operators\n  /// @{\n\n  /// Postfix increment operator.\n  ///\n  /// Increments *this by 1.\n  ///\n  /// \\returns a new APInt value representing the original value of *this.\n  const APInt operator++(int) {\n    APInt API(*this);\n    ++(*this);\n    return API;\n  }\n\n  /// Prefix increment operator.\n  ///\n  /// \\returns *this incremented by one\n  APInt &operator++();\n\n  /// Postfix decrement operator.\n  ///\n  /// Decrements *this by 1.\n  ///\n  /// \\returns a new APInt value representing the original value of *this.\n  const APInt operator--(int) {\n    APInt API(*this);\n    --(*this);\n    return API;\n  }\n\n  /// Prefix decrement operator.\n  ///\n  /// \\returns *this decremented by one.\n  APInt &operator--();\n\n  /// Logical negation operator.\n  ///\n  /// Performs logical negation operation on this APInt.\n  ///\n  /// \\returns true if *this is zero, false otherwise.\n  bool operator!() const {\n    if (isSingleWord())\n      return U.VAL == 0;\n    return countLeadingZerosSlowCase() == BitWidth;\n  }\n\n  /// @}\n  /// \\name Assignment Operators\n  /// @{\n\n  /// Copy assignment operator.\n  ///\n  /// \\returns *this after assignment of RHS.\n  APInt &operator=(const APInt &RHS) {\n    // If the bitwidths are the same, we can avoid mucking with memory\n    if (isSingleWord() && RHS.isSingleWord()) {\n      U.VAL = RHS.U.VAL;\n      BitWidth = RHS.BitWidth;\n      return clearUnusedBits();\n    }\n\n    AssignSlowCase(RHS);\n    return *this;\n  }\n\n  /// Move assignment operator.\n  APInt &operator=(APInt &&that) {\n#ifdef EXPENSIVE_CHECKS\n    // Some std::shuffle implementations still do self-assignment.\n    if (this == &that)\n      return *this;\n#endif\n    assert(this != &that && \"Self-move not supported\");\n    if (!isSingleWord())\n      delete[] U.pVal;\n\n    // Use memcpy so that type based alias analysis sees both VAL and pVal\n    // as modified.\n    memcpy(&U, &that.U, sizeof(U));\n\n    BitWidth = that.BitWidth;\n    that.BitWidth = 0;\n\n    return *this;\n  }\n\n  /// Assignment operator.\n  ///\n  /// The RHS value is assigned to *this. If the significant bits in RHS exceed\n  /// the bit width, the excess bits are truncated. If the bit width is larger\n  /// than 64, the value is zero filled in the unspecified high order bits.\n  ///\n  /// \\returns *this after assignment of RHS value.\n  APInt &operator=(uint64_t RHS) {\n    if (isSingleWord()) {\n      U.VAL = RHS;\n      return clearUnusedBits();\n    }\n    U.pVal[0] = RHS;\n    memset(U.pVal + 1, 0, (getNumWords() - 1) * APINT_WORD_SIZE);\n    return *this;\n  }\n\n  /// Bitwise AND assignment operator.\n  ///\n  /// Performs a bitwise AND operation on this APInt and RHS. The result is\n  /// assigned to *this.\n  ///\n  /// \\returns *this after ANDing with RHS.\n  APInt &operator&=(const APInt &RHS) {\n    assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n    if (isSingleWord())\n      U.VAL &= RHS.U.VAL;\n    else\n      AndAssignSlowCase(RHS);\n    return *this;\n  }\n\n  /// Bitwise AND assignment operator.\n  ///\n  /// Performs a bitwise AND operation on this APInt and RHS. RHS is\n  /// logically zero-extended or truncated to match the bit-width of\n  /// the LHS.\n  APInt &operator&=(uint64_t RHS) {\n    if (isSingleWord()) {\n      U.VAL &= RHS;\n      return *this;\n    }\n    U.pVal[0] &= RHS;\n    memset(U.pVal+1, 0, (getNumWords() - 1) * APINT_WORD_SIZE);\n    return *this;\n  }\n\n  /// Bitwise OR assignment operator.\n  ///\n  /// Performs a bitwise OR operation on this APInt and RHS. The result is\n  /// assigned *this;\n  ///\n  /// \\returns *this after ORing with RHS.\n  APInt &operator|=(const APInt &RHS) {\n    assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n    if (isSingleWord())\n      U.VAL |= RHS.U.VAL;\n    else\n      OrAssignSlowCase(RHS);\n    return *this;\n  }\n\n  /// Bitwise OR assignment operator.\n  ///\n  /// Performs a bitwise OR operation on this APInt and RHS. RHS is\n  /// logically zero-extended or truncated to match the bit-width of\n  /// the LHS.\n  APInt &operator|=(uint64_t RHS) {\n    if (isSingleWord()) {\n      U.VAL |= RHS;\n      return clearUnusedBits();\n    }\n    U.pVal[0] |= RHS;\n    return *this;\n  }\n\n  /// Bitwise XOR assignment operator.\n  ///\n  /// Performs a bitwise XOR operation on this APInt and RHS. The result is\n  /// assigned to *this.\n  ///\n  /// \\returns *this after XORing with RHS.\n  APInt &operator^=(const APInt &RHS) {\n    assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n    if (isSingleWord())\n      U.VAL ^= RHS.U.VAL;\n    else\n      XorAssignSlowCase(RHS);\n    return *this;\n  }\n\n  /// Bitwise XOR assignment operator.\n  ///\n  /// Performs a bitwise XOR operation on this APInt and RHS. RHS is\n  /// logically zero-extended or truncated to match the bit-width of\n  /// the LHS.\n  APInt &operator^=(uint64_t RHS) {\n    if (isSingleWord()) {\n      U.VAL ^= RHS;\n      return clearUnusedBits();\n    }\n    U.pVal[0] ^= RHS;\n    return *this;\n  }\n\n  /// Multiplication assignment operator.\n  ///\n  /// Multiplies this APInt by RHS and assigns the result to *this.\n  ///\n  /// \\returns *this\n  APInt &operator*=(const APInt &RHS);\n  APInt &operator*=(uint64_t RHS);\n\n  /// Addition assignment operator.\n  ///\n  /// Adds RHS to *this and assigns the result to *this.\n  ///\n  /// \\returns *this\n  APInt &operator+=(const APInt &RHS);\n  APInt &operator+=(uint64_t RHS);\n\n  /// Subtraction assignment operator.\n  ///\n  /// Subtracts RHS from *this and assigns the result to *this.\n  ///\n  /// \\returns *this\n  APInt &operator-=(const APInt &RHS);\n  APInt &operator-=(uint64_t RHS);\n\n  /// Left-shift assignment function.\n  ///\n  /// Shifts *this left by shiftAmt and assigns the result to *this.\n  ///\n  /// \\returns *this after shifting left by ShiftAmt\n  APInt &operator<<=(unsigned ShiftAmt) {\n    assert(ShiftAmt <= BitWidth && \"Invalid shift amount\");\n    if (isSingleWord()) {\n      if (ShiftAmt == BitWidth)\n        U.VAL = 0;\n      else\n        U.VAL <<= ShiftAmt;\n      return clearUnusedBits();\n    }\n    shlSlowCase(ShiftAmt);\n    return *this;\n  }\n\n  /// Left-shift assignment function.\n  ///\n  /// Shifts *this left by shiftAmt and assigns the result to *this.\n  ///\n  /// \\returns *this after shifting left by ShiftAmt\n  APInt &operator<<=(const APInt &ShiftAmt);\n\n  /// @}\n  /// \\name Binary Operators\n  /// @{\n\n  /// Multiplication operator.\n  ///\n  /// Multiplies this APInt by RHS and returns the result.\n  APInt operator*(const APInt &RHS) const;\n\n  /// Left logical shift operator.\n  ///\n  /// Shifts this APInt left by \\p Bits and returns the result.\n  APInt operator<<(unsigned Bits) const { return shl(Bits); }\n\n  /// Left logical shift operator.\n  ///\n  /// Shifts this APInt left by \\p Bits and returns the result.\n  APInt operator<<(const APInt &Bits) const { return shl(Bits); }\n\n  /// Arithmetic right-shift function.\n  ///\n  /// Arithmetic right-shift this APInt by shiftAmt.\n  APInt ashr(unsigned ShiftAmt) const {\n    APInt R(*this);\n    R.ashrInPlace(ShiftAmt);\n    return R;\n  }\n\n  /// Arithmetic right-shift this APInt by ShiftAmt in place.\n  void ashrInPlace(unsigned ShiftAmt) {\n    assert(ShiftAmt <= BitWidth && \"Invalid shift amount\");\n    if (isSingleWord()) {\n      int64_t SExtVAL = SignExtend64(U.VAL, BitWidth);\n      if (ShiftAmt == BitWidth)\n        U.VAL = SExtVAL >> (APINT_BITS_PER_WORD - 1); // Fill with sign bit.\n      else\n        U.VAL = SExtVAL >> ShiftAmt;\n      clearUnusedBits();\n      return;\n    }\n    ashrSlowCase(ShiftAmt);\n  }\n\n  /// Logical right-shift function.\n  ///\n  /// Logical right-shift this APInt by shiftAmt.\n  APInt lshr(unsigned shiftAmt) const {\n    APInt R(*this);\n    R.lshrInPlace(shiftAmt);\n    return R;\n  }\n\n  /// Logical right-shift this APInt by ShiftAmt in place.\n  void lshrInPlace(unsigned ShiftAmt) {\n    assert(ShiftAmt <= BitWidth && \"Invalid shift amount\");\n    if (isSingleWord()) {\n      if (ShiftAmt == BitWidth)\n        U.VAL = 0;\n      else\n        U.VAL >>= ShiftAmt;\n      return;\n    }\n    lshrSlowCase(ShiftAmt);\n  }\n\n  /// Left-shift function.\n  ///\n  /// Left-shift this APInt by shiftAmt.\n  APInt shl(unsigned shiftAmt) const {\n    APInt R(*this);\n    R <<= shiftAmt;\n    return R;\n  }\n\n  /// Rotate left by rotateAmt.\n  APInt rotl(unsigned rotateAmt) const;\n\n  /// Rotate right by rotateAmt.\n  APInt rotr(unsigned rotateAmt) const;\n\n  /// Arithmetic right-shift function.\n  ///\n  /// Arithmetic right-shift this APInt by shiftAmt.\n  APInt ashr(const APInt &ShiftAmt) const {\n    APInt R(*this);\n    R.ashrInPlace(ShiftAmt);\n    return R;\n  }\n\n  /// Arithmetic right-shift this APInt by shiftAmt in place.\n  void ashrInPlace(const APInt &shiftAmt);\n\n  /// Logical right-shift function.\n  ///\n  /// Logical right-shift this APInt by shiftAmt.\n  APInt lshr(const APInt &ShiftAmt) const {\n    APInt R(*this);\n    R.lshrInPlace(ShiftAmt);\n    return R;\n  }\n\n  /// Logical right-shift this APInt by ShiftAmt in place.\n  void lshrInPlace(const APInt &ShiftAmt);\n\n  /// Left-shift function.\n  ///\n  /// Left-shift this APInt by shiftAmt.\n  APInt shl(const APInt &ShiftAmt) const {\n    APInt R(*this);\n    R <<= ShiftAmt;\n    return R;\n  }\n\n  /// Rotate left by rotateAmt.\n  APInt rotl(const APInt &rotateAmt) const;\n\n  /// Rotate right by rotateAmt.\n  APInt rotr(const APInt &rotateAmt) const;\n\n  /// Unsigned division operation.\n  ///\n  /// Perform an unsigned divide operation on this APInt by RHS. Both this and\n  /// RHS are treated as unsigned quantities for purposes of this division.\n  ///\n  /// \\returns a new APInt value containing the division result, rounded towards\n  /// zero.\n  APInt udiv(const APInt &RHS) const;\n  APInt udiv(uint64_t RHS) const;\n\n  /// Signed division function for APInt.\n  ///\n  /// Signed divide this APInt by APInt RHS.\n  ///\n  /// The result is rounded towards zero.\n  APInt sdiv(const APInt &RHS) const;\n  APInt sdiv(int64_t RHS) const;\n\n  /// Unsigned remainder operation.\n  ///\n  /// Perform an unsigned remainder operation on this APInt with RHS being the\n  /// divisor. Both this and RHS are treated as unsigned quantities for purposes\n  /// of this operation. Note that this is a true remainder operation and not a\n  /// modulo operation because the sign follows the sign of the dividend which\n  /// is *this.\n  ///\n  /// \\returns a new APInt value containing the remainder result\n  APInt urem(const APInt &RHS) const;\n  uint64_t urem(uint64_t RHS) const;\n\n  /// Function for signed remainder operation.\n  ///\n  /// Signed remainder operation on APInt.\n  APInt srem(const APInt &RHS) const;\n  int64_t srem(int64_t RHS) const;\n\n  /// Dual division/remainder interface.\n  ///\n  /// Sometimes it is convenient to divide two APInt values and obtain both the\n  /// quotient and remainder. This function does both operations in the same\n  /// computation making it a little more efficient. The pair of input arguments\n  /// may overlap with the pair of output arguments. It is safe to call\n  /// udivrem(X, Y, X, Y), for example.\n  static void udivrem(const APInt &LHS, const APInt &RHS, APInt &Quotient,\n                      APInt &Remainder);\n  static void udivrem(const APInt &LHS, uint64_t RHS, APInt &Quotient,\n                      uint64_t &Remainder);\n\n  static void sdivrem(const APInt &LHS, const APInt &RHS, APInt &Quotient,\n                      APInt &Remainder);\n  static void sdivrem(const APInt &LHS, int64_t RHS, APInt &Quotient,\n                      int64_t &Remainder);\n\n  // Operations that return overflow indicators.\n  APInt sadd_ov(const APInt &RHS, bool &Overflow) const;\n  APInt uadd_ov(const APInt &RHS, bool &Overflow) const;\n  APInt ssub_ov(const APInt &RHS, bool &Overflow) const;\n  APInt usub_ov(const APInt &RHS, bool &Overflow) const;\n  APInt sdiv_ov(const APInt &RHS, bool &Overflow) const;\n  APInt smul_ov(const APInt &RHS, bool &Overflow) const;\n  APInt umul_ov(const APInt &RHS, bool &Overflow) const;\n  APInt sshl_ov(const APInt &Amt, bool &Overflow) const;\n  APInt ushl_ov(const APInt &Amt, bool &Overflow) const;\n\n  // Operations that saturate\n  APInt sadd_sat(const APInt &RHS) const;\n  APInt uadd_sat(const APInt &RHS) const;\n  APInt ssub_sat(const APInt &RHS) const;\n  APInt usub_sat(const APInt &RHS) const;\n  APInt smul_sat(const APInt &RHS) const;\n  APInt umul_sat(const APInt &RHS) const;\n  APInt sshl_sat(const APInt &RHS) const;\n  APInt ushl_sat(const APInt &RHS) const;\n\n  /// Array-indexing support.\n  ///\n  /// \\returns the bit value at bitPosition\n  bool operator[](unsigned bitPosition) const {\n    assert(bitPosition < getBitWidth() && \"Bit position out of bounds!\");\n    return (maskBit(bitPosition) & getWord(bitPosition)) != 0;\n  }\n\n  /// @}\n  /// \\name Comparison Operators\n  /// @{\n\n  /// Equality operator.\n  ///\n  /// Compares this APInt with RHS for the validity of the equality\n  /// relationship.\n  bool operator==(const APInt &RHS) const {\n    assert(BitWidth == RHS.BitWidth && \"Comparison requires equal bit widths\");\n    if (isSingleWord())\n      return U.VAL == RHS.U.VAL;\n    return EqualSlowCase(RHS);\n  }\n\n  /// Equality operator.\n  ///\n  /// Compares this APInt with a uint64_t for the validity of the equality\n  /// relationship.\n  ///\n  /// \\returns true if *this == Val\n  bool operator==(uint64_t Val) const {\n    return (isSingleWord() || getActiveBits() <= 64) && getZExtValue() == Val;\n  }\n\n  /// Equality comparison.\n  ///\n  /// Compares this APInt with RHS for the validity of the equality\n  /// relationship.\n  ///\n  /// \\returns true if *this == Val\n  bool eq(const APInt &RHS) const { return (*this) == RHS; }\n\n  /// Inequality operator.\n  ///\n  /// Compares this APInt with RHS for the validity of the inequality\n  /// relationship.\n  ///\n  /// \\returns true if *this != Val\n  bool operator!=(const APInt &RHS) const { return !((*this) == RHS); }\n\n  /// Inequality operator.\n  ///\n  /// Compares this APInt with a uint64_t for the validity of the inequality\n  /// relationship.\n  ///\n  /// \\returns true if *this != Val\n  bool operator!=(uint64_t Val) const { return !((*this) == Val); }\n\n  /// Inequality comparison\n  ///\n  /// Compares this APInt with RHS for the validity of the inequality\n  /// relationship.\n  ///\n  /// \\returns true if *this != Val\n  bool ne(const APInt &RHS) const { return !((*this) == RHS); }\n\n  /// Unsigned less than comparison\n  ///\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// the validity of the less-than relationship.\n  ///\n  /// \\returns true if *this < RHS when both are considered unsigned.\n  bool ult(const APInt &RHS) const { return compare(RHS) < 0; }\n\n  /// Unsigned less than comparison\n  ///\n  /// Regards both *this as an unsigned quantity and compares it with RHS for\n  /// the validity of the less-than relationship.\n  ///\n  /// \\returns true if *this < RHS when considered unsigned.\n  bool ult(uint64_t RHS) const {\n    // Only need to check active bits if not a single word.\n    return (isSingleWord() || getActiveBits() <= 64) && getZExtValue() < RHS;\n  }\n\n  /// Signed less than comparison\n  ///\n  /// Regards both *this and RHS as signed quantities and compares them for\n  /// validity of the less-than relationship.\n  ///\n  /// \\returns true if *this < RHS when both are considered signed.\n  bool slt(const APInt &RHS) const { return compareSigned(RHS) < 0; }\n\n  /// Signed less than comparison\n  ///\n  /// Regards both *this as a signed quantity and compares it with RHS for\n  /// the validity of the less-than relationship.\n  ///\n  /// \\returns true if *this < RHS when considered signed.\n  bool slt(int64_t RHS) const {\n    return (!isSingleWord() && getMinSignedBits() > 64) ? isNegative()\n                                                        : getSExtValue() < RHS;\n  }\n\n  /// Unsigned less or equal comparison\n  ///\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// validity of the less-or-equal relationship.\n  ///\n  /// \\returns true if *this <= RHS when both are considered unsigned.\n  bool ule(const APInt &RHS) const { return compare(RHS) <= 0; }\n\n  /// Unsigned less or equal comparison\n  ///\n  /// Regards both *this as an unsigned quantity and compares it with RHS for\n  /// the validity of the less-or-equal relationship.\n  ///\n  /// \\returns true if *this <= RHS when considered unsigned.\n  bool ule(uint64_t RHS) const { return !ugt(RHS); }\n\n  /// Signed less or equal comparison\n  ///\n  /// Regards both *this and RHS as signed quantities and compares them for\n  /// validity of the less-or-equal relationship.\n  ///\n  /// \\returns true if *this <= RHS when both are considered signed.\n  bool sle(const APInt &RHS) const { return compareSigned(RHS) <= 0; }\n\n  /// Signed less or equal comparison\n  ///\n  /// Regards both *this as a signed quantity and compares it with RHS for the\n  /// validity of the less-or-equal relationship.\n  ///\n  /// \\returns true if *this <= RHS when considered signed.\n  bool sle(uint64_t RHS) const { return !sgt(RHS); }\n\n  /// Unsigned greater than comparison\n  ///\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// the validity of the greater-than relationship.\n  ///\n  /// \\returns true if *this > RHS when both are considered unsigned.\n  bool ugt(const APInt &RHS) const { return !ule(RHS); }\n\n  /// Unsigned greater than comparison\n  ///\n  /// Regards both *this as an unsigned quantity and compares it with RHS for\n  /// the validity of the greater-than relationship.\n  ///\n  /// \\returns true if *this > RHS when considered unsigned.\n  bool ugt(uint64_t RHS) const {\n    // Only need to check active bits if not a single word.\n    return (!isSingleWord() && getActiveBits() > 64) || getZExtValue() > RHS;\n  }\n\n  /// Signed greater than comparison\n  ///\n  /// Regards both *this and RHS as signed quantities and compares them for the\n  /// validity of the greater-than relationship.\n  ///\n  /// \\returns true if *this > RHS when both are considered signed.\n  bool sgt(const APInt &RHS) const { return !sle(RHS); }\n\n  /// Signed greater than comparison\n  ///\n  /// Regards both *this as a signed quantity and compares it with RHS for\n  /// the validity of the greater-than relationship.\n  ///\n  /// \\returns true if *this > RHS when considered signed.\n  bool sgt(int64_t RHS) const {\n    return (!isSingleWord() && getMinSignedBits() > 64) ? !isNegative()\n                                                        : getSExtValue() > RHS;\n  }\n\n  /// Unsigned greater or equal comparison\n  ///\n  /// Regards both *this and RHS as unsigned quantities and compares them for\n  /// validity of the greater-or-equal relationship.\n  ///\n  /// \\returns true if *this >= RHS when both are considered unsigned.\n  bool uge(const APInt &RHS) const { return !ult(RHS); }\n\n  /// Unsigned greater or equal comparison\n  ///\n  /// Regards both *this as an unsigned quantity and compares it with RHS for\n  /// the validity of the greater-or-equal relationship.\n  ///\n  /// \\returns true if *this >= RHS when considered unsigned.\n  bool uge(uint64_t RHS) const { return !ult(RHS); }\n\n  /// Signed greater or equal comparison\n  ///\n  /// Regards both *this and RHS as signed quantities and compares them for\n  /// validity of the greater-or-equal relationship.\n  ///\n  /// \\returns true if *this >= RHS when both are considered signed.\n  bool sge(const APInt &RHS) const { return !slt(RHS); }\n\n  /// Signed greater or equal comparison\n  ///\n  /// Regards both *this as a signed quantity and compares it with RHS for\n  /// the validity of the greater-or-equal relationship.\n  ///\n  /// \\returns true if *this >= RHS when considered signed.\n  bool sge(int64_t RHS) const { return !slt(RHS); }\n\n  /// This operation tests if there are any pairs of corresponding bits\n  /// between this APInt and RHS that are both set.\n  bool intersects(const APInt &RHS) const {\n    assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n    if (isSingleWord())\n      return (U.VAL & RHS.U.VAL) != 0;\n    return intersectsSlowCase(RHS);\n  }\n\n  /// This operation checks that all bits set in this APInt are also set in RHS.\n  bool isSubsetOf(const APInt &RHS) const {\n    assert(BitWidth == RHS.BitWidth && \"Bit widths must be the same\");\n    if (isSingleWord())\n      return (U.VAL & ~RHS.U.VAL) == 0;\n    return isSubsetOfSlowCase(RHS);\n  }\n\n  /// @}\n  /// \\name Resizing Operators\n  /// @{\n\n  /// Truncate to new width.\n  ///\n  /// Truncate the APInt to a specified width. It is an error to specify a width\n  /// that is greater than or equal to the current width.\n  APInt trunc(unsigned width) const;\n\n  /// Truncate to new width with unsigned saturation.\n  ///\n  /// If the APInt, treated as unsigned integer, can be losslessly truncated to\n  /// the new bitwidth, then return truncated APInt. Else, return max value.\n  APInt truncUSat(unsigned width) const;\n\n  /// Truncate to new width with signed saturation.\n  ///\n  /// If this APInt, treated as signed integer, can be losslessly truncated to\n  /// the new bitwidth, then return truncated APInt. Else, return either\n  /// signed min value if the APInt was negative, or signed max value.\n  APInt truncSSat(unsigned width) const;\n\n  /// Sign extend to a new width.\n  ///\n  /// This operation sign extends the APInt to a new width. If the high order\n  /// bit is set, the fill on the left will be done with 1 bits, otherwise zero.\n  /// It is an error to specify a width that is less than or equal to the\n  /// current width.\n  APInt sext(unsigned width) const;\n\n  /// Zero extend to a new width.\n  ///\n  /// This operation zero extends the APInt to a new width. The high order bits\n  /// are filled with 0 bits.  It is an error to specify a width that is less\n  /// than or equal to the current width.\n  APInt zext(unsigned width) const;\n\n  /// Sign extend or truncate to width\n  ///\n  /// Make this APInt have the bit width given by \\p width. The value is sign\n  /// extended, truncated, or left alone to make it that width.\n  APInt sextOrTrunc(unsigned width) const;\n\n  /// Zero extend or truncate to width\n  ///\n  /// Make this APInt have the bit width given by \\p width. The value is zero\n  /// extended, truncated, or left alone to make it that width.\n  APInt zextOrTrunc(unsigned width) const;\n\n  /// Truncate to width\n  ///\n  /// Make this APInt have the bit width given by \\p width. The value is\n  /// truncated or left alone to make it that width.\n  APInt truncOrSelf(unsigned width) const;\n\n  /// Sign extend or truncate to width\n  ///\n  /// Make this APInt have the bit width given by \\p width. The value is sign\n  /// extended, or left alone to make it that width.\n  APInt sextOrSelf(unsigned width) const;\n\n  /// Zero extend or truncate to width\n  ///\n  /// Make this APInt have the bit width given by \\p width. The value is zero\n  /// extended, or left alone to make it that width.\n  APInt zextOrSelf(unsigned width) const;\n\n  /// @}\n  /// \\name Bit Manipulation Operators\n  /// @{\n\n  /// Set every bit to 1.\n  void setAllBits() {\n    if (isSingleWord())\n      U.VAL = WORDTYPE_MAX;\n    else\n      // Set all the bits in all the words.\n      memset(U.pVal, -1, getNumWords() * APINT_WORD_SIZE);\n    // Clear the unused ones\n    clearUnusedBits();\n  }\n\n  /// Set a given bit to 1.\n  ///\n  /// Set the given bit to 1 whose position is given as \"bitPosition\".\n  void setBit(unsigned BitPosition) {\n    assert(BitPosition < BitWidth && \"BitPosition out of range\");\n    WordType Mask = maskBit(BitPosition);\n    if (isSingleWord())\n      U.VAL |= Mask;\n    else\n      U.pVal[whichWord(BitPosition)] |= Mask;\n  }\n\n  /// Set the sign bit to 1.\n  void setSignBit() {\n    setBit(BitWidth - 1);\n  }\n\n  /// Set a given bit to a given value.\n  void setBitVal(unsigned BitPosition, bool BitValue) {\n    if (BitValue)\n      setBit(BitPosition);\n    else\n      clearBit(BitPosition);\n  }\n\n  /// Set the bits from loBit (inclusive) to hiBit (exclusive) to 1.\n  /// This function handles \"wrap\" case when \\p loBit >= \\p hiBit, and calls\n  /// setBits when \\p loBit < \\p hiBit.\n  /// For \\p loBit == \\p hiBit wrap case, set every bit to 1.\n  void setBitsWithWrap(unsigned loBit, unsigned hiBit) {\n    assert(hiBit <= BitWidth && \"hiBit out of range\");\n    assert(loBit <= BitWidth && \"loBit out of range\");\n    if (loBit < hiBit) {\n      setBits(loBit, hiBit);\n      return;\n    }\n    setLowBits(hiBit);\n    setHighBits(BitWidth - loBit);\n  }\n\n  /// Set the bits from loBit (inclusive) to hiBit (exclusive) to 1.\n  /// This function handles case when \\p loBit <= \\p hiBit.\n  void setBits(unsigned loBit, unsigned hiBit) {\n    assert(hiBit <= BitWidth && \"hiBit out of range\");\n    assert(loBit <= BitWidth && \"loBit out of range\");\n    assert(loBit <= hiBit && \"loBit greater than hiBit\");\n    if (loBit == hiBit)\n      return;\n    if (loBit < APINT_BITS_PER_WORD && hiBit <= APINT_BITS_PER_WORD) {\n      uint64_t mask = WORDTYPE_MAX >> (APINT_BITS_PER_WORD - (hiBit - loBit));\n      mask <<= loBit;\n      if (isSingleWord())\n        U.VAL |= mask;\n      else\n        U.pVal[0] |= mask;\n    } else {\n      setBitsSlowCase(loBit, hiBit);\n    }\n  }\n\n  /// Set the top bits starting from loBit.\n  void setBitsFrom(unsigned loBit) {\n    return setBits(loBit, BitWidth);\n  }\n\n  /// Set the bottom loBits bits.\n  void setLowBits(unsigned loBits) {\n    return setBits(0, loBits);\n  }\n\n  /// Set the top hiBits bits.\n  void setHighBits(unsigned hiBits) {\n    return setBits(BitWidth - hiBits, BitWidth);\n  }\n\n  /// Set every bit to 0.\n  void clearAllBits() {\n    if (isSingleWord())\n      U.VAL = 0;\n    else\n      memset(U.pVal, 0, getNumWords() * APINT_WORD_SIZE);\n  }\n\n  /// Set a given bit to 0.\n  ///\n  /// Set the given bit to 0 whose position is given as \"bitPosition\".\n  void clearBit(unsigned BitPosition) {\n    assert(BitPosition < BitWidth && \"BitPosition out of range\");\n    WordType Mask = ~maskBit(BitPosition);\n    if (isSingleWord())\n      U.VAL &= Mask;\n    else\n      U.pVal[whichWord(BitPosition)] &= Mask;\n  }\n\n  /// Set bottom loBits bits to 0.\n  void clearLowBits(unsigned loBits) {\n    assert(loBits <= BitWidth && \"More bits than bitwidth\");\n    APInt Keep = getHighBitsSet(BitWidth, BitWidth - loBits);\n    *this &= Keep;\n  }\n\n  /// Set the sign bit to 0.\n  void clearSignBit() {\n    clearBit(BitWidth - 1);\n  }\n\n  /// Toggle every bit to its opposite value.\n  void flipAllBits() {\n    if (isSingleWord()) {\n      U.VAL ^= WORDTYPE_MAX;\n      clearUnusedBits();\n    } else {\n      flipAllBitsSlowCase();\n    }\n  }\n\n  /// Toggles a given bit to its opposite value.\n  ///\n  /// Toggle a given bit to its opposite value whose position is given\n  /// as \"bitPosition\".\n  void flipBit(unsigned bitPosition);\n\n  /// Negate this APInt in place.\n  void negate() {\n    flipAllBits();\n    ++(*this);\n  }\n\n  /// Insert the bits from a smaller APInt starting at bitPosition.\n  void insertBits(const APInt &SubBits, unsigned bitPosition);\n  void insertBits(uint64_t SubBits, unsigned bitPosition, unsigned numBits);\n\n  /// Return an APInt with the extracted bits [bitPosition,bitPosition+numBits).\n  APInt extractBits(unsigned numBits, unsigned bitPosition) const;\n  uint64_t extractBitsAsZExtValue(unsigned numBits, unsigned bitPosition) const;\n\n  /// @}\n  /// \\name Value Characterization Functions\n  /// @{\n\n  /// Return the number of bits in the APInt.\n  unsigned getBitWidth() const { return BitWidth; }\n\n  /// Get the number of words.\n  ///\n  /// Here one word's bitwidth equals to that of uint64_t.\n  ///\n  /// \\returns the number of words to hold the integer value of this APInt.\n  unsigned getNumWords() const { return getNumWords(BitWidth); }\n\n  /// Get the number of words.\n  ///\n  /// *NOTE* Here one word's bitwidth equals to that of uint64_t.\n  ///\n  /// \\returns the number of words to hold the integer value with a given bit\n  /// width.\n  static unsigned getNumWords(unsigned BitWidth) {\n    return ((uint64_t)BitWidth + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;\n  }\n\n  /// Compute the number of active bits in the value\n  ///\n  /// This function returns the number of active bits which is defined as the\n  /// bit width minus the number of leading zeros. This is used in several\n  /// computations to see how \"wide\" the value is.\n  unsigned getActiveBits() const { return BitWidth - countLeadingZeros(); }\n\n  /// Compute the number of active words in the value of this APInt.\n  ///\n  /// This is used in conjunction with getActiveData to extract the raw value of\n  /// the APInt.\n  unsigned getActiveWords() const {\n    unsigned numActiveBits = getActiveBits();\n    return numActiveBits ? whichWord(numActiveBits - 1) + 1 : 1;\n  }\n\n  /// Get the minimum bit size for this signed APInt\n  ///\n  /// Computes the minimum bit width for this APInt while considering it to be a\n  /// signed (and probably negative) value. If the value is not negative, this\n  /// function returns the same value as getActiveBits()+1. Otherwise, it\n  /// returns the smallest bit width that will retain the negative value. For\n  /// example, -1 can be written as 0b1 or 0xFFFFFFFFFF. 0b1 is shorter and so\n  /// for -1, this function will always return 1.\n  unsigned getMinSignedBits() const { return BitWidth - getNumSignBits() + 1; }\n\n  /// Get zero extended value\n  ///\n  /// This method attempts to return the value of this APInt as a zero extended\n  /// uint64_t. The bitwidth must be <= 64 or the value must fit within a\n  /// uint64_t. Otherwise an assertion will result.\n  uint64_t getZExtValue() const {\n    if (isSingleWord())\n      return U.VAL;\n    assert(getActiveBits() <= 64 && \"Too many bits for uint64_t\");\n    return U.pVal[0];\n  }\n\n  /// Get sign extended value\n  ///\n  /// This method attempts to return the value of this APInt as a sign extended\n  /// int64_t. The bit width must be <= 64 or the value must fit within an\n  /// int64_t. Otherwise an assertion will result.\n  int64_t getSExtValue() const {\n    if (isSingleWord())\n      return SignExtend64(U.VAL, BitWidth);\n    assert(getMinSignedBits() <= 64 && \"Too many bits for int64_t\");\n    return int64_t(U.pVal[0]);\n  }\n\n  /// Get bits required for string value.\n  ///\n  /// This method determines how many bits are required to hold the APInt\n  /// equivalent of the string given by \\p str.\n  static unsigned getBitsNeeded(StringRef str, uint8_t radix);\n\n  /// The APInt version of the countLeadingZeros functions in\n  ///   MathExtras.h.\n  ///\n  /// It counts the number of zeros from the most significant bit to the first\n  /// one bit.\n  ///\n  /// \\returns BitWidth if the value is zero, otherwise returns the number of\n  ///   zeros from the most significant bit to the first one bits.\n  unsigned countLeadingZeros() const {\n    if (isSingleWord()) {\n      unsigned unusedBits = APINT_BITS_PER_WORD - BitWidth;\n      return llvm::countLeadingZeros(U.VAL) - unusedBits;\n    }\n    return countLeadingZerosSlowCase();\n  }\n\n  /// Count the number of leading one bits.\n  ///\n  /// This function is an APInt version of the countLeadingOnes\n  /// functions in MathExtras.h. It counts the number of ones from the most\n  /// significant bit to the first zero bit.\n  ///\n  /// \\returns 0 if the high order bit is not set, otherwise returns the number\n  /// of 1 bits from the most significant to the least\n  unsigned countLeadingOnes() const {\n    if (isSingleWord())\n      return llvm::countLeadingOnes(U.VAL << (APINT_BITS_PER_WORD - BitWidth));\n    return countLeadingOnesSlowCase();\n  }\n\n  /// Computes the number of leading bits of this APInt that are equal to its\n  /// sign bit.\n  unsigned getNumSignBits() const {\n    return isNegative() ? countLeadingOnes() : countLeadingZeros();\n  }\n\n  /// Count the number of trailing zero bits.\n  ///\n  /// This function is an APInt version of the countTrailingZeros\n  /// functions in MathExtras.h. It counts the number of zeros from the least\n  /// significant bit to the first set bit.\n  ///\n  /// \\returns BitWidth if the value is zero, otherwise returns the number of\n  /// zeros from the least significant bit to the first one bit.\n  unsigned countTrailingZeros() const {\n    if (isSingleWord())\n      return std::min(unsigned(llvm::countTrailingZeros(U.VAL)), BitWidth);\n    return countTrailingZerosSlowCase();\n  }\n\n  /// Count the number of trailing one bits.\n  ///\n  /// This function is an APInt version of the countTrailingOnes\n  /// functions in MathExtras.h. It counts the number of ones from the least\n  /// significant bit to the first zero bit.\n  ///\n  /// \\returns BitWidth if the value is all ones, otherwise returns the number\n  /// of ones from the least significant bit to the first zero bit.\n  unsigned countTrailingOnes() const {\n    if (isSingleWord())\n      return llvm::countTrailingOnes(U.VAL);\n    return countTrailingOnesSlowCase();\n  }\n\n  /// Count the number of bits set.\n  ///\n  /// This function is an APInt version of the countPopulation functions\n  /// in MathExtras.h. It counts the number of 1 bits in the APInt value.\n  ///\n  /// \\returns 0 if the value is zero, otherwise returns the number of set bits.\n  unsigned countPopulation() const {\n    if (isSingleWord())\n      return llvm::countPopulation(U.VAL);\n    return countPopulationSlowCase();\n  }\n\n  /// @}\n  /// \\name Conversion Functions\n  /// @{\n  void print(raw_ostream &OS, bool isSigned) const;\n\n  /// Converts an APInt to a string and append it to Str.  Str is commonly a\n  /// SmallString.\n  void toString(SmallVectorImpl<char> &Str, unsigned Radix, bool Signed,\n                bool formatAsCLiteral = false) const;\n\n  /// Considers the APInt to be unsigned and converts it into a string in the\n  /// radix given. The radix can be 2, 8, 10 16, or 36.\n  void toStringUnsigned(SmallVectorImpl<char> &Str, unsigned Radix = 10) const {\n    toString(Str, Radix, false, false);\n  }\n\n  /// Considers the APInt to be signed and converts it into a string in the\n  /// radix given. The radix can be 2, 8, 10, 16, or 36.\n  void toStringSigned(SmallVectorImpl<char> &Str, unsigned Radix = 10) const {\n    toString(Str, Radix, true, false);\n  }\n\n  /// Return the APInt as a std::string.\n  ///\n  /// Note that this is an inefficient method.  It is better to pass in a\n  /// SmallVector/SmallString to the methods above to avoid thrashing the heap\n  /// for the string.\n  std::string toString(unsigned Radix, bool Signed) const;\n\n  /// \\returns a byte-swapped representation of this APInt Value.\n  APInt byteSwap() const;\n\n  /// \\returns the value with the bit representation reversed of this APInt\n  /// Value.\n  APInt reverseBits() const;\n\n  /// Converts this APInt to a double value.\n  double roundToDouble(bool isSigned) const;\n\n  /// Converts this unsigned APInt to a double value.\n  double roundToDouble() const { return roundToDouble(false); }\n\n  /// Converts this signed APInt to a double value.\n  double signedRoundToDouble() const { return roundToDouble(true); }\n\n  /// Converts APInt bits to a double\n  ///\n  /// The conversion does not do a translation from integer to double, it just\n  /// re-interprets the bits as a double. Note that it is valid to do this on\n  /// any bit width. Exactly 64 bits will be translated.\n  double bitsToDouble() const {\n    return BitsToDouble(getWord(0));\n  }\n\n  /// Converts APInt bits to a float\n  ///\n  /// The conversion does not do a translation from integer to float, it just\n  /// re-interprets the bits as a float. Note that it is valid to do this on\n  /// any bit width. Exactly 32 bits will be translated.\n  float bitsToFloat() const {\n    return BitsToFloat(static_cast<uint32_t>(getWord(0)));\n  }\n\n  /// Converts a double to APInt bits.\n  ///\n  /// The conversion does not do a translation from double to integer, it just\n  /// re-interprets the bits of the double.\n  static APInt doubleToBits(double V) {\n    return APInt(sizeof(double) * CHAR_BIT, DoubleToBits(V));\n  }\n\n  /// Converts a float to APInt bits.\n  ///\n  /// The conversion does not do a translation from float to integer, it just\n  /// re-interprets the bits of the float.\n  static APInt floatToBits(float V) {\n    return APInt(sizeof(float) * CHAR_BIT, FloatToBits(V));\n  }\n\n  /// @}\n  /// \\name Mathematics Operations\n  /// @{\n\n  /// \\returns the floor log base 2 of this APInt.\n  unsigned logBase2() const { return getActiveBits() -  1; }\n\n  /// \\returns the ceil log base 2 of this APInt.\n  unsigned ceilLogBase2() const {\n    APInt temp(*this);\n    --temp;\n    return temp.getActiveBits();\n  }\n\n  /// \\returns the nearest log base 2 of this APInt. Ties round up.\n  ///\n  /// NOTE: When we have a BitWidth of 1, we define:\n  ///\n  ///   log2(0) = UINT32_MAX\n  ///   log2(1) = 0\n  ///\n  /// to get around any mathematical concerns resulting from\n  /// referencing 2 in a space where 2 does no exist.\n  unsigned nearestLogBase2() const {\n    // Special case when we have a bitwidth of 1. If VAL is 1, then we\n    // get 0. If VAL is 0, we get WORDTYPE_MAX which gets truncated to\n    // UINT32_MAX.\n    if (BitWidth == 1)\n      return U.VAL - 1;\n\n    // Handle the zero case.\n    if (isNullValue())\n      return UINT32_MAX;\n\n    // The non-zero case is handled by computing:\n    //\n    //   nearestLogBase2(x) = logBase2(x) + x[logBase2(x)-1].\n    //\n    // where x[i] is referring to the value of the ith bit of x.\n    unsigned lg = logBase2();\n    return lg + unsigned((*this)[lg - 1]);\n  }\n\n  /// \\returns the log base 2 of this APInt if its an exact power of two, -1\n  /// otherwise\n  int32_t exactLogBase2() const {\n    if (!isPowerOf2())\n      return -1;\n    return logBase2();\n  }\n\n  /// Compute the square root\n  APInt sqrt() const;\n\n  /// Get the absolute value;\n  ///\n  /// If *this is < 0 then return -(*this), otherwise *this;\n  APInt abs() const {\n    if (isNegative())\n      return -(*this);\n    return *this;\n  }\n\n  /// \\returns the multiplicative inverse for a given modulo.\n  APInt multiplicativeInverse(const APInt &modulo) const;\n\n  /// @}\n  /// \\name Support for division by constant\n  /// @{\n\n  /// Calculate the magic number for signed division by a constant.\n  struct ms;\n  ms magic() const;\n\n  /// Calculate the magic number for unsigned division by a constant.\n  struct mu;\n  mu magicu(unsigned LeadingZeros = 0) const;\n\n  /// @}\n  /// \\name Building-block Operations for APInt and APFloat\n  /// @{\n\n  // These building block operations operate on a representation of arbitrary\n  // precision, two's-complement, bignum integer values. They should be\n  // sufficient to implement APInt and APFloat bignum requirements. Inputs are\n  // generally a pointer to the base of an array of integer parts, representing\n  // an unsigned bignum, and a count of how many parts there are.\n\n  /// Sets the least significant part of a bignum to the input value, and zeroes\n  /// out higher parts.\n  static void tcSet(WordType *, WordType, unsigned);\n\n  /// Assign one bignum to another.\n  static void tcAssign(WordType *, const WordType *, unsigned);\n\n  /// Returns true if a bignum is zero, false otherwise.\n  static bool tcIsZero(const WordType *, unsigned);\n\n  /// Extract the given bit of a bignum; returns 0 or 1.  Zero-based.\n  static int tcExtractBit(const WordType *, unsigned bit);\n\n  /// Copy the bit vector of width srcBITS from SRC, starting at bit srcLSB, to\n  /// DST, of dstCOUNT parts, such that the bit srcLSB becomes the least\n  /// significant bit of DST.  All high bits above srcBITS in DST are\n  /// zero-filled.\n  static void tcExtract(WordType *, unsigned dstCount,\n                        const WordType *, unsigned srcBits,\n                        unsigned srcLSB);\n\n  /// Set the given bit of a bignum.  Zero-based.\n  static void tcSetBit(WordType *, unsigned bit);\n\n  /// Clear the given bit of a bignum.  Zero-based.\n  static void tcClearBit(WordType *, unsigned bit);\n\n  /// Returns the bit number of the least or most significant set bit of a\n  /// number.  If the input number has no bits set -1U is returned.\n  static unsigned tcLSB(const WordType *, unsigned n);\n  static unsigned tcMSB(const WordType *parts, unsigned n);\n\n  /// Negate a bignum in-place.\n  static void tcNegate(WordType *, unsigned);\n\n  /// DST += RHS + CARRY where CARRY is zero or one.  Returns the carry flag.\n  static WordType tcAdd(WordType *, const WordType *,\n                        WordType carry, unsigned);\n  /// DST += RHS.  Returns the carry flag.\n  static WordType tcAddPart(WordType *, WordType, unsigned);\n\n  /// DST -= RHS + CARRY where CARRY is zero or one. Returns the carry flag.\n  static WordType tcSubtract(WordType *, const WordType *,\n                             WordType carry, unsigned);\n  /// DST -= RHS.  Returns the carry flag.\n  static WordType tcSubtractPart(WordType *, WordType, unsigned);\n\n  /// DST += SRC * MULTIPLIER + PART   if add is true\n  /// DST  = SRC * MULTIPLIER + PART   if add is false\n  ///\n  /// Requires 0 <= DSTPARTS <= SRCPARTS + 1.  If DST overlaps SRC they must\n  /// start at the same point, i.e. DST == SRC.\n  ///\n  /// If DSTPARTS == SRC_PARTS + 1 no overflow occurs and zero is returned.\n  /// Otherwise DST is filled with the least significant DSTPARTS parts of the\n  /// result, and if all of the omitted higher parts were zero return zero,\n  /// otherwise overflow occurred and return one.\n  static int tcMultiplyPart(WordType *dst, const WordType *src,\n                            WordType multiplier, WordType carry,\n                            unsigned srcParts, unsigned dstParts,\n                            bool add);\n\n  /// DST = LHS * RHS, where DST has the same width as the operands and is\n  /// filled with the least significant parts of the result.  Returns one if\n  /// overflow occurred, otherwise zero.  DST must be disjoint from both\n  /// operands.\n  static int tcMultiply(WordType *, const WordType *, const WordType *,\n                        unsigned);\n\n  /// DST = LHS * RHS, where DST has width the sum of the widths of the\n  /// operands. No overflow occurs. DST must be disjoint from both operands.\n  static void tcFullMultiply(WordType *, const WordType *,\n                             const WordType *, unsigned, unsigned);\n\n  /// If RHS is zero LHS and REMAINDER are left unchanged, return one.\n  /// Otherwise set LHS to LHS / RHS with the fractional part discarded, set\n  /// REMAINDER to the remainder, return zero.  i.e.\n  ///\n  ///  OLD_LHS = RHS * LHS + REMAINDER\n  ///\n  /// SCRATCH is a bignum of the same size as the operands and result for use by\n  /// the routine; its contents need not be initialized and are destroyed.  LHS,\n  /// REMAINDER and SCRATCH must be distinct.\n  static int tcDivide(WordType *lhs, const WordType *rhs,\n                      WordType *remainder, WordType *scratch,\n                      unsigned parts);\n\n  /// Shift a bignum left Count bits. Shifted in bits are zero. There are no\n  /// restrictions on Count.\n  static void tcShiftLeft(WordType *, unsigned Words, unsigned Count);\n\n  /// Shift a bignum right Count bits.  Shifted in bits are zero.  There are no\n  /// restrictions on Count.\n  static void tcShiftRight(WordType *, unsigned Words, unsigned Count);\n\n  /// The obvious AND, OR and XOR and complement operations.\n  static void tcAnd(WordType *, const WordType *, unsigned);\n  static void tcOr(WordType *, const WordType *, unsigned);\n  static void tcXor(WordType *, const WordType *, unsigned);\n  static void tcComplement(WordType *, unsigned);\n\n  /// Comparison (unsigned) of two bignums.\n  static int tcCompare(const WordType *, const WordType *, unsigned);\n\n  /// Increment a bignum in-place.  Return the carry flag.\n  static WordType tcIncrement(WordType *dst, unsigned parts) {\n    return tcAddPart(dst, 1, parts);\n  }\n\n  /// Decrement a bignum in-place.  Return the borrow flag.\n  static WordType tcDecrement(WordType *dst, unsigned parts) {\n    return tcSubtractPart(dst, 1, parts);\n  }\n\n  /// Set the least significant BITS and clear the rest.\n  static void tcSetLeastSignificantBits(WordType *, unsigned, unsigned bits);\n\n  /// debug method\n  void dump() const;\n\n  /// @}\n};\n\n/// Magic data for optimising signed division by a constant.\nstruct APInt::ms {\n  APInt m;    ///< magic number\n  unsigned s; ///< shift amount\n};\n\n/// Magic data for optimising unsigned division by a constant.\nstruct APInt::mu {\n  APInt m;    ///< magic number\n  bool a;     ///< add indicator\n  unsigned s; ///< shift amount\n};\n\ninline bool operator==(uint64_t V1, const APInt &V2) { return V2 == V1; }\n\ninline bool operator!=(uint64_t V1, const APInt &V2) { return V2 != V1; }\n\n/// Unary bitwise complement operator.\n///\n/// \\returns an APInt that is the bitwise complement of \\p v.\ninline APInt operator~(APInt v) {\n  v.flipAllBits();\n  return v;\n}\n\ninline APInt operator&(APInt a, const APInt &b) {\n  a &= b;\n  return a;\n}\n\ninline APInt operator&(const APInt &a, APInt &&b) {\n  b &= a;\n  return std::move(b);\n}\n\ninline APInt operator&(APInt a, uint64_t RHS) {\n  a &= RHS;\n  return a;\n}\n\ninline APInt operator&(uint64_t LHS, APInt b) {\n  b &= LHS;\n  return b;\n}\n\ninline APInt operator|(APInt a, const APInt &b) {\n  a |= b;\n  return a;\n}\n\ninline APInt operator|(const APInt &a, APInt &&b) {\n  b |= a;\n  return std::move(b);\n}\n\ninline APInt operator|(APInt a, uint64_t RHS) {\n  a |= RHS;\n  return a;\n}\n\ninline APInt operator|(uint64_t LHS, APInt b) {\n  b |= LHS;\n  return b;\n}\n\ninline APInt operator^(APInt a, const APInt &b) {\n  a ^= b;\n  return a;\n}\n\ninline APInt operator^(const APInt &a, APInt &&b) {\n  b ^= a;\n  return std::move(b);\n}\n\ninline APInt operator^(APInt a, uint64_t RHS) {\n  a ^= RHS;\n  return a;\n}\n\ninline APInt operator^(uint64_t LHS, APInt b) {\n  b ^= LHS;\n  return b;\n}\n\ninline raw_ostream &operator<<(raw_ostream &OS, const APInt &I) {\n  I.print(OS, true);\n  return OS;\n}\n\ninline APInt operator-(APInt v) {\n  v.negate();\n  return v;\n}\n\ninline APInt operator+(APInt a, const APInt &b) {\n  a += b;\n  return a;\n}\n\ninline APInt operator+(const APInt &a, APInt &&b) {\n  b += a;\n  return std::move(b);\n}\n\ninline APInt operator+(APInt a, uint64_t RHS) {\n  a += RHS;\n  return a;\n}\n\ninline APInt operator+(uint64_t LHS, APInt b) {\n  b += LHS;\n  return b;\n}\n\ninline APInt operator-(APInt a, const APInt &b) {\n  a -= b;\n  return a;\n}\n\ninline APInt operator-(const APInt &a, APInt &&b) {\n  b.negate();\n  b += a;\n  return std::move(b);\n}\n\ninline APInt operator-(APInt a, uint64_t RHS) {\n  a -= RHS;\n  return a;\n}\n\ninline APInt operator-(uint64_t LHS, APInt b) {\n  b.negate();\n  b += LHS;\n  return b;\n}\n\ninline APInt operator*(APInt a, uint64_t RHS) {\n  a *= RHS;\n  return a;\n}\n\ninline APInt operator*(uint64_t LHS, APInt b) {\n  b *= LHS;\n  return b;\n}\n\n\nnamespace APIntOps {\n\n/// Determine the smaller of two APInts considered to be signed.\ninline const APInt &smin(const APInt &A, const APInt &B) {\n  return A.slt(B) ? A : B;\n}\n\n/// Determine the larger of two APInts considered to be signed.\ninline const APInt &smax(const APInt &A, const APInt &B) {\n  return A.sgt(B) ? A : B;\n}\n\n/// Determine the smaller of two APInts considered to be signed.\ninline const APInt &umin(const APInt &A, const APInt &B) {\n  return A.ult(B) ? A : B;\n}\n\n/// Determine the larger of two APInts considered to be unsigned.\ninline const APInt &umax(const APInt &A, const APInt &B) {\n  return A.ugt(B) ? A : B;\n}\n\n/// Compute GCD of two unsigned APInt values.\n///\n/// This function returns the greatest common divisor of the two APInt values\n/// using Stein's algorithm.\n///\n/// \\returns the greatest common divisor of A and B.\nAPInt GreatestCommonDivisor(APInt A, APInt B);\n\n/// Converts the given APInt to a double value.\n///\n/// Treats the APInt as an unsigned value for conversion purposes.\ninline double RoundAPIntToDouble(const APInt &APIVal) {\n  return APIVal.roundToDouble();\n}\n\n/// Converts the given APInt to a double value.\n///\n/// Treats the APInt as a signed value for conversion purposes.\ninline double RoundSignedAPIntToDouble(const APInt &APIVal) {\n  return APIVal.signedRoundToDouble();\n}\n\n/// Converts the given APInt to a float vlalue.\ninline float RoundAPIntToFloat(const APInt &APIVal) {\n  return float(RoundAPIntToDouble(APIVal));\n}\n\n/// Converts the given APInt to a float value.\n///\n/// Treats the APInt as a signed value for conversion purposes.\ninline float RoundSignedAPIntToFloat(const APInt &APIVal) {\n  return float(APIVal.signedRoundToDouble());\n}\n\n/// Converts the given double value into a APInt.\n///\n/// This function convert a double value to an APInt value.\nAPInt RoundDoubleToAPInt(double Double, unsigned width);\n\n/// Converts a float value into a APInt.\n///\n/// Converts a float value into an APInt value.\ninline APInt RoundFloatToAPInt(float Float, unsigned width) {\n  return RoundDoubleToAPInt(double(Float), width);\n}\n\n/// Return A unsign-divided by B, rounded by the given rounding mode.\nAPInt RoundingUDiv(const APInt &A, const APInt &B, APInt::Rounding RM);\n\n/// Return A sign-divided by B, rounded by the given rounding mode.\nAPInt RoundingSDiv(const APInt &A, const APInt &B, APInt::Rounding RM);\n\n/// Let q(n) = An^2 + Bn + C, and BW = bit width of the value range\n/// (e.g. 32 for i32).\n/// This function finds the smallest number n, such that\n/// (a) n >= 0 and q(n) = 0, or\n/// (b) n >= 1 and q(n-1) and q(n), when evaluated in the set of all\n///     integers, belong to two different intervals [Rk, Rk+R),\n///     where R = 2^BW, and k is an integer.\n/// The idea here is to find when q(n) \"overflows\" 2^BW, while at the\n/// same time \"allowing\" subtraction. In unsigned modulo arithmetic a\n/// subtraction (treated as addition of negated numbers) would always\n/// count as an overflow, but here we want to allow values to decrease\n/// and increase as long as they are within the same interval.\n/// Specifically, adding of two negative numbers should not cause an\n/// overflow (as long as the magnitude does not exceed the bit width).\n/// On the other hand, given a positive number, adding a negative\n/// number to it can give a negative result, which would cause the\n/// value to go from [-2^BW, 0) to [0, 2^BW). In that sense, zero is\n/// treated as a special case of an overflow.\n///\n/// This function returns None if after finding k that minimizes the\n/// positive solution to q(n) = kR, both solutions are contained between\n/// two consecutive integers.\n///\n/// There are cases where q(n) > T, and q(n+1) < T (assuming evaluation\n/// in arithmetic modulo 2^BW, and treating the values as signed) by the\n/// virtue of *signed* overflow. This function will *not* find such an n,\n/// however it may find a value of n satisfying the inequalities due to\n/// an *unsigned* overflow (if the values are treated as unsigned).\n/// To find a solution for a signed overflow, treat it as a problem of\n/// finding an unsigned overflow with a range with of BW-1.\n///\n/// The returned value may have a different bit width from the input\n/// coefficients.\nOptional<APInt> SolveQuadraticEquationWrap(APInt A, APInt B, APInt C,\n                                           unsigned RangeWidth);\n\n/// Compare two values, and if they are different, return the position of the\n/// most significant bit that is different in the values.\nOptional<unsigned> GetMostSignificantDifferentBit(const APInt &A,\n                                                  const APInt &B);\n\n} // End of APIntOps namespace\n\n// See friend declaration above. This additional declaration is required in\n// order to compile LLVM with IBM xlC compiler.\nhash_code hash_value(const APInt &Arg);\n\n/// StoreIntToMemory - Fills the StoreBytes bytes of memory starting from Dst\n/// with the integer held in IntVal.\nvoid StoreIntToMemory(const APInt &IntVal, uint8_t *Dst, unsigned StoreBytes);\n\n/// LoadIntFromMemory - Loads the integer stored in the LoadBytes bytes starting\n/// from Src into IntVal, which is assumed to be wide enough and to hold zero.\nvoid LoadIntFromMemory(APInt &IntVal, const uint8_t *Src, unsigned LoadBytes);\n\n} // namespace llvm\n\n#endif\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "content": "//===-- llvm/ADT/APSInt.h - Arbitrary Precision Signed Int -----*- C++ -*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the APSInt class, which is a simple class that\n// represents an arbitrary sized integer that knows its signedness.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APSINT_H\n#define LLVM_ADT_APSINT_H\n\n#include \"llvm/ADT/APInt.h\"\n\nnamespace llvm {\n\n/// An arbitrary precision integer that knows its signedness.\nclass LLVM_NODISCARD APSInt : public APInt {\n  bool IsUnsigned;\n\npublic:\n  /// Default constructor that creates an uninitialized APInt.\n  explicit APSInt() : IsUnsigned(false) {}\n\n  /// Create an APSInt with the specified width, default to unsigned.\n  explicit APSInt(uint32_t BitWidth, bool isUnsigned = true)\n   : APInt(BitWidth, 0), IsUnsigned(isUnsigned) {}\n\n  explicit APSInt(APInt I, bool isUnsigned = true)\n   : APInt(std::move(I)), IsUnsigned(isUnsigned) {}\n\n  /// Construct an APSInt from a string representation.\n  ///\n  /// This constructor interprets the string \\p Str using the radix of 10.\n  /// The interpretation stops at the end of the string. The bit width of the\n  /// constructed APSInt is determined automatically.\n  ///\n  /// \\param Str the string to be interpreted.\n  explicit APSInt(StringRef Str);\n\n  /// Determine sign of this APSInt.\n  ///\n  /// \\returns true if this APSInt is negative, false otherwise\n  bool isNegative() const { return isSigned() && APInt::isNegative(); }\n\n  /// Determine if this APSInt Value is non-negative (>= 0)\n  ///\n  /// \\returns true if this APSInt is non-negative, false otherwise\n  bool isNonNegative() const { return !isNegative(); }\n\n  /// Determine if this APSInt Value is positive.\n  ///\n  /// This tests if the value of this APSInt is positive (> 0). Note\n  /// that 0 is not a positive value.\n  ///\n  /// \\returns true if this APSInt is positive.\n  bool isStrictlyPositive() const { return isNonNegative() && !isNullValue(); }\n\n  APSInt &operator=(APInt RHS) {\n    // Retain our current sign.\n    APInt::operator=(std::move(RHS));\n    return *this;\n  }\n\n  APSInt &operator=(uint64_t RHS) {\n    // Retain our current sign.\n    APInt::operator=(RHS);\n    return *this;\n  }\n\n  // Query sign information.\n  bool isSigned() const { return !IsUnsigned; }\n  bool isUnsigned() const { return IsUnsigned; }\n  void setIsUnsigned(bool Val) { IsUnsigned = Val; }\n  void setIsSigned(bool Val) { IsUnsigned = !Val; }\n\n  /// Append this APSInt to the specified SmallString.\n  void toString(SmallVectorImpl<char> &Str, unsigned Radix = 10) const {\n    APInt::toString(Str, Radix, isSigned());\n  }\n  /// Converts an APInt to a std::string.  This is an inefficient\n  /// method; you should prefer passing in a SmallString instead.\n  std::string toString(unsigned Radix) const {\n    return APInt::toString(Radix, isSigned());\n  }\n  using APInt::toString;\n\n  /// Get the correctly-extended \\c int64_t value.\n  int64_t getExtValue() const {\n    assert(getMinSignedBits() <= 64 && \"Too many bits for int64_t\");\n    return isSigned() ? getSExtValue() : getZExtValue();\n  }\n\n  APSInt trunc(uint32_t width) const {\n    return APSInt(APInt::trunc(width), IsUnsigned);\n  }\n\n  APSInt extend(uint32_t width) const {\n    if (IsUnsigned)\n      return APSInt(zext(width), IsUnsigned);\n    else\n      return APSInt(sext(width), IsUnsigned);\n  }\n\n  APSInt extOrTrunc(uint32_t width) const {\n    if (IsUnsigned)\n      return APSInt(zextOrTrunc(width), IsUnsigned);\n    else\n      return APSInt(sextOrTrunc(width), IsUnsigned);\n  }\n\n  const APSInt &operator%=(const APSInt &RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    if (IsUnsigned)\n      *this = urem(RHS);\n    else\n      *this = srem(RHS);\n    return *this;\n  }\n  const APSInt &operator/=(const APSInt &RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    if (IsUnsigned)\n      *this = udiv(RHS);\n    else\n      *this = sdiv(RHS);\n    return *this;\n  }\n  APSInt operator%(const APSInt &RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? APSInt(urem(RHS), true) : APSInt(srem(RHS), false);\n  }\n  APSInt operator/(const APSInt &RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? APSInt(udiv(RHS), true) : APSInt(sdiv(RHS), false);\n  }\n\n  APSInt operator>>(unsigned Amt) const {\n    return IsUnsigned ? APSInt(lshr(Amt), true) : APSInt(ashr(Amt), false);\n  }\n  APSInt& operator>>=(unsigned Amt) {\n    if (IsUnsigned)\n      lshrInPlace(Amt);\n    else\n      ashrInPlace(Amt);\n    return *this;\n  }\n\n  inline bool operator<(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? ult(RHS) : slt(RHS);\n  }\n  inline bool operator>(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? ugt(RHS) : sgt(RHS);\n  }\n  inline bool operator<=(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? ule(RHS) : sle(RHS);\n  }\n  inline bool operator>=(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return IsUnsigned ? uge(RHS) : sge(RHS);\n  }\n  inline bool operator==(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return eq(RHS);\n  }\n  inline bool operator!=(const APSInt& RHS) const {\n    return !((*this) == RHS);\n  }\n\n  bool operator==(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) == 0;\n  }\n  bool operator!=(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) != 0;\n  }\n  bool operator<=(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) <= 0;\n  }\n  bool operator>=(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) >= 0;\n  }\n  bool operator<(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) < 0;\n  }\n  bool operator>(int64_t RHS) const {\n    return compareValues(*this, get(RHS)) > 0;\n  }\n\n  // The remaining operators just wrap the logic of APInt, but retain the\n  // signedness information.\n\n  APSInt operator<<(unsigned Bits) const {\n    return APSInt(static_cast<const APInt&>(*this) << Bits, IsUnsigned);\n  }\n  APSInt& operator<<=(unsigned Amt) {\n    static_cast<APInt&>(*this) <<= Amt;\n    return *this;\n  }\n\n  APSInt& operator++() {\n    ++(static_cast<APInt&>(*this));\n    return *this;\n  }\n  APSInt& operator--() {\n    --(static_cast<APInt&>(*this));\n    return *this;\n  }\n  APSInt operator++(int) {\n    return APSInt(++static_cast<APInt&>(*this), IsUnsigned);\n  }\n  APSInt operator--(int) {\n    return APSInt(--static_cast<APInt&>(*this), IsUnsigned);\n  }\n  APSInt operator-() const {\n    return APSInt(-static_cast<const APInt&>(*this), IsUnsigned);\n  }\n  APSInt& operator+=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) += RHS;\n    return *this;\n  }\n  APSInt& operator-=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) -= RHS;\n    return *this;\n  }\n  APSInt& operator*=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) *= RHS;\n    return *this;\n  }\n  APSInt& operator&=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) &= RHS;\n    return *this;\n  }\n  APSInt& operator|=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) |= RHS;\n    return *this;\n  }\n  APSInt& operator^=(const APSInt& RHS) {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    static_cast<APInt&>(*this) ^= RHS;\n    return *this;\n  }\n\n  APSInt operator&(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) & RHS, IsUnsigned);\n  }\n\n  APSInt operator|(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) | RHS, IsUnsigned);\n  }\n\n  APSInt operator^(const APSInt &RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) ^ RHS, IsUnsigned);\n  }\n\n  APSInt operator*(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) * RHS, IsUnsigned);\n  }\n  APSInt operator+(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) + RHS, IsUnsigned);\n  }\n  APSInt operator-(const APSInt& RHS) const {\n    assert(IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\");\n    return APSInt(static_cast<const APInt&>(*this) - RHS, IsUnsigned);\n  }\n  APSInt operator~() const {\n    return APSInt(~static_cast<const APInt&>(*this), IsUnsigned);\n  }\n\n  /// Return the APSInt representing the maximum integer value with the given\n  /// bit width and signedness.\n  static APSInt getMaxValue(uint32_t numBits, bool Unsigned) {\n    return APSInt(Unsigned ? APInt::getMaxValue(numBits)\n                           : APInt::getSignedMaxValue(numBits), Unsigned);\n  }\n\n  /// Return the APSInt representing the minimum integer value with the given\n  /// bit width and signedness.\n  static APSInt getMinValue(uint32_t numBits, bool Unsigned) {\n    return APSInt(Unsigned ? APInt::getMinValue(numBits)\n                           : APInt::getSignedMinValue(numBits), Unsigned);\n  }\n\n  /// Determine if two APSInts have the same value, zero- or\n  /// sign-extending as needed.\n  static bool isSameValue(const APSInt &I1, const APSInt &I2) {\n    return !compareValues(I1, I2);\n  }\n\n  /// Compare underlying values of two numbers.\n  static int compareValues(const APSInt &I1, const APSInt &I2) {\n    if (I1.getBitWidth() == I2.getBitWidth() && I1.isSigned() == I2.isSigned())\n      return I1.IsUnsigned ? I1.compare(I2) : I1.compareSigned(I2);\n\n    // Check for a bit-width mismatch.\n    if (I1.getBitWidth() > I2.getBitWidth())\n      return compareValues(I1, I2.extend(I1.getBitWidth()));\n    if (I2.getBitWidth() > I1.getBitWidth())\n      return compareValues(I1.extend(I2.getBitWidth()), I2);\n\n    // We have a signedness mismatch. Check for negative values and do an\n    // unsigned compare if both are positive.\n    if (I1.isSigned()) {\n      assert(!I2.isSigned() && \"Expected signed mismatch\");\n      if (I1.isNegative())\n        return -1;\n    } else {\n      assert(I2.isSigned() && \"Expected signed mismatch\");\n      if (I2.isNegative())\n        return 1;\n    }\n\n    return I1.compare(I2);\n  }\n\n  static APSInt get(int64_t X) { return APSInt(APInt(64, X), false); }\n  static APSInt getUnsigned(uint64_t X) { return APSInt(APInt(64, X), true); }\n\n  /// Used to insert APSInt objects, or objects that contain APSInt objects,\n  /// into FoldingSets.\n  void Profile(FoldingSetNodeID& ID) const;\n};\n\ninline bool operator==(int64_t V1, const APSInt &V2) { return V2 == V1; }\ninline bool operator!=(int64_t V1, const APSInt &V2) { return V2 != V1; }\ninline bool operator<=(int64_t V1, const APSInt &V2) { return V2 >= V1; }\ninline bool operator>=(int64_t V1, const APSInt &V2) { return V2 <= V1; }\ninline bool operator<(int64_t V1, const APSInt &V2) { return V2 > V1; }\ninline bool operator>(int64_t V1, const APSInt &V2) { return V2 < V1; }\n\ninline raw_ostream &operator<<(raw_ostream &OS, const APSInt &I) {\n  I.print(OS, I.isSigned());\n  return OS;\n}\n\n} // end namespace llvm\n\n#endif\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "content": "//===- ArrayRef.h - Array Reference Wrapper ---------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ARRAYREF_H\n#define LLVM_ADT_ARRAYREF_H\n\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstddef>\n#include <initializer_list>\n#include <iterator>\n#include <memory>\n#include <type_traits>\n#include <vector>\n\nnamespace llvm {\n\n  /// ArrayRef - Represent a constant reference to an array (0 or more elements\n  /// consecutively in memory), i.e. a start pointer and a length.  It allows\n  /// various APIs to take consecutive elements easily and conveniently.\n  ///\n  /// This class does not own the underlying data, it is expected to be used in\n  /// situations where the data resides in some other buffer, whose lifetime\n  /// extends past that of the ArrayRef. For this reason, it is not in general\n  /// safe to store an ArrayRef.\n  ///\n  /// This is intended to be trivially copyable, so it should be passed by\n  /// value.\n  template<typename T>\n  class LLVM_GSL_POINTER LLVM_NODISCARD ArrayRef {\n  public:\n    using value_type = T;\n    using pointer = value_type *;\n    using const_pointer = const value_type *;\n    using reference = value_type &;\n    using const_reference = const value_type &;\n    using iterator = const_pointer;\n    using const_iterator = const_pointer;\n    using reverse_iterator = std::reverse_iterator<iterator>;\n    using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n    using size_type = size_t;\n    using difference_type = ptrdiff_t;\n\n  private:\n    /// The start of the array, in an external buffer.\n    const T *Data = nullptr;\n\n    /// The number of elements.\n    size_type Length = 0;\n\n  public:\n    /// @name Constructors\n    /// @{\n\n    /// Construct an empty ArrayRef.\n    /*implicit*/ ArrayRef() = default;\n\n    /// Construct an empty ArrayRef from None.\n    /*implicit*/ ArrayRef(NoneType) {}\n\n    /// Construct an ArrayRef from a single element.\n    /*implicit*/ ArrayRef(const T &OneElt)\n      : Data(&OneElt), Length(1) {}\n\n    /// Construct an ArrayRef from a pointer and length.\n    /*implicit*/ ArrayRef(const T *data, size_t length)\n      : Data(data), Length(length) {}\n\n    /// Construct an ArrayRef from a range.\n    ArrayRef(const T *begin, const T *end)\n      : Data(begin), Length(end - begin) {}\n\n    /// Construct an ArrayRef from a SmallVector. This is templated in order to\n    /// avoid instantiating SmallVectorTemplateCommon<T> whenever we\n    /// copy-construct an ArrayRef.\n    template<typename U>\n    /*implicit*/ ArrayRef(const SmallVectorTemplateCommon<T, U> &Vec)\n      : Data(Vec.data()), Length(Vec.size()) {\n    }\n\n    /// Construct an ArrayRef from a std::vector.\n    template<typename A>\n    /*implicit*/ ArrayRef(const std::vector<T, A> &Vec)\n      : Data(Vec.data()), Length(Vec.size()) {}\n\n    /// Construct an ArrayRef from a std::array\n    template <size_t N>\n    /*implicit*/ constexpr ArrayRef(const std::array<T, N> &Arr)\n        : Data(Arr.data()), Length(N) {}\n\n    /// Construct an ArrayRef from a C array.\n    template <size_t N>\n    /*implicit*/ constexpr ArrayRef(const T (&Arr)[N]) : Data(Arr), Length(N) {}\n\n    /// Construct an ArrayRef from a std::initializer_list.\n#if LLVM_GNUC_PREREQ(9, 0, 0)\n// Disable gcc's warning in this constructor as it generates an enormous amount\n// of messages. Anyone using ArrayRef should already be aware of the fact that\n// it does not do lifetime extension.\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Winit-list-lifetime\"\n#endif\n    /*implicit*/ ArrayRef(const std::initializer_list<T> &Vec)\n    : Data(Vec.begin() == Vec.end() ? (T*)nullptr : Vec.begin()),\n      Length(Vec.size()) {}\n#if LLVM_GNUC_PREREQ(9, 0, 0)\n#pragma GCC diagnostic pop\n#endif\n\n    /// Construct an ArrayRef<const T*> from ArrayRef<T*>. This uses SFINAE to\n    /// ensure that only ArrayRefs of pointers can be converted.\n    template <typename U>\n    ArrayRef(const ArrayRef<U *> &A,\n             std::enable_if_t<std::is_convertible<U *const *, T const *>::value>\n                 * = nullptr)\n        : Data(A.data()), Length(A.size()) {}\n\n    /// Construct an ArrayRef<const T*> from a SmallVector<T*>. This is\n    /// templated in order to avoid instantiating SmallVectorTemplateCommon<T>\n    /// whenever we copy-construct an ArrayRef.\n    template <typename U, typename DummyT>\n    /*implicit*/ ArrayRef(\n        const SmallVectorTemplateCommon<U *, DummyT> &Vec,\n        std::enable_if_t<std::is_convertible<U *const *, T const *>::value> * =\n            nullptr)\n        : Data(Vec.data()), Length(Vec.size()) {}\n\n    /// Construct an ArrayRef<const T*> from std::vector<T*>. This uses SFINAE\n    /// to ensure that only vectors of pointers can be converted.\n    template <typename U, typename A>\n    ArrayRef(const std::vector<U *, A> &Vec,\n             std::enable_if_t<std::is_convertible<U *const *, T const *>::value>\n                 * = 0)\n        : Data(Vec.data()), Length(Vec.size()) {}\n\n    /// @}\n    /// @name Simple Operations\n    /// @{\n\n    iterator begin() const { return Data; }\n    iterator end() const { return Data + Length; }\n\n    reverse_iterator rbegin() const { return reverse_iterator(end()); }\n    reverse_iterator rend() const { return reverse_iterator(begin()); }\n\n    /// empty - Check if the array is empty.\n    bool empty() const { return Length == 0; }\n\n    const T *data() const { return Data; }\n\n    /// size - Get the array size.\n    size_t size() const { return Length; }\n\n    /// front - Get the first element.\n    const T &front() const {\n      assert(!empty());\n      return Data[0];\n    }\n\n    /// back - Get the last element.\n    const T &back() const {\n      assert(!empty());\n      return Data[Length-1];\n    }\n\n    // copy - Allocate copy in Allocator and return ArrayRef<T> to it.\n    template <typename Allocator> ArrayRef<T> copy(Allocator &A) {\n      T *Buff = A.template Allocate<T>(Length);\n      std::uninitialized_copy(begin(), end(), Buff);\n      return ArrayRef<T>(Buff, Length);\n    }\n\n    /// equals - Check for element-wise equality.\n    bool equals(ArrayRef RHS) const {\n      if (Length != RHS.Length)\n        return false;\n      return std::equal(begin(), end(), RHS.begin());\n    }\n\n    /// slice(n, m) - Chop off the first N elements of the array, and keep M\n    /// elements in the array.\n    ArrayRef<T> slice(size_t N, size_t M) const {\n      assert(N+M <= size() && \"Invalid specifier\");\n      return ArrayRef<T>(data()+N, M);\n    }\n\n    /// slice(n) - Chop off the first N elements of the array.\n    ArrayRef<T> slice(size_t N) const { return slice(N, size() - N); }\n\n    /// Drop the first \\p N elements of the array.\n    ArrayRef<T> drop_front(size_t N = 1) const {\n      assert(size() >= N && \"Dropping more elements than exist\");\n      return slice(N, size() - N);\n    }\n\n    /// Drop the last \\p N elements of the array.\n    ArrayRef<T> drop_back(size_t N = 1) const {\n      assert(size() >= N && \"Dropping more elements than exist\");\n      return slice(0, size() - N);\n    }\n\n    /// Return a copy of *this with the first N elements satisfying the\n    /// given predicate removed.\n    template <class PredicateT> ArrayRef<T> drop_while(PredicateT Pred) const {\n      return ArrayRef<T>(find_if_not(*this, Pred), end());\n    }\n\n    /// Return a copy of *this with the first N elements not satisfying\n    /// the given predicate removed.\n    template <class PredicateT> ArrayRef<T> drop_until(PredicateT Pred) const {\n      return ArrayRef<T>(find_if(*this, Pred), end());\n    }\n\n    /// Return a copy of *this with only the first \\p N elements.\n    ArrayRef<T> take_front(size_t N = 1) const {\n      if (N >= size())\n        return *this;\n      return drop_back(size() - N);\n    }\n\n    /// Return a copy of *this with only the last \\p N elements.\n    ArrayRef<T> take_back(size_t N = 1) const {\n      if (N >= size())\n        return *this;\n      return drop_front(size() - N);\n    }\n\n    /// Return the first N elements of this Array that satisfy the given\n    /// predicate.\n    template <class PredicateT> ArrayRef<T> take_while(PredicateT Pred) const {\n      return ArrayRef<T>(begin(), find_if_not(*this, Pred));\n    }\n\n    /// Return the first N elements of this Array that don't satisfy the\n    /// given predicate.\n    template <class PredicateT> ArrayRef<T> take_until(PredicateT Pred) const {\n      return ArrayRef<T>(begin(), find_if(*this, Pred));\n    }\n\n    /// @}\n    /// @name Operator Overloads\n    /// @{\n    const T &operator[](size_t Index) const {\n      assert(Index < Length && \"Invalid index!\");\n      return Data[Index];\n    }\n\n    /// Disallow accidental assignment from a temporary.\n    ///\n    /// The declaration here is extra complicated so that \"arrayRef = {}\"\n    /// continues to select the move assignment operator.\n    template <typename U>\n    std::enable_if_t<std::is_same<U, T>::value, ArrayRef<T>> &\n    operator=(U &&Temporary) = delete;\n\n    /// Disallow accidental assignment from a temporary.\n    ///\n    /// The declaration here is extra complicated so that \"arrayRef = {}\"\n    /// continues to select the move assignment operator.\n    template <typename U>\n    std::enable_if_t<std::is_same<U, T>::value, ArrayRef<T>> &\n    operator=(std::initializer_list<U>) = delete;\n\n    /// @}\n    /// @name Expensive Operations\n    /// @{\n    std::vector<T> vec() const {\n      return std::vector<T>(Data, Data+Length);\n    }\n\n    /// @}\n    /// @name Conversion operators\n    /// @{\n    operator std::vector<T>() const {\n      return std::vector<T>(Data, Data+Length);\n    }\n\n    /// @}\n  };\n\n  /// MutableArrayRef - Represent a mutable reference to an array (0 or more\n  /// elements consecutively in memory), i.e. a start pointer and a length.  It\n  /// allows various APIs to take and modify consecutive elements easily and\n  /// conveniently.\n  ///\n  /// This class does not own the underlying data, it is expected to be used in\n  /// situations where the data resides in some other buffer, whose lifetime\n  /// extends past that of the MutableArrayRef. For this reason, it is not in\n  /// general safe to store a MutableArrayRef.\n  ///\n  /// This is intended to be trivially copyable, so it should be passed by\n  /// value.\n  template<typename T>\n  class LLVM_NODISCARD MutableArrayRef : public ArrayRef<T> {\n  public:\n    using value_type = T;\n    using pointer = value_type *;\n    using const_pointer = const value_type *;\n    using reference = value_type &;\n    using const_reference = const value_type &;\n    using iterator = pointer;\n    using const_iterator = const_pointer;\n    using reverse_iterator = std::reverse_iterator<iterator>;\n    using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n    using size_type = size_t;\n    using difference_type = ptrdiff_t;\n\n    /// Construct an empty MutableArrayRef.\n    /*implicit*/ MutableArrayRef() = default;\n\n    /// Construct an empty MutableArrayRef from None.\n    /*implicit*/ MutableArrayRef(NoneType) : ArrayRef<T>() {}\n\n    /// Construct a MutableArrayRef from a single element.\n    /*implicit*/ MutableArrayRef(T &OneElt) : ArrayRef<T>(OneElt) {}\n\n    /// Construct a MutableArrayRef from a pointer and length.\n    /*implicit*/ MutableArrayRef(T *data, size_t length)\n      : ArrayRef<T>(data, length) {}\n\n    /// Construct a MutableArrayRef from a range.\n    MutableArrayRef(T *begin, T *end) : ArrayRef<T>(begin, end) {}\n\n    /// Construct a MutableArrayRef from a SmallVector.\n    /*implicit*/ MutableArrayRef(SmallVectorImpl<T> &Vec)\n    : ArrayRef<T>(Vec) {}\n\n    /// Construct a MutableArrayRef from a std::vector.\n    /*implicit*/ MutableArrayRef(std::vector<T> &Vec)\n    : ArrayRef<T>(Vec) {}\n\n    /// Construct a MutableArrayRef from a std::array\n    template <size_t N>\n    /*implicit*/ constexpr MutableArrayRef(std::array<T, N> &Arr)\n        : ArrayRef<T>(Arr) {}\n\n    /// Construct a MutableArrayRef from a C array.\n    template <size_t N>\n    /*implicit*/ constexpr MutableArrayRef(T (&Arr)[N]) : ArrayRef<T>(Arr) {}\n\n    T *data() const { return const_cast<T*>(ArrayRef<T>::data()); }\n\n    iterator begin() const { return data(); }\n    iterator end() const { return data() + this->size(); }\n\n    reverse_iterator rbegin() const { return reverse_iterator(end()); }\n    reverse_iterator rend() const { return reverse_iterator(begin()); }\n\n    /// front - Get the first element.\n    T &front() const {\n      assert(!this->empty());\n      return data()[0];\n    }\n\n    /// back - Get the last element.\n    T &back() const {\n      assert(!this->empty());\n      return data()[this->size()-1];\n    }\n\n    /// slice(n, m) - Chop off the first N elements of the array, and keep M\n    /// elements in the array.\n    MutableArrayRef<T> slice(size_t N, size_t M) const {\n      assert(N + M <= this->size() && \"Invalid specifier\");\n      return MutableArrayRef<T>(this->data() + N, M);\n    }\n\n    /// slice(n) - Chop off the first N elements of the array.\n    MutableArrayRef<T> slice(size_t N) const {\n      return slice(N, this->size() - N);\n    }\n\n    /// Drop the first \\p N elements of the array.\n    MutableArrayRef<T> drop_front(size_t N = 1) const {\n      assert(this->size() >= N && \"Dropping more elements than exist\");\n      return slice(N, this->size() - N);\n    }\n\n    MutableArrayRef<T> drop_back(size_t N = 1) const {\n      assert(this->size() >= N && \"Dropping more elements than exist\");\n      return slice(0, this->size() - N);\n    }\n\n    /// Return a copy of *this with the first N elements satisfying the\n    /// given predicate removed.\n    template <class PredicateT>\n    MutableArrayRef<T> drop_while(PredicateT Pred) const {\n      return MutableArrayRef<T>(find_if_not(*this, Pred), end());\n    }\n\n    /// Return a copy of *this with the first N elements not satisfying\n    /// the given predicate removed.\n    template <class PredicateT>\n    MutableArrayRef<T> drop_until(PredicateT Pred) const {\n      return MutableArrayRef<T>(find_if(*this, Pred), end());\n    }\n\n    /// Return a copy of *this with only the first \\p N elements.\n    MutableArrayRef<T> take_front(size_t N = 1) const {\n      if (N >= this->size())\n        return *this;\n      return drop_back(this->size() - N);\n    }\n\n    /// Return a copy of *this with only the last \\p N elements.\n    MutableArrayRef<T> take_back(size_t N = 1) const {\n      if (N >= this->size())\n        return *this;\n      return drop_front(this->size() - N);\n    }\n\n    /// Return the first N elements of this Array that satisfy the given\n    /// predicate.\n    template <class PredicateT>\n    MutableArrayRef<T> take_while(PredicateT Pred) const {\n      return MutableArrayRef<T>(begin(), find_if_not(*this, Pred));\n    }\n\n    /// Return the first N elements of this Array that don't satisfy the\n    /// given predicate.\n    template <class PredicateT>\n    MutableArrayRef<T> take_until(PredicateT Pred) const {\n      return MutableArrayRef<T>(begin(), find_if(*this, Pred));\n    }\n\n    /// @}\n    /// @name Operator Overloads\n    /// @{\n    T &operator[](size_t Index) const {\n      assert(Index < this->size() && \"Invalid index!\");\n      return data()[Index];\n    }\n  };\n\n  /// This is a MutableArrayRef that owns its array.\n  template <typename T> class OwningArrayRef : public MutableArrayRef<T> {\n  public:\n    OwningArrayRef() = default;\n    OwningArrayRef(size_t Size) : MutableArrayRef<T>(new T[Size], Size) {}\n\n    OwningArrayRef(ArrayRef<T> Data)\n        : MutableArrayRef<T>(new T[Data.size()], Data.size()) {\n      std::copy(Data.begin(), Data.end(), this->begin());\n    }\n\n    OwningArrayRef(OwningArrayRef &&Other) { *this = std::move(Other); }\n\n    OwningArrayRef &operator=(OwningArrayRef &&Other) {\n      delete[] this->data();\n      this->MutableArrayRef<T>::operator=(Other);\n      Other.MutableArrayRef<T>::operator=(MutableArrayRef<T>());\n      return *this;\n    }\n\n    ~OwningArrayRef() { delete[] this->data(); }\n  };\n\n  /// @name ArrayRef Convenience constructors\n  /// @{\n\n  /// Construct an ArrayRef from a single element.\n  template<typename T>\n  ArrayRef<T> makeArrayRef(const T &OneElt) {\n    return OneElt;\n  }\n\n  /// Construct an ArrayRef from a pointer and length.\n  template<typename T>\n  ArrayRef<T> makeArrayRef(const T *data, size_t length) {\n    return ArrayRef<T>(data, length);\n  }\n\n  /// Construct an ArrayRef from a range.\n  template<typename T>\n  ArrayRef<T> makeArrayRef(const T *begin, const T *end) {\n    return ArrayRef<T>(begin, end);\n  }\n\n  /// Construct an ArrayRef from a SmallVector.\n  template <typename T>\n  ArrayRef<T> makeArrayRef(const SmallVectorImpl<T> &Vec) {\n    return Vec;\n  }\n\n  /// Construct an ArrayRef from a SmallVector.\n  template <typename T, unsigned N>\n  ArrayRef<T> makeArrayRef(const SmallVector<T, N> &Vec) {\n    return Vec;\n  }\n\n  /// Construct an ArrayRef from a std::vector.\n  template<typename T>\n  ArrayRef<T> makeArrayRef(const std::vector<T> &Vec) {\n    return Vec;\n  }\n\n  /// Construct an ArrayRef from a std::array.\n  template <typename T, std::size_t N>\n  ArrayRef<T> makeArrayRef(const std::array<T, N> &Arr) {\n    return Arr;\n  }\n\n  /// Construct an ArrayRef from an ArrayRef (no-op) (const)\n  template <typename T> ArrayRef<T> makeArrayRef(const ArrayRef<T> &Vec) {\n    return Vec;\n  }\n\n  /// Construct an ArrayRef from an ArrayRef (no-op)\n  template <typename T> ArrayRef<T> &makeArrayRef(ArrayRef<T> &Vec) {\n    return Vec;\n  }\n\n  /// Construct an ArrayRef from a C array.\n  template<typename T, size_t N>\n  ArrayRef<T> makeArrayRef(const T (&Arr)[N]) {\n    return ArrayRef<T>(Arr);\n  }\n\n  /// Construct a MutableArrayRef from a single element.\n  template<typename T>\n  MutableArrayRef<T> makeMutableArrayRef(T &OneElt) {\n    return OneElt;\n  }\n\n  /// Construct a MutableArrayRef from a pointer and length.\n  template<typename T>\n  MutableArrayRef<T> makeMutableArrayRef(T *data, size_t length) {\n    return MutableArrayRef<T>(data, length);\n  }\n\n  /// @}\n  /// @name ArrayRef Comparison Operators\n  /// @{\n\n  template<typename T>\n  inline bool operator==(ArrayRef<T> LHS, ArrayRef<T> RHS) {\n    return LHS.equals(RHS);\n  }\n\n  template <typename T>\n  inline bool operator==(SmallVectorImpl<T> &LHS, ArrayRef<T> RHS) {\n    return ArrayRef<T>(LHS).equals(RHS);\n  }\n\n  template <typename T>\n  inline bool operator!=(ArrayRef<T> LHS, ArrayRef<T> RHS) {\n    return !(LHS == RHS);\n  }\n\n  template <typename T>\n  inline bool operator!=(SmallVectorImpl<T> &LHS, ArrayRef<T> RHS) {\n    return !(LHS == RHS);\n  }\n\n  /// @}\n\n  template <typename T> hash_code hash_value(ArrayRef<T> S) {\n    return hash_combine_range(S.begin(), S.end());\n  }\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_ARRAYREF_H\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/BitVector.h", "content": "//===- llvm/ADT/BitVector.h - Bit vectors -----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the BitVector class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_BITVECTOR_H\n#define LLVM_ADT_BITVECTOR_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n\nnamespace llvm {\n\n/// ForwardIterator for the bits that are set.\n/// Iterators get invalidated when resize / reserve is called.\ntemplate <typename BitVectorT> class const_set_bits_iterator_impl {\n  const BitVectorT &Parent;\n  int Current = 0;\n\n  void advance() {\n    assert(Current != -1 && \"Trying to advance past end.\");\n    Current = Parent.find_next(Current);\n  }\n\npublic:\n  const_set_bits_iterator_impl(const BitVectorT &Parent, int Current)\n      : Parent(Parent), Current(Current) {}\n  explicit const_set_bits_iterator_impl(const BitVectorT &Parent)\n      : const_set_bits_iterator_impl(Parent, Parent.find_first()) {}\n  const_set_bits_iterator_impl(const const_set_bits_iterator_impl &) = default;\n\n  const_set_bits_iterator_impl operator++(int) {\n    auto Prev = *this;\n    advance();\n    return Prev;\n  }\n\n  const_set_bits_iterator_impl &operator++() {\n    advance();\n    return *this;\n  }\n\n  unsigned operator*() const { return Current; }\n\n  bool operator==(const const_set_bits_iterator_impl &Other) const {\n    assert(&Parent == &Other.Parent &&\n           \"Comparing iterators from different BitVectors\");\n    return Current == Other.Current;\n  }\n\n  bool operator!=(const const_set_bits_iterator_impl &Other) const {\n    assert(&Parent == &Other.Parent &&\n           \"Comparing iterators from different BitVectors\");\n    return Current != Other.Current;\n  }\n};\n\nclass BitVector {\n  typedef uintptr_t BitWord;\n\n  enum { BITWORD_SIZE = (unsigned)sizeof(BitWord) * CHAR_BIT };\n\n  static_assert(BITWORD_SIZE == 64 || BITWORD_SIZE == 32,\n                \"Unsupported word size\");\n\n  MutableArrayRef<BitWord> Bits; // Actual bits.\n  unsigned Size;                 // Size of bitvector in bits.\n\npublic:\n  typedef unsigned size_type;\n  // Encapsulation of a single bit.\n  class reference {\n    friend class BitVector;\n\n    BitWord *WordRef;\n    unsigned BitPos;\n\n  public:\n    reference(BitVector &b, unsigned Idx) {\n      WordRef = &b.Bits[Idx / BITWORD_SIZE];\n      BitPos = Idx % BITWORD_SIZE;\n    }\n\n    reference() = delete;\n    reference(const reference&) = default;\n\n    reference &operator=(reference t) {\n      *this = bool(t);\n      return *this;\n    }\n\n    reference& operator=(bool t) {\n      if (t)\n        *WordRef |= BitWord(1) << BitPos;\n      else\n        *WordRef &= ~(BitWord(1) << BitPos);\n      return *this;\n    }\n\n    operator bool() const {\n      return ((*WordRef) & (BitWord(1) << BitPos)) != 0;\n    }\n  };\n\n  typedef const_set_bits_iterator_impl<BitVector> const_set_bits_iterator;\n  typedef const_set_bits_iterator set_iterator;\n\n  const_set_bits_iterator set_bits_begin() const {\n    return const_set_bits_iterator(*this);\n  }\n  const_set_bits_iterator set_bits_end() const {\n    return const_set_bits_iterator(*this, -1);\n  }\n  iterator_range<const_set_bits_iterator> set_bits() const {\n    return make_range(set_bits_begin(), set_bits_end());\n  }\n\n  /// BitVector default ctor - Creates an empty bitvector.\n  BitVector() : Size(0) {}\n\n  /// BitVector ctor - Creates a bitvector of specified number of bits. All\n  /// bits are initialized to the specified value.\n  explicit BitVector(unsigned s, bool t = false) : Size(s) {\n    size_t Capacity = NumBitWords(s);\n    Bits = allocate(Capacity);\n    init_words(Bits, t);\n    if (t)\n      clear_unused_bits();\n  }\n\n  /// BitVector copy ctor.\n  BitVector(const BitVector &RHS) : Size(RHS.size()) {\n    if (Size == 0) {\n      Bits = MutableArrayRef<BitWord>();\n      return;\n    }\n\n    size_t Capacity = NumBitWords(RHS.size());\n    Bits = allocate(Capacity);\n    std::memcpy(Bits.data(), RHS.Bits.data(), Capacity * sizeof(BitWord));\n  }\n\n  BitVector(BitVector &&RHS) : Bits(RHS.Bits), Size(RHS.Size) {\n    RHS.Bits = MutableArrayRef<BitWord>();\n    RHS.Size = 0;\n  }\n\n  ~BitVector() { std::free(Bits.data()); }\n\n  /// empty - Tests whether there are no bits in this bitvector.\n  bool empty() const { return Size == 0; }\n\n  /// size - Returns the number of bits in this bitvector.\n  size_type size() const { return Size; }\n\n  /// count - Returns the number of bits which are set.\n  size_type count() const {\n    unsigned NumBits = 0;\n    for (unsigned i = 0; i < NumBitWords(size()); ++i)\n      NumBits += countPopulation(Bits[i]);\n    return NumBits;\n  }\n\n  /// any - Returns true if any bit is set.\n  bool any() const {\n    for (unsigned i = 0; i < NumBitWords(size()); ++i)\n      if (Bits[i] != 0)\n        return true;\n    return false;\n  }\n\n  /// all - Returns true if all bits are set.\n  bool all() const {\n    for (unsigned i = 0; i < Size / BITWORD_SIZE; ++i)\n      if (Bits[i] != ~BitWord(0))\n        return false;\n\n    // If bits remain check that they are ones. The unused bits are always zero.\n    if (unsigned Remainder = Size % BITWORD_SIZE)\n      return Bits[Size / BITWORD_SIZE] == (BitWord(1) << Remainder) - 1;\n\n    return true;\n  }\n\n  /// none - Returns true if none of the bits are set.\n  bool none() const {\n    return !any();\n  }\n\n  /// find_first_in - Returns the index of the first set / unset bit,\n  /// depending on \\p Set, in the range [Begin, End).\n  /// Returns -1 if all bits in the range are unset / set.\n  int find_first_in(unsigned Begin, unsigned End, bool Set = true) const {\n    assert(Begin <= End && End <= Size);\n    if (Begin == End)\n      return -1;\n\n    unsigned FirstWord = Begin / BITWORD_SIZE;\n    unsigned LastWord = (End - 1) / BITWORD_SIZE;\n\n    // Check subsequent words.\n    // The code below is based on search for the first _set_ bit. If\n    // we're searching for the first _unset_, we just take the\n    // complement of each word before we use it and apply\n    // the same method.\n    for (unsigned i = FirstWord; i <= LastWord; ++i) {\n      BitWord Copy = Bits[i];\n      if (!Set)\n        Copy = ~Copy;\n\n      if (i == FirstWord) {\n        unsigned FirstBit = Begin % BITWORD_SIZE;\n        Copy &= maskTrailingZeros<BitWord>(FirstBit);\n      }\n\n      if (i == LastWord) {\n        unsigned LastBit = (End - 1) % BITWORD_SIZE;\n        Copy &= maskTrailingOnes<BitWord>(LastBit + 1);\n      }\n      if (Copy != 0)\n        return i * BITWORD_SIZE + countTrailingZeros(Copy);\n    }\n    return -1;\n  }\n\n  /// find_last_in - Returns the index of the last set bit in the range\n  /// [Begin, End).  Returns -1 if all bits in the range are unset.\n  int find_last_in(unsigned Begin, unsigned End) const {\n    assert(Begin <= End && End <= Size);\n    if (Begin == End)\n      return -1;\n\n    unsigned LastWord = (End - 1) / BITWORD_SIZE;\n    unsigned FirstWord = Begin / BITWORD_SIZE;\n\n    for (unsigned i = LastWord + 1; i >= FirstWord + 1; --i) {\n      unsigned CurrentWord = i - 1;\n\n      BitWord Copy = Bits[CurrentWord];\n      if (CurrentWord == LastWord) {\n        unsigned LastBit = (End - 1) % BITWORD_SIZE;\n        Copy &= maskTrailingOnes<BitWord>(LastBit + 1);\n      }\n\n      if (CurrentWord == FirstWord) {\n        unsigned FirstBit = Begin % BITWORD_SIZE;\n        Copy &= maskTrailingZeros<BitWord>(FirstBit);\n      }\n\n      if (Copy != 0)\n        return (CurrentWord + 1) * BITWORD_SIZE - countLeadingZeros(Copy) - 1;\n    }\n\n    return -1;\n  }\n\n  /// find_first_unset_in - Returns the index of the first unset bit in the\n  /// range [Begin, End).  Returns -1 if all bits in the range are set.\n  int find_first_unset_in(unsigned Begin, unsigned End) const {\n    return find_first_in(Begin, End, /* Set = */ false);\n  }\n\n  /// find_last_unset_in - Returns the index of the last unset bit in the\n  /// range [Begin, End).  Returns -1 if all bits in the range are set.\n  int find_last_unset_in(unsigned Begin, unsigned End) const {\n    assert(Begin <= End && End <= Size);\n    if (Begin == End)\n      return -1;\n\n    unsigned LastWord = (End - 1) / BITWORD_SIZE;\n    unsigned FirstWord = Begin / BITWORD_SIZE;\n\n    for (unsigned i = LastWord + 1; i >= FirstWord + 1; --i) {\n      unsigned CurrentWord = i - 1;\n\n      BitWord Copy = Bits[CurrentWord];\n      if (CurrentWord == LastWord) {\n        unsigned LastBit = (End - 1) % BITWORD_SIZE;\n        Copy |= maskTrailingZeros<BitWord>(LastBit + 1);\n      }\n\n      if (CurrentWord == FirstWord) {\n        unsigned FirstBit = Begin % BITWORD_SIZE;\n        Copy |= maskTrailingOnes<BitWord>(FirstBit);\n      }\n\n      if (Copy != ~BitWord(0)) {\n        unsigned Result =\n            (CurrentWord + 1) * BITWORD_SIZE - countLeadingOnes(Copy) - 1;\n        return Result < Size ? Result : -1;\n      }\n    }\n    return -1;\n  }\n\n  /// find_first - Returns the index of the first set bit, -1 if none\n  /// of the bits are set.\n  int find_first() const { return find_first_in(0, Size); }\n\n  /// find_last - Returns the index of the last set bit, -1 if none of the bits\n  /// are set.\n  int find_last() const { return find_last_in(0, Size); }\n\n  /// find_next - Returns the index of the next set bit following the\n  /// \"Prev\" bit. Returns -1 if the next set bit is not found.\n  int find_next(unsigned Prev) const { return find_first_in(Prev + 1, Size); }\n\n  /// find_prev - Returns the index of the first set bit that precedes the\n  /// the bit at \\p PriorTo.  Returns -1 if all previous bits are unset.\n  int find_prev(unsigned PriorTo) const { return find_last_in(0, PriorTo); }\n\n  /// find_first_unset - Returns the index of the first unset bit, -1 if all\n  /// of the bits are set.\n  int find_first_unset() const { return find_first_unset_in(0, Size); }\n\n  /// find_next_unset - Returns the index of the next unset bit following the\n  /// \"Prev\" bit.  Returns -1 if all remaining bits are set.\n  int find_next_unset(unsigned Prev) const {\n    return find_first_unset_in(Prev + 1, Size);\n  }\n\n  /// find_last_unset - Returns the index of the last unset bit, -1 if all of\n  /// the bits are set.\n  int find_last_unset() const { return find_last_unset_in(0, Size); }\n\n  /// find_prev_unset - Returns the index of the first unset bit that precedes\n  /// the bit at \\p PriorTo.  Returns -1 if all previous bits are set.\n  int find_prev_unset(unsigned PriorTo) {\n    return find_last_unset_in(0, PriorTo);\n  }\n\n  /// clear - Removes all bits from the bitvector. Does not change capacity.\n  void clear() {\n    Size = 0;\n  }\n\n  /// resize - Grow or shrink the bitvector.\n  void resize(unsigned N, bool t = false) {\n    if (N > getBitCapacity()) {\n      unsigned OldCapacity = Bits.size();\n      grow(N);\n      init_words(Bits.drop_front(OldCapacity), t);\n    }\n\n    // Set any old unused bits that are now included in the BitVector. This\n    // may set bits that are not included in the new vector, but we will clear\n    // them back out below.\n    if (N > Size)\n      set_unused_bits(t);\n\n    // Update the size, and clear out any bits that are now unused\n    unsigned OldSize = Size;\n    Size = N;\n    if (t || N < OldSize)\n      clear_unused_bits();\n  }\n\n  void reserve(unsigned N) {\n    if (N > getBitCapacity())\n      grow(N);\n  }\n\n  // Set, reset, flip\n  BitVector &set() {\n    init_words(Bits, true);\n    clear_unused_bits();\n    return *this;\n  }\n\n  BitVector &set(unsigned Idx) {\n    assert(Bits.data() && \"Bits never allocated\");\n    Bits[Idx / BITWORD_SIZE] |= BitWord(1) << (Idx % BITWORD_SIZE);\n    return *this;\n  }\n\n  /// set - Efficiently set a range of bits in [I, E)\n  BitVector &set(unsigned I, unsigned E) {\n    assert(I <= E && \"Attempted to set backwards range!\");\n    assert(E <= size() && \"Attempted to set out-of-bounds range!\");\n\n    if (I == E) return *this;\n\n    if (I / BITWORD_SIZE == E / BITWORD_SIZE) {\n      BitWord EMask = BitWord(1) << (E % BITWORD_SIZE);\n      BitWord IMask = BitWord(1) << (I % BITWORD_SIZE);\n      BitWord Mask = EMask - IMask;\n      Bits[I / BITWORD_SIZE] |= Mask;\n      return *this;\n    }\n\n    BitWord PrefixMask = ~BitWord(0) << (I % BITWORD_SIZE);\n    Bits[I / BITWORD_SIZE] |= PrefixMask;\n    I = alignTo(I, BITWORD_SIZE);\n\n    for (; I + BITWORD_SIZE <= E; I += BITWORD_SIZE)\n      Bits[I / BITWORD_SIZE] = ~BitWord(0);\n\n    BitWord PostfixMask = (BitWord(1) << (E % BITWORD_SIZE)) - 1;\n    if (I < E)\n      Bits[I / BITWORD_SIZE] |= PostfixMask;\n\n    return *this;\n  }\n\n  BitVector &reset() {\n    init_words(Bits, false);\n    return *this;\n  }\n\n  BitVector &reset(unsigned Idx) {\n    Bits[Idx / BITWORD_SIZE] &= ~(BitWord(1) << (Idx % BITWORD_SIZE));\n    return *this;\n  }\n\n  /// reset - Efficiently reset a range of bits in [I, E)\n  BitVector &reset(unsigned I, unsigned E) {\n    assert(I <= E && \"Attempted to reset backwards range!\");\n    assert(E <= size() && \"Attempted to reset out-of-bounds range!\");\n\n    if (I == E) return *this;\n\n    if (I / BITWORD_SIZE == E / BITWORD_SIZE) {\n      BitWord EMask = BitWord(1) << (E % BITWORD_SIZE);\n      BitWord IMask = BitWord(1) << (I % BITWORD_SIZE);\n      BitWord Mask = EMask - IMask;\n      Bits[I / BITWORD_SIZE] &= ~Mask;\n      return *this;\n    }\n\n    BitWord PrefixMask = ~BitWord(0) << (I % BITWORD_SIZE);\n    Bits[I / BITWORD_SIZE] &= ~PrefixMask;\n    I = alignTo(I, BITWORD_SIZE);\n\n    for (; I + BITWORD_SIZE <= E; I += BITWORD_SIZE)\n      Bits[I / BITWORD_SIZE] = BitWord(0);\n\n    BitWord PostfixMask = (BitWord(1) << (E % BITWORD_SIZE)) - 1;\n    if (I < E)\n      Bits[I / BITWORD_SIZE] &= ~PostfixMask;\n\n    return *this;\n  }\n\n  BitVector &flip() {\n    for (unsigned i = 0; i < NumBitWords(size()); ++i)\n      Bits[i] = ~Bits[i];\n    clear_unused_bits();\n    return *this;\n  }\n\n  BitVector &flip(unsigned Idx) {\n    Bits[Idx / BITWORD_SIZE] ^= BitWord(1) << (Idx % BITWORD_SIZE);\n    return *this;\n  }\n\n  // Indexing.\n  reference operator[](unsigned Idx) {\n    assert (Idx < Size && \"Out-of-bounds Bit access.\");\n    return reference(*this, Idx);\n  }\n\n  bool operator[](unsigned Idx) const {\n    assert (Idx < Size && \"Out-of-bounds Bit access.\");\n    BitWord Mask = BitWord(1) << (Idx % BITWORD_SIZE);\n    return (Bits[Idx / BITWORD_SIZE] & Mask) != 0;\n  }\n\n  bool test(unsigned Idx) const {\n    return (*this)[Idx];\n  }\n\n  // Push single bit to end of vector.\n  void push_back(bool Val) {\n    unsigned OldSize = Size;\n    unsigned NewSize = Size + 1;\n\n    // Resize, which will insert zeros.\n    // If we already fit then the unused bits will be already zero.\n    if (NewSize > getBitCapacity())\n      resize(NewSize, false);\n    else\n      Size = NewSize;\n\n    // If true, set single bit.\n    if (Val)\n      set(OldSize);\n  }\n\n  /// Test if any common bits are set.\n  bool anyCommon(const BitVector &RHS) const {\n    unsigned ThisWords = NumBitWords(size());\n    unsigned RHSWords  = NumBitWords(RHS.size());\n    for (unsigned i = 0, e = std::min(ThisWords, RHSWords); i != e; ++i)\n      if (Bits[i] & RHS.Bits[i])\n        return true;\n    return false;\n  }\n\n  // Comparison operators.\n  bool operator==(const BitVector &RHS) const {\n    if (size() != RHS.size())\n      return false;\n    unsigned NumWords = NumBitWords(size());\n    return Bits.take_front(NumWords) == RHS.Bits.take_front(NumWords);\n  }\n\n  bool operator!=(const BitVector &RHS) const {\n    return !(*this == RHS);\n  }\n\n  /// Intersection, union, disjoint union.\n  BitVector &operator&=(const BitVector &RHS) {\n    unsigned ThisWords = NumBitWords(size());\n    unsigned RHSWords  = NumBitWords(RHS.size());\n    unsigned i;\n    for (i = 0; i != std::min(ThisWords, RHSWords); ++i)\n      Bits[i] &= RHS.Bits[i];\n\n    // Any bits that are just in this bitvector become zero, because they aren't\n    // in the RHS bit vector.  Any words only in RHS are ignored because they\n    // are already zero in the LHS.\n    for (; i != ThisWords; ++i)\n      Bits[i] = 0;\n\n    return *this;\n  }\n\n  /// reset - Reset bits that are set in RHS. Same as *this &= ~RHS.\n  BitVector &reset(const BitVector &RHS) {\n    unsigned ThisWords = NumBitWords(size());\n    unsigned RHSWords  = NumBitWords(RHS.size());\n    unsigned i;\n    for (i = 0; i != std::min(ThisWords, RHSWords); ++i)\n      Bits[i] &= ~RHS.Bits[i];\n    return *this;\n  }\n\n  /// test - Check if (This - RHS) is zero.\n  /// This is the same as reset(RHS) and any().\n  bool test(const BitVector &RHS) const {\n    unsigned ThisWords = NumBitWords(size());\n    unsigned RHSWords  = NumBitWords(RHS.size());\n    unsigned i;\n    for (i = 0; i != std::min(ThisWords, RHSWords); ++i)\n      if ((Bits[i] & ~RHS.Bits[i]) != 0)\n        return true;\n\n    for (; i != ThisWords ; ++i)\n      if (Bits[i] != 0)\n        return true;\n\n    return false;\n  }\n\n  BitVector &operator|=(const BitVector &RHS) {\n    if (size() < RHS.size())\n      resize(RHS.size());\n    for (size_t i = 0, e = NumBitWords(RHS.size()); i != e; ++i)\n      Bits[i] |= RHS.Bits[i];\n    return *this;\n  }\n\n  BitVector &operator^=(const BitVector &RHS) {\n    if (size() < RHS.size())\n      resize(RHS.size());\n    for (size_t i = 0, e = NumBitWords(RHS.size()); i != e; ++i)\n      Bits[i] ^= RHS.Bits[i];\n    return *this;\n  }\n\n  BitVector &operator>>=(unsigned N) {\n    assert(N <= Size);\n    if (LLVM_UNLIKELY(empty() || N == 0))\n      return *this;\n\n    unsigned NumWords = NumBitWords(Size);\n    assert(NumWords >= 1);\n\n    wordShr(N / BITWORD_SIZE);\n\n    unsigned BitDistance = N % BITWORD_SIZE;\n    if (BitDistance == 0)\n      return *this;\n\n    // When the shift size is not a multiple of the word size, then we have\n    // a tricky situation where each word in succession needs to extract some\n    // of the bits from the next word and or them into this word while\n    // shifting this word to make room for the new bits.  This has to be done\n    // for every word in the array.\n\n    // Since we're shifting each word right, some bits will fall off the end\n    // of each word to the right, and empty space will be created on the left.\n    // The final word in the array will lose bits permanently, so starting at\n    // the beginning, work forwards shifting each word to the right, and\n    // OR'ing in the bits from the end of the next word to the beginning of\n    // the current word.\n\n    // Example:\n    //   Starting with {0xAABBCCDD, 0xEEFF0011, 0x22334455} and shifting right\n    //   by 4 bits.\n    // Step 1: Word[0] >>= 4           ; 0x0ABBCCDD\n    // Step 2: Word[0] |= 0x10000000   ; 0x1ABBCCDD\n    // Step 3: Word[1] >>= 4           ; 0x0EEFF001\n    // Step 4: Word[1] |= 0x50000000   ; 0x5EEFF001\n    // Step 5: Word[2] >>= 4           ; 0x02334455\n    // Result: { 0x1ABBCCDD, 0x5EEFF001, 0x02334455 }\n    const BitWord Mask = maskTrailingOnes<BitWord>(BitDistance);\n    const unsigned LSH = BITWORD_SIZE - BitDistance;\n\n    for (unsigned I = 0; I < NumWords - 1; ++I) {\n      Bits[I] >>= BitDistance;\n      Bits[I] |= (Bits[I + 1] & Mask) << LSH;\n    }\n\n    Bits[NumWords - 1] >>= BitDistance;\n\n    return *this;\n  }\n\n  BitVector &operator<<=(unsigned N) {\n    assert(N <= Size);\n    if (LLVM_UNLIKELY(empty() || N == 0))\n      return *this;\n\n    unsigned NumWords = NumBitWords(Size);\n    assert(NumWords >= 1);\n\n    wordShl(N / BITWORD_SIZE);\n\n    unsigned BitDistance = N % BITWORD_SIZE;\n    if (BitDistance == 0)\n      return *this;\n\n    // When the shift size is not a multiple of the word size, then we have\n    // a tricky situation where each word in succession needs to extract some\n    // of the bits from the previous word and or them into this word while\n    // shifting this word to make room for the new bits.  This has to be done\n    // for every word in the array.  This is similar to the algorithm outlined\n    // in operator>>=, but backwards.\n\n    // Since we're shifting each word left, some bits will fall off the end\n    // of each word to the left, and empty space will be created on the right.\n    // The first word in the array will lose bits permanently, so starting at\n    // the end, work backwards shifting each word to the left, and OR'ing\n    // in the bits from the end of the next word to the beginning of the\n    // current word.\n\n    // Example:\n    //   Starting with {0xAABBCCDD, 0xEEFF0011, 0x22334455} and shifting left\n    //   by 4 bits.\n    // Step 1: Word[2] <<= 4           ; 0x23344550\n    // Step 2: Word[2] |= 0x0000000E   ; 0x2334455E\n    // Step 3: Word[1] <<= 4           ; 0xEFF00110\n    // Step 4: Word[1] |= 0x0000000A   ; 0xEFF0011A\n    // Step 5: Word[0] <<= 4           ; 0xABBCCDD0\n    // Result: { 0xABBCCDD0, 0xEFF0011A, 0x2334455E }\n    const BitWord Mask = maskLeadingOnes<BitWord>(BitDistance);\n    const unsigned RSH = BITWORD_SIZE - BitDistance;\n\n    for (int I = NumWords - 1; I > 0; --I) {\n      Bits[I] <<= BitDistance;\n      Bits[I] |= (Bits[I - 1] & Mask) >> RSH;\n    }\n    Bits[0] <<= BitDistance;\n    clear_unused_bits();\n\n    return *this;\n  }\n\n  // Assignment operator.\n  const BitVector &operator=(const BitVector &RHS) {\n    if (this == &RHS) return *this;\n\n    Size = RHS.size();\n\n    // Handle tombstone when the BitVector is a key of a DenseHash.\n    if (RHS.isInvalid()) {\n      std::free(Bits.data());\n      Bits = None;\n      return *this;\n    }\n\n    unsigned RHSWords = NumBitWords(Size);\n    if (Size <= getBitCapacity()) {\n      if (Size)\n        std::memcpy(Bits.data(), RHS.Bits.data(), RHSWords * sizeof(BitWord));\n      clear_unused_bits();\n      return *this;\n    }\n\n    // Grow the bitvector to have enough elements.\n    unsigned NewCapacity = RHSWords;\n    assert(NewCapacity > 0 && \"negative capacity?\");\n    auto NewBits = allocate(NewCapacity);\n    std::memcpy(NewBits.data(), RHS.Bits.data(), NewCapacity * sizeof(BitWord));\n\n    // Destroy the old bits.\n    std::free(Bits.data());\n    Bits = NewBits;\n\n    return *this;\n  }\n\n  const BitVector &operator=(BitVector &&RHS) {\n    if (this == &RHS) return *this;\n\n    std::free(Bits.data());\n    Bits = RHS.Bits;\n    Size = RHS.Size;\n\n    RHS.Bits = MutableArrayRef<BitWord>();\n    RHS.Size = 0;\n\n    return *this;\n  }\n\n  void swap(BitVector &RHS) {\n    std::swap(Bits, RHS.Bits);\n    std::swap(Size, RHS.Size);\n  }\n\n  void invalid() {\n    assert(!Size && Bits.empty());\n    Size = (unsigned)-1;\n  }\n  bool isInvalid() const { return Size == (unsigned)-1; }\n\n  ArrayRef<BitWord> getData() const {\n    return Bits.take_front(NumBitWords(size()));\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Portable bit mask operations.\n  //===--------------------------------------------------------------------===//\n  //\n  // These methods all operate on arrays of uint32_t, each holding 32 bits. The\n  // fixed word size makes it easier to work with literal bit vector constants\n  // in portable code.\n  //\n  // The LSB in each word is the lowest numbered bit.  The size of a portable\n  // bit mask is always a whole multiple of 32 bits.  If no bit mask size is\n  // given, the bit mask is assumed to cover the entire BitVector.\n\n  /// setBitsInMask - Add '1' bits from Mask to this vector. Don't resize.\n  /// This computes \"*this |= Mask\".\n  void setBitsInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    applyMask<true, false>(Mask, MaskWords);\n  }\n\n  /// clearBitsInMask - Clear any bits in this vector that are set in Mask.\n  /// Don't resize. This computes \"*this &= ~Mask\".\n  void clearBitsInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    applyMask<false, false>(Mask, MaskWords);\n  }\n\n  /// setBitsNotInMask - Add a bit to this vector for every '0' bit in Mask.\n  /// Don't resize.  This computes \"*this |= ~Mask\".\n  void setBitsNotInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    applyMask<true, true>(Mask, MaskWords);\n  }\n\n  /// clearBitsNotInMask - Clear a bit in this vector for every '0' bit in Mask.\n  /// Don't resize.  This computes \"*this &= Mask\".\n  void clearBitsNotInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    applyMask<false, true>(Mask, MaskWords);\n  }\n\nprivate:\n  /// Perform a logical left shift of \\p Count words by moving everything\n  /// \\p Count words to the right in memory.\n  ///\n  /// While confusing, words are stored from least significant at Bits[0] to\n  /// most significant at Bits[NumWords-1].  A logical shift left, however,\n  /// moves the current least significant bit to a higher logical index, and\n  /// fills the previous least significant bits with 0.  Thus, we actually\n  /// need to move the bytes of the memory to the right, not to the left.\n  /// Example:\n  ///   Words = [0xBBBBAAAA, 0xDDDDFFFF, 0x00000000, 0xDDDD0000]\n  /// represents a BitVector where 0xBBBBAAAA contain the least significant\n  /// bits.  So if we want to shift the BitVector left by 2 words, we need to\n  /// turn this into 0x00000000 0x00000000 0xBBBBAAAA 0xDDDDFFFF by using a\n  /// memmove which moves right, not left.\n  void wordShl(uint32_t Count) {\n    if (Count == 0)\n      return;\n\n    uint32_t NumWords = NumBitWords(Size);\n\n    auto Src = Bits.take_front(NumWords).drop_back(Count);\n    auto Dest = Bits.take_front(NumWords).drop_front(Count);\n\n    // Since we always move Word-sized chunks of data with src and dest both\n    // aligned to a word-boundary, we don't need to worry about endianness\n    // here.\n    std::memmove(Dest.begin(), Src.begin(), Dest.size() * sizeof(BitWord));\n    std::memset(Bits.data(), 0, Count * sizeof(BitWord));\n    clear_unused_bits();\n  }\n\n  /// Perform a logical right shift of \\p Count words by moving those\n  /// words to the left in memory.  See wordShl for more information.\n  ///\n  void wordShr(uint32_t Count) {\n    if (Count == 0)\n      return;\n\n    uint32_t NumWords = NumBitWords(Size);\n\n    auto Src = Bits.take_front(NumWords).drop_front(Count);\n    auto Dest = Bits.take_front(NumWords).drop_back(Count);\n    assert(Dest.size() == Src.size());\n\n    std::memmove(Dest.begin(), Src.begin(), Dest.size() * sizeof(BitWord));\n    std::memset(Dest.end(), 0, Count * sizeof(BitWord));\n  }\n\n  MutableArrayRef<BitWord> allocate(size_t NumWords) {\n    BitWord *RawBits = static_cast<BitWord *>(\n        safe_malloc(NumWords * sizeof(BitWord)));\n    return MutableArrayRef<BitWord>(RawBits, NumWords);\n  }\n\n  int next_unset_in_word(int WordIndex, BitWord Word) const {\n    unsigned Result = WordIndex * BITWORD_SIZE + countTrailingOnes(Word);\n    return Result < size() ? Result : -1;\n  }\n\n  unsigned NumBitWords(unsigned S) const {\n    return (S + BITWORD_SIZE-1) / BITWORD_SIZE;\n  }\n\n  // Set the unused bits in the high words.\n  void set_unused_bits(bool t = true) {\n    //  Set high words first.\n    unsigned UsedWords = NumBitWords(Size);\n    if (Bits.size() > UsedWords)\n      init_words(Bits.drop_front(UsedWords), t);\n\n    //  Then set any stray high bits of the last used word.\n    unsigned ExtraBits = Size % BITWORD_SIZE;\n    if (ExtraBits) {\n      BitWord ExtraBitMask = ~BitWord(0) << ExtraBits;\n      if (t)\n        Bits[UsedWords-1] |= ExtraBitMask;\n      else\n        Bits[UsedWords-1] &= ~ExtraBitMask;\n    }\n  }\n\n  // Clear the unused bits in the high words.\n  void clear_unused_bits() {\n    set_unused_bits(false);\n  }\n\n  void grow(unsigned NewSize) {\n    size_t NewCapacity = std::max<size_t>(NumBitWords(NewSize), Bits.size() * 2);\n    assert(NewCapacity > 0 && \"realloc-ing zero space\");\n    BitWord *NewBits = static_cast<BitWord *>(\n        safe_realloc(Bits.data(), NewCapacity * sizeof(BitWord)));\n    Bits = MutableArrayRef<BitWord>(NewBits, NewCapacity);\n    clear_unused_bits();\n  }\n\n  void init_words(MutableArrayRef<BitWord> B, bool t) {\n    if (B.size() > 0)\n      memset(B.data(), 0 - (int)t, B.size() * sizeof(BitWord));\n  }\n\n  template<bool AddBits, bool InvertMask>\n  void applyMask(const uint32_t *Mask, unsigned MaskWords) {\n    static_assert(BITWORD_SIZE % 32 == 0, \"Unsupported BitWord size.\");\n    MaskWords = std::min(MaskWords, (size() + 31) / 32);\n    const unsigned Scale = BITWORD_SIZE / 32;\n    unsigned i;\n    for (i = 0; MaskWords >= Scale; ++i, MaskWords -= Scale) {\n      BitWord BW = Bits[i];\n      // This inner loop should unroll completely when BITWORD_SIZE > 32.\n      for (unsigned b = 0; b != BITWORD_SIZE; b += 32) {\n        uint32_t M = *Mask++;\n        if (InvertMask) M = ~M;\n        if (AddBits) BW |=   BitWord(M) << b;\n        else         BW &= ~(BitWord(M) << b);\n      }\n      Bits[i] = BW;\n    }\n    for (unsigned b = 0; MaskWords; b += 32, --MaskWords) {\n      uint32_t M = *Mask++;\n      if (InvertMask) M = ~M;\n      if (AddBits) Bits[i] |=   BitWord(M) << b;\n      else         Bits[i] &= ~(BitWord(M) << b);\n    }\n    if (AddBits)\n      clear_unused_bits();\n  }\n\npublic:\n  /// Return the size (in bytes) of the bit vector.\n  size_t getMemorySize() const { return Bits.size() * sizeof(BitWord); }\n  size_t getBitCapacity() const { return Bits.size() * BITWORD_SIZE; }\n};\n\ninline size_t capacity_in_bytes(const BitVector &X) {\n  return X.getMemorySize();\n}\n\ntemplate <> struct DenseMapInfo<BitVector> {\n  static inline BitVector getEmptyKey() { return BitVector(); }\n  static inline BitVector getTombstoneKey() {\n    BitVector V;\n    V.invalid();\n    return V;\n  }\n  static unsigned getHashValue(const BitVector &V) {\n    return DenseMapInfo<std::pair<unsigned, ArrayRef<uintptr_t>>>::getHashValue(\n        std::make_pair(V.size(), V.getData()));\n  }\n  static bool isEqual(const BitVector &LHS, const BitVector &RHS) {\n    if (LHS.isInvalid() || RHS.isInvalid())\n      return LHS.isInvalid() == RHS.isInvalid();\n    return LHS == RHS;\n  }\n};\n} // end namespace llvm\n\nnamespace std {\n  /// Implement std::swap in terms of BitVector swap.\n  inline void\n  swap(llvm::BitVector &LHS, llvm::BitVector &RHS) {\n    LHS.swap(RHS);\n  }\n} // end namespace std\n\n#endif // LLVM_ADT_BITVECTOR_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Hashing.h", "content": "//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the newly proposed standard C++ interfaces for hashing\n// arbitrary data and building hash functions for user-defined types. This\n// interface was originally proposed in N3333[1] and is currently under review\n// for inclusion in a future TR and/or standard.\n//\n// The primary interfaces provide are comprised of one type and three functions:\n//\n//  -- 'hash_code' class is an opaque type representing the hash code for some\n//     data. It is the intended product of hashing, and can be used to implement\n//     hash tables, checksumming, and other common uses of hashes. It is not an\n//     integer type (although it can be converted to one) because it is risky\n//     to assume much about the internals of a hash_code. In particular, each\n//     execution of the program has a high probability of producing a different\n//     hash_code for a given input. Thus their values are not stable to save or\n//     persist, and should only be used during the execution for the\n//     construction of hashing datastructures.\n//\n//  -- 'hash_value' is a function designed to be overloaded for each\n//     user-defined type which wishes to be used within a hashing context. It\n//     should be overloaded within the user-defined type's namespace and found\n//     via ADL. Overloads for primitive types are provided by this library.\n//\n//  -- 'hash_combine' and 'hash_combine_range' are functions designed to aid\n//      programmers in easily and intuitively combining a set of data into\n//      a single hash_code for their object. They should only logically be used\n//      within the implementation of a 'hash_value' routine or similar context.\n//\n// Note that 'hash_combine_range' contains very special logic for hashing\n// a contiguous array of integers or pointers. This logic is *extremely* fast,\n// on a modern Intel \"Gainestown\" Xeon (Nehalem uarch) @2.2 GHz, these were\n// benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys\n// under 32-bytes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_HASHING_H\n#define LLVM_ADT_HASHING_H\n\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/SwapByteOrder.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <string>\n#include <tuple>\n#include <utility>\n\nnamespace llvm {\n\n/// An opaque object representing a hash code.\n///\n/// This object represents the result of hashing some entity. It is intended to\n/// be used to implement hashtables or other hashing-based data structures.\n/// While it wraps and exposes a numeric value, this value should not be\n/// trusted to be stable or predictable across processes or executions.\n///\n/// In order to obtain the hash_code for an object 'x':\n/// \\code\n///   using llvm::hash_value;\n///   llvm::hash_code code = hash_value(x);\n/// \\endcode\nclass hash_code {\n  size_t value;\n\npublic:\n  /// Default construct a hash_code.\n  /// Note that this leaves the value uninitialized.\n  hash_code() = default;\n\n  /// Form a hash code directly from a numerical value.\n  hash_code(size_t value) : value(value) {}\n\n  /// Convert the hash code to its numerical value for use.\n  /*explicit*/ operator size_t() const { return value; }\n\n  friend bool operator==(const hash_code &lhs, const hash_code &rhs) {\n    return lhs.value == rhs.value;\n  }\n  friend bool operator!=(const hash_code &lhs, const hash_code &rhs) {\n    return lhs.value != rhs.value;\n  }\n\n  /// Allow a hash_code to be directly run through hash_value.\n  friend size_t hash_value(const hash_code &code) { return code.value; }\n};\n\n/// Compute a hash_code for any integer value.\n///\n/// Note that this function is intended to compute the same hash_code for\n/// a particular value without regard to the pre-promotion type. This is in\n/// contrast to hash_combine which may produce different hash_codes for\n/// differing argument types even if they would implicit promote to a common\n/// type without changing the value.\ntemplate <typename T>\nstd::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value);\n\n/// Compute a hash_code for a pointer's address.\n///\n/// N.B.: This hashes the *address*. Not the value and not the type.\ntemplate <typename T> hash_code hash_value(const T *ptr);\n\n/// Compute a hash_code for a pair of objects.\ntemplate <typename T, typename U>\nhash_code hash_value(const std::pair<T, U> &arg);\n\n/// Compute a hash_code for a tuple.\ntemplate <typename... Ts>\nhash_code hash_value(const std::tuple<Ts...> &arg);\n\n/// Compute a hash_code for a standard string.\ntemplate <typename T>\nhash_code hash_value(const std::basic_string<T> &arg);\n\n\n/// Override the execution seed with a fixed value.\n///\n/// This hashing library uses a per-execution seed designed to change on each\n/// run with high probability in order to ensure that the hash codes are not\n/// attackable and to ensure that output which is intended to be stable does\n/// not rely on the particulars of the hash codes produced.\n///\n/// That said, there are use cases where it is important to be able to\n/// reproduce *exactly* a specific behavior. To that end, we provide a function\n/// which will forcibly set the seed to a fixed value. This must be done at the\n/// start of the program, before any hashes are computed. Also, it cannot be\n/// undone. This makes it thread-hostile and very hard to use outside of\n/// immediately on start of a simple program designed for reproducible\n/// behavior.\nvoid set_fixed_execution_hash_seed(uint64_t fixed_value);\n\n\n// All of the implementation details of actually computing the various hash\n// code values are held within this namespace. These routines are included in\n// the header file mainly to allow inlining and constant propagation.\nnamespace hashing {\nnamespace detail {\n\ninline uint64_t fetch64(const char *p) {\n  uint64_t result;\n  memcpy(&result, p, sizeof(result));\n  if (sys::IsBigEndianHost)\n    sys::swapByteOrder(result);\n  return result;\n}\n\ninline uint32_t fetch32(const char *p) {\n  uint32_t result;\n  memcpy(&result, p, sizeof(result));\n  if (sys::IsBigEndianHost)\n    sys::swapByteOrder(result);\n  return result;\n}\n\n/// Some primes between 2^63 and 2^64 for various uses.\nstatic constexpr uint64_t k0 = 0xc3a5c85c97cb3127ULL;\nstatic constexpr uint64_t k1 = 0xb492b66fbe98f273ULL;\nstatic constexpr uint64_t k2 = 0x9ae16a3b2f90404fULL;\nstatic constexpr uint64_t k3 = 0xc949d7c7509e6557ULL;\n\n/// Bitwise right rotate.\n/// Normally this will compile to a single instruction, especially if the\n/// shift is a manifest constant.\ninline uint64_t rotate(uint64_t val, size_t shift) {\n  // Avoid shifting by 64: doing so yields an undefined result.\n  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));\n}\n\ninline uint64_t shift_mix(uint64_t val) {\n  return val ^ (val >> 47);\n}\n\ninline uint64_t hash_16_bytes(uint64_t low, uint64_t high) {\n  // Murmur-inspired hashing.\n  const uint64_t kMul = 0x9ddfea08eb382d69ULL;\n  uint64_t a = (low ^ high) * kMul;\n  a ^= (a >> 47);\n  uint64_t b = (high ^ a) * kMul;\n  b ^= (b >> 47);\n  b *= kMul;\n  return b;\n}\n\ninline uint64_t hash_1to3_bytes(const char *s, size_t len, uint64_t seed) {\n  uint8_t a = s[0];\n  uint8_t b = s[len >> 1];\n  uint8_t c = s[len - 1];\n  uint32_t y = static_cast<uint32_t>(a) + (static_cast<uint32_t>(b) << 8);\n  uint32_t z = static_cast<uint32_t>(len) + (static_cast<uint32_t>(c) << 2);\n  return shift_mix(y * k2 ^ z * k3 ^ seed) * k2;\n}\n\ninline uint64_t hash_4to8_bytes(const char *s, size_t len, uint64_t seed) {\n  uint64_t a = fetch32(s);\n  return hash_16_bytes(len + (a << 3), seed ^ fetch32(s + len - 4));\n}\n\ninline uint64_t hash_9to16_bytes(const char *s, size_t len, uint64_t seed) {\n  uint64_t a = fetch64(s);\n  uint64_t b = fetch64(s + len - 8);\n  return hash_16_bytes(seed ^ a, rotate(b + len, len)) ^ b;\n}\n\ninline uint64_t hash_17to32_bytes(const char *s, size_t len, uint64_t seed) {\n  uint64_t a = fetch64(s) * k1;\n  uint64_t b = fetch64(s + 8);\n  uint64_t c = fetch64(s + len - 8) * k2;\n  uint64_t d = fetch64(s + len - 16) * k0;\n  return hash_16_bytes(rotate(a - b, 43) + rotate(c ^ seed, 30) + d,\n                       a + rotate(b ^ k3, 20) - c + len + seed);\n}\n\ninline uint64_t hash_33to64_bytes(const char *s, size_t len, uint64_t seed) {\n  uint64_t z = fetch64(s + 24);\n  uint64_t a = fetch64(s) + (len + fetch64(s + len - 16)) * k0;\n  uint64_t b = rotate(a + z, 52);\n  uint64_t c = rotate(a, 37);\n  a += fetch64(s + 8);\n  c += rotate(a, 7);\n  a += fetch64(s + 16);\n  uint64_t vf = a + z;\n  uint64_t vs = b + rotate(a, 31) + c;\n  a = fetch64(s + 16) + fetch64(s + len - 32);\n  z = fetch64(s + len - 8);\n  b = rotate(a + z, 52);\n  c = rotate(a, 37);\n  a += fetch64(s + len - 24);\n  c += rotate(a, 7);\n  a += fetch64(s + len - 16);\n  uint64_t wf = a + z;\n  uint64_t ws = b + rotate(a, 31) + c;\n  uint64_t r = shift_mix((vf + ws) * k2 + (wf + vs) * k0);\n  return shift_mix((seed ^ (r * k0)) + vs) * k2;\n}\n\ninline uint64_t hash_short(const char *s, size_t length, uint64_t seed) {\n  if (length >= 4 && length <= 8)\n    return hash_4to8_bytes(s, length, seed);\n  if (length > 8 && length <= 16)\n    return hash_9to16_bytes(s, length, seed);\n  if (length > 16 && length <= 32)\n    return hash_17to32_bytes(s, length, seed);\n  if (length > 32)\n    return hash_33to64_bytes(s, length, seed);\n  if (length != 0)\n    return hash_1to3_bytes(s, length, seed);\n\n  return k2 ^ seed;\n}\n\n/// The intermediate state used during hashing.\n/// Currently, the algorithm for computing hash codes is based on CityHash and\n/// keeps 56 bytes of arbitrary state.\nstruct hash_state {\n  uint64_t h0 = 0, h1 = 0, h2 = 0, h3 = 0, h4 = 0, h5 = 0, h6 = 0;\n\n  /// Create a new hash_state structure and initialize it based on the\n  /// seed and the first 64-byte chunk.\n  /// This effectively performs the initial mix.\n  static hash_state create(const char *s, uint64_t seed) {\n    hash_state state = {\n      0, seed, hash_16_bytes(seed, k1), rotate(seed ^ k1, 49),\n      seed * k1, shift_mix(seed), 0 };\n    state.h6 = hash_16_bytes(state.h4, state.h5);\n    state.mix(s);\n    return state;\n  }\n\n  /// Mix 32-bytes from the input sequence into the 16-bytes of 'a'\n  /// and 'b', including whatever is already in 'a' and 'b'.\n  static void mix_32_bytes(const char *s, uint64_t &a, uint64_t &b) {\n    a += fetch64(s);\n    uint64_t c = fetch64(s + 24);\n    b = rotate(b + a + c, 21);\n    uint64_t d = a;\n    a += fetch64(s + 8) + fetch64(s + 16);\n    b += rotate(a, 44) + d;\n    a += c;\n  }\n\n  /// Mix in a 64-byte buffer of data.\n  /// We mix all 64 bytes even when the chunk length is smaller, but we\n  /// record the actual length.\n  void mix(const char *s) {\n    h0 = rotate(h0 + h1 + h3 + fetch64(s + 8), 37) * k1;\n    h1 = rotate(h1 + h4 + fetch64(s + 48), 42) * k1;\n    h0 ^= h6;\n    h1 += h3 + fetch64(s + 40);\n    h2 = rotate(h2 + h5, 33) * k1;\n    h3 = h4 * k1;\n    h4 = h0 + h5;\n    mix_32_bytes(s, h3, h4);\n    h5 = h2 + h6;\n    h6 = h1 + fetch64(s + 16);\n    mix_32_bytes(s + 32, h5, h6);\n    std::swap(h2, h0);\n  }\n\n  /// Compute the final 64-bit hash code value based on the current\n  /// state and the length of bytes hashed.\n  uint64_t finalize(size_t length) {\n    return hash_16_bytes(hash_16_bytes(h3, h5) + shift_mix(h1) * k1 + h2,\n                         hash_16_bytes(h4, h6) + shift_mix(length) * k1 + h0);\n  }\n};\n\n\n/// A global, fixed seed-override variable.\n///\n/// This variable can be set using the \\see llvm::set_fixed_execution_seed\n/// function. See that function for details. Do not, under any circumstances,\n/// set or read this variable.\nextern uint64_t fixed_seed_override;\n\ninline uint64_t get_execution_seed() {\n  // FIXME: This needs to be a per-execution seed. This is just a placeholder\n  // implementation. Switching to a per-execution seed is likely to flush out\n  // instability bugs and so will happen as its own commit.\n  //\n  // However, if there is a fixed seed override set the first time this is\n  // called, return that instead of the per-execution seed.\n  const uint64_t seed_prime = 0xff51afd7ed558ccdULL;\n  static uint64_t seed = fixed_seed_override ? fixed_seed_override : seed_prime;\n  return seed;\n}\n\n\n/// Trait to indicate whether a type's bits can be hashed directly.\n///\n/// A type trait which is true if we want to combine values for hashing by\n/// reading the underlying data. It is false if values of this type must\n/// first be passed to hash_value, and the resulting hash_codes combined.\n//\n// FIXME: We want to replace is_integral_or_enum and is_pointer here with\n// a predicate which asserts that comparing the underlying storage of two\n// values of the type for equality is equivalent to comparing the two values\n// for equality. For all the platforms we care about, this holds for integers\n// and pointers, but there are platforms where it doesn't and we would like to\n// support user-defined types which happen to satisfy this property.\ntemplate <typename T> struct is_hashable_data\n  : std::integral_constant<bool, ((is_integral_or_enum<T>::value ||\n                                   std::is_pointer<T>::value) &&\n                                  64 % sizeof(T) == 0)> {};\n\n// Special case std::pair to detect when both types are viable and when there\n// is no alignment-derived padding in the pair. This is a bit of a lie because\n// std::pair isn't truly POD, but it's close enough in all reasonable\n// implementations for our use case of hashing the underlying data.\ntemplate <typename T, typename U> struct is_hashable_data<std::pair<T, U> >\n  : std::integral_constant<bool, (is_hashable_data<T>::value &&\n                                  is_hashable_data<U>::value &&\n                                  (sizeof(T) + sizeof(U)) ==\n                                   sizeof(std::pair<T, U>))> {};\n\n/// Helper to get the hashable data representation for a type.\n/// This variant is enabled when the type itself can be used.\ntemplate <typename T>\nstd::enable_if_t<is_hashable_data<T>::value, T>\nget_hashable_data(const T &value) {\n  return value;\n}\n/// Helper to get the hashable data representation for a type.\n/// This variant is enabled when we must first call hash_value and use the\n/// result as our data.\ntemplate <typename T>\nstd::enable_if_t<!is_hashable_data<T>::value, size_t>\nget_hashable_data(const T &value) {\n  using ::llvm::hash_value;\n  return hash_value(value);\n}\n\n/// Helper to store data from a value into a buffer and advance the\n/// pointer into that buffer.\n///\n/// This routine first checks whether there is enough space in the provided\n/// buffer, and if not immediately returns false. If there is space, it\n/// copies the underlying bytes of value into the buffer, advances the\n/// buffer_ptr past the copied bytes, and returns true.\ntemplate <typename T>\nbool store_and_advance(char *&buffer_ptr, char *buffer_end, const T& value,\n                       size_t offset = 0) {\n  size_t store_size = sizeof(value) - offset;\n  if (buffer_ptr + store_size > buffer_end)\n    return false;\n  const char *value_data = reinterpret_cast<const char *>(&value);\n  memcpy(buffer_ptr, value_data + offset, store_size);\n  buffer_ptr += store_size;\n  return true;\n}\n\n/// Implement the combining of integral values into a hash_code.\n///\n/// This overload is selected when the value type of the iterator is\n/// integral. Rather than computing a hash_code for each object and then\n/// combining them, this (as an optimization) directly combines the integers.\ntemplate <typename InputIteratorT>\nhash_code hash_combine_range_impl(InputIteratorT first, InputIteratorT last) {\n  const uint64_t seed = get_execution_seed();\n  char buffer[64], *buffer_ptr = buffer;\n  char *const buffer_end = std::end(buffer);\n  while (first != last && store_and_advance(buffer_ptr, buffer_end,\n                                            get_hashable_data(*first)))\n    ++first;\n  if (first == last)\n    return hash_short(buffer, buffer_ptr - buffer, seed);\n  assert(buffer_ptr == buffer_end);\n\n  hash_state state = state.create(buffer, seed);\n  size_t length = 64;\n  while (first != last) {\n    // Fill up the buffer. We don't clear it, which re-mixes the last round\n    // when only a partial 64-byte chunk is left.\n    buffer_ptr = buffer;\n    while (first != last && store_and_advance(buffer_ptr, buffer_end,\n                                              get_hashable_data(*first)))\n      ++first;\n\n    // Rotate the buffer if we did a partial fill in order to simulate doing\n    // a mix of the last 64-bytes. That is how the algorithm works when we\n    // have a contiguous byte sequence, and we want to emulate that here.\n    std::rotate(buffer, buffer_ptr, buffer_end);\n\n    // Mix this chunk into the current state.\n    state.mix(buffer);\n    length += buffer_ptr - buffer;\n  };\n\n  return state.finalize(length);\n}\n\n/// Implement the combining of integral values into a hash_code.\n///\n/// This overload is selected when the value type of the iterator is integral\n/// and when the input iterator is actually a pointer. Rather than computing\n/// a hash_code for each object and then combining them, this (as an\n/// optimization) directly combines the integers. Also, because the integers\n/// are stored in contiguous memory, this routine avoids copying each value\n/// and directly reads from the underlying memory.\ntemplate <typename ValueT>\nstd::enable_if_t<is_hashable_data<ValueT>::value, hash_code>\nhash_combine_range_impl(ValueT *first, ValueT *last) {\n  const uint64_t seed = get_execution_seed();\n  const char *s_begin = reinterpret_cast<const char *>(first);\n  const char *s_end = reinterpret_cast<const char *>(last);\n  const size_t length = std::distance(s_begin, s_end);\n  if (length <= 64)\n    return hash_short(s_begin, length, seed);\n\n  const char *s_aligned_end = s_begin + (length & ~63);\n  hash_state state = state.create(s_begin, seed);\n  s_begin += 64;\n  while (s_begin != s_aligned_end) {\n    state.mix(s_begin);\n    s_begin += 64;\n  }\n  if (length & 63)\n    state.mix(s_end - 64);\n\n  return state.finalize(length);\n}\n\n} // namespace detail\n} // namespace hashing\n\n\n/// Compute a hash_code for a sequence of values.\n///\n/// This hashes a sequence of values. It produces the same hash_code as\n/// 'hash_combine(a, b, c, ...)', but can run over arbitrary sized sequences\n/// and is significantly faster given pointers and types which can be hashed as\n/// a sequence of bytes.\ntemplate <typename InputIteratorT>\nhash_code hash_combine_range(InputIteratorT first, InputIteratorT last) {\n  return ::llvm::hashing::detail::hash_combine_range_impl(first, last);\n}\n\n\n// Implementation details for hash_combine.\nnamespace hashing {\nnamespace detail {\n\n/// Helper class to manage the recursive combining of hash_combine\n/// arguments.\n///\n/// This class exists to manage the state and various calls involved in the\n/// recursive combining of arguments used in hash_combine. It is particularly\n/// useful at minimizing the code in the recursive calls to ease the pain\n/// caused by a lack of variadic functions.\nstruct hash_combine_recursive_helper {\n  char buffer[64] = {};\n  hash_state state;\n  const uint64_t seed;\n\npublic:\n  /// Construct a recursive hash combining helper.\n  ///\n  /// This sets up the state for a recursive hash combine, including getting\n  /// the seed and buffer setup.\n  hash_combine_recursive_helper()\n    : seed(get_execution_seed()) {}\n\n  /// Combine one chunk of data into the current in-flight hash.\n  ///\n  /// This merges one chunk of data into the hash. First it tries to buffer\n  /// the data. If the buffer is full, it hashes the buffer into its\n  /// hash_state, empties it, and then merges the new chunk in. This also\n  /// handles cases where the data straddles the end of the buffer.\n  template <typename T>\n  char *combine_data(size_t &length, char *buffer_ptr, char *buffer_end, T data) {\n    if (!store_and_advance(buffer_ptr, buffer_end, data)) {\n      // Check for skew which prevents the buffer from being packed, and do\n      // a partial store into the buffer to fill it. This is only a concern\n      // with the variadic combine because that formation can have varying\n      // argument types.\n      size_t partial_store_size = buffer_end - buffer_ptr;\n      memcpy(buffer_ptr, &data, partial_store_size);\n\n      // If the store fails, our buffer is full and ready to hash. We have to\n      // either initialize the hash state (on the first full buffer) or mix\n      // this buffer into the existing hash state. Length tracks the *hashed*\n      // length, not the buffered length.\n      if (length == 0) {\n        state = state.create(buffer, seed);\n        length = 64;\n      } else {\n        // Mix this chunk into the current state and bump length up by 64.\n        state.mix(buffer);\n        length += 64;\n      }\n      // Reset the buffer_ptr to the head of the buffer for the next chunk of\n      // data.\n      buffer_ptr = buffer;\n\n      // Try again to store into the buffer -- this cannot fail as we only\n      // store types smaller than the buffer.\n      if (!store_and_advance(buffer_ptr, buffer_end, data,\n                             partial_store_size))\n        llvm_unreachable(\"buffer smaller than stored type\");\n    }\n    return buffer_ptr;\n  }\n\n  /// Recursive, variadic combining method.\n  ///\n  /// This function recurses through each argument, combining that argument\n  /// into a single hash.\n  template <typename T, typename ...Ts>\n  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end,\n                    const T &arg, const Ts &...args) {\n    buffer_ptr = combine_data(length, buffer_ptr, buffer_end, get_hashable_data(arg));\n\n    // Recurse to the next argument.\n    return combine(length, buffer_ptr, buffer_end, args...);\n  }\n\n  /// Base case for recursive, variadic combining.\n  ///\n  /// The base case when combining arguments recursively is reached when all\n  /// arguments have been handled. It flushes the remaining buffer and\n  /// constructs a hash_code.\n  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end) {\n    // Check whether the entire set of values fit in the buffer. If so, we'll\n    // use the optimized short hashing routine and skip state entirely.\n    if (length == 0)\n      return hash_short(buffer, buffer_ptr - buffer, seed);\n\n    // Mix the final buffer, rotating it if we did a partial fill in order to\n    // simulate doing a mix of the last 64-bytes. That is how the algorithm\n    // works when we have a contiguous byte sequence, and we want to emulate\n    // that here.\n    std::rotate(buffer, buffer_ptr, buffer_end);\n\n    // Mix this chunk into the current state.\n    state.mix(buffer);\n    length += buffer_ptr - buffer;\n\n    return state.finalize(length);\n  }\n};\n\n} // namespace detail\n} // namespace hashing\n\n/// Combine values into a single hash_code.\n///\n/// This routine accepts a varying number of arguments of any type. It will\n/// attempt to combine them into a single hash_code. For user-defined types it\n/// attempts to call a \\see hash_value overload (via ADL) for the type. For\n/// integer and pointer types it directly combines their data into the\n/// resulting hash_code.\n///\n/// The result is suitable for returning from a user's hash_value\n/// *implementation* for their user-defined type. Consumers of a type should\n/// *not* call this routine, they should instead call 'hash_value'.\ntemplate <typename ...Ts> hash_code hash_combine(const Ts &...args) {\n  // Recursively hash each argument using a helper class.\n  ::llvm::hashing::detail::hash_combine_recursive_helper helper;\n  return helper.combine(0, helper.buffer, helper.buffer + 64, args...);\n}\n\n// Implementation details for implementations of hash_value overloads provided\n// here.\nnamespace hashing {\nnamespace detail {\n\n/// Helper to hash the value of a single integer.\n///\n/// Overloads for smaller integer types are not provided to ensure consistent\n/// behavior in the presence of integral promotions. Essentially,\n/// \"hash_value('4')\" and \"hash_value('0' + 4)\" should be the same.\ninline hash_code hash_integer_value(uint64_t value) {\n  // Similar to hash_4to8_bytes but using a seed instead of length.\n  const uint64_t seed = get_execution_seed();\n  const char *s = reinterpret_cast<const char *>(&value);\n  const uint64_t a = fetch32(s);\n  return hash_16_bytes(seed + (a << 3), fetch32(s + 4));\n}\n\n} // namespace detail\n} // namespace hashing\n\n// Declared and documented above, but defined here so that any of the hashing\n// infrastructure is available.\ntemplate <typename T>\nstd::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value) {\n  return ::llvm::hashing::detail::hash_integer_value(\n      static_cast<uint64_t>(value));\n}\n\n// Declared and documented above, but defined here so that any of the hashing\n// infrastructure is available.\ntemplate <typename T> hash_code hash_value(const T *ptr) {\n  return ::llvm::hashing::detail::hash_integer_value(\n    reinterpret_cast<uintptr_t>(ptr));\n}\n\n// Declared and documented above, but defined here so that any of the hashing\n// infrastructure is available.\ntemplate <typename T, typename U>\nhash_code hash_value(const std::pair<T, U> &arg) {\n  return hash_combine(arg.first, arg.second);\n}\n\n// Implementation details for the hash_value overload for std::tuple<...>(...).\nnamespace hashing {\nnamespace detail {\n\ntemplate <typename... Ts, std::size_t... Indices>\nhash_code hash_value_tuple_helper(const std::tuple<Ts...> &arg,\n                                  std::index_sequence<Indices...>) {\n  return hash_combine(std::get<Indices>(arg)...);\n}\n\n} // namespace detail\n} // namespace hashing\n\ntemplate <typename... Ts>\nhash_code hash_value(const std::tuple<Ts...> &arg) {\n  // TODO: Use std::apply when LLVM starts using C++17.\n  return ::llvm::hashing::detail::hash_value_tuple_helper(\n      arg, typename std::index_sequence_for<Ts...>());\n}\n\n// Declared and documented above, but defined here so that any of the hashing\n// infrastructure is available.\ntemplate <typename T>\nhash_code hash_value(const std::basic_string<T> &arg) {\n  return hash_combine_range(arg.begin(), arg.end());\n}\n\n} // namespace llvm\n\n#endif\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "content": "//==- llvm/ADT/IntrusiveRefCntPtr.h - Smart Refcounting Pointer --*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the RefCountedBase, ThreadSafeRefCountedBase, and\n// IntrusiveRefCntPtr classes.\n//\n// IntrusiveRefCntPtr is a smart pointer to an object which maintains a\n// reference count.  (ThreadSafe)RefCountedBase is a mixin class that adds a\n// refcount member variable and methods for updating the refcount.  An object\n// that inherits from (ThreadSafe)RefCountedBase deletes itself when its\n// refcount hits zero.\n//\n// For example:\n//\n//   class MyClass : public RefCountedBase<MyClass> {};\n//\n//   void foo() {\n//     // Constructing an IntrusiveRefCntPtr increases the pointee's refcount by\n//     // 1 (from 0 in this case).\n//     IntrusiveRefCntPtr<MyClass> Ptr1(new MyClass());\n//\n//     // Copying an IntrusiveRefCntPtr increases the pointee's refcount by 1.\n//     IntrusiveRefCntPtr<MyClass> Ptr2(Ptr1);\n//\n//     // Constructing an IntrusiveRefCntPtr has no effect on the object's\n//     // refcount.  After a move, the moved-from pointer is null.\n//     IntrusiveRefCntPtr<MyClass> Ptr3(std::move(Ptr1));\n//     assert(Ptr1 == nullptr);\n//\n//     // Clearing an IntrusiveRefCntPtr decreases the pointee's refcount by 1.\n//     Ptr2.reset();\n//\n//     // The object deletes itself when we return from the function, because\n//     // Ptr3's destructor decrements its refcount to 0.\n//   }\n//\n// You can use IntrusiveRefCntPtr with isa<T>(), dyn_cast<T>(), etc.:\n//\n//   IntrusiveRefCntPtr<MyClass> Ptr(new MyClass());\n//   OtherClass *Other = dyn_cast<OtherClass>(Ptr);  // Ptr.get() not required\n//\n// IntrusiveRefCntPtr works with any class that\n//\n//  - inherits from (ThreadSafe)RefCountedBase,\n//  - has Retain() and Release() methods, or\n//  - specializes IntrusiveRefCntPtrInfo.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_INTRUSIVEREFCNTPTR_H\n#define LLVM_ADT_INTRUSIVEREFCNTPTR_H\n\n#include <atomic>\n#include <cassert>\n#include <cstddef>\n#include <memory>\n\nnamespace llvm {\n\n/// A CRTP mixin class that adds reference counting to a type.\n///\n/// The lifetime of an object which inherits from RefCountedBase is managed by\n/// calls to Release() and Retain(), which increment and decrement the object's\n/// refcount, respectively.  When a Release() call decrements the refcount to 0,\n/// the object deletes itself.\ntemplate <class Derived> class RefCountedBase {\n  mutable unsigned RefCount = 0;\n\nprotected:\n  RefCountedBase() = default;\n  RefCountedBase(const RefCountedBase &) {}\n  RefCountedBase &operator=(const RefCountedBase &) = delete;\n\n#ifndef NDEBUG\n  ~RefCountedBase() {\n    assert(RefCount == 0 &&\n           \"Destruction occured when there are still references to this.\");\n  }\n#else\n  // Default the destructor in release builds, A trivial destructor may enable\n  // better codegen.\n  ~RefCountedBase() = default;\n#endif\n\npublic:\n  void Retain() const { ++RefCount; }\n\n  void Release() const {\n    assert(RefCount > 0 && \"Reference count is already zero.\");\n    if (--RefCount == 0)\n      delete static_cast<const Derived *>(this);\n  }\n};\n\n/// A thread-safe version of \\c RefCountedBase.\ntemplate <class Derived> class ThreadSafeRefCountedBase {\n  mutable std::atomic<int> RefCount{0};\n\nprotected:\n  ThreadSafeRefCountedBase() = default;\n  ThreadSafeRefCountedBase(const ThreadSafeRefCountedBase &) {}\n  ThreadSafeRefCountedBase &\n  operator=(const ThreadSafeRefCountedBase &) = delete;\n\n#ifndef NDEBUG\n  ~ThreadSafeRefCountedBase() {\n    assert(RefCount == 0 &&\n           \"Destruction occured when there are still references to this.\");\n  }\n#else\n  // Default the destructor in release builds, A trivial destructor may enable\n  // better codegen.\n  ~ThreadSafeRefCountedBase() = default;\n#endif\n\npublic:\n  void Retain() const { RefCount.fetch_add(1, std::memory_order_relaxed); }\n\n  void Release() const {\n    int NewRefCount = RefCount.fetch_sub(1, std::memory_order_acq_rel) - 1;\n    assert(NewRefCount >= 0 && \"Reference count was already zero.\");\n    if (NewRefCount == 0)\n      delete static_cast<const Derived *>(this);\n  }\n};\n\n/// Class you can specialize to provide custom retain/release functionality for\n/// a type.\n///\n/// Usually specializing this class is not necessary, as IntrusiveRefCntPtr\n/// works with any type which defines Retain() and Release() functions -- you\n/// can define those functions yourself if RefCountedBase doesn't work for you.\n///\n/// One case when you might want to specialize this type is if you have\n///  - Foo.h defines type Foo and includes Bar.h, and\n///  - Bar.h uses IntrusiveRefCntPtr<Foo> in inline functions.\n///\n/// Because Foo.h includes Bar.h, Bar.h can't include Foo.h in order to pull in\n/// the declaration of Foo.  Without the declaration of Foo, normally Bar.h\n/// wouldn't be able to use IntrusiveRefCntPtr<Foo>, which wants to call\n/// T::Retain and T::Release.\n///\n/// To resolve this, Bar.h could include a third header, FooFwd.h, which\n/// forward-declares Foo and specializes IntrusiveRefCntPtrInfo<Foo>.  Then\n/// Bar.h could use IntrusiveRefCntPtr<Foo>, although it still couldn't call any\n/// functions on Foo itself, because Foo would be an incomplete type.\ntemplate <typename T> struct IntrusiveRefCntPtrInfo {\n  static void retain(T *obj) { obj->Retain(); }\n  static void release(T *obj) { obj->Release(); }\n};\n\n/// A smart pointer to a reference-counted object that inherits from\n/// RefCountedBase or ThreadSafeRefCountedBase.\n///\n/// This class increments its pointee's reference count when it is created, and\n/// decrements its refcount when it's destroyed (or is changed to point to a\n/// different object).\ntemplate <typename T> class IntrusiveRefCntPtr {\n  T *Obj = nullptr;\n\npublic:\n  using element_type = T;\n\n  explicit IntrusiveRefCntPtr() = default;\n  IntrusiveRefCntPtr(T *obj) : Obj(obj) { retain(); }\n  IntrusiveRefCntPtr(const IntrusiveRefCntPtr &S) : Obj(S.Obj) { retain(); }\n  IntrusiveRefCntPtr(IntrusiveRefCntPtr &&S) : Obj(S.Obj) { S.Obj = nullptr; }\n\n  template <class X,\n            std::enable_if_t<std::is_convertible<X *, T *>::value, bool> = true>\n  IntrusiveRefCntPtr(IntrusiveRefCntPtr<X> S) : Obj(S.get()) {\n    S.Obj = nullptr;\n  }\n\n  template <class X,\n            std::enable_if_t<std::is_convertible<X *, T *>::value, bool> = true>\n  IntrusiveRefCntPtr(std::unique_ptr<X> S) : Obj(S.release()) {\n    retain();\n  }\n\n  ~IntrusiveRefCntPtr() { release(); }\n\n  IntrusiveRefCntPtr &operator=(IntrusiveRefCntPtr S) {\n    swap(S);\n    return *this;\n  }\n\n  T &operator*() const { return *Obj; }\n  T *operator->() const { return Obj; }\n  T *get() const { return Obj; }\n  explicit operator bool() const { return Obj; }\n\n  void swap(IntrusiveRefCntPtr &other) {\n    T *tmp = other.Obj;\n    other.Obj = Obj;\n    Obj = tmp;\n  }\n\n  void reset() {\n    release();\n    Obj = nullptr;\n  }\n\n  void resetWithoutRelease() { Obj = nullptr; }\n\nprivate:\n  void retain() {\n    if (Obj)\n      IntrusiveRefCntPtrInfo<T>::retain(Obj);\n  }\n\n  void release() {\n    if (Obj)\n      IntrusiveRefCntPtrInfo<T>::release(Obj);\n  }\n\n  template <typename X> friend class IntrusiveRefCntPtr;\n};\n\ntemplate <class T, class U>\ninline bool operator==(const IntrusiveRefCntPtr<T> &A,\n                       const IntrusiveRefCntPtr<U> &B) {\n  return A.get() == B.get();\n}\n\ntemplate <class T, class U>\ninline bool operator!=(const IntrusiveRefCntPtr<T> &A,\n                       const IntrusiveRefCntPtr<U> &B) {\n  return A.get() != B.get();\n}\n\ntemplate <class T, class U>\ninline bool operator==(const IntrusiveRefCntPtr<T> &A, U *B) {\n  return A.get() == B;\n}\n\ntemplate <class T, class U>\ninline bool operator!=(const IntrusiveRefCntPtr<T> &A, U *B) {\n  return A.get() != B;\n}\n\ntemplate <class T, class U>\ninline bool operator==(T *A, const IntrusiveRefCntPtr<U> &B) {\n  return A == B.get();\n}\n\ntemplate <class T, class U>\ninline bool operator!=(T *A, const IntrusiveRefCntPtr<U> &B) {\n  return A != B.get();\n}\n\ntemplate <class T>\nbool operator==(std::nullptr_t, const IntrusiveRefCntPtr<T> &B) {\n  return !B;\n}\n\ntemplate <class T>\nbool operator==(const IntrusiveRefCntPtr<T> &A, std::nullptr_t B) {\n  return B == A;\n}\n\ntemplate <class T>\nbool operator!=(std::nullptr_t A, const IntrusiveRefCntPtr<T> &B) {\n  return !(A == B);\n}\n\ntemplate <class T>\nbool operator!=(const IntrusiveRefCntPtr<T> &A, std::nullptr_t B) {\n  return !(A == B);\n}\n\n// Make IntrusiveRefCntPtr work with dyn_cast, isa, and the other idioms from\n// Casting.h.\ntemplate <typename From> struct simplify_type;\n\ntemplate <class T> struct simplify_type<IntrusiveRefCntPtr<T>> {\n  using SimpleType = T *;\n\n  static SimpleType getSimplifiedValue(IntrusiveRefCntPtr<T> &Val) {\n    return Val.get();\n  }\n};\n\ntemplate <class T> struct simplify_type<const IntrusiveRefCntPtr<T>> {\n  using SimpleType = /*const*/ T *;\n\n  static SimpleType getSimplifiedValue(const IntrusiveRefCntPtr<T> &Val) {\n    return Val.get();\n  }\n};\n\n/// Factory function for creating intrusive ref counted pointers.\ntemplate <typename T, typename... Args>\nIntrusiveRefCntPtr<T> makeIntrusiveRefCnt(Args &&...A) {\n  return IntrusiveRefCntPtr<T>(new T(std::forward<Args>(A)...));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_INTRUSIVEREFCNTPTR_H\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "content": "//===- Optional.h - Simple variant for passing optional values --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file provides Optional, a template class modeled in the spirit of\n//  OCaml's 'opt' variant.  The idea is to strongly type whether or not\n//  a value can be optional.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_OPTIONAL_H\n#define LLVM_ADT_OPTIONAL_H\n\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <memory>\n#include <new>\n#include <utility>\n\nnamespace llvm {\n\nclass raw_ostream;\n\nnamespace optional_detail {\n\nstruct in_place_t {};\n\n/// Storage for any type.\n//\n// The specialization condition intentionally uses\n// llvm::is_trivially_copy_constructible instead of\n// std::is_trivially_copy_constructible.  GCC versions prior to 7.4 may\n// instantiate the copy constructor of `T` when\n// std::is_trivially_copy_constructible is instantiated.  This causes\n// compilation to fail if we query the trivially copy constructible property of\n// a class which is not copy constructible.\n//\n// The current implementation of OptionalStorage insists that in order to use\n// the trivial specialization, the value_type must be trivially copy\n// constructible and trivially copy assignable due to =default implementations\n// of the copy/move constructor/assignment.  It does not follow that this is\n// necessarily the case std::is_trivially_copyable is true (hence the expanded\n// specialization condition).\n//\n// The move constructible / assignable conditions emulate the remaining behavior\n// of std::is_trivially_copyable.\ntemplate <typename T, bool = (llvm::is_trivially_copy_constructible<T>::value &&\n                              std::is_trivially_copy_assignable<T>::value &&\n                              (std::is_trivially_move_constructible<T>::value ||\n                               !std::is_move_constructible<T>::value) &&\n                              (std::is_trivially_move_assignable<T>::value ||\n                               !std::is_move_assignable<T>::value))>\nclass OptionalStorage {\n  union {\n    char empty;\n    T value;\n  };\n  bool hasVal;\n\npublic:\n  ~OptionalStorage() { reset(); }\n\n  constexpr OptionalStorage() noexcept : empty(), hasVal(false) {}\n\n  constexpr OptionalStorage(OptionalStorage const &other) : OptionalStorage() {\n    if (other.hasValue()) {\n      emplace(other.value);\n    }\n  }\n  constexpr OptionalStorage(OptionalStorage &&other) : OptionalStorage() {\n    if (other.hasValue()) {\n      emplace(std::move(other.value));\n    }\n  }\n\n  template <class... Args>\n  constexpr explicit OptionalStorage(in_place_t, Args &&... args)\n      : value(std::forward<Args>(args)...), hasVal(true) {}\n\n  void reset() noexcept {\n    if (hasVal) {\n      value.~T();\n      hasVal = false;\n    }\n  }\n\n  constexpr bool hasValue() const noexcept { return hasVal; }\n\n  T &getValue() LLVM_LVALUE_FUNCTION noexcept {\n    assert(hasVal);\n    return value;\n  }\n  constexpr T const &getValue() const LLVM_LVALUE_FUNCTION noexcept {\n    assert(hasVal);\n    return value;\n  }\n#if LLVM_HAS_RVALUE_REFERENCE_THIS\n  T &&getValue() && noexcept {\n    assert(hasVal);\n    return std::move(value);\n  }\n#endif\n\n  template <class... Args> void emplace(Args &&... args) {\n    reset();\n    ::new ((void *)std::addressof(value)) T(std::forward<Args>(args)...);\n    hasVal = true;\n  }\n\n  OptionalStorage &operator=(T const &y) {\n    if (hasValue()) {\n      value = y;\n    } else {\n      ::new ((void *)std::addressof(value)) T(y);\n      hasVal = true;\n    }\n    return *this;\n  }\n  OptionalStorage &operator=(T &&y) {\n    if (hasValue()) {\n      value = std::move(y);\n    } else {\n      ::new ((void *)std::addressof(value)) T(std::move(y));\n      hasVal = true;\n    }\n    return *this;\n  }\n\n  OptionalStorage &operator=(OptionalStorage const &other) {\n    if (other.hasValue()) {\n      if (hasValue()) {\n        value = other.value;\n      } else {\n        ::new ((void *)std::addressof(value)) T(other.value);\n        hasVal = true;\n      }\n    } else {\n      reset();\n    }\n    return *this;\n  }\n\n  OptionalStorage &operator=(OptionalStorage &&other) {\n    if (other.hasValue()) {\n      if (hasValue()) {\n        value = std::move(other.value);\n      } else {\n        ::new ((void *)std::addressof(value)) T(std::move(other.value));\n        hasVal = true;\n      }\n    } else {\n      reset();\n    }\n    return *this;\n  }\n};\n\ntemplate <typename T> class OptionalStorage<T, true> {\n  union {\n    char empty;\n    T value;\n  };\n  bool hasVal = false;\n\npublic:\n  ~OptionalStorage() = default;\n\n  constexpr OptionalStorage() noexcept : empty{} {}\n\n  constexpr OptionalStorage(OptionalStorage const &other) = default;\n  constexpr OptionalStorage(OptionalStorage &&other) = default;\n\n  OptionalStorage &operator=(OptionalStorage const &other) = default;\n  OptionalStorage &operator=(OptionalStorage &&other) = default;\n\n  template <class... Args>\n  constexpr explicit OptionalStorage(in_place_t, Args &&... args)\n      : value(std::forward<Args>(args)...), hasVal(true) {}\n\n  void reset() noexcept {\n    if (hasVal) {\n      value.~T();\n      hasVal = false;\n    }\n  }\n\n  constexpr bool hasValue() const noexcept { return hasVal; }\n\n  T &getValue() LLVM_LVALUE_FUNCTION noexcept {\n    assert(hasVal);\n    return value;\n  }\n  constexpr T const &getValue() const LLVM_LVALUE_FUNCTION noexcept {\n    assert(hasVal);\n    return value;\n  }\n#if LLVM_HAS_RVALUE_REFERENCE_THIS\n  T &&getValue() && noexcept {\n    assert(hasVal);\n    return std::move(value);\n  }\n#endif\n\n  template <class... Args> void emplace(Args &&... args) {\n    reset();\n    ::new ((void *)std::addressof(value)) T(std::forward<Args>(args)...);\n    hasVal = true;\n  }\n\n  OptionalStorage &operator=(T const &y) {\n    if (hasValue()) {\n      value = y;\n    } else {\n      ::new ((void *)std::addressof(value)) T(y);\n      hasVal = true;\n    }\n    return *this;\n  }\n  OptionalStorage &operator=(T &&y) {\n    if (hasValue()) {\n      value = std::move(y);\n    } else {\n      ::new ((void *)std::addressof(value)) T(std::move(y));\n      hasVal = true;\n    }\n    return *this;\n  }\n};\n\n} // namespace optional_detail\n\ntemplate <typename T> class Optional {\n  optional_detail::OptionalStorage<T> Storage;\n\npublic:\n  using value_type = T;\n\n  constexpr Optional() {}\n  constexpr Optional(NoneType) {}\n\n  constexpr Optional(const T &y) : Storage(optional_detail::in_place_t{}, y) {}\n  constexpr Optional(const Optional &O) = default;\n\n  constexpr Optional(T &&y)\n      : Storage(optional_detail::in_place_t{}, std::move(y)) {}\n  constexpr Optional(Optional &&O) = default;\n\n  Optional &operator=(T &&y) {\n    Storage = std::move(y);\n    return *this;\n  }\n  Optional &operator=(Optional &&O) = default;\n\n  /// Create a new object by constructing it in place with the given arguments.\n  template <typename... ArgTypes> void emplace(ArgTypes &&... Args) {\n    Storage.emplace(std::forward<ArgTypes>(Args)...);\n  }\n\n  static constexpr Optional create(const T *y) {\n    return y ? Optional(*y) : Optional();\n  }\n\n  Optional &operator=(const T &y) {\n    Storage = y;\n    return *this;\n  }\n  Optional &operator=(const Optional &O) = default;\n\n  void reset() { Storage.reset(); }\n\n  constexpr const T *getPointer() const { return &Storage.getValue(); }\n  T *getPointer() { return &Storage.getValue(); }\n  constexpr const T &getValue() const LLVM_LVALUE_FUNCTION {\n    return Storage.getValue();\n  }\n  T &getValue() LLVM_LVALUE_FUNCTION { return Storage.getValue(); }\n\n  constexpr explicit operator bool() const { return hasValue(); }\n  constexpr bool hasValue() const { return Storage.hasValue(); }\n  constexpr const T *operator->() const { return getPointer(); }\n  T *operator->() { return getPointer(); }\n  constexpr const T &operator*() const LLVM_LVALUE_FUNCTION {\n    return getValue();\n  }\n  T &operator*() LLVM_LVALUE_FUNCTION { return getValue(); }\n\n  template <typename U>\n  constexpr T getValueOr(U &&value) const LLVM_LVALUE_FUNCTION {\n    return hasValue() ? getValue() : std::forward<U>(value);\n  }\n\n  /// Apply a function to the value if present; otherwise return None.\n  template <class Function>\n  auto map(const Function &F) const LLVM_LVALUE_FUNCTION\n      -> Optional<decltype(F(getValue()))> {\n    if (*this) return F(getValue());\n    return None;\n  }\n\n#if LLVM_HAS_RVALUE_REFERENCE_THIS\n  T &&getValue() && { return std::move(Storage.getValue()); }\n  T &&operator*() && { return std::move(Storage.getValue()); }\n\n  template <typename U>\n  T getValueOr(U &&value) && {\n    return hasValue() ? std::move(getValue()) : std::forward<U>(value);\n  }\n\n  /// Apply a function to the value if present; otherwise return None.\n  template <class Function>\n  auto map(const Function &F) &&\n      -> Optional<decltype(F(std::move(*this).getValue()))> {\n    if (*this) return F(std::move(*this).getValue());\n    return None;\n  }\n#endif\n};\n\ntemplate <class T> llvm::hash_code hash_value(const Optional<T> &O) {\n  return O ? hash_combine(true, *O) : hash_value(false);\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator==(const Optional<T> &X, const Optional<U> &Y) {\n  if (X && Y)\n    return *X == *Y;\n  return X.hasValue() == Y.hasValue();\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator!=(const Optional<T> &X, const Optional<U> &Y) {\n  return !(X == Y);\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator<(const Optional<T> &X, const Optional<U> &Y) {\n  if (X && Y)\n    return *X < *Y;\n  return X.hasValue() < Y.hasValue();\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator<=(const Optional<T> &X, const Optional<U> &Y) {\n  return !(Y < X);\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator>(const Optional<T> &X, const Optional<U> &Y) {\n  return Y < X;\n}\n\ntemplate <typename T, typename U>\nconstexpr bool operator>=(const Optional<T> &X, const Optional<U> &Y) {\n  return !(X < Y);\n}\n\ntemplate <typename T>\nconstexpr bool operator==(const Optional<T> &X, NoneType) {\n  return !X;\n}\n\ntemplate <typename T>\nconstexpr bool operator==(NoneType, const Optional<T> &X) {\n  return X == None;\n}\n\ntemplate <typename T>\nconstexpr bool operator!=(const Optional<T> &X, NoneType) {\n  return !(X == None);\n}\n\ntemplate <typename T>\nconstexpr bool operator!=(NoneType, const Optional<T> &X) {\n  return X != None;\n}\n\ntemplate <typename T> constexpr bool operator<(const Optional<T> &, NoneType) {\n  return false;\n}\n\ntemplate <typename T> constexpr bool operator<(NoneType, const Optional<T> &X) {\n  return X.hasValue();\n}\n\ntemplate <typename T>\nconstexpr bool operator<=(const Optional<T> &X, NoneType) {\n  return !(None < X);\n}\n\ntemplate <typename T>\nconstexpr bool operator<=(NoneType, const Optional<T> &X) {\n  return !(X < None);\n}\n\ntemplate <typename T> constexpr bool operator>(const Optional<T> &X, NoneType) {\n  return None < X;\n}\n\ntemplate <typename T> constexpr bool operator>(NoneType, const Optional<T> &X) {\n  return X < None;\n}\n\ntemplate <typename T>\nconstexpr bool operator>=(const Optional<T> &X, NoneType) {\n  return None <= X;\n}\n\ntemplate <typename T>\nconstexpr bool operator>=(NoneType, const Optional<T> &X) {\n  return X <= None;\n}\n\ntemplate <typename T>\nconstexpr bool operator==(const Optional<T> &X, const T &Y) {\n  return X && *X == Y;\n}\n\ntemplate <typename T>\nconstexpr bool operator==(const T &X, const Optional<T> &Y) {\n  return Y && X == *Y;\n}\n\ntemplate <typename T>\nconstexpr bool operator!=(const Optional<T> &X, const T &Y) {\n  return !(X == Y);\n}\n\ntemplate <typename T>\nconstexpr bool operator!=(const T &X, const Optional<T> &Y) {\n  return !(X == Y);\n}\n\ntemplate <typename T>\nconstexpr bool operator<(const Optional<T> &X, const T &Y) {\n  return !X || *X < Y;\n}\n\ntemplate <typename T>\nconstexpr bool operator<(const T &X, const Optional<T> &Y) {\n  return Y && X < *Y;\n}\n\ntemplate <typename T>\nconstexpr bool operator<=(const Optional<T> &X, const T &Y) {\n  return !(Y < X);\n}\n\ntemplate <typename T>\nconstexpr bool operator<=(const T &X, const Optional<T> &Y) {\n  return !(Y < X);\n}\n\ntemplate <typename T>\nconstexpr bool operator>(const Optional<T> &X, const T &Y) {\n  return Y < X;\n}\n\ntemplate <typename T>\nconstexpr bool operator>(const T &X, const Optional<T> &Y) {\n  return Y < X;\n}\n\ntemplate <typename T>\nconstexpr bool operator>=(const Optional<T> &X, const T &Y) {\n  return !(X < Y);\n}\n\ntemplate <typename T>\nconstexpr bool operator>=(const T &X, const Optional<T> &Y) {\n  return !(X < Y);\n}\n\nraw_ostream &operator<<(raw_ostream &OS, NoneType);\n\ntemplate <typename T, typename = decltype(std::declval<raw_ostream &>()\n                                          << std::declval<const T &>())>\nraw_ostream &operator<<(raw_ostream &OS, const Optional<T> &O) {\n  if (O)\n    OS << *O;\n  else\n    OS << None;\n  return OS;\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_OPTIONAL_H\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "content": "//===- llvm/ADT/STLExtras.h - Useful STL related functions ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains some templates that are useful if you are working with the\n// STL at all.\n//\n// No library is required when using these functions.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_STLEXTRAS_H\n#define LLVM_ADT_STLEXTRAS_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Config/abi-breaking.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <functional>\n#include <initializer_list>\n#include <iterator>\n#include <limits>\n#include <memory>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n\n#ifdef EXPENSIVE_CHECKS\n#include <random> // for std::mt19937\n#endif\n\nnamespace llvm {\n\n// Only used by compiler if both template types are the same.  Useful when\n// using SFINAE to test for the existence of member functions.\ntemplate <typename T, T> struct SameType;\n\nnamespace detail {\n\ntemplate <typename RangeT>\nusing IterOfRange = decltype(std::begin(std::declval<RangeT &>()));\n\ntemplate <typename RangeT>\nusing ValueOfRange = typename std::remove_reference<decltype(\n    *std::begin(std::declval<RangeT &>()))>::type;\n\n} // end namespace detail\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <type_traits>\n//===----------------------------------------------------------------------===//\n\ntemplate <typename T>\nstruct negation : std::integral_constant<bool, !bool(T::value)> {};\n\ntemplate <typename...> struct conjunction : std::true_type {};\ntemplate <typename B1> struct conjunction<B1> : B1 {};\ntemplate <typename B1, typename... Bn>\nstruct conjunction<B1, Bn...>\n    : std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type {};\n\ntemplate <typename T> struct make_const_ptr {\n  using type =\n      typename std::add_pointer<typename std::add_const<T>::type>::type;\n};\n\ntemplate <typename T> struct make_const_ref {\n  using type = typename std::add_lvalue_reference<\n      typename std::add_const<T>::type>::type;\n};\n\n/// Utilities for detecting if a given trait holds for some set of arguments\n/// 'Args'. For example, the given trait could be used to detect if a given type\n/// has a copy assignment operator:\n///   template<class T>\n///   using has_copy_assign_t = decltype(std::declval<T&>()\n///                                                 = std::declval<const T&>());\n///   bool fooHasCopyAssign = is_detected<has_copy_assign_t, FooClass>::value;\nnamespace detail {\ntemplate <typename...> using void_t = void;\ntemplate <class, template <class...> class Op, class... Args> struct detector {\n  using value_t = std::false_type;\n};\ntemplate <template <class...> class Op, class... Args>\nstruct detector<void_t<Op<Args...>>, Op, Args...> {\n  using value_t = std::true_type;\n};\n} // end namespace detail\n\ntemplate <template <class...> class Op, class... Args>\nusing is_detected = typename detail::detector<void, Op, Args...>::value_t;\n\n/// Check if a Callable type can be invoked with the given set of arg types.\nnamespace detail {\ntemplate <typename Callable, typename... Args>\nusing is_invocable =\n    decltype(std::declval<Callable &>()(std::declval<Args>()...));\n} // namespace detail\n\ntemplate <typename Callable, typename... Args>\nusing is_invocable = is_detected<detail::is_invocable, Callable, Args...>;\n\n/// This class provides various trait information about a callable object.\n///   * To access the number of arguments: Traits::num_args\n///   * To access the type of an argument: Traits::arg_t<Index>\n///   * To access the type of the result:  Traits::result_t\ntemplate <typename T, bool isClass = std::is_class<T>::value>\nstruct function_traits : public function_traits<decltype(&T::operator())> {};\n\n/// Overload for class function types.\ntemplate <typename ClassType, typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (ClassType::*)(Args...) const, false> {\n  /// The number of arguments to this function.\n  enum { num_args = sizeof...(Args) };\n\n  /// The result type of this function.\n  using result_t = ReturnType;\n\n  /// The type of an argument to this function.\n  template <size_t Index>\n  using arg_t = typename std::tuple_element<Index, std::tuple<Args...>>::type;\n};\n/// Overload for class function types.\ntemplate <typename ClassType, typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (ClassType::*)(Args...), false>\n    : function_traits<ReturnType (ClassType::*)(Args...) const> {};\n/// Overload for non-class function types.\ntemplate <typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (*)(Args...), false> {\n  /// The number of arguments to this function.\n  enum { num_args = sizeof...(Args) };\n\n  /// The result type of this function.\n  using result_t = ReturnType;\n\n  /// The type of an argument to this function.\n  template <size_t i>\n  using arg_t = typename std::tuple_element<i, std::tuple<Args...>>::type;\n};\n/// Overload for non-class function type references.\ntemplate <typename ReturnType, typename... Args>\nstruct function_traits<ReturnType (&)(Args...), false>\n    : public function_traits<ReturnType (*)(Args...)> {};\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <functional>\n//===----------------------------------------------------------------------===//\n\ntemplate <class Ty> struct identity {\n  using argument_type = Ty;\n\n  Ty &operator()(Ty &self) const {\n    return self;\n  }\n  const Ty &operator()(const Ty &self) const {\n    return self;\n  }\n};\n\n/// An efficient, type-erasing, non-owning reference to a callable. This is\n/// intended for use as the type of a function parameter that is not used\n/// after the function in question returns.\n///\n/// This class does not own the callable, so it is not in general safe to store\n/// a function_ref.\ntemplate<typename Fn> class function_ref;\n\ntemplate<typename Ret, typename ...Params>\nclass function_ref<Ret(Params...)> {\n  Ret (*callback)(intptr_t callable, Params ...params) = nullptr;\n  intptr_t callable;\n\n  template<typename Callable>\n  static Ret callback_fn(intptr_t callable, Params ...params) {\n    return (*reinterpret_cast<Callable*>(callable))(\n        std::forward<Params>(params)...);\n  }\n\npublic:\n  function_ref() = default;\n  function_ref(std::nullptr_t) {}\n\n  template <typename Callable>\n  function_ref(\n      Callable &&callable,\n      // This is not the copy-constructor.\n      std::enable_if_t<\n          !std::is_same<std::remove_cv_t<std::remove_reference_t<Callable>>,\n                        function_ref>::value> * = nullptr,\n      // Functor must be callable and return a suitable type.\n      std::enable_if_t<std::is_void<Ret>::value ||\n                       std::is_convertible<decltype(std::declval<Callable>()(\n                                               std::declval<Params>()...)),\n                                           Ret>::value> * = nullptr)\n      : callback(callback_fn<typename std::remove_reference<Callable>::type>),\n        callable(reinterpret_cast<intptr_t>(&callable)) {}\n\n  Ret operator()(Params ...params) const {\n    return callback(callable, std::forward<Params>(params)...);\n  }\n\n  explicit operator bool() const { return callback; }\n};\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <iterator>\n//===----------------------------------------------------------------------===//\n\nnamespace adl_detail {\n\nusing std::begin;\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_begin(ContainerTy &&container) {\n  return begin(std::forward<ContainerTy>(container));\n}\n\nusing std::end;\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_end(ContainerTy &&container) {\n  return end(std::forward<ContainerTy>(container));\n}\n\nusing std::swap;\n\ntemplate <typename T>\nvoid adl_swap(T &&lhs, T &&rhs) noexcept(noexcept(swap(std::declval<T>(),\n                                                       std::declval<T>()))) {\n  swap(std::forward<T>(lhs), std::forward<T>(rhs));\n}\n\n} // end namespace adl_detail\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_begin(ContainerTy &&container) {\n  return adl_detail::adl_begin(std::forward<ContainerTy>(container));\n}\n\ntemplate <typename ContainerTy>\ndecltype(auto) adl_end(ContainerTy &&container) {\n  return adl_detail::adl_end(std::forward<ContainerTy>(container));\n}\n\ntemplate <typename T>\nvoid adl_swap(T &&lhs, T &&rhs) noexcept(\n    noexcept(adl_detail::adl_swap(std::declval<T>(), std::declval<T>()))) {\n  adl_detail::adl_swap(std::forward<T>(lhs), std::forward<T>(rhs));\n}\n\n/// Test whether \\p RangeOrContainer is empty. Similar to C++17 std::empty.\ntemplate <typename T>\nconstexpr bool empty(const T &RangeOrContainer) {\n  return adl_begin(RangeOrContainer) == adl_end(RangeOrContainer);\n}\n\n/// Returns true if the given container only contains a single element.\ntemplate <typename ContainerTy> bool hasSingleElement(ContainerTy &&C) {\n  auto B = std::begin(C), E = std::end(C);\n  return B != E && std::next(B) == E;\n}\n\n/// Return a range covering \\p RangeOrContainer with the first N elements\n/// excluded.\ntemplate <typename T> auto drop_begin(T &&RangeOrContainer, size_t N = 1) {\n  return make_range(std::next(adl_begin(RangeOrContainer), N),\n                    adl_end(RangeOrContainer));\n}\n\n// mapped_iterator - This is a simple iterator adapter that causes a function to\n// be applied whenever operator* is invoked on the iterator.\n\ntemplate <typename ItTy, typename FuncTy,\n          typename FuncReturnTy =\n            decltype(std::declval<FuncTy>()(*std::declval<ItTy>()))>\nclass mapped_iterator\n    : public iterator_adaptor_base<\n             mapped_iterator<ItTy, FuncTy>, ItTy,\n             typename std::iterator_traits<ItTy>::iterator_category,\n             typename std::remove_reference<FuncReturnTy>::type> {\npublic:\n  mapped_iterator(ItTy U, FuncTy F)\n    : mapped_iterator::iterator_adaptor_base(std::move(U)), F(std::move(F)) {}\n\n  ItTy getCurrent() { return this->I; }\n\n  FuncReturnTy operator*() const { return F(*this->I); }\n\nprivate:\n  FuncTy F;\n};\n\n// map_iterator - Provide a convenient way to create mapped_iterators, just like\n// make_pair is useful for creating pairs...\ntemplate <class ItTy, class FuncTy>\ninline mapped_iterator<ItTy, FuncTy> map_iterator(ItTy I, FuncTy F) {\n  return mapped_iterator<ItTy, FuncTy>(std::move(I), std::move(F));\n}\n\ntemplate <class ContainerTy, class FuncTy>\nauto map_range(ContainerTy &&C, FuncTy F) {\n  return make_range(map_iterator(C.begin(), F), map_iterator(C.end(), F));\n}\n\n/// Helper to determine if type T has a member called rbegin().\ntemplate <typename Ty> class has_rbegin_impl {\n  using yes = char[1];\n  using no = char[2];\n\n  template <typename Inner>\n  static yes& test(Inner *I, decltype(I->rbegin()) * = nullptr);\n\n  template <typename>\n  static no& test(...);\n\npublic:\n  static const bool value = sizeof(test<Ty>(nullptr)) == sizeof(yes);\n};\n\n/// Metafunction to determine if T& or T has a member called rbegin().\ntemplate <typename Ty>\nstruct has_rbegin : has_rbegin_impl<typename std::remove_reference<Ty>::type> {\n};\n\n// Returns an iterator_range over the given container which iterates in reverse.\n// Note that the container must have rbegin()/rend() methods for this to work.\ntemplate <typename ContainerTy>\nauto reverse(ContainerTy &&C,\n             std::enable_if_t<has_rbegin<ContainerTy>::value> * = nullptr) {\n  return make_range(C.rbegin(), C.rend());\n}\n\n// Returns a std::reverse_iterator wrapped around the given iterator.\ntemplate <typename IteratorTy>\nstd::reverse_iterator<IteratorTy> make_reverse_iterator(IteratorTy It) {\n  return std::reverse_iterator<IteratorTy>(It);\n}\n\n// Returns an iterator_range over the given container which iterates in reverse.\n// Note that the container must have begin()/end() methods which return\n// bidirectional iterators for this to work.\ntemplate <typename ContainerTy>\nauto reverse(ContainerTy &&C,\n             std::enable_if_t<!has_rbegin<ContainerTy>::value> * = nullptr) {\n  return make_range(llvm::make_reverse_iterator(std::end(C)),\n                    llvm::make_reverse_iterator(std::begin(C)));\n}\n\n/// An iterator adaptor that filters the elements of given inner iterators.\n///\n/// The predicate parameter should be a callable object that accepts the wrapped\n/// iterator's reference type and returns a bool. When incrementing or\n/// decrementing the iterator, it will call the predicate on each element and\n/// skip any where it returns false.\n///\n/// \\code\n///   int A[] = { 1, 2, 3, 4 };\n///   auto R = make_filter_range(A, [](int N) { return N % 2 == 1; });\n///   // R contains { 1, 3 }.\n/// \\endcode\n///\n/// Note: filter_iterator_base implements support for forward iteration.\n/// filter_iterator_impl exists to provide support for bidirectional iteration,\n/// conditional on whether the wrapped iterator supports it.\ntemplate <typename WrappedIteratorT, typename PredicateT, typename IterTag>\nclass filter_iterator_base\n    : public iterator_adaptor_base<\n          filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,\n          WrappedIteratorT,\n          typename std::common_type<\n              IterTag, typename std::iterator_traits<\n                           WrappedIteratorT>::iterator_category>::type> {\n  using BaseT = iterator_adaptor_base<\n      filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,\n      WrappedIteratorT,\n      typename std::common_type<\n          IterTag, typename std::iterator_traits<\n                       WrappedIteratorT>::iterator_category>::type>;\n\nprotected:\n  WrappedIteratorT End;\n  PredicateT Pred;\n\n  void findNextValid() {\n    while (this->I != End && !Pred(*this->I))\n      BaseT::operator++();\n  }\n\n  // Construct the iterator. The begin iterator needs to know where the end\n  // is, so that it can properly stop when it gets there. The end iterator only\n  // needs the predicate to support bidirectional iteration.\n  filter_iterator_base(WrappedIteratorT Begin, WrappedIteratorT End,\n                       PredicateT Pred)\n      : BaseT(Begin), End(End), Pred(Pred) {\n    findNextValid();\n  }\n\npublic:\n  using BaseT::operator++;\n\n  filter_iterator_base &operator++() {\n    BaseT::operator++();\n    findNextValid();\n    return *this;\n  }\n};\n\n/// Specialization of filter_iterator_base for forward iteration only.\ntemplate <typename WrappedIteratorT, typename PredicateT,\n          typename IterTag = std::forward_iterator_tag>\nclass filter_iterator_impl\n    : public filter_iterator_base<WrappedIteratorT, PredicateT, IterTag> {\n  using BaseT = filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>;\n\npublic:\n  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,\n                       PredicateT Pred)\n      : BaseT(Begin, End, Pred) {}\n};\n\n/// Specialization of filter_iterator_base for bidirectional iteration.\ntemplate <typename WrappedIteratorT, typename PredicateT>\nclass filter_iterator_impl<WrappedIteratorT, PredicateT,\n                           std::bidirectional_iterator_tag>\n    : public filter_iterator_base<WrappedIteratorT, PredicateT,\n                                  std::bidirectional_iterator_tag> {\n  using BaseT = filter_iterator_base<WrappedIteratorT, PredicateT,\n                                     std::bidirectional_iterator_tag>;\n  void findPrevValid() {\n    while (!this->Pred(*this->I))\n      BaseT::operator--();\n  }\n\npublic:\n  using BaseT::operator--;\n\n  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,\n                       PredicateT Pred)\n      : BaseT(Begin, End, Pred) {}\n\n  filter_iterator_impl &operator--() {\n    BaseT::operator--();\n    findPrevValid();\n    return *this;\n  }\n};\n\nnamespace detail {\n\ntemplate <bool is_bidirectional> struct fwd_or_bidi_tag_impl {\n  using type = std::forward_iterator_tag;\n};\n\ntemplate <> struct fwd_or_bidi_tag_impl<true> {\n  using type = std::bidirectional_iterator_tag;\n};\n\n/// Helper which sets its type member to forward_iterator_tag if the category\n/// of \\p IterT does not derive from bidirectional_iterator_tag, and to\n/// bidirectional_iterator_tag otherwise.\ntemplate <typename IterT> struct fwd_or_bidi_tag {\n  using type = typename fwd_or_bidi_tag_impl<std::is_base_of<\n      std::bidirectional_iterator_tag,\n      typename std::iterator_traits<IterT>::iterator_category>::value>::type;\n};\n\n} // namespace detail\n\n/// Defines filter_iterator to a suitable specialization of\n/// filter_iterator_impl, based on the underlying iterator's category.\ntemplate <typename WrappedIteratorT, typename PredicateT>\nusing filter_iterator = filter_iterator_impl<\n    WrappedIteratorT, PredicateT,\n    typename detail::fwd_or_bidi_tag<WrappedIteratorT>::type>;\n\n/// Convenience function that takes a range of elements and a predicate,\n/// and return a new filter_iterator range.\n///\n/// FIXME: Currently if RangeT && is a rvalue reference to a temporary, the\n/// lifetime of that temporary is not kept by the returned range object, and the\n/// temporary is going to be dropped on the floor after the make_iterator_range\n/// full expression that contains this function call.\ntemplate <typename RangeT, typename PredicateT>\niterator_range<filter_iterator<detail::IterOfRange<RangeT>, PredicateT>>\nmake_filter_range(RangeT &&Range, PredicateT Pred) {\n  using FilterIteratorT =\n      filter_iterator<detail::IterOfRange<RangeT>, PredicateT>;\n  return make_range(\n      FilterIteratorT(std::begin(std::forward<RangeT>(Range)),\n                      std::end(std::forward<RangeT>(Range)), Pred),\n      FilterIteratorT(std::end(std::forward<RangeT>(Range)),\n                      std::end(std::forward<RangeT>(Range)), Pred));\n}\n\n/// A pseudo-iterator adaptor that is designed to implement \"early increment\"\n/// style loops.\n///\n/// This is *not a normal iterator* and should almost never be used directly. It\n/// is intended primarily to be used with range based for loops and some range\n/// algorithms.\n///\n/// The iterator isn't quite an `OutputIterator` or an `InputIterator` but\n/// somewhere between them. The constraints of these iterators are:\n///\n/// - On construction or after being incremented, it is comparable and\n///   dereferencable. It is *not* incrementable.\n/// - After being dereferenced, it is neither comparable nor dereferencable, it\n///   is only incrementable.\n///\n/// This means you can only dereference the iterator once, and you can only\n/// increment it once between dereferences.\ntemplate <typename WrappedIteratorT>\nclass early_inc_iterator_impl\n    : public iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,\n                                   WrappedIteratorT, std::input_iterator_tag> {\n  using BaseT =\n      iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,\n                            WrappedIteratorT, std::input_iterator_tag>;\n\n  using PointerT = typename std::iterator_traits<WrappedIteratorT>::pointer;\n\nprotected:\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n  bool IsEarlyIncremented = false;\n#endif\n\npublic:\n  early_inc_iterator_impl(WrappedIteratorT I) : BaseT(I) {}\n\n  using BaseT::operator*;\n  decltype(*std::declval<WrappedIteratorT>()) operator*() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(!IsEarlyIncremented && \"Cannot dereference twice!\");\n    IsEarlyIncremented = true;\n#endif\n    return *(this->I)++;\n  }\n\n  using BaseT::operator++;\n  early_inc_iterator_impl &operator++() {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(IsEarlyIncremented && \"Cannot increment before dereferencing!\");\n    IsEarlyIncremented = false;\n#endif\n    return *this;\n  }\n\n  friend bool operator==(const early_inc_iterator_impl &LHS,\n                         const early_inc_iterator_impl &RHS) {\n#if LLVM_ENABLE_ABI_BREAKING_CHECKS\n    assert(!LHS.IsEarlyIncremented && \"Cannot compare after dereferencing!\");\n#endif\n    return (const BaseT &)LHS == (const BaseT &)RHS;\n  }\n};\n\n/// Make a range that does early increment to allow mutation of the underlying\n/// range without disrupting iteration.\n///\n/// The underlying iterator will be incremented immediately after it is\n/// dereferenced, allowing deletion of the current node or insertion of nodes to\n/// not disrupt iteration provided they do not invalidate the *next* iterator --\n/// the current iterator can be invalidated.\n///\n/// This requires a very exact pattern of use that is only really suitable to\n/// range based for loops and other range algorithms that explicitly guarantee\n/// to dereference exactly once each element, and to increment exactly once each\n/// element.\ntemplate <typename RangeT>\niterator_range<early_inc_iterator_impl<detail::IterOfRange<RangeT>>>\nmake_early_inc_range(RangeT &&Range) {\n  using EarlyIncIteratorT =\n      early_inc_iterator_impl<detail::IterOfRange<RangeT>>;\n  return make_range(EarlyIncIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    EarlyIncIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\n// forward declarations required by zip_shortest/zip_first/zip_longest\ntemplate <typename R, typename UnaryPredicate>\nbool all_of(R &&range, UnaryPredicate P);\ntemplate <typename R, typename UnaryPredicate>\nbool any_of(R &&range, UnaryPredicate P);\n\nnamespace detail {\n\nusing std::declval;\n\n// We have to alias this since inlining the actual type at the usage site\n// in the parameter list of iterator_facade_base<> below ICEs MSVC 2017.\ntemplate<typename... Iters> struct ZipTupleType {\n  using type = std::tuple<decltype(*declval<Iters>())...>;\n};\n\ntemplate <typename ZipType, typename... Iters>\nusing zip_traits = iterator_facade_base<\n    ZipType, typename std::common_type<std::bidirectional_iterator_tag,\n                                       typename std::iterator_traits<\n                                           Iters>::iterator_category...>::type,\n    // ^ TODO: Implement random access methods.\n    typename ZipTupleType<Iters...>::type,\n    typename std::iterator_traits<typename std::tuple_element<\n        0, std::tuple<Iters...>>::type>::difference_type,\n    // ^ FIXME: This follows boost::make_zip_iterator's assumption that all\n    // inner iterators have the same difference_type. It would fail if, for\n    // instance, the second field's difference_type were non-numeric while the\n    // first is.\n    typename ZipTupleType<Iters...>::type *,\n    typename ZipTupleType<Iters...>::type>;\n\ntemplate <typename ZipType, typename... Iters>\nstruct zip_common : public zip_traits<ZipType, Iters...> {\n  using Base = zip_traits<ZipType, Iters...>;\n  using value_type = typename Base::value_type;\n\n  std::tuple<Iters...> iterators;\n\nprotected:\n  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {\n    return value_type(*std::get<Ns>(iterators)...);\n  }\n\n  template <size_t... Ns>\n  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {\n    return std::tuple<Iters...>(std::next(std::get<Ns>(iterators))...);\n  }\n\n  template <size_t... Ns>\n  decltype(iterators) tup_dec(std::index_sequence<Ns...>) const {\n    return std::tuple<Iters...>(std::prev(std::get<Ns>(iterators))...);\n  }\n\npublic:\n  zip_common(Iters &&... ts) : iterators(std::forward<Iters>(ts)...) {}\n\n  value_type operator*() { return deref(std::index_sequence_for<Iters...>{}); }\n\n  const value_type operator*() const {\n    return deref(std::index_sequence_for<Iters...>{});\n  }\n\n  ZipType &operator++() {\n    iterators = tup_inc(std::index_sequence_for<Iters...>{});\n    return *reinterpret_cast<ZipType *>(this);\n  }\n\n  ZipType &operator--() {\n    static_assert(Base::IsBidirectional,\n                  \"All inner iterators must be at least bidirectional.\");\n    iterators = tup_dec(std::index_sequence_for<Iters...>{});\n    return *reinterpret_cast<ZipType *>(this);\n  }\n};\n\ntemplate <typename... Iters>\nstruct zip_first : public zip_common<zip_first<Iters...>, Iters...> {\n  using Base = zip_common<zip_first<Iters...>, Iters...>;\n\n  bool operator==(const zip_first<Iters...> &other) const {\n    return std::get<0>(this->iterators) == std::get<0>(other.iterators);\n  }\n\n  zip_first(Iters &&... ts) : Base(std::forward<Iters>(ts)...) {}\n};\n\ntemplate <typename... Iters>\nclass zip_shortest : public zip_common<zip_shortest<Iters...>, Iters...> {\n  template <size_t... Ns>\n  bool test(const zip_shortest<Iters...> &other,\n            std::index_sequence<Ns...>) const {\n    return all_of(std::initializer_list<bool>{std::get<Ns>(this->iterators) !=\n                                              std::get<Ns>(other.iterators)...},\n                  identity<bool>{});\n  }\n\npublic:\n  using Base = zip_common<zip_shortest<Iters...>, Iters...>;\n\n  zip_shortest(Iters &&... ts) : Base(std::forward<Iters>(ts)...) {}\n\n  bool operator==(const zip_shortest<Iters...> &other) const {\n    return !test(other, std::index_sequence_for<Iters...>{});\n  }\n};\n\ntemplate <template <typename...> class ItType, typename... Args> class zippy {\npublic:\n  using iterator = ItType<decltype(std::begin(std::declval<Args>()))...>;\n  using iterator_category = typename iterator::iterator_category;\n  using value_type = typename iterator::value_type;\n  using difference_type = typename iterator::difference_type;\n  using pointer = typename iterator::pointer;\n  using reference = typename iterator::reference;\n\nprivate:\n  std::tuple<Args...> ts;\n\n  template <size_t... Ns>\n  iterator begin_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::begin(std::get<Ns>(ts))...);\n  }\n  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::end(std::get<Ns>(ts))...);\n  }\n\npublic:\n  zippy(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}\n\n  iterator begin() const {\n    return begin_impl(std::index_sequence_for<Args...>{});\n  }\n  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }\n};\n\n} // end namespace detail\n\n/// zip iterator for two or more iteratable types.\ntemplate <typename T, typename U, typename... Args>\ndetail::zippy<detail::zip_shortest, T, U, Args...> zip(T &&t, U &&u,\n                                                       Args &&... args) {\n  return detail::zippy<detail::zip_shortest, T, U, Args...>(\n      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);\n}\n\n/// zip iterator that, for the sake of efficiency, assumes the first iteratee to\n/// be the shortest.\ntemplate <typename T, typename U, typename... Args>\ndetail::zippy<detail::zip_first, T, U, Args...> zip_first(T &&t, U &&u,\n                                                          Args &&... args) {\n  return detail::zippy<detail::zip_first, T, U, Args...>(\n      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);\n}\n\nnamespace detail {\ntemplate <typename Iter>\nIter next_or_end(const Iter &I, const Iter &End) {\n  if (I == End)\n    return End;\n  return std::next(I);\n}\n\ntemplate <typename Iter>\nauto deref_or_none(const Iter &I, const Iter &End) -> llvm::Optional<\n    std::remove_const_t<std::remove_reference_t<decltype(*I)>>> {\n  if (I == End)\n    return None;\n  return *I;\n}\n\ntemplate <typename Iter> struct ZipLongestItemType {\n  using type =\n      llvm::Optional<typename std::remove_const<typename std::remove_reference<\n          decltype(*std::declval<Iter>())>::type>::type>;\n};\n\ntemplate <typename... Iters> struct ZipLongestTupleType {\n  using type = std::tuple<typename ZipLongestItemType<Iters>::type...>;\n};\n\ntemplate <typename... Iters>\nclass zip_longest_iterator\n    : public iterator_facade_base<\n          zip_longest_iterator<Iters...>,\n          typename std::common_type<\n              std::forward_iterator_tag,\n              typename std::iterator_traits<Iters>::iterator_category...>::type,\n          typename ZipLongestTupleType<Iters...>::type,\n          typename std::iterator_traits<typename std::tuple_element<\n              0, std::tuple<Iters...>>::type>::difference_type,\n          typename ZipLongestTupleType<Iters...>::type *,\n          typename ZipLongestTupleType<Iters...>::type> {\npublic:\n  using value_type = typename ZipLongestTupleType<Iters...>::type;\n\nprivate:\n  std::tuple<Iters...> iterators;\n  std::tuple<Iters...> end_iterators;\n\n  template <size_t... Ns>\n  bool test(const zip_longest_iterator<Iters...> &other,\n            std::index_sequence<Ns...>) const {\n    return llvm::any_of(\n        std::initializer_list<bool>{std::get<Ns>(this->iterators) !=\n                                    std::get<Ns>(other.iterators)...},\n        identity<bool>{});\n  }\n\n  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {\n    return value_type(\n        deref_or_none(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);\n  }\n\n  template <size_t... Ns>\n  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {\n    return std::tuple<Iters...>(\n        next_or_end(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);\n  }\n\npublic:\n  zip_longest_iterator(std::pair<Iters &&, Iters &&>... ts)\n      : iterators(std::forward<Iters>(ts.first)...),\n        end_iterators(std::forward<Iters>(ts.second)...) {}\n\n  value_type operator*() { return deref(std::index_sequence_for<Iters...>{}); }\n\n  value_type operator*() const {\n    return deref(std::index_sequence_for<Iters...>{});\n  }\n\n  zip_longest_iterator<Iters...> &operator++() {\n    iterators = tup_inc(std::index_sequence_for<Iters...>{});\n    return *this;\n  }\n\n  bool operator==(const zip_longest_iterator<Iters...> &other) const {\n    return !test(other, std::index_sequence_for<Iters...>{});\n  }\n};\n\ntemplate <typename... Args> class zip_longest_range {\npublic:\n  using iterator =\n      zip_longest_iterator<decltype(adl_begin(std::declval<Args>()))...>;\n  using iterator_category = typename iterator::iterator_category;\n  using value_type = typename iterator::value_type;\n  using difference_type = typename iterator::difference_type;\n  using pointer = typename iterator::pointer;\n  using reference = typename iterator::reference;\n\nprivate:\n  std::tuple<Args...> ts;\n\n  template <size_t... Ns>\n  iterator begin_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::make_pair(adl_begin(std::get<Ns>(ts)),\n                                   adl_end(std::get<Ns>(ts)))...);\n  }\n\n  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {\n    return iterator(std::make_pair(adl_end(std::get<Ns>(ts)),\n                                   adl_end(std::get<Ns>(ts)))...);\n  }\n\npublic:\n  zip_longest_range(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}\n\n  iterator begin() const {\n    return begin_impl(std::index_sequence_for<Args...>{});\n  }\n  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }\n};\n} // namespace detail\n\n/// Iterate over two or more iterators at the same time. Iteration continues\n/// until all iterators reach the end. The llvm::Optional only contains a value\n/// if the iterator has not reached the end.\ntemplate <typename T, typename U, typename... Args>\ndetail::zip_longest_range<T, U, Args...> zip_longest(T &&t, U &&u,\n                                                     Args &&... args) {\n  return detail::zip_longest_range<T, U, Args...>(\n      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);\n}\n\n/// Iterator wrapper that concatenates sequences together.\n///\n/// This can concatenate different iterators, even with different types, into\n/// a single iterator provided the value types of all the concatenated\n/// iterators expose `reference` and `pointer` types that can be converted to\n/// `ValueT &` and `ValueT *` respectively. It doesn't support more\n/// interesting/customized pointer or reference types.\n///\n/// Currently this only supports forward or higher iterator categories as\n/// inputs and always exposes a forward iterator interface.\ntemplate <typename ValueT, typename... IterTs>\nclass concat_iterator\n    : public iterator_facade_base<concat_iterator<ValueT, IterTs...>,\n                                  std::forward_iterator_tag, ValueT> {\n  using BaseT = typename concat_iterator::iterator_facade_base;\n\n  /// We store both the current and end iterators for each concatenated\n  /// sequence in a tuple of pairs.\n  ///\n  /// Note that something like iterator_range seems nice at first here, but the\n  /// range properties are of little benefit and end up getting in the way\n  /// because we need to do mutation on the current iterators.\n  std::tuple<IterTs...> Begins;\n  std::tuple<IterTs...> Ends;\n\n  /// Attempts to increment a specific iterator.\n  ///\n  /// Returns true if it was able to increment the iterator. Returns false if\n  /// the iterator is already at the end iterator.\n  template <size_t Index> bool incrementHelper() {\n    auto &Begin = std::get<Index>(Begins);\n    auto &End = std::get<Index>(Ends);\n    if (Begin == End)\n      return false;\n\n    ++Begin;\n    return true;\n  }\n\n  /// Increments the first non-end iterator.\n  ///\n  /// It is an error to call this with all iterators at the end.\n  template <size_t... Ns> void increment(std::index_sequence<Ns...>) {\n    // Build a sequence of functions to increment each iterator if possible.\n    bool (concat_iterator::*IncrementHelperFns[])() = {\n        &concat_iterator::incrementHelper<Ns>...};\n\n    // Loop over them, and stop as soon as we succeed at incrementing one.\n    for (auto &IncrementHelperFn : IncrementHelperFns)\n      if ((this->*IncrementHelperFn)())\n        return;\n\n    llvm_unreachable(\"Attempted to increment an end concat iterator!\");\n  }\n\n  /// Returns null if the specified iterator is at the end. Otherwise,\n  /// dereferences the iterator and returns the address of the resulting\n  /// reference.\n  template <size_t Index> ValueT *getHelper() const {\n    auto &Begin = std::get<Index>(Begins);\n    auto &End = std::get<Index>(Ends);\n    if (Begin == End)\n      return nullptr;\n\n    return &*Begin;\n  }\n\n  /// Finds the first non-end iterator, dereferences, and returns the resulting\n  /// reference.\n  ///\n  /// It is an error to call this with all iterators at the end.\n  template <size_t... Ns> ValueT &get(std::index_sequence<Ns...>) const {\n    // Build a sequence of functions to get from iterator if possible.\n    ValueT *(concat_iterator::*GetHelperFns[])() const = {\n        &concat_iterator::getHelper<Ns>...};\n\n    // Loop over them, and return the first result we find.\n    for (auto &GetHelperFn : GetHelperFns)\n      if (ValueT *P = (this->*GetHelperFn)())\n        return *P;\n\n    llvm_unreachable(\"Attempted to get a pointer from an end concat iterator!\");\n  }\n\npublic:\n  /// Constructs an iterator from a sequence of ranges.\n  ///\n  /// We need the full range to know how to switch between each of the\n  /// iterators.\n  template <typename... RangeTs>\n  explicit concat_iterator(RangeTs &&... Ranges)\n      : Begins(std::begin(Ranges)...), Ends(std::end(Ranges)...) {}\n\n  using BaseT::operator++;\n\n  concat_iterator &operator++() {\n    increment(std::index_sequence_for<IterTs...>());\n    return *this;\n  }\n\n  ValueT &operator*() const {\n    return get(std::index_sequence_for<IterTs...>());\n  }\n\n  bool operator==(const concat_iterator &RHS) const {\n    return Begins == RHS.Begins && Ends == RHS.Ends;\n  }\n};\n\nnamespace detail {\n\n/// Helper to store a sequence of ranges being concatenated and access them.\n///\n/// This is designed to facilitate providing actual storage when temporaries\n/// are passed into the constructor such that we can use it as part of range\n/// based for loops.\ntemplate <typename ValueT, typename... RangeTs> class concat_range {\npublic:\n  using iterator =\n      concat_iterator<ValueT,\n                      decltype(std::begin(std::declval<RangeTs &>()))...>;\n\nprivate:\n  std::tuple<RangeTs...> Ranges;\n\n  template <size_t... Ns> iterator begin_impl(std::index_sequence<Ns...>) {\n    return iterator(std::get<Ns>(Ranges)...);\n  }\n  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {\n    return iterator(make_range(std::end(std::get<Ns>(Ranges)),\n                               std::end(std::get<Ns>(Ranges)))...);\n  }\n\npublic:\n  concat_range(RangeTs &&... Ranges)\n      : Ranges(std::forward<RangeTs>(Ranges)...) {}\n\n  iterator begin() { return begin_impl(std::index_sequence_for<RangeTs...>{}); }\n  iterator end() { return end_impl(std::index_sequence_for<RangeTs...>{}); }\n};\n\n} // end namespace detail\n\n/// Concatenated range across two or more ranges.\n///\n/// The desired value type must be explicitly specified.\ntemplate <typename ValueT, typename... RangeTs>\ndetail::concat_range<ValueT, RangeTs...> concat(RangeTs &&... Ranges) {\n  static_assert(sizeof...(RangeTs) > 1,\n                \"Need more than one range to concatenate!\");\n  return detail::concat_range<ValueT, RangeTs...>(\n      std::forward<RangeTs>(Ranges)...);\n}\n\n/// A utility class used to implement an iterator that contains some base object\n/// and an index. The iterator moves the index but keeps the base constant.\ntemplate <typename DerivedT, typename BaseT, typename T,\n          typename PointerT = T *, typename ReferenceT = T &>\nclass indexed_accessor_iterator\n    : public llvm::iterator_facade_base<DerivedT,\n                                        std::random_access_iterator_tag, T,\n                                        std::ptrdiff_t, PointerT, ReferenceT> {\npublic:\n  ptrdiff_t operator-(const indexed_accessor_iterator &rhs) const {\n    assert(base == rhs.base && \"incompatible iterators\");\n    return index - rhs.index;\n  }\n  bool operator==(const indexed_accessor_iterator &rhs) const {\n    return base == rhs.base && index == rhs.index;\n  }\n  bool operator<(const indexed_accessor_iterator &rhs) const {\n    assert(base == rhs.base && \"incompatible iterators\");\n    return index < rhs.index;\n  }\n\n  DerivedT &operator+=(ptrdiff_t offset) {\n    this->index += offset;\n    return static_cast<DerivedT &>(*this);\n  }\n  DerivedT &operator-=(ptrdiff_t offset) {\n    this->index -= offset;\n    return static_cast<DerivedT &>(*this);\n  }\n\n  /// Returns the current index of the iterator.\n  ptrdiff_t getIndex() const { return index; }\n\n  /// Returns the current base of the iterator.\n  const BaseT &getBase() const { return base; }\n\nprotected:\n  indexed_accessor_iterator(BaseT base, ptrdiff_t index)\n      : base(base), index(index) {}\n  BaseT base;\n  ptrdiff_t index;\n};\n\nnamespace detail {\n/// The class represents the base of a range of indexed_accessor_iterators. It\n/// provides support for many different range functionalities, e.g.\n/// drop_front/slice/etc.. Derived range classes must implement the following\n/// static methods:\n///   * ReferenceT dereference_iterator(const BaseT &base, ptrdiff_t index)\n///     - Dereference an iterator pointing to the base object at the given\n///       index.\n///   * BaseT offset_base(const BaseT &base, ptrdiff_t index)\n///     - Return a new base that is offset from the provide base by 'index'\n///       elements.\ntemplate <typename DerivedT, typename BaseT, typename T,\n          typename PointerT = T *, typename ReferenceT = T &>\nclass indexed_accessor_range_base {\npublic:\n  using RangeBaseT =\n      indexed_accessor_range_base<DerivedT, BaseT, T, PointerT, ReferenceT>;\n\n  /// An iterator element of this range.\n  class iterator : public indexed_accessor_iterator<iterator, BaseT, T,\n                                                    PointerT, ReferenceT> {\n  public:\n    // Index into this iterator, invoking a static method on the derived type.\n    ReferenceT operator*() const {\n      return DerivedT::dereference_iterator(this->getBase(), this->getIndex());\n    }\n\n  private:\n    iterator(BaseT owner, ptrdiff_t curIndex)\n        : indexed_accessor_iterator<iterator, BaseT, T, PointerT, ReferenceT>(\n              owner, curIndex) {}\n\n    /// Allow access to the constructor.\n    friend indexed_accessor_range_base<DerivedT, BaseT, T, PointerT,\n                                       ReferenceT>;\n  };\n\n  indexed_accessor_range_base(iterator begin, iterator end)\n      : base(offset_base(begin.getBase(), begin.getIndex())),\n        count(end.getIndex() - begin.getIndex()) {}\n  indexed_accessor_range_base(const iterator_range<iterator> &range)\n      : indexed_accessor_range_base(range.begin(), range.end()) {}\n  indexed_accessor_range_base(BaseT base, ptrdiff_t count)\n      : base(base), count(count) {}\n\n  iterator begin() const { return iterator(base, 0); }\n  iterator end() const { return iterator(base, count); }\n  ReferenceT operator[](size_t Index) const {\n    assert(Index < size() && \"invalid index for value range\");\n    return DerivedT::dereference_iterator(base, static_cast<ptrdiff_t>(Index));\n  }\n  ReferenceT front() const {\n    assert(!empty() && \"expected non-empty range\");\n    return (*this)[0];\n  }\n  ReferenceT back() const {\n    assert(!empty() && \"expected non-empty range\");\n    return (*this)[size() - 1];\n  }\n\n  /// Compare this range with another.\n  template <typename OtherT> bool operator==(const OtherT &other) const {\n    return size() ==\n               static_cast<size_t>(std::distance(other.begin(), other.end())) &&\n           std::equal(begin(), end(), other.begin());\n  }\n  template <typename OtherT> bool operator!=(const OtherT &other) const {\n    return !(*this == other);\n  }\n\n  /// Return the size of this range.\n  size_t size() const { return count; }\n\n  /// Return if the range is empty.\n  bool empty() const { return size() == 0; }\n\n  /// Drop the first N elements, and keep M elements.\n  DerivedT slice(size_t n, size_t m) const {\n    assert(n + m <= size() && \"invalid size specifiers\");\n    return DerivedT(offset_base(base, n), m);\n  }\n\n  /// Drop the first n elements.\n  DerivedT drop_front(size_t n = 1) const {\n    assert(size() >= n && \"Dropping more elements than exist\");\n    return slice(n, size() - n);\n  }\n  /// Drop the last n elements.\n  DerivedT drop_back(size_t n = 1) const {\n    assert(size() >= n && \"Dropping more elements than exist\");\n    return DerivedT(base, size() - n);\n  }\n\n  /// Take the first n elements.\n  DerivedT take_front(size_t n = 1) const {\n    return n < size() ? drop_back(size() - n)\n                      : static_cast<const DerivedT &>(*this);\n  }\n\n  /// Take the last n elements.\n  DerivedT take_back(size_t n = 1) const {\n    return n < size() ? drop_front(size() - n)\n                      : static_cast<const DerivedT &>(*this);\n  }\n\n  /// Allow conversion to any type accepting an iterator_range.\n  template <typename RangeT, typename = std::enable_if_t<std::is_constructible<\n                                 RangeT, iterator_range<iterator>>::value>>\n  operator RangeT() const {\n    return RangeT(iterator_range<iterator>(*this));\n  }\n\n  /// Returns the base of this range.\n  const BaseT &getBase() const { return base; }\n\nprivate:\n  /// Offset the given base by the given amount.\n  static BaseT offset_base(const BaseT &base, size_t n) {\n    return n == 0 ? base : DerivedT::offset_base(base, n);\n  }\n\nprotected:\n  indexed_accessor_range_base(const indexed_accessor_range_base &) = default;\n  indexed_accessor_range_base(indexed_accessor_range_base &&) = default;\n  indexed_accessor_range_base &\n  operator=(const indexed_accessor_range_base &) = default;\n\n  /// The base that owns the provided range of values.\n  BaseT base;\n  /// The size from the owning range.\n  ptrdiff_t count;\n};\n} // end namespace detail\n\n/// This class provides an implementation of a range of\n/// indexed_accessor_iterators where the base is not indexable. Ranges with\n/// bases that are offsetable should derive from indexed_accessor_range_base\n/// instead. Derived range classes are expected to implement the following\n/// static method:\n///   * ReferenceT dereference(const BaseT &base, ptrdiff_t index)\n///     - Dereference an iterator pointing to a parent base at the given index.\ntemplate <typename DerivedT, typename BaseT, typename T,\n          typename PointerT = T *, typename ReferenceT = T &>\nclass indexed_accessor_range\n    : public detail::indexed_accessor_range_base<\n          DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT> {\npublic:\n  indexed_accessor_range(BaseT base, ptrdiff_t startIndex, ptrdiff_t count)\n      : detail::indexed_accessor_range_base<\n            DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT>(\n            std::make_pair(base, startIndex), count) {}\n  using detail::indexed_accessor_range_base<\n      DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT,\n      ReferenceT>::indexed_accessor_range_base;\n\n  /// Returns the current base of the range.\n  const BaseT &getBase() const { return this->base.first; }\n\n  /// Returns the current start index of the range.\n  ptrdiff_t getStartIndex() const { return this->base.second; }\n\n  /// See `detail::indexed_accessor_range_base` for details.\n  static std::pair<BaseT, ptrdiff_t>\n  offset_base(const std::pair<BaseT, ptrdiff_t> &base, ptrdiff_t index) {\n    // We encode the internal base as a pair of the derived base and a start\n    // index into the derived base.\n    return std::make_pair(base.first, base.second + index);\n  }\n  /// See `detail::indexed_accessor_range_base` for details.\n  static ReferenceT\n  dereference_iterator(const std::pair<BaseT, ptrdiff_t> &base,\n                       ptrdiff_t index) {\n    return DerivedT::dereference(base.first, base.second + index);\n  }\n};\n\n/// Given a container of pairs, return a range over the first elements.\ntemplate <typename ContainerTy> auto make_first_range(ContainerTy &&c) {\n  return llvm::map_range(\n      std::forward<ContainerTy>(c),\n      [](decltype((*std::begin(c))) elt) -> decltype((elt.first)) {\n        return elt.first;\n      });\n}\n\n/// Given a container of pairs, return a range over the second elements.\ntemplate <typename ContainerTy> auto make_second_range(ContainerTy &&c) {\n  return llvm::map_range(\n      std::forward<ContainerTy>(c),\n      [](decltype((*std::begin(c))) elt) -> decltype((elt.second)) {\n        return elt.second;\n      });\n}\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <utility>\n//===----------------------------------------------------------------------===//\n\n/// Function object to check whether the first component of a std::pair\n/// compares less than the first component of another std::pair.\nstruct less_first {\n  template <typename T> bool operator()(const T &lhs, const T &rhs) const {\n    return lhs.first < rhs.first;\n  }\n};\n\n/// Function object to check whether the second component of a std::pair\n/// compares less than the second component of another std::pair.\nstruct less_second {\n  template <typename T> bool operator()(const T &lhs, const T &rhs) const {\n    return lhs.second < rhs.second;\n  }\n};\n\n/// \\brief Function object to apply a binary function to the first component of\n/// a std::pair.\ntemplate<typename FuncTy>\nstruct on_first {\n  FuncTy func;\n\n  template <typename T>\n  decltype(auto) operator()(const T &lhs, const T &rhs) const {\n    return func(lhs.first, rhs.first);\n  }\n};\n\n/// Utility type to build an inheritance chain that makes it easy to rank\n/// overload candidates.\ntemplate <int N> struct rank : rank<N - 1> {};\ntemplate <> struct rank<0> {};\n\n/// traits class for checking whether type T is one of any of the given\n/// types in the variadic list.\ntemplate <typename T, typename... Ts> struct is_one_of {\n  static const bool value = false;\n};\n\ntemplate <typename T, typename U, typename... Ts>\nstruct is_one_of<T, U, Ts...> {\n  static const bool value =\n      std::is_same<T, U>::value || is_one_of<T, Ts...>::value;\n};\n\n/// traits class for checking whether type T is a base class for all\n///  the given types in the variadic list.\ntemplate <typename T, typename... Ts> struct are_base_of {\n  static const bool value = true;\n};\n\ntemplate <typename T, typename U, typename... Ts>\nstruct are_base_of<T, U, Ts...> {\n  static const bool value =\n      std::is_base_of<T, U>::value && are_base_of<T, Ts...>::value;\n};\n\n//===----------------------------------------------------------------------===//\n//     Extra additions for arrays\n//===----------------------------------------------------------------------===//\n\n// We have a copy here so that LLVM behaves the same when using different\n// standard libraries.\ntemplate <class Iterator, class RNG>\nvoid shuffle(Iterator first, Iterator last, RNG &&g) {\n  // It would be better to use a std::uniform_int_distribution,\n  // but that would be stdlib dependent.\n  typedef\n      typename std::iterator_traits<Iterator>::difference_type difference_type;\n  for (auto size = last - first; size > 1; ++first, (void)--size) {\n    difference_type offset = g() % size;\n    // Avoid self-assignment due to incorrect assertions in libstdc++\n    // containers (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85828).\n    if (offset != difference_type(0))\n      std::iter_swap(first, first + offset);\n  }\n}\n\n/// Find the length of an array.\ntemplate <class T, std::size_t N>\nconstexpr inline size_t array_lengthof(T (&)[N]) {\n  return N;\n}\n\n/// Adapt std::less<T> for array_pod_sort.\ntemplate<typename T>\ninline int array_pod_sort_comparator(const void *P1, const void *P2) {\n  if (std::less<T>()(*reinterpret_cast<const T*>(P1),\n                     *reinterpret_cast<const T*>(P2)))\n    return -1;\n  if (std::less<T>()(*reinterpret_cast<const T*>(P2),\n                     *reinterpret_cast<const T*>(P1)))\n    return 1;\n  return 0;\n}\n\n/// get_array_pod_sort_comparator - This is an internal helper function used to\n/// get type deduction of T right.\ntemplate<typename T>\ninline int (*get_array_pod_sort_comparator(const T &))\n             (const void*, const void*) {\n  return array_pod_sort_comparator<T>;\n}\n\n#ifdef EXPENSIVE_CHECKS\nnamespace detail {\n\ninline unsigned presortShuffleEntropy() {\n  static unsigned Result(std::random_device{}());\n  return Result;\n}\n\ntemplate <class IteratorTy>\ninline void presortShuffle(IteratorTy Start, IteratorTy End) {\n  std::mt19937 Generator(presortShuffleEntropy());\n  llvm::shuffle(Start, End, Generator);\n}\n\n} // end namespace detail\n#endif\n\n/// array_pod_sort - This sorts an array with the specified start and end\n/// extent.  This is just like std::sort, except that it calls qsort instead of\n/// using an inlined template.  qsort is slightly slower than std::sort, but\n/// most sorts are not performance critical in LLVM and std::sort has to be\n/// template instantiated for each type, leading to significant measured code\n/// bloat.  This function should generally be used instead of std::sort where\n/// possible.\n///\n/// This function assumes that you have simple POD-like types that can be\n/// compared with std::less and can be moved with memcpy.  If this isn't true,\n/// you should use std::sort.\n///\n/// NOTE: If qsort_r were portable, we could allow a custom comparator and\n/// default to std::less.\ntemplate<class IteratorTy>\ninline void array_pod_sort(IteratorTy Start, IteratorTy End) {\n  // Don't inefficiently call qsort with one element or trigger undefined\n  // behavior with an empty sequence.\n  auto NElts = End - Start;\n  if (NElts <= 1) return;\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  qsort(&*Start, NElts, sizeof(*Start), get_array_pod_sort_comparator(*Start));\n}\n\ntemplate <class IteratorTy>\ninline void array_pod_sort(\n    IteratorTy Start, IteratorTy End,\n    int (*Compare)(\n        const typename std::iterator_traits<IteratorTy>::value_type *,\n        const typename std::iterator_traits<IteratorTy>::value_type *)) {\n  // Don't inefficiently call qsort with one element or trigger undefined\n  // behavior with an empty sequence.\n  auto NElts = End - Start;\n  if (NElts <= 1) return;\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  qsort(&*Start, NElts, sizeof(*Start),\n        reinterpret_cast<int (*)(const void *, const void *)>(Compare));\n}\n\nnamespace detail {\ntemplate <typename T>\n// We can use qsort if the iterator type is a pointer and the underlying value\n// is trivially copyable.\nusing sort_trivially_copyable = conjunction<\n    std::is_pointer<T>,\n    std::is_trivially_copyable<typename std::iterator_traits<T>::value_type>>;\n} // namespace detail\n\n// Provide wrappers to std::sort which shuffle the elements before sorting\n// to help uncover non-deterministic behavior (PR35135).\ntemplate <typename IteratorTy,\n          std::enable_if_t<!detail::sort_trivially_copyable<IteratorTy>::value,\n                           int> = 0>\ninline void sort(IteratorTy Start, IteratorTy End) {\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  std::sort(Start, End);\n}\n\n// Forward trivially copyable types to array_pod_sort. This avoids a large\n// amount of code bloat for a minor performance hit.\ntemplate <typename IteratorTy,\n          std::enable_if_t<detail::sort_trivially_copyable<IteratorTy>::value,\n                           int> = 0>\ninline void sort(IteratorTy Start, IteratorTy End) {\n  array_pod_sort(Start, End);\n}\n\ntemplate <typename Container> inline void sort(Container &&C) {\n  llvm::sort(adl_begin(C), adl_end(C));\n}\n\ntemplate <typename IteratorTy, typename Compare>\ninline void sort(IteratorTy Start, IteratorTy End, Compare Comp) {\n#ifdef EXPENSIVE_CHECKS\n  detail::presortShuffle<IteratorTy>(Start, End);\n#endif\n  std::sort(Start, End, Comp);\n}\n\ntemplate <typename Container, typename Compare>\ninline void sort(Container &&C, Compare Comp) {\n  llvm::sort(adl_begin(C), adl_end(C), Comp);\n}\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <algorithm>\n//===----------------------------------------------------------------------===//\n\n/// Get the size of a range. This is a wrapper function around std::distance\n/// which is only enabled when the operation is O(1).\ntemplate <typename R>\nauto size(R &&Range,\n          std::enable_if_t<\n              std::is_base_of<std::random_access_iterator_tag,\n                              typename std::iterator_traits<decltype(\n                                  Range.begin())>::iterator_category>::value,\n              void> * = nullptr) {\n  return std::distance(Range.begin(), Range.end());\n}\n\n/// Provide wrappers to std::for_each which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename UnaryFunction>\nUnaryFunction for_each(R &&Range, UnaryFunction F) {\n  return std::for_each(adl_begin(Range), adl_end(Range), F);\n}\n\n/// Provide wrappers to std::all_of which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nbool all_of(R &&Range, UnaryPredicate P) {\n  return std::all_of(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::any_of which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nbool any_of(R &&Range, UnaryPredicate P) {\n  return std::any_of(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::none_of which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nbool none_of(R &&Range, UnaryPredicate P) {\n  return std::none_of(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::find which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename T> auto find(R &&Range, const T &Val) {\n  return std::find(adl_begin(Range), adl_end(Range), Val);\n}\n\n/// Provide wrappers to std::find_if which take ranges instead of having to pass\n/// begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nauto find_if(R &&Range, UnaryPredicate P) {\n  return std::find_if(adl_begin(Range), adl_end(Range), P);\n}\n\ntemplate <typename R, typename UnaryPredicate>\nauto find_if_not(R &&Range, UnaryPredicate P) {\n  return std::find_if_not(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::remove_if which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nauto remove_if(R &&Range, UnaryPredicate P) {\n  return std::remove_if(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::copy_if which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename OutputIt, typename UnaryPredicate>\nOutputIt copy_if(R &&Range, OutputIt Out, UnaryPredicate P) {\n  return std::copy_if(adl_begin(Range), adl_end(Range), Out, P);\n}\n\ntemplate <typename R, typename OutputIt>\nOutputIt copy(R &&Range, OutputIt Out) {\n  return std::copy(adl_begin(Range), adl_end(Range), Out);\n}\n\n/// Provide wrappers to std::move which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename OutputIt>\nOutputIt move(R &&Range, OutputIt Out) {\n  return std::move(adl_begin(Range), adl_end(Range), Out);\n}\n\n/// Wrapper function around std::find to detect if an element exists\n/// in a container.\ntemplate <typename R, typename E>\nbool is_contained(R &&Range, const E &Element) {\n  return std::find(adl_begin(Range), adl_end(Range), Element) != adl_end(Range);\n}\n\n/// Wrapper function around std::is_sorted to check if elements in a range \\p R\n/// are sorted with respect to a comparator \\p C.\ntemplate <typename R, typename Compare> bool is_sorted(R &&Range, Compare C) {\n  return std::is_sorted(adl_begin(Range), adl_end(Range), C);\n}\n\n/// Wrapper function around std::is_sorted to check if elements in a range \\p R\n/// are sorted in non-descending order.\ntemplate <typename R> bool is_sorted(R &&Range) {\n  return std::is_sorted(adl_begin(Range), adl_end(Range));\n}\n\n/// Wrapper function around std::count to count the number of times an element\n/// \\p Element occurs in the given range \\p Range.\ntemplate <typename R, typename E> auto count(R &&Range, const E &Element) {\n  return std::count(adl_begin(Range), adl_end(Range), Element);\n}\n\n/// Wrapper function around std::count_if to count the number of times an\n/// element satisfying a given predicate occurs in a range.\ntemplate <typename R, typename UnaryPredicate>\nauto count_if(R &&Range, UnaryPredicate P) {\n  return std::count_if(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Wrapper function around std::transform to apply a function to a range and\n/// store the result elsewhere.\ntemplate <typename R, typename OutputIt, typename UnaryFunction>\nOutputIt transform(R &&Range, OutputIt d_first, UnaryFunction F) {\n  return std::transform(adl_begin(Range), adl_end(Range), d_first, F);\n}\n\n/// Provide wrappers to std::partition which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename UnaryPredicate>\nauto partition(R &&Range, UnaryPredicate P) {\n  return std::partition(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Provide wrappers to std::lower_bound which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename T> auto lower_bound(R &&Range, T &&Value) {\n  return std::lower_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value));\n}\n\ntemplate <typename R, typename T, typename Compare>\nauto lower_bound(R &&Range, T &&Value, Compare C) {\n  return std::lower_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value), C);\n}\n\n/// Provide wrappers to std::upper_bound which take ranges instead of having to\n/// pass begin/end explicitly.\ntemplate <typename R, typename T> auto upper_bound(R &&Range, T &&Value) {\n  return std::upper_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value));\n}\n\ntemplate <typename R, typename T, typename Compare>\nauto upper_bound(R &&Range, T &&Value, Compare C) {\n  return std::upper_bound(adl_begin(Range), adl_end(Range),\n                          std::forward<T>(Value), C);\n}\n\ntemplate <typename R>\nvoid stable_sort(R &&Range) {\n  std::stable_sort(adl_begin(Range), adl_end(Range));\n}\n\ntemplate <typename R, typename Compare>\nvoid stable_sort(R &&Range, Compare C) {\n  std::stable_sort(adl_begin(Range), adl_end(Range), C);\n}\n\n/// Binary search for the first iterator in a range where a predicate is false.\n/// Requires that C is always true below some limit, and always false above it.\ntemplate <typename R, typename Predicate,\n          typename Val = decltype(*adl_begin(std::declval<R>()))>\nauto partition_point(R &&Range, Predicate P) {\n  return std::partition_point(adl_begin(Range), adl_end(Range), P);\n}\n\n/// Wrapper function around std::equal to detect if all elements\n/// in a container are same.\ntemplate <typename R>\nbool is_splat(R &&Range) {\n  size_t range_size = size(Range);\n  return range_size != 0 && (range_size == 1 ||\n         std::equal(adl_begin(Range) + 1, adl_end(Range), adl_begin(Range)));\n}\n\n/// Provide a container algorithm similar to C++ Library Fundamentals v2's\n/// `erase_if` which is equivalent to:\n///\n///   C.erase(remove_if(C, pred), C.end());\n///\n/// This version works for any container with an erase method call accepting\n/// two iterators.\ntemplate <typename Container, typename UnaryPredicate>\nvoid erase_if(Container &C, UnaryPredicate P) {\n  C.erase(remove_if(C, P), C.end());\n}\n\n/// Wrapper function to remove a value from a container:\n///\n/// C.erase(remove(C.begin(), C.end(), V), C.end());\ntemplate <typename Container, typename ValueType>\nvoid erase_value(Container &C, ValueType V) {\n  C.erase(std::remove(C.begin(), C.end(), V), C.end());\n}\n\n/// Wrapper function to append a range to a container.\n///\n/// C.insert(C.end(), R.begin(), R.end());\ntemplate <typename Container, typename Range>\ninline void append_range(Container &C, Range &&R) {\n  C.insert(C.end(), R.begin(), R.end());\n}\n\n/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with\n/// the range [ValIt, ValEnd) (which is not from the same container).\ntemplate<typename Container, typename RandomAccessIterator>\nvoid replace(Container &Cont, typename Container::iterator ContIt,\n             typename Container::iterator ContEnd, RandomAccessIterator ValIt,\n             RandomAccessIterator ValEnd) {\n  while (true) {\n    if (ValIt == ValEnd) {\n      Cont.erase(ContIt, ContEnd);\n      return;\n    } else if (ContIt == ContEnd) {\n      Cont.insert(ContIt, ValIt, ValEnd);\n      return;\n    }\n    *ContIt++ = *ValIt++;\n  }\n}\n\n/// Given a sequence container Cont, replace the range [ContIt, ContEnd) with\n/// the range R.\ntemplate<typename Container, typename Range = std::initializer_list<\n                                 typename Container::value_type>>\nvoid replace(Container &Cont, typename Container::iterator ContIt,\n             typename Container::iterator ContEnd, Range R) {\n  replace(Cont, ContIt, ContEnd, R.begin(), R.end());\n}\n\n/// An STL-style algorithm similar to std::for_each that applies a second\n/// functor between every pair of elements.\n///\n/// This provides the control flow logic to, for example, print a\n/// comma-separated list:\n/// \\code\n///   interleave(names.begin(), names.end(),\n///              [&](StringRef name) { os << name; },\n///              [&] { os << \", \"; });\n/// \\endcode\ntemplate <typename ForwardIterator, typename UnaryFunctor,\n          typename NullaryFunctor,\n          typename = typename std::enable_if<\n              !std::is_constructible<StringRef, UnaryFunctor>::value &&\n              !std::is_constructible<StringRef, NullaryFunctor>::value>::type>\ninline void interleave(ForwardIterator begin, ForwardIterator end,\n                       UnaryFunctor each_fn, NullaryFunctor between_fn) {\n  if (begin == end)\n    return;\n  each_fn(*begin);\n  ++begin;\n  for (; begin != end; ++begin) {\n    between_fn();\n    each_fn(*begin);\n  }\n}\n\ntemplate <typename Container, typename UnaryFunctor, typename NullaryFunctor,\n          typename = typename std::enable_if<\n              !std::is_constructible<StringRef, UnaryFunctor>::value &&\n              !std::is_constructible<StringRef, NullaryFunctor>::value>::type>\ninline void interleave(const Container &c, UnaryFunctor each_fn,\n                       NullaryFunctor between_fn) {\n  interleave(c.begin(), c.end(), each_fn, between_fn);\n}\n\n/// Overload of interleave for the common case of string separator.\ntemplate <typename Container, typename UnaryFunctor, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleave(const Container &c, StreamT &os, UnaryFunctor each_fn,\n                       const StringRef &separator) {\n  interleave(c.begin(), c.end(), each_fn, [&] { os << separator; });\n}\ntemplate <typename Container, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleave(const Container &c, StreamT &os,\n                       const StringRef &separator) {\n  interleave(\n      c, os, [&](const T &a) { os << a; }, separator);\n}\n\ntemplate <typename Container, typename UnaryFunctor, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleaveComma(const Container &c, StreamT &os,\n                            UnaryFunctor each_fn) {\n  interleave(c, os, each_fn, \", \");\n}\ntemplate <typename Container, typename StreamT,\n          typename T = detail::ValueOfRange<Container>>\ninline void interleaveComma(const Container &c, StreamT &os) {\n  interleaveComma(c, os, [&](const T &a) { os << a; });\n}\n\n//===----------------------------------------------------------------------===//\n//     Extra additions to <memory>\n//===----------------------------------------------------------------------===//\n\nstruct FreeDeleter {\n  void operator()(void* v) {\n    ::free(v);\n  }\n};\n\ntemplate<typename First, typename Second>\nstruct pair_hash {\n  size_t operator()(const std::pair<First, Second> &P) const {\n    return std::hash<First>()(P.first) * 31 + std::hash<Second>()(P.second);\n  }\n};\n\n/// Binary functor that adapts to any other binary functor after dereferencing\n/// operands.\ntemplate <typename T> struct deref {\n  T func;\n\n  // Could be further improved to cope with non-derivable functors and\n  // non-binary functors (should be a variadic template member function\n  // operator()).\n  template <typename A, typename B> auto operator()(A &lhs, B &rhs) const {\n    assert(lhs);\n    assert(rhs);\n    return func(*lhs, *rhs);\n  }\n};\n\nnamespace detail {\n\ntemplate <typename R> class enumerator_iter;\n\ntemplate <typename R> struct result_pair {\n  using value_reference =\n      typename std::iterator_traits<IterOfRange<R>>::reference;\n\n  friend class enumerator_iter<R>;\n\n  result_pair() = default;\n  result_pair(std::size_t Index, IterOfRange<R> Iter)\n      : Index(Index), Iter(Iter) {}\n\n  result_pair(const result_pair<R> &Other)\n      : Index(Other.Index), Iter(Other.Iter) {}\n  result_pair &operator=(const result_pair &Other) {\n    Index = Other.Index;\n    Iter = Other.Iter;\n    return *this;\n  }\n\n  std::size_t index() const { return Index; }\n  const value_reference value() const { return *Iter; }\n  value_reference value() { return *Iter; }\n\nprivate:\n  std::size_t Index = std::numeric_limits<std::size_t>::max();\n  IterOfRange<R> Iter;\n};\n\ntemplate <typename R>\nclass enumerator_iter\n    : public iterator_facade_base<\n          enumerator_iter<R>, std::forward_iterator_tag, result_pair<R>,\n          typename std::iterator_traits<IterOfRange<R>>::difference_type,\n          typename std::iterator_traits<IterOfRange<R>>::pointer,\n          typename std::iterator_traits<IterOfRange<R>>::reference> {\n  using result_type = result_pair<R>;\n\npublic:\n  explicit enumerator_iter(IterOfRange<R> EndIter)\n      : Result(std::numeric_limits<size_t>::max(), EndIter) {}\n\n  enumerator_iter(std::size_t Index, IterOfRange<R> Iter)\n      : Result(Index, Iter) {}\n\n  result_type &operator*() { return Result; }\n  const result_type &operator*() const { return Result; }\n\n  enumerator_iter &operator++() {\n    assert(Result.Index != std::numeric_limits<size_t>::max());\n    ++Result.Iter;\n    ++Result.Index;\n    return *this;\n  }\n\n  bool operator==(const enumerator_iter &RHS) const {\n    // Don't compare indices here, only iterators.  It's possible for an end\n    // iterator to have different indices depending on whether it was created\n    // by calling std::end() versus incrementing a valid iterator.\n    return Result.Iter == RHS.Result.Iter;\n  }\n\n  enumerator_iter(const enumerator_iter &Other) : Result(Other.Result) {}\n  enumerator_iter &operator=(const enumerator_iter &Other) {\n    Result = Other.Result;\n    return *this;\n  }\n\nprivate:\n  result_type Result;\n};\n\ntemplate <typename R> class enumerator {\npublic:\n  explicit enumerator(R &&Range) : TheRange(std::forward<R>(Range)) {}\n\n  enumerator_iter<R> begin() {\n    return enumerator_iter<R>(0, std::begin(TheRange));\n  }\n\n  enumerator_iter<R> end() {\n    return enumerator_iter<R>(std::end(TheRange));\n  }\n\nprivate:\n  R TheRange;\n};\n\n} // end namespace detail\n\n/// Given an input range, returns a new range whose values are are pair (A,B)\n/// such that A is the 0-based index of the item in the sequence, and B is\n/// the value from the original sequence.  Example:\n///\n/// std::vector<char> Items = {'A', 'B', 'C', 'D'};\n/// for (auto X : enumerate(Items)) {\n///   printf(\"Item %d - %c\\n\", X.index(), X.value());\n/// }\n///\n/// Output:\n///   Item 0 - A\n///   Item 1 - B\n///   Item 2 - C\n///   Item 3 - D\n///\ntemplate <typename R> detail::enumerator<R> enumerate(R &&TheRange) {\n  return detail::enumerator<R>(std::forward<R>(TheRange));\n}\n\nnamespace detail {\n\ntemplate <typename F, typename Tuple, std::size_t... I>\ndecltype(auto) apply_tuple_impl(F &&f, Tuple &&t, std::index_sequence<I...>) {\n  return std::forward<F>(f)(std::get<I>(std::forward<Tuple>(t))...);\n}\n\n} // end namespace detail\n\n/// Given an input tuple (a1, a2, ..., an), pass the arguments of the\n/// tuple variadically to f as if by calling f(a1, a2, ..., an) and\n/// return the result.\ntemplate <typename F, typename Tuple>\ndecltype(auto) apply_tuple(F &&f, Tuple &&t) {\n  using Indices = std::make_index_sequence<\n      std::tuple_size<typename std::decay<Tuple>::type>::value>;\n\n  return detail::apply_tuple_impl(std::forward<F>(f), std::forward<Tuple>(t),\n                                  Indices{});\n}\n\n/// Return true if the sequence [Begin, End) has exactly N items. Runs in O(N)\n/// time. Not meant for use with random-access iterators.\n/// Can optionally take a predicate to filter lazily some items.\ntemplate <typename IterTy,\n          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>\nbool hasNItems(\n    IterTy &&Begin, IterTy &&End, unsigned N,\n    Pred &&ShouldBeCounted =\n        [](const decltype(*std::declval<IterTy>()) &) { return true; },\n    std::enable_if_t<\n        !std::is_base_of<std::random_access_iterator_tag,\n                         typename std::iterator_traits<std::remove_reference_t<\n                             decltype(Begin)>>::iterator_category>::value,\n        void> * = nullptr) {\n  for (; N; ++Begin) {\n    if (Begin == End)\n      return false; // Too few.\n    N -= ShouldBeCounted(*Begin);\n  }\n  for (; Begin != End; ++Begin)\n    if (ShouldBeCounted(*Begin))\n      return false; // Too many.\n  return true;\n}\n\n/// Return true if the sequence [Begin, End) has N or more items. Runs in O(N)\n/// time. Not meant for use with random-access iterators.\n/// Can optionally take a predicate to lazily filter some items.\ntemplate <typename IterTy,\n          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>\nbool hasNItemsOrMore(\n    IterTy &&Begin, IterTy &&End, unsigned N,\n    Pred &&ShouldBeCounted =\n        [](const decltype(*std::declval<IterTy>()) &) { return true; },\n    std::enable_if_t<\n        !std::is_base_of<std::random_access_iterator_tag,\n                         typename std::iterator_traits<std::remove_reference_t<\n                             decltype(Begin)>>::iterator_category>::value,\n        void> * = nullptr) {\n  for (; N; ++Begin) {\n    if (Begin == End)\n      return false; // Too few.\n    N -= ShouldBeCounted(*Begin);\n  }\n  return true;\n}\n\n/// Returns true if the sequence [Begin, End) has N or less items. Can\n/// optionally take a predicate to lazily filter some items.\ntemplate <typename IterTy,\n          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>\nbool hasNItemsOrLess(\n    IterTy &&Begin, IterTy &&End, unsigned N,\n    Pred &&ShouldBeCounted = [](const decltype(*std::declval<IterTy>()) &) {\n      return true;\n    }) {\n  assert(N != std::numeric_limits<unsigned>::max());\n  return !hasNItemsOrMore(Begin, End, N + 1, ShouldBeCounted);\n}\n\n/// Returns true if the given container has exactly N items\ntemplate <typename ContainerTy> bool hasNItems(ContainerTy &&C, unsigned N) {\n  return hasNItems(std::begin(C), std::end(C), N);\n}\n\n/// Returns true if the given container has N or more items\ntemplate <typename ContainerTy>\nbool hasNItemsOrMore(ContainerTy &&C, unsigned N) {\n  return hasNItemsOrMore(std::begin(C), std::end(C), N);\n}\n\n/// Returns true if the given container has N or less items\ntemplate <typename ContainerTy>\nbool hasNItemsOrLess(ContainerTy &&C, unsigned N) {\n  return hasNItemsOrLess(std::begin(C), std::end(C), N);\n}\n\n/// Returns a raw pointer that represents the same address as the argument.\n///\n/// This implementation can be removed once we move to C++20 where it's defined\n/// as std::to_address().\n///\n/// The std::pointer_traits<>::to_address(p) variations of these overloads has\n/// not been implemented.\ntemplate <class Ptr> auto to_address(const Ptr &P) { return P.operator->(); }\ntemplate <class T> constexpr T *to_address(T *P) { return P; }\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_STLEXTRAS_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "content": "//===- llvm/ADT/SmallPtrSet.h - 'Normally small' pointer set ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the SmallPtrSet class.  See the doxygen comment for\n// SmallPtrSetImplBase for more details on the algorithm used.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SMALLPTRSET_H\n#define LLVM_ADT_SMALLPTRSET_H\n\n#include \"llvm/ADT/EpochTracker.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ReverseIteration.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdlib>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <utility>\n\nnamespace llvm {\n\n/// SmallPtrSetImplBase - This is the common code shared among all the\n/// SmallPtrSet<>'s, which is almost everything.  SmallPtrSet has two modes, one\n/// for small and one for large sets.\n///\n/// Small sets use an array of pointers allocated in the SmallPtrSet object,\n/// which is treated as a simple array of pointers.  When a pointer is added to\n/// the set, the array is scanned to see if the element already exists, if not\n/// the element is 'pushed back' onto the array.  If we run out of space in the\n/// array, we grow into the 'large set' case.  SmallSet should be used when the\n/// sets are often small.  In this case, no memory allocation is used, and only\n/// light-weight and cache-efficient scanning is used.\n///\n/// Large sets use a classic exponentially-probed hash table.  Empty buckets are\n/// represented with an illegal pointer value (-1) to allow null pointers to be\n/// inserted.  Tombstones are represented with another illegal pointer value\n/// (-2), to allow deletion.  The hash table is resized when the table is 3/4 or\n/// more.  When this happens, the table is doubled in size.\n///\nclass SmallPtrSetImplBase : public DebugEpochBase {\n  friend class SmallPtrSetIteratorImpl;\n\nprotected:\n  /// SmallArray - Points to a fixed size set of buckets, used in 'small mode'.\n  const void **SmallArray;\n  /// CurArray - This is the current set of buckets.  If equal to SmallArray,\n  /// then the set is in 'small mode'.\n  const void **CurArray;\n  /// CurArraySize - The allocated size of CurArray, always a power of two.\n  unsigned CurArraySize;\n\n  /// Number of elements in CurArray that contain a value or are a tombstone.\n  /// If small, all these elements are at the beginning of CurArray and the rest\n  /// is uninitialized.\n  unsigned NumNonEmpty;\n  /// Number of tombstones in CurArray.\n  unsigned NumTombstones;\n\n  // Helpers to copy and move construct a SmallPtrSet.\n  SmallPtrSetImplBase(const void **SmallStorage,\n                      const SmallPtrSetImplBase &that);\n  SmallPtrSetImplBase(const void **SmallStorage, unsigned SmallSize,\n                      SmallPtrSetImplBase &&that);\n\n  explicit SmallPtrSetImplBase(const void **SmallStorage, unsigned SmallSize)\n      : SmallArray(SmallStorage), CurArray(SmallStorage),\n        CurArraySize(SmallSize), NumNonEmpty(0), NumTombstones(0) {\n    assert(SmallSize && (SmallSize & (SmallSize-1)) == 0 &&\n           \"Initial size must be a power of two!\");\n  }\n\n  ~SmallPtrSetImplBase() {\n    if (!isSmall())\n      free(CurArray);\n  }\n\npublic:\n  using size_type = unsigned;\n\n  SmallPtrSetImplBase &operator=(const SmallPtrSetImplBase &) = delete;\n\n  LLVM_NODISCARD bool empty() const { return size() == 0; }\n  size_type size() const { return NumNonEmpty - NumTombstones; }\n\n  void clear() {\n    incrementEpoch();\n    // If the capacity of the array is huge, and the # elements used is small,\n    // shrink the array.\n    if (!isSmall()) {\n      if (size() * 4 < CurArraySize && CurArraySize > 32)\n        return shrink_and_clear();\n      // Fill the array with empty markers.\n      memset(CurArray, -1, CurArraySize * sizeof(void *));\n    }\n\n    NumNonEmpty = 0;\n    NumTombstones = 0;\n  }\n\nprotected:\n  static void *getTombstoneMarker() { return reinterpret_cast<void*>(-2); }\n\n  static void *getEmptyMarker() {\n    // Note that -1 is chosen to make clear() efficiently implementable with\n    // memset and because it's not a valid pointer value.\n    return reinterpret_cast<void*>(-1);\n  }\n\n  const void **EndPointer() const {\n    return isSmall() ? CurArray + NumNonEmpty : CurArray + CurArraySize;\n  }\n\n  /// insert_imp - This returns true if the pointer was new to the set, false if\n  /// it was already in the set.  This is hidden from the client so that the\n  /// derived class can check that the right type of pointer is passed in.\n  std::pair<const void *const *, bool> insert_imp(const void *Ptr) {\n    if (isSmall()) {\n      // Check to see if it is already in the set.\n      const void **LastTombstone = nullptr;\n      for (const void **APtr = SmallArray, **E = SmallArray + NumNonEmpty;\n           APtr != E; ++APtr) {\n        const void *Value = *APtr;\n        if (Value == Ptr)\n          return std::make_pair(APtr, false);\n        if (Value == getTombstoneMarker())\n          LastTombstone = APtr;\n      }\n\n      // Did we find any tombstone marker?\n      if (LastTombstone != nullptr) {\n        *LastTombstone = Ptr;\n        --NumTombstones;\n        incrementEpoch();\n        return std::make_pair(LastTombstone, true);\n      }\n\n      // Nope, there isn't.  If we stay small, just 'pushback' now.\n      if (NumNonEmpty < CurArraySize) {\n        SmallArray[NumNonEmpty++] = Ptr;\n        incrementEpoch();\n        return std::make_pair(SmallArray + (NumNonEmpty - 1), true);\n      }\n      // Otherwise, hit the big set case, which will call grow.\n    }\n    return insert_imp_big(Ptr);\n  }\n\n  /// erase_imp - If the set contains the specified pointer, remove it and\n  /// return true, otherwise return false.  This is hidden from the client so\n  /// that the derived class can check that the right type of pointer is passed\n  /// in.\n  bool erase_imp(const void * Ptr) {\n    const void *const *P = find_imp(Ptr);\n    if (P == EndPointer())\n      return false;\n\n    const void **Loc = const_cast<const void **>(P);\n    assert(*Loc == Ptr && \"broken find!\");\n    *Loc = getTombstoneMarker();\n    NumTombstones++;\n    return true;\n  }\n\n  /// Returns the raw pointer needed to construct an iterator.  If element not\n  /// found, this will be EndPointer.  Otherwise, it will be a pointer to the\n  /// slot which stores Ptr;\n  const void *const * find_imp(const void * Ptr) const {\n    if (isSmall()) {\n      // Linear search for the item.\n      for (const void *const *APtr = SmallArray,\n                      *const *E = SmallArray + NumNonEmpty; APtr != E; ++APtr)\n        if (*APtr == Ptr)\n          return APtr;\n      return EndPointer();\n    }\n\n    // Big set case.\n    auto *Bucket = FindBucketFor(Ptr);\n    if (*Bucket == Ptr)\n      return Bucket;\n    return EndPointer();\n  }\n\nprivate:\n  bool isSmall() const { return CurArray == SmallArray; }\n\n  std::pair<const void *const *, bool> insert_imp_big(const void *Ptr);\n\n  const void * const *FindBucketFor(const void *Ptr) const;\n  void shrink_and_clear();\n\n  /// Grow - Allocate a larger backing store for the buckets and move it over.\n  void Grow(unsigned NewSize);\n\nprotected:\n  /// swap - Swaps the elements of two sets.\n  /// Note: This method assumes that both sets have the same small size.\n  void swap(SmallPtrSetImplBase &RHS);\n\n  void CopyFrom(const SmallPtrSetImplBase &RHS);\n  void MoveFrom(unsigned SmallSize, SmallPtrSetImplBase &&RHS);\n\nprivate:\n  /// Code shared by MoveFrom() and move constructor.\n  void MoveHelper(unsigned SmallSize, SmallPtrSetImplBase &&RHS);\n  /// Code shared by CopyFrom() and copy constructor.\n  void CopyHelper(const SmallPtrSetImplBase &RHS);\n};\n\n/// SmallPtrSetIteratorImpl - This is the common base class shared between all\n/// instances of SmallPtrSetIterator.\nclass SmallPtrSetIteratorImpl {\nprotected:\n  const void *const *Bucket;\n  const void *const *End;\n\npublic:\n  explicit SmallPtrSetIteratorImpl(const void *const *BP, const void*const *E)\n    : Bucket(BP), End(E) {\n    if (shouldReverseIterate()) {\n      RetreatIfNotValid();\n      return;\n    }\n    AdvanceIfNotValid();\n  }\n\n  bool operator==(const SmallPtrSetIteratorImpl &RHS) const {\n    return Bucket == RHS.Bucket;\n  }\n  bool operator!=(const SmallPtrSetIteratorImpl &RHS) const {\n    return Bucket != RHS.Bucket;\n  }\n\nprotected:\n  /// AdvanceIfNotValid - If the current bucket isn't valid, advance to a bucket\n  /// that is.   This is guaranteed to stop because the end() bucket is marked\n  /// valid.\n  void AdvanceIfNotValid() {\n    assert(Bucket <= End);\n    while (Bucket != End &&\n           (*Bucket == SmallPtrSetImplBase::getEmptyMarker() ||\n            *Bucket == SmallPtrSetImplBase::getTombstoneMarker()))\n      ++Bucket;\n  }\n  void RetreatIfNotValid() {\n    assert(Bucket >= End);\n    while (Bucket != End &&\n           (Bucket[-1] == SmallPtrSetImplBase::getEmptyMarker() ||\n            Bucket[-1] == SmallPtrSetImplBase::getTombstoneMarker())) {\n      --Bucket;\n    }\n  }\n};\n\n/// SmallPtrSetIterator - This implements a const_iterator for SmallPtrSet.\ntemplate <typename PtrTy>\nclass SmallPtrSetIterator : public SmallPtrSetIteratorImpl,\n                            DebugEpochBase::HandleBase {\n  using PtrTraits = PointerLikeTypeTraits<PtrTy>;\n\npublic:\n  using value_type = PtrTy;\n  using reference = PtrTy;\n  using pointer = PtrTy;\n  using difference_type = std::ptrdiff_t;\n  using iterator_category = std::forward_iterator_tag;\n\n  explicit SmallPtrSetIterator(const void *const *BP, const void *const *E,\n                               const DebugEpochBase &Epoch)\n      : SmallPtrSetIteratorImpl(BP, E), DebugEpochBase::HandleBase(&Epoch) {}\n\n  // Most methods are provided by the base class.\n\n  const PtrTy operator*() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    if (shouldReverseIterate()) {\n      assert(Bucket > End);\n      return PtrTraits::getFromVoidPointer(const_cast<void *>(Bucket[-1]));\n    }\n    assert(Bucket < End);\n    return PtrTraits::getFromVoidPointer(const_cast<void*>(*Bucket));\n  }\n\n  inline SmallPtrSetIterator& operator++() {          // Preincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    if (shouldReverseIterate()) {\n      --Bucket;\n      RetreatIfNotValid();\n      return *this;\n    }\n    ++Bucket;\n    AdvanceIfNotValid();\n    return *this;\n  }\n\n  SmallPtrSetIterator operator++(int) {        // Postincrement\n    SmallPtrSetIterator tmp = *this;\n    ++*this;\n    return tmp;\n  }\n};\n\n/// RoundUpToPowerOfTwo - This is a helper template that rounds N up to the next\n/// power of two (which means N itself if N is already a power of two).\ntemplate<unsigned N>\nstruct RoundUpToPowerOfTwo;\n\n/// RoundUpToPowerOfTwoH - If N is not a power of two, increase it.  This is a\n/// helper template used to implement RoundUpToPowerOfTwo.\ntemplate<unsigned N, bool isPowerTwo>\nstruct RoundUpToPowerOfTwoH {\n  enum { Val = N };\n};\ntemplate<unsigned N>\nstruct RoundUpToPowerOfTwoH<N, false> {\n  enum {\n    // We could just use NextVal = N+1, but this converges faster.  N|(N-1) sets\n    // the right-most zero bits to one all at once, e.g. 0b0011000 -> 0b0011111.\n    Val = RoundUpToPowerOfTwo<(N|(N-1)) + 1>::Val\n  };\n};\n\ntemplate<unsigned N>\nstruct RoundUpToPowerOfTwo {\n  enum { Val = RoundUpToPowerOfTwoH<N, (N&(N-1)) == 0>::Val };\n};\n\n/// A templated base class for \\c SmallPtrSet which provides the\n/// typesafe interface that is common across all small sizes.\n///\n/// This is particularly useful for passing around between interface boundaries\n/// to avoid encoding a particular small size in the interface boundary.\ntemplate <typename PtrType>\nclass SmallPtrSetImpl : public SmallPtrSetImplBase {\n  using ConstPtrType = typename add_const_past_pointer<PtrType>::type;\n  using PtrTraits = PointerLikeTypeTraits<PtrType>;\n  using ConstPtrTraits = PointerLikeTypeTraits<ConstPtrType>;\n\nprotected:\n  // Forward constructors to the base.\n  using SmallPtrSetImplBase::SmallPtrSetImplBase;\n\npublic:\n  using iterator = SmallPtrSetIterator<PtrType>;\n  using const_iterator = SmallPtrSetIterator<PtrType>;\n  using key_type = ConstPtrType;\n  using value_type = PtrType;\n\n  SmallPtrSetImpl(const SmallPtrSetImpl &) = delete;\n\n  /// Inserts Ptr if and only if there is no element in the container equal to\n  /// Ptr. The bool component of the returned pair is true if and only if the\n  /// insertion takes place, and the iterator component of the pair points to\n  /// the element equal to Ptr.\n  std::pair<iterator, bool> insert(PtrType Ptr) {\n    auto p = insert_imp(PtrTraits::getAsVoidPointer(Ptr));\n    return std::make_pair(makeIterator(p.first), p.second);\n  }\n\n  /// Insert the given pointer with an iterator hint that is ignored. This is\n  /// identical to calling insert(Ptr), but allows SmallPtrSet to be used by\n  /// std::insert_iterator and std::inserter().\n  iterator insert(iterator, PtrType Ptr) {\n    return insert(Ptr).first;\n  }\n\n  /// erase - If the set contains the specified pointer, remove it and return\n  /// true, otherwise return false.\n  bool erase(PtrType Ptr) {\n    return erase_imp(PtrTraits::getAsVoidPointer(Ptr));\n  }\n  /// count - Return 1 if the specified pointer is in the set, 0 otherwise.\n  size_type count(ConstPtrType Ptr) const {\n    return find_imp(ConstPtrTraits::getAsVoidPointer(Ptr)) != EndPointer();\n  }\n  iterator find(ConstPtrType Ptr) const {\n    return makeIterator(find_imp(ConstPtrTraits::getAsVoidPointer(Ptr)));\n  }\n  bool contains(ConstPtrType Ptr) const {\n    return find_imp(ConstPtrTraits::getAsVoidPointer(Ptr)) != EndPointer();\n  }\n\n  template <typename IterT>\n  void insert(IterT I, IterT E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  void insert(std::initializer_list<PtrType> IL) {\n    insert(IL.begin(), IL.end());\n  }\n\n  iterator begin() const {\n    if (shouldReverseIterate())\n      return makeIterator(EndPointer() - 1);\n    return makeIterator(CurArray);\n  }\n  iterator end() const { return makeIterator(EndPointer()); }\n\nprivate:\n  /// Create an iterator that dereferences to same place as the given pointer.\n  iterator makeIterator(const void *const *P) const {\n    if (shouldReverseIterate())\n      return iterator(P == EndPointer() ? CurArray : P + 1, CurArray, *this);\n    return iterator(P, EndPointer(), *this);\n  }\n};\n\n/// Equality comparison for SmallPtrSet.\n///\n/// Iterates over elements of LHS confirming that each value from LHS is also in\n/// RHS, and that no additional values are in RHS.\ntemplate <typename PtrType>\nbool operator==(const SmallPtrSetImpl<PtrType> &LHS,\n                const SmallPtrSetImpl<PtrType> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (const auto *KV : LHS)\n    if (!RHS.count(KV))\n      return false;\n\n  return true;\n}\n\n/// Inequality comparison for SmallPtrSet.\n///\n/// Equivalent to !(LHS == RHS).\ntemplate <typename PtrType>\nbool operator!=(const SmallPtrSetImpl<PtrType> &LHS,\n                const SmallPtrSetImpl<PtrType> &RHS) {\n  return !(LHS == RHS);\n}\n\n/// SmallPtrSet - This class implements a set which is optimized for holding\n/// SmallSize or less elements.  This internally rounds up SmallSize to the next\n/// power of two if it is not already a power of two.  See the comments above\n/// SmallPtrSetImplBase for details of the algorithm.\ntemplate<class PtrType, unsigned SmallSize>\nclass SmallPtrSet : public SmallPtrSetImpl<PtrType> {\n  // In small mode SmallPtrSet uses linear search for the elements, so it is\n  // not a good idea to choose this value too high. You may consider using a\n  // DenseSet<> instead if you expect many elements in the set.\n  static_assert(SmallSize <= 32, \"SmallSize should be small\");\n\n  using BaseT = SmallPtrSetImpl<PtrType>;\n\n  // Make sure that SmallSize is a power of two, round up if not.\n  enum { SmallSizePowTwo = RoundUpToPowerOfTwo<SmallSize>::Val };\n  /// SmallStorage - Fixed size storage used in 'small mode'.\n  const void *SmallStorage[SmallSizePowTwo];\n\npublic:\n  SmallPtrSet() : BaseT(SmallStorage, SmallSizePowTwo) {}\n  SmallPtrSet(const SmallPtrSet &that) : BaseT(SmallStorage, that) {}\n  SmallPtrSet(SmallPtrSet &&that)\n      : BaseT(SmallStorage, SmallSizePowTwo, std::move(that)) {}\n\n  template<typename It>\n  SmallPtrSet(It I, It E) : BaseT(SmallStorage, SmallSizePowTwo) {\n    this->insert(I, E);\n  }\n\n  SmallPtrSet(std::initializer_list<PtrType> IL)\n      : BaseT(SmallStorage, SmallSizePowTwo) {\n    this->insert(IL.begin(), IL.end());\n  }\n\n  SmallPtrSet<PtrType, SmallSize> &\n  operator=(const SmallPtrSet<PtrType, SmallSize> &RHS) {\n    if (&RHS != this)\n      this->CopyFrom(RHS);\n    return *this;\n  }\n\n  SmallPtrSet<PtrType, SmallSize> &\n  operator=(SmallPtrSet<PtrType, SmallSize> &&RHS) {\n    if (&RHS != this)\n      this->MoveFrom(SmallSizePowTwo, std::move(RHS));\n    return *this;\n  }\n\n  SmallPtrSet<PtrType, SmallSize> &\n  operator=(std::initializer_list<PtrType> IL) {\n    this->clear();\n    this->insert(IL.begin(), IL.end());\n    return *this;\n  }\n\n  /// swap - Swaps the elements of two sets.\n  void swap(SmallPtrSet<PtrType, SmallSize> &RHS) {\n    SmallPtrSetImplBase::swap(RHS);\n  }\n};\n\n} // end namespace llvm\n\nnamespace std {\n\n  /// Implement std::swap in terms of SmallPtrSet swap.\n  template<class T, unsigned N>\n  inline void swap(llvm::SmallPtrSet<T, N> &LHS, llvm::SmallPtrSet<T, N> &RHS) {\n    LHS.swap(RHS);\n  }\n\n} // end namespace std\n\n#endif // LLVM_ADT_SMALLPTRSET_H\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallVector.h", "content": "//===- llvm/ADT/SmallVector.h - 'Normally small' vectors --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the SmallVector class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SMALLVECTOR_H\n#define LLVM_ADT_SMALLVECTOR_H\n\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MemAlloc.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdlib>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <limits>\n#include <memory>\n#include <new>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\n/// This is all the stuff common to all SmallVectors.\n///\n/// The template parameter specifies the type which should be used to hold the\n/// Size and Capacity of the SmallVector, so it can be adjusted.\n/// Using 32 bit size is desirable to shrink the size of the SmallVector.\n/// Using 64 bit size is desirable for cases like SmallVector<char>, where a\n/// 32 bit size would limit the vector to ~4GB. SmallVectors are used for\n/// buffering bitcode output - which can exceed 4GB.\ntemplate <class Size_T> class SmallVectorBase {\nprotected:\n  void *BeginX;\n  Size_T Size = 0, Capacity;\n\n  /// The maximum value of the Size_T used.\n  static constexpr size_t SizeTypeMax() {\n    return std::numeric_limits<Size_T>::max();\n  }\n\n  SmallVectorBase() = delete;\n  SmallVectorBase(void *FirstEl, size_t TotalCapacity)\n      : BeginX(FirstEl), Capacity(TotalCapacity) {}\n\n  /// This is a helper for \\a grow() that's out of line to reduce code\n  /// duplication.  This function will report a fatal error if it can't grow at\n  /// least to \\p MinSize.\n  void *mallocForGrow(size_t MinSize, size_t TSize, size_t &NewCapacity);\n\n  /// This is an implementation of the grow() method which only works\n  /// on POD-like data types and is out of line to reduce code duplication.\n  /// This function will report a fatal error if it cannot increase capacity.\n  void grow_pod(void *FirstEl, size_t MinSize, size_t TSize);\n\npublic:\n  size_t size() const { return Size; }\n  size_t capacity() const { return Capacity; }\n\n  LLVM_NODISCARD bool empty() const { return !Size; }\n\n  /// Set the array size to \\p N, which the current array must have enough\n  /// capacity for.\n  ///\n  /// This does not construct or destroy any elements in the vector.\n  ///\n  /// Clients can use this in conjunction with capacity() to write past the end\n  /// of the buffer when they know that more elements are available, and only\n  /// update the size later. This avoids the cost of value initializing elements\n  /// which will only be overwritten.\n  void set_size(size_t N) {\n    assert(N <= capacity());\n    Size = N;\n  }\n};\n\ntemplate <class T>\nusing SmallVectorSizeType =\n    typename std::conditional<sizeof(T) < 4 && sizeof(void *) >= 8, uint64_t,\n                              uint32_t>::type;\n\n/// Figure out the offset of the first element.\ntemplate <class T, typename = void> struct SmallVectorAlignmentAndSize {\n  alignas(SmallVectorBase<SmallVectorSizeType<T>>) char Base[sizeof(\n      SmallVectorBase<SmallVectorSizeType<T>>)];\n  alignas(T) char FirstEl[sizeof(T)];\n};\n\n/// This is the part of SmallVectorTemplateBase which does not depend on whether\n/// the type T is a POD. The extra dummy template argument is used by ArrayRef\n/// to avoid unnecessarily requiring T to be complete.\ntemplate <typename T, typename = void>\nclass SmallVectorTemplateCommon\n    : public SmallVectorBase<SmallVectorSizeType<T>> {\n  using Base = SmallVectorBase<SmallVectorSizeType<T>>;\n\n  /// Find the address of the first element.  For this pointer math to be valid\n  /// with small-size of 0 for T with lots of alignment, it's important that\n  /// SmallVectorStorage is properly-aligned even for small-size of 0.\n  void *getFirstEl() const {\n    return const_cast<void *>(reinterpret_cast<const void *>(\n        reinterpret_cast<const char *>(this) +\n        offsetof(SmallVectorAlignmentAndSize<T>, FirstEl)));\n  }\n  // Space after 'FirstEl' is clobbered, do not add any instance vars after it.\n\nprotected:\n  SmallVectorTemplateCommon(size_t Size) : Base(getFirstEl(), Size) {}\n\n  void grow_pod(size_t MinSize, size_t TSize) {\n    Base::grow_pod(getFirstEl(), MinSize, TSize);\n  }\n\n  /// Return true if this is a smallvector which has not had dynamic\n  /// memory allocated for it.\n  bool isSmall() const { return this->BeginX == getFirstEl(); }\n\n  /// Put this vector in a state of being small.\n  void resetToSmall() {\n    this->BeginX = getFirstEl();\n    this->Size = this->Capacity = 0; // FIXME: Setting Capacity to 0 is suspect.\n  }\n\n  /// Return true if V is an internal reference to the given range.\n  bool isReferenceToRange(const void *V, const void *First, const void *Last) const {\n    // Use std::less to avoid UB.\n    std::less<> LessThan;\n    return !LessThan(V, First) && LessThan(V, Last);\n  }\n\n  /// Return true if V is an internal reference to this vector.\n  bool isReferenceToStorage(const void *V) const {\n    return isReferenceToRange(V, this->begin(), this->end());\n  }\n\n  /// Return true if First and Last form a valid (possibly empty) range in this\n  /// vector's storage.\n  bool isRangeInStorage(const void *First, const void *Last) const {\n    // Use std::less to avoid UB.\n    std::less<> LessThan;\n    return !LessThan(First, this->begin()) && !LessThan(Last, First) &&\n           !LessThan(this->end(), Last);\n  }\n\n  /// Return true unless Elt will be invalidated by resizing the vector to\n  /// NewSize.\n  bool isSafeToReferenceAfterResize(const void *Elt, size_t NewSize) {\n    // Past the end.\n    if (LLVM_LIKELY(!isReferenceToStorage(Elt)))\n      return true;\n\n    // Return false if Elt will be destroyed by shrinking.\n    if (NewSize <= this->size())\n      return Elt < this->begin() + NewSize;\n\n    // Return false if we need to grow.\n    return NewSize <= this->capacity();\n  }\n\n  /// Check whether Elt will be invalidated by resizing the vector to NewSize.\n  void assertSafeToReferenceAfterResize(const void *Elt, size_t NewSize) {\n    assert(isSafeToReferenceAfterResize(Elt, NewSize) &&\n           \"Attempting to reference an element of the vector in an operation \"\n           \"that invalidates it\");\n  }\n\n  /// Check whether Elt will be invalidated by increasing the size of the\n  /// vector by N.\n  void assertSafeToAdd(const void *Elt, size_t N = 1) {\n    this->assertSafeToReferenceAfterResize(Elt, this->size() + N);\n  }\n\n  /// Check whether any part of the range will be invalidated by clearing.\n  void assertSafeToReferenceAfterClear(const T *From, const T *To) {\n    if (From == To)\n      return;\n    this->assertSafeToReferenceAfterResize(From, 0);\n    this->assertSafeToReferenceAfterResize(To - 1, 0);\n  }\n  template <\n      class ItTy,\n      std::enable_if_t<!std::is_same<std::remove_const_t<ItTy>, T *>::value,\n                       bool> = false>\n  void assertSafeToReferenceAfterClear(ItTy, ItTy) {}\n\n  /// Check whether any part of the range will be invalidated by growing.\n  void assertSafeToAddRange(const T *From, const T *To) {\n    if (From == To)\n      return;\n    this->assertSafeToAdd(From, To - From);\n    this->assertSafeToAdd(To - 1, To - From);\n  }\n  template <\n      class ItTy,\n      std::enable_if_t<!std::is_same<std::remove_const_t<ItTy>, T *>::value,\n                       bool> = false>\n  void assertSafeToAddRange(ItTy, ItTy) {}\n\n  /// Reserve enough space to add one element, and return the updated element\n  /// pointer in case it was a reference to the storage.\n  template <class U>\n  static const T *reserveForParamAndGetAddressImpl(U *This, const T &Elt,\n                                                   size_t N) {\n    size_t NewSize = This->size() + N;\n    if (LLVM_LIKELY(NewSize <= This->capacity()))\n      return &Elt;\n\n    bool ReferencesStorage = false;\n    int64_t Index = -1;\n    if (!U::TakesParamByValue) {\n      if (LLVM_UNLIKELY(This->isReferenceToStorage(&Elt))) {\n        ReferencesStorage = true;\n        Index = &Elt - This->begin();\n      }\n    }\n    This->grow(NewSize);\n    return ReferencesStorage ? This->begin() + Index : &Elt;\n  }\n\npublic:\n  using size_type = size_t;\n  using difference_type = ptrdiff_t;\n  using value_type = T;\n  using iterator = T *;\n  using const_iterator = const T *;\n\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n\n  using reference = T &;\n  using const_reference = const T &;\n  using pointer = T *;\n  using const_pointer = const T *;\n\n  using Base::capacity;\n  using Base::empty;\n  using Base::size;\n\n  // forward iterator creation methods.\n  iterator begin() { return (iterator)this->BeginX; }\n  const_iterator begin() const { return (const_iterator)this->BeginX; }\n  iterator end() { return begin() + size(); }\n  const_iterator end() const { return begin() + size(); }\n\n  // reverse iterator creation methods.\n  reverse_iterator rbegin()            { return reverse_iterator(end()); }\n  const_reverse_iterator rbegin() const{ return const_reverse_iterator(end()); }\n  reverse_iterator rend()              { return reverse_iterator(begin()); }\n  const_reverse_iterator rend() const { return const_reverse_iterator(begin());}\n\n  size_type size_in_bytes() const { return size() * sizeof(T); }\n  size_type max_size() const {\n    return std::min(this->SizeTypeMax(), size_type(-1) / sizeof(T));\n  }\n\n  size_t capacity_in_bytes() const { return capacity() * sizeof(T); }\n\n  /// Return a pointer to the vector's buffer, even if empty().\n  pointer data() { return pointer(begin()); }\n  /// Return a pointer to the vector's buffer, even if empty().\n  const_pointer data() const { return const_pointer(begin()); }\n\n  reference operator[](size_type idx) {\n    assert(idx < size());\n    return begin()[idx];\n  }\n  const_reference operator[](size_type idx) const {\n    assert(idx < size());\n    return begin()[idx];\n  }\n\n  reference front() {\n    assert(!empty());\n    return begin()[0];\n  }\n  const_reference front() const {\n    assert(!empty());\n    return begin()[0];\n  }\n\n  reference back() {\n    assert(!empty());\n    return end()[-1];\n  }\n  const_reference back() const {\n    assert(!empty());\n    return end()[-1];\n  }\n};\n\n/// SmallVectorTemplateBase<TriviallyCopyable = false> - This is where we put\n/// method implementations that are designed to work with non-trivial T's.\n///\n/// We approximate is_trivially_copyable with trivial move/copy construction and\n/// trivial destruction. While the standard doesn't specify that you're allowed\n/// copy these types with memcpy, there is no way for the type to observe this.\n/// This catches the important case of std::pair<POD, POD>, which is not\n/// trivially assignable.\ntemplate <typename T, bool = (is_trivially_copy_constructible<T>::value) &&\n                             (is_trivially_move_constructible<T>::value) &&\n                             std::is_trivially_destructible<T>::value>\nclass SmallVectorTemplateBase : public SmallVectorTemplateCommon<T> {\n  friend class SmallVectorTemplateCommon<T>;\n\nprotected:\n  static constexpr bool TakesParamByValue = false;\n  using ValueParamT = const T &;\n\n  SmallVectorTemplateBase(size_t Size) : SmallVectorTemplateCommon<T>(Size) {}\n\n  static void destroy_range(T *S, T *E) {\n    while (S != E) {\n      --E;\n      E->~T();\n    }\n  }\n\n  /// Move the range [I, E) into the uninitialized memory starting with \"Dest\",\n  /// constructing elements as needed.\n  template<typename It1, typename It2>\n  static void uninitialized_move(It1 I, It1 E, It2 Dest) {\n    std::uninitialized_copy(std::make_move_iterator(I),\n                            std::make_move_iterator(E), Dest);\n  }\n\n  /// Copy the range [I, E) onto the uninitialized memory starting with \"Dest\",\n  /// constructing elements as needed.\n  template<typename It1, typename It2>\n  static void uninitialized_copy(It1 I, It1 E, It2 Dest) {\n    std::uninitialized_copy(I, E, Dest);\n  }\n\n  /// Grow the allocated memory (without initializing new elements), doubling\n  /// the size of the allocated memory. Guarantees space for at least one more\n  /// element, or MinSize more elements if specified.\n  void grow(size_t MinSize = 0);\n\n  /// Create a new allocation big enough for \\p MinSize and pass back its size\n  /// in \\p NewCapacity. This is the first section of \\a grow().\n  T *mallocForGrow(size_t MinSize, size_t &NewCapacity) {\n    return static_cast<T *>(\n        SmallVectorBase<SmallVectorSizeType<T>>::mallocForGrow(\n            MinSize, sizeof(T), NewCapacity));\n  }\n\n  /// Move existing elements over to the new allocation \\p NewElts, the middle\n  /// section of \\a grow().\n  void moveElementsForGrow(T *NewElts);\n\n  /// Transfer ownership of the allocation, finishing up \\a grow().\n  void takeAllocationForGrow(T *NewElts, size_t NewCapacity);\n\n  /// Reserve enough space to add one element, and return the updated element\n  /// pointer in case it was a reference to the storage.\n  const T *reserveForParamAndGetAddress(const T &Elt, size_t N = 1) {\n    return this->reserveForParamAndGetAddressImpl(this, Elt, N);\n  }\n\n  /// Reserve enough space to add one element, and return the updated element\n  /// pointer in case it was a reference to the storage.\n  T *reserveForParamAndGetAddress(T &Elt, size_t N = 1) {\n    return const_cast<T *>(\n        this->reserveForParamAndGetAddressImpl(this, Elt, N));\n  }\n\n  static T &&forward_value_param(T &&V) { return std::move(V); }\n  static const T &forward_value_param(const T &V) { return V; }\n\n  void growAndAssign(size_t NumElts, const T &Elt) {\n    // Grow manually in case Elt is an internal reference.\n    size_t NewCapacity;\n    T *NewElts = mallocForGrow(NumElts, NewCapacity);\n    std::uninitialized_fill_n(NewElts, NumElts, Elt);\n    this->destroy_range(this->begin(), this->end());\n    takeAllocationForGrow(NewElts, NewCapacity);\n    this->set_size(NumElts);\n  }\n\n  template <typename... ArgTypes> T &growAndEmplaceBack(ArgTypes &&... Args) {\n    // Grow manually in case one of Args is an internal reference.\n    size_t NewCapacity;\n    T *NewElts = mallocForGrow(0, NewCapacity);\n    ::new ((void *)(NewElts + this->size())) T(std::forward<ArgTypes>(Args)...);\n    moveElementsForGrow(NewElts);\n    takeAllocationForGrow(NewElts, NewCapacity);\n    this->set_size(this->size() + 1);\n    return this->back();\n  }\n\npublic:\n  void push_back(const T &Elt) {\n    const T *EltPtr = reserveForParamAndGetAddress(Elt);\n    ::new ((void *)this->end()) T(*EltPtr);\n    this->set_size(this->size() + 1);\n  }\n\n  void push_back(T &&Elt) {\n    T *EltPtr = reserveForParamAndGetAddress(Elt);\n    ::new ((void *)this->end()) T(::std::move(*EltPtr));\n    this->set_size(this->size() + 1);\n  }\n\n  void pop_back() {\n    this->set_size(this->size() - 1);\n    this->end()->~T();\n  }\n};\n\n// Define this out-of-line to dissuade the C++ compiler from inlining it.\ntemplate <typename T, bool TriviallyCopyable>\nvoid SmallVectorTemplateBase<T, TriviallyCopyable>::grow(size_t MinSize) {\n  size_t NewCapacity;\n  T *NewElts = mallocForGrow(MinSize, NewCapacity);\n  moveElementsForGrow(NewElts);\n  takeAllocationForGrow(NewElts, NewCapacity);\n}\n\n// Define this out-of-line to dissuade the C++ compiler from inlining it.\ntemplate <typename T, bool TriviallyCopyable>\nvoid SmallVectorTemplateBase<T, TriviallyCopyable>::moveElementsForGrow(\n    T *NewElts) {\n  // Move the elements over.\n  this->uninitialized_move(this->begin(), this->end(), NewElts);\n\n  // Destroy the original elements.\n  destroy_range(this->begin(), this->end());\n}\n\n// Define this out-of-line to dissuade the C++ compiler from inlining it.\ntemplate <typename T, bool TriviallyCopyable>\nvoid SmallVectorTemplateBase<T, TriviallyCopyable>::takeAllocationForGrow(\n    T *NewElts, size_t NewCapacity) {\n  // If this wasn't grown from the inline copy, deallocate the old space.\n  if (!this->isSmall())\n    free(this->begin());\n\n  this->BeginX = NewElts;\n  this->Capacity = NewCapacity;\n}\n\n/// SmallVectorTemplateBase<TriviallyCopyable = true> - This is where we put\n/// method implementations that are designed to work with trivially copyable\n/// T's. This allows using memcpy in place of copy/move construction and\n/// skipping destruction.\ntemplate <typename T>\nclass SmallVectorTemplateBase<T, true> : public SmallVectorTemplateCommon<T> {\n  friend class SmallVectorTemplateCommon<T>;\n\nprotected:\n  /// True if it's cheap enough to take parameters by value. Doing so avoids\n  /// overhead related to mitigations for reference invalidation.\n  static constexpr bool TakesParamByValue = sizeof(T) <= 2 * sizeof(void *);\n\n  /// Either const T& or T, depending on whether it's cheap enough to take\n  /// parameters by value.\n  using ValueParamT =\n      typename std::conditional<TakesParamByValue, T, const T &>::type;\n\n  SmallVectorTemplateBase(size_t Size) : SmallVectorTemplateCommon<T>(Size) {}\n\n  // No need to do a destroy loop for POD's.\n  static void destroy_range(T *, T *) {}\n\n  /// Move the range [I, E) onto the uninitialized memory\n  /// starting with \"Dest\", constructing elements into it as needed.\n  template<typename It1, typename It2>\n  static void uninitialized_move(It1 I, It1 E, It2 Dest) {\n    // Just do a copy.\n    uninitialized_copy(I, E, Dest);\n  }\n\n  /// Copy the range [I, E) onto the uninitialized memory\n  /// starting with \"Dest\", constructing elements into it as needed.\n  template<typename It1, typename It2>\n  static void uninitialized_copy(It1 I, It1 E, It2 Dest) {\n    // Arbitrary iterator types; just use the basic implementation.\n    std::uninitialized_copy(I, E, Dest);\n  }\n\n  /// Copy the range [I, E) onto the uninitialized memory\n  /// starting with \"Dest\", constructing elements into it as needed.\n  template <typename T1, typename T2>\n  static void uninitialized_copy(\n      T1 *I, T1 *E, T2 *Dest,\n      std::enable_if_t<std::is_same<typename std::remove_const<T1>::type,\n                                    T2>::value> * = nullptr) {\n    // Use memcpy for PODs iterated by pointers (which includes SmallVector\n    // iterators): std::uninitialized_copy optimizes to memmove, but we can\n    // use memcpy here. Note that I and E are iterators and thus might be\n    // invalid for memcpy if they are equal.\n    if (I != E)\n      memcpy(reinterpret_cast<void *>(Dest), I, (E - I) * sizeof(T));\n  }\n\n  /// Double the size of the allocated memory, guaranteeing space for at\n  /// least one more element or MinSize if specified.\n  void grow(size_t MinSize = 0) { this->grow_pod(MinSize, sizeof(T)); }\n\n  /// Reserve enough space to add one element, and return the updated element\n  /// pointer in case it was a reference to the storage.\n  const T *reserveForParamAndGetAddress(const T &Elt, size_t N = 1) {\n    return this->reserveForParamAndGetAddressImpl(this, Elt, N);\n  }\n\n  /// Reserve enough space to add one element, and return the updated element\n  /// pointer in case it was a reference to the storage.\n  T *reserveForParamAndGetAddress(T &Elt, size_t N = 1) {\n    return const_cast<T *>(\n        this->reserveForParamAndGetAddressImpl(this, Elt, N));\n  }\n\n  /// Copy \\p V or return a reference, depending on \\a ValueParamT.\n  static ValueParamT forward_value_param(ValueParamT V) { return V; }\n\n  void growAndAssign(size_t NumElts, T Elt) {\n    // Elt has been copied in case it's an internal reference, side-stepping\n    // reference invalidation problems without losing the realloc optimization.\n    this->set_size(0);\n    this->grow(NumElts);\n    std::uninitialized_fill_n(this->begin(), NumElts, Elt);\n    this->set_size(NumElts);\n  }\n\n  template <typename... ArgTypes> T &growAndEmplaceBack(ArgTypes &&... Args) {\n    // Use push_back with a copy in case Args has an internal reference,\n    // side-stepping reference invalidation problems without losing the realloc\n    // optimization.\n    push_back(T(std::forward<ArgTypes>(Args)...));\n    return this->back();\n  }\n\npublic:\n  void push_back(ValueParamT Elt) {\n    const T *EltPtr = reserveForParamAndGetAddress(Elt);\n    memcpy(reinterpret_cast<void *>(this->end()), EltPtr, sizeof(T));\n    this->set_size(this->size() + 1);\n  }\n\n  void pop_back() { this->set_size(this->size() - 1); }\n};\n\n/// This class consists of common code factored out of the SmallVector class to\n/// reduce code duplication based on the SmallVector 'N' template parameter.\ntemplate <typename T>\nclass SmallVectorImpl : public SmallVectorTemplateBase<T> {\n  using SuperClass = SmallVectorTemplateBase<T>;\n\npublic:\n  using iterator = typename SuperClass::iterator;\n  using const_iterator = typename SuperClass::const_iterator;\n  using reference = typename SuperClass::reference;\n  using size_type = typename SuperClass::size_type;\n\nprotected:\n  using SmallVectorTemplateBase<T>::TakesParamByValue;\n  using ValueParamT = typename SuperClass::ValueParamT;\n\n  // Default ctor - Initialize to empty.\n  explicit SmallVectorImpl(unsigned N)\n      : SmallVectorTemplateBase<T>(N) {}\n\npublic:\n  SmallVectorImpl(const SmallVectorImpl &) = delete;\n\n  ~SmallVectorImpl() {\n    // Subclass has already destructed this vector's elements.\n    // If this wasn't grown from the inline copy, deallocate the old space.\n    if (!this->isSmall())\n      free(this->begin());\n  }\n\n  void clear() {\n    this->destroy_range(this->begin(), this->end());\n    this->Size = 0;\n  }\n\nprivate:\n  template <bool ForOverwrite> void resizeImpl(size_type N) {\n    if (N < this->size()) {\n      this->pop_back_n(this->size() - N);\n    } else if (N > this->size()) {\n      this->reserve(N);\n      for (auto I = this->end(), E = this->begin() + N; I != E; ++I)\n        if (ForOverwrite)\n          new (&*I) T;\n        else\n          new (&*I) T();\n      this->set_size(N);\n    }\n  }\n\npublic:\n  void resize(size_type N) { resizeImpl<false>(N); }\n\n  /// Like resize, but \\ref T is POD, the new values won't be initialized.\n  void resize_for_overwrite(size_type N) { resizeImpl<true>(N); }\n\n  void resize(size_type N, ValueParamT NV) {\n    if (N == this->size())\n      return;\n\n    if (N < this->size()) {\n      this->pop_back_n(this->size() - N);\n      return;\n    }\n\n    // N > this->size(). Defer to append.\n    this->append(N - this->size(), NV);\n  }\n\n  void reserve(size_type N) {\n    if (this->capacity() < N)\n      this->grow(N);\n  }\n\n  void pop_back_n(size_type NumItems) {\n    assert(this->size() >= NumItems);\n    this->destroy_range(this->end() - NumItems, this->end());\n    this->set_size(this->size() - NumItems);\n  }\n\n  LLVM_NODISCARD T pop_back_val() {\n    T Result = ::std::move(this->back());\n    this->pop_back();\n    return Result;\n  }\n\n  void swap(SmallVectorImpl &RHS);\n\n  /// Add the specified range to the end of the SmallVector.\n  template <typename in_iter,\n            typename = std::enable_if_t<std::is_convertible<\n                typename std::iterator_traits<in_iter>::iterator_category,\n                std::input_iterator_tag>::value>>\n  void append(in_iter in_start, in_iter in_end) {\n    this->assertSafeToAddRange(in_start, in_end);\n    size_type NumInputs = std::distance(in_start, in_end);\n    this->reserve(this->size() + NumInputs);\n    this->uninitialized_copy(in_start, in_end, this->end());\n    this->set_size(this->size() + NumInputs);\n  }\n\n  /// Append \\p NumInputs copies of \\p Elt to the end.\n  void append(size_type NumInputs, ValueParamT Elt) {\n    const T *EltPtr = this->reserveForParamAndGetAddress(Elt, NumInputs);\n    std::uninitialized_fill_n(this->end(), NumInputs, *EltPtr);\n    this->set_size(this->size() + NumInputs);\n  }\n\n  void append(std::initializer_list<T> IL) {\n    append(IL.begin(), IL.end());\n  }\n\n  void append(const SmallVectorImpl &RHS) { append(RHS.begin(), RHS.end()); }\n\n  void assign(size_type NumElts, ValueParamT Elt) {\n    // Note that Elt could be an internal reference.\n    if (NumElts > this->capacity()) {\n      this->growAndAssign(NumElts, Elt);\n      return;\n    }\n\n    // Assign over existing elements.\n    std::fill_n(this->begin(), std::min(NumElts, this->size()), Elt);\n    if (NumElts > this->size())\n      std::uninitialized_fill_n(this->end(), NumElts - this->size(), Elt);\n    else if (NumElts < this->size())\n      this->destroy_range(this->begin() + NumElts, this->end());\n    this->set_size(NumElts);\n  }\n\n  // FIXME: Consider assigning over existing elements, rather than clearing &\n  // re-initializing them - for all assign(...) variants.\n\n  template <typename in_iter,\n            typename = std::enable_if_t<std::is_convertible<\n                typename std::iterator_traits<in_iter>::iterator_category,\n                std::input_iterator_tag>::value>>\n  void assign(in_iter in_start, in_iter in_end) {\n    this->assertSafeToReferenceAfterClear(in_start, in_end);\n    clear();\n    append(in_start, in_end);\n  }\n\n  void assign(std::initializer_list<T> IL) {\n    clear();\n    append(IL);\n  }\n\n  void assign(const SmallVectorImpl &RHS) { assign(RHS.begin(), RHS.end()); }\n\n  iterator erase(const_iterator CI) {\n    // Just cast away constness because this is a non-const member function.\n    iterator I = const_cast<iterator>(CI);\n\n    assert(this->isReferenceToStorage(CI) && \"Iterator to erase is out of bounds.\");\n\n    iterator N = I;\n    // Shift all elts down one.\n    std::move(I+1, this->end(), I);\n    // Drop the last elt.\n    this->pop_back();\n    return(N);\n  }\n\n  iterator erase(const_iterator CS, const_iterator CE) {\n    // Just cast away constness because this is a non-const member function.\n    iterator S = const_cast<iterator>(CS);\n    iterator E = const_cast<iterator>(CE);\n\n    assert(this->isRangeInStorage(S, E) && \"Range to erase is out of bounds.\");\n\n    iterator N = S;\n    // Shift all elts down.\n    iterator I = std::move(E, this->end(), S);\n    // Drop the last elts.\n    this->destroy_range(I, this->end());\n    this->set_size(I - this->begin());\n    return(N);\n  }\n\nprivate:\n  template <class ArgType> iterator insert_one_impl(iterator I, ArgType &&Elt) {\n    // Callers ensure that ArgType is derived from T.\n    static_assert(\n        std::is_same<std::remove_const_t<std::remove_reference_t<ArgType>>,\n                     T>::value,\n        \"ArgType must be derived from T!\");\n\n    if (I == this->end()) {  // Important special case for empty vector.\n      this->push_back(::std::forward<ArgType>(Elt));\n      return this->end()-1;\n    }\n\n    assert(this->isReferenceToStorage(I) && \"Insertion iterator is out of bounds.\");\n\n    // Grow if necessary.\n    size_t Index = I - this->begin();\n    std::remove_reference_t<ArgType> *EltPtr =\n        this->reserveForParamAndGetAddress(Elt);\n    I = this->begin() + Index;\n\n    ::new ((void*) this->end()) T(::std::move(this->back()));\n    // Push everything else over.\n    std::move_backward(I, this->end()-1, this->end());\n    this->set_size(this->size() + 1);\n\n    // If we just moved the element we're inserting, be sure to update\n    // the reference (never happens if TakesParamByValue).\n    static_assert(!TakesParamByValue || std::is_same<ArgType, T>::value,\n                  \"ArgType must be 'T' when taking by value!\");\n    if (!TakesParamByValue && this->isReferenceToRange(EltPtr, I, this->end()))\n      ++EltPtr;\n\n    *I = ::std::forward<ArgType>(*EltPtr);\n    return I;\n  }\n\npublic:\n  iterator insert(iterator I, T &&Elt) {\n    return insert_one_impl(I, this->forward_value_param(std::move(Elt)));\n  }\n\n  iterator insert(iterator I, const T &Elt) {\n    return insert_one_impl(I, this->forward_value_param(Elt));\n  }\n\n  iterator insert(iterator I, size_type NumToInsert, ValueParamT Elt) {\n    // Convert iterator to elt# to avoid invalidating iterator when we reserve()\n    size_t InsertElt = I - this->begin();\n\n    if (I == this->end()) {  // Important special case for empty vector.\n      append(NumToInsert, Elt);\n      return this->begin()+InsertElt;\n    }\n\n    assert(this->isReferenceToStorage(I) && \"Insertion iterator is out of bounds.\");\n\n    // Ensure there is enough space, and get the (maybe updated) address of\n    // Elt.\n    const T *EltPtr = this->reserveForParamAndGetAddress(Elt, NumToInsert);\n\n    // Uninvalidate the iterator.\n    I = this->begin()+InsertElt;\n\n    // If there are more elements between the insertion point and the end of the\n    // range than there are being inserted, we can use a simple approach to\n    // insertion.  Since we already reserved space, we know that this won't\n    // reallocate the vector.\n    if (size_t(this->end()-I) >= NumToInsert) {\n      T *OldEnd = this->end();\n      append(std::move_iterator<iterator>(this->end() - NumToInsert),\n             std::move_iterator<iterator>(this->end()));\n\n      // Copy the existing elements that get replaced.\n      std::move_backward(I, OldEnd-NumToInsert, OldEnd);\n\n      // If we just moved the element we're inserting, be sure to update\n      // the reference (never happens if TakesParamByValue).\n      if (!TakesParamByValue && I <= EltPtr && EltPtr < this->end())\n        EltPtr += NumToInsert;\n\n      std::fill_n(I, NumToInsert, *EltPtr);\n      return I;\n    }\n\n    // Otherwise, we're inserting more elements than exist already, and we're\n    // not inserting at the end.\n\n    // Move over the elements that we're about to overwrite.\n    T *OldEnd = this->end();\n    this->set_size(this->size() + NumToInsert);\n    size_t NumOverwritten = OldEnd-I;\n    this->uninitialized_move(I, OldEnd, this->end()-NumOverwritten);\n\n    // If we just moved the element we're inserting, be sure to update\n    // the reference (never happens if TakesParamByValue).\n    if (!TakesParamByValue && I <= EltPtr && EltPtr < this->end())\n      EltPtr += NumToInsert;\n\n    // Replace the overwritten part.\n    std::fill_n(I, NumOverwritten, *EltPtr);\n\n    // Insert the non-overwritten middle part.\n    std::uninitialized_fill_n(OldEnd, NumToInsert - NumOverwritten, *EltPtr);\n    return I;\n  }\n\n  template <typename ItTy,\n            typename = std::enable_if_t<std::is_convertible<\n                typename std::iterator_traits<ItTy>::iterator_category,\n                std::input_iterator_tag>::value>>\n  iterator insert(iterator I, ItTy From, ItTy To) {\n    // Convert iterator to elt# to avoid invalidating iterator when we reserve()\n    size_t InsertElt = I - this->begin();\n\n    if (I == this->end()) {  // Important special case for empty vector.\n      append(From, To);\n      return this->begin()+InsertElt;\n    }\n\n    assert(this->isReferenceToStorage(I) && \"Insertion iterator is out of bounds.\");\n\n    // Check that the reserve that follows doesn't invalidate the iterators.\n    this->assertSafeToAddRange(From, To);\n\n    size_t NumToInsert = std::distance(From, To);\n\n    // Ensure there is enough space.\n    reserve(this->size() + NumToInsert);\n\n    // Uninvalidate the iterator.\n    I = this->begin()+InsertElt;\n\n    // If there are more elements between the insertion point and the end of the\n    // range than there are being inserted, we can use a simple approach to\n    // insertion.  Since we already reserved space, we know that this won't\n    // reallocate the vector.\n    if (size_t(this->end()-I) >= NumToInsert) {\n      T *OldEnd = this->end();\n      append(std::move_iterator<iterator>(this->end() - NumToInsert),\n             std::move_iterator<iterator>(this->end()));\n\n      // Copy the existing elements that get replaced.\n      std::move_backward(I, OldEnd-NumToInsert, OldEnd);\n\n      std::copy(From, To, I);\n      return I;\n    }\n\n    // Otherwise, we're inserting more elements than exist already, and we're\n    // not inserting at the end.\n\n    // Move over the elements that we're about to overwrite.\n    T *OldEnd = this->end();\n    this->set_size(this->size() + NumToInsert);\n    size_t NumOverwritten = OldEnd-I;\n    this->uninitialized_move(I, OldEnd, this->end()-NumOverwritten);\n\n    // Replace the overwritten part.\n    for (T *J = I; NumOverwritten > 0; --NumOverwritten) {\n      *J = *From;\n      ++J; ++From;\n    }\n\n    // Insert the non-overwritten middle part.\n    this->uninitialized_copy(From, To, OldEnd);\n    return I;\n  }\n\n  void insert(iterator I, std::initializer_list<T> IL) {\n    insert(I, IL.begin(), IL.end());\n  }\n\n  template <typename... ArgTypes> reference emplace_back(ArgTypes &&... Args) {\n    if (LLVM_UNLIKELY(this->size() >= this->capacity()))\n      return this->growAndEmplaceBack(std::forward<ArgTypes>(Args)...);\n\n    ::new ((void *)this->end()) T(std::forward<ArgTypes>(Args)...);\n    this->set_size(this->size() + 1);\n    return this->back();\n  }\n\n  SmallVectorImpl &operator=(const SmallVectorImpl &RHS);\n\n  SmallVectorImpl &operator=(SmallVectorImpl &&RHS);\n\n  bool operator==(const SmallVectorImpl &RHS) const {\n    if (this->size() != RHS.size()) return false;\n    return std::equal(this->begin(), this->end(), RHS.begin());\n  }\n  bool operator!=(const SmallVectorImpl &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool operator<(const SmallVectorImpl &RHS) const {\n    return std::lexicographical_compare(this->begin(), this->end(),\n                                        RHS.begin(), RHS.end());\n  }\n};\n\ntemplate <typename T>\nvoid SmallVectorImpl<T>::swap(SmallVectorImpl<T> &RHS) {\n  if (this == &RHS) return;\n\n  // We can only avoid copying elements if neither vector is small.\n  if (!this->isSmall() && !RHS.isSmall()) {\n    std::swap(this->BeginX, RHS.BeginX);\n    std::swap(this->Size, RHS.Size);\n    std::swap(this->Capacity, RHS.Capacity);\n    return;\n  }\n  this->reserve(RHS.size());\n  RHS.reserve(this->size());\n\n  // Swap the shared elements.\n  size_t NumShared = this->size();\n  if (NumShared > RHS.size()) NumShared = RHS.size();\n  for (size_type i = 0; i != NumShared; ++i)\n    std::swap((*this)[i], RHS[i]);\n\n  // Copy over the extra elts.\n  if (this->size() > RHS.size()) {\n    size_t EltDiff = this->size() - RHS.size();\n    this->uninitialized_copy(this->begin()+NumShared, this->end(), RHS.end());\n    RHS.set_size(RHS.size() + EltDiff);\n    this->destroy_range(this->begin()+NumShared, this->end());\n    this->set_size(NumShared);\n  } else if (RHS.size() > this->size()) {\n    size_t EltDiff = RHS.size() - this->size();\n    this->uninitialized_copy(RHS.begin()+NumShared, RHS.end(), this->end());\n    this->set_size(this->size() + EltDiff);\n    this->destroy_range(RHS.begin()+NumShared, RHS.end());\n    RHS.set_size(NumShared);\n  }\n}\n\ntemplate <typename T>\nSmallVectorImpl<T> &SmallVectorImpl<T>::\n  operator=(const SmallVectorImpl<T> &RHS) {\n  // Avoid self-assignment.\n  if (this == &RHS) return *this;\n\n  // If we already have sufficient space, assign the common elements, then\n  // destroy any excess.\n  size_t RHSSize = RHS.size();\n  size_t CurSize = this->size();\n  if (CurSize >= RHSSize) {\n    // Assign common elements.\n    iterator NewEnd;\n    if (RHSSize)\n      NewEnd = std::copy(RHS.begin(), RHS.begin()+RHSSize, this->begin());\n    else\n      NewEnd = this->begin();\n\n    // Destroy excess elements.\n    this->destroy_range(NewEnd, this->end());\n\n    // Trim.\n    this->set_size(RHSSize);\n    return *this;\n  }\n\n  // If we have to grow to have enough elements, destroy the current elements.\n  // This allows us to avoid copying them during the grow.\n  // FIXME: don't do this if they're efficiently moveable.\n  if (this->capacity() < RHSSize) {\n    // Destroy current elements.\n    this->clear();\n    CurSize = 0;\n    this->grow(RHSSize);\n  } else if (CurSize) {\n    // Otherwise, use assignment for the already-constructed elements.\n    std::copy(RHS.begin(), RHS.begin()+CurSize, this->begin());\n  }\n\n  // Copy construct the new elements in place.\n  this->uninitialized_copy(RHS.begin()+CurSize, RHS.end(),\n                           this->begin()+CurSize);\n\n  // Set end.\n  this->set_size(RHSSize);\n  return *this;\n}\n\ntemplate <typename T>\nSmallVectorImpl<T> &SmallVectorImpl<T>::operator=(SmallVectorImpl<T> &&RHS) {\n  // Avoid self-assignment.\n  if (this == &RHS) return *this;\n\n  // If the RHS isn't small, clear this vector and then steal its buffer.\n  if (!RHS.isSmall()) {\n    this->destroy_range(this->begin(), this->end());\n    if (!this->isSmall()) free(this->begin());\n    this->BeginX = RHS.BeginX;\n    this->Size = RHS.Size;\n    this->Capacity = RHS.Capacity;\n    RHS.resetToSmall();\n    return *this;\n  }\n\n  // If we already have sufficient space, assign the common elements, then\n  // destroy any excess.\n  size_t RHSSize = RHS.size();\n  size_t CurSize = this->size();\n  if (CurSize >= RHSSize) {\n    // Assign common elements.\n    iterator NewEnd = this->begin();\n    if (RHSSize)\n      NewEnd = std::move(RHS.begin(), RHS.end(), NewEnd);\n\n    // Destroy excess elements and trim the bounds.\n    this->destroy_range(NewEnd, this->end());\n    this->set_size(RHSSize);\n\n    // Clear the RHS.\n    RHS.clear();\n\n    return *this;\n  }\n\n  // If we have to grow to have enough elements, destroy the current elements.\n  // This allows us to avoid copying them during the grow.\n  // FIXME: this may not actually make any sense if we can efficiently move\n  // elements.\n  if (this->capacity() < RHSSize) {\n    // Destroy current elements.\n    this->clear();\n    CurSize = 0;\n    this->grow(RHSSize);\n  } else if (CurSize) {\n    // Otherwise, use assignment for the already-constructed elements.\n    std::move(RHS.begin(), RHS.begin()+CurSize, this->begin());\n  }\n\n  // Move-construct the new elements in place.\n  this->uninitialized_move(RHS.begin()+CurSize, RHS.end(),\n                           this->begin()+CurSize);\n\n  // Set end.\n  this->set_size(RHSSize);\n\n  RHS.clear();\n  return *this;\n}\n\n/// Storage for the SmallVector elements.  This is specialized for the N=0 case\n/// to avoid allocating unnecessary storage.\ntemplate <typename T, unsigned N>\nstruct SmallVectorStorage {\n  alignas(T) char InlineElts[N * sizeof(T)];\n};\n\n/// We need the storage to be properly aligned even for small-size of 0 so that\n/// the pointer math in \\a SmallVectorTemplateCommon::getFirstEl() is\n/// well-defined.\ntemplate <typename T> struct alignas(T) SmallVectorStorage<T, 0> {};\n\n/// Forward declaration of SmallVector so that\n/// calculateSmallVectorDefaultInlinedElements can reference\n/// `sizeof(SmallVector<T, 0>)`.\ntemplate <typename T, unsigned N> class LLVM_GSL_OWNER SmallVector;\n\n/// Helper class for calculating the default number of inline elements for\n/// `SmallVector<T>`.\n///\n/// This should be migrated to a constexpr function when our minimum\n/// compiler support is enough for multi-statement constexpr functions.\ntemplate <typename T> struct CalculateSmallVectorDefaultInlinedElements {\n  // Parameter controlling the default number of inlined elements\n  // for `SmallVector<T>`.\n  //\n  // The default number of inlined elements ensures that\n  // 1. There is at least one inlined element.\n  // 2. `sizeof(SmallVector<T>) <= kPreferredSmallVectorSizeof` unless\n  // it contradicts 1.\n  static constexpr size_t kPreferredSmallVectorSizeof = 64;\n\n  // static_assert that sizeof(T) is not \"too big\".\n  //\n  // Because our policy guarantees at least one inlined element, it is possible\n  // for an arbitrarily large inlined element to allocate an arbitrarily large\n  // amount of inline storage. We generally consider it an antipattern for a\n  // SmallVector to allocate an excessive amount of inline storage, so we want\n  // to call attention to these cases and make sure that users are making an\n  // intentional decision if they request a lot of inline storage.\n  //\n  // We want this assertion to trigger in pathological cases, but otherwise\n  // not be too easy to hit. To accomplish that, the cutoff is actually somewhat\n  // larger than kPreferredSmallVectorSizeof (otherwise,\n  // `SmallVector<SmallVector<T>>` would be one easy way to trip it, and that\n  // pattern seems useful in practice).\n  //\n  // One wrinkle is that this assertion is in theory non-portable, since\n  // sizeof(T) is in general platform-dependent. However, we don't expect this\n  // to be much of an issue, because most LLVM development happens on 64-bit\n  // hosts, and therefore sizeof(T) is expected to *decrease* when compiled for\n  // 32-bit hosts, dodging the issue. The reverse situation, where development\n  // happens on a 32-bit host and then fails due to sizeof(T) *increasing* on a\n  // 64-bit host, is expected to be very rare.\n  static_assert(\n      sizeof(T) <= 256,\n      \"You are trying to use a default number of inlined elements for \"\n      \"`SmallVector<T>` but `sizeof(T)` is really big! Please use an \"\n      \"explicit number of inlined elements with `SmallVector<T, N>` to make \"\n      \"sure you really want that much inline storage.\");\n\n  // Discount the size of the header itself when calculating the maximum inline\n  // bytes.\n  static constexpr size_t PreferredInlineBytes =\n      kPreferredSmallVectorSizeof - sizeof(SmallVector<T, 0>);\n  static constexpr size_t NumElementsThatFit = PreferredInlineBytes / sizeof(T);\n  static constexpr size_t value =\n      NumElementsThatFit == 0 ? 1 : NumElementsThatFit;\n};\n\n/// This is a 'vector' (really, a variable-sized array), optimized\n/// for the case when the array is small.  It contains some number of elements\n/// in-place, which allows it to avoid heap allocation when the actual number of\n/// elements is below that threshold.  This allows normal \"small\" cases to be\n/// fast without losing generality for large inputs.\n///\n/// \\note\n/// In the absence of a well-motivated choice for the number of inlined\n/// elements \\p N, it is recommended to use \\c SmallVector<T> (that is,\n/// omitting the \\p N). This will choose a default number of inlined elements\n/// reasonable for allocation on the stack (for example, trying to keep \\c\n/// sizeof(SmallVector<T>) around 64 bytes).\n///\n/// \\warning This does not attempt to be exception safe.\n///\n/// \\see https://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h\ntemplate <typename T,\n          unsigned N = CalculateSmallVectorDefaultInlinedElements<T>::value>\nclass LLVM_GSL_OWNER SmallVector : public SmallVectorImpl<T>,\n                                   SmallVectorStorage<T, N> {\npublic:\n  SmallVector() : SmallVectorImpl<T>(N) {}\n\n  ~SmallVector() {\n    // Destroy the constructed elements in the vector.\n    this->destroy_range(this->begin(), this->end());\n  }\n\n  explicit SmallVector(size_t Size, const T &Value = T())\n    : SmallVectorImpl<T>(N) {\n    this->assign(Size, Value);\n  }\n\n  template <typename ItTy,\n            typename = std::enable_if_t<std::is_convertible<\n                typename std::iterator_traits<ItTy>::iterator_category,\n                std::input_iterator_tag>::value>>\n  SmallVector(ItTy S, ItTy E) : SmallVectorImpl<T>(N) {\n    this->append(S, E);\n  }\n\n  template <typename RangeTy>\n  explicit SmallVector(const iterator_range<RangeTy> &R)\n      : SmallVectorImpl<T>(N) {\n    this->append(R.begin(), R.end());\n  }\n\n  SmallVector(std::initializer_list<T> IL) : SmallVectorImpl<T>(N) {\n    this->assign(IL);\n  }\n\n  SmallVector(const SmallVector &RHS) : SmallVectorImpl<T>(N) {\n    if (!RHS.empty())\n      SmallVectorImpl<T>::operator=(RHS);\n  }\n\n  SmallVector &operator=(const SmallVector &RHS) {\n    SmallVectorImpl<T>::operator=(RHS);\n    return *this;\n  }\n\n  SmallVector(SmallVector &&RHS) : SmallVectorImpl<T>(N) {\n    if (!RHS.empty())\n      SmallVectorImpl<T>::operator=(::std::move(RHS));\n  }\n\n  SmallVector(SmallVectorImpl<T> &&RHS) : SmallVectorImpl<T>(N) {\n    if (!RHS.empty())\n      SmallVectorImpl<T>::operator=(::std::move(RHS));\n  }\n\n  SmallVector &operator=(SmallVector &&RHS) {\n    SmallVectorImpl<T>::operator=(::std::move(RHS));\n    return *this;\n  }\n\n  SmallVector &operator=(SmallVectorImpl<T> &&RHS) {\n    SmallVectorImpl<T>::operator=(::std::move(RHS));\n    return *this;\n  }\n\n  SmallVector &operator=(std::initializer_list<T> IL) {\n    this->assign(IL);\n    return *this;\n  }\n};\n\ntemplate <typename T, unsigned N>\ninline size_t capacity_in_bytes(const SmallVector<T, N> &X) {\n  return X.capacity_in_bytes();\n}\n\n/// Given a range of type R, iterate the entire range and return a\n/// SmallVector with elements of the vector.  This is useful, for example,\n/// when you want to iterate a range and then sort the results.\ntemplate <unsigned Size, typename R>\nSmallVector<typename std::remove_const<typename std::remove_reference<\n                decltype(*std::begin(std::declval<R &>()))>::type>::type,\n            Size>\nto_vector(R &&Range) {\n  return {std::begin(Range), std::end(Range)};\n}\n\n} // end namespace llvm\n\nnamespace std {\n\n  /// Implement std::swap in terms of SmallVector swap.\n  template<typename T>\n  inline void\n  swap(llvm::SmallVectorImpl<T> &LHS, llvm::SmallVectorImpl<T> &RHS) {\n    LHS.swap(RHS);\n  }\n\n  /// Implement std::swap in terms of SmallVector swap.\n  template<typename T, unsigned N>\n  inline void\n  swap(llvm::SmallVector<T, N> &LHS, llvm::SmallVector<T, N> &RHS) {\n    LHS.swap(RHS);\n  }\n\n} // end namespace std\n\n#endif // LLVM_ADT_SMALLVECTOR_H\n"}, "10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "content": "//===- StringMap.h - String Hash table map interface ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the StringMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_STRINGMAP_H\n#define LLVM_ADT_STRINGMAP_H\n\n#include \"llvm/ADT/StringMapEntry.h\"\n#include \"llvm/Support/AllocatorBase.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <initializer_list>\n#include <iterator>\n\nnamespace llvm {\n\ntemplate <typename ValueTy> class StringMapConstIterator;\ntemplate <typename ValueTy> class StringMapIterator;\ntemplate <typename ValueTy> class StringMapKeyIterator;\n\n/// StringMapImpl - This is the base class of StringMap that is shared among\n/// all of its instantiations.\nclass StringMapImpl {\nprotected:\n  // Array of NumBuckets pointers to entries, null pointers are holes.\n  // TheTable[NumBuckets] contains a sentinel value for easy iteration. Followed\n  // by an array of the actual hash values as unsigned integers.\n  StringMapEntryBase **TheTable = nullptr;\n  unsigned NumBuckets = 0;\n  unsigned NumItems = 0;\n  unsigned NumTombstones = 0;\n  unsigned ItemSize;\n\nprotected:\n  explicit StringMapImpl(unsigned itemSize) : ItemSize(itemSize) {}\n  StringMapImpl(StringMapImpl &&RHS)\n      : TheTable(RHS.TheTable), NumBuckets(RHS.NumBuckets),\n        NumItems(RHS.NumItems), NumTombstones(RHS.NumTombstones),\n        ItemSize(RHS.ItemSize) {\n    RHS.TheTable = nullptr;\n    RHS.NumBuckets = 0;\n    RHS.NumItems = 0;\n    RHS.NumTombstones = 0;\n  }\n\n  StringMapImpl(unsigned InitSize, unsigned ItemSize);\n  unsigned RehashTable(unsigned BucketNo = 0);\n\n  /// LookupBucketFor - Look up the bucket that the specified string should end\n  /// up in.  If it already exists as a key in the map, the Item pointer for the\n  /// specified bucket will be non-null.  Otherwise, it will be null.  In either\n  /// case, the FullHashValue field of the bucket will be set to the hash value\n  /// of the string.\n  unsigned LookupBucketFor(StringRef Key);\n\n  /// FindKey - Look up the bucket that contains the specified key. If it exists\n  /// in the map, return the bucket number of the key.  Otherwise return -1.\n  /// This does not modify the map.\n  int FindKey(StringRef Key) const;\n\n  /// RemoveKey - Remove the specified StringMapEntry from the table, but do not\n  /// delete it.  This aborts if the value isn't in the table.\n  void RemoveKey(StringMapEntryBase *V);\n\n  /// RemoveKey - Remove the StringMapEntry for the specified key from the\n  /// table, returning it.  If the key is not in the table, this returns null.\n  StringMapEntryBase *RemoveKey(StringRef Key);\n\n  /// Allocate the table with the specified number of buckets and otherwise\n  /// setup the map as empty.\n  void init(unsigned Size);\n\npublic:\n  static constexpr uintptr_t TombstoneIntVal =\n      static_cast<uintptr_t>(-1)\n      << PointerLikeTypeTraits<StringMapEntryBase *>::NumLowBitsAvailable;\n\n  static StringMapEntryBase *getTombstoneVal() {\n    return reinterpret_cast<StringMapEntryBase *>(TombstoneIntVal);\n  }\n\n  unsigned getNumBuckets() const { return NumBuckets; }\n  unsigned getNumItems() const { return NumItems; }\n\n  bool empty() const { return NumItems == 0; }\n  unsigned size() const { return NumItems; }\n\n  void swap(StringMapImpl &Other) {\n    std::swap(TheTable, Other.TheTable);\n    std::swap(NumBuckets, Other.NumBuckets);\n    std::swap(NumItems, Other.NumItems);\n    std::swap(NumTombstones, Other.NumTombstones);\n  }\n};\n\n/// StringMap - This is an unconventional map that is specialized for handling\n/// keys that are \"strings\", which are basically ranges of bytes. This does some\n/// funky memory allocation and hashing things to make it extremely efficient,\n/// storing the string data *after* the value in the map.\ntemplate <typename ValueTy, typename AllocatorTy = MallocAllocator>\nclass StringMap : public StringMapImpl {\n  AllocatorTy Allocator;\n\npublic:\n  using MapEntryTy = StringMapEntry<ValueTy>;\n\n  StringMap() : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))) {}\n\n  explicit StringMap(unsigned InitialSize)\n      : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))) {}\n\n  explicit StringMap(AllocatorTy A)\n      : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))), Allocator(A) {\n  }\n\n  StringMap(unsigned InitialSize, AllocatorTy A)\n      : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))),\n        Allocator(A) {}\n\n  StringMap(std::initializer_list<std::pair<StringRef, ValueTy>> List)\n      : StringMapImpl(List.size(), static_cast<unsigned>(sizeof(MapEntryTy))) {\n    for (const auto &P : List) {\n      insert(P);\n    }\n  }\n\n  StringMap(StringMap &&RHS)\n      : StringMapImpl(std::move(RHS)), Allocator(std::move(RHS.Allocator)) {}\n\n  StringMap(const StringMap &RHS)\n      : StringMapImpl(static_cast<unsigned>(sizeof(MapEntryTy))),\n        Allocator(RHS.Allocator) {\n    if (RHS.empty())\n      return;\n\n    // Allocate TheTable of the same size as RHS's TheTable, and set the\n    // sentinel appropriately (and NumBuckets).\n    init(RHS.NumBuckets);\n    unsigned *HashTable = (unsigned *)(TheTable + NumBuckets + 1),\n             *RHSHashTable = (unsigned *)(RHS.TheTable + NumBuckets + 1);\n\n    NumItems = RHS.NumItems;\n    NumTombstones = RHS.NumTombstones;\n    for (unsigned I = 0, E = NumBuckets; I != E; ++I) {\n      StringMapEntryBase *Bucket = RHS.TheTable[I];\n      if (!Bucket || Bucket == getTombstoneVal()) {\n        TheTable[I] = Bucket;\n        continue;\n      }\n\n      TheTable[I] = MapEntryTy::Create(\n          static_cast<MapEntryTy *>(Bucket)->getKey(), Allocator,\n          static_cast<MapEntryTy *>(Bucket)->getValue());\n      HashTable[I] = RHSHashTable[I];\n    }\n\n    // Note that here we've copied everything from the RHS into this object,\n    // tombstones included. We could, instead, have re-probed for each key to\n    // instantiate this new object without any tombstone buckets. The\n    // assumption here is that items are rarely deleted from most StringMaps,\n    // and so tombstones are rare, so the cost of re-probing for all inputs is\n    // not worthwhile.\n  }\n\n  StringMap &operator=(StringMap RHS) {\n    StringMapImpl::swap(RHS);\n    std::swap(Allocator, RHS.Allocator);\n    return *this;\n  }\n\n  ~StringMap() {\n    // Delete all the elements in the map, but don't reset the elements\n    // to default values.  This is a copy of clear(), but avoids unnecessary\n    // work not required in the destructor.\n    if (!empty()) {\n      for (unsigned I = 0, E = NumBuckets; I != E; ++I) {\n        StringMapEntryBase *Bucket = TheTable[I];\n        if (Bucket && Bucket != getTombstoneVal()) {\n          static_cast<MapEntryTy *>(Bucket)->Destroy(Allocator);\n        }\n      }\n    }\n    free(TheTable);\n  }\n\n  AllocatorTy &getAllocator() { return Allocator; }\n  const AllocatorTy &getAllocator() const { return Allocator; }\n\n  using key_type = const char *;\n  using mapped_type = ValueTy;\n  using value_type = StringMapEntry<ValueTy>;\n  using size_type = size_t;\n\n  using const_iterator = StringMapConstIterator<ValueTy>;\n  using iterator = StringMapIterator<ValueTy>;\n\n  iterator begin() { return iterator(TheTable, NumBuckets == 0); }\n  iterator end() { return iterator(TheTable + NumBuckets, true); }\n  const_iterator begin() const {\n    return const_iterator(TheTable, NumBuckets == 0);\n  }\n  const_iterator end() const {\n    return const_iterator(TheTable + NumBuckets, true);\n  }\n\n  iterator_range<StringMapKeyIterator<ValueTy>> keys() const {\n    return make_range(StringMapKeyIterator<ValueTy>(begin()),\n                      StringMapKeyIterator<ValueTy>(end()));\n  }\n\n  iterator find(StringRef Key) {\n    int Bucket = FindKey(Key);\n    if (Bucket == -1)\n      return end();\n    return iterator(TheTable + Bucket, true);\n  }\n\n  const_iterator find(StringRef Key) const {\n    int Bucket = FindKey(Key);\n    if (Bucket == -1)\n      return end();\n    return const_iterator(TheTable + Bucket, true);\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueTy lookup(StringRef Key) const {\n    const_iterator it = find(Key);\n    if (it != end())\n      return it->second;\n    return ValueTy();\n  }\n\n  /// Lookup the ValueTy for the \\p Key, or create a default constructed value\n  /// if the key is not in the map.\n  ValueTy &operator[](StringRef Key) { return try_emplace(Key).first->second; }\n\n  /// count - Return 1 if the element is in the map, 0 otherwise.\n  size_type count(StringRef Key) const { return find(Key) == end() ? 0 : 1; }\n\n  template <typename InputTy>\n  size_type count(const StringMapEntry<InputTy> &MapEntry) const {\n    return count(MapEntry.getKey());\n  }\n\n  /// equal - check whether both of the containers are equal.\n  bool operator==(const StringMap &RHS) const {\n    if (size() != RHS.size())\n      return false;\n\n    for (const auto &KeyValue : *this) {\n      auto FindInRHS = RHS.find(KeyValue.getKey());\n\n      if (FindInRHS == RHS.end())\n        return false;\n\n      if (!(KeyValue.getValue() == FindInRHS->getValue()))\n        return false;\n    }\n\n    return true;\n  }\n\n  bool operator!=(const StringMap &RHS) const { return !(*this == RHS); }\n\n  /// insert - Insert the specified key/value pair into the map.  If the key\n  /// already exists in the map, return false and ignore the request, otherwise\n  /// insert it and return true.\n  bool insert(MapEntryTy *KeyValue) {\n    unsigned BucketNo = LookupBucketFor(KeyValue->getKey());\n    StringMapEntryBase *&Bucket = TheTable[BucketNo];\n    if (Bucket && Bucket != getTombstoneVal())\n      return false; // Already exists in map.\n\n    if (Bucket == getTombstoneVal())\n      --NumTombstones;\n    Bucket = KeyValue;\n    ++NumItems;\n    assert(NumItems + NumTombstones <= NumBuckets);\n\n    RehashTable();\n    return true;\n  }\n\n  /// insert - Inserts the specified key/value pair into the map if the key\n  /// isn't already in the map. The bool component of the returned pair is true\n  /// if and only if the insertion takes place, and the iterator component of\n  /// the pair points to the element with key equivalent to the key of the pair.\n  std::pair<iterator, bool> insert(std::pair<StringRef, ValueTy> KV) {\n    return try_emplace(KV.first, std::move(KV.second));\n  }\n\n  /// Inserts an element or assigns to the current element if the key already\n  /// exists. The return type is the same as try_emplace.\n  template <typename V>\n  std::pair<iterator, bool> insert_or_assign(StringRef Key, V &&Val) {\n    auto Ret = try_emplace(Key, std::forward<V>(Val));\n    if (!Ret.second)\n      Ret.first->second = std::forward<V>(Val);\n    return Ret;\n  }\n\n  /// Emplace a new element for the specified key into the map if the key isn't\n  /// already in the map. The bool component of the returned pair is true\n  /// if and only if the insertion takes place, and the iterator component of\n  /// the pair points to the element with key equivalent to the key of the pair.\n  template <typename... ArgsTy>\n  std::pair<iterator, bool> try_emplace(StringRef Key, ArgsTy &&... Args) {\n    unsigned BucketNo = LookupBucketFor(Key);\n    StringMapEntryBase *&Bucket = TheTable[BucketNo];\n    if (Bucket && Bucket != getTombstoneVal())\n      return std::make_pair(iterator(TheTable + BucketNo, false),\n                            false); // Already exists in map.\n\n    if (Bucket == getTombstoneVal())\n      --NumTombstones;\n    Bucket = MapEntryTy::Create(Key, Allocator, std::forward<ArgsTy>(Args)...);\n    ++NumItems;\n    assert(NumItems + NumTombstones <= NumBuckets);\n\n    BucketNo = RehashTable(BucketNo);\n    return std::make_pair(iterator(TheTable + BucketNo, false), true);\n  }\n\n  // clear - Empties out the StringMap\n  void clear() {\n    if (empty())\n      return;\n\n    // Zap all values, resetting the keys back to non-present (not tombstone),\n    // which is safe because we're removing all elements.\n    for (unsigned I = 0, E = NumBuckets; I != E; ++I) {\n      StringMapEntryBase *&Bucket = TheTable[I];\n      if (Bucket && Bucket != getTombstoneVal()) {\n        static_cast<MapEntryTy *>(Bucket)->Destroy(Allocator);\n      }\n      Bucket = nullptr;\n    }\n\n    NumItems = 0;\n    NumTombstones = 0;\n  }\n\n  /// remove - Remove the specified key/value pair from the map, but do not\n  /// erase it.  This aborts if the key is not in the map.\n  void remove(MapEntryTy *KeyValue) { RemoveKey(KeyValue); }\n\n  void erase(iterator I) {\n    MapEntryTy &V = *I;\n    remove(&V);\n    V.Destroy(Allocator);\n  }\n\n  bool erase(StringRef Key) {\n    iterator I = find(Key);\n    if (I == end())\n      return false;\n    erase(I);\n    return true;\n  }\n};\n\ntemplate <typename DerivedTy, typename ValueTy>\nclass StringMapIterBase\n    : public iterator_facade_base<DerivedTy, std::forward_iterator_tag,\n                                  ValueTy> {\nprotected:\n  StringMapEntryBase **Ptr = nullptr;\n\npublic:\n  StringMapIterBase() = default;\n\n  explicit StringMapIterBase(StringMapEntryBase **Bucket,\n                             bool NoAdvance = false)\n      : Ptr(Bucket) {\n    if (!NoAdvance)\n      AdvancePastEmptyBuckets();\n  }\n\n  DerivedTy &operator=(const DerivedTy &Other) {\n    Ptr = Other.Ptr;\n    return static_cast<DerivedTy &>(*this);\n  }\n\n  friend bool operator==(const DerivedTy &LHS, const DerivedTy &RHS) {\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  DerivedTy &operator++() { // Preincrement\n    ++Ptr;\n    AdvancePastEmptyBuckets();\n    return static_cast<DerivedTy &>(*this);\n  }\n\n  DerivedTy operator++(int) { // Post-increment\n    DerivedTy Tmp(Ptr);\n    ++*this;\n    return Tmp;\n  }\n\nprivate:\n  void AdvancePastEmptyBuckets() {\n    while (*Ptr == nullptr || *Ptr == StringMapImpl::getTombstoneVal())\n      ++Ptr;\n  }\n};\n\ntemplate <typename ValueTy>\nclass StringMapConstIterator\n    : public StringMapIterBase<StringMapConstIterator<ValueTy>,\n                               const StringMapEntry<ValueTy>> {\n  using base = StringMapIterBase<StringMapConstIterator<ValueTy>,\n                                 const StringMapEntry<ValueTy>>;\n\npublic:\n  StringMapConstIterator() = default;\n  explicit StringMapConstIterator(StringMapEntryBase **Bucket,\n                                  bool NoAdvance = false)\n      : base(Bucket, NoAdvance) {}\n\n  const StringMapEntry<ValueTy> &operator*() const {\n    return *static_cast<const StringMapEntry<ValueTy> *>(*this->Ptr);\n  }\n};\n\ntemplate <typename ValueTy>\nclass StringMapIterator : public StringMapIterBase<StringMapIterator<ValueTy>,\n                                                   StringMapEntry<ValueTy>> {\n  using base =\n      StringMapIterBase<StringMapIterator<ValueTy>, StringMapEntry<ValueTy>>;\n\npublic:\n  StringMapIterator() = default;\n  explicit StringMapIterator(StringMapEntryBase **Bucket,\n                             bool NoAdvance = false)\n      : base(Bucket, NoAdvance) {}\n\n  StringMapEntry<ValueTy> &operator*() const {\n    return *static_cast<StringMapEntry<ValueTy> *>(*this->Ptr);\n  }\n\n  operator StringMapConstIterator<ValueTy>() const {\n    return StringMapConstIterator<ValueTy>(this->Ptr, true);\n  }\n};\n\ntemplate <typename ValueTy>\nclass StringMapKeyIterator\n    : public iterator_adaptor_base<StringMapKeyIterator<ValueTy>,\n                                   StringMapConstIterator<ValueTy>,\n                                   std::forward_iterator_tag, StringRef> {\n  using base = iterator_adaptor_base<StringMapKeyIterator<ValueTy>,\n                                     StringMapConstIterator<ValueTy>,\n                                     std::forward_iterator_tag, StringRef>;\n\npublic:\n  StringMapKeyIterator() = default;\n  explicit StringMapKeyIterator(StringMapConstIterator<ValueTy> Iter)\n      : base(std::move(Iter)) {}\n\n  StringRef &operator*() {\n    Key = this->wrapped()->getKey();\n    return Key;\n  }\n\nprivate:\n  StringRef Key;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_STRINGMAP_H\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringRef.h", "content": "//===- StringRef.h - Constant String Reference Wrapper ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_STRINGREF_H\n#define LLVM_ADT_STRINGREF_H\n\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <limits>\n#include <string>\n#if __cplusplus > 201402L\n#include <string_view>\n#endif\n#include <type_traits>\n#include <utility>\n\n// Declare the __builtin_strlen intrinsic for MSVC so it can be used in\n// constexpr context.\n#if defined(_MSC_VER)\nextern \"C\" size_t __builtin_strlen(const char *);\n#endif\n\nnamespace llvm {\n\n  class APInt;\n  class hash_code;\n  template <typename T> class SmallVectorImpl;\n  class StringRef;\n\n  /// Helper functions for StringRef::getAsInteger.\n  bool getAsUnsignedInteger(StringRef Str, unsigned Radix,\n                            unsigned long long &Result);\n\n  bool getAsSignedInteger(StringRef Str, unsigned Radix, long long &Result);\n\n  bool consumeUnsignedInteger(StringRef &Str, unsigned Radix,\n                              unsigned long long &Result);\n  bool consumeSignedInteger(StringRef &Str, unsigned Radix, long long &Result);\n\n  /// StringRef - Represent a constant reference to a string, i.e. a character\n  /// array and a length, which need not be null terminated.\n  ///\n  /// This class does not own the string data, it is expected to be used in\n  /// situations where the character data resides in some other buffer, whose\n  /// lifetime extends past that of the StringRef. For this reason, it is not in\n  /// general safe to store a StringRef.\n  class LLVM_GSL_POINTER StringRef {\n  public:\n    static constexpr size_t npos = ~size_t(0);\n\n    using iterator = const char *;\n    using const_iterator = const char *;\n    using size_type = size_t;\n\n  private:\n    /// The start of the string, in an external buffer.\n    const char *Data = nullptr;\n\n    /// The length of the string.\n    size_t Length = 0;\n\n    // Workaround memcmp issue with null pointers (undefined behavior)\n    // by providing a specialized version\n    static int compareMemory(const char *Lhs, const char *Rhs, size_t Length) {\n      if (Length == 0) { return 0; }\n      return ::memcmp(Lhs,Rhs,Length);\n    }\n\n    // Constexpr version of std::strlen.\n    static constexpr size_t strLen(const char *Str) {\n#if __cplusplus > 201402L\n      return std::char_traits<char>::length(Str);\n#elif __has_builtin(__builtin_strlen) || defined(__GNUC__) || \\\n    (defined(_MSC_VER) && _MSC_VER >= 1916)\n      return __builtin_strlen(Str);\n#else\n      const char *Begin = Str;\n      while (*Str != '\\0')\n        ++Str;\n      return Str - Begin;\n#endif\n    }\n\n  public:\n    /// @name Constructors\n    /// @{\n\n    /// Construct an empty string ref.\n    /*implicit*/ StringRef() = default;\n\n    /// Disable conversion from nullptr.  This prevents things like\n    /// if (S == nullptr)\n    StringRef(std::nullptr_t) = delete;\n\n    /// Construct a string ref from a cstring.\n    /*implicit*/ constexpr StringRef(const char *Str)\n        : Data(Str), Length(Str ? strLen(Str) : 0) {}\n\n    /// Construct a string ref from a pointer and length.\n    /*implicit*/ constexpr StringRef(const char *data, size_t length)\n        : Data(data), Length(length) {}\n\n    /// Construct a string ref from an std::string.\n    /*implicit*/ StringRef(const std::string &Str)\n      : Data(Str.data()), Length(Str.length()) {}\n\n#if __cplusplus > 201402L\n    /// Construct a string ref from an std::string_view.\n    /*implicit*/ constexpr StringRef(std::string_view Str)\n        : Data(Str.data()), Length(Str.size()) {}\n#endif\n\n    static StringRef withNullAsEmpty(const char *data) {\n      return StringRef(data ? data : \"\");\n    }\n\n    /// @}\n    /// @name Iterators\n    /// @{\n\n    iterator begin() const { return Data; }\n\n    iterator end() const { return Data + Length; }\n\n    const unsigned char *bytes_begin() const {\n      return reinterpret_cast<const unsigned char *>(begin());\n    }\n    const unsigned char *bytes_end() const {\n      return reinterpret_cast<const unsigned char *>(end());\n    }\n    iterator_range<const unsigned char *> bytes() const {\n      return make_range(bytes_begin(), bytes_end());\n    }\n\n    /// @}\n    /// @name String Operations\n    /// @{\n\n    /// data - Get a pointer to the start of the string (which may not be null\n    /// terminated).\n    LLVM_NODISCARD\n    const char *data() const { return Data; }\n\n    /// empty - Check if the string is empty.\n    LLVM_NODISCARD\n    bool empty() const { return Length == 0; }\n\n    /// size - Get the string size.\n    LLVM_NODISCARD\n    size_t size() const { return Length; }\n\n    /// front - Get the first character in the string.\n    LLVM_NODISCARD\n    char front() const {\n      assert(!empty());\n      return Data[0];\n    }\n\n    /// back - Get the last character in the string.\n    LLVM_NODISCARD\n    char back() const {\n      assert(!empty());\n      return Data[Length-1];\n    }\n\n    // copy - Allocate copy in Allocator and return StringRef to it.\n    template <typename Allocator>\n    LLVM_NODISCARD StringRef copy(Allocator &A) const {\n      // Don't request a length 0 copy from the allocator.\n      if (empty())\n        return StringRef();\n      char *S = A.template Allocate<char>(Length);\n      std::copy(begin(), end(), S);\n      return StringRef(S, Length);\n    }\n\n    /// equals - Check for string equality, this is more efficient than\n    /// compare() when the relative ordering of inequal strings isn't needed.\n    LLVM_NODISCARD\n    bool equals(StringRef RHS) const {\n      return (Length == RHS.Length &&\n              compareMemory(Data, RHS.Data, RHS.Length) == 0);\n    }\n\n    /// equals_lower - Check for string equality, ignoring case.\n    LLVM_NODISCARD\n    bool equals_lower(StringRef RHS) const {\n      return Length == RHS.Length && compare_lower(RHS) == 0;\n    }\n\n    /// compare - Compare two strings; the result is -1, 0, or 1 if this string\n    /// is lexicographically less than, equal to, or greater than the \\p RHS.\n    LLVM_NODISCARD\n    int compare(StringRef RHS) const {\n      // Check the prefix for a mismatch.\n      if (int Res = compareMemory(Data, RHS.Data, std::min(Length, RHS.Length)))\n        return Res < 0 ? -1 : 1;\n\n      // Otherwise the prefixes match, so we only need to check the lengths.\n      if (Length == RHS.Length)\n        return 0;\n      return Length < RHS.Length ? -1 : 1;\n    }\n\n    /// compare_lower - Compare two strings, ignoring case.\n    LLVM_NODISCARD\n    int compare_lower(StringRef RHS) const;\n\n    /// compare_numeric - Compare two strings, treating sequences of digits as\n    /// numbers.\n    LLVM_NODISCARD\n    int compare_numeric(StringRef RHS) const;\n\n    /// Determine the edit distance between this string and another\n    /// string.\n    ///\n    /// \\param Other the string to compare this string against.\n    ///\n    /// \\param AllowReplacements whether to allow character\n    /// replacements (change one character into another) as a single\n    /// operation, rather than as two operations (an insertion and a\n    /// removal).\n    ///\n    /// \\param MaxEditDistance If non-zero, the maximum edit distance that\n    /// this routine is allowed to compute. If the edit distance will exceed\n    /// that maximum, returns \\c MaxEditDistance+1.\n    ///\n    /// \\returns the minimum number of character insertions, removals,\n    /// or (if \\p AllowReplacements is \\c true) replacements needed to\n    /// transform one of the given strings into the other. If zero,\n    /// the strings are identical.\n    LLVM_NODISCARD\n    unsigned edit_distance(StringRef Other, bool AllowReplacements = true,\n                           unsigned MaxEditDistance = 0) const;\n\n    /// str - Get the contents as an std::string.\n    LLVM_NODISCARD\n    std::string str() const {\n      if (!Data) return std::string();\n      return std::string(Data, Length);\n    }\n\n    /// @}\n    /// @name Operator Overloads\n    /// @{\n\n    LLVM_NODISCARD\n    char operator[](size_t Index) const {\n      assert(Index < Length && \"Invalid index!\");\n      return Data[Index];\n    }\n\n    /// Disallow accidental assignment from a temporary std::string.\n    ///\n    /// The declaration here is extra complicated so that `stringRef = {}`\n    /// and `stringRef = \"abc\"` continue to select the move assignment operator.\n    template <typename T>\n    std::enable_if_t<std::is_same<T, std::string>::value, StringRef> &\n    operator=(T &&Str) = delete;\n\n    /// @}\n    /// @name Type Conversions\n    /// @{\n\n    explicit operator std::string() const { return str(); }\n\n#if __cplusplus > 201402L\n    operator std::string_view() const {\n      return std::string_view(data(), size());\n    }\n#endif\n\n    /// @}\n    /// @name String Predicates\n    /// @{\n\n    /// Check if this string starts with the given \\p Prefix.\n    LLVM_NODISCARD\n    bool startswith(StringRef Prefix) const {\n      return Length >= Prefix.Length &&\n             compareMemory(Data, Prefix.Data, Prefix.Length) == 0;\n    }\n\n    /// Check if this string starts with the given \\p Prefix, ignoring case.\n    LLVM_NODISCARD\n    bool startswith_lower(StringRef Prefix) const;\n\n    /// Check if this string ends with the given \\p Suffix.\n    LLVM_NODISCARD\n    bool endswith(StringRef Suffix) const {\n      return Length >= Suffix.Length &&\n        compareMemory(end() - Suffix.Length, Suffix.Data, Suffix.Length) == 0;\n    }\n\n    /// Check if this string ends with the given \\p Suffix, ignoring case.\n    LLVM_NODISCARD\n    bool endswith_lower(StringRef Suffix) const;\n\n    /// @}\n    /// @name String Searching\n    /// @{\n\n    /// Search for the first character \\p C in the string.\n    ///\n    /// \\returns The index of the first occurrence of \\p C, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t find(char C, size_t From = 0) const {\n      size_t FindBegin = std::min(From, Length);\n      if (FindBegin < Length) { // Avoid calling memchr with nullptr.\n        // Just forward to memchr, which is faster than a hand-rolled loop.\n        if (const void *P = ::memchr(Data + FindBegin, C, Length - FindBegin))\n          return static_cast<const char *>(P) - Data;\n      }\n      return npos;\n    }\n\n    /// Search for the first character \\p C in the string, ignoring case.\n    ///\n    /// \\returns The index of the first occurrence of \\p C, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t find_lower(char C, size_t From = 0) const;\n\n    /// Search for the first character satisfying the predicate \\p F\n    ///\n    /// \\returns The index of the first character satisfying \\p F starting from\n    /// \\p From, or npos if not found.\n    LLVM_NODISCARD\n    size_t find_if(function_ref<bool(char)> F, size_t From = 0) const {\n      StringRef S = drop_front(From);\n      while (!S.empty()) {\n        if (F(S.front()))\n          return size() - S.size();\n        S = S.drop_front();\n      }\n      return npos;\n    }\n\n    /// Search for the first character not satisfying the predicate \\p F\n    ///\n    /// \\returns The index of the first character not satisfying \\p F starting\n    /// from \\p From, or npos if not found.\n    LLVM_NODISCARD\n    size_t find_if_not(function_ref<bool(char)> F, size_t From = 0) const {\n      return find_if([F](char c) { return !F(c); }, From);\n    }\n\n    /// Search for the first string \\p Str in the string.\n    ///\n    /// \\returns The index of the first occurrence of \\p Str, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t find(StringRef Str, size_t From = 0) const;\n\n    /// Search for the first string \\p Str in the string, ignoring case.\n    ///\n    /// \\returns The index of the first occurrence of \\p Str, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t find_lower(StringRef Str, size_t From = 0) const;\n\n    /// Search for the last character \\p C in the string.\n    ///\n    /// \\returns The index of the last occurrence of \\p C, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t rfind(char C, size_t From = npos) const {\n      From = std::min(From, Length);\n      size_t i = From;\n      while (i != 0) {\n        --i;\n        if (Data[i] == C)\n          return i;\n      }\n      return npos;\n    }\n\n    /// Search for the last character \\p C in the string, ignoring case.\n    ///\n    /// \\returns The index of the last occurrence of \\p C, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t rfind_lower(char C, size_t From = npos) const;\n\n    /// Search for the last string \\p Str in the string.\n    ///\n    /// \\returns The index of the last occurrence of \\p Str, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t rfind(StringRef Str) const;\n\n    /// Search for the last string \\p Str in the string, ignoring case.\n    ///\n    /// \\returns The index of the last occurrence of \\p Str, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t rfind_lower(StringRef Str) const;\n\n    /// Find the first character in the string that is \\p C, or npos if not\n    /// found. Same as find.\n    LLVM_NODISCARD\n    size_t find_first_of(char C, size_t From = 0) const {\n      return find(C, From);\n    }\n\n    /// Find the first character in the string that is in \\p Chars, or npos if\n    /// not found.\n    ///\n    /// Complexity: O(size() + Chars.size())\n    LLVM_NODISCARD\n    size_t find_first_of(StringRef Chars, size_t From = 0) const;\n\n    /// Find the first character in the string that is not \\p C or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t find_first_not_of(char C, size_t From = 0) const;\n\n    /// Find the first character in the string that is not in the string\n    /// \\p Chars, or npos if not found.\n    ///\n    /// Complexity: O(size() + Chars.size())\n    LLVM_NODISCARD\n    size_t find_first_not_of(StringRef Chars, size_t From = 0) const;\n\n    /// Find the last character in the string that is \\p C, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t find_last_of(char C, size_t From = npos) const {\n      return rfind(C, From);\n    }\n\n    /// Find the last character in the string that is in \\p C, or npos if not\n    /// found.\n    ///\n    /// Complexity: O(size() + Chars.size())\n    LLVM_NODISCARD\n    size_t find_last_of(StringRef Chars, size_t From = npos) const;\n\n    /// Find the last character in the string that is not \\p C, or npos if not\n    /// found.\n    LLVM_NODISCARD\n    size_t find_last_not_of(char C, size_t From = npos) const;\n\n    /// Find the last character in the string that is not in \\p Chars, or\n    /// npos if not found.\n    ///\n    /// Complexity: O(size() + Chars.size())\n    LLVM_NODISCARD\n    size_t find_last_not_of(StringRef Chars, size_t From = npos) const;\n\n    /// Return true if the given string is a substring of *this, and false\n    /// otherwise.\n    LLVM_NODISCARD\n    bool contains(StringRef Other) const { return find(Other) != npos; }\n\n    /// Return true if the given character is contained in *this, and false\n    /// otherwise.\n    LLVM_NODISCARD\n    bool contains(char C) const { return find_first_of(C) != npos; }\n\n    /// Return true if the given string is a substring of *this, and false\n    /// otherwise.\n    LLVM_NODISCARD\n    bool contains_lower(StringRef Other) const {\n      return find_lower(Other) != npos;\n    }\n\n    /// Return true if the given character is contained in *this, and false\n    /// otherwise.\n    LLVM_NODISCARD\n    bool contains_lower(char C) const { return find_lower(C) != npos; }\n\n    /// @}\n    /// @name Helpful Algorithms\n    /// @{\n\n    /// Return the number of occurrences of \\p C in the string.\n    LLVM_NODISCARD\n    size_t count(char C) const {\n      size_t Count = 0;\n      for (size_t i = 0, e = Length; i != e; ++i)\n        if (Data[i] == C)\n          ++Count;\n      return Count;\n    }\n\n    /// Return the number of non-overlapped occurrences of \\p Str in\n    /// the string.\n    size_t count(StringRef Str) const;\n\n    /// Parse the current string as an integer of the specified radix.  If\n    /// \\p Radix is specified as zero, this does radix autosensing using\n    /// extended C rules: 0 is octal, 0x is hex, 0b is binary.\n    ///\n    /// If the string is invalid or if only a subset of the string is valid,\n    /// this returns true to signify the error.  The string is considered\n    /// erroneous if empty or if it overflows T.\n    template <typename T>\n    std::enable_if_t<std::numeric_limits<T>::is_signed, bool>\n    getAsInteger(unsigned Radix, T &Result) const {\n      long long LLVal;\n      if (getAsSignedInteger(*this, Radix, LLVal) ||\n            static_cast<T>(LLVal) != LLVal)\n        return true;\n      Result = LLVal;\n      return false;\n    }\n\n    template <typename T>\n    std::enable_if_t<!std::numeric_limits<T>::is_signed, bool>\n    getAsInteger(unsigned Radix, T &Result) const {\n      unsigned long long ULLVal;\n      // The additional cast to unsigned long long is required to avoid the\n      // Visual C++ warning C4805: '!=' : unsafe mix of type 'bool' and type\n      // 'unsigned __int64' when instantiating getAsInteger with T = bool.\n      if (getAsUnsignedInteger(*this, Radix, ULLVal) ||\n          static_cast<unsigned long long>(static_cast<T>(ULLVal)) != ULLVal)\n        return true;\n      Result = ULLVal;\n      return false;\n    }\n\n    /// Parse the current string as an integer of the specified radix.  If\n    /// \\p Radix is specified as zero, this does radix autosensing using\n    /// extended C rules: 0 is octal, 0x is hex, 0b is binary.\n    ///\n    /// If the string does not begin with a number of the specified radix,\n    /// this returns true to signify the error. The string is considered\n    /// erroneous if empty or if it overflows T.\n    /// The portion of the string representing the discovered numeric value\n    /// is removed from the beginning of the string.\n    template <typename T>\n    std::enable_if_t<std::numeric_limits<T>::is_signed, bool>\n    consumeInteger(unsigned Radix, T &Result) {\n      long long LLVal;\n      if (consumeSignedInteger(*this, Radix, LLVal) ||\n          static_cast<long long>(static_cast<T>(LLVal)) != LLVal)\n        return true;\n      Result = LLVal;\n      return false;\n    }\n\n    template <typename T>\n    std::enable_if_t<!std::numeric_limits<T>::is_signed, bool>\n    consumeInteger(unsigned Radix, T &Result) {\n      unsigned long long ULLVal;\n      if (consumeUnsignedInteger(*this, Radix, ULLVal) ||\n          static_cast<unsigned long long>(static_cast<T>(ULLVal)) != ULLVal)\n        return true;\n      Result = ULLVal;\n      return false;\n    }\n\n    /// Parse the current string as an integer of the specified \\p Radix, or of\n    /// an autosensed radix if the \\p Radix given is 0.  The current value in\n    /// \\p Result is discarded, and the storage is changed to be wide enough to\n    /// store the parsed integer.\n    ///\n    /// \\returns true if the string does not solely consist of a valid\n    /// non-empty number in the appropriate base.\n    ///\n    /// APInt::fromString is superficially similar but assumes the\n    /// string is well-formed in the given radix.\n    bool getAsInteger(unsigned Radix, APInt &Result) const;\n\n    /// Parse the current string as an IEEE double-precision floating\n    /// point value.  The string must be a well-formed double.\n    ///\n    /// If \\p AllowInexact is false, the function will fail if the string\n    /// cannot be represented exactly.  Otherwise, the function only fails\n    /// in case of an overflow or underflow, or an invalid floating point\n    /// representation.\n    bool getAsDouble(double &Result, bool AllowInexact = true) const;\n\n    /// @}\n    /// @name String Operations\n    /// @{\n\n    // Convert the given ASCII string to lowercase.\n    LLVM_NODISCARD\n    std::string lower() const;\n\n    /// Convert the given ASCII string to uppercase.\n    LLVM_NODISCARD\n    std::string upper() const;\n\n    /// @}\n    /// @name Substring Operations\n    /// @{\n\n    /// Return a reference to the substring from [Start, Start + N).\n    ///\n    /// \\param Start The index of the starting character in the substring; if\n    /// the index is npos or greater than the length of the string then the\n    /// empty substring will be returned.\n    ///\n    /// \\param N The number of characters to included in the substring. If N\n    /// exceeds the number of characters remaining in the string, the string\n    /// suffix (starting with \\p Start) will be returned.\n    LLVM_NODISCARD\n    StringRef substr(size_t Start, size_t N = npos) const {\n      Start = std::min(Start, Length);\n      return StringRef(Data + Start, std::min(N, Length - Start));\n    }\n\n    /// Return a StringRef equal to 'this' but with only the first \\p N\n    /// elements remaining.  If \\p N is greater than the length of the\n    /// string, the entire string is returned.\n    LLVM_NODISCARD\n    StringRef take_front(size_t N = 1) const {\n      if (N >= size())\n        return *this;\n      return drop_back(size() - N);\n    }\n\n    /// Return a StringRef equal to 'this' but with only the last \\p N\n    /// elements remaining.  If \\p N is greater than the length of the\n    /// string, the entire string is returned.\n    LLVM_NODISCARD\n    StringRef take_back(size_t N = 1) const {\n      if (N >= size())\n        return *this;\n      return drop_front(size() - N);\n    }\n\n    /// Return the longest prefix of 'this' such that every character\n    /// in the prefix satisfies the given predicate.\n    LLVM_NODISCARD\n    StringRef take_while(function_ref<bool(char)> F) const {\n      return substr(0, find_if_not(F));\n    }\n\n    /// Return the longest prefix of 'this' such that no character in\n    /// the prefix satisfies the given predicate.\n    LLVM_NODISCARD\n    StringRef take_until(function_ref<bool(char)> F) const {\n      return substr(0, find_if(F));\n    }\n\n    /// Return a StringRef equal to 'this' but with the first \\p N elements\n    /// dropped.\n    LLVM_NODISCARD\n    StringRef drop_front(size_t N = 1) const {\n      assert(size() >= N && \"Dropping more elements than exist\");\n      return substr(N);\n    }\n\n    /// Return a StringRef equal to 'this' but with the last \\p N elements\n    /// dropped.\n    LLVM_NODISCARD\n    StringRef drop_back(size_t N = 1) const {\n      assert(size() >= N && \"Dropping more elements than exist\");\n      return substr(0, size()-N);\n    }\n\n    /// Return a StringRef equal to 'this', but with all characters satisfying\n    /// the given predicate dropped from the beginning of the string.\n    LLVM_NODISCARD\n    StringRef drop_while(function_ref<bool(char)> F) const {\n      return substr(find_if_not(F));\n    }\n\n    /// Return a StringRef equal to 'this', but with all characters not\n    /// satisfying the given predicate dropped from the beginning of the string.\n    LLVM_NODISCARD\n    StringRef drop_until(function_ref<bool(char)> F) const {\n      return substr(find_if(F));\n    }\n\n    /// Returns true if this StringRef has the given prefix and removes that\n    /// prefix.\n    bool consume_front(StringRef Prefix) {\n      if (!startswith(Prefix))\n        return false;\n\n      *this = drop_front(Prefix.size());\n      return true;\n    }\n\n    /// Returns true if this StringRef has the given suffix and removes that\n    /// suffix.\n    bool consume_back(StringRef Suffix) {\n      if (!endswith(Suffix))\n        return false;\n\n      *this = drop_back(Suffix.size());\n      return true;\n    }\n\n    /// Return a reference to the substring from [Start, End).\n    ///\n    /// \\param Start The index of the starting character in the substring; if\n    /// the index is npos or greater than the length of the string then the\n    /// empty substring will be returned.\n    ///\n    /// \\param End The index following the last character to include in the\n    /// substring. If this is npos or exceeds the number of characters\n    /// remaining in the string, the string suffix (starting with \\p Start)\n    /// will be returned. If this is less than \\p Start, an empty string will\n    /// be returned.\n    LLVM_NODISCARD\n    StringRef slice(size_t Start, size_t End) const {\n      Start = std::min(Start, Length);\n      End = std::min(std::max(Start, End), Length);\n      return StringRef(Data + Start, End - Start);\n    }\n\n    /// Split into two substrings around the first occurrence of a separator\n    /// character.\n    ///\n    /// If \\p Separator is in the string, then the result is a pair (LHS, RHS)\n    /// such that (*this == LHS + Separator + RHS) is true and RHS is\n    /// maximal. If \\p Separator is not in the string, then the result is a\n    /// pair (LHS, RHS) where (*this == LHS) and (RHS == \"\").\n    ///\n    /// \\param Separator The character to split on.\n    /// \\returns The split substrings.\n    LLVM_NODISCARD\n    std::pair<StringRef, StringRef> split(char Separator) const {\n      return split(StringRef(&Separator, 1));\n    }\n\n    /// Split into two substrings around the first occurrence of a separator\n    /// string.\n    ///\n    /// If \\p Separator is in the string, then the result is a pair (LHS, RHS)\n    /// such that (*this == LHS + Separator + RHS) is true and RHS is\n    /// maximal. If \\p Separator is not in the string, then the result is a\n    /// pair (LHS, RHS) where (*this == LHS) and (RHS == \"\").\n    ///\n    /// \\param Separator - The string to split on.\n    /// \\return - The split substrings.\n    LLVM_NODISCARD\n    std::pair<StringRef, StringRef> split(StringRef Separator) const {\n      size_t Idx = find(Separator);\n      if (Idx == npos)\n        return std::make_pair(*this, StringRef());\n      return std::make_pair(slice(0, Idx), slice(Idx + Separator.size(), npos));\n    }\n\n    /// Split into two substrings around the last occurrence of a separator\n    /// string.\n    ///\n    /// If \\p Separator is in the string, then the result is a pair (LHS, RHS)\n    /// such that (*this == LHS + Separator + RHS) is true and RHS is\n    /// minimal. If \\p Separator is not in the string, then the result is a\n    /// pair (LHS, RHS) where (*this == LHS) and (RHS == \"\").\n    ///\n    /// \\param Separator - The string to split on.\n    /// \\return - The split substrings.\n    LLVM_NODISCARD\n    std::pair<StringRef, StringRef> rsplit(StringRef Separator) const {\n      size_t Idx = rfind(Separator);\n      if (Idx == npos)\n        return std::make_pair(*this, StringRef());\n      return std::make_pair(slice(0, Idx), slice(Idx + Separator.size(), npos));\n    }\n\n    /// Split into substrings around the occurrences of a separator string.\n    ///\n    /// Each substring is stored in \\p A. If \\p MaxSplit is >= 0, at most\n    /// \\p MaxSplit splits are done and consequently <= \\p MaxSplit + 1\n    /// elements are added to A.\n    /// If \\p KeepEmpty is false, empty strings are not added to \\p A. They\n    /// still count when considering \\p MaxSplit\n    /// An useful invariant is that\n    /// Separator.join(A) == *this if MaxSplit == -1 and KeepEmpty == true\n    ///\n    /// \\param A - Where to put the substrings.\n    /// \\param Separator - The string to split on.\n    /// \\param MaxSplit - The maximum number of times the string is split.\n    /// \\param KeepEmpty - True if empty substring should be added.\n    void split(SmallVectorImpl<StringRef> &A,\n               StringRef Separator, int MaxSplit = -1,\n               bool KeepEmpty = true) const;\n\n    /// Split into substrings around the occurrences of a separator character.\n    ///\n    /// Each substring is stored in \\p A. If \\p MaxSplit is >= 0, at most\n    /// \\p MaxSplit splits are done and consequently <= \\p MaxSplit + 1\n    /// elements are added to A.\n    /// If \\p KeepEmpty is false, empty strings are not added to \\p A. They\n    /// still count when considering \\p MaxSplit\n    /// An useful invariant is that\n    /// Separator.join(A) == *this if MaxSplit == -1 and KeepEmpty == true\n    ///\n    /// \\param A - Where to put the substrings.\n    /// \\param Separator - The string to split on.\n    /// \\param MaxSplit - The maximum number of times the string is split.\n    /// \\param KeepEmpty - True if empty substring should be added.\n    void split(SmallVectorImpl<StringRef> &A, char Separator, int MaxSplit = -1,\n               bool KeepEmpty = true) const;\n\n    /// Split into two substrings around the last occurrence of a separator\n    /// character.\n    ///\n    /// If \\p Separator is in the string, then the result is a pair (LHS, RHS)\n    /// such that (*this == LHS + Separator + RHS) is true and RHS is\n    /// minimal. If \\p Separator is not in the string, then the result is a\n    /// pair (LHS, RHS) where (*this == LHS) and (RHS == \"\").\n    ///\n    /// \\param Separator - The character to split on.\n    /// \\return - The split substrings.\n    LLVM_NODISCARD\n    std::pair<StringRef, StringRef> rsplit(char Separator) const {\n      return rsplit(StringRef(&Separator, 1));\n    }\n\n    /// Return string with consecutive \\p Char characters starting from the\n    /// the left removed.\n    LLVM_NODISCARD\n    StringRef ltrim(char Char) const {\n      return drop_front(std::min(Length, find_first_not_of(Char)));\n    }\n\n    /// Return string with consecutive characters in \\p Chars starting from\n    /// the left removed.\n    LLVM_NODISCARD\n    StringRef ltrim(StringRef Chars = \" \\t\\n\\v\\f\\r\") const {\n      return drop_front(std::min(Length, find_first_not_of(Chars)));\n    }\n\n    /// Return string with consecutive \\p Char characters starting from the\n    /// right removed.\n    LLVM_NODISCARD\n    StringRef rtrim(char Char) const {\n      return drop_back(Length - std::min(Length, find_last_not_of(Char) + 1));\n    }\n\n    /// Return string with consecutive characters in \\p Chars starting from\n    /// the right removed.\n    LLVM_NODISCARD\n    StringRef rtrim(StringRef Chars = \" \\t\\n\\v\\f\\r\") const {\n      return drop_back(Length - std::min(Length, find_last_not_of(Chars) + 1));\n    }\n\n    /// Return string with consecutive \\p Char characters starting from the\n    /// left and right removed.\n    LLVM_NODISCARD\n    StringRef trim(char Char) const {\n      return ltrim(Char).rtrim(Char);\n    }\n\n    /// Return string with consecutive characters in \\p Chars starting from\n    /// the left and right removed.\n    LLVM_NODISCARD\n    StringRef trim(StringRef Chars = \" \\t\\n\\v\\f\\r\") const {\n      return ltrim(Chars).rtrim(Chars);\n    }\n\n    /// @}\n  };\n\n  /// A wrapper around a string literal that serves as a proxy for constructing\n  /// global tables of StringRefs with the length computed at compile time.\n  /// In order to avoid the invocation of a global constructor, StringLiteral\n  /// should *only* be used in a constexpr context, as such:\n  ///\n  /// constexpr StringLiteral S(\"test\");\n  ///\n  class StringLiteral : public StringRef {\n  private:\n    constexpr StringLiteral(const char *Str, size_t N) : StringRef(Str, N) {\n    }\n\n  public:\n    template <size_t N>\n    constexpr StringLiteral(const char (&Str)[N])\n#if defined(__clang__) && __has_attribute(enable_if)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wgcc-compat\"\n        __attribute((enable_if(__builtin_strlen(Str) == N - 1,\n                               \"invalid string literal\")))\n#pragma clang diagnostic pop\n#endif\n        : StringRef(Str, N - 1) {\n    }\n\n    // Explicit construction for strings like \"foo\\0bar\".\n    template <size_t N>\n    static constexpr StringLiteral withInnerNUL(const char (&Str)[N]) {\n      return StringLiteral(Str, N - 1);\n    }\n  };\n\n  /// @name StringRef Comparison Operators\n  /// @{\n\n  inline bool operator==(StringRef LHS, StringRef RHS) {\n    return LHS.equals(RHS);\n  }\n\n  inline bool operator!=(StringRef LHS, StringRef RHS) { return !(LHS == RHS); }\n\n  inline bool operator<(StringRef LHS, StringRef RHS) {\n    return LHS.compare(RHS) == -1;\n  }\n\n  inline bool operator<=(StringRef LHS, StringRef RHS) {\n    return LHS.compare(RHS) != 1;\n  }\n\n  inline bool operator>(StringRef LHS, StringRef RHS) {\n    return LHS.compare(RHS) == 1;\n  }\n\n  inline bool operator>=(StringRef LHS, StringRef RHS) {\n    return LHS.compare(RHS) != -1;\n  }\n\n  inline std::string &operator+=(std::string &buffer, StringRef string) {\n    return buffer.append(string.data(), string.size());\n  }\n\n  /// @}\n\n  /// Compute a hash_code for a StringRef.\n  LLVM_NODISCARD\n  hash_code hash_value(StringRef S);\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_STRINGREF_H\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "content": "//===- iterator.h - Utilities for using and defining iterators --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_ITERATOR_H\n#define LLVM_ADT_ITERATOR_H\n\n#include \"llvm/ADT/iterator_range.h\"\n#include <algorithm>\n#include <cstddef>\n#include <iterator>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\n/// CRTP base class which implements the entire standard iterator facade\n/// in terms of a minimal subset of the interface.\n///\n/// Use this when it is reasonable to implement most of the iterator\n/// functionality in terms of a core subset. If you need special behavior or\n/// there are performance implications for this, you may want to override the\n/// relevant members instead.\n///\n/// Note, one abstraction that this does *not* provide is implementing\n/// subtraction in terms of addition by negating the difference. Negation isn't\n/// always information preserving, and I can see very reasonable iterator\n/// designs where this doesn't work well. It doesn't really force much added\n/// boilerplate anyways.\n///\n/// Another abstraction that this doesn't provide is implementing increment in\n/// terms of addition of one. These aren't equivalent for all iterator\n/// categories, and respecting that adds a lot of complexity for little gain.\n///\n/// Classes wishing to use `iterator_facade_base` should implement the following\n/// methods:\n///\n/// Forward Iterators:\n///   (All of the following methods)\n///   - DerivedT &operator=(const DerivedT &R);\n///   - bool operator==(const DerivedT &R) const;\n///   - const T &operator*() const;\n///   - T &operator*();\n///   - DerivedT &operator++();\n///\n/// Bidirectional Iterators:\n///   (All methods of forward iterators, plus the following)\n///   - DerivedT &operator--();\n///\n/// Random-access Iterators:\n///   (All methods of bidirectional iterators excluding the following)\n///   - DerivedT &operator++();\n///   - DerivedT &operator--();\n///   (and plus the following)\n///   - bool operator<(const DerivedT &RHS) const;\n///   - DifferenceTypeT operator-(const DerivedT &R) const;\n///   - DerivedT &operator+=(DifferenceTypeT N);\n///   - DerivedT &operator-=(DifferenceTypeT N);\n///\ntemplate <typename DerivedT, typename IteratorCategoryT, typename T,\n          typename DifferenceTypeT = std::ptrdiff_t, typename PointerT = T *,\n          typename ReferenceT = T &>\nclass iterator_facade_base\n    : public std::iterator<IteratorCategoryT, T, DifferenceTypeT, PointerT,\n                           ReferenceT> {\nprotected:\n  enum {\n    IsRandomAccess = std::is_base_of<std::random_access_iterator_tag,\n                                     IteratorCategoryT>::value,\n    IsBidirectional = std::is_base_of<std::bidirectional_iterator_tag,\n                                      IteratorCategoryT>::value,\n  };\n\n  /// A proxy object for computing a reference via indirecting a copy of an\n  /// iterator. This is used in APIs which need to produce a reference via\n  /// indirection but for which the iterator object might be a temporary. The\n  /// proxy preserves the iterator internally and exposes the indirected\n  /// reference via a conversion operator.\n  class ReferenceProxy {\n    friend iterator_facade_base;\n\n    DerivedT I;\n\n    ReferenceProxy(DerivedT I) : I(std::move(I)) {}\n\n  public:\n    operator ReferenceT() const { return *I; }\n  };\n\npublic:\n  DerivedT operator+(DifferenceTypeT n) const {\n    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    static_assert(\n        IsRandomAccess,\n        \"The '+' operator is only defined for random access iterators.\");\n    DerivedT tmp = *static_cast<const DerivedT *>(this);\n    tmp += n;\n    return tmp;\n  }\n  friend DerivedT operator+(DifferenceTypeT n, const DerivedT &i) {\n    static_assert(\n        IsRandomAccess,\n        \"The '+' operator is only defined for random access iterators.\");\n    return i + n;\n  }\n  DerivedT operator-(DifferenceTypeT n) const {\n    static_assert(\n        IsRandomAccess,\n        \"The '-' operator is only defined for random access iterators.\");\n    DerivedT tmp = *static_cast<const DerivedT *>(this);\n    tmp -= n;\n    return tmp;\n  }\n\n  DerivedT &operator++() {\n    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return static_cast<DerivedT *>(this)->operator+=(1);\n  }\n  DerivedT operator++(int) {\n    DerivedT tmp = *static_cast<DerivedT *>(this);\n    ++*static_cast<DerivedT *>(this);\n    return tmp;\n  }\n  DerivedT &operator--() {\n    static_assert(\n        IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    return static_cast<DerivedT *>(this)->operator-=(1);\n  }\n  DerivedT operator--(int) {\n    static_assert(\n        IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    DerivedT tmp = *static_cast<DerivedT *>(this);\n    --*static_cast<DerivedT *>(this);\n    return tmp;\n  }\n\n#ifndef __cpp_impl_three_way_comparison\n  bool operator!=(const DerivedT &RHS) const {\n    return !(static_cast<const DerivedT &>(*this) == RHS);\n  }\n#endif\n\n  bool operator>(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) < RHS) &&\n           !(static_cast<const DerivedT &>(*this) == RHS);\n  }\n  bool operator<=(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) > RHS);\n  }\n  bool operator>=(const DerivedT &RHS) const {\n    static_assert(\n        IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return !(static_cast<const DerivedT &>(*this) < RHS);\n  }\n\n  PointerT operator->() { return &static_cast<DerivedT *>(this)->operator*(); }\n  PointerT operator->() const {\n    return &static_cast<const DerivedT *>(this)->operator*();\n  }\n  ReferenceProxy operator[](DifferenceTypeT n) {\n    static_assert(IsRandomAccess,\n                  \"Subscripting is only defined for random access iterators.\");\n    return ReferenceProxy(static_cast<DerivedT *>(this)->operator+(n));\n  }\n  ReferenceProxy operator[](DifferenceTypeT n) const {\n    static_assert(IsRandomAccess,\n                  \"Subscripting is only defined for random access iterators.\");\n    return ReferenceProxy(static_cast<const DerivedT *>(this)->operator+(n));\n  }\n};\n\n/// CRTP base class for adapting an iterator to a different type.\n///\n/// This class can be used through CRTP to adapt one iterator into another.\n/// Typically this is done through providing in the derived class a custom \\c\n/// operator* implementation. Other methods can be overridden as well.\ntemplate <\n    typename DerivedT, typename WrappedIteratorT,\n    typename IteratorCategoryT =\n        typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n    typename T = typename std::iterator_traits<WrappedIteratorT>::value_type,\n    typename DifferenceTypeT =\n        typename std::iterator_traits<WrappedIteratorT>::difference_type,\n    typename PointerT = std::conditional_t<\n        std::is_same<T, typename std::iterator_traits<\n                            WrappedIteratorT>::value_type>::value,\n        typename std::iterator_traits<WrappedIteratorT>::pointer, T *>,\n    typename ReferenceT = std::conditional_t<\n        std::is_same<T, typename std::iterator_traits<\n                            WrappedIteratorT>::value_type>::value,\n        typename std::iterator_traits<WrappedIteratorT>::reference, T &>>\nclass iterator_adaptor_base\n    : public iterator_facade_base<DerivedT, IteratorCategoryT, T,\n                                  DifferenceTypeT, PointerT, ReferenceT> {\n  using BaseT = typename iterator_adaptor_base::iterator_facade_base;\n\nprotected:\n  WrappedIteratorT I;\n\n  iterator_adaptor_base() = default;\n\n  explicit iterator_adaptor_base(WrappedIteratorT u) : I(std::move(u)) {\n    static_assert(std::is_base_of<iterator_adaptor_base, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n  }\n\n  const WrappedIteratorT &wrapped() const { return I; }\n\npublic:\n  using difference_type = DifferenceTypeT;\n\n  DerivedT &operator+=(difference_type n) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '+=' operator is only defined for random access iterators.\");\n    I += n;\n    return *static_cast<DerivedT *>(this);\n  }\n  DerivedT &operator-=(difference_type n) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '-=' operator is only defined for random access iterators.\");\n    I -= n;\n    return *static_cast<DerivedT *>(this);\n  }\n  using BaseT::operator-;\n  difference_type operator-(const DerivedT &RHS) const {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"The '-' operator is only defined for random access iterators.\");\n    return I - RHS.I;\n  }\n\n  // We have to explicitly provide ++ and -- rather than letting the facade\n  // forward to += because WrappedIteratorT might not support +=.\n  using BaseT::operator++;\n  DerivedT &operator++() {\n    ++I;\n    return *static_cast<DerivedT *>(this);\n  }\n  using BaseT::operator--;\n  DerivedT &operator--() {\n    static_assert(\n        BaseT::IsBidirectional,\n        \"The decrement operator is only defined for bidirectional iterators.\");\n    --I;\n    return *static_cast<DerivedT *>(this);\n  }\n\n  friend bool operator==(const iterator_adaptor_base &LHS,\n                         const iterator_adaptor_base &RHS) {\n    return LHS.I == RHS.I;\n  }\n  friend bool operator<(const iterator_adaptor_base &LHS,\n                        const iterator_adaptor_base &RHS) {\n    static_assert(\n        BaseT::IsRandomAccess,\n        \"Relational operators are only defined for random access iterators.\");\n    return LHS.I < RHS.I;\n  }\n\n  ReferenceT operator*() const { return *I; }\n};\n\n/// An iterator type that allows iterating over the pointees via some\n/// other iterator.\n///\n/// The typical usage of this is to expose a type that iterates over Ts, but\n/// which is implemented with some iterator over T*s:\n///\n/// \\code\n///   using iterator = pointee_iterator<SmallVectorImpl<T *>::iterator>;\n/// \\endcode\ntemplate <typename WrappedIteratorT,\n          typename T = std::remove_reference_t<decltype(\n              **std::declval<WrappedIteratorT>())>>\nstruct pointee_iterator\n    : iterator_adaptor_base<\n          pointee_iterator<WrappedIteratorT, T>, WrappedIteratorT,\n          typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n          T> {\n  pointee_iterator() = default;\n  template <typename U>\n  pointee_iterator(U &&u)\n      : pointee_iterator::iterator_adaptor_base(std::forward<U &&>(u)) {}\n\n  T &operator*() const { return **this->I; }\n};\n\ntemplate <typename RangeT, typename WrappedIteratorT =\n                               decltype(std::begin(std::declval<RangeT>()))>\niterator_range<pointee_iterator<WrappedIteratorT>>\nmake_pointee_range(RangeT &&Range) {\n  using PointeeIteratorT = pointee_iterator<WrappedIteratorT>;\n  return make_range(PointeeIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    PointeeIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\ntemplate <typename WrappedIteratorT,\n          typename T = decltype(&*std::declval<WrappedIteratorT>())>\nclass pointer_iterator\n    : public iterator_adaptor_base<\n          pointer_iterator<WrappedIteratorT, T>, WrappedIteratorT,\n          typename std::iterator_traits<WrappedIteratorT>::iterator_category,\n          T> {\n  mutable T Ptr;\n\npublic:\n  pointer_iterator() = default;\n\n  explicit pointer_iterator(WrappedIteratorT u)\n      : pointer_iterator::iterator_adaptor_base(std::move(u)) {}\n\n  T &operator*() { return Ptr = &*this->I; }\n  const T &operator*() const { return Ptr = &*this->I; }\n};\n\ntemplate <typename RangeT, typename WrappedIteratorT =\n                               decltype(std::begin(std::declval<RangeT>()))>\niterator_range<pointer_iterator<WrappedIteratorT>>\nmake_pointer_range(RangeT &&Range) {\n  using PointerIteratorT = pointer_iterator<WrappedIteratorT>;\n  return make_range(PointerIteratorT(std::begin(std::forward<RangeT>(Range))),\n                    PointerIteratorT(std::end(std::forward<RangeT>(Range))));\n}\n\ntemplate <typename WrappedIteratorT,\n          typename T1 = std::remove_reference_t<decltype(\n              **std::declval<WrappedIteratorT>())>,\n          typename T2 = std::add_pointer_t<T1>>\nusing raw_pointer_iterator =\n    pointer_iterator<pointee_iterator<WrappedIteratorT, T1>, T2>;\n\n// Wrapper iterator over iterator ItType, adding DataRef to the type of ItType,\n// to create NodeRef = std::pair<InnerTypeOfItType, DataRef>.\ntemplate <typename ItType, typename NodeRef, typename DataRef>\nclass WrappedPairNodeDataIterator\n    : public iterator_adaptor_base<\n          WrappedPairNodeDataIterator<ItType, NodeRef, DataRef>, ItType,\n          typename std::iterator_traits<ItType>::iterator_category, NodeRef,\n          std::ptrdiff_t, NodeRef *, NodeRef &> {\n  using BaseT = iterator_adaptor_base<\n      WrappedPairNodeDataIterator, ItType,\n      typename std::iterator_traits<ItType>::iterator_category, NodeRef,\n      std::ptrdiff_t, NodeRef *, NodeRef &>;\n\n  const DataRef DR;\n  mutable NodeRef NR;\n\npublic:\n  WrappedPairNodeDataIterator(ItType Begin, const DataRef DR)\n      : BaseT(Begin), DR(DR) {\n    NR.first = DR;\n  }\n\n  NodeRef &operator*() const {\n    NR.second = *this->I;\n    return NR;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_ITERATOR_H\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "content": "//===-- llvm/Support/Alignment.h - Useful alignment functions ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains types to represent alignments.\n// They are instrumented to guarantee some invariants are preserved and prevent\n// invalid manipulations.\n//\n// - Align represents an alignment in bytes, it is always set and always a valid\n// power of two, its minimum value is 1 which means no alignment requirements.\n//\n// - MaybeAlign is an optional type, it may be undefined or set. When it's set\n// you can get the underlying Align type by using the getValue() method.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ALIGNMENT_H_\n#define LLVM_SUPPORT_ALIGNMENT_H_\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <cassert>\n#ifndef NDEBUG\n#include <string>\n#endif // NDEBUG\n\nnamespace llvm {\n\n#define ALIGN_CHECK_ISPOSITIVE(decl)                                           \\\n  assert(decl > 0 && (#decl \" should be defined\"))\n\n/// This struct is a compact representation of a valid (non-zero power of two)\n/// alignment.\n/// It is suitable for use as static global constants.\nstruct Align {\nprivate:\n  uint8_t ShiftValue = 0; /// The log2 of the required alignment.\n                          /// ShiftValue is less than 64 by construction.\n\n  friend struct MaybeAlign;\n  friend unsigned Log2(Align);\n  friend bool operator==(Align Lhs, Align Rhs);\n  friend bool operator!=(Align Lhs, Align Rhs);\n  friend bool operator<=(Align Lhs, Align Rhs);\n  friend bool operator>=(Align Lhs, Align Rhs);\n  friend bool operator<(Align Lhs, Align Rhs);\n  friend bool operator>(Align Lhs, Align Rhs);\n  friend unsigned encode(struct MaybeAlign A);\n  friend struct MaybeAlign decodeMaybeAlign(unsigned Value);\n\n  /// A trivial type to allow construction of constexpr Align.\n  /// This is currently needed to workaround a bug in GCC 5.3 which prevents\n  /// definition of constexpr assign operators.\n  /// https://stackoverflow.com/questions/46756288/explicitly-defaulted-function-cannot-be-declared-as-constexpr-because-the-implic\n  /// FIXME: Remove this, make all assign operators constexpr and introduce user\n  /// defined literals when we don't have to support GCC 5.3 anymore.\n  /// https://llvm.org/docs/GettingStarted.html#getting-a-modern-host-c-toolchain\n  struct LogValue {\n    uint8_t Log;\n  };\n\npublic:\n  /// Default is byte-aligned.\n  constexpr Align() = default;\n  /// Do not perform checks in case of copy/move construct/assign, because the\n  /// checks have been performed when building `Other`.\n  constexpr Align(const Align &Other) = default;\n  constexpr Align(Align &&Other) = default;\n  Align &operator=(const Align &Other) = default;\n  Align &operator=(Align &&Other) = default;\n\n  explicit Align(uint64_t Value) {\n    assert(Value > 0 && \"Value must not be 0\");\n    assert(llvm::isPowerOf2_64(Value) && \"Alignment is not a power of 2\");\n    ShiftValue = Log2_64(Value);\n    assert(ShiftValue < 64 && \"Broken invariant\");\n  }\n\n  /// This is a hole in the type system and should not be abused.\n  /// Needed to interact with C for instance.\n  uint64_t value() const { return uint64_t(1) << ShiftValue; }\n\n  /// Returns a default constructed Align which corresponds to no alignment.\n  /// It was decided to deprecate Align::None because it's too close to\n  /// llvm::None which can be used to initialize `MaybeAlign`.\n  /// MaybeAlign = llvm::None means unspecified alignment,\n  /// Align = Align::None() means alignment of one byte.\n  LLVM_ATTRIBUTE_DEPRECATED(constexpr static const Align None(),\n                            \"Use Align() or Align(1) instead\") {\n    return Align();\n  }\n\n  /// Allow constructions of constexpr Align.\n  template <size_t kValue> constexpr static LogValue Constant() {\n    return LogValue{static_cast<uint8_t>(CTLog2<kValue>())};\n  }\n\n  /// Allow constructions of constexpr Align from types.\n  /// Compile time equivalent to Align(alignof(T)).\n  template <typename T> constexpr static LogValue Of() {\n    return Constant<std::alignment_of<T>::value>();\n  }\n\n  /// Constexpr constructor from LogValue type.\n  constexpr Align(LogValue CA) : ShiftValue(CA.Log) {}\n};\n\n/// Treats the value 0 as a 1, so Align is always at least 1.\ninline Align assumeAligned(uint64_t Value) {\n  return Value ? Align(Value) : Align();\n}\n\n/// This struct is a compact representation of a valid (power of two) or\n/// undefined (0) alignment.\nstruct MaybeAlign : public llvm::Optional<Align> {\nprivate:\n  using UP = llvm::Optional<Align>;\n\npublic:\n  /// Default is undefined.\n  MaybeAlign() = default;\n  /// Do not perform checks in case of copy/move construct/assign, because the\n  /// checks have been performed when building `Other`.\n  MaybeAlign(const MaybeAlign &Other) = default;\n  MaybeAlign &operator=(const MaybeAlign &Other) = default;\n  MaybeAlign(MaybeAlign &&Other) = default;\n  MaybeAlign &operator=(MaybeAlign &&Other) = default;\n\n  /// Use llvm::Optional<Align> constructor.\n  using UP::UP;\n\n  explicit MaybeAlign(uint64_t Value) {\n    assert((Value == 0 || llvm::isPowerOf2_64(Value)) &&\n           \"Alignment is neither 0 nor a power of 2\");\n    if (Value)\n      emplace(Value);\n  }\n\n  /// For convenience, returns a valid alignment or 1 if undefined.\n  Align valueOrOne() const { return hasValue() ? getValue() : Align(); }\n};\n\n/// Checks that SizeInBytes is a multiple of the alignment.\ninline bool isAligned(Align Lhs, uint64_t SizeInBytes) {\n  return SizeInBytes % Lhs.value() == 0;\n}\n\n/// Checks that Addr is a multiple of the alignment.\ninline bool isAddrAligned(Align Lhs, const void *Addr) {\n  return isAligned(Lhs, reinterpret_cast<uintptr_t>(Addr));\n}\n\n/// Returns a multiple of A needed to store `Size` bytes.\ninline uint64_t alignTo(uint64_t Size, Align A) {\n  const uint64_t Value = A.value();\n  // The following line is equivalent to `(Size + Value - 1) / Value * Value`.\n\n  // The division followed by a multiplication can be thought of as a right\n  // shift followed by a left shift which zeros out the extra bits produced in\n  // the bump; `~(Value - 1)` is a mask where all those bits being zeroed out\n  // are just zero.\n\n  // Most compilers can generate this code but the pattern may be missed when\n  // multiple functions gets inlined.\n  return (Size + Value - 1) & ~(Value - 1U);\n}\n\n/// If non-zero \\p Skew is specified, the return value will be a minimal integer\n/// that is greater than or equal to \\p Size and equal to \\p A * N + \\p Skew for\n/// some integer N. If \\p Skew is larger than \\p A, its value is adjusted to '\\p\n/// Skew mod \\p A'.\n///\n/// Examples:\n/// \\code\n///   alignTo(5, Align(8), 7) = 7\n///   alignTo(17, Align(8), 1) = 17\n///   alignTo(~0LL, Align(8), 3) = 3\n/// \\endcode\ninline uint64_t alignTo(uint64_t Size, Align A, uint64_t Skew) {\n  const uint64_t Value = A.value();\n  Skew %= Value;\n  return ((Size + Value - 1 - Skew) & ~(Value - 1U)) + Skew;\n}\n\n/// Returns a multiple of A needed to store `Size` bytes.\n/// Returns `Size` if current alignment is undefined.\ninline uint64_t alignTo(uint64_t Size, MaybeAlign A) {\n  return A ? alignTo(Size, A.getValue()) : Size;\n}\n\n/// Aligns `Addr` to `Alignment` bytes, rounding up.\ninline uintptr_t alignAddr(const void *Addr, Align Alignment) {\n  uintptr_t ArithAddr = reinterpret_cast<uintptr_t>(Addr);\n  assert(static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >=\n             ArithAddr &&\n         \"Overflow\");\n  return alignTo(ArithAddr, Alignment);\n}\n\n/// Returns the offset to the next integer (mod 2**64) that is greater than\n/// or equal to \\p Value and is a multiple of \\p Align.\ninline uint64_t offsetToAlignment(uint64_t Value, Align Alignment) {\n  return alignTo(Value, Alignment) - Value;\n}\n\n/// Returns the necessary adjustment for aligning `Addr` to `Alignment`\n/// bytes, rounding up.\ninline uint64_t offsetToAlignedAddr(const void *Addr, Align Alignment) {\n  return offsetToAlignment(reinterpret_cast<uintptr_t>(Addr), Alignment);\n}\n\n/// Returns the log2 of the alignment.\ninline unsigned Log2(Align A) { return A.ShiftValue; }\n\n/// Returns the alignment that satisfies both alignments.\n/// Same semantic as MinAlign.\ninline Align commonAlignment(Align A, Align B) { return std::min(A, B); }\n\n/// Returns the alignment that satisfies both alignments.\n/// Same semantic as MinAlign.\ninline Align commonAlignment(Align A, uint64_t Offset) {\n  return Align(MinAlign(A.value(), Offset));\n}\n\n/// Returns the alignment that satisfies both alignments.\n/// Same semantic as MinAlign.\ninline MaybeAlign commonAlignment(MaybeAlign A, MaybeAlign B) {\n  return A && B ? commonAlignment(*A, *B) : A ? A : B;\n}\n\n/// Returns the alignment that satisfies both alignments.\n/// Same semantic as MinAlign.\ninline MaybeAlign commonAlignment(MaybeAlign A, uint64_t Offset) {\n  return MaybeAlign(MinAlign((*A).value(), Offset));\n}\n\n/// Returns a representation of the alignment that encodes undefined as 0.\ninline unsigned encode(MaybeAlign A) { return A ? A->ShiftValue + 1 : 0; }\n\n/// Dual operation of the encode function above.\ninline MaybeAlign decodeMaybeAlign(unsigned Value) {\n  if (Value == 0)\n    return MaybeAlign();\n  Align Out;\n  Out.ShiftValue = Value - 1;\n  return Out;\n}\n\n/// Returns a representation of the alignment, the encoded value is positive by\n/// definition.\ninline unsigned encode(Align A) { return encode(MaybeAlign(A)); }\n\n/// Comparisons between Align and scalars. Rhs must be positive.\ninline bool operator==(Align Lhs, uint64_t Rhs) {\n  ALIGN_CHECK_ISPOSITIVE(Rhs);\n  return Lhs.value() == Rhs;\n}\ninline bool operator!=(Align Lhs, uint64_t Rhs) {\n  ALIGN_CHECK_ISPOSITIVE(Rhs);\n  return Lhs.value() != Rhs;\n}\ninline bool operator<=(Align Lhs, uint64_t Rhs) {\n  ALIGN_CHECK_ISPOSITIVE(Rhs);\n  return Lhs.value() <= Rhs;\n}\ninline bool operator>=(Align Lhs, uint64_t Rhs) {\n  ALIGN_CHECK_ISPOSITIVE(Rhs);\n  return Lhs.value() >= Rhs;\n}\ninline bool operator<(Align Lhs, uint64_t Rhs) {\n  ALIGN_CHECK_ISPOSITIVE(Rhs);\n  return Lhs.value() < Rhs;\n}\ninline bool operator>(Align Lhs, uint64_t Rhs) {\n  ALIGN_CHECK_ISPOSITIVE(Rhs);\n  return Lhs.value() > Rhs;\n}\n\n/// Comparisons between MaybeAlign and scalars.\ninline bool operator==(MaybeAlign Lhs, uint64_t Rhs) {\n  return Lhs ? (*Lhs).value() == Rhs : Rhs == 0;\n}\ninline bool operator!=(MaybeAlign Lhs, uint64_t Rhs) {\n  return Lhs ? (*Lhs).value() != Rhs : Rhs != 0;\n}\n\n/// Comparisons operators between Align.\ninline bool operator==(Align Lhs, Align Rhs) {\n  return Lhs.ShiftValue == Rhs.ShiftValue;\n}\ninline bool operator!=(Align Lhs, Align Rhs) {\n  return Lhs.ShiftValue != Rhs.ShiftValue;\n}\ninline bool operator<=(Align Lhs, Align Rhs) {\n  return Lhs.ShiftValue <= Rhs.ShiftValue;\n}\ninline bool operator>=(Align Lhs, Align Rhs) {\n  return Lhs.ShiftValue >= Rhs.ShiftValue;\n}\ninline bool operator<(Align Lhs, Align Rhs) {\n  return Lhs.ShiftValue < Rhs.ShiftValue;\n}\ninline bool operator>(Align Lhs, Align Rhs) {\n  return Lhs.ShiftValue > Rhs.ShiftValue;\n}\n\n// Don't allow relational comparisons with MaybeAlign.\nbool operator<=(Align Lhs, MaybeAlign Rhs) = delete;\nbool operator>=(Align Lhs, MaybeAlign Rhs) = delete;\nbool operator<(Align Lhs, MaybeAlign Rhs) = delete;\nbool operator>(Align Lhs, MaybeAlign Rhs) = delete;\n\nbool operator<=(MaybeAlign Lhs, Align Rhs) = delete;\nbool operator>=(MaybeAlign Lhs, Align Rhs) = delete;\nbool operator<(MaybeAlign Lhs, Align Rhs) = delete;\nbool operator>(MaybeAlign Lhs, Align Rhs) = delete;\n\nbool operator<=(MaybeAlign Lhs, MaybeAlign Rhs) = delete;\nbool operator>=(MaybeAlign Lhs, MaybeAlign Rhs) = delete;\nbool operator<(MaybeAlign Lhs, MaybeAlign Rhs) = delete;\nbool operator>(MaybeAlign Lhs, MaybeAlign Rhs) = delete;\n\ninline Align operator*(Align Lhs, uint64_t Rhs) {\n  assert(Rhs > 0 && \"Rhs must be positive\");\n  return Align(Lhs.value() * Rhs);\n}\n\ninline MaybeAlign operator*(MaybeAlign Lhs, uint64_t Rhs) {\n  assert(Rhs > 0 && \"Rhs must be positive\");\n  return Lhs ? Lhs.getValue() * Rhs : MaybeAlign();\n}\n\ninline Align operator/(Align Lhs, uint64_t Divisor) {\n  assert(llvm::isPowerOf2_64(Divisor) &&\n         \"Divisor must be positive and a power of 2\");\n  assert(Lhs != 1 && \"Can't halve byte alignment\");\n  return Align(Lhs.value() / Divisor);\n}\n\ninline MaybeAlign operator/(MaybeAlign Lhs, uint64_t Divisor) {\n  assert(llvm::isPowerOf2_64(Divisor) &&\n         \"Divisor must be positive and a power of 2\");\n  return Lhs ? Lhs.getValue() / Divisor : MaybeAlign();\n}\n\ninline Align max(MaybeAlign Lhs, Align Rhs) {\n  return Lhs && *Lhs > Rhs ? *Lhs : Rhs;\n}\n\ninline Align max(Align Lhs, MaybeAlign Rhs) {\n  return Rhs && *Rhs > Lhs ? *Rhs : Lhs;\n}\n\n#ifndef NDEBUG\n// For usage in LLVM_DEBUG macros.\ninline std::string DebugStr(const Align &A) {\n  return std::to_string(A.value());\n}\n// For usage in LLVM_DEBUG macros.\ninline std::string DebugStr(const MaybeAlign &MA) {\n  if (MA)\n    return std::to_string(MA->value());\n  return \"None\";\n}\n#endif // NDEBUG\n\n#undef ALIGN_CHECK_ISPOSITIVE\n\n} // namespace llvm\n\n#endif // LLVM_SUPPORT_ALIGNMENT_H_\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ErrorOr.h", "content": "//===- llvm/Support/ErrorOr.h - Error Smart Pointer -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n///\n/// Provides ErrorOr<T> smart pointer.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ERROROR_H\n#define LLVM_SUPPORT_ERROROR_H\n\n#include \"llvm/Support/AlignOf.h\"\n#include <cassert>\n#include <system_error>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\n/// Represents either an error or a value T.\n///\n/// ErrorOr<T> is a pointer-like class that represents the result of an\n/// operation. The result is either an error, or a value of type T. This is\n/// designed to emulate the usage of returning a pointer where nullptr indicates\n/// failure. However instead of just knowing that the operation failed, we also\n/// have an error_code and optional user data that describes why it failed.\n///\n/// It is used like the following.\n/// \\code\n///   ErrorOr<Buffer> getBuffer();\n///\n///   auto buffer = getBuffer();\n///   if (error_code ec = buffer.getError())\n///     return ec;\n///   buffer->write(\"adena\");\n/// \\endcode\n///\n///\n/// Implicit conversion to bool returns true if there is a usable value. The\n/// unary * and -> operators provide pointer like access to the value. Accessing\n/// the value when there is an error has undefined behavior.\n///\n/// When T is a reference type the behavior is slightly different. The reference\n/// is held in a std::reference_wrapper<std::remove_reference<T>::type>, and\n/// there is special handling to make operator -> work as if T was not a\n/// reference.\n///\n/// T cannot be a rvalue reference.\ntemplate<class T>\nclass ErrorOr {\n  template <class OtherT> friend class ErrorOr;\n\n  static constexpr bool isRef = std::is_reference<T>::value;\n\n  using wrap = std::reference_wrapper<std::remove_reference_t<T>>;\n\npublic:\n  using storage_type = std::conditional_t<isRef, wrap, T>;\n\nprivate:\n  using reference = std::remove_reference_t<T> &;\n  using const_reference = const std::remove_reference_t<T> &;\n  using pointer = std::remove_reference_t<T> *;\n  using const_pointer = const std::remove_reference_t<T> *;\n\npublic:\n  template <class E>\n  ErrorOr(E ErrorCode,\n          std::enable_if_t<std::is_error_code_enum<E>::value ||\n                               std::is_error_condition_enum<E>::value,\n                           void *> = nullptr)\n      : HasError(true) {\n    new (getErrorStorage()) std::error_code(make_error_code(ErrorCode));\n  }\n\n  ErrorOr(std::error_code EC) : HasError(true) {\n    new (getErrorStorage()) std::error_code(EC);\n  }\n\n  template <class OtherT>\n  ErrorOr(OtherT &&Val,\n          std::enable_if_t<std::is_convertible<OtherT, T>::value> * = nullptr)\n      : HasError(false) {\n    new (getStorage()) storage_type(std::forward<OtherT>(Val));\n  }\n\n  ErrorOr(const ErrorOr &Other) {\n    copyConstruct(Other);\n  }\n\n  template <class OtherT>\n  ErrorOr(const ErrorOr<OtherT> &Other,\n          std::enable_if_t<std::is_convertible<OtherT, T>::value> * = nullptr) {\n    copyConstruct(Other);\n  }\n\n  template <class OtherT>\n  explicit ErrorOr(\n      const ErrorOr<OtherT> &Other,\n      std::enable_if_t<!std::is_convertible<OtherT, const T &>::value> * =\n          nullptr) {\n    copyConstruct(Other);\n  }\n\n  ErrorOr(ErrorOr &&Other) {\n    moveConstruct(std::move(Other));\n  }\n\n  template <class OtherT>\n  ErrorOr(ErrorOr<OtherT> &&Other,\n          std::enable_if_t<std::is_convertible<OtherT, T>::value> * = nullptr) {\n    moveConstruct(std::move(Other));\n  }\n\n  // This might eventually need SFINAE but it's more complex than is_convertible\n  // & I'm too lazy to write it right now.\n  template <class OtherT>\n  explicit ErrorOr(\n      ErrorOr<OtherT> &&Other,\n      std::enable_if_t<!std::is_convertible<OtherT, T>::value> * = nullptr) {\n    moveConstruct(std::move(Other));\n  }\n\n  ErrorOr &operator=(const ErrorOr &Other) {\n    copyAssign(Other);\n    return *this;\n  }\n\n  ErrorOr &operator=(ErrorOr &&Other) {\n    moveAssign(std::move(Other));\n    return *this;\n  }\n\n  ~ErrorOr() {\n    if (!HasError)\n      getStorage()->~storage_type();\n  }\n\n  /// Return false if there is an error.\n  explicit operator bool() const {\n    return !HasError;\n  }\n\n  reference get() { return *getStorage(); }\n  const_reference get() const { return const_cast<ErrorOr<T> *>(this)->get(); }\n\n  std::error_code getError() const {\n    return HasError ? *getErrorStorage() : std::error_code();\n  }\n\n  pointer operator ->() {\n    return toPointer(getStorage());\n  }\n\n  const_pointer operator->() const { return toPointer(getStorage()); }\n\n  reference operator *() {\n    return *getStorage();\n  }\n\n  const_reference operator*() const { return *getStorage(); }\n\nprivate:\n  template <class OtherT>\n  void copyConstruct(const ErrorOr<OtherT> &Other) {\n    if (!Other.HasError) {\n      // Get the other value.\n      HasError = false;\n      new (getStorage()) storage_type(*Other.getStorage());\n    } else {\n      // Get other's error.\n      HasError = true;\n      new (getErrorStorage()) std::error_code(Other.getError());\n    }\n  }\n\n  template <class T1>\n  static bool compareThisIfSameType(const T1 &a, const T1 &b) {\n    return &a == &b;\n  }\n\n  template <class T1, class T2>\n  static bool compareThisIfSameType(const T1 &a, const T2 &b) {\n    return false;\n  }\n\n  template <class OtherT>\n  void copyAssign(const ErrorOr<OtherT> &Other) {\n    if (compareThisIfSameType(*this, Other))\n      return;\n\n    this->~ErrorOr();\n    new (this) ErrorOr(Other);\n  }\n\n  template <class OtherT>\n  void moveConstruct(ErrorOr<OtherT> &&Other) {\n    if (!Other.HasError) {\n      // Get the other value.\n      HasError = false;\n      new (getStorage()) storage_type(std::move(*Other.getStorage()));\n    } else {\n      // Get other's error.\n      HasError = true;\n      new (getErrorStorage()) std::error_code(Other.getError());\n    }\n  }\n\n  template <class OtherT>\n  void moveAssign(ErrorOr<OtherT> &&Other) {\n    if (compareThisIfSameType(*this, Other))\n      return;\n\n    this->~ErrorOr();\n    new (this) ErrorOr(std::move(Other));\n  }\n\n  pointer toPointer(pointer Val) {\n    return Val;\n  }\n\n  const_pointer toPointer(const_pointer Val) const { return Val; }\n\n  pointer toPointer(wrap *Val) {\n    return &Val->get();\n  }\n\n  const_pointer toPointer(const wrap *Val) const { return &Val->get(); }\n\n  storage_type *getStorage() {\n    assert(!HasError && \"Cannot get value when an error exists!\");\n    return reinterpret_cast<storage_type *>(&TStorage);\n  }\n\n  const storage_type *getStorage() const {\n    assert(!HasError && \"Cannot get value when an error exists!\");\n    return reinterpret_cast<const storage_type *>(&TStorage);\n  }\n\n  std::error_code *getErrorStorage() {\n    assert(HasError && \"Cannot get error when a value exists!\");\n    return reinterpret_cast<std::error_code *>(&ErrorStorage);\n  }\n\n  const std::error_code *getErrorStorage() const {\n    return const_cast<ErrorOr<T> *>(this)->getErrorStorage();\n  }\n\n  union {\n    AlignedCharArrayUnion<storage_type> TStorage;\n    AlignedCharArrayUnion<std::error_code> ErrorStorage;\n  };\n  bool HasError : 1;\n};\n\ntemplate <class T, class E>\nstd::enable_if_t<std::is_error_code_enum<E>::value ||\n                     std::is_error_condition_enum<E>::value,\n                 bool>\noperator==(const ErrorOr<T> &Err, E Code) {\n  return Err.getError() == Code;\n}\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_ERROROR_H\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "content": "//===- llvm/Support/FileSystem.h - File System OS Concept -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the llvm::sys::fs namespace. It is designed after\n// TR2/boost filesystem (v3), but modified to remove exception handling and the\n// path class.\n//\n// All functions return an error_code and their actual work via the last out\n// argument. The out argument is defined if and only if errc::success is\n// returned. A function may return any error code in the generic or system\n// category. However, they shall be equivalent to any error conditions listed\n// in each functions respective documentation if the condition applies. [ note:\n// this does not guarantee that error_code will be in the set of explicitly\n// listed codes, but it does guarantee that if any of the explicitly listed\n// errors occur, the correct error_code will be used ]. All functions may\n// return errc::not_enough_memory if there is not enough memory to complete the\n// operation.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_FILESYSTEM_H\n#define LLVM_SUPPORT_FILESYSTEM_H\n\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/Support/Chrono.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/FileSystem/UniqueID.h\"\n#include \"llvm/Support/MD5.h\"\n#include <cassert>\n#include <cstdint>\n#include <ctime>\n#include <memory>\n#include <stack>\n#include <string>\n#include <system_error>\n#include <vector>\n\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n\nnamespace llvm {\nnamespace sys {\nnamespace fs {\n\n#if defined(_WIN32)\n// A Win32 HANDLE is a typedef of void*\nusing file_t = void *;\n#else\nusing file_t = int;\n#endif\n\nextern const file_t kInvalidFile;\n\n/// An enumeration for the file system's view of the type.\nenum class file_type {\n  status_error,\n  file_not_found,\n  regular_file,\n  directory_file,\n  symlink_file,\n  block_file,\n  character_file,\n  fifo_file,\n  socket_file,\n  type_unknown\n};\n\n/// space_info - Self explanatory.\nstruct space_info {\n  uint64_t capacity;\n  uint64_t free;\n  uint64_t available;\n};\n\nenum perms {\n  no_perms = 0,\n  owner_read = 0400,\n  owner_write = 0200,\n  owner_exe = 0100,\n  owner_all = owner_read | owner_write | owner_exe,\n  group_read = 040,\n  group_write = 020,\n  group_exe = 010,\n  group_all = group_read | group_write | group_exe,\n  others_read = 04,\n  others_write = 02,\n  others_exe = 01,\n  others_all = others_read | others_write | others_exe,\n  all_read = owner_read | group_read | others_read,\n  all_write = owner_write | group_write | others_write,\n  all_exe = owner_exe | group_exe | others_exe,\n  all_all = owner_all | group_all | others_all,\n  set_uid_on_exe = 04000,\n  set_gid_on_exe = 02000,\n  sticky_bit = 01000,\n  all_perms = all_all | set_uid_on_exe | set_gid_on_exe | sticky_bit,\n  perms_not_known = 0xFFFF\n};\n\n// Helper functions so that you can use & and | to manipulate perms bits:\ninline perms operator|(perms l, perms r) {\n  return static_cast<perms>(static_cast<unsigned short>(l) |\n                            static_cast<unsigned short>(r));\n}\ninline perms operator&(perms l, perms r) {\n  return static_cast<perms>(static_cast<unsigned short>(l) &\n                            static_cast<unsigned short>(r));\n}\ninline perms &operator|=(perms &l, perms r) {\n  l = l | r;\n  return l;\n}\ninline perms &operator&=(perms &l, perms r) {\n  l = l & r;\n  return l;\n}\ninline perms operator~(perms x) {\n  // Avoid UB by explicitly truncating the (unsigned) ~ result.\n  return static_cast<perms>(\n      static_cast<unsigned short>(~static_cast<unsigned short>(x)));\n}\n\n/// Represents the result of a call to directory_iterator::status(). This is a\n/// subset of the information returned by a regular sys::fs::status() call, and\n/// represents the information provided by Windows FileFirstFile/FindNextFile.\nclass basic_file_status {\nprotected:\n  #if defined(LLVM_ON_UNIX)\n  time_t fs_st_atime = 0;\n  time_t fs_st_mtime = 0;\n  uint32_t fs_st_atime_nsec = 0;\n  uint32_t fs_st_mtime_nsec = 0;\n  uid_t fs_st_uid = 0;\n  gid_t fs_st_gid = 0;\n  off_t fs_st_size = 0;\n  #elif defined (_WIN32)\n  uint32_t LastAccessedTimeHigh = 0;\n  uint32_t LastAccessedTimeLow = 0;\n  uint32_t LastWriteTimeHigh = 0;\n  uint32_t LastWriteTimeLow = 0;\n  uint32_t FileSizeHigh = 0;\n  uint32_t FileSizeLow = 0;\n  #endif\n  file_type Type = file_type::status_error;\n  perms Perms = perms_not_known;\n\npublic:\n  basic_file_status() = default;\n\n  explicit basic_file_status(file_type Type) : Type(Type) {}\n\n  #if defined(LLVM_ON_UNIX)\n  basic_file_status(file_type Type, perms Perms, time_t ATime,\n                    uint32_t ATimeNSec, time_t MTime, uint32_t MTimeNSec,\n                    uid_t UID, gid_t GID, off_t Size)\n      : fs_st_atime(ATime), fs_st_mtime(MTime),\n        fs_st_atime_nsec(ATimeNSec), fs_st_mtime_nsec(MTimeNSec),\n        fs_st_uid(UID), fs_st_gid(GID),\n        fs_st_size(Size), Type(Type), Perms(Perms) {}\n#elif defined(_WIN32)\n  basic_file_status(file_type Type, perms Perms, uint32_t LastAccessTimeHigh,\n                    uint32_t LastAccessTimeLow, uint32_t LastWriteTimeHigh,\n                    uint32_t LastWriteTimeLow, uint32_t FileSizeHigh,\n                    uint32_t FileSizeLow)\n      : LastAccessedTimeHigh(LastAccessTimeHigh),\n        LastAccessedTimeLow(LastAccessTimeLow),\n        LastWriteTimeHigh(LastWriteTimeHigh),\n        LastWriteTimeLow(LastWriteTimeLow), FileSizeHigh(FileSizeHigh),\n        FileSizeLow(FileSizeLow), Type(Type), Perms(Perms) {}\n  #endif\n\n  // getters\n  file_type type() const { return Type; }\n  perms permissions() const { return Perms; }\n\n  /// The file access time as reported from the underlying file system.\n  ///\n  /// Also see comments on \\c getLastModificationTime() related to the precision\n  /// of the returned value.\n  TimePoint<> getLastAccessedTime() const;\n\n  /// The file modification time as reported from the underlying file system.\n  ///\n  /// The returned value allows for nanosecond precision but the actual\n  /// resolution is an implementation detail of the underlying file system.\n  /// There is no guarantee for what kind of resolution you can expect, the\n  /// resolution can differ across platforms and even across mountpoints on the\n  /// same machine.\n  TimePoint<> getLastModificationTime() const;\n\n  #if defined(LLVM_ON_UNIX)\n  uint32_t getUser() const { return fs_st_uid; }\n  uint32_t getGroup() const { return fs_st_gid; }\n  uint64_t getSize() const { return fs_st_size; }\n  #elif defined (_WIN32)\n  uint32_t getUser() const {\n    return 9999; // Not applicable to Windows, so...\n  }\n\n  uint32_t getGroup() const {\n    return 9999; // Not applicable to Windows, so...\n  }\n\n  uint64_t getSize() const {\n    return (uint64_t(FileSizeHigh) << 32) + FileSizeLow;\n  }\n  #endif\n\n  // setters\n  void type(file_type v) { Type = v; }\n  void permissions(perms p) { Perms = p; }\n};\n\n/// Represents the result of a call to sys::fs::status().\nclass file_status : public basic_file_status {\n  friend bool equivalent(file_status A, file_status B);\n\n  #if defined(LLVM_ON_UNIX)\n  dev_t fs_st_dev = 0;\n  nlink_t fs_st_nlinks = 0;\n  ino_t fs_st_ino = 0;\n  #elif defined (_WIN32)\n  uint32_t NumLinks = 0;\n  uint32_t VolumeSerialNumber = 0;\n  uint32_t FileIndexHigh = 0;\n  uint32_t FileIndexLow = 0;\n  #endif\n\npublic:\n  file_status() = default;\n\n  explicit file_status(file_type Type) : basic_file_status(Type) {}\n\n  #if defined(LLVM_ON_UNIX)\n  file_status(file_type Type, perms Perms, dev_t Dev, nlink_t Links, ino_t Ino,\n              time_t ATime, uint32_t ATimeNSec,\n              time_t MTime, uint32_t MTimeNSec,\n              uid_t UID, gid_t GID, off_t Size)\n      : basic_file_status(Type, Perms, ATime, ATimeNSec, MTime, MTimeNSec,\n                          UID, GID, Size),\n        fs_st_dev(Dev), fs_st_nlinks(Links), fs_st_ino(Ino) {}\n  #elif defined(_WIN32)\n  file_status(file_type Type, perms Perms, uint32_t LinkCount,\n              uint32_t LastAccessTimeHigh, uint32_t LastAccessTimeLow,\n              uint32_t LastWriteTimeHigh, uint32_t LastWriteTimeLow,\n              uint32_t VolumeSerialNumber, uint32_t FileSizeHigh,\n              uint32_t FileSizeLow, uint32_t FileIndexHigh,\n              uint32_t FileIndexLow)\n      : basic_file_status(Type, Perms, LastAccessTimeHigh, LastAccessTimeLow,\n                          LastWriteTimeHigh, LastWriteTimeLow, FileSizeHigh,\n                          FileSizeLow),\n        NumLinks(LinkCount), VolumeSerialNumber(VolumeSerialNumber),\n        FileIndexHigh(FileIndexHigh), FileIndexLow(FileIndexLow) {}\n  #endif\n\n  UniqueID getUniqueID() const;\n  uint32_t getLinkCount() const;\n};\n\n/// @}\n/// @name Physical Operators\n/// @{\n\n/// Make \\a path an absolute path.\n///\n/// Makes \\a path absolute using the \\a current_directory if it is not already.\n/// An empty \\a path will result in the \\a current_directory.\n///\n/// /absolute/path   => /absolute/path\n/// relative/../path => <current-directory>/relative/../path\n///\n/// @param path A path that is modified to be an absolute path.\nvoid make_absolute(const Twine &current_directory, SmallVectorImpl<char> &path);\n\n/// Make \\a path an absolute path.\n///\n/// Makes \\a path absolute using the current directory if it is not already. An\n/// empty \\a path will result in the current directory.\n///\n/// /absolute/path   => /absolute/path\n/// relative/../path => <current-directory>/relative/../path\n///\n/// @param path A path that is modified to be an absolute path.\n/// @returns errc::success if \\a path has been made absolute, otherwise a\n///          platform-specific error_code.\nstd::error_code make_absolute(SmallVectorImpl<char> &path);\n\n/// Create all the non-existent directories in path.\n///\n/// @param path Directories to create.\n/// @returns errc::success if is_directory(path), otherwise a platform\n///          specific error_code. If IgnoreExisting is false, also returns\n///          error if the directory already existed.\nstd::error_code create_directories(const Twine &path,\n                                   bool IgnoreExisting = true,\n                                   perms Perms = owner_all | group_all);\n\n/// Create the directory in path.\n///\n/// @param path Directory to create.\n/// @returns errc::success if is_directory(path), otherwise a platform\n///          specific error_code. If IgnoreExisting is false, also returns\n///          error if the directory already existed.\nstd::error_code create_directory(const Twine &path, bool IgnoreExisting = true,\n                                 perms Perms = owner_all | group_all);\n\n/// Create a link from \\a from to \\a to.\n///\n/// The link may be a soft or a hard link, depending on the platform. The caller\n/// may not assume which one. Currently on windows it creates a hard link since\n/// soft links require extra privileges. On unix, it creates a soft link since\n/// hard links don't work on SMB file systems.\n///\n/// @param to The path to hard link to.\n/// @param from The path to hard link from. This is created.\n/// @returns errc::success if the link was created, otherwise a platform\n/// specific error_code.\nstd::error_code create_link(const Twine &to, const Twine &from);\n\n/// Create a hard link from \\a from to \\a to, or return an error.\n///\n/// @param to The path to hard link to.\n/// @param from The path to hard link from. This is created.\n/// @returns errc::success if the link was created, otherwise a platform\n/// specific error_code.\nstd::error_code create_hard_link(const Twine &to, const Twine &from);\n\n/// Collapse all . and .. patterns, resolve all symlinks, and optionally\n///        expand ~ expressions to the user's home directory.\n///\n/// @param path The path to resolve.\n/// @param output The location to store the resolved path.\n/// @param expand_tilde If true, resolves ~ expressions to the user's home\n///                     directory.\nstd::error_code real_path(const Twine &path, SmallVectorImpl<char> &output,\n                          bool expand_tilde = false);\n\n/// Expands ~ expressions to the user's home directory. On Unix ~user\n/// directories are resolved as well.\n///\n/// @param path The path to resolve.\nvoid expand_tilde(const Twine &path, SmallVectorImpl<char> &output);\n\n/// Get the current path.\n///\n/// @param result Holds the current path on return.\n/// @returns errc::success if the current path has been stored in result,\n///          otherwise a platform-specific error_code.\nstd::error_code current_path(SmallVectorImpl<char> &result);\n\n/// Set the current path.\n///\n/// @param path The path to set.\n/// @returns errc::success if the current path was successfully set,\n///          otherwise a platform-specific error_code.\nstd::error_code set_current_path(const Twine &path);\n\n/// Remove path. Equivalent to POSIX remove().\n///\n/// @param path Input path.\n/// @returns errc::success if path has been removed or didn't exist, otherwise a\n///          platform-specific error code. If IgnoreNonExisting is false, also\n///          returns error if the file didn't exist.\nstd::error_code remove(const Twine &path, bool IgnoreNonExisting = true);\n\n/// Recursively delete a directory.\n///\n/// @param path Input path.\n/// @returns errc::success if path has been removed or didn't exist, otherwise a\n///          platform-specific error code.\nstd::error_code remove_directories(const Twine &path, bool IgnoreErrors = true);\n\n/// Rename \\a from to \\a to.\n///\n/// Files are renamed as if by POSIX rename(), except that on Windows there may\n/// be a short interval of time during which the destination file does not\n/// exist.\n///\n/// @param from The path to rename from.\n/// @param to The path to rename to. This is created.\nstd::error_code rename(const Twine &from, const Twine &to);\n\n/// Copy the contents of \\a From to \\a To.\n///\n/// @param From The path to copy from.\n/// @param To The path to copy to. This is created.\nstd::error_code copy_file(const Twine &From, const Twine &To);\n\n/// Copy the contents of \\a From to \\a To.\n///\n/// @param From The path to copy from.\n/// @param ToFD The open file descriptor of the destination file.\nstd::error_code copy_file(const Twine &From, int ToFD);\n\n/// Resize path to size. File is resized as if by POSIX truncate().\n///\n/// @param FD Input file descriptor.\n/// @param Size Size to resize to.\n/// @returns errc::success if \\a path has been resized to \\a size, otherwise a\n///          platform-specific error_code.\nstd::error_code resize_file(int FD, uint64_t Size);\n\n/// Compute an MD5 hash of a file's contents.\n///\n/// @param FD Input file descriptor.\n/// @returns An MD5Result with the hash computed, if successful, otherwise a\n///          std::error_code.\nErrorOr<MD5::MD5Result> md5_contents(int FD);\n\n/// Version of compute_md5 that doesn't require an open file descriptor.\nErrorOr<MD5::MD5Result> md5_contents(const Twine &Path);\n\n/// @}\n/// @name Physical Observers\n/// @{\n\n/// Does file exist?\n///\n/// @param status A basic_file_status previously returned from stat.\n/// @returns True if the file represented by status exists, false if it does\n///          not.\nbool exists(const basic_file_status &status);\n\nenum class AccessMode { Exist, Write, Execute };\n\n/// Can the file be accessed?\n///\n/// @param Path Input path.\n/// @returns errc::success if the path can be accessed, otherwise a\n///          platform-specific error_code.\nstd::error_code access(const Twine &Path, AccessMode Mode);\n\n/// Does file exist?\n///\n/// @param Path Input path.\n/// @returns True if it exists, false otherwise.\ninline bool exists(const Twine &Path) {\n  return !access(Path, AccessMode::Exist);\n}\n\n/// Can we execute this file?\n///\n/// @param Path Input path.\n/// @returns True if we can execute it, false otherwise.\nbool can_execute(const Twine &Path);\n\n/// Can we write this file?\n///\n/// @param Path Input path.\n/// @returns True if we can write to it, false otherwise.\ninline bool can_write(const Twine &Path) {\n  return !access(Path, AccessMode::Write);\n}\n\n/// Do file_status's represent the same thing?\n///\n/// @param A Input file_status.\n/// @param B Input file_status.\n///\n/// assert(status_known(A) || status_known(B));\n///\n/// @returns True if A and B both represent the same file system entity, false\n///          otherwise.\nbool equivalent(file_status A, file_status B);\n\n/// Do paths represent the same thing?\n///\n/// assert(status_known(A) || status_known(B));\n///\n/// @param A Input path A.\n/// @param B Input path B.\n/// @param result Set to true if stat(A) and stat(B) have the same device and\n///               inode (or equivalent).\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code equivalent(const Twine &A, const Twine &B, bool &result);\n\n/// Simpler version of equivalent for clients that don't need to\n///        differentiate between an error and false.\ninline bool equivalent(const Twine &A, const Twine &B) {\n  bool result;\n  return !equivalent(A, B, result) && result;\n}\n\n/// Is the file mounted on a local filesystem?\n///\n/// @param path Input path.\n/// @param result Set to true if \\a path is on fixed media such as a hard disk,\n///               false if it is not.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform specific error_code.\nstd::error_code is_local(const Twine &path, bool &result);\n\n/// Version of is_local accepting an open file descriptor.\nstd::error_code is_local(int FD, bool &result);\n\n/// Simpler version of is_local for clients that don't need to\n///        differentiate between an error and false.\ninline bool is_local(const Twine &Path) {\n  bool Result;\n  return !is_local(Path, Result) && Result;\n}\n\n/// Simpler version of is_local accepting an open file descriptor for\n///        clients that don't need to differentiate between an error and false.\ninline bool is_local(int FD) {\n  bool Result;\n  return !is_local(FD, Result) && Result;\n}\n\n/// Does status represent a directory?\n///\n/// @param Path The path to get the type of.\n/// @param Follow For symbolic links, indicates whether to return the file type\n///               of the link itself, or of the target.\n/// @returns A value from the file_type enumeration indicating the type of file.\nfile_type get_file_type(const Twine &Path, bool Follow = true);\n\n/// Does status represent a directory?\n///\n/// @param status A basic_file_status previously returned from status.\n/// @returns status.type() == file_type::directory_file.\nbool is_directory(const basic_file_status &status);\n\n/// Is path a directory?\n///\n/// @param path Input path.\n/// @param result Set to true if \\a path is a directory (after following\n///               symlinks, false if it is not. Undefined otherwise.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code is_directory(const Twine &path, bool &result);\n\n/// Simpler version of is_directory for clients that don't need to\n///        differentiate between an error and false.\ninline bool is_directory(const Twine &Path) {\n  bool Result;\n  return !is_directory(Path, Result) && Result;\n}\n\n/// Does status represent a regular file?\n///\n/// @param status A basic_file_status previously returned from status.\n/// @returns status_known(status) && status.type() == file_type::regular_file.\nbool is_regular_file(const basic_file_status &status);\n\n/// Is path a regular file?\n///\n/// @param path Input path.\n/// @param result Set to true if \\a path is a regular file (after following\n///               symlinks), false if it is not. Undefined otherwise.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code is_regular_file(const Twine &path, bool &result);\n\n/// Simpler version of is_regular_file for clients that don't need to\n///        differentiate between an error and false.\ninline bool is_regular_file(const Twine &Path) {\n  bool Result;\n  if (is_regular_file(Path, Result))\n    return false;\n  return Result;\n}\n\n/// Does status represent a symlink file?\n///\n/// @param status A basic_file_status previously returned from status.\n/// @returns status_known(status) && status.type() == file_type::symlink_file.\nbool is_symlink_file(const basic_file_status &status);\n\n/// Is path a symlink file?\n///\n/// @param path Input path.\n/// @param result Set to true if \\a path is a symlink file, false if it is not.\n///               Undefined otherwise.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code is_symlink_file(const Twine &path, bool &result);\n\n/// Simpler version of is_symlink_file for clients that don't need to\n///        differentiate between an error and false.\ninline bool is_symlink_file(const Twine &Path) {\n  bool Result;\n  if (is_symlink_file(Path, Result))\n    return false;\n  return Result;\n}\n\n/// Does this status represent something that exists but is not a\n///        directory or regular file?\n///\n/// @param status A basic_file_status previously returned from status.\n/// @returns exists(s) && !is_regular_file(s) && !is_directory(s)\nbool is_other(const basic_file_status &status);\n\n/// Is path something that exists but is not a directory,\n///        regular file, or symlink?\n///\n/// @param path Input path.\n/// @param result Set to true if \\a path exists, but is not a directory, regular\n///               file, or a symlink, false if it does not. Undefined otherwise.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code is_other(const Twine &path, bool &result);\n\n/// Get file status as if by POSIX stat().\n///\n/// @param path Input path.\n/// @param result Set to the file status.\n/// @param follow When true, follows symlinks.  Otherwise, the symlink itself is\n///               statted.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code status(const Twine &path, file_status &result,\n                       bool follow = true);\n\n/// A version for when a file descriptor is already available.\nstd::error_code status(int FD, file_status &Result);\n\n#ifdef _WIN32\n/// A version for when a file descriptor is already available.\nstd::error_code status(file_t FD, file_status &Result);\n#endif\n\n/// Get file creation mode mask of the process.\n///\n/// @returns Mask reported by umask(2)\n/// @note There is no umask on Windows. This function returns 0 always\n///       on Windows. This function does not return an error_code because\n///       umask(2) never fails. It is not thread safe.\nunsigned getUmask();\n\n/// Set file permissions.\n///\n/// @param Path File to set permissions on.\n/// @param Permissions New file permissions.\n/// @returns errc::success if the permissions were successfully set, otherwise\n///          a platform-specific error_code.\n/// @note On Windows, all permissions except *_write are ignored. Using any of\n///       owner_write, group_write, or all_write will make the file writable.\n///       Otherwise, the file will be marked as read-only.\nstd::error_code setPermissions(const Twine &Path, perms Permissions);\n\n/// Vesion of setPermissions accepting a file descriptor.\n/// TODO Delete the path based overload once we implement the FD based overload\n/// on Windows.\nstd::error_code setPermissions(int FD, perms Permissions);\n\n/// Get file permissions.\n///\n/// @param Path File to get permissions from.\n/// @returns the permissions if they were successfully retrieved, otherwise a\n///          platform-specific error_code.\n/// @note On Windows, if the file does not have the FILE_ATTRIBUTE_READONLY\n///       attribute, all_all will be returned. Otherwise, all_read | all_exe\n///       will be returned.\nErrorOr<perms> getPermissions(const Twine &Path);\n\n/// Get file size.\n///\n/// @param Path Input path.\n/// @param Result Set to the size of the file in \\a Path.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\ninline std::error_code file_size(const Twine &Path, uint64_t &Result) {\n  file_status Status;\n  std::error_code EC = status(Path, Status);\n  if (EC)\n    return EC;\n  Result = Status.getSize();\n  return std::error_code();\n}\n\n/// Set the file modification and access time.\n///\n/// @returns errc::success if the file times were successfully set, otherwise a\n///          platform-specific error_code or errc::function_not_supported on\n///          platforms where the functionality isn't available.\nstd::error_code setLastAccessAndModificationTime(int FD, TimePoint<> AccessTime,\n                                                 TimePoint<> ModificationTime);\n\n/// Simpler version that sets both file modification and access time to the same\n/// time.\ninline std::error_code setLastAccessAndModificationTime(int FD,\n                                                        TimePoint<> Time) {\n  return setLastAccessAndModificationTime(FD, Time, Time);\n}\n\n/// Is status available?\n///\n/// @param s Input file status.\n/// @returns True if status() != status_error.\nbool status_known(const basic_file_status &s);\n\n/// Is status available?\n///\n/// @param path Input path.\n/// @param result Set to true if status() != status_error.\n/// @returns errc::success if result has been successfully set, otherwise a\n///          platform-specific error_code.\nstd::error_code status_known(const Twine &path, bool &result);\n\nenum CreationDisposition : unsigned {\n  /// CD_CreateAlways - When opening a file:\n  ///   * If it already exists, truncate it.\n  ///   * If it does not already exist, create a new file.\n  CD_CreateAlways = 0,\n\n  /// CD_CreateNew - When opening a file:\n  ///   * If it already exists, fail.\n  ///   * If it does not already exist, create a new file.\n  CD_CreateNew = 1,\n\n  /// CD_OpenExisting - When opening a file:\n  ///   * If it already exists, open the file with the offset set to 0.\n  ///   * If it does not already exist, fail.\n  CD_OpenExisting = 2,\n\n  /// CD_OpenAlways - When opening a file:\n  ///   * If it already exists, open the file with the offset set to 0.\n  ///   * If it does not already exist, create a new file.\n  CD_OpenAlways = 3,\n};\n\nenum FileAccess : unsigned {\n  FA_Read = 1,\n  FA_Write = 2,\n};\n\nenum OpenFlags : unsigned {\n  OF_None = 0,\n  F_None = 0, // For compatibility\n\n  /// The file should be opened in text mode on platforms that make this\n  /// distinction.\n  OF_Text = 1,\n  F_Text = 1, // For compatibility\n\n  /// The file should be opened in append mode.\n  OF_Append = 2,\n  F_Append = 2, // For compatibility\n\n  /// Delete the file on close. Only makes a difference on windows.\n  OF_Delete = 4,\n\n  /// When a child process is launched, this file should remain open in the\n  /// child process.\n  OF_ChildInherit = 8,\n\n  /// Force files Atime to be updated on access. Only makes a difference on windows.\n  OF_UpdateAtime = 16,\n};\n\n/// Create a potentially unique file name but does not create it.\n///\n/// Generates a unique path suitable for a temporary file but does not\n/// open or create the file. The name is based on \\a Model with '%'\n/// replaced by a random char in [0-9a-f]. If \\a MakeAbsolute is true\n/// then the system's temp directory is prepended first. If \\a MakeAbsolute\n/// is false the current directory will be used instead.\n///\n/// This function does not check if the file exists. If you want to be sure\n/// that the file does not yet exist, you should use use enough '%' characters\n/// in your model to ensure this. Each '%' gives 4-bits of entropy so you can\n/// use 32 of them to get 128 bits of entropy.\n///\n/// Example: clang-%%-%%-%%-%%-%%.s => clang-a0-b1-c2-d3-e4.s\n///\n/// @param Model Name to base unique path off of.\n/// @param ResultPath Set to the file's path.\n/// @param MakeAbsolute Whether to use the system temp directory.\nvoid createUniquePath(const Twine &Model, SmallVectorImpl<char> &ResultPath,\n                      bool MakeAbsolute);\n\n/// Create a uniquely named file.\n///\n/// Generates a unique path suitable for a temporary file and then opens it as a\n/// file. The name is based on \\a Model with '%' replaced by a random char in\n/// [0-9a-f]. If \\a Model is not an absolute path, the temporary file will be\n/// created in the current directory.\n///\n/// Example: clang-%%-%%-%%-%%-%%.s => clang-a0-b1-c2-d3-e4.s\n///\n/// This is an atomic operation. Either the file is created and opened, or the\n/// file system is left untouched.\n///\n/// The intended use is for files that are to be kept, possibly after\n/// renaming them. For example, when running 'clang -c foo.o', the file can\n/// be first created as foo-abc123.o and then renamed.\n///\n/// @param Model Name to base unique path off of.\n/// @param ResultFD Set to the opened file's file descriptor.\n/// @param ResultPath Set to the opened file's absolute path.\n/// @returns errc::success if Result{FD,Path} have been successfully set,\n///          otherwise a platform-specific error_code.\nstd::error_code createUniqueFile(const Twine &Model, int &ResultFD,\n                                 SmallVectorImpl<char> &ResultPath,\n                                 unsigned Mode = all_read | all_write);\n\n/// Simpler version for clients that don't want an open file. An empty\n/// file will still be created.\nstd::error_code createUniqueFile(const Twine &Model,\n                                 SmallVectorImpl<char> &ResultPath,\n                                 unsigned Mode = all_read | all_write);\n\n/// Represents a temporary file.\n///\n/// The temporary file must be eventually discarded or given a final name and\n/// kept.\n///\n/// The destructor doesn't implicitly discard because there is no way to\n/// properly handle errors in a destructor.\nclass TempFile {\n  bool Done = false;\n  TempFile(StringRef Name, int FD);\n\npublic:\n  /// This creates a temporary file with createUniqueFile and schedules it for\n  /// deletion with sys::RemoveFileOnSignal.\n  static Expected<TempFile> create(const Twine &Model,\n                                   unsigned Mode = all_read | all_write);\n  TempFile(TempFile &&Other);\n  TempFile &operator=(TempFile &&Other);\n\n  // Name of the temporary file.\n  std::string TmpName;\n\n  // The open file descriptor.\n  int FD = -1;\n\n  // Keep this with the given name.\n  Error keep(const Twine &Name);\n\n  // Keep this with the temporary name.\n  Error keep();\n\n  // Delete the file.\n  Error discard();\n\n  // This checks that keep or delete was called.\n  ~TempFile();\n};\n\n/// Create a file in the system temporary directory.\n///\n/// The filename is of the form prefix-random_chars.suffix. Since the directory\n/// is not know to the caller, Prefix and Suffix cannot have path separators.\n/// The files are created with mode 0600.\n///\n/// This should be used for things like a temporary .s that is removed after\n/// running the assembler.\nstd::error_code createTemporaryFile(const Twine &Prefix, StringRef Suffix,\n                                    int &ResultFD,\n                                    SmallVectorImpl<char> &ResultPath);\n\n/// Simpler version for clients that don't want an open file. An empty\n/// file will still be created.\nstd::error_code createTemporaryFile(const Twine &Prefix, StringRef Suffix,\n                                    SmallVectorImpl<char> &ResultPath);\n\nstd::error_code createUniqueDirectory(const Twine &Prefix,\n                                      SmallVectorImpl<char> &ResultPath);\n\n/// Get a unique name, not currently exisiting in the filesystem. Subject\n/// to race conditions, prefer to use createUniqueFile instead.\n///\n/// Similar to createUniqueFile, but instead of creating a file only\n/// checks if it exists. This function is subject to race conditions, if you\n/// want to use the returned name to actually create a file, use\n/// createUniqueFile instead.\nstd::error_code getPotentiallyUniqueFileName(const Twine &Model,\n                                             SmallVectorImpl<char> &ResultPath);\n\n/// Get a unique temporary file name, not currently exisiting in the\n/// filesystem. Subject to race conditions, prefer to use createTemporaryFile\n/// instead.\n///\n/// Similar to createTemporaryFile, but instead of creating a file only\n/// checks if it exists. This function is subject to race conditions, if you\n/// want to use the returned name to actually create a file, use\n/// createTemporaryFile instead.\nstd::error_code\ngetPotentiallyUniqueTempFileName(const Twine &Prefix, StringRef Suffix,\n                                 SmallVectorImpl<char> &ResultPath);\n\ninline OpenFlags operator|(OpenFlags A, OpenFlags B) {\n  return OpenFlags(unsigned(A) | unsigned(B));\n}\n\ninline OpenFlags &operator|=(OpenFlags &A, OpenFlags B) {\n  A = A | B;\n  return A;\n}\n\ninline FileAccess operator|(FileAccess A, FileAccess B) {\n  return FileAccess(unsigned(A) | unsigned(B));\n}\n\ninline FileAccess &operator|=(FileAccess &A, FileAccess B) {\n  A = A | B;\n  return A;\n}\n\n/// @brief Opens a file with the specified creation disposition, access mode,\n/// and flags and returns a file descriptor.\n///\n/// The caller is responsible for closing the file descriptor once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param ResultFD If the file could be opened successfully, its descriptor\n///                 is stored in this location. Otherwise, this is set to -1.\n/// @param Disp Value specifying the existing-file behavior.\n/// @param Access Value specifying whether to open the file in read, write, or\n///               read-write mode.\n/// @param Flags Additional flags.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns errc::success if \\a Name has been opened, otherwise a\n///          platform-specific error_code.\nstd::error_code openFile(const Twine &Name, int &ResultFD,\n                         CreationDisposition Disp, FileAccess Access,\n                         OpenFlags Flags, unsigned Mode = 0666);\n\n/// @brief Opens a file with the specified creation disposition, access mode,\n/// and flags and returns a platform-specific file object.\n///\n/// The caller is responsible for closing the file object once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param Disp Value specifying the existing-file behavior.\n/// @param Access Value specifying whether to open the file in read, write, or\n///               read-write mode.\n/// @param Flags Additional flags.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns errc::success if \\a Name has been opened, otherwise a\n///          platform-specific error_code.\nExpected<file_t> openNativeFile(const Twine &Name, CreationDisposition Disp,\n                                FileAccess Access, OpenFlags Flags,\n                                unsigned Mode = 0666);\n\n/// Converts from a Posix file descriptor number to a native file handle.\n/// On Windows, this retreives the underlying handle. On non-Windows, this is a\n/// no-op.\nfile_t convertFDToNativeFile(int FD);\n\n#ifndef _WIN32\ninline file_t convertFDToNativeFile(int FD) { return FD; }\n#endif\n\n/// Return an open handle to standard in. On Unix, this is typically FD 0.\n/// Returns kInvalidFile when the stream is closed.\nfile_t getStdinHandle();\n\n/// Return an open handle to standard out. On Unix, this is typically FD 1.\n/// Returns kInvalidFile when the stream is closed.\nfile_t getStdoutHandle();\n\n/// Return an open handle to standard error. On Unix, this is typically FD 2.\n/// Returns kInvalidFile when the stream is closed.\nfile_t getStderrHandle();\n\n/// Reads \\p Buf.size() bytes from \\p FileHandle into \\p Buf. Returns the number\n/// of bytes actually read. On Unix, this is equivalent to `return ::read(FD,\n/// Buf.data(), Buf.size())`, with error reporting. Returns 0 when reaching EOF.\n///\n/// @param FileHandle File to read from.\n/// @param Buf Buffer to read into.\n/// @returns The number of bytes read, or error.\nExpected<size_t> readNativeFile(file_t FileHandle, MutableArrayRef<char> Buf);\n\n/// Reads \\p Buf.size() bytes from \\p FileHandle at offset \\p Offset into \\p\n/// Buf. If 'pread' is available, this will use that, otherwise it will use\n/// 'lseek'. Returns the number of bytes actually read. Returns 0 when reaching\n/// EOF.\n///\n/// @param FileHandle File to read from.\n/// @param Buf Buffer to read into.\n/// @param Offset Offset into the file at which the read should occur.\n/// @returns The number of bytes read, or error.\nExpected<size_t> readNativeFileSlice(file_t FileHandle,\n                                     MutableArrayRef<char> Buf,\n                                     uint64_t Offset);\n\n/// @brief Opens the file with the given name in a write-only or read-write\n/// mode, returning its open file descriptor. If the file does not exist, it\n/// is created.\n///\n/// The caller is responsible for closing the file descriptor once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param ResultFD If the file could be opened successfully, its descriptor\n///                 is stored in this location. Otherwise, this is set to -1.\n/// @param Flags Additional flags used to determine whether the file should be\n///              opened in, for example, read-write or in write-only mode.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns errc::success if \\a Name has been opened, otherwise a\n///          platform-specific error_code.\ninline std::error_code\nopenFileForWrite(const Twine &Name, int &ResultFD,\n                 CreationDisposition Disp = CD_CreateAlways,\n                 OpenFlags Flags = OF_None, unsigned Mode = 0666) {\n  return openFile(Name, ResultFD, Disp, FA_Write, Flags, Mode);\n}\n\n/// @brief Opens the file with the given name in a write-only or read-write\n/// mode, returning its open file descriptor. If the file does not exist, it\n/// is created.\n///\n/// The caller is responsible for closing the freeing the file once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param Flags Additional flags used to determine whether the file should be\n///              opened in, for example, read-write or in write-only mode.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns a platform-specific file descriptor if \\a Name has been opened,\n///          otherwise an error object.\ninline Expected<file_t> openNativeFileForWrite(const Twine &Name,\n                                               CreationDisposition Disp,\n                                               OpenFlags Flags,\n                                               unsigned Mode = 0666) {\n  return openNativeFile(Name, Disp, FA_Write, Flags, Mode);\n}\n\n/// @brief Opens the file with the given name in a write-only or read-write\n/// mode, returning its open file descriptor. If the file does not exist, it\n/// is created.\n///\n/// The caller is responsible for closing the file descriptor once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param ResultFD If the file could be opened successfully, its descriptor\n///                 is stored in this location. Otherwise, this is set to -1.\n/// @param Flags Additional flags used to determine whether the file should be\n///              opened in, for example, read-write or in write-only mode.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns errc::success if \\a Name has been opened, otherwise a\n///          platform-specific error_code.\ninline std::error_code openFileForReadWrite(const Twine &Name, int &ResultFD,\n                                            CreationDisposition Disp,\n                                            OpenFlags Flags,\n                                            unsigned Mode = 0666) {\n  return openFile(Name, ResultFD, Disp, FA_Write | FA_Read, Flags, Mode);\n}\n\n/// @brief Opens the file with the given name in a write-only or read-write\n/// mode, returning its open file descriptor. If the file does not exist, it\n/// is created.\n///\n/// The caller is responsible for closing the freeing the file once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param Flags Additional flags used to determine whether the file should be\n///              opened in, for example, read-write or in write-only mode.\n/// @param Mode The access permissions of the file, represented in octal.\n/// @returns a platform-specific file descriptor if \\a Name has been opened,\n///          otherwise an error object.\ninline Expected<file_t> openNativeFileForReadWrite(const Twine &Name,\n                                                   CreationDisposition Disp,\n                                                   OpenFlags Flags,\n                                                   unsigned Mode = 0666) {\n  return openNativeFile(Name, Disp, FA_Write | FA_Read, Flags, Mode);\n}\n\n/// @brief Opens the file with the given name in a read-only mode, returning\n/// its open file descriptor.\n///\n/// The caller is responsible for closing the file descriptor once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param ResultFD If the file could be opened successfully, its descriptor\n///                 is stored in this location. Otherwise, this is set to -1.\n/// @param RealPath If nonnull, extra work is done to determine the real path\n///                 of the opened file, and that path is stored in this\n///                 location.\n/// @returns errc::success if \\a Name has been opened, otherwise a\n///          platform-specific error_code.\nstd::error_code openFileForRead(const Twine &Name, int &ResultFD,\n                                OpenFlags Flags = OF_None,\n                                SmallVectorImpl<char> *RealPath = nullptr);\n\n/// @brief Opens the file with the given name in a read-only mode, returning\n/// its open file descriptor.\n///\n/// The caller is responsible for closing the freeing the file once they are\n/// finished with it.\n///\n/// @param Name The path of the file to open, relative or absolute.\n/// @param RealPath If nonnull, extra work is done to determine the real path\n///                 of the opened file, and that path is stored in this\n///                 location.\n/// @returns a platform-specific file descriptor if \\a Name has been opened,\n///          otherwise an error object.\nExpected<file_t>\nopenNativeFileForRead(const Twine &Name, OpenFlags Flags = OF_None,\n                      SmallVectorImpl<char> *RealPath = nullptr);\n\n/// Try to locks the file during the specified time.\n///\n/// This function implements advisory locking on entire file. If it returns\n/// <em>errc::success</em>, the file is locked by the calling process. Until the\n/// process unlocks the file by calling \\a unlockFile, all attempts to lock the\n/// same file will fail/block. The process that locked the file may assume that\n/// none of other processes read or write this file, provided that all processes\n/// lock the file prior to accessing its content.\n///\n/// @param FD      The descriptor representing the file to lock.\n/// @param Timeout Time in milliseconds that the process should wait before\n///                reporting lock failure. Zero value means try to get lock only\n///                once.\n/// @returns errc::success if lock is successfully obtained,\n/// errc::no_lock_available if the file cannot be locked, or platform-specific\n/// error_code otherwise.\n///\n/// @note Care should be taken when using this function in a multithreaded\n/// context, as it may not prevent other threads in the same process from\n/// obtaining a lock on the same file, even if they are using a different file\n/// descriptor.\nstd::error_code\ntryLockFile(int FD,\n            std::chrono::milliseconds Timeout = std::chrono::milliseconds(0));\n\n/// Lock the file.\n///\n/// This function acts as @ref tryLockFile but it waits infinitely.\nstd::error_code lockFile(int FD);\n\n/// Unlock the file.\n///\n/// @param FD The descriptor representing the file to unlock.\n/// @returns errc::success if lock is successfully released or platform-specific\n/// error_code otherwise.\nstd::error_code unlockFile(int FD);\n\n/// @brief Close the file object.  This should be used instead of ::close for\n/// portability. On error, the caller should assume the file is closed, as is\n/// the case for Process::SafelyCloseFileDescriptor\n///\n/// @param F On input, this is the file to close.  On output, the file is\n/// set to kInvalidFile.\n///\n/// @returns An error code if closing the file failed. Typically, an error here\n/// means that the filesystem may have failed to perform some buffered writes.\nstd::error_code closeFile(file_t &F);\n\n#ifdef LLVM_ON_UNIX\n/// @brief Change ownership of a file.\n///\n/// @param Owner The owner of the file to change to.\n/// @param Group The group of the file to change to.\n/// @returns errc::success if successfully updated file ownership, otherwise an\n///          error code is returned.\nstd::error_code changeFileOwnership(int FD, uint32_t Owner, uint32_t Group);\n#endif\n\n/// RAII class that facilitates file locking.\nclass FileLocker {\n  int FD; ///< Locked file handle.\n  FileLocker(int FD) : FD(FD) {}\n  friend class llvm::raw_fd_ostream;\n\npublic:\n  FileLocker(const FileLocker &L) = delete;\n  FileLocker(FileLocker &&L) : FD(L.FD) { L.FD = -1; }\n  ~FileLocker() {\n    if (FD != -1)\n      unlockFile(FD);\n  }\n  FileLocker &operator=(FileLocker &&L) {\n    FD = L.FD;\n    L.FD = -1;\n    return *this;\n  }\n  FileLocker &operator=(const FileLocker &L) = delete;\n  std::error_code unlock() {\n    if (FD != -1) {\n      std::error_code Result = unlockFile(FD);\n      FD = -1;\n      return Result;\n    }\n    return std::error_code();\n  }\n};\n\nstd::error_code getUniqueID(const Twine Path, UniqueID &Result);\n\n/// Get disk space usage information.\n///\n/// Note: Users must be careful about \"Time Of Check, Time Of Use\" kind of bug.\n/// Note: Windows reports results according to the quota allocated to the user.\n///\n/// @param Path Input path.\n/// @returns a space_info structure filled with the capacity, free, and\n/// available space on the device \\a Path is on. A platform specific error_code\n/// is returned on error.\nErrorOr<space_info> disk_space(const Twine &Path);\n\n/// This class represents a memory mapped file. It is based on\n/// boost::iostreams::mapped_file.\nclass mapped_file_region {\npublic:\n  enum mapmode {\n    readonly, ///< May only access map via const_data as read only.\n    readwrite, ///< May access map via data and modify it. Written to path.\n    priv ///< May modify via data, but changes are lost on destruction.\n  };\n\nprivate:\n  /// Platform-specific mapping state.\n  size_t Size;\n  void *Mapping;\n#ifdef _WIN32\n  sys::fs::file_t FileHandle;\n#endif\n  mapmode Mode;\n\n  std::error_code init(sys::fs::file_t FD, uint64_t Offset, mapmode Mode);\n\npublic:\n  mapped_file_region() = delete;\n  mapped_file_region(mapped_file_region&) = delete;\n  mapped_file_region &operator =(mapped_file_region&) = delete;\n\n  /// \\param fd An open file descriptor to map. Does not take ownership of fd.\n  mapped_file_region(sys::fs::file_t fd, mapmode mode, size_t length, uint64_t offset,\n                     std::error_code &ec);\n\n  ~mapped_file_region();\n\n  size_t size() const;\n  char *data() const;\n\n  /// Get a const view of the data. Modifying this memory has undefined\n  /// behavior.\n  const char *const_data() const;\n\n  /// \\returns The minimum alignment offset must be.\n  static int alignment();\n};\n\n/// Return the path to the main executable, given the value of argv[0] from\n/// program startup and the address of main itself. In extremis, this function\n/// may fail and return an empty path.\nstd::string getMainExecutable(const char *argv0, void *MainExecAddr);\n\n/// @}\n/// @name Iterators\n/// @{\n\n/// directory_entry - A single entry in a directory.\nclass directory_entry {\n  // FIXME: different platforms make different information available \"for free\"\n  // when traversing a directory. The design of this class wraps most of the\n  // information in basic_file_status, so on platforms where we can't populate\n  // that whole structure, callers end up paying for a stat().\n  // std::filesystem::directory_entry may be a better model.\n  std::string Path;\n  file_type Type = file_type::type_unknown; // Most platforms can provide this.\n  bool FollowSymlinks = true;               // Affects the behavior of status().\n  basic_file_status Status;                 // If available.\n\npublic:\n  explicit directory_entry(const Twine &Path, bool FollowSymlinks = true,\n                           file_type Type = file_type::type_unknown,\n                           basic_file_status Status = basic_file_status())\n      : Path(Path.str()), Type(Type), FollowSymlinks(FollowSymlinks),\n        Status(Status) {}\n\n  directory_entry() = default;\n\n  void replace_filename(const Twine &Filename, file_type Type,\n                        basic_file_status Status = basic_file_status());\n\n  const std::string &path() const { return Path; }\n  // Get basic information about entry file (a subset of fs::status()).\n  // On most platforms this is a stat() call.\n  // On windows the information was already retrieved from the directory.\n  ErrorOr<basic_file_status> status() const;\n  // Get the type of this file.\n  // On most platforms (Linux/Mac/Windows/BSD), this was already retrieved.\n  // On some platforms (e.g. Solaris) this is a stat() call.\n  file_type type() const {\n    if (Type != file_type::type_unknown)\n      return Type;\n    auto S = status();\n    return S ? S->type() : file_type::type_unknown;\n  }\n\n  bool operator==(const directory_entry& RHS) const { return Path == RHS.Path; }\n  bool operator!=(const directory_entry& RHS) const { return !(*this == RHS); }\n  bool operator< (const directory_entry& RHS) const;\n  bool operator<=(const directory_entry& RHS) const;\n  bool operator> (const directory_entry& RHS) const;\n  bool operator>=(const directory_entry& RHS) const;\n};\n\nnamespace detail {\n\n  struct DirIterState;\n\n  std::error_code directory_iterator_construct(DirIterState &, StringRef, bool);\n  std::error_code directory_iterator_increment(DirIterState &);\n  std::error_code directory_iterator_destruct(DirIterState &);\n\n  /// Keeps state for the directory_iterator.\n  struct DirIterState {\n    ~DirIterState() {\n      directory_iterator_destruct(*this);\n    }\n\n    intptr_t IterationHandle = 0;\n    directory_entry CurrentEntry;\n  };\n\n} // end namespace detail\n\n/// directory_iterator - Iterates through the entries in path. There is no\n/// operator++ because we need an error_code. If it's really needed we can make\n/// it call report_fatal_error on error.\nclass directory_iterator {\n  std::shared_ptr<detail::DirIterState> State;\n  bool FollowSymlinks = true;\n\npublic:\n  explicit directory_iterator(const Twine &path, std::error_code &ec,\n                              bool follow_symlinks = true)\n      : FollowSymlinks(follow_symlinks) {\n    State = std::make_shared<detail::DirIterState>();\n    SmallString<128> path_storage;\n    ec = detail::directory_iterator_construct(\n        *State, path.toStringRef(path_storage), FollowSymlinks);\n  }\n\n  explicit directory_iterator(const directory_entry &de, std::error_code &ec,\n                              bool follow_symlinks = true)\n      : FollowSymlinks(follow_symlinks) {\n    State = std::make_shared<detail::DirIterState>();\n    ec = detail::directory_iterator_construct(\n        *State, de.path(), FollowSymlinks);\n  }\n\n  /// Construct end iterator.\n  directory_iterator() = default;\n\n  // No operator++ because we need error_code.\n  directory_iterator &increment(std::error_code &ec) {\n    ec = directory_iterator_increment(*State);\n    return *this;\n  }\n\n  const directory_entry &operator*() const { return State->CurrentEntry; }\n  const directory_entry *operator->() const { return &State->CurrentEntry; }\n\n  bool operator==(const directory_iterator &RHS) const {\n    if (State == RHS.State)\n      return true;\n    if (!RHS.State)\n      return State->CurrentEntry == directory_entry();\n    if (!State)\n      return RHS.State->CurrentEntry == directory_entry();\n    return State->CurrentEntry == RHS.State->CurrentEntry;\n  }\n\n  bool operator!=(const directory_iterator &RHS) const {\n    return !(*this == RHS);\n  }\n};\n\nnamespace detail {\n\n  /// Keeps state for the recursive_directory_iterator.\n  struct RecDirIterState {\n    std::stack<directory_iterator, std::vector<directory_iterator>> Stack;\n    uint16_t Level = 0;\n    bool HasNoPushRequest = false;\n  };\n\n} // end namespace detail\n\n/// recursive_directory_iterator - Same as directory_iterator except for it\n/// recurses down into child directories.\nclass recursive_directory_iterator {\n  std::shared_ptr<detail::RecDirIterState> State;\n  bool Follow;\n\npublic:\n  recursive_directory_iterator() = default;\n  explicit recursive_directory_iterator(const Twine &path, std::error_code &ec,\n                                        bool follow_symlinks = true)\n      : State(std::make_shared<detail::RecDirIterState>()),\n        Follow(follow_symlinks) {\n    State->Stack.push(directory_iterator(path, ec, Follow));\n    if (State->Stack.top() == directory_iterator())\n      State.reset();\n  }\n\n  // No operator++ because we need error_code.\n  recursive_directory_iterator &increment(std::error_code &ec) {\n    const directory_iterator end_itr = {};\n\n    if (State->HasNoPushRequest)\n      State->HasNoPushRequest = false;\n    else {\n      file_type type = State->Stack.top()->type();\n      if (type == file_type::symlink_file && Follow) {\n        // Resolve the symlink: is it a directory to recurse into?\n        ErrorOr<basic_file_status> status = State->Stack.top()->status();\n        if (status)\n          type = status->type();\n        // Otherwise broken symlink, and we'll continue.\n      }\n      if (type == file_type::directory_file) {\n        State->Stack.push(directory_iterator(*State->Stack.top(), ec, Follow));\n        if (State->Stack.top() != end_itr) {\n          ++State->Level;\n          return *this;\n        }\n        State->Stack.pop();\n      }\n    }\n\n    while (!State->Stack.empty()\n           && State->Stack.top().increment(ec) == end_itr) {\n      State->Stack.pop();\n      --State->Level;\n    }\n\n    // Check if we are done. If so, create an end iterator.\n    if (State->Stack.empty())\n      State.reset();\n\n    return *this;\n  }\n\n  const directory_entry &operator*() const { return *State->Stack.top(); }\n  const directory_entry *operator->() const { return &*State->Stack.top(); }\n\n  // observers\n  /// Gets the current level. Starting path is at level 0.\n  int level() const { return State->Level; }\n\n  /// Returns true if no_push has been called for this directory_entry.\n  bool no_push_request() const { return State->HasNoPushRequest; }\n\n  // modifiers\n  /// Goes up one level if Level > 0.\n  void pop() {\n    assert(State && \"Cannot pop an end iterator!\");\n    assert(State->Level > 0 && \"Cannot pop an iterator with level < 1\");\n\n    const directory_iterator end_itr = {};\n    std::error_code ec;\n    do {\n      if (ec)\n        report_fatal_error(\"Error incrementing directory iterator.\");\n      State->Stack.pop();\n      --State->Level;\n    } while (!State->Stack.empty()\n             && State->Stack.top().increment(ec) == end_itr);\n\n    // Check if we are done. If so, create an end iterator.\n    if (State->Stack.empty())\n      State.reset();\n  }\n\n  /// Does not go down into the current directory_entry.\n  void no_push() { State->HasNoPushRequest = true; }\n\n  bool operator==(const recursive_directory_iterator &RHS) const {\n    return State == RHS.State;\n  }\n\n  bool operator!=(const recursive_directory_iterator &RHS) const {\n    return !(*this == RHS);\n  }\n};\n\n/// @}\n\n} // end namespace fs\n} // end namespace sys\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_FILESYSTEM_H\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem/UniqueID.h", "content": "//===- llvm/Support/FileSystem/UniqueID.h - UniqueID for files --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is cut out of llvm/Support/FileSystem.h to allow UniqueID to be\n// reused without bloating the includes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_FILESYSTEM_UNIQUEID_H\n#define LLVM_SUPPORT_FILESYSTEM_UNIQUEID_H\n\n#include <cstdint>\n\nnamespace llvm {\nnamespace sys {\nnamespace fs {\n\nclass UniqueID {\n  uint64_t Device;\n  uint64_t File;\n\npublic:\n  UniqueID() = default;\n  UniqueID(uint64_t Device, uint64_t File) : Device(Device), File(File) {}\n\n  bool operator==(const UniqueID &Other) const {\n    return Device == Other.Device && File == Other.File;\n  }\n  bool operator!=(const UniqueID &Other) const { return !(*this == Other); }\n  bool operator<(const UniqueID &Other) const {\n    /// Don't use std::tie since it bloats the compile time of this header.\n    if (Device < Other.Device)\n      return true;\n    if (Other.Device < Device)\n      return false;\n    return File < Other.File;\n  }\n\n  uint64_t getDevice() const { return Device; }\n  uint64_t getFile() const { return File; }\n};\n\n} // end namespace fs\n} // end namespace sys\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_FILESYSTEM_UNIQUEID_H\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MD5.h", "content": "/* -*- C++ -*-\n * This code is derived from (original license follows):\n *\n * This is an OpenSSL-compatible implementation of the RSA Data Security, Inc.\n * MD5 Message-Digest Algorithm (RFC 1321).\n *\n * Homepage:\n * http://openwall.info/wiki/people/solar/software/public-domain-source-code/md5\n *\n * Author:\n * Alexander Peslyak, better known as Solar Designer <solar at openwall.com>\n *\n * This software was written by Alexander Peslyak in 2001.  No copyright is\n * claimed, and the software is hereby placed in the public domain.\n * In case this attempt to disclaim copyright and place the software in the\n * public domain is deemed null and void, then the software is\n * Copyright (c) 2001 Alexander Peslyak and it is hereby released to the\n * general public under the following terms:\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted.\n *\n * There's ABSOLUTELY NO WARRANTY, express or implied.\n *\n * See md5.c for more information.\n */\n\n#ifndef LLVM_SUPPORT_MD5_H\n#define LLVM_SUPPORT_MD5_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Endian.h\"\n#include <array>\n#include <cstdint>\n\nnamespace llvm {\n\ntemplate <unsigned N> class SmallString;\ntemplate <typename T> class ArrayRef;\n\nclass MD5 {\n  // Any 32-bit or wider unsigned integer data type will do.\n  typedef uint32_t MD5_u32plus;\n\n  MD5_u32plus a = 0x67452301;\n  MD5_u32plus b = 0xefcdab89;\n  MD5_u32plus c = 0x98badcfe;\n  MD5_u32plus d = 0x10325476;\n  MD5_u32plus hi = 0;\n  MD5_u32plus lo = 0;\n  uint8_t buffer[64];\n  MD5_u32plus block[16];\n\npublic:\n  struct MD5Result {\n    std::array<uint8_t, 16> Bytes;\n\n    operator std::array<uint8_t, 16>() const { return Bytes; }\n\n    const uint8_t &operator[](size_t I) const { return Bytes[I]; }\n    uint8_t &operator[](size_t I) { return Bytes[I]; }\n\n    SmallString<32> digest() const;\n\n    uint64_t low() const {\n      // Our MD5 implementation returns the result in little endian, so the low\n      // word is first.\n      using namespace support;\n      return endian::read<uint64_t, little, unaligned>(Bytes.data());\n    }\n\n    uint64_t high() const {\n      using namespace support;\n      return endian::read<uint64_t, little, unaligned>(Bytes.data() + 8);\n    }\n    std::pair<uint64_t, uint64_t> words() const {\n      using namespace support;\n      return std::make_pair(high(), low());\n    }\n  };\n\n  MD5();\n\n  /// Updates the hash for the byte stream provided.\n  void update(ArrayRef<uint8_t> Data);\n\n  /// Updates the hash for the StringRef provided.\n  void update(StringRef Str);\n\n  /// Finishes off the hash and puts the result in result.\n  void final(MD5Result &Result);\n\n  /// Translates the bytes in \\p Res to a hex string that is\n  /// deposited into \\p Str. The result will be of length 32.\n  static void stringifyResult(MD5Result &Result, SmallString<32> &Str);\n\n  /// Computes the hash for a given bytes.\n  static std::array<uint8_t, 16> hash(ArrayRef<uint8_t> Data);\n\nprivate:\n  const uint8_t *body(ArrayRef<uint8_t> Data);\n};\n\ninline bool operator==(const MD5::MD5Result &LHS, const MD5::MD5Result &RHS) {\n  return LHS.Bytes == RHS.Bytes;\n}\n\n/// Helper to compute and return lower 64 bits of the given string's MD5 hash.\ninline uint64_t MD5Hash(StringRef Str) {\n  using namespace support;\n\n  MD5 Hash;\n  Hash.update(Str);\n  MD5::MD5Result Result;\n  Hash.final(Result);\n  // Return the least significant word.\n  return Result.low();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_MD5_H\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MemoryBufferRef.h", "content": "//===- MemoryBufferRef.h - Memory Buffer Reference --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the MemoryBuffer interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_MEMORYBUFFERREF_H\n#define LLVM_SUPPORT_MEMORYBUFFERREF_H\n\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace llvm {\n\nclass MemoryBuffer;\n\nclass MemoryBufferRef {\n  StringRef Buffer;\n  StringRef Identifier;\n\npublic:\n  MemoryBufferRef() = default;\n  MemoryBufferRef(const MemoryBuffer &Buffer);\n  MemoryBufferRef(StringRef Buffer, StringRef Identifier)\n      : Buffer(Buffer), Identifier(Identifier) {}\n\n  StringRef getBuffer() const { return Buffer; }\n  StringRef getBufferIdentifier() const { return Identifier; }\n\n  const char *getBufferStart() const { return Buffer.begin(); }\n  const char *getBufferEnd() const { return Buffer.end(); }\n  size_t getBufferSize() const { return Buffer.size(); }\n\n  /// Check pointer identity (not value) of identifier and data.\n  friend bool operator==(const MemoryBufferRef &LHS,\n                         const MemoryBufferRef &RHS) {\n    return LHS.Buffer.begin() == RHS.Buffer.begin() &&\n           LHS.Buffer.end() == RHS.Buffer.end() &&\n           LHS.Identifier.begin() == RHS.Identifier.begin() &&\n           LHS.Identifier.end() == RHS.Identifier.end();\n  }\n\n  friend bool operator!=(const MemoryBufferRef &LHS,\n                         const MemoryBufferRef &RHS) {\n    return !(LHS == RHS);\n  }\n};\n\n} // namespace llvm\n\n#endif // LLVM_SUPPORT_MEMORYBUFFERREF_H\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Path.h", "content": "//===- llvm/Support/Path.h - Path Operating System Concept ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the llvm::sys::path namespace. It is designed after\n// TR2/boost filesystem (v3), but modified to remove exception handling and the\n// path class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_PATH_H\n#define LLVM_SUPPORT_PATH_H\n\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include <iterator>\n#include <system_error>\n\nnamespace llvm {\nnamespace sys {\nnamespace path {\n\nenum class Style { windows, posix, native };\n\n/// @name Lexical Component Iterator\n/// @{\n\n/// Path iterator.\n///\n/// This is an input iterator that iterates over the individual components in\n/// \\a path. The traversal order is as follows:\n/// * The root-name element, if present.\n/// * The root-directory element, if present.\n/// * Each successive filename element, if present.\n/// * Dot, if one or more trailing non-root slash characters are present.\n/// Traversing backwards is possible with \\a reverse_iterator\n///\n/// Iteration examples. Each component is separated by ',':\n/// @code\n///   /          => /\n///   /foo       => /,foo\n///   foo/       => foo,.\n///   /foo/bar   => /,foo,bar\n///   ../        => ..,.\n///   C:\\foo\\bar => C:,\\,foo,bar\n/// @endcode\nclass const_iterator\n    : public iterator_facade_base<const_iterator, std::input_iterator_tag,\n                                  const StringRef> {\n  StringRef Path;          ///< The entire path.\n  StringRef Component;     ///< The current component. Not necessarily in Path.\n  size_t    Position = 0;  ///< The iterators current position within Path.\n  Style S = Style::native; ///< The path style to use.\n\n  // An end iterator has Position = Path.size() + 1.\n  friend const_iterator begin(StringRef path, Style style);\n  friend const_iterator end(StringRef path);\n\npublic:\n  reference operator*() const { return Component; }\n  const_iterator &operator++();    // preincrement\n  bool operator==(const const_iterator &RHS) const;\n\n  /// Difference in bytes between this and RHS.\n  ptrdiff_t operator-(const const_iterator &RHS) const;\n};\n\n/// Reverse path iterator.\n///\n/// This is an input iterator that iterates over the individual components in\n/// \\a path in reverse order. The traversal order is exactly reversed from that\n/// of \\a const_iterator\nclass reverse_iterator\n    : public iterator_facade_base<reverse_iterator, std::input_iterator_tag,\n                                  const StringRef> {\n  StringRef Path;          ///< The entire path.\n  StringRef Component;     ///< The current component. Not necessarily in Path.\n  size_t    Position = 0;  ///< The iterators current position within Path.\n  Style S = Style::native; ///< The path style to use.\n\n  friend reverse_iterator rbegin(StringRef path, Style style);\n  friend reverse_iterator rend(StringRef path);\n\npublic:\n  reference operator*() const { return Component; }\n  reverse_iterator &operator++();    // preincrement\n  bool operator==(const reverse_iterator &RHS) const;\n\n  /// Difference in bytes between this and RHS.\n  ptrdiff_t operator-(const reverse_iterator &RHS) const;\n};\n\n/// Get begin iterator over \\a path.\n/// @param path Input path.\n/// @returns Iterator initialized with the first component of \\a path.\nconst_iterator begin(StringRef path, Style style = Style::native);\n\n/// Get end iterator over \\a path.\n/// @param path Input path.\n/// @returns Iterator initialized to the end of \\a path.\nconst_iterator end(StringRef path);\n\n/// Get reverse begin iterator over \\a path.\n/// @param path Input path.\n/// @returns Iterator initialized with the first reverse component of \\a path.\nreverse_iterator rbegin(StringRef path, Style style = Style::native);\n\n/// Get reverse end iterator over \\a path.\n/// @param path Input path.\n/// @returns Iterator initialized to the reverse end of \\a path.\nreverse_iterator rend(StringRef path);\n\n/// @}\n/// @name Lexical Modifiers\n/// @{\n\n/// Remove the last component from \\a path unless it is the root dir.\n///\n/// Similar to the POSIX \"dirname\" utility.\n///\n/// @code\n///   directory/filename.cpp => directory/\n///   directory/             => directory\n///   filename.cpp           => <empty>\n///   /                      => /\n/// @endcode\n///\n/// @param path A path that is modified to not have a file component.\nvoid remove_filename(SmallVectorImpl<char> &path, Style style = Style::native);\n\n/// Replace the file extension of \\a path with \\a extension.\n///\n/// @code\n///   ./filename.cpp => ./filename.extension\n///   ./filename     => ./filename.extension\n///   ./             => ./.extension\n/// @endcode\n///\n/// @param path A path that has its extension replaced with \\a extension.\n/// @param extension The extension to be added. It may be empty. It may also\n///                  optionally start with a '.', if it does not, one will be\n///                  prepended.\nvoid replace_extension(SmallVectorImpl<char> &path, const Twine &extension,\n                       Style style = Style::native);\n\n/// Replace matching path prefix with another path.\n///\n/// @code\n///   /foo, /old, /new => /foo\n///   /old, /old, /new => /new\n///   /old, /old/, /new => /old\n///   /old/foo, /old, /new => /new/foo\n///   /old/foo, /old/, /new => /new/foo\n///   /old/foo, /old/, /new/ => /new/foo\n///   /oldfoo, /old, /new => /oldfoo\n///   /foo, <empty>, /new => /new/foo\n///   /foo, <empty>, new => new/foo\n///   /old/foo, /old, <empty> => /foo\n/// @endcode\n///\n/// @param Path If \\a Path starts with \\a OldPrefix modify to instead\n///        start with \\a NewPrefix.\n/// @param OldPrefix The path prefix to strip from \\a Path.\n/// @param NewPrefix The path prefix to replace \\a NewPrefix with.\n/// @param style The style used to match the prefix. Exact match using\n/// Posix style, case/separator insensitive match for Windows style.\n/// @result true if \\a Path begins with OldPrefix\nbool replace_path_prefix(SmallVectorImpl<char> &Path, StringRef OldPrefix,\n                         StringRef NewPrefix,\n                         Style style = Style::native);\n\n/// Append to path.\n///\n/// @code\n///   /foo  + bar/f => /foo/bar/f\n///   /foo/ + bar/f => /foo/bar/f\n///   foo   + bar/f => foo/bar/f\n/// @endcode\n///\n/// @param path Set to \\a path + \\a component.\n/// @param a The component to be appended to \\a path.\nvoid append(SmallVectorImpl<char> &path, const Twine &a,\n                                         const Twine &b = \"\",\n                                         const Twine &c = \"\",\n                                         const Twine &d = \"\");\n\nvoid append(SmallVectorImpl<char> &path, Style style, const Twine &a,\n            const Twine &b = \"\", const Twine &c = \"\", const Twine &d = \"\");\n\n/// Append to path.\n///\n/// @code\n///   /foo  + [bar,f] => /foo/bar/f\n///   /foo/ + [bar,f] => /foo/bar/f\n///   foo   + [bar,f] => foo/bar/f\n/// @endcode\n///\n/// @param path Set to \\a path + [\\a begin, \\a end).\n/// @param begin Start of components to append.\n/// @param end One past the end of components to append.\nvoid append(SmallVectorImpl<char> &path, const_iterator begin,\n            const_iterator end, Style style = Style::native);\n\n/// @}\n/// @name Transforms (or some other better name)\n/// @{\n\n/// Convert path to the native form. This is used to give paths to users and\n/// operating system calls in the platform's normal way. For example, on Windows\n/// all '/' are converted to '\\'.\n///\n/// @param path A path that is transformed to native format.\n/// @param result Holds the result of the transformation.\nvoid native(const Twine &path, SmallVectorImpl<char> &result,\n            Style style = Style::native);\n\n/// Convert path to the native form in place. This is used to give paths to\n/// users and operating system calls in the platform's normal way. For example,\n/// on Windows all '/' are converted to '\\'.\n///\n/// @param path A path that is transformed to native format.\nvoid native(SmallVectorImpl<char> &path, Style style = Style::native);\n\n/// Replaces backslashes with slashes if Windows.\n///\n/// @param path processed path\n/// @result The result of replacing backslashes with forward slashes if Windows.\n/// On Unix, this function is a no-op because backslashes are valid path\n/// chracters.\nstd::string convert_to_slash(StringRef path, Style style = Style::native);\n\n/// @}\n/// @name Lexical Observers\n/// @{\n\n/// Get root name.\n///\n/// @code\n///   //net/hello => //net\n///   c:/hello    => c: (on Windows, on other platforms nothing)\n///   /hello      => <empty>\n/// @endcode\n///\n/// @param path Input path.\n/// @result The root name of \\a path if it has one, otherwise \"\".\nStringRef root_name(StringRef path, Style style = Style::native);\n\n/// Get root directory.\n///\n/// @code\n///   /goo/hello => /\n///   c:/hello   => /\n///   d/file.txt => <empty>\n/// @endcode\n///\n/// @param path Input path.\n/// @result The root directory of \\a path if it has one, otherwise\n///               \"\".\nStringRef root_directory(StringRef path, Style style = Style::native);\n\n/// Get root path.\n///\n/// Equivalent to root_name + root_directory.\n///\n/// @param path Input path.\n/// @result The root path of \\a path if it has one, otherwise \"\".\nStringRef root_path(StringRef path, Style style = Style::native);\n\n/// Get relative path.\n///\n/// @code\n///   C:\\hello\\world => hello\\world\n///   foo/bar        => foo/bar\n///   /foo/bar       => foo/bar\n/// @endcode\n///\n/// @param path Input path.\n/// @result The path starting after root_path if one exists, otherwise \"\".\nStringRef relative_path(StringRef path, Style style = Style::native);\n\n/// Get parent path.\n///\n/// @code\n///   /          => <empty>\n///   /foo       => /\n///   foo/../bar => foo/..\n/// @endcode\n///\n/// @param path Input path.\n/// @result The parent path of \\a path if one exists, otherwise \"\".\nStringRef parent_path(StringRef path, Style style = Style::native);\n\n/// Get filename.\n///\n/// @code\n///   /foo.txt    => foo.txt\n///   .          => .\n///   ..         => ..\n///   /          => /\n/// @endcode\n///\n/// @param path Input path.\n/// @result The filename part of \\a path. This is defined as the last component\n///         of \\a path. Similar to the POSIX \"basename\" utility.\nStringRef filename(StringRef path, Style style = Style::native);\n\n/// Get stem.\n///\n/// If filename contains a dot but not solely one or two dots, result is the\n/// substring of filename ending at (but not including) the last dot. Otherwise\n/// it is filename.\n///\n/// @code\n///   /foo/bar.txt => bar\n///   /foo/bar     => bar\n///   /foo/.txt    => <empty>\n///   /foo/.       => .\n///   /foo/..      => ..\n/// @endcode\n///\n/// @param path Input path.\n/// @result The stem of \\a path.\nStringRef stem(StringRef path, Style style = Style::native);\n\n/// Get extension.\n///\n/// If filename contains a dot but not solely one or two dots, result is the\n/// substring of filename starting at (and including) the last dot, and ending\n/// at the end of \\a path. Otherwise \"\".\n///\n/// @code\n///   /foo/bar.txt => .txt\n///   /foo/bar     => <empty>\n///   /foo/.txt    => .txt\n/// @endcode\n///\n/// @param path Input path.\n/// @result The extension of \\a path.\nStringRef extension(StringRef path, Style style = Style::native);\n\n/// Check whether the given char is a path separator on the host OS.\n///\n/// @param value a character\n/// @result true if \\a value is a path separator character on the host OS\nbool is_separator(char value, Style style = Style::native);\n\n/// Return the preferred separator for this platform.\n///\n/// @result StringRef of the preferred separator, null-terminated.\nStringRef get_separator(Style style = Style::native);\n\n/// Get the typical temporary directory for the system, e.g.,\n/// \"/var/tmp\" or \"C:/TEMP\"\n///\n/// @param erasedOnReboot Whether to favor a path that is erased on reboot\n/// rather than one that potentially persists longer. This parameter will be\n/// ignored if the user or system has set the typical environment variable\n/// (e.g., TEMP on Windows, TMPDIR on *nix) to specify a temporary directory.\n///\n/// @param result Holds the resulting path name.\nvoid system_temp_directory(bool erasedOnReboot, SmallVectorImpl<char> &result);\n\n/// Get the user's home directory.\n///\n/// @param result Holds the resulting path name.\n/// @result True if a home directory is set, false otherwise.\nbool home_directory(SmallVectorImpl<char> &result);\n\n/// Get the directory where packages should read user-specific configurations.\n/// e.g. $XDG_CONFIG_HOME.\n///\n/// @param result Holds the resulting path name.\n/// @result True if the appropriate path was determined, it need not exist.\nbool user_config_directory(SmallVectorImpl<char> &result);\n\n/// Get the directory where installed packages should put their\n/// machine-local cache, e.g. $XDG_CACHE_HOME.\n///\n/// @param result Holds the resulting path name.\n/// @result True if the appropriate path was determined, it need not exist.\nbool cache_directory(SmallVectorImpl<char> &result);\n\n/// Has root name?\n///\n/// root_name != \"\"\n///\n/// @param path Input path.\n/// @result True if the path has a root name, false otherwise.\nbool has_root_name(const Twine &path, Style style = Style::native);\n\n/// Has root directory?\n///\n/// root_directory != \"\"\n///\n/// @param path Input path.\n/// @result True if the path has a root directory, false otherwise.\nbool has_root_directory(const Twine &path, Style style = Style::native);\n\n/// Has root path?\n///\n/// root_path != \"\"\n///\n/// @param path Input path.\n/// @result True if the path has a root path, false otherwise.\nbool has_root_path(const Twine &path, Style style = Style::native);\n\n/// Has relative path?\n///\n/// relative_path != \"\"\n///\n/// @param path Input path.\n/// @result True if the path has a relative path, false otherwise.\nbool has_relative_path(const Twine &path, Style style = Style::native);\n\n/// Has parent path?\n///\n/// parent_path != \"\"\n///\n/// @param path Input path.\n/// @result True if the path has a parent path, false otherwise.\nbool has_parent_path(const Twine &path, Style style = Style::native);\n\n/// Has filename?\n///\n/// filename != \"\"\n///\n/// @param path Input path.\n/// @result True if the path has a filename, false otherwise.\nbool has_filename(const Twine &path, Style style = Style::native);\n\n/// Has stem?\n///\n/// stem != \"\"\n///\n/// @param path Input path.\n/// @result True if the path has a stem, false otherwise.\nbool has_stem(const Twine &path, Style style = Style::native);\n\n/// Has extension?\n///\n/// extension != \"\"\n///\n/// @param path Input path.\n/// @result True if the path has a extension, false otherwise.\nbool has_extension(const Twine &path, Style style = Style::native);\n\n/// Is path absolute?\n///\n/// According to cppreference.com, C++17 states: \"An absolute path is a path\n/// that unambiguously identifies the location of a file without reference to\n/// an additional starting location.\"\n///\n/// In other words, the rules are:\n/// 1) POSIX style paths with nonempty root directory are absolute.\n/// 2) Windows style paths with nonempty root name and root directory are\n///    absolute.\n/// 3) No other paths are absolute.\n///\n/// \\see has_root_name\n/// \\see has_root_directory\n///\n/// @param path Input path.\n/// @result True if the path is absolute, false if it is not.\nbool is_absolute(const Twine &path, Style style = Style::native);\n\n/// Is path absolute using GNU rules?\n///\n/// GNU rules are:\n/// 1) Paths starting with a path separator are absolute.\n/// 2) Windows style paths are also absolute if they start with a character\n///    followed by ':'.\n/// 3) No other paths are absolute.\n///\n/// On Windows style the path \"C:\\Users\\Default\" has \"C:\" as root name and \"\\\"\n/// as root directory.\n///\n/// Hence \"C:\" on Windows is absolute under GNU rules and not absolute under\n/// C++17 because it has no root directory. Likewise \"/\" and \"\\\" on Windows are\n/// absolute under GNU and are not absolute under C++17 due to empty root name.\n///\n/// \\see has_root_name\n/// \\see has_root_directory\n///\n/// @param path Input path.\n/// @param style The style of \\p path (e.g. Windows or POSIX). \"native\" style\n/// means to derive the style from the host.\n/// @result True if the path is absolute following GNU rules, false if it is\n/// not.\nbool is_absolute_gnu(const Twine &path, Style style = Style::native);\n\n/// Is path relative?\n///\n/// @param path Input path.\n/// @result True if the path is relative, false if it is not.\nbool is_relative(const Twine &path, Style style = Style::native);\n\n/// Remove redundant leading \"./\" pieces and consecutive separators.\n///\n/// @param path Input path.\n/// @result The cleaned-up \\a path.\nStringRef remove_leading_dotslash(StringRef path, Style style = Style::native);\n\n/// In-place remove any './' and optionally '../' components from a path.\n///\n/// @param path processed path\n/// @param remove_dot_dot specify if '../' (except for leading \"../\") should be\n/// removed\n/// @result True if path was changed\nbool remove_dots(SmallVectorImpl<char> &path, bool remove_dot_dot = false,\n                 Style style = Style::native);\n\n} // end namespace path\n} // end namespace sys\n} // end namespace llvm\n\n#endif\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SMLoc.h", "content": "//===- SMLoc.h - Source location for use with diagnostics -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the SMLoc class.  This class encapsulates a location in\n// source code for use in diagnostics.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_SMLOC_H\n#define LLVM_SUPPORT_SMLOC_H\n\n#include \"llvm/ADT/None.h\"\n#include <cassert>\n\nnamespace llvm {\n\n/// Represents a location in source code.\nclass SMLoc {\n  const char *Ptr = nullptr;\n\npublic:\n  SMLoc() = default;\n\n  bool isValid() const { return Ptr != nullptr; }\n\n  bool operator==(const SMLoc &RHS) const { return RHS.Ptr == Ptr; }\n  bool operator!=(const SMLoc &RHS) const { return RHS.Ptr != Ptr; }\n\n  const char *getPointer() const { return Ptr; }\n\n  static SMLoc getFromPointer(const char *Ptr) {\n    SMLoc L;\n    L.Ptr = Ptr;\n    return L;\n  }\n};\n\n/// Represents a range in source code.\n///\n/// SMRange is implemented using a half-open range, as is the convention in C++.\n/// In the string \"abc\", the range [1,3) represents the substring \"bc\", and the\n/// range [2,2) represents an empty range between the characters \"b\" and \"c\".\nclass SMRange {\npublic:\n  SMLoc Start, End;\n\n  SMRange() = default;\n  SMRange(NoneType) {}\n  SMRange(SMLoc St, SMLoc En) : Start(St), End(En) {\n    assert(Start.isValid() == End.isValid() &&\n           \"Start and End should either both be valid or both be invalid!\");\n  }\n\n  bool isValid() const { return Start.isValid(); }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_SMLOC_H\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SourceMgr.h", "content": "//===- SourceMgr.h - Manager for Source Buffers & Diagnostics ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the SMDiagnostic and SourceMgr classes.  This\n// provides a simple substrate for diagnostics, #include handling, and other low\n// level things for simple parsers.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_SOURCEMGR_H\n#define LLVM_SUPPORT_SOURCEMGR_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include <vector>\n\nnamespace llvm {\n\nclass raw_ostream;\nclass SMDiagnostic;\nclass SMFixIt;\n\n/// This owns the files read by a parser, handles include stacks,\n/// and handles diagnostic wrangling.\nclass SourceMgr {\npublic:\n  enum DiagKind {\n    DK_Error,\n    DK_Warning,\n    DK_Remark,\n    DK_Note,\n  };\n\n  /// Clients that want to handle their own diagnostics in a custom way can\n  /// register a function pointer+context as a diagnostic handler.\n  /// It gets called each time PrintMessage is invoked.\n  using DiagHandlerTy = void (*)(const SMDiagnostic &, void *Context);\n\nprivate:\n  struct SrcBuffer {\n    /// The memory buffer for the file.\n    std::unique_ptr<MemoryBuffer> Buffer;\n\n    /// Vector of offsets into Buffer at which there are line-endings\n    /// (lazily populated). Once populated, the '\\n' that marks the end of\n    /// line number N from [1..] is at Buffer[OffsetCache[N-1]]. Since\n    /// these offsets are in sorted (ascending) order, they can be\n    /// binary-searched for the first one after any given offset (eg. an\n    /// offset corresponding to a particular SMLoc).\n    ///\n    /// Since we're storing offsets into relatively small files (often smaller\n    /// than 2^8 or 2^16 bytes), we select the offset vector element type\n    /// dynamically based on the size of Buffer.\n    mutable void *OffsetCache = nullptr;\n\n    /// Look up a given \\p Ptr in in the buffer, determining which line it came\n    /// from.\n    unsigned getLineNumber(const char *Ptr) const;\n    template <typename T>\n    unsigned getLineNumberSpecialized(const char *Ptr) const;\n\n    /// Return a pointer to the first character of the specified line number or\n    /// null if the line number is invalid.\n    const char *getPointerForLineNumber(unsigned LineNo) const;\n    template <typename T>\n    const char *getPointerForLineNumberSpecialized(unsigned LineNo) const;\n\n    /// This is the location of the parent include, or null if at the top level.\n    SMLoc IncludeLoc;\n\n    SrcBuffer() = default;\n    SrcBuffer(SrcBuffer &&);\n    SrcBuffer(const SrcBuffer &) = delete;\n    SrcBuffer &operator=(const SrcBuffer &) = delete;\n    ~SrcBuffer();\n  };\n\n  /// This is all of the buffers that we are reading from.\n  std::vector<SrcBuffer> Buffers;\n\n  // This is the list of directories we should search for include files in.\n  std::vector<std::string> IncludeDirectories;\n\n  DiagHandlerTy DiagHandler = nullptr;\n  void *DiagContext = nullptr;\n\n  bool isValidBufferID(unsigned i) const { return i && i <= Buffers.size(); }\n\npublic:\n  SourceMgr() = default;\n  SourceMgr(const SourceMgr &) = delete;\n  SourceMgr &operator=(const SourceMgr &) = delete;\n  SourceMgr(SourceMgr &&) = default;\n  SourceMgr &operator=(SourceMgr &&) = default;\n  ~SourceMgr() = default;\n\n  void setIncludeDirs(const std::vector<std::string> &Dirs) {\n    IncludeDirectories = Dirs;\n  }\n\n  /// Specify a diagnostic handler to be invoked every time PrintMessage is\n  /// called. \\p Ctx is passed into the handler when it is invoked.\n  void setDiagHandler(DiagHandlerTy DH, void *Ctx = nullptr) {\n    DiagHandler = DH;\n    DiagContext = Ctx;\n  }\n\n  DiagHandlerTy getDiagHandler() const { return DiagHandler; }\n  void *getDiagContext() const { return DiagContext; }\n\n  const SrcBuffer &getBufferInfo(unsigned i) const {\n    assert(isValidBufferID(i));\n    return Buffers[i - 1];\n  }\n\n  const MemoryBuffer *getMemoryBuffer(unsigned i) const {\n    assert(isValidBufferID(i));\n    return Buffers[i - 1].Buffer.get();\n  }\n\n  unsigned getNumBuffers() const { return Buffers.size(); }\n\n  unsigned getMainFileID() const {\n    assert(getNumBuffers());\n    return 1;\n  }\n\n  SMLoc getParentIncludeLoc(unsigned i) const {\n    assert(isValidBufferID(i));\n    return Buffers[i - 1].IncludeLoc;\n  }\n\n  /// Add a new source buffer to this source manager. This takes ownership of\n  /// the memory buffer.\n  unsigned AddNewSourceBuffer(std::unique_ptr<MemoryBuffer> F,\n                              SMLoc IncludeLoc) {\n    SrcBuffer NB;\n    NB.Buffer = std::move(F);\n    NB.IncludeLoc = IncludeLoc;\n    Buffers.push_back(std::move(NB));\n    return Buffers.size();\n  }\n\n  /// Search for a file with the specified name in the current directory or in\n  /// one of the IncludeDirs.\n  ///\n  /// If no file is found, this returns 0, otherwise it returns the buffer ID\n  /// of the stacked file. The full path to the included file can be found in\n  /// \\p IncludedFile.\n  unsigned AddIncludeFile(const std::string &Filename, SMLoc IncludeLoc,\n                          std::string &IncludedFile);\n\n  /// Return the ID of the buffer containing the specified location.\n  ///\n  /// 0 is returned if the buffer is not found.\n  unsigned FindBufferContainingLoc(SMLoc Loc) const;\n\n  /// Find the line number for the specified location in the specified file.\n  /// This is not a fast method.\n  unsigned FindLineNumber(SMLoc Loc, unsigned BufferID = 0) const {\n    return getLineAndColumn(Loc, BufferID).first;\n  }\n\n  /// Find the line and column number for the specified location in the\n  /// specified file. This is not a fast method.\n  std::pair<unsigned, unsigned> getLineAndColumn(SMLoc Loc,\n                                                 unsigned BufferID = 0) const;\n\n  /// Get a string with the \\p SMLoc filename and line number\n  /// formatted in the standard style.\n  std::string getFormattedLocationNoOffset(SMLoc Loc,\n                                           bool IncludePath = false) const;\n\n  /// Given a line and column number in a mapped buffer, turn it into an SMLoc.\n  /// This will return a null SMLoc if the line/column location is invalid.\n  SMLoc FindLocForLineAndColumn(unsigned BufferID, unsigned LineNo,\n                                unsigned ColNo);\n\n  /// Emit a message about the specified location with the specified string.\n  ///\n  /// \\param ShowColors Display colored messages if output is a terminal and\n  /// the default error handler is used.\n  void PrintMessage(raw_ostream &OS, SMLoc Loc, DiagKind Kind, const Twine &Msg,\n                    ArrayRef<SMRange> Ranges = {},\n                    ArrayRef<SMFixIt> FixIts = {},\n                    bool ShowColors = true) const;\n\n  /// Emits a diagnostic to llvm::errs().\n  void PrintMessage(SMLoc Loc, DiagKind Kind, const Twine &Msg,\n                    ArrayRef<SMRange> Ranges = {},\n                    ArrayRef<SMFixIt> FixIts = {},\n                    bool ShowColors = true) const;\n\n  /// Emits a manually-constructed diagnostic to the given output stream.\n  ///\n  /// \\param ShowColors Display colored messages if output is a terminal and\n  /// the default error handler is used.\n  void PrintMessage(raw_ostream &OS, const SMDiagnostic &Diagnostic,\n                    bool ShowColors = true) const;\n\n  /// Return an SMDiagnostic at the specified location with the specified\n  /// string.\n  ///\n  /// \\param Msg If non-null, the kind of message (e.g., \"error\") which is\n  /// prefixed to the message.\n  SMDiagnostic GetMessage(SMLoc Loc, DiagKind Kind, const Twine &Msg,\n                          ArrayRef<SMRange> Ranges = {},\n                          ArrayRef<SMFixIt> FixIts = {}) const;\n\n  /// Prints the names of included files and the line of the file they were\n  /// included from. A diagnostic handler can use this before printing its\n  /// custom formatted message.\n  ///\n  /// \\param IncludeLoc The location of the include.\n  /// \\param OS the raw_ostream to print on.\n  void PrintIncludeStack(SMLoc IncludeLoc, raw_ostream &OS) const;\n};\n\n/// Represents a single fixit, a replacement of one range of text with another.\nclass SMFixIt {\n  SMRange Range;\n\n  std::string Text;\n\npublic:\n  SMFixIt(SMRange R, const Twine &Replacement);\n\n  SMFixIt(SMLoc Loc, const Twine &Replacement)\n      : SMFixIt(SMRange(Loc, Loc), Replacement) {}\n\n  StringRef getText() const { return Text; }\n  SMRange getRange() const { return Range; }\n\n  bool operator<(const SMFixIt &Other) const {\n    if (Range.Start.getPointer() != Other.Range.Start.getPointer())\n      return Range.Start.getPointer() < Other.Range.Start.getPointer();\n    if (Range.End.getPointer() != Other.Range.End.getPointer())\n      return Range.End.getPointer() < Other.Range.End.getPointer();\n    return Text < Other.Text;\n  }\n};\n\n/// Instances of this class encapsulate one diagnostic report, allowing\n/// printing to a raw_ostream as a caret diagnostic.\nclass SMDiagnostic {\n  const SourceMgr *SM = nullptr;\n  SMLoc Loc;\n  std::string Filename;\n  int LineNo = 0;\n  int ColumnNo = 0;\n  SourceMgr::DiagKind Kind = SourceMgr::DK_Error;\n  std::string Message, LineContents;\n  std::vector<std::pair<unsigned, unsigned>> Ranges;\n  SmallVector<SMFixIt, 4> FixIts;\n\npublic:\n  // Null diagnostic.\n  SMDiagnostic() = default;\n  // Diagnostic with no location (e.g. file not found, command line arg error).\n  SMDiagnostic(StringRef filename, SourceMgr::DiagKind Knd, StringRef Msg)\n      : Filename(filename), LineNo(-1), ColumnNo(-1), Kind(Knd), Message(Msg) {}\n\n  // Diagnostic with a location.\n  SMDiagnostic(const SourceMgr &sm, SMLoc L, StringRef FN, int Line, int Col,\n               SourceMgr::DiagKind Kind, StringRef Msg, StringRef LineStr,\n               ArrayRef<std::pair<unsigned, unsigned>> Ranges,\n               ArrayRef<SMFixIt> FixIts = {});\n\n  const SourceMgr *getSourceMgr() const { return SM; }\n  SMLoc getLoc() const { return Loc; }\n  StringRef getFilename() const { return Filename; }\n  int getLineNo() const { return LineNo; }\n  int getColumnNo() const { return ColumnNo; }\n  SourceMgr::DiagKind getKind() const { return Kind; }\n  StringRef getMessage() const { return Message; }\n  StringRef getLineContents() const { return LineContents; }\n  ArrayRef<std::pair<unsigned, unsigned>> getRanges() const { return Ranges; }\n\n  void addFixIt(const SMFixIt &Hint) { FixIts.push_back(Hint); }\n\n  ArrayRef<SMFixIt> getFixIts() const { return FixIts; }\n\n  void print(const char *ProgName, raw_ostream &S, bool ShowColors = true,\n             bool ShowKindLabel = true) const;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_SOURCEMGR_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "content": "//===- VirtualFileSystem.h - Virtual File System Layer ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the virtual file system interface vfs::FileSystem.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_VIRTUALFILESYSTEM_H\n#define LLVM_SUPPORT_VIRTUALFILESYSTEM_H\n\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Chrono.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/FileSystem.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include <cassert>\n#include <cstdint>\n#include <ctime>\n#include <memory>\n#include <stack>\n#include <string>\n#include <system_error>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass MemoryBuffer;\nclass MemoryBufferRef;\nclass Twine;\n\nnamespace vfs {\n\n/// The result of a \\p status operation.\nclass Status {\n  std::string Name;\n  llvm::sys::fs::UniqueID UID;\n  llvm::sys::TimePoint<> MTime;\n  uint32_t User;\n  uint32_t Group;\n  uint64_t Size;\n  llvm::sys::fs::file_type Type = llvm::sys::fs::file_type::status_error;\n  llvm::sys::fs::perms Perms;\n\npublic:\n  // FIXME: remove when files support multiple names\n  bool IsVFSMapped = false;\n\n  Status() = default;\n  Status(const llvm::sys::fs::file_status &Status);\n  Status(const Twine &Name, llvm::sys::fs::UniqueID UID,\n         llvm::sys::TimePoint<> MTime, uint32_t User, uint32_t Group,\n         uint64_t Size, llvm::sys::fs::file_type Type,\n         llvm::sys::fs::perms Perms);\n\n  /// Get a copy of a Status with a different name.\n  static Status copyWithNewName(const Status &In, const Twine &NewName);\n  static Status copyWithNewName(const llvm::sys::fs::file_status &In,\n                                const Twine &NewName);\n\n  /// Returns the name that should be used for this file or directory.\n  StringRef getName() const { return Name; }\n\n  /// @name Status interface from llvm::sys::fs\n  /// @{\n  llvm::sys::fs::file_type getType() const { return Type; }\n  llvm::sys::fs::perms getPermissions() const { return Perms; }\n  llvm::sys::TimePoint<> getLastModificationTime() const { return MTime; }\n  llvm::sys::fs::UniqueID getUniqueID() const { return UID; }\n  uint32_t getUser() const { return User; }\n  uint32_t getGroup() const { return Group; }\n  uint64_t getSize() const { return Size; }\n  /// @}\n  /// @name Status queries\n  /// These are static queries in llvm::sys::fs.\n  /// @{\n  bool equivalent(const Status &Other) const;\n  bool isDirectory() const;\n  bool isRegularFile() const;\n  bool isOther() const;\n  bool isSymlink() const;\n  bool isStatusKnown() const;\n  bool exists() const;\n  /// @}\n};\n\n/// Represents an open file.\nclass File {\npublic:\n  /// Destroy the file after closing it (if open).\n  /// Sub-classes should generally call close() inside their destructors.  We\n  /// cannot do that from the base class, since close is virtual.\n  virtual ~File();\n\n  /// Get the status of the file.\n  virtual llvm::ErrorOr<Status> status() = 0;\n\n  /// Get the name of the file\n  virtual llvm::ErrorOr<std::string> getName() {\n    if (auto Status = status())\n      return Status->getName().str();\n    else\n      return Status.getError();\n  }\n\n  /// Get the contents of the file as a \\p MemoryBuffer.\n  virtual llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>>\n  getBuffer(const Twine &Name, int64_t FileSize = -1,\n            bool RequiresNullTerminator = true, bool IsVolatile = false) = 0;\n\n  /// Closes the file.\n  virtual std::error_code close() = 0;\n};\n\n/// A member of a directory, yielded by a directory_iterator.\n/// Only information available on most platforms is included.\nclass directory_entry {\n  std::string Path;\n  llvm::sys::fs::file_type Type = llvm::sys::fs::file_type::type_unknown;\n\npublic:\n  directory_entry() = default;\n  directory_entry(std::string Path, llvm::sys::fs::file_type Type)\n      : Path(std::move(Path)), Type(Type) {}\n\n  llvm::StringRef path() const { return Path; }\n  llvm::sys::fs::file_type type() const { return Type; }\n};\n\nnamespace detail {\n\n/// An interface for virtual file systems to provide an iterator over the\n/// (non-recursive) contents of a directory.\nstruct DirIterImpl {\n  virtual ~DirIterImpl();\n\n  /// Sets \\c CurrentEntry to the next entry in the directory on success,\n  /// to directory_entry() at end,  or returns a system-defined \\c error_code.\n  virtual std::error_code increment() = 0;\n\n  directory_entry CurrentEntry;\n};\n\n} // namespace detail\n\n/// An input iterator over the entries in a virtual path, similar to\n/// llvm::sys::fs::directory_iterator.\nclass directory_iterator {\n  std::shared_ptr<detail::DirIterImpl> Impl; // Input iterator semantics on copy\n\npublic:\n  directory_iterator(std::shared_ptr<detail::DirIterImpl> I)\n      : Impl(std::move(I)) {\n    assert(Impl.get() != nullptr && \"requires non-null implementation\");\n    if (Impl->CurrentEntry.path().empty())\n      Impl.reset(); // Normalize the end iterator to Impl == nullptr.\n  }\n\n  /// Construct an 'end' iterator.\n  directory_iterator() = default;\n\n  /// Equivalent to operator++, with an error code.\n  directory_iterator &increment(std::error_code &EC) {\n    assert(Impl && \"attempting to increment past end\");\n    EC = Impl->increment();\n    if (Impl->CurrentEntry.path().empty())\n      Impl.reset(); // Normalize the end iterator to Impl == nullptr.\n    return *this;\n  }\n\n  const directory_entry &operator*() const { return Impl->CurrentEntry; }\n  const directory_entry *operator->() const { return &Impl->CurrentEntry; }\n\n  bool operator==(const directory_iterator &RHS) const {\n    if (Impl && RHS.Impl)\n      return Impl->CurrentEntry.path() == RHS.Impl->CurrentEntry.path();\n    return !Impl && !RHS.Impl;\n  }\n  bool operator!=(const directory_iterator &RHS) const {\n    return !(*this == RHS);\n  }\n};\n\nclass FileSystem;\n\nnamespace detail {\n\n/// Keeps state for the recursive_directory_iterator.\nstruct RecDirIterState {\n  std::stack<directory_iterator, std::vector<directory_iterator>> Stack;\n  bool HasNoPushRequest = false;\n};\n\n} // end namespace detail\n\n/// An input iterator over the recursive contents of a virtual path,\n/// similar to llvm::sys::fs::recursive_directory_iterator.\nclass recursive_directory_iterator {\n  FileSystem *FS;\n  std::shared_ptr<detail::RecDirIterState>\n      State; // Input iterator semantics on copy.\n\npublic:\n  recursive_directory_iterator(FileSystem &FS, const Twine &Path,\n                               std::error_code &EC);\n\n  /// Construct an 'end' iterator.\n  recursive_directory_iterator() = default;\n\n  /// Equivalent to operator++, with an error code.\n  recursive_directory_iterator &increment(std::error_code &EC);\n\n  const directory_entry &operator*() const { return *State->Stack.top(); }\n  const directory_entry *operator->() const { return &*State->Stack.top(); }\n\n  bool operator==(const recursive_directory_iterator &Other) const {\n    return State == Other.State; // identity\n  }\n  bool operator!=(const recursive_directory_iterator &RHS) const {\n    return !(*this == RHS);\n  }\n\n  /// Gets the current level. Starting path is at level 0.\n  int level() const {\n    assert(!State->Stack.empty() &&\n           \"Cannot get level without any iteration state\");\n    return State->Stack.size() - 1;\n  }\n\n  void no_push() { State->HasNoPushRequest = true; }\n};\n\n/// The virtual file system interface.\nclass FileSystem : public llvm::ThreadSafeRefCountedBase<FileSystem> {\npublic:\n  virtual ~FileSystem();\n\n  /// Get the status of the entry at \\p Path, if one exists.\n  virtual llvm::ErrorOr<Status> status(const Twine &Path) = 0;\n\n  /// Get a \\p File object for the file at \\p Path, if one exists.\n  virtual llvm::ErrorOr<std::unique_ptr<File>>\n  openFileForRead(const Twine &Path) = 0;\n\n  /// This is a convenience method that opens a file, gets its content and then\n  /// closes the file.\n  llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>>\n  getBufferForFile(const Twine &Name, int64_t FileSize = -1,\n                   bool RequiresNullTerminator = true, bool IsVolatile = false);\n\n  /// Get a directory_iterator for \\p Dir.\n  /// \\note The 'end' iterator is directory_iterator().\n  virtual directory_iterator dir_begin(const Twine &Dir,\n                                       std::error_code &EC) = 0;\n\n  /// Set the working directory. This will affect all following operations on\n  /// this file system and may propagate down for nested file systems.\n  virtual std::error_code setCurrentWorkingDirectory(const Twine &Path) = 0;\n\n  /// Get the working directory of this file system.\n  virtual llvm::ErrorOr<std::string> getCurrentWorkingDirectory() const = 0;\n\n  /// Gets real path of \\p Path e.g. collapse all . and .. patterns, resolve\n  /// symlinks. For real file system, this uses `llvm::sys::fs::real_path`.\n  /// This returns errc::operation_not_permitted if not implemented by subclass.\n  virtual std::error_code getRealPath(const Twine &Path,\n                                      SmallVectorImpl<char> &Output) const;\n\n  /// Check whether a file exists. Provided for convenience.\n  bool exists(const Twine &Path);\n\n  /// Is the file mounted on a local filesystem?\n  virtual std::error_code isLocal(const Twine &Path, bool &Result);\n\n  /// Make \\a Path an absolute path.\n  ///\n  /// Makes \\a Path absolute using the current directory if it is not already.\n  /// An empty \\a Path will result in the current directory.\n  ///\n  /// /absolute/path   => /absolute/path\n  /// relative/../path => <current-directory>/relative/../path\n  ///\n  /// \\param Path A path that is modified to be an absolute path.\n  /// \\returns success if \\a path has been made absolute, otherwise a\n  ///          platform-specific error_code.\n  virtual std::error_code makeAbsolute(SmallVectorImpl<char> &Path) const;\n};\n\n/// Gets an \\p vfs::FileSystem for the 'real' file system, as seen by\n/// the operating system.\n/// The working directory is linked to the process's working directory.\n/// (This is usually thread-hostile).\nIntrusiveRefCntPtr<FileSystem> getRealFileSystem();\n\n/// Create an \\p vfs::FileSystem for the 'real' file system, as seen by\n/// the operating system.\n/// It has its own working directory, independent of (but initially equal to)\n/// that of the process.\nstd::unique_ptr<FileSystem> createPhysicalFileSystem();\n\n/// A file system that allows overlaying one \\p AbstractFileSystem on top\n/// of another.\n///\n/// Consists of a stack of >=1 \\p FileSystem objects, which are treated as being\n/// one merged file system. When there is a directory that exists in more than\n/// one file system, the \\p OverlayFileSystem contains a directory containing\n/// the union of their contents.  The attributes (permissions, etc.) of the\n/// top-most (most recently added) directory are used.  When there is a file\n/// that exists in more than one file system, the file in the top-most file\n/// system overrides the other(s).\nclass OverlayFileSystem : public FileSystem {\n  using FileSystemList = SmallVector<IntrusiveRefCntPtr<FileSystem>, 1>;\n\n  /// The stack of file systems, implemented as a list in order of\n  /// their addition.\n  FileSystemList FSList;\n\npublic:\n  OverlayFileSystem(IntrusiveRefCntPtr<FileSystem> Base);\n\n  /// Pushes a file system on top of the stack.\n  void pushOverlay(IntrusiveRefCntPtr<FileSystem> FS);\n\n  llvm::ErrorOr<Status> status(const Twine &Path) override;\n  llvm::ErrorOr<std::unique_ptr<File>>\n  openFileForRead(const Twine &Path) override;\n  directory_iterator dir_begin(const Twine &Dir, std::error_code &EC) override;\n  llvm::ErrorOr<std::string> getCurrentWorkingDirectory() const override;\n  std::error_code setCurrentWorkingDirectory(const Twine &Path) override;\n  std::error_code isLocal(const Twine &Path, bool &Result) override;\n  std::error_code getRealPath(const Twine &Path,\n                              SmallVectorImpl<char> &Output) const override;\n\n  using iterator = FileSystemList::reverse_iterator;\n  using const_iterator = FileSystemList::const_reverse_iterator;\n  using reverse_iterator = FileSystemList::iterator;\n  using const_reverse_iterator = FileSystemList::const_iterator;\n\n  /// Get an iterator pointing to the most recently added file system.\n  iterator overlays_begin() { return FSList.rbegin(); }\n  const_iterator overlays_begin() const { return FSList.rbegin(); }\n\n  /// Get an iterator pointing one-past the least recently added file system.\n  iterator overlays_end() { return FSList.rend(); }\n  const_iterator overlays_end() const { return FSList.rend(); }\n\n  /// Get an iterator pointing to the least recently added file system.\n  reverse_iterator overlays_rbegin() { return FSList.begin(); }\n  const_reverse_iterator overlays_rbegin() const { return FSList.begin(); }\n\n  /// Get an iterator pointing one-past the most recently added file system.\n  reverse_iterator overlays_rend() { return FSList.end(); }\n  const_reverse_iterator overlays_rend() const { return FSList.end(); }\n};\n\n/// By default, this delegates all calls to the underlying file system. This\n/// is useful when derived file systems want to override some calls and still\n/// proxy other calls.\nclass ProxyFileSystem : public FileSystem {\npublic:\n  explicit ProxyFileSystem(IntrusiveRefCntPtr<FileSystem> FS)\n      : FS(std::move(FS)) {}\n\n  llvm::ErrorOr<Status> status(const Twine &Path) override {\n    return FS->status(Path);\n  }\n  llvm::ErrorOr<std::unique_ptr<File>>\n  openFileForRead(const Twine &Path) override {\n    return FS->openFileForRead(Path);\n  }\n  directory_iterator dir_begin(const Twine &Dir, std::error_code &EC) override {\n    return FS->dir_begin(Dir, EC);\n  }\n  llvm::ErrorOr<std::string> getCurrentWorkingDirectory() const override {\n    return FS->getCurrentWorkingDirectory();\n  }\n  std::error_code setCurrentWorkingDirectory(const Twine &Path) override {\n    return FS->setCurrentWorkingDirectory(Path);\n  }\n  std::error_code getRealPath(const Twine &Path,\n                              SmallVectorImpl<char> &Output) const override {\n    return FS->getRealPath(Path, Output);\n  }\n  std::error_code isLocal(const Twine &Path, bool &Result) override {\n    return FS->isLocal(Path, Result);\n  }\n\nprotected:\n  FileSystem &getUnderlyingFS() { return *FS; }\n\nprivate:\n  IntrusiveRefCntPtr<FileSystem> FS;\n\n  virtual void anchor();\n};\n\nnamespace detail {\n\nclass InMemoryDirectory;\nclass InMemoryFile;\n\n} // namespace detail\n\n/// An in-memory file system.\nclass InMemoryFileSystem : public FileSystem {\n  std::unique_ptr<detail::InMemoryDirectory> Root;\n  std::string WorkingDirectory;\n  bool UseNormalizedPaths = true;\n\n  /// If HardLinkTarget is non-null, a hardlink is created to the To path which\n  /// must be a file. If it is null then it adds the file as the public addFile.\n  bool addFile(const Twine &Path, time_t ModificationTime,\n               std::unique_ptr<llvm::MemoryBuffer> Buffer,\n               Optional<uint32_t> User, Optional<uint32_t> Group,\n               Optional<llvm::sys::fs::file_type> Type,\n               Optional<llvm::sys::fs::perms> Perms,\n               const detail::InMemoryFile *HardLinkTarget);\n\npublic:\n  explicit InMemoryFileSystem(bool UseNormalizedPaths = true);\n  ~InMemoryFileSystem() override;\n\n  /// Add a file containing a buffer or a directory to the VFS with a\n  /// path. The VFS owns the buffer.  If present, User, Group, Type\n  /// and Perms apply to the newly-created file or directory.\n  /// \\return true if the file or directory was successfully added,\n  /// false if the file or directory already exists in the file system with\n  /// different contents.\n  bool addFile(const Twine &Path, time_t ModificationTime,\n               std::unique_ptr<llvm::MemoryBuffer> Buffer,\n               Optional<uint32_t> User = None, Optional<uint32_t> Group = None,\n               Optional<llvm::sys::fs::file_type> Type = None,\n               Optional<llvm::sys::fs::perms> Perms = None);\n\n  /// Add a hard link to a file.\n  /// Here hard links are not intended to be fully equivalent to the classical\n  /// filesystem. Both the hard link and the file share the same buffer and\n  /// status (and thus have the same UniqueID). Because of this there is no way\n  /// to distinguish between the link and the file after the link has been\n  /// added.\n  ///\n  /// The To path must be an existing file or a hardlink. The From file must not\n  /// have been added before. The To Path must not be a directory. The From Node\n  /// is added as a hard link which points to the resolved file of To Node.\n  /// \\return true if the above condition is satisfied and hardlink was\n  /// successfully created, false otherwise.\n  bool addHardLink(const Twine &From, const Twine &To);\n\n  /// Add a buffer to the VFS with a path. The VFS does not own the buffer.\n  /// If present, User, Group, Type and Perms apply to the newly-created file\n  /// or directory.\n  /// \\return true if the file or directory was successfully added,\n  /// false if the file or directory already exists in the file system with\n  /// different contents.\n  bool addFileNoOwn(const Twine &Path, time_t ModificationTime,\n                    const llvm::MemoryBufferRef &Buffer,\n                    Optional<uint32_t> User = None,\n                    Optional<uint32_t> Group = None,\n                    Optional<llvm::sys::fs::file_type> Type = None,\n                    Optional<llvm::sys::fs::perms> Perms = None);\n\n  std::string toString() const;\n\n  /// Return true if this file system normalizes . and .. in paths.\n  bool useNormalizedPaths() const { return UseNormalizedPaths; }\n\n  llvm::ErrorOr<Status> status(const Twine &Path) override;\n  llvm::ErrorOr<std::unique_ptr<File>>\n  openFileForRead(const Twine &Path) override;\n  directory_iterator dir_begin(const Twine &Dir, std::error_code &EC) override;\n\n  llvm::ErrorOr<std::string> getCurrentWorkingDirectory() const override {\n    return WorkingDirectory;\n  }\n  /// Canonicalizes \\p Path by combining with the current working\n  /// directory and normalizing the path (e.g. remove dots). If the current\n  /// working directory is not set, this returns errc::operation_not_permitted.\n  ///\n  /// This doesn't resolve symlinks as they are not supported in in-memory file\n  /// system.\n  std::error_code getRealPath(const Twine &Path,\n                              SmallVectorImpl<char> &Output) const override;\n  std::error_code isLocal(const Twine &Path, bool &Result) override;\n  std::error_code setCurrentWorkingDirectory(const Twine &Path) override;\n};\n\n/// Get a globally unique ID for a virtual file or directory.\nllvm::sys::fs::UniqueID getNextVirtualUniqueID();\n\n/// Gets a \\p FileSystem for a virtual file system described in YAML\n/// format.\nstd::unique_ptr<FileSystem>\ngetVFSFromYAML(std::unique_ptr<llvm::MemoryBuffer> Buffer,\n               llvm::SourceMgr::DiagHandlerTy DiagHandler,\n               StringRef YAMLFilePath, void *DiagContext = nullptr,\n               IntrusiveRefCntPtr<FileSystem> ExternalFS = getRealFileSystem());\n\nstruct YAMLVFSEntry {\n  template <typename T1, typename T2>\n  YAMLVFSEntry(T1 &&VPath, T2 &&RPath, bool IsDirectory = false)\n      : VPath(std::forward<T1>(VPath)), RPath(std::forward<T2>(RPath)),\n        IsDirectory(IsDirectory) {}\n  std::string VPath;\n  std::string RPath;\n  bool IsDirectory = false;\n};\n\nclass RedirectingFSDirIterImpl;\nclass RedirectingFileSystemParser;\n\n/// A virtual file system parsed from a YAML file.\n///\n/// Currently, this class allows creating virtual files and directories. Virtual\n/// files map to existing external files in \\c ExternalFS, and virtual\n/// directories may either map to existing directories in \\c ExternalFS or list\n/// their contents in the form of other virtual directories and/or files.\n///\n/// The basic structure of the parsed file is:\n/// \\verbatim\n/// {\n///   'version': <version number>,\n///   <optional configuration>\n///   'roots': [\n///              <directory entries>\n///            ]\n/// }\n/// \\endverbatim\n///\n/// All configuration options are optional.\n///   'case-sensitive': <boolean, default=(true for Posix, false for Windows)>\n///   'use-external-names': <boolean, default=true>\n///   'overlay-relative': <boolean, default=false>\n///   'fallthrough': <boolean, default=true>\n///\n/// Virtual directories that list their contents are represented as\n/// \\verbatim\n/// {\n///   'type': 'directory',\n///   'name': <string>,\n///   'contents': [ <file or directory entries> ]\n/// }\n/// \\endverbatim\n///\n/// The default attributes for such virtual directories are:\n/// \\verbatim\n/// MTime = now() when created\n/// Perms = 0777\n/// User = Group = 0\n/// Size = 0\n/// UniqueID = unspecified unique value\n/// \\endverbatim\n///\n/// When a path prefix matches such a directory, the next component in the path\n/// is matched against the entries in the 'contents' array.\n///\n/// Re-mapped directories, on the other hand, are represented as\n/// /// \\verbatim\n/// {\n///   'type': 'directory-remap',\n///   'name': <string>,\n///   'use-external-name': <boolean>, # Optional\n///   'external-contents': <path to external directory>\n/// }\n/// \\endverbatim\n///\n/// and inherit their attributes from the external directory. When a path\n/// prefix matches such an entry, the unmatched components are appended to the\n/// 'external-contents' path, and the resulting path is looked up in the\n/// external file system instead.\n///\n/// Re-mapped files are represented as\n/// \\verbatim\n/// {\n///   'type': 'file',\n///   'name': <string>,\n///   'use-external-name': <boolean>, # Optional\n///   'external-contents': <path to external file>\n/// }\n/// \\endverbatim\n///\n/// Their attributes and file contents are determined by looking up the file at\n/// their 'external-contents' path in the external file system.\n///\n/// For 'file', 'directory' and 'directory-remap' entries the 'name' field may\n/// contain multiple path components (e.g. /path/to/file). However, any\n/// directory in such a path that contains more than one child must be uniquely\n/// represented by a 'directory' entry.\nclass RedirectingFileSystem : public vfs::FileSystem {\npublic:\n  enum EntryKind { EK_Directory, EK_DirectoryRemap, EK_File };\n  enum NameKind { NK_NotSet, NK_External, NK_Virtual };\n\n  /// A single file or directory in the VFS.\n  class Entry {\n    EntryKind Kind;\n    std::string Name;\n\n  public:\n    Entry(EntryKind K, StringRef Name) : Kind(K), Name(Name) {}\n    virtual ~Entry() = default;\n\n    StringRef getName() const { return Name; }\n    EntryKind getKind() const { return Kind; }\n  };\n\n  /// A directory in the vfs with explicitly specified contents.\n  class DirectoryEntry : public Entry {\n    std::vector<std::unique_ptr<Entry>> Contents;\n    Status S;\n\n  public:\n    /// Constructs a directory entry with explicitly specified contents.\n    DirectoryEntry(StringRef Name, std::vector<std::unique_ptr<Entry>> Contents,\n                   Status S)\n        : Entry(EK_Directory, Name), Contents(std::move(Contents)),\n          S(std::move(S)) {}\n\n    /// Constructs an empty directory entry.\n    DirectoryEntry(StringRef Name, Status S)\n        : Entry(EK_Directory, Name), S(std::move(S)) {}\n\n    Status getStatus() { return S; }\n\n    void addContent(std::unique_ptr<Entry> Content) {\n      Contents.push_back(std::move(Content));\n    }\n\n    Entry *getLastContent() const { return Contents.back().get(); }\n\n    using iterator = decltype(Contents)::iterator;\n\n    iterator contents_begin() { return Contents.begin(); }\n    iterator contents_end() { return Contents.end(); }\n\n    static bool classof(const Entry *E) { return E->getKind() == EK_Directory; }\n  };\n\n  /// A file or directory in the vfs that is mapped to a file or directory in\n  /// the external filesystem.\n  class RemapEntry : public Entry {\n    std::string ExternalContentsPath;\n    NameKind UseName;\n\n  protected:\n    RemapEntry(EntryKind K, StringRef Name, StringRef ExternalContentsPath,\n               NameKind UseName)\n        : Entry(K, Name), ExternalContentsPath(ExternalContentsPath),\n          UseName(UseName) {}\n\n  public:\n    StringRef getExternalContentsPath() const { return ExternalContentsPath; }\n\n    /// Whether to use the external path as the name for this file or directory.\n    bool useExternalName(bool GlobalUseExternalName) const {\n      return UseName == NK_NotSet ? GlobalUseExternalName\n                                  : (UseName == NK_External);\n    }\n\n    NameKind getUseName() const { return UseName; }\n\n    static bool classof(const Entry *E) {\n      switch (E->getKind()) {\n      case EK_DirectoryRemap:\n        LLVM_FALLTHROUGH;\n      case EK_File:\n        return true;\n      case EK_Directory:\n        return false;\n      }\n      llvm_unreachable(\"invalid entry kind\");\n    }\n  };\n\n  /// A directory in the vfs that maps to a directory in the external file\n  /// system.\n  class DirectoryRemapEntry : public RemapEntry {\n  public:\n    DirectoryRemapEntry(StringRef Name, StringRef ExternalContentsPath,\n                        NameKind UseName)\n        : RemapEntry(EK_DirectoryRemap, Name, ExternalContentsPath, UseName) {}\n\n    static bool classof(const Entry *E) {\n      return E->getKind() == EK_DirectoryRemap;\n    }\n  };\n\n  /// A file in the vfs that maps to a file in the external file system.\n  class FileEntry : public RemapEntry {\n  public:\n    FileEntry(StringRef Name, StringRef ExternalContentsPath, NameKind UseName)\n        : RemapEntry(EK_File, Name, ExternalContentsPath, UseName) {}\n\n    static bool classof(const Entry *E) { return E->getKind() == EK_File; }\n  };\n\n  /// Represents the result of a path lookup into the RedirectingFileSystem.\n  struct LookupResult {\n    /// The entry the looked-up path corresponds to.\n    Entry *E;\n\n  private:\n    /// When the found Entry is a DirectoryRemapEntry, stores the path in the\n    /// external file system that the looked-up path in the virtual file system\n    //  corresponds to.\n    Optional<std::string> ExternalRedirect;\n\n  public:\n    LookupResult(Entry *E, sys::path::const_iterator Start,\n                 sys::path::const_iterator End);\n\n    /// If the found Entry maps the the input path to a path in the external\n    /// file system (i.e. it is a FileEntry or DirectoryRemapEntry), returns\n    /// that path.\n    Optional<StringRef> getExternalRedirect() const {\n      if (isa<DirectoryRemapEntry>(E))\n        return StringRef(*ExternalRedirect);\n      if (auto *FE = dyn_cast<FileEntry>(E))\n        return FE->getExternalContentsPath();\n      return None;\n    }\n  };\n\nprivate:\n  friend class RedirectingFSDirIterImpl;\n  friend class RedirectingFileSystemParser;\n\n  bool shouldUseExternalFS() const { return IsFallthrough; }\n\n  /// Canonicalize path by removing \".\", \"..\", \"./\", components. This is\n  /// a VFS request, do not bother about symlinks in the path components\n  /// but canonicalize in order to perform the correct entry search.\n  std::error_code makeCanonical(SmallVectorImpl<char> &Path) const;\n\n  /// Whether to fall back to the external file system when an operation fails\n  /// with the given error code on a path associated with the provided Entry.\n  bool shouldFallBackToExternalFS(std::error_code EC, Entry *E = nullptr) const;\n\n  // In a RedirectingFileSystem, keys can be specified in Posix or Windows\n  // style (or even a mixture of both), so this comparison helper allows\n  // slashes (representing a root) to match backslashes (and vice versa).  Note\n  // that, other than the root, path components should not contain slashes or\n  // backslashes.\n  bool pathComponentMatches(llvm::StringRef lhs, llvm::StringRef rhs) const {\n    if ((CaseSensitive ? lhs.equals(rhs) : lhs.equals_lower(rhs)))\n      return true;\n    return (lhs == \"/\" && rhs == \"\\\\\") || (lhs == \"\\\\\" && rhs == \"/\");\n  }\n\n  /// The root(s) of the virtual file system.\n  std::vector<std::unique_ptr<Entry>> Roots;\n\n  /// The current working directory of the file system.\n  std::string WorkingDirectory;\n\n  /// The file system to use for external references.\n  IntrusiveRefCntPtr<FileSystem> ExternalFS;\n\n  /// If IsRelativeOverlay is set, this represents the directory\n  /// path that should be prefixed to each 'external-contents' entry\n  /// when reading from YAML files.\n  std::string ExternalContentsPrefixDir;\n\n  /// @name Configuration\n  /// @{\n\n  /// Whether to perform case-sensitive comparisons.\n  ///\n  /// Currently, case-insensitive matching only works correctly with ASCII.\n  bool CaseSensitive =\n#ifdef _WIN32\n      false;\n#else\n      true;\n#endif\n\n  /// IsRelativeOverlay marks whether a ExternalContentsPrefixDir path must\n  /// be prefixed in every 'external-contents' when reading from YAML files.\n  bool IsRelativeOverlay = false;\n\n  /// Whether to use to use the value of 'external-contents' for the\n  /// names of files.  This global value is overridable on a per-file basis.\n  bool UseExternalNames = true;\n\n  /// Whether to attempt a file lookup in external file system after it wasn't\n  /// found in VFS.\n  bool IsFallthrough = true;\n  /// @}\n\n  RedirectingFileSystem(IntrusiveRefCntPtr<FileSystem> ExternalFS);\n\n  /// Looks up the path <tt>[Start, End)</tt> in \\p From, possibly recursing\n  /// into the contents of \\p From if it is a directory. Returns a LookupResult\n  /// giving the matched entry and, if that entry is a FileEntry or\n  /// DirectoryRemapEntry, the path it redirects to in the external file system.\n  ErrorOr<LookupResult> lookupPathImpl(llvm::sys::path::const_iterator Start,\n                                       llvm::sys::path::const_iterator End,\n                                       Entry *From) const;\n\n  /// Get the status for a path with the provided \\c LookupResult.\n  ErrorOr<Status> status(const Twine &Path, const LookupResult &Result);\n\npublic:\n  /// Looks up \\p Path in \\c Roots and returns a LookupResult giving the\n  /// matched entry and, if the entry was a FileEntry or DirectoryRemapEntry,\n  /// the path it redirects to in the external file system.\n  ErrorOr<LookupResult> lookupPath(StringRef Path) const;\n\n  /// Parses \\p Buffer, which is expected to be in YAML format and\n  /// returns a virtual file system representing its contents.\n  static std::unique_ptr<RedirectingFileSystem>\n  create(std::unique_ptr<MemoryBuffer> Buffer,\n         SourceMgr::DiagHandlerTy DiagHandler, StringRef YAMLFilePath,\n         void *DiagContext, IntrusiveRefCntPtr<FileSystem> ExternalFS);\n\n  /// Redirect each of the remapped files from first to second.\n  static std::unique_ptr<RedirectingFileSystem>\n  create(ArrayRef<std::pair<std::string, std::string>> RemappedFiles,\n         bool UseExternalNames, FileSystem &ExternalFS);\n\n  ErrorOr<Status> status(const Twine &Path) override;\n  ErrorOr<std::unique_ptr<File>> openFileForRead(const Twine &Path) override;\n\n  std::error_code getRealPath(const Twine &Path,\n                              SmallVectorImpl<char> &Output) const override;\n\n  llvm::ErrorOr<std::string> getCurrentWorkingDirectory() const override;\n\n  std::error_code setCurrentWorkingDirectory(const Twine &Path) override;\n\n  std::error_code isLocal(const Twine &Path, bool &Result) override;\n\n  std::error_code makeAbsolute(SmallVectorImpl<char> &Path) const override;\n\n  directory_iterator dir_begin(const Twine &Dir, std::error_code &EC) override;\n\n  void setExternalContentsPrefixDir(StringRef PrefixDir);\n\n  StringRef getExternalContentsPrefixDir() const;\n\n  void setFallthrough(bool Fallthrough);\n\n  std::vector<llvm::StringRef> getRoots() const;\n\n  void dump(raw_ostream &OS) const;\n  void dumpEntry(raw_ostream &OS, Entry *E, int NumSpaces = 0) const;\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  LLVM_DUMP_METHOD void dump() const;\n#endif\n};\n\n/// Collect all pairs of <virtual path, real path> entries from the\n/// \\p YAMLFilePath. This is used by the module dependency collector to forward\n/// the entries into the reproducer output VFS YAML file.\nvoid collectVFSFromYAML(\n    std::unique_ptr<llvm::MemoryBuffer> Buffer,\n    llvm::SourceMgr::DiagHandlerTy DiagHandler, StringRef YAMLFilePath,\n    SmallVectorImpl<YAMLVFSEntry> &CollectedEntries,\n    void *DiagContext = nullptr,\n    IntrusiveRefCntPtr<FileSystem> ExternalFS = getRealFileSystem());\n\nclass YAMLVFSWriter {\n  std::vector<YAMLVFSEntry> Mappings;\n  Optional<bool> IsCaseSensitive;\n  Optional<bool> IsOverlayRelative;\n  Optional<bool> UseExternalNames;\n  std::string OverlayDir;\n\n  void addEntry(StringRef VirtualPath, StringRef RealPath, bool IsDirectory);\n\npublic:\n  YAMLVFSWriter() = default;\n\n  void addFileMapping(StringRef VirtualPath, StringRef RealPath);\n  void addDirectoryMapping(StringRef VirtualPath, StringRef RealPath);\n\n  void setCaseSensitivity(bool CaseSensitive) {\n    IsCaseSensitive = CaseSensitive;\n  }\n\n  void setUseExternalNames(bool UseExtNames) { UseExternalNames = UseExtNames; }\n\n  void setOverlayDir(StringRef OverlayDirectory) {\n    IsOverlayRelative = true;\n    OverlayDir.assign(OverlayDirectory.str());\n  }\n\n  const std::vector<YAMLVFSEntry> &getMappings() const { return Mappings; }\n\n  void write(llvm::raw_ostream &OS);\n};\n\n} // namespace vfs\n} // namespace llvm\n\n#endif // LLVM_SUPPORT_VIRTUALFILESYSTEM_H\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 0, "line": 1150}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 0, "line": 1150}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "b645dc842b9187a42a01415426795161", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1150}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "9084ab3306e48da3307a02a25ad2bb0a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1163}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 0, "line": 1163}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "a7fa12426c6a502729725fe958280daa", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1163}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "a28c4d664a0eef5874ed4df187f6b3b7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1181}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 0, "line": 1181}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "9785e03d81490d9e4dd2f4bcf39799cd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1181}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "a403f0c5c204aacb827bb8db933ce206", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1189}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 0, "line": 1189}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "392ccd181700824326e65878438b789e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 0, "line": 1189}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "6e27a7b78cf65f29d7aa01ccbb9f32e4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 0, "line": 2035}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 0, "line": 2035}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "0ab5cb7c1767ba24bbde576b9ff8e04e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 0, "line": 2035}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "295ce0303a1aa30c5c3c639fc998622b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 0, "line": 2037}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 0, "line": 2037}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "c72c2356ae7209a702eb7931b7d1a59a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 0, "line": 2037}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APInt.h", "reportHash": "330f597c1df73dad380e32e510042348", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 152}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 152}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "c115ec71ab7a032d1efed2937e7e455e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 152}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "d7c47ed532a049786f861f6a88090101", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 156}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 156}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "f82d2b8ca286cb761fba0e1eb44180fb", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 156}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "5a856a4b7583ce4986b61cfd0bafe8a8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 160}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 160}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "71b687391bbd00be06a2526eb9580ec0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 160}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "a0e45862f12dc473f2e63dd6ef455f0f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 164}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 164}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "bf7cb7388e396b60553e723141a974b1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 164}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "4b451f13b096d43ac880159f36e3f29a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 168}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 168}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "a96238bd6990ac1ba2d1868a29c8db0c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 168}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "d23938c48ba0bec39c640a493a397fa8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 172}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 1, "line": 172}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "c1b05f664e3ac1d8c3be9350213ba7e6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 1, "line": 172}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "541884a84bf44806ac6d8dfbe396075c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 1, "line": 176}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 1, "line": 176}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "c2bebdafded29d2c049daf27117fff2e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 1, "line": 176}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "0802a292e08e8e8b53b8e7e47f603788", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 1, "line": 179}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 1, "line": 179}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "a318039069f6293c954cc1584a2c7cb5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 1, "line": 179}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "7983f3bb869d2891e0de7f226bc859f2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 1, "line": 182}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 1, "line": 182}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "ba860153997db94b68d5733e212cf6bb", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 1, "line": 182}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "bd31b23b0f3cb3bd4610c2ccae857db9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 1, "line": 185}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 1, "line": 185}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "f79b5bca1865b33409f0c5b1af566acf", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 1, "line": 185}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "7238a891f0e51d2ef8fc114b2bf3c159", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 1, "line": 188}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 1, "line": 188}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "09619ede70f0090414cdd3bd8ca9cad7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 1, "line": 188}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "93bf51d17d6e2c8e3a8c8b8b742a5f97", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 1, "line": 191}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 1, "line": 191}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "3abc63f9010e5ea844eae7f4bcff13fa", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 1, "line": 191}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "f9ee03b1ec029ae575716bcac7927562", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 1, "line": 339}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 1, "line": 339}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "4bf302ccbc6ac5092942f63d5f0edca4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 1, "line": 339}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "ed4da1403bf6b52e2ed666a0089e112d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 1, "line": 340}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 1, "line": 340}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "728031653f75783ccc83213a5920f4aa", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 1, "line": 340}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "ee0c7d8a7e9297f1c3614c08ab95d04f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 1, "line": 341}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 1, "line": 341}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "d009497e29e967add097d0005249ebf1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 1, "line": 341}, "message": "'operator<=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "d6edc6c568a0202296183ffe4600b9ad", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 1, "line": 342}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 1, "line": 342}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "b8a4adbdf73098f36dce2c6c062d7636", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 1, "line": 342}, "message": "'operator>=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "5c7da2a4ec396b77d939bc7bf4a014f7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 1, "line": 343}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 1, "line": 343}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "ad9b2e530c26baa02243ef7e38f5c769", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 1, "line": 343}, "message": "'operator<' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "f09b9492bf28b498212f052c344a9788", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 1, "line": 344}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 1, "line": 344}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "23399cf41cf01819445662983190e55f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 1, "line": 344}, "message": "'operator>' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APSInt.h", "reportHash": "26098719c7407a1a97c6dd5125cd4e13", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 2, "line": 547}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 2, "line": 547}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "reportHash": "284fea81a99c42d5d7c7ff063b274ddb", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 2, "line": 547}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "reportHash": "e71f794fdf45f04571c2131d98f5b4ab", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 2, "line": 547}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 2, "line": 547}, "message": "'operator==<unsigned long>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "reportHash": "1a8717e5b9aaae224a33cae88996f095", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 2, "line": 547}, "message": "'operator==<unsigned long>' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "reportHash": "a11896a6554783ec0bb18738c3d2f8b8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 2, "line": 552}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 2, "line": 552}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "reportHash": "2bdf3ec15e3d80f49a3d5d325b524e46", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 2, "line": 552}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "reportHash": "e50e5446b433cda6c15bce116cebbada", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 2, "line": 557}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 2, "line": 557}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "reportHash": "18a43dbcfe72cf8786402f2f9a03e16a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 2, "line": 557}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "reportHash": "0da0c5ab2b389a180f7ece9364f2abfe", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 2, "line": 562}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 2, "line": 562}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "reportHash": "046f538a34eed6ef33f1b72ea654dcc3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 2, "line": 562}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ArrayRef.h", "reportHash": "61d77fd7b97dc67fccd5be198ad83ce6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 61}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 3, "line": 61}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/BitVector.h", "reportHash": "7a46034a64bf808f742295925d47d786", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 61}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/BitVector.h", "reportHash": "f5949af39c75cb0a5c4db940662f460c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 67}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 3, "line": 67}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/BitVector.h", "reportHash": "ae8cfe26f707781aff40fc7d8a73b4eb", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 67}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/BitVector.h", "reportHash": "23903916dd99fdb8388c21a4de436b7c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 516}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 3, "line": 516}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/BitVector.h", "reportHash": "ff867bff61280d83db5e9f1e69e1d2f4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 516}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/BitVector.h", "reportHash": "dbb4937dc819b680b803cfe88a2f5296", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 523}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 3, "line": 523}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/BitVector.h", "reportHash": "d0e405ddbbc09c2cce0a136f5d64c7d7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 3, "line": 523}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/BitVector.h", "reportHash": "9a4f3296478913907a922f0f036f0c61", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 4, "line": 86}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 4, "line": 86}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Hashing.h", "reportHash": "142ceabf3393821e72c0a007e92f3c72", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 4, "line": 89}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 4, "line": 89}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Hashing.h", "reportHash": "6bf76b1195dffdbf33b817446e533646", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 5, "line": 226}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 5, "line": 226}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "4cc62f81022ccc0f7cce77d040b11da5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 5, "line": 226}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "1d3f222fee5637c6e4ab7b8f71f41c09", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 5, "line": 232}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 5, "line": 232}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "496a00885f80654bf9cac00b988fad26", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 5, "line": 232}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "6f25c800df4bdf090f0ddf4a69896182", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 5, "line": 238}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 5, "line": 238}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "95faec8fd634e2d839b7ec7d479db31c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 5, "line": 238}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "e75851a7b75fe7390efd0b2eb01f27a2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 5, "line": 243}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 5, "line": 243}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "8ccb593dc80c7da17a1ad792bd3a767c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 5, "line": 243}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "a0052610d715a94ff2ee94ffc428a1c1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 5, "line": 248}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 5, "line": 248}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "e5e7d4bf7b9eaffc27b56e20a8530d54", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 5, "line": 248}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "ce0b4c4dcb0398c332c008f023683085", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 5, "line": 253}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 5, "line": 253}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "6518696ff9f168172d227250253f1c59", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 5, "line": 253}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "4b231994b6ea582dad3a08631eeab567", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 5, "line": 258}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 5, "line": 258}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "93d12aed3832a512958de6c5e09ec538", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 5, "line": 258}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "142eb1b24c844c1681d11fdf87102ec0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 5, "line": 263}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 5, "line": 263}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "6558a7fa3a218a6cf42082b248ec17bc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 5, "line": 263}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "2e16db43eafb814fd340be77c8a38eb1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 5, "line": 268}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 5, "line": 268}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "8c595a3d14e1f87067a32de174fe57ee", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 5, "line": 268}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "fd1752e6e74b593493dab4efda2204f1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 5, "line": 273}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 5, "line": 273}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "5e469e3114e709523c931928fcc8eb4e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 5, "line": 273}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h", "reportHash": "de98fe02a1526ac28d55a8d3943c36f2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 331}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 331}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "970fdb532a4a966f91f16713c9d56964", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 331}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "0200981d1d1fbcd833a7a53f5d27b70a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 338}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 338}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "5c0d44db8466f7987af04a8792cbb426", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 338}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "921f0ff3c9e4e7ce5a61f2f7b504a7a7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 343}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 343}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "5f50c841bd9a8ca9a3888b66c094a25a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 343}, "message": "'operator<' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "cbb2f57fa3195bed9345955f132e9c86", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 350}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 350}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "b6c82d48b4ae09fb2b0db5b94e528be3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 350}, "message": "'operator<=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "38f8becb271ebb289c863149671325e3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 355}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 355}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "55a9f563a75c2d46fbd67a6100112fb0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 355}, "message": "'operator>' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "4158b71f07a78e561ded5e20d373d5d4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 360}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 360}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "a9d0eff4404195518b542dd88a8133f7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 360}, "message": "'operator>=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "eaa3cb263de123e1ca5416b993f9611c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 365}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 365}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "c282d4c05c561467f35c46db57dc0634", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 365}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "9b1a3424da90a15bd65db2e815934568", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 370}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 370}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "2867711dc24db30e60a20bc69bcf82ae", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 370}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "1db99d6c309ea6e2ca7549ccdf68bdd5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 375}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 375}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "cd7df7973fe439395348cba687cddd20", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 375}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "b78aeb5ec0f163a1e4784ad07b6c1b8f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 380}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 380}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "f0d22de91c93d63b57848af2fded7e61", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 380}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "87e98cfb61f9df86099e7bc082beae2c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 6, "line": 384}, "message": "mark 'noexcept'"}, {"location": {"col": 38, "file": 6, "line": 384}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "cc07e77ebfa97911e6dff123fd0e0b8d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 6, "line": 384}, "message": "'operator<' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "8acecd357e2d184cfa492d878ca24bb3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 6, "line": 388}, "message": "mark 'noexcept'"}, {"location": {"col": 38, "file": 6, "line": 388}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "2c84e04647d48e5caba6fc4e3b486cb3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 6, "line": 388}, "message": "'operator<' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "4ea5dbe01330b3eec63698e73f1828c3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 393}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 393}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "26db9382699deef57bcfe1a3630a0536", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 393}, "message": "'operator<=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "32e8cabfae58d02aaaa7365901c91ea7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 398}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 398}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "415bdf016e47d7e436593a01d82390d1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 398}, "message": "'operator<=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "66dff5b12829fefd5bd8b18b15763f10", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 6, "line": 402}, "message": "mark 'noexcept'"}, {"location": {"col": 38, "file": 6, "line": 402}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "30c170a0c9ffd71451fb62f87c0fc797", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 6, "line": 402}, "message": "'operator>' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "c6877284ba4791c776a87270a0d40f6e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 6, "line": 406}, "message": "mark 'noexcept'"}, {"location": {"col": 38, "file": 6, "line": 406}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "e8a1ba6459d973a80f395b51734fa1dc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 6, "line": 406}, "message": "'operator>' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "b743bc10d4bd8bf2912ec2df1f7bdba1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 411}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 411}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "a7b2043cd175bf3783e72883130d435b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 411}, "message": "'operator>=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "d3952ca4e4b2ced73083716f5ea88b3e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 416}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 416}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "d847dd8184126b24961afbbf9f4c1ef2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 416}, "message": "'operator>=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "33ddb74e76b085c72d0ed3067c12bb90", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 421}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 421}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "ba511963b371e478f6abf7e8b8822beb", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 421}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "f2f51e792822bbe68c102135a8d6112f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 426}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 426}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "4351f80539db49fa75f85111f2e48fd1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 426}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "7ad3672a8344d595ac2e994ad439eb91", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 431}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 431}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "be9df2a5f8d6083ac4b26bcce9c54ca5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 431}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "4be45fd06d37013ec498308b8fb1aec6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 436}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 436}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "b0d2adf14e1f851266a7e277bca6e607", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 436}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "da7c3281f8f846a1b7e8584cbaa9246f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 441}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 441}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "27356dbe695a0da2dab33d74be70601b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 441}, "message": "'operator<' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "c05c3c8ada77ea3eafbbac980a026087", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 446}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 446}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "37171f9f80a1ceb11ef80d4861f1ade1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 446}, "message": "'operator<' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "314f7e1751b1035f6eb66c024c88c53b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 451}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 451}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "a31927fa03687c30814a94ba119ef2d9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 451}, "message": "'operator<=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "787c17f5f2b1057c903ca954645a7ebb", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 456}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 456}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "ca1733395af569d110b4c24ac8430e16", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 456}, "message": "'operator<=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "41c4367e489194c7b13054f808c3e1d2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 461}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 461}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "2cfc66f17a0ec66758c5ad51ad0ed299", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 461}, "message": "'operator>' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "7ce99f9e14b781f010adb0f0ce6d72a0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 466}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 466}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "3a0ce56cdbf0657cb96c19059853d85c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 466}, "message": "'operator>' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "7ccec941f8bc3fdaac72f457536eca67", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 471}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 471}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "c3557a3fe05d43b75996aab997ea39d1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 471}, "message": "'operator>=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "7c50ae952b160767fb75b4e87dc97ed0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 476}, "message": "mark 'noexcept'"}, {"location": {"col": 16, "file": 6, "line": 476}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "b071d19dcfe974331d485de1efc8a63f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 6, "line": 476}, "message": "'operator>=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/Optional.h", "reportHash": "b43ec04da79b470f4904a16efdab7ca9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 7, "line": 558}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 7, "line": 558}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "ad5d73b56a242999c23dee7e987a46e1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 668}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 7, "line": 668}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "f3e64f3f62a55c7c0bd44d1c97570f83", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 668}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "29a0606d8291d579a27d4c168b635575", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 690}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 7, "line": 690}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "764e9103739207ad83d53e6ce56321d6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 690}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "bd1e7a8017201072d3a2277078513626", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 824}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 7, "line": 824}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "216ce85df8fe950a5bf796bfce7d91db", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 824}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "c53bb94c26720b9c3a75518a9ce4900e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 977}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 7, "line": 977}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "25cd13da95de116aead386527da4a6c7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 977}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "1ff6910e803c2dfb41d65efa8e0903e0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 1040}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 7, "line": 1040}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "f6836ce7b1201a3b331d870740637b05", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 1040}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "794e8e604bf897e34bc271185df8dda8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 1043}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 7, "line": 1043}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "4673c79194f27c4ed787585b4312e0b8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 1043}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "3e09793269fe35d873dd2ce7a66442c6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 7, "line": 1131}, "message": "mark 'noexcept'"}, {"location": {"col": 35, "file": 7, "line": 1131}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "2ab483c3d11452ffa48ab1ead465dfda", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 7, "line": 1131}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "7bfb9c9923e20c6a2aa525a059b7a81f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 7, "line": 1136}, "message": "mark 'noexcept'"}, {"location": {"col": 35, "file": 7, "line": 1136}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "6d81a669c01b6617f67a151a3e62e571", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 35, "file": 7, "line": 1136}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "fe956412666ea1ea91df565e094a90c8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 1873}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 7, "line": 1873}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "70dc143d7a3826ce958b03bb17639481", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 1873}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/STLExtras.h", "reportHash": "120428d0166690a02a16ae35d3acafdc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 8, "line": 236}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 8, "line": 236}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "a7a5d4da6b36c7756e5e55afed7b28da", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 8, "line": 236}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "828bcba39dd5c69605e09fee0293f51c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 8, "line": 239}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 8, "line": 239}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "4cdd30c57cc8b1295c01c6bfae7b58b5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 8, "line": 239}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "4396c094468fed0c3c6673fc78f54f54", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 8, "line": 423}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 8, "line": 423}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "6eda990c0496244a280466081b444374", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 8, "line": 423}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "b1f93b6339e559fa2c685adbb16e4a64", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 8, "line": 439}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 8, "line": 439}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "ac870d9ff0cb1d73f549beb03543ce03", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 8, "line": 439}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h", "reportHash": "a80d7416beeeb842d5c8e35ea6c27bcf", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 9, "line": 921}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 9, "line": 921}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallVector.h", "reportHash": "53ea418c5318fedd1bc55c9fa790fab1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 9, "line": 921}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallVector.h", "reportHash": "d67ff2179f198a1c5fadf636947e27b1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 9, "line": 925}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 9, "line": 925}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallVector.h", "reportHash": "8852c6a65002cef989bff47302c85880", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 9, "line": 925}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallVector.h", "reportHash": "e6cee7f614842d2f9a2afd6503bd5165", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 9, "line": 929}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 9, "line": 929}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallVector.h", "reportHash": "8889e89d0d06764dd360aee97c5b734a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 9, "line": 929}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallVector.h", "reportHash": "5e3e17b7d78f9c5dfdc70e47f83a36d1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 254}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 10, "line": 254}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "40baccd49dc826b5cae1a9c9a7d0995f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 254}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "7361020c668f4312a6f004f791c058bf", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 271}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 10, "line": 271}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "35f82d5d71bcf972e42bef75069f2b15", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 10, "line": 271}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "8f5ee25ea1b0b3cc2fc25e10e089a8d8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 10, "line": 392}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 10, "line": 392}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringMap.h", "reportHash": "e86b072ce5da6976bc00bf16d041ec12", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 11, "line": 900}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 11, "line": 900}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringRef.h", "reportHash": "4b9813eea0735b1b21a3e61ff22c6cc0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 11, "line": 904}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 11, "line": 904}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringRef.h", "reportHash": "99eaf08a142a8e32fc2eac8f380842a0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 11, "line": 906}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 11, "line": 906}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringRef.h", "reportHash": "fd5868cd475cc853f7cfa2a5b05df580", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 11, "line": 910}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 11, "line": 910}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringRef.h", "reportHash": "4d14f5d43f28f4f6dfe8a38618ce7ce4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 11, "line": 914}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 11, "line": 914}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringRef.h", "reportHash": "736d2ed379d1347cacd5257e162fa2a4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 11, "line": 918}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 11, "line": 918}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringRef.h", "reportHash": "87efb94e0d76cb6e7efa0aa6b30cc334", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 12, "line": 146}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 12, "line": 146}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "00c06f3368b1a3a92a2e5b7436579be3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 12, "line": 146}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "7123aeb573a63d156ac9585d5e7e87da", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 12, "line": 151}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 12, "line": 151}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "2ab86806d0afedade9ebb95ae89880de", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 12, "line": 151}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "bf0258acc5e21b65224c9386caa39c44", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 12, "line": 158}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 12, "line": 158}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "8e9bd5a79661936c15bb5067a699cf6d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 12, "line": 158}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "b3f63d047ce90991322de4ae03fdf8d0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 12, "line": 164}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 12, "line": 164}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "41f99e7005e51e989d9fca71cbc1d15f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 12, "line": 164}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "60e6677112bb59fe3e95fe6a53ffaf14", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 12, "line": 265}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 12, "line": 265}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "7307ce3cacde71102e559f5cc0594388", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 12, "line": 269}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 12, "line": 269}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/iterator.h", "reportHash": "60a6b86eff098d31424f7afdd44a8060", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 13, "line": 46}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 13, "line": 46}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "337977193ce858f7e85cdf5c840643ae", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 13, "line": 47}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 13, "line": 47}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "b31d9defeb8e95928245d4d81c74fb79", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 13, "line": 48}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 13, "line": 48}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "a6226b5762583904eb151708c903e9b0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 13, "line": 49}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 13, "line": 49}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "7f5810c8f22c469ee811cde44418d148", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 13, "line": 50}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 13, "line": 50}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "d6ea6e120093a1cf9aab04a887e7ffbc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 13, "line": 51}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 13, "line": 51}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "124f08736a02981ebc107b6bea1a9cb0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 258}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 13, "line": 258}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "d0d4ce5bda46416930e64bc4259ae10e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 258}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "0f140d1a656dc4e608a9822189c17181", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 262}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 13, "line": 262}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "639ddaf663294c147e091874d2ff4848", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 262}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "41021330650c9a71f86aea78ff8e73d1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 266}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 13, "line": 266}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "8b7d009729e36683b7a7b02177a83041", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 266}, "message": "'operator<=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "dfad77c3331faf3e08695dc8a9bbef51", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 270}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 13, "line": 270}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "252533bea47036ebde91de0a3049c93e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 270}, "message": "'operator>=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "bffcfc7df8c80824a2e2e9461bbf79ef", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 274}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 13, "line": 274}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "3b58a60a45b2e8f2248234806f0d9c1a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 274}, "message": "'operator<' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "5e5f16a41126d6cc14a91e6c0cb80c58", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 278}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 13, "line": 278}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "65d7028c7be27e6fcfe8de1e45ead869", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 278}, "message": "'operator>' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "dc15895e3046bc5bc3a31c815be7fae5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 284}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 13, "line": 284}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "4e944e61c91580ca3ef1c806baf4b323", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 284}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "88ee4a6a9a66ff10cbe7dba1183b9476", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 287}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 13, "line": 287}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "1930a4b0bee8fa5a08e04434d46fc05b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 287}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "6f6465092e6d7d849bde4407621cce97", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 292}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 13, "line": 292}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "1541346123db311724115b5108cc4f25", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 295}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 13, "line": 295}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "1f04514ba91c136b31a08788f3e10df6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 298}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 13, "line": 298}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "1d9a98e59dea257792afd90496b006c2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 301}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 13, "line": 301}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "13020a004e3e134f8bc01389bb4edc98", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 304}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 13, "line": 304}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "7b8f750d3fd8c5d2fc5e6ab750df523a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 13, "line": 307}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 13, "line": 307}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "0f731a2ebf8ad8d3eea8c6b4d9bf2e9e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 312}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 13, "line": 312}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "a0f80db7247242aa45ecc08880c7c9bd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 312}, "message": "'operator<=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "8a6a4cd58b138ea92cd8eea181f79d1b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 313}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 13, "line": 313}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "e65fd0638d677021c3276d567146b3d2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 313}, "message": "'operator>=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "3e1a95a99332249d2766d72020f2cbe4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 314}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 13, "line": 314}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "9712845b2a1025ea2ffd2ef7f298ebb2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 314}, "message": "'operator<' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "eccfb5024b167798b6e67d2ea51f8b9f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 315}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 13, "line": 315}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "6f944927b92204dda4e88ef9de7ad1dd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 315}, "message": "'operator>' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "fe55b597b4b09f210c6e31e8d54e3777", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 317}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 13, "line": 317}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "9ad27c617f0cfee5f40f56f9a3619929", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 317}, "message": "'operator<=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "6c58d98c1af0a866d27c6ee96ae707f1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 318}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 13, "line": 318}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "f3d46681a8ee9fcbd287fe1ce5f3c22a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 318}, "message": "'operator>=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "b5527073fae883f623de8ee4a116a86d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 319}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 13, "line": 319}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "8255abcb7ed8494d6a2b46dedb0f8bd9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 319}, "message": "'operator<' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "d0d20069ea34a740b8dcfe90ca2050a4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 320}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 13, "line": 320}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "ee648cb665d514c78e48d8f51dce0962", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 320}, "message": "'operator>' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "430f8f6535cf8d7b1f2e0733e688c57a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 322}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 13, "line": 322}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "a898022bb78198fe26cb5265e9d07ec7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 323}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 13, "line": 323}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "b2634b1c48fbf37c4774274ecfa965a5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 324}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 13, "line": 324}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "3eb46d1c339a44337d0d62cfd7bdc342", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 13, "line": 325}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 13, "line": 325}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Alignment.h", "reportHash": "52fee5b46c553a74f0db0fd78ea162a6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 14, "line": 266}, "message": "mark 'noexcept'"}, {"location": {"col": 1, "file": 14, "line": 266}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ErrorOr.h", "reportHash": "c64be87bc88f897d65bbdc71031e9686", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 1, "file": 14, "line": 266}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/ErrorOr.h", "reportHash": "05d3d302f3ef4b5105b89d7c98f3dedf", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1305}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 15, "line": 1305}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "71c0ec6d3c894698dd1f58642873fca7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1305}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "fa3585b0422772e3dbaf5331fad97cb3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1306}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 15, "line": 1306}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "9e717c8fbf1b5201eec2df1394b0abf0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1306}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "eec3efb11a7463405d0f6db7cb37aec5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1307}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 15, "line": 1307}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "964d6449594c99d582ada98e99eb8aed", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1307}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "e9ca4391e576c8fcfc6c786b96f88da1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1308}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 15, "line": 1308}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "fe9647e025a68db9b54b3a4dd367cb21", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1308}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "a565455dc05eff19a1c56858dab6e4ba", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1309}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 15, "line": 1309}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "30bb7584a62677eaf1a6b8cd12e6031d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1309}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "7f126c985499d31e790ab54fa5446cf5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1310}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 15, "line": 1310}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "342a3032722ffa6d160d05efc526bf13", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1310}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "39c87ac97ab3b75d8a99d33ee5f4b09d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1370}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 15, "line": 1370}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "97aeb180fb30300c05abdea6e4f1a9fc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1370}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "84e2477191abd275bb2ff7382e09581e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1380}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 15, "line": 1380}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "cf6ea2a1b6ed748bf218bb6131b6abe7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1380}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "bd46dabe2466c83374d069a9974418ff", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1485}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 15, "line": 1485}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "9be4ff5a3b5e2896458d3d87b80b130e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1485}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "282d7d7a985db845ec31fc0a531e8399", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1489}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 15, "line": 1489}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "d04d0c193c0793ba01d6b1f43a364fce", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 1489}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem.h", "reportHash": "15847ebc0589967b680fc8d412ac0f73", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 31}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 16, "line": 31}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem/UniqueID.h", "reportHash": "d7d64f0fa746f5cdbd12c47dad1c6336", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 31}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem/UniqueID.h", "reportHash": "5dc85d23500eed927b983f8117ead038", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 34}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 16, "line": 34}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem/UniqueID.h", "reportHash": "fb6e3fad5d522ff8252e10aeb629f722", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 34}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem/UniqueID.h", "reportHash": "e60d79d59e67863d0c7ba474d3349b3c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 35}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 16, "line": 35}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem/UniqueID.h", "reportHash": "3693d0ef3e8892636ee3dd39bec87675", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 35}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileSystem/UniqueID.h", "reportHash": "9429fe47662e44485ac4576b4ec16f22", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 17, "line": 104}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 17, "line": 104}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MD5.h", "reportHash": "4948c537ab6d6d56f4b30fd887bec358", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 18, "line": 40}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 18, "line": 40}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MemoryBufferRef.h", "reportHash": "5fd9ea9da4a5a7d877aac57ab99ba06d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 18, "line": 48}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 18, "line": 48}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/MemoryBufferRef.h", "reportHash": "79a0a317ebd53ca47f353f4658afeee8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 67}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 19, "line": 67}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Path.h", "reportHash": "d789b1fc1c8404946e366db9f2b9cd4f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 67}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Path.h", "reportHash": "fa7ecab53851419f88156efb600047d8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 92}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 19, "line": 92}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Path.h", "reportHash": "a877dcc1017fd8ca8ee095a3acd759d2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 92}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/Path.h", "reportHash": "9f718c0a55bfc3cbe27ddea7b92a4046", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 31}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 20, "line": 31}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SMLoc.h", "reportHash": "af4ab038ca479c686dc75c0d0ec93f22", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 31}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SMLoc.h", "reportHash": "0187ff38064ab873c3a1381de787b2d9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 32}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 20, "line": 32}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SMLoc.h", "reportHash": "034e91afc10125a48325c920d17aa608", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 32}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SMLoc.h", "reportHash": "336a27269c59d247b4d2f67dbfcc26a3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 21, "line": 240}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 21, "line": 240}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SourceMgr.h", "reportHash": "34a47d63dceb01a4f5e590271635535c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 21, "line": 240}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/SourceMgr.h", "reportHash": "f93d44acf504fc2b72a6af13996d077d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 22, "line": 185}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 22, "line": 185}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "2c00221ef06c1c4613847cb3af44d99e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 22, "line": 185}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "f09ccfb1a5c57007642d04b8b70c0ea7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 22, "line": 190}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 22, "line": 190}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "01e60bd8cc96a4dc7157e9f4b6552a5e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 22, "line": 190}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "10d9906a290a573629ca126ae361188f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 22, "line": 227}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 22, "line": 227}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "68dc3b4a9c828dee56b406258c45ecb2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 22, "line": 227}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "d1f15cce74f5455485970165fefef37d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 22, "line": 230}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 22, "line": 230}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "ec0e24076042494dc7d2f6d3e7749d6b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 22, "line": 230}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h", "reportHash": "d1f4117f7e11ddb6511fba150c68ba1b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
