<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h", "content": "//===- llvm/ADT/DepthFirstIterator.h - Depth First iterator -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file builds on the ADT/GraphTraits.h file to build generic depth\n// first graph iterator.  This file exposes the following functions/types:\n//\n// df_begin/df_end/df_iterator\n//   * Normal depth-first iteration - visit a node and then all of its children.\n//\n// idf_begin/idf_end/idf_iterator\n//   * Depth-first iteration on the 'inverse' graph.\n//\n// df_ext_begin/df_ext_end/df_ext_iterator\n//   * Normal depth-first iteration - visit a node and then all of its children.\n//     This iterator stores the 'visited' set in an external set, which allows\n//     it to be more efficient, and allows external clients to use the set for\n//     other purposes.\n//\n// idf_ext_begin/idf_ext_end/idf_ext_iterator\n//   * Depth-first iteration on the 'inverse' graph.\n//     This iterator stores the 'visited' set in an external set, which allows\n//     it to be more efficient, and allows external clients to use the set for\n//     other purposes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_DEPTHFIRSTITERATOR_H\n#define LLVM_ADT_DEPTHFIRSTITERATOR_H\n\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include <iterator>\n#include <set>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\n// df_iterator_storage - A private class which is used to figure out where to\n// store the visited set.\ntemplate<class SetType, bool External>   // Non-external set\nclass df_iterator_storage {\npublic:\n  SetType Visited;\n};\n\ntemplate<class SetType>\nclass df_iterator_storage<SetType, true> {\npublic:\n  df_iterator_storage(SetType &VSet) : Visited(VSet) {}\n  df_iterator_storage(const df_iterator_storage &S) : Visited(S.Visited) {}\n\n  SetType &Visited;\n};\n\n// The visited stated for the iteration is a simple set augmented with\n// one more method, completed, which is invoked when all children of a\n// node have been processed. It is intended to distinguish of back and\n// cross edges in the spanning tree but is not used in the common case.\ntemplate <typename NodeRef, unsigned SmallSize=8>\nstruct df_iterator_default_set : public SmallPtrSet<NodeRef, SmallSize> {\n  using BaseSet = SmallPtrSet<NodeRef, SmallSize>;\n  using iterator = typename BaseSet::iterator;\n\n  std::pair<iterator,bool> insert(NodeRef N) { return BaseSet::insert(N); }\n  template <typename IterT>\n  void insert(IterT Begin, IterT End) { BaseSet::insert(Begin,End); }\n\n  void completed(NodeRef) {}\n};\n\n// Generic Depth First Iterator\ntemplate <class GraphT,\n          class SetType =\n              df_iterator_default_set<typename GraphTraits<GraphT>::NodeRef>,\n          bool ExtStorage = false, class GT = GraphTraits<GraphT>>\nclass df_iterator\n    : public std::iterator<std::forward_iterator_tag, typename GT::NodeRef>,\n      public df_iterator_storage<SetType, ExtStorage> {\n  using super = std::iterator<std::forward_iterator_tag, typename GT::NodeRef>;\n  using NodeRef = typename GT::NodeRef;\n  using ChildItTy = typename GT::ChildIteratorType;\n\n  // First element is node reference, second is the 'next child' to visit.\n  // The second child is initialized lazily to pick up graph changes during the\n  // DFS.\n  using StackElement = std::pair<NodeRef, Optional<ChildItTy>>;\n\n  // VisitStack - Used to maintain the ordering.  Top = current block\n  std::vector<StackElement> VisitStack;\n\nprivate:\n  inline df_iterator(NodeRef Node) {\n    this->Visited.insert(Node);\n    VisitStack.push_back(StackElement(Node, None));\n  }\n\n  inline df_iterator() = default; // End is when stack is empty\n\n  inline df_iterator(NodeRef Node, SetType &S)\n      : df_iterator_storage<SetType, ExtStorage>(S) {\n    if (this->Visited.insert(Node).second)\n      VisitStack.push_back(StackElement(Node, None));\n  }\n\n  inline df_iterator(SetType &S)\n    : df_iterator_storage<SetType, ExtStorage>(S) {\n    // End is when stack is empty\n  }\n\n  inline void toNext() {\n    do {\n      NodeRef Node = VisitStack.back().first;\n      Optional<ChildItTy> &Opt = VisitStack.back().second;\n\n      if (!Opt)\n        Opt.emplace(GT::child_begin(Node));\n\n      // Notice that we directly mutate *Opt here, so that\n      // VisitStack.back().second actually gets updated as the iterator\n      // increases.\n      while (*Opt != GT::child_end(Node)) {\n        NodeRef Next = *(*Opt)++;\n        // Has our next sibling been visited?\n        if (this->Visited.insert(Next).second) {\n          // No, do it now.\n          VisitStack.push_back(StackElement(Next, None));\n          return;\n        }\n      }\n      this->Visited.completed(Node);\n\n      // Oops, ran out of successors... go up a level on the stack.\n      VisitStack.pop_back();\n    } while (!VisitStack.empty());\n  }\n\npublic:\n  using pointer = typename super::pointer;\n\n  // Provide static begin and end methods as our public \"constructors\"\n  static df_iterator begin(const GraphT &G) {\n    return df_iterator(GT::getEntryNode(G));\n  }\n  static df_iterator end(const GraphT &G) { return df_iterator(); }\n\n  // Static begin and end methods as our public ctors for external iterators\n  static df_iterator begin(const GraphT &G, SetType &S) {\n    return df_iterator(GT::getEntryNode(G), S);\n  }\n  static df_iterator end(const GraphT &G, SetType &S) { return df_iterator(S); }\n\n  bool operator==(const df_iterator &x) const {\n    return VisitStack == x.VisitStack;\n  }\n  bool operator!=(const df_iterator &x) const { return !(*this == x); }\n\n  const NodeRef &operator*() const { return VisitStack.back().first; }\n\n  // This is a nonstandard operator-> that dereferences the pointer an extra\n  // time... so that you can actually call methods ON the Node, because\n  // the contained type is a pointer.  This allows BBIt->getTerminator() f.e.\n  //\n  NodeRef operator->() const { return **this; }\n\n  df_iterator &operator++() { // Preincrement\n    toNext();\n    return *this;\n  }\n\n  /// Skips all children of the current node and traverses to next node\n  ///\n  /// Note: This function takes care of incrementing the iterator. If you\n  /// always increment and call this function, you risk walking off the end.\n  df_iterator &skipChildren() {\n    VisitStack.pop_back();\n    if (!VisitStack.empty())\n      toNext();\n    return *this;\n  }\n\n  df_iterator operator++(int) { // Postincrement\n    df_iterator tmp = *this;\n    ++*this;\n    return tmp;\n  }\n\n  // nodeVisited - return true if this iterator has already visited the\n  // specified node.  This is public, and will probably be used to iterate over\n  // nodes that a depth first iteration did not find: ie unreachable nodes.\n  //\n  bool nodeVisited(NodeRef Node) const {\n    return this->Visited.contains(Node);\n  }\n\n  /// getPathLength - Return the length of the path from the entry node to the\n  /// current node, counting both nodes.\n  unsigned getPathLength() const { return VisitStack.size(); }\n\n  /// getPath - Return the n'th node in the path from the entry node to the\n  /// current node.\n  NodeRef getPath(unsigned n) const { return VisitStack[n].first; }\n};\n\n// Provide global constructors that automatically figure out correct types...\n//\ntemplate <class T>\ndf_iterator<T> df_begin(const T& G) {\n  return df_iterator<T>::begin(G);\n}\n\ntemplate <class T>\ndf_iterator<T> df_end(const T& G) {\n  return df_iterator<T>::end(G);\n}\n\n// Provide an accessor method to use them in range-based patterns.\ntemplate <class T>\niterator_range<df_iterator<T>> depth_first(const T& G) {\n  return make_range(df_begin(G), df_end(G));\n}\n\n// Provide global definitions of external depth first iterators...\ntemplate <class T, class SetTy = std::set<typename GraphTraits<T>::NodeRef>>\nstruct df_ext_iterator : public df_iterator<T, SetTy, true> {\n  df_ext_iterator(const df_iterator<T, SetTy, true> &V)\n    : df_iterator<T, SetTy, true>(V) {}\n};\n\ntemplate <class T, class SetTy>\ndf_ext_iterator<T, SetTy> df_ext_begin(const T& G, SetTy &S) {\n  return df_ext_iterator<T, SetTy>::begin(G, S);\n}\n\ntemplate <class T, class SetTy>\ndf_ext_iterator<T, SetTy> df_ext_end(const T& G, SetTy &S) {\n  return df_ext_iterator<T, SetTy>::end(G, S);\n}\n\ntemplate <class T, class SetTy>\niterator_range<df_ext_iterator<T, SetTy>> depth_first_ext(const T& G,\n                                                          SetTy &S) {\n  return make_range(df_ext_begin(G, S), df_ext_end(G, S));\n}\n\n// Provide global definitions of inverse depth first iterators...\ntemplate <class T,\n          class SetTy =\n              df_iterator_default_set<typename GraphTraits<T>::NodeRef>,\n          bool External = false>\nstruct idf_iterator : public df_iterator<Inverse<T>, SetTy, External> {\n  idf_iterator(const df_iterator<Inverse<T>, SetTy, External> &V)\n    : df_iterator<Inverse<T>, SetTy, External>(V) {}\n};\n\ntemplate <class T>\nidf_iterator<T> idf_begin(const T& G) {\n  return idf_iterator<T>::begin(Inverse<T>(G));\n}\n\ntemplate <class T>\nidf_iterator<T> idf_end(const T& G){\n  return idf_iterator<T>::end(Inverse<T>(G));\n}\n\n// Provide an accessor method to use them in range-based patterns.\ntemplate <class T>\niterator_range<idf_iterator<T>> inverse_depth_first(const T& G) {\n  return make_range(idf_begin(G), idf_end(G));\n}\n\n// Provide global definitions of external inverse depth first iterators...\ntemplate <class T, class SetTy = std::set<typename GraphTraits<T>::NodeRef>>\nstruct idf_ext_iterator : public idf_iterator<T, SetTy, true> {\n  idf_ext_iterator(const idf_iterator<T, SetTy, true> &V)\n    : idf_iterator<T, SetTy, true>(V) {}\n  idf_ext_iterator(const df_iterator<Inverse<T>, SetTy, true> &V)\n    : idf_iterator<T, SetTy, true>(V) {}\n};\n\ntemplate <class T, class SetTy>\nidf_ext_iterator<T, SetTy> idf_ext_begin(const T& G, SetTy &S) {\n  return idf_ext_iterator<T, SetTy>::begin(Inverse<T>(G), S);\n}\n\ntemplate <class T, class SetTy>\nidf_ext_iterator<T, SetTy> idf_ext_end(const T& G, SetTy &S) {\n  return idf_ext_iterator<T, SetTy>::end(Inverse<T>(G), S);\n}\n\ntemplate <class T, class SetTy>\niterator_range<idf_ext_iterator<T, SetTy>> inverse_depth_first_ext(const T& G,\n                                                                   SetTy &S) {\n  return make_range(idf_ext_begin(G, S), idf_ext_end(G, S));\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_DEPTHFIRSTITERATOR_H\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h", "content": "//===- llvm/Analysis/AliasSetTracker.h - Build Alias Sets -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines two classes: AliasSetTracker and AliasSet. These interfaces\n// are used to classify a collection of pointer references into a maximal number\n// of disjoint sets. Each AliasSet object constructed by the AliasSetTracker\n// object refers to memory disjoint from the other sets.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_ALIASSETTRACKER_H\n#define LLVM_ANALYSIS_ALIASSETTRACKER_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/ADT/ilist_node.h\"\n#include \"llvm/Analysis/MemoryLocation.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <vector>\n\nnamespace llvm {\n\nclass AAResults;\nclass AliasSetTracker;\nclass BasicBlock;\nclass LoadInst;\nclass AnyMemSetInst;\nclass AnyMemTransferInst;\nclass raw_ostream;\nclass StoreInst;\nclass VAArgInst;\nclass Value;\n\nenum AliasResult : uint8_t;\n\nclass AliasSet : public ilist_node<AliasSet> {\n  friend class AliasSetTracker;\n\n  class PointerRec {\n    Value *Val;  // The pointer this record corresponds to.\n    PointerRec **PrevInList = nullptr;\n    PointerRec *NextInList = nullptr;\n    AliasSet *AS = nullptr;\n    LocationSize Size = LocationSize::mapEmpty();\n    AAMDNodes AAInfo;\n\n    // Whether the size for this record has been set at all. This makes no\n    // guarantees about the size being known.\n    bool isSizeSet() const { return Size != LocationSize::mapEmpty(); }\n\n  public:\n    PointerRec(Value *V)\n      : Val(V), AAInfo(DenseMapInfo<AAMDNodes>::getEmptyKey()) {}\n\n    Value *getValue() const { return Val; }\n\n    PointerRec *getNext() const { return NextInList; }\n    bool hasAliasSet() const { return AS != nullptr; }\n\n    PointerRec** setPrevInList(PointerRec **PIL) {\n      PrevInList = PIL;\n      return &NextInList;\n    }\n\n    bool updateSizeAndAAInfo(LocationSize NewSize, const AAMDNodes &NewAAInfo) {\n      bool SizeChanged = false;\n      if (NewSize != Size) {\n        LocationSize OldSize = Size;\n        Size = isSizeSet() ? Size.unionWith(NewSize) : NewSize;\n        SizeChanged = OldSize != Size;\n      }\n\n      if (AAInfo == DenseMapInfo<AAMDNodes>::getEmptyKey())\n        // We don't have a AAInfo yet. Set it to NewAAInfo.\n        AAInfo = NewAAInfo;\n      else {\n        AAMDNodes Intersection(AAInfo.intersect(NewAAInfo));\n        SizeChanged |= Intersection != AAInfo;\n        AAInfo = Intersection;\n      }\n      return SizeChanged;\n    }\n\n    LocationSize getSize() const {\n      assert(isSizeSet() && \"Getting an unset size!\");\n      return Size;\n    }\n\n    /// Return the AAInfo, or null if there is no information or conflicting\n    /// information.\n    AAMDNodes getAAInfo() const {\n      // If we have missing or conflicting AAInfo, return null.\n      if (AAInfo == DenseMapInfo<AAMDNodes>::getEmptyKey() ||\n          AAInfo == DenseMapInfo<AAMDNodes>::getTombstoneKey())\n        return AAMDNodes();\n      return AAInfo;\n    }\n\n    AliasSet *getAliasSet(AliasSetTracker &AST) {\n      assert(AS && \"No AliasSet yet!\");\n      if (AS->Forward) {\n        AliasSet *OldAS = AS;\n        AS = OldAS->getForwardedTarget(AST);\n        AS->addRef();\n        OldAS->dropRef(AST);\n      }\n      return AS;\n    }\n\n    void setAliasSet(AliasSet *as) {\n      assert(!AS && \"Already have an alias set!\");\n      AS = as;\n    }\n\n    void eraseFromList() {\n      if (NextInList) NextInList->PrevInList = PrevInList;\n      *PrevInList = NextInList;\n      if (AS->PtrListEnd == &NextInList) {\n        AS->PtrListEnd = PrevInList;\n        assert(*AS->PtrListEnd == nullptr && \"List not terminated right!\");\n      }\n      delete this;\n    }\n  };\n\n  // Doubly linked list of nodes.\n  PointerRec *PtrList = nullptr;\n  PointerRec **PtrListEnd;\n  // Forwarding pointer.\n  AliasSet *Forward = nullptr;\n\n  /// All instructions without a specific address in this alias set.\n  /// In rare cases this vector can have a null'ed out WeakVH\n  /// instances (can happen if some other loop pass deletes an\n  /// instruction in this list).\n  std::vector<WeakVH> UnknownInsts;\n\n  /// Number of nodes pointing to this AliasSet plus the number of AliasSets\n  /// forwarding to it.\n  unsigned RefCount : 27;\n\n  // Signifies that this set should be considered to alias any pointer.\n  // Use when the tracker holding this set is saturated.\n  unsigned AliasAny : 1;\n\n  /// The kinds of access this alias set models.\n  ///\n  /// We keep track of whether this alias set merely refers to the locations of\n  /// memory (and not any particular access), whether it modifies or references\n  /// the memory, or whether it does both. The lattice goes from \"NoAccess\" to\n  /// either RefAccess or ModAccess, then to ModRefAccess as necessary.\n  enum AccessLattice {\n    NoAccess = 0,\n    RefAccess = 1,\n    ModAccess = 2,\n    ModRefAccess = RefAccess | ModAccess\n  };\n  unsigned Access : 2;\n\n  /// The kind of alias relationship between pointers of the set.\n  ///\n  /// These represent conservatively correct alias results between any members\n  /// of the set. We represent these independently of the values of alias\n  /// results in order to pack it into a single bit. Lattice goes from\n  /// MustAlias to MayAlias.\n  enum AliasLattice {\n    SetMustAlias = 0, SetMayAlias = 1\n  };\n  unsigned Alias : 1;\n\n  unsigned SetSize = 0;\n\n  void addRef() { ++RefCount; }\n\n  void dropRef(AliasSetTracker &AST) {\n    assert(RefCount >= 1 && \"Invalid reference count detected!\");\n    if (--RefCount == 0)\n      removeFromTracker(AST);\n  }\n\n  Instruction *getUnknownInst(unsigned i) const {\n    assert(i < UnknownInsts.size());\n    return cast_or_null<Instruction>(UnknownInsts[i]);\n  }\n\npublic:\n  AliasSet(const AliasSet &) = delete;\n  AliasSet &operator=(const AliasSet &) = delete;\n\n  /// Accessors...\n  bool isRef() const { return Access & RefAccess; }\n  bool isMod() const { return Access & ModAccess; }\n  bool isMustAlias() const { return Alias == SetMustAlias; }\n  bool isMayAlias()  const { return Alias == SetMayAlias; }\n\n  /// Return true if this alias set should be ignored as part of the\n  /// AliasSetTracker object.\n  bool isForwardingAliasSet() const { return Forward; }\n\n  /// Merge the specified alias set into this alias set.\n  void mergeSetIn(AliasSet &AS, AliasSetTracker &AST);\n\n  // Alias Set iteration - Allow access to all of the pointers which are part of\n  // this alias set.\n  class iterator;\n  iterator begin() const { return iterator(PtrList); }\n  iterator end()   const { return iterator(); }\n  bool empty() const { return PtrList == nullptr; }\n\n  // Unfortunately, ilist::size() is linear, so we have to add code to keep\n  // track of the list's exact size.\n  unsigned size() { return SetSize; }\n\n  /// If this alias set is known to contain a single instruction and *only* a\n  /// single unique instruction, return it.  Otherwise, return nullptr.\n  Instruction* getUniqueInstruction();\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n\n  /// Define an iterator for alias sets... this is just a forward iterator.\n  class iterator : public std::iterator<std::forward_iterator_tag,\n                                        PointerRec, ptrdiff_t> {\n    PointerRec *CurNode;\n\n  public:\n    explicit iterator(PointerRec *CN = nullptr) : CurNode(CN) {}\n\n    bool operator==(const iterator& x) const {\n      return CurNode == x.CurNode;\n    }\n    bool operator!=(const iterator& x) const { return !operator==(x); }\n\n    value_type &operator*() const {\n      assert(CurNode && \"Dereferencing AliasSet.end()!\");\n      return *CurNode;\n    }\n    value_type *operator->() const { return &operator*(); }\n\n    Value *getPointer() const { return CurNode->getValue(); }\n    LocationSize getSize() const { return CurNode->getSize(); }\n    AAMDNodes getAAInfo() const { return CurNode->getAAInfo(); }\n\n    iterator& operator++() {                // Preincrement\n      assert(CurNode && \"Advancing past AliasSet.end()!\");\n      CurNode = CurNode->getNext();\n      return *this;\n    }\n    iterator operator++(int) { // Postincrement\n      iterator tmp = *this; ++*this; return tmp;\n    }\n  };\n\nprivate:\n  // Can only be created by AliasSetTracker.\n  AliasSet()\n      : PtrListEnd(&PtrList), RefCount(0),  AliasAny(false), Access(NoAccess),\n        Alias(SetMustAlias) {}\n\n  PointerRec *getSomePointer() const {\n    return PtrList;\n  }\n\n  /// Return the real alias set this represents. If this has been merged with\n  /// another set and is forwarding, return the ultimate destination set. This\n  /// also implements the union-find collapsing as well.\n  AliasSet *getForwardedTarget(AliasSetTracker &AST) {\n    if (!Forward) return this;\n\n    AliasSet *Dest = Forward->getForwardedTarget(AST);\n    if (Dest != Forward) {\n      Dest->addRef();\n      Forward->dropRef(AST);\n      Forward = Dest;\n    }\n    return Dest;\n  }\n\n  void removeFromTracker(AliasSetTracker &AST);\n\n  void addPointer(AliasSetTracker &AST, PointerRec &Entry, LocationSize Size,\n                  const AAMDNodes &AAInfo, bool KnownMustAlias = false,\n                  bool SkipSizeUpdate = false);\n  void addUnknownInst(Instruction *I, AAResults &AA);\n\n  void removeUnknownInst(AliasSetTracker &AST, Instruction *I) {\n    bool WasEmpty = UnknownInsts.empty();\n    for (size_t i = 0, e = UnknownInsts.size(); i != e; ++i)\n      if (UnknownInsts[i] == I) {\n        UnknownInsts[i] = UnknownInsts.back();\n        UnknownInsts.pop_back();\n        --i; --e;  // Revisit the moved entry.\n      }\n    if (!WasEmpty && UnknownInsts.empty())\n      dropRef(AST);\n  }\n\npublic:\n  /// If the specified pointer \"may\" (or must) alias one of the members in the\n  /// set return the appropriate AliasResult. Otherwise return NoAlias.\n  AliasResult aliasesPointer(const Value *Ptr, LocationSize Size,\n                             const AAMDNodes &AAInfo, AAResults &AA) const;\n  bool aliasesUnknownInst(const Instruction *Inst, AAResults &AA) const;\n};\n\ninline raw_ostream& operator<<(raw_ostream &OS, const AliasSet &AS) {\n  AS.print(OS);\n  return OS;\n}\n\nclass AliasSetTracker {\n  /// A CallbackVH to arrange for AliasSetTracker to be notified whenever a\n  /// Value is deleted.\n  class ASTCallbackVH final : public CallbackVH {\n    AliasSetTracker *AST;\n\n    void deleted() override;\n    void allUsesReplacedWith(Value *) override;\n\n  public:\n    ASTCallbackVH(Value *V, AliasSetTracker *AST = nullptr);\n\n    ASTCallbackVH &operator=(Value *V);\n  };\n  /// Traits to tell DenseMap that tell us how to compare and hash the value\n  /// handle.\n  struct ASTCallbackVHDenseMapInfo : public DenseMapInfo<Value *> {};\n\n  AAResults &AA;\n  ilist<AliasSet> AliasSets;\n\n  using PointerMapType = DenseMap<ASTCallbackVH, AliasSet::PointerRec *,\n                                  ASTCallbackVHDenseMapInfo>;\n\n  // Map from pointers to their node\n  PointerMapType PointerMap;\n\npublic:\n  /// Create an empty collection of AliasSets, and use the specified alias\n  /// analysis object to disambiguate load and store addresses.\n  explicit AliasSetTracker(AAResults &AA) : AA(AA) {}\n  ~AliasSetTracker() { clear(); }\n\n  /// These methods are used to add different types of instructions to the alias\n  /// sets. Adding a new instruction can result in one of three actions\n  /// happening:\n  ///\n  ///   1. If the instruction doesn't alias any other sets, create a new set.\n  ///   2. If the instruction aliases exactly one set, add it to the set\n  ///   3. If the instruction aliases multiple sets, merge the sets, and add\n  ///      the instruction to the result.\n  ///\n  /// These methods return true if inserting the instruction resulted in the\n  /// addition of a new alias set (i.e., the pointer did not alias anything).\n  ///\n  void add(Value *Ptr, LocationSize Size, const AAMDNodes &AAInfo); // Add a loc\n  void add(LoadInst *LI);\n  void add(StoreInst *SI);\n  void add(VAArgInst *VAAI);\n  void add(AnyMemSetInst *MSI);\n  void add(AnyMemTransferInst *MTI);\n  void add(Instruction *I);       // Dispatch to one of the other add methods...\n  void add(BasicBlock &BB);       // Add all instructions in basic block\n  void add(const AliasSetTracker &AST); // Add alias relations from another AST\n  void addUnknown(Instruction *I);\n\n  void clear();\n\n  /// Return the alias sets that are active.\n  const ilist<AliasSet> &getAliasSets() const { return AliasSets; }\n\n  /// Return the alias set which contains the specified memory location.  If\n  /// the memory location aliases two or more existing alias sets, will have\n  /// the effect of merging those alias sets before the single resulting alias\n  /// set is returned.\n  AliasSet &getAliasSetFor(const MemoryLocation &MemLoc);\n\n  /// Return the underlying alias analysis object used by this tracker.\n  AAResults &getAliasAnalysis() const { return AA; }\n\n  /// This method is used to remove a pointer value from the AliasSetTracker\n  /// entirely. It should be used when an instruction is deleted from the\n  /// program to update the AST. If you don't use this, you would have dangling\n  /// pointers to deleted instructions.\n  void deleteValue(Value *PtrVal);\n\n  /// This method should be used whenever a preexisting value in the program is\n  /// copied or cloned, introducing a new value.  Note that it is ok for clients\n  /// that use this method to introduce the same value multiple times: if the\n  /// tracker already knows about a value, it will ignore the request.\n  void copyValue(Value *From, Value *To);\n\n  using iterator = ilist<AliasSet>::iterator;\n  using const_iterator = ilist<AliasSet>::const_iterator;\n\n  const_iterator begin() const { return AliasSets.begin(); }\n  const_iterator end()   const { return AliasSets.end(); }\n\n  iterator begin() { return AliasSets.begin(); }\n  iterator end()   { return AliasSets.end(); }\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n\nprivate:\n  friend class AliasSet;\n\n  // The total number of pointers contained in all \"may\" alias sets.\n  unsigned TotalMayAliasSetSize = 0;\n\n  // A non-null value signifies this AST is saturated. A saturated AST lumps\n  // all pointers into a single \"May\" set.\n  AliasSet *AliasAnyAS = nullptr;\n\n  void removeAliasSet(AliasSet *AS);\n\n  /// Just like operator[] on the map, except that it creates an entry for the\n  /// pointer if it doesn't already exist.\n  AliasSet::PointerRec &getEntryFor(Value *V) {\n    AliasSet::PointerRec *&Entry = PointerMap[ASTCallbackVH(V, this)];\n    if (!Entry)\n      Entry = new AliasSet::PointerRec(V);\n    return *Entry;\n  }\n\n  AliasSet &addPointer(MemoryLocation Loc, AliasSet::AccessLattice E);\n  AliasSet *mergeAliasSetsForPointer(const Value *Ptr, LocationSize Size,\n                                     const AAMDNodes &AAInfo,\n                                     bool &MustAliasAll);\n\n  /// Merge all alias sets into a single set that is considered to alias any\n  /// pointer.\n  AliasSet &mergeAllAliasSets();\n\n  AliasSet *findAliasSetForUnknownInst(Instruction *Inst);\n};\n\ninline raw_ostream& operator<<(raw_ostream &OS, const AliasSetTracker &AST) {\n  AST.print(OS);\n  return OS;\n}\n\nclass AliasSetsPrinterPass : public PassInfoMixin<AliasSetsPrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit AliasSetsPrinterPass(raw_ostream &OS);\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ANALYSIS_ALIASSETTRACKER_H\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h", "content": "//===- MemoryLocation.h - Memory location descriptions ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This file provides utility analysis objects describing memory locations.\n/// These are used both by the Alias Analysis infrastructure and more\n/// specialized memory analysis layers.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_MEMORYLOCATION_H\n#define LLVM_ANALYSIS_MEMORYLOCATION_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/Support/TypeSize.h\"\n\nnamespace llvm {\n\nclass CallBase;\nclass Instruction;\nclass LoadInst;\nclass StoreInst;\nclass MemTransferInst;\nclass MemIntrinsic;\nclass AtomicCmpXchgInst;\nclass AtomicMemTransferInst;\nclass AtomicMemIntrinsic;\nclass AtomicRMWInst;\nclass AnyMemTransferInst;\nclass AnyMemIntrinsic;\nclass TargetLibraryInfo;\nclass VAArgInst;\n\n// Represents the size of a MemoryLocation. Logically, it's an\n// Optional<uint63_t> that also carries a bit to represent whether the integer\n// it contains, N, is 'precise'. Precise, in this context, means that we know\n// that the area of storage referenced by the given MemoryLocation must be\n// precisely N bytes. An imprecise value is formed as the union of two or more\n// precise values, and can conservatively represent all of the values unioned\n// into it. Importantly, imprecise values are an *upper-bound* on the size of a\n// MemoryLocation.\n//\n// Concretely, a precise MemoryLocation is (%p, 4) in\n// store i32 0, i32* %p\n//\n// Since we know that %p must be at least 4 bytes large at this point.\n// Otherwise, we have UB. An example of an imprecise MemoryLocation is (%p, 4)\n// at the memcpy in\n//\n//   %n = select i1 %foo, i64 1, i64 4\n//   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %baz, i64 %n, i32 1,\n//                                        i1 false)\n//\n// ...Since we'll copy *up to* 4 bytes into %p, but we can't guarantee that\n// we'll ever actually do so.\n//\n// If asked to represent a pathologically large value, this will degrade to\n// None.\nclass LocationSize {\n  enum : uint64_t {\n    BeforeOrAfterPointer = ~uint64_t(0),\n    AfterPointer = BeforeOrAfterPointer - 1,\n    MapEmpty = BeforeOrAfterPointer - 2,\n    MapTombstone = BeforeOrAfterPointer - 3,\n    ImpreciseBit = uint64_t(1) << 63,\n\n    // The maximum value we can represent without falling back to 'unknown'.\n    MaxValue = (MapTombstone - 1) & ~ImpreciseBit,\n  };\n\n  uint64_t Value;\n\n  // Hack to support implicit construction. This should disappear when the\n  // public LocationSize ctor goes away.\n  enum DirectConstruction { Direct };\n\n  constexpr LocationSize(uint64_t Raw, DirectConstruction): Value(Raw) {}\n\n  static_assert(AfterPointer & ImpreciseBit,\n                \"AfterPointer is imprecise by definition.\");\n  static_assert(BeforeOrAfterPointer & ImpreciseBit,\n                \"BeforeOrAfterPointer is imprecise by definition.\");\n\npublic:\n  // FIXME: Migrate all users to construct via either `precise` or `upperBound`,\n  // to make it more obvious at the callsite the kind of size that they're\n  // providing.\n  //\n  // Since the overwhelming majority of users of this provide precise values,\n  // this assumes the provided value is precise.\n  constexpr LocationSize(uint64_t Raw)\n      : Value(Raw > MaxValue ? AfterPointer : Raw) {}\n\n  static LocationSize precise(uint64_t Value) { return LocationSize(Value); }\n  static LocationSize precise(TypeSize Value) {\n    if (Value.isScalable())\n      return afterPointer();\n    return precise(Value.getFixedSize());\n  }\n\n  static LocationSize upperBound(uint64_t Value) {\n    // You can't go lower than 0, so give a precise result.\n    if (LLVM_UNLIKELY(Value == 0))\n      return precise(0);\n    if (LLVM_UNLIKELY(Value > MaxValue))\n      return afterPointer();\n    return LocationSize(Value | ImpreciseBit, Direct);\n  }\n  static LocationSize upperBound(TypeSize Value) {\n    if (Value.isScalable())\n      return afterPointer();\n    return upperBound(Value.getFixedSize());\n  }\n\n  /// Any location after the base pointer (but still within the underlying\n  /// object).\n  constexpr static LocationSize afterPointer() {\n    return LocationSize(AfterPointer, Direct);\n  }\n\n  /// Any location before or after the base pointer (but still within the\n  /// underlying object).\n  constexpr static LocationSize beforeOrAfterPointer() {\n    return LocationSize(BeforeOrAfterPointer, Direct);\n  }\n\n  // Sentinel values, generally used for maps.\n  constexpr static LocationSize mapTombstone() {\n    return LocationSize(MapTombstone, Direct);\n  }\n  constexpr static LocationSize mapEmpty() {\n    return LocationSize(MapEmpty, Direct);\n  }\n\n  // Returns a LocationSize that can correctly represent either `*this` or\n  // `Other`.\n  LocationSize unionWith(LocationSize Other) const {\n    if (Other == *this)\n      return *this;\n\n    if (Value == BeforeOrAfterPointer || Other.Value == BeforeOrAfterPointer)\n      return beforeOrAfterPointer();\n    if (Value == AfterPointer || Other.Value == AfterPointer)\n      return afterPointer();\n\n    return upperBound(std::max(getValue(), Other.getValue()));\n  }\n\n  bool hasValue() const {\n    return Value != AfterPointer && Value != BeforeOrAfterPointer;\n  }\n  uint64_t getValue() const {\n    assert(hasValue() && \"Getting value from an unknown LocationSize!\");\n    return Value & ~ImpreciseBit;\n  }\n\n  // Returns whether or not this value is precise. Note that if a value is\n  // precise, it's guaranteed to not be unknown.\n  bool isPrecise() const {\n    return (Value & ImpreciseBit) == 0;\n  }\n\n  // Convenience method to check if this LocationSize's value is 0.\n  bool isZero() const { return hasValue() && getValue() == 0; }\n\n  /// Whether accesses before the base pointer are possible.\n  bool mayBeBeforePointer() const { return Value == BeforeOrAfterPointer; }\n\n  bool operator==(const LocationSize &Other) const {\n    return Value == Other.Value;\n  }\n\n  bool operator!=(const LocationSize &Other) const {\n    return !(*this == Other);\n  }\n\n  // Ordering operators are not provided, since it's unclear if there's only one\n  // reasonable way to compare:\n  // - values that don't exist against values that do, and\n  // - precise values to imprecise values\n\n  void print(raw_ostream &OS) const;\n\n  // Returns an opaque value that represents this LocationSize. Cannot be\n  // reliably converted back into a LocationSize.\n  uint64_t toRaw() const { return Value; }\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, LocationSize Size) {\n  Size.print(OS);\n  return OS;\n}\n\n/// Representation for a specific memory location.\n///\n/// This abstraction can be used to represent a specific location in memory.\n/// The goal of the location is to represent enough information to describe\n/// abstract aliasing, modification, and reference behaviors of whatever\n/// value(s) are stored in memory at the particular location.\n///\n/// The primary user of this interface is LLVM's Alias Analysis, but other\n/// memory analyses such as MemoryDependence can use it as well.\nclass MemoryLocation {\npublic:\n  /// UnknownSize - This is a special value which can be used with the\n  /// size arguments in alias queries to indicate that the caller does not\n  /// know the sizes of the potential memory references.\n  enum : uint64_t { UnknownSize = ~UINT64_C(0) };\n\n  /// The address of the start of the location.\n  const Value *Ptr;\n\n  /// The maximum size of the location, in address-units, or\n  /// UnknownSize if the size is not known.\n  ///\n  /// Note that an unknown size does not mean the pointer aliases the entire\n  /// virtual address space, because there are restrictions on stepping out of\n  /// one object and into another. See\n  /// http://llvm.org/docs/LangRef.html#pointeraliasing\n  LocationSize Size;\n\n  /// The metadata nodes which describes the aliasing of the location (each\n  /// member is null if that kind of information is unavailable).\n  AAMDNodes AATags;\n\n  void print(raw_ostream &OS) const { OS << *Ptr << \" \" << Size << \"\\n\"; }\n\n  /// Return a location with information about the memory reference by the given\n  /// instruction.\n  static MemoryLocation get(const LoadInst *LI);\n  static MemoryLocation get(const StoreInst *SI);\n  static MemoryLocation get(const VAArgInst *VI);\n  static MemoryLocation get(const AtomicCmpXchgInst *CXI);\n  static MemoryLocation get(const AtomicRMWInst *RMWI);\n  static MemoryLocation get(const Instruction *Inst) {\n    return *MemoryLocation::getOrNone(Inst);\n  }\n  static Optional<MemoryLocation> getOrNone(const Instruction *Inst);\n\n  /// Return a location representing the source of a memory transfer.\n  static MemoryLocation getForSource(const MemTransferInst *MTI);\n  static MemoryLocation getForSource(const AtomicMemTransferInst *MTI);\n  static MemoryLocation getForSource(const AnyMemTransferInst *MTI);\n\n  /// Return a location representing the destination of a memory set or\n  /// transfer.\n  static MemoryLocation getForDest(const MemIntrinsic *MI);\n  static MemoryLocation getForDest(const AtomicMemIntrinsic *MI);\n  static MemoryLocation getForDest(const AnyMemIntrinsic *MI);\n\n  /// Return a location representing a particular argument of a call.\n  static MemoryLocation getForArgument(const CallBase *Call, unsigned ArgIdx,\n                                       const TargetLibraryInfo *TLI);\n  static MemoryLocation getForArgument(const CallBase *Call, unsigned ArgIdx,\n                                       const TargetLibraryInfo &TLI) {\n    return getForArgument(Call, ArgIdx, &TLI);\n  }\n\n  /// Return a location that may access any location after Ptr, while remaining\n  /// within the underlying object.\n  static MemoryLocation getAfter(const Value *Ptr,\n                                 const AAMDNodes &AATags = AAMDNodes()) {\n    return MemoryLocation(Ptr, LocationSize::afterPointer(), AATags);\n  }\n\n  /// Return a location that may access any location before or after Ptr, while\n  /// remaining within the underlying object.\n  static MemoryLocation\n  getBeforeOrAfter(const Value *Ptr, const AAMDNodes &AATags = AAMDNodes()) {\n    return MemoryLocation(Ptr, LocationSize::beforeOrAfterPointer(), AATags);\n  }\n\n  // Return the exact size if the exact size is known at compiletime,\n  // otherwise return MemoryLocation::UnknownSize.\n  static uint64_t getSizeOrUnknown(const TypeSize &T) {\n    return T.isScalable() ? UnknownSize : T.getFixedSize();\n  }\n\n  MemoryLocation()\n      : Ptr(nullptr), Size(LocationSize::beforeOrAfterPointer()), AATags() {}\n\n  explicit MemoryLocation(const Value *Ptr, LocationSize Size,\n                          const AAMDNodes &AATags = AAMDNodes())\n      : Ptr(Ptr), Size(Size), AATags(AATags) {}\n\n  MemoryLocation getWithNewPtr(const Value *NewPtr) const {\n    MemoryLocation Copy(*this);\n    Copy.Ptr = NewPtr;\n    return Copy;\n  }\n\n  MemoryLocation getWithNewSize(LocationSize NewSize) const {\n    MemoryLocation Copy(*this);\n    Copy.Size = NewSize;\n    return Copy;\n  }\n\n  MemoryLocation getWithoutAATags() const {\n    MemoryLocation Copy(*this);\n    Copy.AATags = AAMDNodes();\n    return Copy;\n  }\n\n  bool operator==(const MemoryLocation &Other) const {\n    return Ptr == Other.Ptr && Size == Other.Size && AATags == Other.AATags;\n  }\n};\n\n// Specialize DenseMapInfo.\ntemplate <> struct DenseMapInfo<LocationSize> {\n  static inline LocationSize getEmptyKey() {\n    return LocationSize::mapEmpty();\n  }\n  static inline LocationSize getTombstoneKey() {\n    return LocationSize::mapTombstone();\n  }\n  static unsigned getHashValue(const LocationSize &Val) {\n    return DenseMapInfo<uint64_t>::getHashValue(Val.toRaw());\n  }\n  static bool isEqual(const LocationSize &LHS, const LocationSize &RHS) {\n    return LHS == RHS;\n  }\n};\n\ntemplate <> struct DenseMapInfo<MemoryLocation> {\n  static inline MemoryLocation getEmptyKey() {\n    return MemoryLocation(DenseMapInfo<const Value *>::getEmptyKey(),\n                          DenseMapInfo<LocationSize>::getEmptyKey());\n  }\n  static inline MemoryLocation getTombstoneKey() {\n    return MemoryLocation(DenseMapInfo<const Value *>::getTombstoneKey(),\n                          DenseMapInfo<LocationSize>::getTombstoneKey());\n  }\n  static unsigned getHashValue(const MemoryLocation &Val) {\n    return DenseMapInfo<const Value *>::getHashValue(Val.Ptr) ^\n           DenseMapInfo<LocationSize>::getHashValue(Val.Size) ^\n           DenseMapInfo<AAMDNodes>::getHashValue(Val.AATags);\n  }\n  static bool isEqual(const MemoryLocation &LHS, const MemoryLocation &RHS) {\n    return LHS == RHS;\n  }\n};\n}\n\n#endif\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h", "content": "//===- RegionInfo.h - SESE region analysis ----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Calculate a program structure tree built out of single entry single exit\n// regions.\n// The basic ideas are taken from \"The Program Structure Tree - Richard Johnson,\n// David Pearson, Keshav Pingali - 1994\", however enriched with ideas from \"The\n// Refined Process Structure Tree - Jussi Vanhatalo, Hagen Voelyer, Jana\n// Koehler - 2009\".\n// The algorithm to calculate these data structures however is completely\n// different, as it takes advantage of existing information already available\n// in (Post)dominace tree and dominance frontier passes. This leads to a simpler\n// and in practice hopefully better performing algorithm. The runtime of the\n// algorithms described in the papers above are both linear in graph size,\n// O(V+E), whereas this algorithm is not, as the dominance frontier information\n// itself is not, but in practice runtime seems to be in the order of magnitude\n// of dominance tree calculation.\n//\n// WARNING: LLVM is generally very concerned about compile time such that\n//          the use of additional analysis passes in the default\n//          optimization sequence is avoided as much as possible.\n//          Specifically, if you do not need the RegionInfo, but dominance\n//          information could be sufficient please base your work only on\n//          the dominator tree. Most passes maintain it, such that using\n//          it has often near zero cost. In contrast RegionInfo is by\n//          default not available, is not maintained by existing\n//          transformations and there is no intention to do so.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ANALYSIS_REGIONINFO_H\n#define LLVM_ANALYSIS_REGIONINFO_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DepthFirstIterator.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <type_traits>\n#include <vector>\n\nnamespace llvm {\n\nclass DominanceFrontier;\nclass Loop;\nclass LoopInfo;\nclass PostDominatorTree;\nclass Region;\ntemplate <class RegionTr> class RegionBase;\nclass RegionInfo;\ntemplate <class RegionTr> class RegionInfoBase;\nclass RegionNode;\n\n// Class to be specialized for different users of RegionInfo\n// (i.e. BasicBlocks or MachineBasicBlocks). This is only to avoid needing to\n// pass around an unreasonable number of template parameters.\ntemplate <class FuncT_>\nstruct RegionTraits {\n  // FuncT\n  // BlockT\n  // RegionT\n  // RegionNodeT\n  // RegionInfoT\n  using BrokenT = typename FuncT_::UnknownRegionTypeError;\n};\n\ntemplate <>\nstruct RegionTraits<Function> {\n  using FuncT = Function;\n  using BlockT = BasicBlock;\n  using RegionT = Region;\n  using RegionNodeT = RegionNode;\n  using RegionInfoT = RegionInfo;\n  using DomTreeT = DominatorTree;\n  using DomTreeNodeT = DomTreeNode;\n  using DomFrontierT = DominanceFrontier;\n  using PostDomTreeT = PostDominatorTree;\n  using InstT = Instruction;\n  using LoopT = Loop;\n  using LoopInfoT = LoopInfo;\n\n  static unsigned getNumSuccessors(BasicBlock *BB) {\n    return BB->getTerminator()->getNumSuccessors();\n  }\n};\n\n/// Marker class to iterate over the elements of a Region in flat mode.\n///\n/// The class is used to either iterate in Flat mode or by not using it to not\n/// iterate in Flat mode.  During a Flat mode iteration all Regions are entered\n/// and the iteration returns every BasicBlock.  If the Flat mode is not\n/// selected for SubRegions just one RegionNode containing the subregion is\n/// returned.\ntemplate <class GraphType>\nclass FlatIt {};\n\n/// A RegionNode represents a subregion or a BasicBlock that is part of a\n/// Region.\ntemplate <class Tr>\nclass RegionNodeBase {\n  friend class RegionBase<Tr>;\n\npublic:\n  using BlockT = typename Tr::BlockT;\n  using RegionT = typename Tr::RegionT;\n\nprivate:\n  /// This is the entry basic block that starts this region node.  If this is a\n  /// BasicBlock RegionNode, then entry is just the basic block, that this\n  /// RegionNode represents.  Otherwise it is the entry of this (Sub)RegionNode.\n  ///\n  /// In the BBtoRegionNode map of the parent of this node, BB will always map\n  /// to this node no matter which kind of node this one is.\n  ///\n  /// The node can hold either a Region or a BasicBlock.\n  /// Use one bit to save, if this RegionNode is a subregion or BasicBlock\n  /// RegionNode.\n  PointerIntPair<BlockT *, 1, bool> entry;\n\n  /// The parent Region of this RegionNode.\n  /// @see getParent()\n  RegionT *parent;\n\nprotected:\n  /// Create a RegionNode.\n  ///\n  /// @param Parent      The parent of this RegionNode.\n  /// @param Entry       The entry BasicBlock of the RegionNode.  If this\n  ///                    RegionNode represents a BasicBlock, this is the\n  ///                    BasicBlock itself.  If it represents a subregion, this\n  ///                    is the entry BasicBlock of the subregion.\n  /// @param isSubRegion If this RegionNode represents a SubRegion.\n  inline RegionNodeBase(RegionT *Parent, BlockT *Entry,\n                        bool isSubRegion = false)\n      : entry(Entry, isSubRegion), parent(Parent) {}\n\npublic:\n  RegionNodeBase(const RegionNodeBase &) = delete;\n  RegionNodeBase &operator=(const RegionNodeBase &) = delete;\n\n  /// Get the parent Region of this RegionNode.\n  ///\n  /// The parent Region is the Region this RegionNode belongs to. If for\n  /// example a BasicBlock is element of two Regions, there exist two\n  /// RegionNodes for this BasicBlock. Each with the getParent() function\n  /// pointing to the Region this RegionNode belongs to.\n  ///\n  /// @return Get the parent Region of this RegionNode.\n  inline RegionT *getParent() const { return parent; }\n\n  /// Get the entry BasicBlock of this RegionNode.\n  ///\n  /// If this RegionNode represents a BasicBlock this is just the BasicBlock\n  /// itself, otherwise we return the entry BasicBlock of the Subregion\n  ///\n  /// @return The entry BasicBlock of this RegionNode.\n  inline BlockT *getEntry() const { return entry.getPointer(); }\n\n  /// Get the content of this RegionNode.\n  ///\n  /// This can be either a BasicBlock or a subregion. Before calling getNodeAs()\n  /// check the type of the content with the isSubRegion() function call.\n  ///\n  /// @return The content of this RegionNode.\n  template <class T> inline T *getNodeAs() const;\n\n  /// Is this RegionNode a subregion?\n  ///\n  /// @return True if it contains a subregion. False if it contains a\n  ///         BasicBlock.\n  inline bool isSubRegion() const { return entry.getInt(); }\n};\n\n//===----------------------------------------------------------------------===//\n/// A single entry single exit Region.\n///\n/// A Region is a connected subgraph of a control flow graph that has exactly\n/// two connections to the remaining graph. It can be used to analyze or\n/// optimize parts of the control flow graph.\n///\n/// A <em> simple Region </em> is connected to the remaining graph by just two\n/// edges. One edge entering the Region and another one leaving the Region.\n///\n/// An <em> extended Region </em> (or just Region) is a subgraph that can be\n/// transform into a simple Region. The transformation is done by adding\n/// BasicBlocks that merge several entry or exit edges so that after the merge\n/// just one entry and one exit edge exists.\n///\n/// The \\e Entry of a Region is the first BasicBlock that is passed after\n/// entering the Region. It is an element of the Region. The entry BasicBlock\n/// dominates all BasicBlocks in the Region.\n///\n/// The \\e Exit of a Region is the first BasicBlock that is passed after\n/// leaving the Region. It is not an element of the Region. The exit BasicBlock,\n/// postdominates all BasicBlocks in the Region.\n///\n/// A <em> canonical Region </em> cannot be constructed by combining smaller\n/// Regions.\n///\n/// Region A is the \\e parent of Region B, if B is completely contained in A.\n///\n/// Two canonical Regions either do not intersect at all or one is\n/// the parent of the other.\n///\n/// The <em> Program Structure Tree</em> is a graph (V, E) where V is the set of\n/// Regions in the control flow graph and E is the \\e parent relation of these\n/// Regions.\n///\n/// Example:\n///\n/// \\verbatim\n/// A simple control flow graph, that contains two regions.\n///\n///        1\n///       / |\n///      2   |\n///     / \\   3\n///    4   5  |\n///    |   |  |\n///    6   7  8\n///     \\  | /\n///      \\ |/       Region A: 1 -> 9 {1,2,3,4,5,6,7,8}\n///        9        Region B: 2 -> 9 {2,4,5,6,7}\n/// \\endverbatim\n///\n/// You can obtain more examples by either calling\n///\n/// <tt> \"opt -regions -analyze anyprogram.ll\" </tt>\n/// or\n/// <tt> \"opt -view-regions-only anyprogram.ll\" </tt>\n///\n/// on any LLVM file you are interested in.\n///\n/// The first call returns a textual representation of the program structure\n/// tree, the second one creates a graphical representation using graphviz.\ntemplate <class Tr>\nclass RegionBase : public RegionNodeBase<Tr> {\n  friend class RegionInfoBase<Tr>;\n\n  using FuncT = typename Tr::FuncT;\n  using BlockT = typename Tr::BlockT;\n  using RegionInfoT = typename Tr::RegionInfoT;\n  using RegionT = typename Tr::RegionT;\n  using RegionNodeT = typename Tr::RegionNodeT;\n  using DomTreeT = typename Tr::DomTreeT;\n  using LoopT = typename Tr::LoopT;\n  using LoopInfoT = typename Tr::LoopInfoT;\n  using InstT = typename Tr::InstT;\n\n  using BlockTraits = GraphTraits<BlockT *>;\n  using InvBlockTraits = GraphTraits<Inverse<BlockT *>>;\n  using SuccIterTy = typename BlockTraits::ChildIteratorType;\n  using PredIterTy = typename InvBlockTraits::ChildIteratorType;\n\n  // Information necessary to manage this Region.\n  RegionInfoT *RI;\n  DomTreeT *DT;\n\n  // The exit BasicBlock of this region.\n  // (The entry BasicBlock is part of RegionNode)\n  BlockT *exit;\n\n  using RegionSet = std::vector<std::unique_ptr<RegionT>>;\n\n  // The subregions of this region.\n  RegionSet children;\n\n  using BBNodeMapT = std::map<BlockT *, std::unique_ptr<RegionNodeT>>;\n\n  // Save the BasicBlock RegionNodes that are element of this Region.\n  mutable BBNodeMapT BBNodeMap;\n\n  /// Check if a BB is in this Region. This check also works\n  /// if the region is incorrectly built. (EXPENSIVE!)\n  void verifyBBInRegion(BlockT *BB) const;\n\n  /// Walk over all the BBs of the region starting from BB and\n  /// verify that all reachable basic blocks are elements of the region.\n  /// (EXPENSIVE!)\n  void verifyWalk(BlockT *BB, std::set<BlockT *> *visitedBB) const;\n\n  /// Verify if the region and its children are valid regions (EXPENSIVE!)\n  void verifyRegionNest() const;\n\npublic:\n  /// Create a new region.\n  ///\n  /// @param Entry  The entry basic block of the region.\n  /// @param Exit   The exit basic block of the region.\n  /// @param RI     The region info object that is managing this region.\n  /// @param DT     The dominator tree of the current function.\n  /// @param Parent The surrounding region or NULL if this is a top level\n  ///               region.\n  RegionBase(BlockT *Entry, BlockT *Exit, RegionInfoT *RI, DomTreeT *DT,\n             RegionT *Parent = nullptr);\n\n  RegionBase(const RegionBase &) = delete;\n  RegionBase &operator=(const RegionBase &) = delete;\n\n  /// Delete the Region and all its subregions.\n  ~RegionBase();\n\n  /// Get the entry BasicBlock of the Region.\n  /// @return The entry BasicBlock of the region.\n  BlockT *getEntry() const {\n    return RegionNodeBase<Tr>::getEntry();\n  }\n\n  /// Replace the entry basic block of the region with the new basic\n  ///        block.\n  ///\n  /// @param BB  The new entry basic block of the region.\n  void replaceEntry(BlockT *BB);\n\n  /// Replace the exit basic block of the region with the new basic\n  ///        block.\n  ///\n  /// @param BB  The new exit basic block of the region.\n  void replaceExit(BlockT *BB);\n\n  /// Recursively replace the entry basic block of the region.\n  ///\n  /// This function replaces the entry basic block with a new basic block. It\n  /// also updates all child regions that have the same entry basic block as\n  /// this region.\n  ///\n  /// @param NewEntry The new entry basic block.\n  void replaceEntryRecursive(BlockT *NewEntry);\n\n  /// Recursively replace the exit basic block of the region.\n  ///\n  /// This function replaces the exit basic block with a new basic block. It\n  /// also updates all child regions that have the same exit basic block as\n  /// this region.\n  ///\n  /// @param NewExit The new exit basic block.\n  void replaceExitRecursive(BlockT *NewExit);\n\n  /// Get the exit BasicBlock of the Region.\n  /// @return The exit BasicBlock of the Region, NULL if this is the TopLevel\n  ///         Region.\n  BlockT *getExit() const { return exit; }\n\n  /// Get the parent of the Region.\n  /// @return The parent of the Region or NULL if this is a top level\n  ///         Region.\n  RegionT *getParent() const {\n    return RegionNodeBase<Tr>::getParent();\n  }\n\n  /// Get the RegionNode representing the current Region.\n  /// @return The RegionNode representing the current Region.\n  RegionNodeT *getNode() const {\n    return const_cast<RegionNodeT *>(\n        reinterpret_cast<const RegionNodeT *>(this));\n  }\n\n  /// Get the nesting level of this Region.\n  ///\n  /// An toplevel Region has depth 0.\n  ///\n  /// @return The depth of the region.\n  unsigned getDepth() const;\n\n  /// Check if a Region is the TopLevel region.\n  ///\n  /// The toplevel region represents the whole function.\n  bool isTopLevelRegion() const { return exit == nullptr; }\n\n  /// Return a new (non-canonical) region, that is obtained by joining\n  ///        this region with its predecessors.\n  ///\n  /// @return A region also starting at getEntry(), but reaching to the next\n  ///         basic block that forms with getEntry() a (non-canonical) region.\n  ///         NULL if such a basic block does not exist.\n  RegionT *getExpandedRegion() const;\n\n  /// Return the first block of this region's single entry edge,\n  ///        if existing.\n  ///\n  /// @return The BasicBlock starting this region's single entry edge,\n  ///         else NULL.\n  BlockT *getEnteringBlock() const;\n\n  /// Return the first block of this region's single exit edge,\n  ///        if existing.\n  ///\n  /// @return The BasicBlock starting this region's single exit edge,\n  ///         else NULL.\n  BlockT *getExitingBlock() const;\n\n  /// Collect all blocks of this region's single exit edge, if existing.\n  ///\n  /// @return True if this region contains all the predecessors of the exit.\n  bool getExitingBlocks(SmallVectorImpl<BlockT *> &Exitings) const;\n\n  /// Is this a simple region?\n  ///\n  /// A region is simple if it has exactly one exit and one entry edge.\n  ///\n  /// @return True if the Region is simple.\n  bool isSimple() const;\n\n  /// Returns the name of the Region.\n  /// @return The Name of the Region.\n  std::string getNameStr() const;\n\n  /// Return the RegionInfo object, that belongs to this Region.\n  RegionInfoT *getRegionInfo() const { return RI; }\n\n  /// PrintStyle - Print region in difference ways.\n  enum PrintStyle { PrintNone, PrintBB, PrintRN };\n\n  /// Print the region.\n  ///\n  /// @param OS The output stream the Region is printed to.\n  /// @param printTree Print also the tree of subregions.\n  /// @param level The indentation level used for printing.\n  void print(raw_ostream &OS, bool printTree = true, unsigned level = 0,\n             PrintStyle Style = PrintNone) const;\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  /// Print the region to stderr.\n  void dump() const;\n#endif\n\n  /// Check if the region contains a BasicBlock.\n  ///\n  /// @param BB The BasicBlock that might be contained in this Region.\n  /// @return True if the block is contained in the region otherwise false.\n  bool contains(const BlockT *BB) const;\n\n  /// Check if the region contains another region.\n  ///\n  /// @param SubRegion The region that might be contained in this Region.\n  /// @return True if SubRegion is contained in the region otherwise false.\n  bool contains(const RegionT *SubRegion) const {\n    // Toplevel Region.\n    if (!getExit())\n      return true;\n\n    return contains(SubRegion->getEntry()) &&\n           (contains(SubRegion->getExit()) ||\n            SubRegion->getExit() == getExit());\n  }\n\n  /// Check if the region contains an Instruction.\n  ///\n  /// @param Inst The Instruction that might be contained in this region.\n  /// @return True if the Instruction is contained in the region otherwise\n  /// false.\n  bool contains(const InstT *Inst) const { return contains(Inst->getParent()); }\n\n  /// Check if the region contains a loop.\n  ///\n  /// @param L The loop that might be contained in this region.\n  /// @return True if the loop is contained in the region otherwise false.\n  ///         In case a NULL pointer is passed to this function the result\n  ///         is false, except for the region that describes the whole function.\n  ///         In that case true is returned.\n  bool contains(const LoopT *L) const;\n\n  /// Get the outermost loop in the region that contains a loop.\n  ///\n  /// Find for a Loop L the outermost loop OuterL that is a parent loop of L\n  /// and is itself contained in the region.\n  ///\n  /// @param L The loop the lookup is started.\n  /// @return The outermost loop in the region, NULL if such a loop does not\n  ///         exist or if the region describes the whole function.\n  LoopT *outermostLoopInRegion(LoopT *L) const;\n\n  /// Get the outermost loop in the region that contains a basic block.\n  ///\n  /// Find for a basic block BB the outermost loop L that contains BB and is\n  /// itself contained in the region.\n  ///\n  /// @param LI A pointer to a LoopInfo analysis.\n  /// @param BB The basic block surrounded by the loop.\n  /// @return The outermost loop in the region, NULL if such a loop does not\n  ///         exist or if the region describes the whole function.\n  LoopT *outermostLoopInRegion(LoopInfoT *LI, BlockT *BB) const;\n\n  /// Get the subregion that starts at a BasicBlock\n  ///\n  /// @param BB The BasicBlock the subregion should start.\n  /// @return The Subregion if available, otherwise NULL.\n  RegionT *getSubRegionNode(BlockT *BB) const;\n\n  /// Get the RegionNode for a BasicBlock\n  ///\n  /// @param BB The BasicBlock at which the RegionNode should start.\n  /// @return If available, the RegionNode that represents the subregion\n  ///         starting at BB. If no subregion starts at BB, the RegionNode\n  ///         representing BB.\n  RegionNodeT *getNode(BlockT *BB) const;\n\n  /// Get the BasicBlock RegionNode for a BasicBlock\n  ///\n  /// @param BB The BasicBlock for which the RegionNode is requested.\n  /// @return The RegionNode representing the BB.\n  RegionNodeT *getBBNode(BlockT *BB) const;\n\n  /// Add a new subregion to this Region.\n  ///\n  /// @param SubRegion The new subregion that will be added.\n  /// @param moveChildren Move the children of this region, that are also\n  ///                     contained in SubRegion into SubRegion.\n  void addSubRegion(RegionT *SubRegion, bool moveChildren = false);\n\n  /// Remove a subregion from this Region.\n  ///\n  /// The subregion is not deleted, as it will probably be inserted into another\n  /// region.\n  /// @param SubRegion The SubRegion that will be removed.\n  RegionT *removeSubRegion(RegionT *SubRegion);\n\n  /// Move all direct child nodes of this Region to another Region.\n  ///\n  /// @param To The Region the child nodes will be transferred to.\n  void transferChildrenTo(RegionT *To);\n\n  /// Verify if the region is a correct region.\n  ///\n  /// Check if this is a correctly build Region. This is an expensive check, as\n  /// the complete CFG of the Region will be walked.\n  void verifyRegion() const;\n\n  /// Clear the cache for BB RegionNodes.\n  ///\n  /// After calling this function the BasicBlock RegionNodes will be stored at\n  /// different memory locations. RegionNodes obtained before this function is\n  /// called are therefore not comparable to RegionNodes abtained afterwords.\n  void clearNodeCache();\n\n  /// @name Subregion Iterators\n  ///\n  /// These iterators iterator over all subregions of this Region.\n  //@{\n  using iterator = typename RegionSet::iterator;\n  using const_iterator = typename RegionSet::const_iterator;\n\n  iterator begin() { return children.begin(); }\n  iterator end() { return children.end(); }\n\n  const_iterator begin() const { return children.begin(); }\n  const_iterator end() const { return children.end(); }\n  //@}\n\n  /// @name BasicBlock Iterators\n  ///\n  /// These iterators iterate over all BasicBlocks that are contained in this\n  /// Region. The iterator also iterates over BasicBlocks that are elements of\n  /// a subregion of this Region. It is therefore called a flat iterator.\n  //@{\n  template <bool IsConst>\n  class block_iterator_wrapper\n      : public df_iterator<\n            std::conditional_t<IsConst, const BlockT, BlockT> *> {\n    using super =\n        df_iterator<std::conditional_t<IsConst, const BlockT, BlockT> *>;\n\n  public:\n    using Self = block_iterator_wrapper<IsConst>;\n    using value_type = typename super::value_type;\n\n    // Construct the begin iterator.\n    block_iterator_wrapper(value_type Entry, value_type Exit)\n        : super(df_begin(Entry)) {\n      // Mark the exit of the region as visited, so that the children of the\n      // exit and the exit itself, i.e. the block outside the region will never\n      // be visited.\n      super::Visited.insert(Exit);\n    }\n\n    // Construct the end iterator.\n    block_iterator_wrapper() : super(df_end<value_type>((BlockT *)nullptr)) {}\n\n    /*implicit*/ block_iterator_wrapper(super I) : super(I) {}\n\n    // FIXME: Even a const_iterator returns a non-const BasicBlock pointer.\n    //        This was introduced for backwards compatibility, but should\n    //        be removed as soon as all users are fixed.\n    BlockT *operator*() const {\n      return const_cast<BlockT *>(super::operator*());\n    }\n  };\n\n  using block_iterator = block_iterator_wrapper<false>;\n  using const_block_iterator = block_iterator_wrapper<true>;\n\n  block_iterator block_begin() { return block_iterator(getEntry(), getExit()); }\n\n  block_iterator block_end() { return block_iterator(); }\n\n  const_block_iterator block_begin() const {\n    return const_block_iterator(getEntry(), getExit());\n  }\n  const_block_iterator block_end() const { return const_block_iterator(); }\n\n  using block_range = iterator_range<block_iterator>;\n  using const_block_range = iterator_range<const_block_iterator>;\n\n  /// Returns a range view of the basic blocks in the region.\n  inline block_range blocks() {\n    return block_range(block_begin(), block_end());\n  }\n\n  /// Returns a range view of the basic blocks in the region.\n  ///\n  /// This is the 'const' version of the range view.\n  inline const_block_range blocks() const {\n    return const_block_range(block_begin(), block_end());\n  }\n  //@}\n\n  /// @name Element Iterators\n  ///\n  /// These iterators iterate over all BasicBlock and subregion RegionNodes that\n  /// are direct children of this Region. It does not iterate over any\n  /// RegionNodes that are also element of a subregion of this Region.\n  //@{\n  using element_iterator =\n      df_iterator<RegionNodeT *, df_iterator_default_set<RegionNodeT *>, false,\n                  GraphTraits<RegionNodeT *>>;\n\n  using const_element_iterator =\n      df_iterator<const RegionNodeT *,\n                  df_iterator_default_set<const RegionNodeT *>, false,\n                  GraphTraits<const RegionNodeT *>>;\n\n  element_iterator element_begin();\n  element_iterator element_end();\n  iterator_range<element_iterator> elements() {\n    return make_range(element_begin(), element_end());\n  }\n\n  const_element_iterator element_begin() const;\n  const_element_iterator element_end() const;\n  iterator_range<const_element_iterator> elements() const {\n    return make_range(element_begin(), element_end());\n  }\n  //@}\n};\n\n/// Print a RegionNode.\ntemplate <class Tr>\ninline raw_ostream &operator<<(raw_ostream &OS, const RegionNodeBase<Tr> &Node);\n\n//===----------------------------------------------------------------------===//\n/// Analysis that detects all canonical Regions.\n///\n/// The RegionInfo pass detects all canonical regions in a function. The Regions\n/// are connected using the parent relation. This builds a Program Structure\n/// Tree.\ntemplate <class Tr>\nclass RegionInfoBase {\n  friend class RegionInfo;\n  friend class MachineRegionInfo;\n\n  using BlockT = typename Tr::BlockT;\n  using FuncT = typename Tr::FuncT;\n  using RegionT = typename Tr::RegionT;\n  using RegionInfoT = typename Tr::RegionInfoT;\n  using DomTreeT = typename Tr::DomTreeT;\n  using DomTreeNodeT = typename Tr::DomTreeNodeT;\n  using PostDomTreeT = typename Tr::PostDomTreeT;\n  using DomFrontierT = typename Tr::DomFrontierT;\n  using BlockTraits = GraphTraits<BlockT *>;\n  using InvBlockTraits = GraphTraits<Inverse<BlockT *>>;\n  using SuccIterTy = typename BlockTraits::ChildIteratorType;\n  using PredIterTy = typename InvBlockTraits::ChildIteratorType;\n\n  using BBtoBBMap = DenseMap<BlockT *, BlockT *>;\n  using BBtoRegionMap = DenseMap<BlockT *, RegionT *>;\n\n  RegionInfoBase();\n\n  RegionInfoBase(RegionInfoBase &&Arg)\n    : DT(std::move(Arg.DT)), PDT(std::move(Arg.PDT)), DF(std::move(Arg.DF)),\n      TopLevelRegion(std::move(Arg.TopLevelRegion)),\n      BBtoRegion(std::move(Arg.BBtoRegion)) {\n    Arg.wipe();\n  }\n\n  RegionInfoBase &operator=(RegionInfoBase &&RHS) {\n    DT = std::move(RHS.DT);\n    PDT = std::move(RHS.PDT);\n    DF = std::move(RHS.DF);\n    TopLevelRegion = std::move(RHS.TopLevelRegion);\n    BBtoRegion = std::move(RHS.BBtoRegion);\n    RHS.wipe();\n    return *this;\n  }\n\n  virtual ~RegionInfoBase();\n\n  DomTreeT *DT;\n  PostDomTreeT *PDT;\n  DomFrontierT *DF;\n\n  /// The top level region.\n  RegionT *TopLevelRegion = nullptr;\n\n  /// Map every BB to the smallest region, that contains BB.\n  BBtoRegionMap BBtoRegion;\n\nprotected:\n  /// Update refences to a RegionInfoT held by the RegionT managed here\n  ///\n  /// This is a post-move helper. Regions hold references to the owning\n  /// RegionInfo object. After a move these need to be fixed.\n  template<typename TheRegionT>\n  void updateRegionTree(RegionInfoT &RI, TheRegionT *R) {\n    if (!R)\n      return;\n    R->RI = &RI;\n    for (auto &SubR : *R)\n      updateRegionTree(RI, SubR.get());\n  }\n\nprivate:\n  /// Wipe this region tree's state without releasing any resources.\n  ///\n  /// This is essentially a post-move helper only. It leaves the object in an\n  /// assignable and destroyable state, but otherwise invalid.\n  void wipe() {\n    DT = nullptr;\n    PDT = nullptr;\n    DF = nullptr;\n    TopLevelRegion = nullptr;\n    BBtoRegion.clear();\n  }\n\n  // Check whether the entries of BBtoRegion for the BBs of region\n  // SR are correct. Triggers an assertion if not. Calls itself recursively for\n  // subregions.\n  void verifyBBMap(const RegionT *SR) const;\n\n  // Returns true if BB is in the dominance frontier of\n  // entry, because it was inherited from exit. In the other case there is an\n  // edge going from entry to BB without passing exit.\n  bool isCommonDomFrontier(BlockT *BB, BlockT *entry, BlockT *exit) const;\n\n  // Check if entry and exit surround a valid region, based on\n  // dominance tree and dominance frontier.\n  bool isRegion(BlockT *entry, BlockT *exit) const;\n\n  // Saves a shortcut pointing from entry to exit.\n  // This function may extend this shortcut if possible.\n  void insertShortCut(BlockT *entry, BlockT *exit, BBtoBBMap *ShortCut) const;\n\n  // Returns the next BB that postdominates N, while skipping\n  // all post dominators that cannot finish a canonical region.\n  DomTreeNodeT *getNextPostDom(DomTreeNodeT *N, BBtoBBMap *ShortCut) const;\n\n  // A region is trivial, if it contains only one BB.\n  bool isTrivialRegion(BlockT *entry, BlockT *exit) const;\n\n  // Creates a single entry single exit region.\n  RegionT *createRegion(BlockT *entry, BlockT *exit);\n\n  // Detect all regions starting with bb 'entry'.\n  void findRegionsWithEntry(BlockT *entry, BBtoBBMap *ShortCut);\n\n  // Detects regions in F.\n  void scanForRegions(FuncT &F, BBtoBBMap *ShortCut);\n\n  // Get the top most parent with the same entry block.\n  RegionT *getTopMostParent(RegionT *region);\n\n  // Build the region hierarchy after all region detected.\n  void buildRegionsTree(DomTreeNodeT *N, RegionT *region);\n\n  // Update statistic about created regions.\n  virtual void updateStatistics(RegionT *R) = 0;\n\n  // Detect all regions in function and build the region tree.\n  void calculate(FuncT &F);\n\npublic:\n  RegionInfoBase(const RegionInfoBase &) = delete;\n  RegionInfoBase &operator=(const RegionInfoBase &) = delete;\n\n  static bool VerifyRegionInfo;\n  static typename RegionT::PrintStyle printStyle;\n\n  void print(raw_ostream &OS) const;\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  void dump() const;\n#endif\n\n  void releaseMemory();\n\n  /// Get the smallest region that contains a BasicBlock.\n  ///\n  /// @param BB The basic block.\n  /// @return The smallest region, that contains BB or NULL, if there is no\n  /// region containing BB.\n  RegionT *getRegionFor(BlockT *BB) const;\n\n  ///  Set the smallest region that surrounds a basic block.\n  ///\n  /// @param BB The basic block surrounded by a region.\n  /// @param R The smallest region that surrounds BB.\n  void setRegionFor(BlockT *BB, RegionT *R);\n\n  /// A shortcut for getRegionFor().\n  ///\n  /// @param BB The basic block.\n  /// @return The smallest region, that contains BB or NULL, if there is no\n  /// region containing BB.\n  RegionT *operator[](BlockT *BB) const;\n\n  /// Return the exit of the maximal refined region, that starts at a\n  /// BasicBlock.\n  ///\n  /// @param BB The BasicBlock the refined region starts.\n  BlockT *getMaxRegionExit(BlockT *BB) const;\n\n  /// Find the smallest region that contains two regions.\n  ///\n  /// @param A The first region.\n  /// @param B The second region.\n  /// @return The smallest region containing A and B.\n  RegionT *getCommonRegion(RegionT *A, RegionT *B) const;\n\n  /// Find the smallest region that contains two basic blocks.\n  ///\n  /// @param A The first basic block.\n  /// @param B The second basic block.\n  /// @return The smallest region that contains A and B.\n  RegionT *getCommonRegion(BlockT *A, BlockT *B) const {\n    return getCommonRegion(getRegionFor(A), getRegionFor(B));\n  }\n\n  /// Find the smallest region that contains a set of regions.\n  ///\n  /// @param Regions A vector of regions.\n  /// @return The smallest region that contains all regions in Regions.\n  RegionT *getCommonRegion(SmallVectorImpl<RegionT *> &Regions) const;\n\n  /// Find the smallest region that contains a set of basic blocks.\n  ///\n  /// @param BBs A vector of basic blocks.\n  /// @return The smallest region that contains all basic blocks in BBS.\n  RegionT *getCommonRegion(SmallVectorImpl<BlockT *> &BBs) const;\n\n  RegionT *getTopLevelRegion() const { return TopLevelRegion; }\n\n  /// Clear the Node Cache for all Regions.\n  ///\n  /// @see Region::clearNodeCache()\n  void clearNodeCache() {\n    if (TopLevelRegion)\n      TopLevelRegion->clearNodeCache();\n  }\n\n  void verifyAnalysis() const;\n};\n\nclass RegionNode : public RegionNodeBase<RegionTraits<Function>> {\npublic:\n  inline RegionNode(Region *Parent, BasicBlock *Entry, bool isSubRegion = false)\n      : RegionNodeBase<RegionTraits<Function>>(Parent, Entry, isSubRegion) {}\n\n  bool operator==(const Region &RN) const {\n    return this == reinterpret_cast<const RegionNode *>(&RN);\n  }\n};\n\nclass Region : public RegionBase<RegionTraits<Function>> {\npublic:\n  Region(BasicBlock *Entry, BasicBlock *Exit, RegionInfo *RI, DominatorTree *DT,\n         Region *Parent = nullptr);\n  ~Region();\n\n  bool operator==(const RegionNode &RN) const {\n    return &RN == reinterpret_cast<const RegionNode *>(this);\n  }\n};\n\nclass RegionInfo : public RegionInfoBase<RegionTraits<Function>> {\npublic:\n  using Base = RegionInfoBase<RegionTraits<Function>>;\n\n  explicit RegionInfo();\n\n  RegionInfo(RegionInfo &&Arg) : Base(std::move(static_cast<Base &>(Arg))) {\n    updateRegionTree(*this, TopLevelRegion);\n  }\n\n  RegionInfo &operator=(RegionInfo &&RHS) {\n    Base::operator=(std::move(static_cast<Base &>(RHS)));\n    updateRegionTree(*this, TopLevelRegion);\n    return *this;\n  }\n\n  ~RegionInfo() override;\n\n  /// Handle invalidation explicitly.\n  bool invalidate(Function &F, const PreservedAnalyses &PA,\n                  FunctionAnalysisManager::Invalidator &);\n\n  // updateStatistics - Update statistic about created regions.\n  void updateStatistics(Region *R) final;\n\n  void recalculate(Function &F, DominatorTree *DT, PostDominatorTree *PDT,\n                   DominanceFrontier *DF);\n\n#ifndef NDEBUG\n  /// Opens a viewer to show the GraphViz visualization of the regions.\n  ///\n  /// Useful during debugging as an alternative to dump().\n  void view();\n\n  /// Opens a viewer to show the GraphViz visualization of this region\n  /// without instructions in the BasicBlocks.\n  ///\n  /// Useful during debugging as an alternative to dump().\n  void viewOnly();\n#endif\n};\n\nclass RegionInfoPass : public FunctionPass {\n  RegionInfo RI;\n\npublic:\n  static char ID;\n\n  explicit RegionInfoPass();\n  ~RegionInfoPass() override;\n\n  RegionInfo &getRegionInfo() { return RI; }\n\n  const RegionInfo &getRegionInfo() const { return RI; }\n\n  /// @name FunctionPass interface\n  //@{\n  bool runOnFunction(Function &F) override;\n  void releaseMemory() override;\n  void verifyAnalysis() const override;\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n  void print(raw_ostream &OS, const Module *) const override;\n  void dump() const;\n  //@}\n};\n\n/// Analysis pass that exposes the \\c RegionInfo for a function.\nclass RegionInfoAnalysis : public AnalysisInfoMixin<RegionInfoAnalysis> {\n  friend AnalysisInfoMixin<RegionInfoAnalysis>;\n\n  static AnalysisKey Key;\n\npublic:\n  using Result = RegionInfo;\n\n  RegionInfo run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Printer pass for the \\c RegionInfo.\nclass RegionInfoPrinterPass : public PassInfoMixin<RegionInfoPrinterPass> {\n  raw_ostream &OS;\n\npublic:\n  explicit RegionInfoPrinterPass(raw_ostream &OS);\n\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\n/// Verifier pass for the \\c RegionInfo.\nstruct RegionInfoVerifierPass : PassInfoMixin<RegionInfoVerifierPass> {\n  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);\n};\n\ntemplate <>\ntemplate <>\ninline BasicBlock *\nRegionNodeBase<RegionTraits<Function>>::getNodeAs<BasicBlock>() const {\n  assert(!isSubRegion() && \"This is not a BasicBlock RegionNode!\");\n  return getEntry();\n}\n\ntemplate <>\ntemplate <>\ninline Region *\nRegionNodeBase<RegionTraits<Function>>::getNodeAs<Region>() const {\n  assert(isSubRegion() && \"This is not a subregion RegionNode!\");\n  auto Unconst = const_cast<RegionNodeBase<RegionTraits<Function>> *>(this);\n  return reinterpret_cast<Region *>(Unconst);\n}\n\ntemplate <class Tr>\ninline raw_ostream &operator<<(raw_ostream &OS,\n                               const RegionNodeBase<Tr> &Node) {\n  using BlockT = typename Tr::BlockT;\n  using RegionT = typename Tr::RegionT;\n\n  if (Node.isSubRegion())\n    return OS << Node.template getNodeAs<RegionT>()->getNameStr();\n  else\n    return OS << Node.template getNodeAs<BlockT>()->getName();\n}\n\nextern template class RegionBase<RegionTraits<Function>>;\nextern template class RegionNodeBase<RegionTraits<Function>>;\nextern template class RegionInfoBase<RegionTraits<Function>>;\n\n} // end namespace llvm\n\n#endif // LLVM_ANALYSIS_REGIONINFO_H\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "content": "//===- llvm/Attributes.h - Container for Attributes -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// This file contains the simple types necessary to represent the\n/// attributes associated with functions and their calls.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_ATTRIBUTES_H\n#define LLVM_IR_ATTRIBUTES_H\n\n#include \"llvm-c/Types.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <bitset>\n#include <cassert>\n#include <cstdint>\n#include <map>\n#include <string>\n#include <utility>\n\nnamespace llvm {\n\nclass AttrBuilder;\nclass AttributeImpl;\nclass AttributeListImpl;\nclass AttributeSetNode;\ntemplate<typename T> struct DenseMapInfo;\nclass FoldingSetNodeID;\nclass Function;\nclass LLVMContext;\nclass Type;\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// Functions, function parameters, and return types can have attributes\n/// to indicate how they should be treated by optimizations and code\n/// generation. This class represents one of those attributes. It's light-weight\n/// and should be passed around by-value.\nclass Attribute {\npublic:\n  /// This enumeration lists the attributes that can be associated with\n  /// parameters, function results, or the function itself.\n  ///\n  /// Note: The `uwtable' attribute is about the ABI or the user mandating an\n  /// entry in the unwind table. The `nounwind' attribute is about an exception\n  /// passing by the function.\n  ///\n  /// In a theoretical system that uses tables for profiling and SjLj for\n  /// exceptions, they would be fully independent. In a normal system that uses\n  /// tables for both, the semantics are:\n  ///\n  /// nil                = Needs an entry because an exception might pass by.\n  /// nounwind           = No need for an entry\n  /// uwtable            = Needs an entry because the ABI says so and because\n  ///                      an exception might pass by.\n  /// uwtable + nounwind = Needs an entry because the ABI says so.\n\n  enum AttrKind {\n    // IR-Level Attributes\n    None,                  ///< No attributes have been set\n    #define GET_ATTR_NAMES\n    #define ATTRIBUTE_ENUM(ENUM_NAME, OTHER) ENUM_NAME,\n    #include \"llvm/IR/Attributes.inc\"\n    EndAttrKinds,          ///< Sentinal value useful for loops\n    EmptyKey,              ///< Use as Empty key for DenseMap of AttrKind\n    TombstoneKey,          ///< Use as Tombstone key for DenseMap of AttrKind\n  };\n\nprivate:\n  AttributeImpl *pImpl = nullptr;\n\n  Attribute(AttributeImpl *A) : pImpl(A) {}\n\npublic:\n  Attribute() = default;\n\n  //===--------------------------------------------------------------------===//\n  // Attribute Construction\n  //===--------------------------------------------------------------------===//\n\n  /// Return a uniquified Attribute object.\n  static Attribute get(LLVMContext &Context, AttrKind Kind, uint64_t Val = 0);\n  static Attribute get(LLVMContext &Context, StringRef Kind,\n                       StringRef Val = StringRef());\n  static Attribute get(LLVMContext &Context, AttrKind Kind, Type *Ty);\n\n  /// Return a uniquified Attribute object that has the specific\n  /// alignment set.\n  static Attribute getWithAlignment(LLVMContext &Context, Align Alignment);\n  static Attribute getWithStackAlignment(LLVMContext &Context, Align Alignment);\n  static Attribute getWithDereferenceableBytes(LLVMContext &Context,\n                                              uint64_t Bytes);\n  static Attribute getWithDereferenceableOrNullBytes(LLVMContext &Context,\n                                                     uint64_t Bytes);\n  static Attribute getWithAllocSizeArgs(LLVMContext &Context,\n                                        unsigned ElemSizeArg,\n                                        const Optional<unsigned> &NumElemsArg);\n  static Attribute getWithByValType(LLVMContext &Context, Type *Ty);\n  static Attribute getWithStructRetType(LLVMContext &Context, Type *Ty);\n  static Attribute getWithByRefType(LLVMContext &Context, Type *Ty);\n  static Attribute getWithPreallocatedType(LLVMContext &Context, Type *Ty);\n\n  /// For a typed attribute, return the equivalent attribute with the type\n  /// changed to \\p ReplacementTy.\n  Attribute getWithNewType(LLVMContext &Context, Type *ReplacementTy) {\n    assert(isTypeAttribute() && \"this requires a typed attribute\");\n    return get(Context, getKindAsEnum(), ReplacementTy);\n  }\n\n  static Attribute::AttrKind getAttrKindFromName(StringRef AttrName);\n\n  static StringRef getNameFromAttrKind(Attribute::AttrKind AttrKind);\n\n  /// Return true if and only if the attribute has an Argument.\n  static bool doesAttrKindHaveArgument(Attribute::AttrKind AttrKind);\n\n  /// Return true if the provided string matches the IR name of an attribute.\n  /// example: \"noalias\" return true but not \"NoAlias\"\n  static bool isExistingAttribute(StringRef Name);\n\n  //===--------------------------------------------------------------------===//\n  // Attribute Accessors\n  //===--------------------------------------------------------------------===//\n\n  /// Return true if the attribute is an Attribute::AttrKind type.\n  bool isEnumAttribute() const;\n\n  /// Return true if the attribute is an integer attribute.\n  bool isIntAttribute() const;\n\n  /// Return true if the attribute is a string (target-dependent)\n  /// attribute.\n  bool isStringAttribute() const;\n\n  /// Return true if the attribute is a type attribute.\n  bool isTypeAttribute() const;\n\n  /// Return true if the attribute is any kind of attribute.\n  bool isValid() const { return pImpl; }\n\n  /// Return true if the attribute is present.\n  bool hasAttribute(AttrKind Val) const;\n\n  /// Return true if the target-dependent attribute is present.\n  bool hasAttribute(StringRef Val) const;\n\n  /// Return the attribute's kind as an enum (Attribute::AttrKind). This\n  /// requires the attribute to be an enum or integer attribute.\n  Attribute::AttrKind getKindAsEnum() const;\n\n  /// Return the attribute's value as an integer. This requires that the\n  /// attribute be an integer attribute.\n  uint64_t getValueAsInt() const;\n\n  /// Return the attribute's kind as a string. This requires the\n  /// attribute to be a string attribute.\n  StringRef getKindAsString() const;\n\n  /// Return the attribute's value as a string. This requires the\n  /// attribute to be a string attribute.\n  StringRef getValueAsString() const;\n\n  /// Return the attribute's value as a Type. This requires the attribute to be\n  /// a type attribute.\n  Type *getValueAsType() const;\n\n  /// Returns the alignment field of an attribute as a byte alignment\n  /// value.\n  MaybeAlign getAlignment() const;\n\n  /// Returns the stack alignment field of an attribute as a byte\n  /// alignment value.\n  MaybeAlign getStackAlignment() const;\n\n  /// Returns the number of dereferenceable bytes from the\n  /// dereferenceable attribute.\n  uint64_t getDereferenceableBytes() const;\n\n  /// Returns the number of dereferenceable_or_null bytes from the\n  /// dereferenceable_or_null attribute.\n  uint64_t getDereferenceableOrNullBytes() const;\n\n  /// Returns the argument numbers for the allocsize attribute (or pair(0, 0)\n  /// if not known).\n  std::pair<unsigned, Optional<unsigned>> getAllocSizeArgs() const;\n\n  /// The Attribute is converted to a string of equivalent mnemonic. This\n  /// is, presumably, for writing out the mnemonics for the assembly writer.\n  std::string getAsString(bool InAttrGrp = false) const;\n\n  /// Equality and non-equality operators.\n  bool operator==(Attribute A) const { return pImpl == A.pImpl; }\n  bool operator!=(Attribute A) const { return pImpl != A.pImpl; }\n\n  /// Less-than operator. Useful for sorting the attributes list.\n  bool operator<(Attribute A) const;\n\n  void Profile(FoldingSetNodeID &ID) const;\n\n  /// Return a raw pointer that uniquely identifies this attribute.\n  void *getRawPointer() const {\n    return pImpl;\n  }\n\n  /// Get an attribute from a raw pointer created by getRawPointer.\n  static Attribute fromRawPointer(void *RawPtr) {\n    return Attribute(reinterpret_cast<AttributeImpl*>(RawPtr));\n  }\n};\n\n// Specialized opaque value conversions.\ninline LLVMAttributeRef wrap(Attribute Attr) {\n  return reinterpret_cast<LLVMAttributeRef>(Attr.getRawPointer());\n}\n\n// Specialized opaque value conversions.\ninline Attribute unwrap(LLVMAttributeRef Attr) {\n  return Attribute::fromRawPointer(Attr);\n}\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// This class holds the attributes for a particular argument, parameter,\n/// function, or return value. It is an immutable value type that is cheap to\n/// copy. Adding and removing enum attributes is intended to be fast, but adding\n/// and removing string or integer attributes involves a FoldingSet lookup.\nclass AttributeSet {\n  friend AttributeListImpl;\n  template <typename Ty> friend struct DenseMapInfo;\n\n  // TODO: Extract AvailableAttrs from AttributeSetNode and store them here.\n  // This will allow an efficient implementation of addAttribute and\n  // removeAttribute for enum attrs.\n\n  /// Private implementation pointer.\n  AttributeSetNode *SetNode = nullptr;\n\nprivate:\n  explicit AttributeSet(AttributeSetNode *ASN) : SetNode(ASN) {}\n\npublic:\n  /// AttributeSet is a trivially copyable value type.\n  AttributeSet() = default;\n  AttributeSet(const AttributeSet &) = default;\n  ~AttributeSet() = default;\n\n  static AttributeSet get(LLVMContext &C, const AttrBuilder &B);\n  static AttributeSet get(LLVMContext &C, ArrayRef<Attribute> Attrs);\n\n  bool operator==(const AttributeSet &O) const { return SetNode == O.SetNode; }\n  bool operator!=(const AttributeSet &O) const { return !(*this == O); }\n\n  /// Add an argument attribute. Returns a new set because attribute sets are\n  /// immutable.\n  LLVM_NODISCARD AttributeSet addAttribute(LLVMContext &C,\n                                           Attribute::AttrKind Kind) const;\n\n  /// Add a target-dependent attribute. Returns a new set because attribute sets\n  /// are immutable.\n  LLVM_NODISCARD AttributeSet addAttribute(LLVMContext &C, StringRef Kind,\n                                           StringRef Value = StringRef()) const;\n\n  /// Add attributes to the attribute set. Returns a new set because attribute\n  /// sets are immutable.\n  LLVM_NODISCARD AttributeSet addAttributes(LLVMContext &C,\n                                            AttributeSet AS) const;\n\n  /// Remove the specified attribute from this set. Returns a new set because\n  /// attribute sets are immutable.\n  LLVM_NODISCARD AttributeSet removeAttribute(LLVMContext &C,\n                                              Attribute::AttrKind Kind) const;\n\n  /// Remove the specified attribute from this set. Returns a new set because\n  /// attribute sets are immutable.\n  LLVM_NODISCARD AttributeSet removeAttribute(LLVMContext &C,\n                                              StringRef Kind) const;\n\n  /// Remove the specified attributes from this set. Returns a new set because\n  /// attribute sets are immutable.\n  LLVM_NODISCARD AttributeSet\n  removeAttributes(LLVMContext &C, const AttrBuilder &AttrsToRemove) const;\n\n  /// Return the number of attributes in this set.\n  unsigned getNumAttributes() const;\n\n  /// Return true if attributes exists in this set.\n  bool hasAttributes() const { return SetNode != nullptr; }\n\n  /// Return true if the attribute exists in this set.\n  bool hasAttribute(Attribute::AttrKind Kind) const;\n\n  /// Return true if the attribute exists in this set.\n  bool hasAttribute(StringRef Kind) const;\n\n  /// Return the attribute object.\n  Attribute getAttribute(Attribute::AttrKind Kind) const;\n\n  /// Return the target-dependent attribute object.\n  Attribute getAttribute(StringRef Kind) const;\n\n  MaybeAlign getAlignment() const;\n  MaybeAlign getStackAlignment() const;\n  uint64_t getDereferenceableBytes() const;\n  uint64_t getDereferenceableOrNullBytes() const;\n  Type *getByValType() const;\n  Type *getStructRetType() const;\n  Type *getByRefType() const;\n  Type *getPreallocatedType() const;\n  std::pair<unsigned, Optional<unsigned>> getAllocSizeArgs() const;\n  std::string getAsString(bool InAttrGrp = false) const;\n\n  using iterator = const Attribute *;\n\n  iterator begin() const;\n  iterator end() const;\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  void dump() const;\n#endif\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// Provide DenseMapInfo for AttributeSet.\ntemplate <> struct DenseMapInfo<AttributeSet> {\n  static AttributeSet getEmptyKey() {\n    auto Val = static_cast<uintptr_t>(-1);\n    Val <<= PointerLikeTypeTraits<void *>::NumLowBitsAvailable;\n    return AttributeSet(reinterpret_cast<AttributeSetNode *>(Val));\n  }\n\n  static AttributeSet getTombstoneKey() {\n    auto Val = static_cast<uintptr_t>(-2);\n    Val <<= PointerLikeTypeTraits<void *>::NumLowBitsAvailable;\n    return AttributeSet(reinterpret_cast<AttributeSetNode *>(Val));\n  }\n\n  static unsigned getHashValue(AttributeSet AS) {\n    return (unsigned((uintptr_t)AS.SetNode) >> 4) ^\n           (unsigned((uintptr_t)AS.SetNode) >> 9);\n  }\n\n  static bool isEqual(AttributeSet LHS, AttributeSet RHS) { return LHS == RHS; }\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// This class holds the attributes for a function, its return value, and\n/// its parameters. You access the attributes for each of them via an index into\n/// the AttributeList object. The function attributes are at index\n/// `AttributeList::FunctionIndex', the return value is at index\n/// `AttributeList::ReturnIndex', and the attributes for the parameters start at\n/// index `AttributeList::FirstArgIndex'.\nclass AttributeList {\npublic:\n  enum AttrIndex : unsigned {\n    ReturnIndex = 0U,\n    FunctionIndex = ~0U,\n    FirstArgIndex = 1,\n  };\n\nprivate:\n  friend class AttrBuilder;\n  friend class AttributeListImpl;\n  friend class AttributeSet;\n  friend class AttributeSetNode;\n  template <typename Ty> friend struct DenseMapInfo;\n\n  /// The attributes that we are managing. This can be null to represent\n  /// the empty attributes list.\n  AttributeListImpl *pImpl = nullptr;\n\npublic:\n  /// Create an AttributeList with the specified parameters in it.\n  static AttributeList get(LLVMContext &C,\n                           ArrayRef<std::pair<unsigned, Attribute>> Attrs);\n  static AttributeList get(LLVMContext &C,\n                           ArrayRef<std::pair<unsigned, AttributeSet>> Attrs);\n\n  /// Create an AttributeList from attribute sets for a function, its\n  /// return value, and all of its arguments.\n  static AttributeList get(LLVMContext &C, AttributeSet FnAttrs,\n                           AttributeSet RetAttrs,\n                           ArrayRef<AttributeSet> ArgAttrs);\n\nprivate:\n  explicit AttributeList(AttributeListImpl *LI) : pImpl(LI) {}\n\n  static AttributeList getImpl(LLVMContext &C, ArrayRef<AttributeSet> AttrSets);\n\n  AttributeList setAttributes(LLVMContext &C, unsigned Index,\n                              AttributeSet Attrs) const;\n\npublic:\n  AttributeList() = default;\n\n  //===--------------------------------------------------------------------===//\n  // AttributeList Construction and Mutation\n  //===--------------------------------------------------------------------===//\n\n  /// Return an AttributeList with the specified parameters in it.\n  static AttributeList get(LLVMContext &C, ArrayRef<AttributeList> Attrs);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           ArrayRef<Attribute::AttrKind> Kinds);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           ArrayRef<Attribute::AttrKind> Kinds,\n                           ArrayRef<uint64_t> Values);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           ArrayRef<StringRef> Kind);\n  static AttributeList get(LLVMContext &C, unsigned Index,\n                           const AttrBuilder &B);\n\n  /// Add an attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addAttribute(LLVMContext &C, unsigned Index,\n                                            Attribute::AttrKind Kind) const;\n\n  /// Add an attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addAttribute(LLVMContext &C, unsigned Index, StringRef Kind,\n               StringRef Value = StringRef()) const;\n\n  /// Add an attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addAttribute(LLVMContext &C, unsigned Index,\n                                            Attribute A) const;\n\n  /// Add attributes to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addAttributes(LLVMContext &C, unsigned Index,\n                                             const AttrBuilder &B) const;\n\n  /// Add an argument attribute to the list. Returns a new list because\n  /// attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addParamAttribute(\n      LLVMContext &C, unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return addAttribute(C, ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Add an argument attribute to the list. Returns a new list because\n  /// attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addParamAttribute(LLVMContext &C, unsigned ArgNo, StringRef Kind,\n                    StringRef Value = StringRef()) const {\n    return addAttribute(C, ArgNo + FirstArgIndex, Kind, Value);\n  }\n\n  /// Add an attribute to the attribute list at the given arg indices. Returns a\n  /// new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addParamAttribute(LLVMContext &C,\n                                                 ArrayRef<unsigned> ArgNos,\n                                                 Attribute A) const;\n\n  /// Add an argument attribute to the list. Returns a new list because\n  /// attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addParamAttributes(LLVMContext &C,\n                                                  unsigned ArgNo,\n                                                  const AttrBuilder &B) const {\n    return addAttributes(C, ArgNo + FirstArgIndex, B);\n  }\n\n  /// Remove the specified attribute at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttribute(LLVMContext &C, unsigned Index,\n                                               Attribute::AttrKind Kind) const;\n\n  /// Remove the specified attribute at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttribute(LLVMContext &C, unsigned Index,\n                                               StringRef Kind) const;\n\n  /// Remove the specified attributes at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttributes(\n      LLVMContext &C, unsigned Index, const AttrBuilder &AttrsToRemove) const;\n\n  /// Remove all attributes at the specified index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeAttributes(LLVMContext &C,\n                                                unsigned Index) const;\n\n  /// Remove the specified attribute at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttribute(\n      LLVMContext &C, unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return removeAttribute(C, ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Remove the specified attribute at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttribute(LLVMContext &C,\n                                                    unsigned ArgNo,\n                                                    StringRef Kind) const {\n    return removeAttribute(C, ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Remove the specified attribute at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttributes(\n      LLVMContext &C, unsigned ArgNo, const AttrBuilder &AttrsToRemove) const {\n    return removeAttributes(C, ArgNo + FirstArgIndex, AttrsToRemove);\n  }\n\n  /// Remove all attributes at the specified arg index from this\n  /// attribute list. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList removeParamAttributes(LLVMContext &C,\n                                                     unsigned ArgNo) const {\n    return removeAttributes(C, ArgNo + FirstArgIndex);\n  }\n\n  /// Replace the type contained by attribute \\p AttrKind at index \\p ArgNo wih\n  /// \\p ReplacementTy, preserving all other attributes.\n  LLVM_NODISCARD AttributeList replaceAttributeType(LLVMContext &C,\n                                                    unsigned ArgNo,\n                                                    Attribute::AttrKind Kind,\n                                                    Type *ReplacementTy) const {\n    Attribute Attr = getAttribute(ArgNo, Kind);\n    auto Attrs = removeAttribute(C, ArgNo, Kind);\n    return Attrs.addAttribute(C, ArgNo, Attr.getWithNewType(C, ReplacementTy));\n  }\n\n  /// \\brief Add the dereferenceable attribute to the attribute set at the given\n  /// index. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableAttr(LLVMContext &C,\n                                                      unsigned Index,\n                                                      uint64_t Bytes) const;\n\n  /// \\brief Add the dereferenceable attribute to the attribute set at the given\n  /// arg index. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableParamAttr(\n      LLVMContext &C, unsigned ArgNo, uint64_t Bytes) const {\n    return addDereferenceableAttr(C, ArgNo + FirstArgIndex, Bytes);\n  }\n\n  /// Add the dereferenceable_or_null attribute to the attribute set at\n  /// the given index. Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableOrNullAttr(\n      LLVMContext &C, unsigned Index, uint64_t Bytes) const;\n\n  /// Add the dereferenceable_or_null attribute to the attribute set at\n  /// the given arg index. Returns a new list because attribute lists are\n  /// immutable.\n  LLVM_NODISCARD AttributeList addDereferenceableOrNullParamAttr(\n      LLVMContext &C, unsigned ArgNo, uint64_t Bytes) const {\n    return addDereferenceableOrNullAttr(C, ArgNo + FirstArgIndex, Bytes);\n  }\n\n  /// Add the allocsize attribute to the attribute set at the given index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addAllocSizeAttr(LLVMContext &C, unsigned Index, unsigned ElemSizeArg,\n                   const Optional<unsigned> &NumElemsArg);\n\n  /// Add the allocsize attribute to the attribute set at the given arg index.\n  /// Returns a new list because attribute lists are immutable.\n  LLVM_NODISCARD AttributeList\n  addAllocSizeParamAttr(LLVMContext &C, unsigned ArgNo, unsigned ElemSizeArg,\n                        const Optional<unsigned> &NumElemsArg) {\n    return addAllocSizeAttr(C, ArgNo + FirstArgIndex, ElemSizeArg, NumElemsArg);\n  }\n\n  //===--------------------------------------------------------------------===//\n  // AttributeList Accessors\n  //===--------------------------------------------------------------------===//\n\n  /// The attributes for the specified index are returned.\n  AttributeSet getAttributes(unsigned Index) const;\n\n  /// The attributes for the argument or parameter at the given index are\n  /// returned.\n  AttributeSet getParamAttributes(unsigned ArgNo) const;\n\n  /// The attributes for the ret value are returned.\n  AttributeSet getRetAttributes() const;\n\n  /// The function attributes are returned.\n  AttributeSet getFnAttributes() const;\n\n  /// Return true if the attribute exists at the given index.\n  bool hasAttribute(unsigned Index, Attribute::AttrKind Kind) const;\n\n  /// Return true if the attribute exists at the given index.\n  bool hasAttribute(unsigned Index, StringRef Kind) const;\n\n  /// Return true if attribute exists at the given index.\n  bool hasAttributes(unsigned Index) const;\n\n  /// Return true if the attribute exists for the given argument\n  bool hasParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return hasAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return true if the attribute exists for the given argument\n  bool hasParamAttr(unsigned ArgNo, StringRef Kind) const {\n    return hasAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return true if attributes exists for the given argument\n  bool hasParamAttrs(unsigned ArgNo) const {\n    return hasAttributes(ArgNo + FirstArgIndex);\n  }\n\n  /// Equivalent to hasAttribute(AttributeList::FunctionIndex, Kind) but\n  /// may be faster.\n  bool hasFnAttribute(Attribute::AttrKind Kind) const;\n\n  /// Equivalent to hasAttribute(AttributeList::FunctionIndex, Kind) but\n  /// may be faster.\n  bool hasFnAttribute(StringRef Kind) const;\n\n  /// Equivalent to hasAttribute(ArgNo + FirstArgIndex, Kind).\n  bool hasParamAttribute(unsigned ArgNo, Attribute::AttrKind Kind) const;\n\n  /// Return true if the specified attribute is set for at least one\n  /// parameter or for the return value. If Index is not nullptr, the index\n  /// of a parameter with the specified attribute is provided.\n  bool hasAttrSomewhere(Attribute::AttrKind Kind,\n                        unsigned *Index = nullptr) const;\n\n  /// Return the attribute object that exists at the given index.\n  Attribute getAttribute(unsigned Index, Attribute::AttrKind Kind) const;\n\n  /// Return the attribute object that exists at the given index.\n  Attribute getAttribute(unsigned Index, StringRef Kind) const;\n\n  /// Return the attribute object that exists at the arg index.\n  Attribute getParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    return getAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return the attribute object that exists at the given index.\n  Attribute getParamAttr(unsigned ArgNo, StringRef Kind) const {\n    return getAttribute(ArgNo + FirstArgIndex, Kind);\n  }\n\n  /// Return the alignment of the return value.\n  MaybeAlign getRetAlignment() const;\n\n  /// Return the alignment for the specified function parameter.\n  MaybeAlign getParamAlignment(unsigned ArgNo) const;\n\n  /// Return the byval type for the specified function parameter.\n  Type *getParamByValType(unsigned ArgNo) const;\n\n  /// Return the sret type for the specified function parameter.\n  Type *getParamStructRetType(unsigned ArgNo) const;\n\n  /// Return the byref type for the specified function parameter.\n  Type *getParamByRefType(unsigned ArgNo) const;\n\n  /// Return the preallocated type for the specified function parameter.\n  Type *getParamPreallocatedType(unsigned ArgNo) const;\n\n  /// Get the stack alignment.\n  MaybeAlign getStackAlignment(unsigned Index) const;\n\n  /// Get the number of dereferenceable bytes (or zero if unknown).\n  uint64_t getDereferenceableBytes(unsigned Index) const;\n\n  /// Get the number of dereferenceable bytes (or zero if unknown) of an\n  /// arg.\n  uint64_t getParamDereferenceableBytes(unsigned ArgNo) const {\n    return getDereferenceableBytes(ArgNo + FirstArgIndex);\n  }\n\n  /// Get the number of dereferenceable_or_null bytes (or zero if\n  /// unknown).\n  uint64_t getDereferenceableOrNullBytes(unsigned Index) const;\n\n  /// Get the number of dereferenceable_or_null bytes (or zero if\n  /// unknown) of an arg.\n  uint64_t getParamDereferenceableOrNullBytes(unsigned ArgNo) const {\n    return getDereferenceableOrNullBytes(ArgNo + FirstArgIndex);\n  }\n\n  /// Get the allocsize argument numbers (or pair(0, 0) if unknown).\n  std::pair<unsigned, Optional<unsigned>>\n  getAllocSizeArgs(unsigned Index) const;\n\n  /// Return the attributes at the index as a string.\n  std::string getAsString(unsigned Index, bool InAttrGrp = false) const;\n\n  //===--------------------------------------------------------------------===//\n  // AttributeList Introspection\n  //===--------------------------------------------------------------------===//\n\n  using iterator = const AttributeSet *;\n\n  iterator begin() const;\n  iterator end() const;\n\n  unsigned getNumAttrSets() const;\n\n  /// Use these to iterate over the valid attribute indices.\n  unsigned index_begin() const { return AttributeList::FunctionIndex; }\n  unsigned index_end() const { return getNumAttrSets() - 1; }\n\n  /// operator==/!= - Provide equality predicates.\n  bool operator==(const AttributeList &RHS) const { return pImpl == RHS.pImpl; }\n  bool operator!=(const AttributeList &RHS) const { return pImpl != RHS.pImpl; }\n\n  /// Return a raw pointer that uniquely identifies this attribute list.\n  void *getRawPointer() const {\n    return pImpl;\n  }\n\n  /// Return true if there are no attributes.\n  bool isEmpty() const { return pImpl == nullptr; }\n\n  void dump() const;\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// Provide DenseMapInfo for AttributeList.\ntemplate <> struct DenseMapInfo<AttributeList> {\n  static AttributeList getEmptyKey() {\n    auto Val = static_cast<uintptr_t>(-1);\n    Val <<= PointerLikeTypeTraits<void*>::NumLowBitsAvailable;\n    return AttributeList(reinterpret_cast<AttributeListImpl *>(Val));\n  }\n\n  static AttributeList getTombstoneKey() {\n    auto Val = static_cast<uintptr_t>(-2);\n    Val <<= PointerLikeTypeTraits<void*>::NumLowBitsAvailable;\n    return AttributeList(reinterpret_cast<AttributeListImpl *>(Val));\n  }\n\n  static unsigned getHashValue(AttributeList AS) {\n    return (unsigned((uintptr_t)AS.pImpl) >> 4) ^\n           (unsigned((uintptr_t)AS.pImpl) >> 9);\n  }\n\n  static bool isEqual(AttributeList LHS, AttributeList RHS) {\n    return LHS == RHS;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// \\class\n/// This class is used in conjunction with the Attribute::get method to\n/// create an Attribute object. The object itself is uniquified. The Builder's\n/// value, however, is not. So this can be used as a quick way to test for\n/// equality, presence of attributes, etc.\nclass AttrBuilder {\n  std::bitset<Attribute::EndAttrKinds> Attrs;\n  std::map<std::string, std::string, std::less<>> TargetDepAttrs;\n  MaybeAlign Alignment;\n  MaybeAlign StackAlignment;\n  uint64_t DerefBytes = 0;\n  uint64_t DerefOrNullBytes = 0;\n  uint64_t AllocSizeArgs = 0;\n  Type *ByValType = nullptr;\n  Type *StructRetType = nullptr;\n  Type *ByRefType = nullptr;\n  Type *PreallocatedType = nullptr;\n\npublic:\n  AttrBuilder() = default;\n\n  AttrBuilder(const Attribute &A) {\n    addAttribute(A);\n  }\n\n  AttrBuilder(AttributeList AS, unsigned Idx);\n  AttrBuilder(AttributeSet AS);\n\n  void clear();\n\n  /// Add an attribute to the builder.\n  AttrBuilder &addAttribute(Attribute::AttrKind Val) {\n    assert((unsigned)Val < Attribute::EndAttrKinds &&\n           \"Attribute out of range!\");\n    assert(!Attribute::doesAttrKindHaveArgument(Val) &&\n           \"Adding integer attribute without adding a value!\");\n    Attrs[Val] = true;\n    return *this;\n  }\n\n  /// Add the Attribute object to the builder.\n  AttrBuilder &addAttribute(Attribute A);\n\n  /// Add the target-dependent attribute to the builder.\n  AttrBuilder &addAttribute(StringRef A, StringRef V = StringRef());\n\n  /// Remove an attribute from the builder.\n  AttrBuilder &removeAttribute(Attribute::AttrKind Val);\n\n  /// Remove the attributes from the builder.\n  AttrBuilder &removeAttributes(AttributeList A, uint64_t WithoutIndex);\n\n  /// Remove the target-dependent attribute to the builder.\n  AttrBuilder &removeAttribute(StringRef A);\n\n  /// Add the attributes from the builder.\n  AttrBuilder &merge(const AttrBuilder &B);\n\n  /// Remove the attributes from the builder.\n  AttrBuilder &remove(const AttrBuilder &B);\n\n  /// Return true if the builder has any attribute that's in the\n  /// specified builder.\n  bool overlaps(const AttrBuilder &B) const;\n\n  /// Return true if the builder has the specified attribute.\n  bool contains(Attribute::AttrKind A) const {\n    assert((unsigned)A < Attribute::EndAttrKinds && \"Attribute out of range!\");\n    return Attrs[A];\n  }\n\n  /// Return true if the builder has the specified target-dependent\n  /// attribute.\n  bool contains(StringRef A) const;\n\n  /// Return true if the builder has IR-level attributes.\n  bool hasAttributes() const;\n\n  /// Return true if the builder has any attribute that's in the\n  /// specified attribute.\n  bool hasAttributes(AttributeList A, uint64_t Index) const;\n\n  /// Return true if the builder has an alignment attribute.\n  bool hasAlignmentAttr() const;\n\n  /// Retrieve the alignment attribute, if it exists.\n  MaybeAlign getAlignment() const { return Alignment; }\n\n  /// Retrieve the stack alignment attribute, if it exists.\n  MaybeAlign getStackAlignment() const { return StackAlignment; }\n\n  /// Retrieve the number of dereferenceable bytes, if the\n  /// dereferenceable attribute exists (zero is returned otherwise).\n  uint64_t getDereferenceableBytes() const { return DerefBytes; }\n\n  /// Retrieve the number of dereferenceable_or_null bytes, if the\n  /// dereferenceable_or_null attribute exists (zero is returned otherwise).\n  uint64_t getDereferenceableOrNullBytes() const { return DerefOrNullBytes; }\n\n  /// Retrieve the byval type.\n  Type *getByValType() const { return ByValType; }\n\n  /// Retrieve the sret type.\n  Type *getStructRetType() const { return StructRetType; }\n\n  /// Retrieve the byref type.\n  Type *getByRefType() const { return ByRefType; }\n\n  /// Retrieve the preallocated type.\n  Type *getPreallocatedType() const { return PreallocatedType; }\n\n  /// Retrieve the allocsize args, if the allocsize attribute exists.  If it\n  /// doesn't exist, pair(0, 0) is returned.\n  std::pair<unsigned, Optional<unsigned>> getAllocSizeArgs() const;\n\n  /// This turns an alignment into the form used internally in Attribute.\n  /// This call has no effect if Align is not set.\n  AttrBuilder &addAlignmentAttr(MaybeAlign Align);\n\n  /// This turns an int alignment (which must be a power of 2) into the\n  /// form used internally in Attribute.\n  /// This call has no effect if Align is 0.\n  /// Deprecated, use the version using a MaybeAlign.\n  inline AttrBuilder &addAlignmentAttr(unsigned Align) {\n    return addAlignmentAttr(MaybeAlign(Align));\n  }\n\n  /// This turns a stack alignment into the form used internally in Attribute.\n  /// This call has no effect if Align is not set.\n  AttrBuilder &addStackAlignmentAttr(MaybeAlign Align);\n\n  /// This turns an int stack alignment (which must be a power of 2) into\n  /// the form used internally in Attribute.\n  /// This call has no effect if Align is 0.\n  /// Deprecated, use the version using a MaybeAlign.\n  inline AttrBuilder &addStackAlignmentAttr(unsigned Align) {\n    return addStackAlignmentAttr(MaybeAlign(Align));\n  }\n\n  /// This turns the number of dereferenceable bytes into the form used\n  /// internally in Attribute.\n  AttrBuilder &addDereferenceableAttr(uint64_t Bytes);\n\n  /// This turns the number of dereferenceable_or_null bytes into the\n  /// form used internally in Attribute.\n  AttrBuilder &addDereferenceableOrNullAttr(uint64_t Bytes);\n\n  /// This turns one (or two) ints into the form used internally in Attribute.\n  AttrBuilder &addAllocSizeAttr(unsigned ElemSizeArg,\n                                const Optional<unsigned> &NumElemsArg);\n\n  /// This turns a byval type into the form used internally in Attribute.\n  AttrBuilder &addByValAttr(Type *Ty);\n\n  /// This turns a sret type into the form used internally in Attribute.\n  AttrBuilder &addStructRetAttr(Type *Ty);\n\n  /// This turns a byref type into the form used internally in Attribute.\n  AttrBuilder &addByRefAttr(Type *Ty);\n\n  /// This turns a preallocated type into the form used internally in Attribute.\n  AttrBuilder &addPreallocatedAttr(Type *Ty);\n\n  /// Add an allocsize attribute, using the representation returned by\n  /// Attribute.getIntValue().\n  AttrBuilder &addAllocSizeAttrFromRawRepr(uint64_t RawAllocSizeRepr);\n\n  /// Return true if the builder contains no target-independent\n  /// attributes.\n  bool empty() const { return Attrs.none(); }\n\n  // Iterators for target-dependent attributes.\n  using td_type = std::pair<std::string, std::string>;\n  using td_iterator = decltype(TargetDepAttrs)::iterator;\n  using td_const_iterator = decltype(TargetDepAttrs)::const_iterator;\n  using td_range = iterator_range<td_iterator>;\n  using td_const_range = iterator_range<td_const_iterator>;\n\n  td_iterator td_begin() { return TargetDepAttrs.begin(); }\n  td_iterator td_end() { return TargetDepAttrs.end(); }\n\n  td_const_iterator td_begin() const { return TargetDepAttrs.begin(); }\n  td_const_iterator td_end() const { return TargetDepAttrs.end(); }\n\n  td_range td_attrs() { return td_range(td_begin(), td_end()); }\n\n  td_const_range td_attrs() const {\n    return td_const_range(td_begin(), td_end());\n  }\n\n  bool td_empty() const { return TargetDepAttrs.empty(); }\n\n  bool operator==(const AttrBuilder &B) const;\n  bool operator!=(const AttrBuilder &B) const { return !(*this == B); }\n};\n\nnamespace AttributeFuncs {\n\n/// Which attributes cannot be applied to a type.\nAttrBuilder typeIncompatible(Type *Ty);\n\n/// \\returns Return true if the two functions have compatible target-independent\n/// attributes for inlining purposes.\nbool areInlineCompatible(const Function &Caller, const Function &Callee);\n\n\n/// Checks  if there are any incompatible function attributes between\n/// \\p A and \\p B.\n///\n/// \\param [in] A - The first function to be compared with.\n/// \\param [in] B - The second function to be compared with.\n/// \\returns true if the functions have compatible attributes.\nbool areOutlineCompatible(const Function &A, const Function &B);\n\n/// Merge caller's and callee's attributes.\nvoid mergeAttributesForInlining(Function &Caller, const Function &Callee);\n\n/// Merges the functions attributes from \\p ToMerge into function \\p Base.\n///\n/// \\param [in,out] Base - The function being merged into.\n/// \\param [in] ToMerge - The function to merge attributes from.\nvoid mergeAttributesForOutlining(Function &Base, const Function &ToMerge);\n\n} // end namespace AttributeFuncs\n\n} // end namespace llvm\n\n#endif // LLVM_IR_ATTRIBUTES_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/CFG.h", "content": "//===- CFG.h ----------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n///\n/// This file provides various utilities for inspecting and working with the\n/// control flow graph in LLVM IR. This includes generic facilities for\n/// iterating successors and predecessors of basic blocks, the successors of\n/// specific terminator instructions, etc. It also defines specializations of\n/// GraphTraits that allow Function and BasicBlock graphs to be treated as\n/// proper graphs for generic algorithms.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_CFG_H\n#define LLVM_IR_CFG_H\n\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n\nnamespace llvm {\n\nclass BasicBlock;\nclass Instruction;\nclass Use;\n\n//===----------------------------------------------------------------------===//\n// BasicBlock pred_iterator definition\n//===----------------------------------------------------------------------===//\n\ntemplate <class Ptr, class USE_iterator> // Predecessor Iterator\nclass PredIterator : public std::iterator<std::forward_iterator_tag,\n                                          Ptr, ptrdiff_t, Ptr*, Ptr*> {\n  using super =\n      std::iterator<std::forward_iterator_tag, Ptr, ptrdiff_t, Ptr*, Ptr*>;\n  using Self = PredIterator<Ptr, USE_iterator>;\n  USE_iterator It;\n\n  inline void advancePastNonTerminators() {\n    // Loop to ignore non-terminator uses (for example BlockAddresses).\n    while (!It.atEnd()) {\n      if (auto *Inst = dyn_cast<Instruction>(*It))\n        if (Inst->isTerminator())\n          break;\n\n      ++It;\n    }\n  }\n\npublic:\n  using pointer = typename super::pointer;\n  using reference = typename super::reference;\n\n  PredIterator() = default;\n  explicit inline PredIterator(Ptr *bb) : It(bb->user_begin()) {\n    advancePastNonTerminators();\n  }\n  inline PredIterator(Ptr *bb, bool) : It(bb->user_end()) {}\n\n  inline bool operator==(const Self& x) const { return It == x.It; }\n  inline bool operator!=(const Self& x) const { return !operator==(x); }\n\n  inline reference operator*() const {\n    assert(!It.atEnd() && \"pred_iterator out of range!\");\n    return cast<Instruction>(*It)->getParent();\n  }\n  inline pointer *operator->() const { return &operator*(); }\n\n  inline Self& operator++() {   // Preincrement\n    assert(!It.atEnd() && \"pred_iterator out of range!\");\n    ++It; advancePastNonTerminators();\n    return *this;\n  }\n\n  inline Self operator++(int) { // Postincrement\n    Self tmp = *this; ++*this; return tmp;\n  }\n\n  /// getOperandNo - Return the operand number in the predecessor's\n  /// terminator of the successor.\n  unsigned getOperandNo() const {\n    return It.getOperandNo();\n  }\n\n  /// getUse - Return the operand Use in the predecessor's terminator\n  /// of the successor.\n  Use &getUse() const {\n    return It.getUse();\n  }\n};\n\nusing pred_iterator = PredIterator<BasicBlock, Value::user_iterator>;\nusing const_pred_iterator =\n    PredIterator<const BasicBlock, Value::const_user_iterator>;\nusing pred_range = iterator_range<pred_iterator>;\nusing const_pred_range = iterator_range<const_pred_iterator>;\n\ninline pred_iterator pred_begin(BasicBlock *BB) { return pred_iterator(BB); }\ninline const_pred_iterator pred_begin(const BasicBlock *BB) {\n  return const_pred_iterator(BB);\n}\ninline pred_iterator pred_end(BasicBlock *BB) { return pred_iterator(BB, true);}\ninline const_pred_iterator pred_end(const BasicBlock *BB) {\n  return const_pred_iterator(BB, true);\n}\ninline bool pred_empty(const BasicBlock *BB) {\n  return pred_begin(BB) == pred_end(BB);\n}\n/// Get the number of predecessors of \\p BB. This is a linear time operation.\n/// Use \\ref BasicBlock::hasNPredecessors() or hasNPredecessorsOrMore if able.\ninline unsigned pred_size(const BasicBlock *BB) {\n  return std::distance(pred_begin(BB), pred_end(BB));\n}\ninline pred_range predecessors(BasicBlock *BB) {\n  return pred_range(pred_begin(BB), pred_end(BB));\n}\ninline const_pred_range predecessors(const BasicBlock *BB) {\n  return const_pred_range(pred_begin(BB), pred_end(BB));\n}\n\n//===----------------------------------------------------------------------===//\n// Instruction and BasicBlock succ_iterator helpers\n//===----------------------------------------------------------------------===//\n\ntemplate <class InstructionT, class BlockT>\nclass SuccIterator\n    : public iterator_facade_base<SuccIterator<InstructionT, BlockT>,\n                                  std::random_access_iterator_tag, BlockT, int,\n                                  BlockT *, BlockT *> {\npublic:\n  using difference_type = int;\n  using pointer = BlockT *;\n  using reference = BlockT *;\n\nprivate:\n  InstructionT *Inst;\n  int Idx;\n  using Self = SuccIterator<InstructionT, BlockT>;\n\n  inline bool index_is_valid(int Idx) {\n    // Note that we specially support the index of zero being valid even in the\n    // face of a null instruction.\n    return Idx >= 0 && (Idx == 0 || Idx <= (int)Inst->getNumSuccessors());\n  }\n\n  /// Proxy object to allow write access in operator[]\n  class SuccessorProxy {\n    Self It;\n\n  public:\n    explicit SuccessorProxy(const Self &It) : It(It) {}\n\n    SuccessorProxy(const SuccessorProxy &) = default;\n\n    SuccessorProxy &operator=(SuccessorProxy RHS) {\n      *this = reference(RHS);\n      return *this;\n    }\n\n    SuccessorProxy &operator=(reference RHS) {\n      It.Inst->setSuccessor(It.Idx, RHS);\n      return *this;\n    }\n\n    operator reference() const { return *It; }\n  };\n\npublic:\n  // begin iterator\n  explicit inline SuccIterator(InstructionT *Inst) : Inst(Inst), Idx(0) {}\n  // end iterator\n  inline SuccIterator(InstructionT *Inst, bool) : Inst(Inst) {\n    if (Inst)\n      Idx = Inst->getNumSuccessors();\n    else\n      // Inst == NULL happens, if a basic block is not fully constructed and\n      // consequently getTerminator() returns NULL. In this case we construct\n      // a SuccIterator which describes a basic block that has zero\n      // successors.\n      // Defining SuccIterator for incomplete and malformed CFGs is especially\n      // useful for debugging.\n      Idx = 0;\n  }\n\n  /// This is used to interface between code that wants to\n  /// operate on terminator instructions directly.\n  int getSuccessorIndex() const { return Idx; }\n\n  inline bool operator==(const Self &x) const { return Idx == x.Idx; }\n\n  inline BlockT *operator*() const { return Inst->getSuccessor(Idx); }\n\n  // We use the basic block pointer directly for operator->.\n  inline BlockT *operator->() const { return operator*(); }\n\n  inline bool operator<(const Self &RHS) const {\n    assert(Inst == RHS.Inst && \"Cannot compare iterators of different blocks!\");\n    return Idx < RHS.Idx;\n  }\n\n  int operator-(const Self &RHS) const {\n    assert(Inst == RHS.Inst && \"Cannot compare iterators of different blocks!\");\n    return Idx - RHS.Idx;\n  }\n\n  inline Self &operator+=(int RHS) {\n    int NewIdx = Idx + RHS;\n    assert(index_is_valid(NewIdx) && \"Iterator index out of bound\");\n    Idx = NewIdx;\n    return *this;\n  }\n\n  inline Self &operator-=(int RHS) { return operator+=(-RHS); }\n\n  // Specially implement the [] operation using a proxy object to support\n  // assignment.\n  inline SuccessorProxy operator[](int Offset) {\n    Self TmpIt = *this;\n    TmpIt += Offset;\n    return SuccessorProxy(TmpIt);\n  }\n\n  /// Get the source BlockT of this iterator.\n  inline BlockT *getSource() {\n    assert(Inst && \"Source not available, if basic block was malformed\");\n    return Inst->getParent();\n  }\n};\n\nusing succ_iterator = SuccIterator<Instruction, BasicBlock>;\nusing const_succ_iterator = SuccIterator<const Instruction, const BasicBlock>;\nusing succ_range = iterator_range<succ_iterator>;\nusing const_succ_range = iterator_range<const_succ_iterator>;\n\ninline succ_iterator succ_begin(Instruction *I) { return succ_iterator(I); }\ninline const_succ_iterator succ_begin(const Instruction *I) {\n  return const_succ_iterator(I);\n}\ninline succ_iterator succ_end(Instruction *I) { return succ_iterator(I, true); }\ninline const_succ_iterator succ_end(const Instruction *I) {\n  return const_succ_iterator(I, true);\n}\ninline bool succ_empty(const Instruction *I) {\n  return succ_begin(I) == succ_end(I);\n}\ninline unsigned succ_size(const Instruction *I) {\n  return std::distance(succ_begin(I), succ_end(I));\n}\ninline succ_range successors(Instruction *I) {\n  return succ_range(succ_begin(I), succ_end(I));\n}\ninline const_succ_range successors(const Instruction *I) {\n  return const_succ_range(succ_begin(I), succ_end(I));\n}\n\ninline succ_iterator succ_begin(BasicBlock *BB) {\n  return succ_iterator(BB->getTerminator());\n}\ninline const_succ_iterator succ_begin(const BasicBlock *BB) {\n  return const_succ_iterator(BB->getTerminator());\n}\ninline succ_iterator succ_end(BasicBlock *BB) {\n  return succ_iterator(BB->getTerminator(), true);\n}\ninline const_succ_iterator succ_end(const BasicBlock *BB) {\n  return const_succ_iterator(BB->getTerminator(), true);\n}\ninline bool succ_empty(const BasicBlock *BB) {\n  return succ_begin(BB) == succ_end(BB);\n}\ninline unsigned succ_size(const BasicBlock *BB) {\n  return std::distance(succ_begin(BB), succ_end(BB));\n}\ninline succ_range successors(BasicBlock *BB) {\n  return succ_range(succ_begin(BB), succ_end(BB));\n}\ninline const_succ_range successors(const BasicBlock *BB) {\n  return const_succ_range(succ_begin(BB), succ_end(BB));\n}\n\n//===--------------------------------------------------------------------===//\n// GraphTraits specializations for basic block graphs (CFGs)\n//===--------------------------------------------------------------------===//\n\n// Provide specializations of GraphTraits to be able to treat a function as a\n// graph of basic blocks...\n\ntemplate <> struct GraphTraits<BasicBlock*> {\n  using NodeRef = BasicBlock *;\n  using ChildIteratorType = succ_iterator;\n\n  static NodeRef getEntryNode(BasicBlock *BB) { return BB; }\n  static ChildIteratorType child_begin(NodeRef N) { return succ_begin(N); }\n  static ChildIteratorType child_end(NodeRef N) { return succ_end(N); }\n};\n\ntemplate <> struct GraphTraits<const BasicBlock*> {\n  using NodeRef = const BasicBlock *;\n  using ChildIteratorType = const_succ_iterator;\n\n  static NodeRef getEntryNode(const BasicBlock *BB) { return BB; }\n\n  static ChildIteratorType child_begin(NodeRef N) { return succ_begin(N); }\n  static ChildIteratorType child_end(NodeRef N) { return succ_end(N); }\n};\n\n// Provide specializations of GraphTraits to be able to treat a function as a\n// graph of basic blocks... and to walk it in inverse order.  Inverse order for\n// a function is considered to be when traversing the predecessor edges of a BB\n// instead of the successor edges.\n//\ntemplate <> struct GraphTraits<Inverse<BasicBlock*>> {\n  using NodeRef = BasicBlock *;\n  using ChildIteratorType = pred_iterator;\n\n  static NodeRef getEntryNode(Inverse<BasicBlock *> G) { return G.Graph; }\n  static ChildIteratorType child_begin(NodeRef N) { return pred_begin(N); }\n  static ChildIteratorType child_end(NodeRef N) { return pred_end(N); }\n};\n\ntemplate <> struct GraphTraits<Inverse<const BasicBlock*>> {\n  using NodeRef = const BasicBlock *;\n  using ChildIteratorType = const_pred_iterator;\n\n  static NodeRef getEntryNode(Inverse<const BasicBlock *> G) { return G.Graph; }\n  static ChildIteratorType child_begin(NodeRef N) { return pred_begin(N); }\n  static ChildIteratorType child_end(NodeRef N) { return pred_end(N); }\n};\n\n//===--------------------------------------------------------------------===//\n// GraphTraits specializations for function basic block graphs (CFGs)\n//===--------------------------------------------------------------------===//\n\n// Provide specializations of GraphTraits to be able to treat a function as a\n// graph of basic blocks... these are the same as the basic block iterators,\n// except that the root node is implicitly the first node of the function.\n//\ntemplate <> struct GraphTraits<Function*> : public GraphTraits<BasicBlock*> {\n  static NodeRef getEntryNode(Function *F) { return &F->getEntryBlock(); }\n\n  // nodes_iterator/begin/end - Allow iteration over all nodes in the graph\n  using nodes_iterator = pointer_iterator<Function::iterator>;\n\n  static nodes_iterator nodes_begin(Function *F) {\n    return nodes_iterator(F->begin());\n  }\n\n  static nodes_iterator nodes_end(Function *F) {\n    return nodes_iterator(F->end());\n  }\n\n  static size_t size(Function *F) { return F->size(); }\n};\ntemplate <> struct GraphTraits<const Function*> :\n  public GraphTraits<const BasicBlock*> {\n  static NodeRef getEntryNode(const Function *F) { return &F->getEntryBlock(); }\n\n  // nodes_iterator/begin/end - Allow iteration over all nodes in the graph\n  using nodes_iterator = pointer_iterator<Function::const_iterator>;\n\n  static nodes_iterator nodes_begin(const Function *F) {\n    return nodes_iterator(F->begin());\n  }\n\n  static nodes_iterator nodes_end(const Function *F) {\n    return nodes_iterator(F->end());\n  }\n\n  static size_t size(const Function *F) { return F->size(); }\n};\n\n// Provide specializations of GraphTraits to be able to treat a function as a\n// graph of basic blocks... and to walk it in inverse order.  Inverse order for\n// a function is considered to be when traversing the predecessor edges of a BB\n// instead of the successor edges.\n//\ntemplate <> struct GraphTraits<Inverse<Function*>> :\n  public GraphTraits<Inverse<BasicBlock*>> {\n  static NodeRef getEntryNode(Inverse<Function *> G) {\n    return &G.Graph->getEntryBlock();\n  }\n};\ntemplate <> struct GraphTraits<Inverse<const Function*>> :\n  public GraphTraits<Inverse<const BasicBlock*>> {\n  static NodeRef getEntryNode(Inverse<const Function *> G) {\n    return &G.Graph->getEntryBlock();\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_CFG_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ConstantRange.h", "content": "//===- ConstantRange.h - Represent a range ----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Represent a range of possible values that may occur when the program is run\n// for an integral value.  This keeps track of a lower and upper bound for the\n// constant, which MAY wrap around the end of the numeric range.  To do this, it\n// keeps track of a [lower, upper) bound, which specifies an interval just like\n// STL iterators.  When used with boolean values, the following are important\n// ranges: :\n//\n//  [F, F) = {}     = Empty set\n//  [T, F) = {T}\n//  [F, T) = {F}\n//  [T, T) = {F, T} = Full set\n//\n// The other integral ranges use min/max values for special range values. For\n// example, for 8-bit types, it uses:\n// [0, 0)     = {}       = Empty set\n// [255, 255) = {0..255} = Full Set\n//\n// Note that ConstantRange can be used to represent either signed or\n// unsigned ranges.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_CONSTANTRANGE_H\n#define LLVM_IR_CONSTANTRANGE_H\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cstdint>\n\nnamespace llvm {\n\nclass MDNode;\nclass raw_ostream;\nstruct KnownBits;\n\n/// This class represents a range of values.\nclass LLVM_NODISCARD ConstantRange {\n  APInt Lower, Upper;\n\n  /// Create empty constant range with same bitwidth.\n  ConstantRange getEmpty() const {\n    return ConstantRange(getBitWidth(), false);\n  }\n\n  /// Create full constant range with same bitwidth.\n  ConstantRange getFull() const {\n    return ConstantRange(getBitWidth(), true);\n  }\n\npublic:\n  /// Initialize a full or empty set for the specified bit width.\n  explicit ConstantRange(uint32_t BitWidth, bool isFullSet);\n\n  /// Initialize a range to hold the single specified value.\n  ConstantRange(APInt Value);\n\n  /// Initialize a range of values explicitly. This will assert out if\n  /// Lower==Upper and Lower != Min or Max value for its type. It will also\n  /// assert out if the two APInt's are not the same bit width.\n  ConstantRange(APInt Lower, APInt Upper);\n\n  /// Create empty constant range with the given bit width.\n  static ConstantRange getEmpty(uint32_t BitWidth) {\n    return ConstantRange(BitWidth, false);\n  }\n\n  /// Create full constant range with the given bit width.\n  static ConstantRange getFull(uint32_t BitWidth) {\n    return ConstantRange(BitWidth, true);\n  }\n\n  /// Create non-empty constant range with the given bounds. If Lower and\n  /// Upper are the same, a full range is returned.\n  static ConstantRange getNonEmpty(APInt Lower, APInt Upper) {\n    if (Lower == Upper)\n      return getFull(Lower.getBitWidth());\n    return ConstantRange(std::move(Lower), std::move(Upper));\n  }\n\n  /// Initialize a range based on a known bits constraint. The IsSigned flag\n  /// indicates whether the constant range should not wrap in the signed or\n  /// unsigned domain.\n  static ConstantRange fromKnownBits(const KnownBits &Known, bool IsSigned);\n\n  /// Produce the smallest range such that all values that may satisfy the given\n  /// predicate with any value contained within Other is contained in the\n  /// returned range.  Formally, this returns a superset of\n  /// 'union over all y in Other . { x : icmp op x y is true }'.  If the exact\n  /// answer is not representable as a ConstantRange, the return value will be a\n  /// proper superset of the above.\n  ///\n  /// Example: Pred = ult and Other = i8 [2, 5) returns Result = [0, 4)\n  static ConstantRange makeAllowedICmpRegion(CmpInst::Predicate Pred,\n                                             const ConstantRange &Other);\n\n  /// Produce the largest range such that all values in the returned range\n  /// satisfy the given predicate with all values contained within Other.\n  /// Formally, this returns a subset of\n  /// 'intersection over all y in Other . { x : icmp op x y is true }'.  If the\n  /// exact answer is not representable as a ConstantRange, the return value\n  /// will be a proper subset of the above.\n  ///\n  /// Example: Pred = ult and Other = i8 [2, 5) returns [0, 2)\n  static ConstantRange makeSatisfyingICmpRegion(CmpInst::Predicate Pred,\n                                                const ConstantRange &Other);\n\n  /// Produce the exact range such that all values in the returned range satisfy\n  /// the given predicate with any value contained within Other. Formally, this\n  /// returns the exact answer when the superset of 'union over all y in Other\n  /// is exactly same as the subset of intersection over all y in Other.\n  /// { x : icmp op x y is true}'.\n  ///\n  /// Example: Pred = ult and Other = i8 3 returns [0, 3)\n  static ConstantRange makeExactICmpRegion(CmpInst::Predicate Pred,\n                                           const APInt &Other);\n\n  /// Produce the largest range containing all X such that \"X BinOp Y\" is\n  /// guaranteed not to wrap (overflow) for *all* Y in Other. However, there may\n  /// be *some* Y in Other for which additional X not contained in the result\n  /// also do not overflow.\n  ///\n  /// NoWrapKind must be one of OBO::NoUnsignedWrap or OBO::NoSignedWrap.\n  ///\n  /// Examples:\n  ///  typedef OverflowingBinaryOperator OBO;\n  ///  #define MGNR makeGuaranteedNoWrapRegion\n  ///  MGNR(Add, [i8 1, 2), OBO::NoSignedWrap) == [-128, 127)\n  ///  MGNR(Add, [i8 1, 2), OBO::NoUnsignedWrap) == [0, -1)\n  ///  MGNR(Add, [i8 0, 1), OBO::NoUnsignedWrap) == Full Set\n  ///  MGNR(Add, [i8 -1, 6), OBO::NoSignedWrap) == [INT_MIN+1, INT_MAX-4)\n  ///  MGNR(Sub, [i8 1, 2), OBO::NoSignedWrap) == [-127, 128)\n  ///  MGNR(Sub, [i8 1, 2), OBO::NoUnsignedWrap) == [1, 0)\n  static ConstantRange makeGuaranteedNoWrapRegion(Instruction::BinaryOps BinOp,\n                                                  const ConstantRange &Other,\n                                                  unsigned NoWrapKind);\n\n  /// Produce the range that contains X if and only if \"X BinOp Other\" does\n  /// not wrap.\n  static ConstantRange makeExactNoWrapRegion(Instruction::BinaryOps BinOp,\n                                             const APInt &Other,\n                                             unsigned NoWrapKind);\n\n  /// Returns true if ConstantRange calculations are supported for intrinsic\n  /// with \\p IntrinsicID.\n  static bool isIntrinsicSupported(Intrinsic::ID IntrinsicID);\n\n  /// Compute range of intrinsic result for the given operand ranges.\n  static ConstantRange intrinsic(Intrinsic::ID IntrinsicID,\n                                 ArrayRef<ConstantRange> Ops);\n\n  /// Set up \\p Pred and \\p RHS such that\n  /// ConstantRange::makeExactICmpRegion(Pred, RHS) == *this.  Return true if\n  /// successful.\n  bool getEquivalentICmp(CmpInst::Predicate &Pred, APInt &RHS) const;\n\n  /// Return the lower value for this range.\n  const APInt &getLower() const { return Lower; }\n\n  /// Return the upper value for this range.\n  const APInt &getUpper() const { return Upper; }\n\n  /// Get the bit width of this ConstantRange.\n  uint32_t getBitWidth() const { return Lower.getBitWidth(); }\n\n  /// Return true if this set contains all of the elements possible\n  /// for this data-type.\n  bool isFullSet() const;\n\n  /// Return true if this set contains no members.\n  bool isEmptySet() const;\n\n  /// Return true if this set wraps around the unsigned domain. Special cases:\n  ///  * Empty set: Not wrapped.\n  ///  * Full set: Not wrapped.\n  ///  * [X, 0) == [X, Max]: Not wrapped.\n  bool isWrappedSet() const;\n\n  /// Return true if the exclusive upper bound wraps around the unsigned\n  /// domain. Special cases:\n  ///  * Empty set: Not wrapped.\n  ///  * Full set: Not wrapped.\n  ///  * [X, 0): Wrapped.\n  bool isUpperWrapped() const;\n\n  /// Return true if this set wraps around the signed domain. Special cases:\n  ///  * Empty set: Not wrapped.\n  ///  * Full set: Not wrapped.\n  ///  * [X, SignedMin) == [X, SignedMax]: Not wrapped.\n  bool isSignWrappedSet() const;\n\n  /// Return true if the (exclusive) upper bound wraps around the signed\n  /// domain. Special cases:\n  ///  * Empty set: Not wrapped.\n  ///  * Full set: Not wrapped.\n  ///  * [X, SignedMin): Wrapped.\n  bool isUpperSignWrapped() const;\n\n  /// Return true if the specified value is in the set.\n  bool contains(const APInt &Val) const;\n\n  /// Return true if the other range is a subset of this one.\n  bool contains(const ConstantRange &CR) const;\n\n  /// If this set contains a single element, return it, otherwise return null.\n  const APInt *getSingleElement() const {\n    if (Upper == Lower + 1)\n      return &Lower;\n    return nullptr;\n  }\n\n  /// If this set contains all but a single element, return it, otherwise return\n  /// null.\n  const APInt *getSingleMissingElement() const {\n    if (Lower == Upper + 1)\n      return &Upper;\n    return nullptr;\n  }\n\n  /// Return true if this set contains exactly one member.\n  bool isSingleElement() const { return getSingleElement() != nullptr; }\n\n  /// Compare set size of this range with the range CR.\n  bool isSizeStrictlySmallerThan(const ConstantRange &CR) const;\n\n  /// Compare set size of this range with Value.\n  bool isSizeLargerThan(uint64_t MaxSize) const;\n\n  /// Return true if all values in this range are negative.\n  bool isAllNegative() const;\n\n  /// Return true if all values in this range are non-negative.\n  bool isAllNonNegative() const;\n\n  /// Return the largest unsigned value contained in the ConstantRange.\n  APInt getUnsignedMax() const;\n\n  /// Return the smallest unsigned value contained in the ConstantRange.\n  APInt getUnsignedMin() const;\n\n  /// Return the largest signed value contained in the ConstantRange.\n  APInt getSignedMax() const;\n\n  /// Return the smallest signed value contained in the ConstantRange.\n  APInt getSignedMin() const;\n\n  /// Return true if this range is equal to another range.\n  bool operator==(const ConstantRange &CR) const {\n    return Lower == CR.Lower && Upper == CR.Upper;\n  }\n  bool operator!=(const ConstantRange &CR) const {\n    return !operator==(CR);\n  }\n\n  /// Compute the maximal number of active bits needed to represent every value\n  /// in this range.\n  unsigned getActiveBits() const;\n\n  /// Compute the maximal number of bits needed to represent every value\n  /// in this signed range.\n  unsigned getMinSignedBits() const;\n\n  /// Subtract the specified constant from the endpoints of this constant range.\n  ConstantRange subtract(const APInt &CI) const;\n\n  /// Subtract the specified range from this range (aka relative complement of\n  /// the sets).\n  ConstantRange difference(const ConstantRange &CR) const;\n\n  /// If represented precisely, the result of some range operations may consist\n  /// of multiple disjoint ranges. As only a single range may be returned, any\n  /// range covering these disjoint ranges constitutes a valid result, but some\n  /// may be more useful than others depending on context. The preferred range\n  /// type specifies whether a range that is non-wrapping in the unsigned or\n  /// signed domain, or has the smallest size, is preferred. If a signedness is\n  /// preferred but all ranges are non-wrapping or all wrapping, then the\n  /// smallest set size is preferred. If there are multiple smallest sets, any\n  /// one of them may be returned.\n  enum PreferredRangeType { Smallest, Unsigned, Signed };\n\n  /// Return the range that results from the intersection of this range with\n  /// another range. If the intersection is disjoint, such that two results\n  /// are possible, the preferred range is determined by the PreferredRangeType.\n  ConstantRange intersectWith(const ConstantRange &CR,\n                              PreferredRangeType Type = Smallest) const;\n\n  /// Return the range that results from the union of this range\n  /// with another range.  The resultant range is guaranteed to include the\n  /// elements of both sets, but may contain more.  For example, [3, 9) union\n  /// [12,15) is [3, 15), which includes 9, 10, and 11, which were not included\n  /// in either set before.\n  ConstantRange unionWith(const ConstantRange &CR,\n                          PreferredRangeType Type = Smallest) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an application of the specified cast operator to this range. \\p\n  /// BitWidth is the target bitwidth of the cast.  For casts which don't\n  /// change bitwidth, it must be the same as the source bitwidth.  For casts\n  /// which do change bitwidth, the bitwidth must be consistent with the\n  /// requested cast and source bitwidth.\n  ConstantRange castOp(Instruction::CastOps CastOp,\n                       uint32_t BitWidth) const;\n\n  /// Return a new range in the specified integer type, which must\n  /// be strictly larger than the current type.  The returned range will\n  /// correspond to the possible range of values if the source range had been\n  /// zero extended to BitWidth.\n  ConstantRange zeroExtend(uint32_t BitWidth) const;\n\n  /// Return a new range in the specified integer type, which must\n  /// be strictly larger than the current type.  The returned range will\n  /// correspond to the possible range of values if the source range had been\n  /// sign extended to BitWidth.\n  ConstantRange signExtend(uint32_t BitWidth) const;\n\n  /// Return a new range in the specified integer type, which must be\n  /// strictly smaller than the current type.  The returned range will\n  /// correspond to the possible range of values if the source range had been\n  /// truncated to the specified type.\n  ConstantRange truncate(uint32_t BitWidth) const;\n\n  /// Make this range have the bit width given by \\p BitWidth. The\n  /// value is zero extended, truncated, or left alone to make it that width.\n  ConstantRange zextOrTrunc(uint32_t BitWidth) const;\n\n  /// Make this range have the bit width given by \\p BitWidth. The\n  /// value is sign extended, truncated, or left alone to make it that width.\n  ConstantRange sextOrTrunc(uint32_t BitWidth) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an application of the specified binary operator to an left hand side\n  /// of this range and a right hand side of \\p Other.\n  ConstantRange binaryOp(Instruction::BinaryOps BinOp,\n                         const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an application of the specified overflowing binary operator to a\n  /// left hand side of this range and a right hand side of \\p Other given\n  /// the provided knowledge about lack of wrapping \\p NoWrapKind.\n  ConstantRange overflowingBinaryOp(Instruction::BinaryOps BinOp,\n                                    const ConstantRange &Other,\n                                    unsigned NoWrapKind) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an addition of a value in this range and a value in \\p Other.\n  ConstantRange add(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an addition with wrap type \\p NoWrapKind of a value in this\n  /// range and a value in \\p Other.\n  /// If the result range is disjoint, the preferred range is determined by the\n  /// \\p PreferredRangeType.\n  ConstantRange addWithNoWrap(const ConstantRange &Other, unsigned NoWrapKind,\n                              PreferredRangeType RangeType = Smallest) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a subtraction of a value in this range and a value in \\p Other.\n  ConstantRange sub(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an subtraction with wrap type \\p NoWrapKind of a value in this\n  /// range and a value in \\p Other.\n  /// If the result range is disjoint, the preferred range is determined by the\n  /// \\p PreferredRangeType.\n  ConstantRange subWithNoWrap(const ConstantRange &Other, unsigned NoWrapKind,\n                              PreferredRangeType RangeType = Smallest) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a multiplication of a value in this range and a value in \\p Other,\n  /// treating both this and \\p Other as unsigned ranges.\n  ConstantRange multiply(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a signed maximum of a value in this range and a value in \\p Other.\n  ConstantRange smax(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an unsigned maximum of a value in this range and a value in \\p Other.\n  ConstantRange umax(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a signed minimum of a value in this range and a value in \\p Other.\n  ConstantRange smin(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an unsigned minimum of a value in this range and a value in \\p Other.\n  ConstantRange umin(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an unsigned division of a value in this range and a value in\n  /// \\p Other.\n  ConstantRange udiv(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a signed division of a value in this range and a value in\n  /// \\p Other. Division by zero and division of SignedMin by -1 are considered\n  /// undefined behavior, in line with IR, and do not contribute towards the\n  /// result.\n  ConstantRange sdiv(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from an unsigned remainder operation of a value in this range and a\n  /// value in \\p Other.\n  ConstantRange urem(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a signed remainder operation of a value in this range and a\n  /// value in \\p Other.\n  ConstantRange srem(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting from\n  /// a binary-xor of a value in this range by an all-one value,\n  /// aka bitwise complement operation.\n  ConstantRange binaryNot() const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a binary-and of a value in this range by a value in \\p Other.\n  ConstantRange binaryAnd(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a binary-or of a value in this range by a value in \\p Other.\n  ConstantRange binaryOr(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a binary-xor of a value in this range by a value in \\p Other.\n  ConstantRange binaryXor(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting\n  /// from a left shift of a value in this range by a value in \\p Other.\n  /// TODO: This isn't fully implemented yet.\n  ConstantRange shl(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting from a\n  /// logical right shift of a value in this range and a value in \\p Other.\n  ConstantRange lshr(const ConstantRange &Other) const;\n\n  /// Return a new range representing the possible values resulting from a\n  /// arithmetic right shift of a value in this range and a value in \\p Other.\n  ConstantRange ashr(const ConstantRange &Other) const;\n\n  /// Perform an unsigned saturating addition of two constant ranges.\n  ConstantRange uadd_sat(const ConstantRange &Other) const;\n\n  /// Perform a signed saturating addition of two constant ranges.\n  ConstantRange sadd_sat(const ConstantRange &Other) const;\n\n  /// Perform an unsigned saturating subtraction of two constant ranges.\n  ConstantRange usub_sat(const ConstantRange &Other) const;\n\n  /// Perform a signed saturating subtraction of two constant ranges.\n  ConstantRange ssub_sat(const ConstantRange &Other) const;\n\n  /// Perform an unsigned saturating multiplication of two constant ranges.\n  ConstantRange umul_sat(const ConstantRange &Other) const;\n\n  /// Perform a signed saturating multiplication of two constant ranges.\n  ConstantRange smul_sat(const ConstantRange &Other) const;\n\n  /// Perform an unsigned saturating left shift of this constant range by a\n  /// value in \\p Other.\n  ConstantRange ushl_sat(const ConstantRange &Other) const;\n\n  /// Perform a signed saturating left shift of this constant range by a\n  /// value in \\p Other.\n  ConstantRange sshl_sat(const ConstantRange &Other) const;\n\n  /// Return a new range that is the logical not of the current set.\n  ConstantRange inverse() const;\n\n  /// Calculate absolute value range. If the original range contains signed\n  /// min, then the resulting range will contain signed min if and only if\n  /// \\p IntMinIsPoison is false.\n  ConstantRange abs(bool IntMinIsPoison = false) const;\n\n  /// Represents whether an operation on the given constant range is known to\n  /// always or never overflow.\n  enum class OverflowResult {\n    /// Always overflows in the direction of signed/unsigned min value.\n    AlwaysOverflowsLow,\n    /// Always overflows in the direction of signed/unsigned max value.\n    AlwaysOverflowsHigh,\n    /// May or may not overflow.\n    MayOverflow,\n    /// Never overflows.\n    NeverOverflows,\n  };\n\n  /// Return whether unsigned add of the two ranges always/never overflows.\n  OverflowResult unsignedAddMayOverflow(const ConstantRange &Other) const;\n\n  /// Return whether signed add of the two ranges always/never overflows.\n  OverflowResult signedAddMayOverflow(const ConstantRange &Other) const;\n\n  /// Return whether unsigned sub of the two ranges always/never overflows.\n  OverflowResult unsignedSubMayOverflow(const ConstantRange &Other) const;\n\n  /// Return whether signed sub of the two ranges always/never overflows.\n  OverflowResult signedSubMayOverflow(const ConstantRange &Other) const;\n\n  /// Return whether unsigned mul of the two ranges always/never overflows.\n  OverflowResult unsignedMulMayOverflow(const ConstantRange &Other) const;\n\n  /// Print out the bounds to a stream.\n  void print(raw_ostream &OS) const;\n\n  /// Allow printing from a debugger easily.\n  void dump() const;\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const ConstantRange &CR) {\n  CR.print(OS);\n  return OS;\n}\n\n/// Parse out a conservative ConstantRange from !range metadata.\n///\n/// E.g. if RangeMD is !{i32 0, i32 10, i32 15, i32 20} then return [0, 20).\nConstantRange getConstantRangeFromMetadata(const MDNode &RangeMD);\n\n} // end namespace llvm\n\n#endif // LLVM_IR_CONSTANTRANGE_H\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/InstrTypes.h", "content": "//===- llvm/InstrTypes.h - Important Instruction subclasses -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines various meta classes of instructions that exist in the VM\n// representation.  Specific concrete subclasses of these may be found in the\n// i*.h files...\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_INSTRTYPES_H\n#define LLVM_IR_INSTRTYPES_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/CallingConv.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/OperandTraits.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\nnamespace Intrinsic {\ntypedef unsigned ID;\n}\n\n//===----------------------------------------------------------------------===//\n//                          UnaryInstruction Class\n//===----------------------------------------------------------------------===//\n\nclass UnaryInstruction : public Instruction {\nprotected:\n  UnaryInstruction(Type *Ty, unsigned iType, Value *V,\n                   Instruction *IB = nullptr)\n    : Instruction(Ty, iType, &Op<0>(), 1, IB) {\n    Op<0>() = V;\n  }\n  UnaryInstruction(Type *Ty, unsigned iType, Value *V, BasicBlock *IAE)\n    : Instruction(Ty, iType, &Op<0>(), 1, IAE) {\n    Op<0>() = V;\n  }\n\npublic:\n  // allocate space for exactly one operand\n  void *operator new(size_t s) {\n    return User::operator new(s, 1);\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->isUnaryOp() ||\n           I->getOpcode() == Instruction::Alloca ||\n           I->getOpcode() == Instruction::Load ||\n           I->getOpcode() == Instruction::VAArg ||\n           I->getOpcode() == Instruction::ExtractValue ||\n           (I->getOpcode() >= CastOpsBegin && I->getOpcode() < CastOpsEnd);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<UnaryInstruction> :\n  public FixedNumOperandTraits<UnaryInstruction, 1> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(UnaryInstruction, Value)\n\n//===----------------------------------------------------------------------===//\n//                                UnaryOperator Class\n//===----------------------------------------------------------------------===//\n\nclass UnaryOperator : public UnaryInstruction {\n  void AssertOK();\n\nprotected:\n  UnaryOperator(UnaryOps iType, Value *S, Type *Ty,\n                const Twine &Name, Instruction *InsertBefore);\n  UnaryOperator(UnaryOps iType, Value *S, Type *Ty,\n                const Twine &Name, BasicBlock *InsertAtEnd);\n\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  UnaryOperator *cloneImpl() const;\n\npublic:\n\n  /// Construct a unary instruction, given the opcode and an operand.\n  /// Optionally (if InstBefore is specified) insert the instruction\n  /// into a BasicBlock right before the specified instruction.  The specified\n  /// Instruction is allowed to be a dereferenced end iterator.\n  ///\n  static UnaryOperator *Create(UnaryOps Op, Value *S,\n                               const Twine &Name = Twine(),\n                               Instruction *InsertBefore = nullptr);\n\n  /// Construct a unary instruction, given the opcode and an operand.\n  /// Also automatically insert this instruction to the end of the\n  /// BasicBlock specified.\n  ///\n  static UnaryOperator *Create(UnaryOps Op, Value *S,\n                               const Twine &Name,\n                               BasicBlock *InsertAtEnd);\n\n  /// These methods just forward to Create, and are useful when you\n  /// statically know what type of instruction you're going to create.  These\n  /// helpers just save some typing.\n#define HANDLE_UNARY_INST(N, OPC, CLASS) \\\n  static UnaryOperator *Create##OPC(Value *V, const Twine &Name = \"\") {\\\n    return Create(Instruction::OPC, V, Name);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n#define HANDLE_UNARY_INST(N, OPC, CLASS) \\\n  static UnaryOperator *Create##OPC(Value *V, const Twine &Name, \\\n                                    BasicBlock *BB) {\\\n    return Create(Instruction::OPC, V, Name, BB);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n#define HANDLE_UNARY_INST(N, OPC, CLASS) \\\n  static UnaryOperator *Create##OPC(Value *V, const Twine &Name, \\\n                                    Instruction *I) {\\\n    return Create(Instruction::OPC, V, Name, I);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n\n  static UnaryOperator *\n  CreateWithCopiedFlags(UnaryOps Opc, Value *V, Instruction *CopyO,\n                        const Twine &Name = \"\",\n                        Instruction *InsertBefore = nullptr) {\n    UnaryOperator *UO = Create(Opc, V, Name, InsertBefore);\n    UO->copyIRFlags(CopyO);\n    return UO;\n  }\n\n  static UnaryOperator *CreateFNegFMF(Value *Op, Instruction *FMFSource,\n                                      const Twine &Name = \"\",\n                                      Instruction *InsertBefore = nullptr) {\n    return CreateWithCopiedFlags(Instruction::FNeg, Op, FMFSource, Name,\n                                 InsertBefore);\n  }\n\n  UnaryOps getOpcode() const {\n    return static_cast<UnaryOps>(Instruction::getOpcode());\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->isUnaryOp();\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                           BinaryOperator Class\n//===----------------------------------------------------------------------===//\n\nclass BinaryOperator : public Instruction {\n  void AssertOK();\n\nprotected:\n  BinaryOperator(BinaryOps iType, Value *S1, Value *S2, Type *Ty,\n                 const Twine &Name, Instruction *InsertBefore);\n  BinaryOperator(BinaryOps iType, Value *S1, Value *S2, Type *Ty,\n                 const Twine &Name, BasicBlock *InsertAtEnd);\n\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  BinaryOperator *cloneImpl() const;\n\npublic:\n  // allocate space for exactly two operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 2);\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Construct a binary instruction, given the opcode and the two\n  /// operands.  Optionally (if InstBefore is specified) insert the instruction\n  /// into a BasicBlock right before the specified instruction.  The specified\n  /// Instruction is allowed to be a dereferenced end iterator.\n  ///\n  static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2,\n                                const Twine &Name = Twine(),\n                                Instruction *InsertBefore = nullptr);\n\n  /// Construct a binary instruction, given the opcode and the two\n  /// operands.  Also automatically insert this instruction to the end of the\n  /// BasicBlock specified.\n  ///\n  static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2,\n                                const Twine &Name, BasicBlock *InsertAtEnd);\n\n  /// These methods just forward to Create, and are useful when you\n  /// statically know what type of instruction you're going to create.  These\n  /// helpers just save some typing.\n#define HANDLE_BINARY_INST(N, OPC, CLASS) \\\n  static BinaryOperator *Create##OPC(Value *V1, Value *V2, \\\n                                     const Twine &Name = \"\") {\\\n    return Create(Instruction::OPC, V1, V2, Name);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n#define HANDLE_BINARY_INST(N, OPC, CLASS) \\\n  static BinaryOperator *Create##OPC(Value *V1, Value *V2, \\\n                                     const Twine &Name, BasicBlock *BB) {\\\n    return Create(Instruction::OPC, V1, V2, Name, BB);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n#define HANDLE_BINARY_INST(N, OPC, CLASS) \\\n  static BinaryOperator *Create##OPC(Value *V1, Value *V2, \\\n                                     const Twine &Name, Instruction *I) {\\\n    return Create(Instruction::OPC, V1, V2, Name, I);\\\n  }\n#include \"llvm/IR/Instruction.def\"\n\n  static BinaryOperator *CreateWithCopiedFlags(BinaryOps Opc,\n                                               Value *V1, Value *V2,\n                                               Instruction *CopyO,\n                                               const Twine &Name = \"\") {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name);\n    BO->copyIRFlags(CopyO);\n    return BO;\n  }\n\n  static BinaryOperator *CreateFAddFMF(Value *V1, Value *V2,\n                                       Instruction *FMFSource,\n                                       const Twine &Name = \"\") {\n    return CreateWithCopiedFlags(Instruction::FAdd, V1, V2, FMFSource, Name);\n  }\n  static BinaryOperator *CreateFSubFMF(Value *V1, Value *V2,\n                                       Instruction *FMFSource,\n                                       const Twine &Name = \"\") {\n    return CreateWithCopiedFlags(Instruction::FSub, V1, V2, FMFSource, Name);\n  }\n  static BinaryOperator *CreateFMulFMF(Value *V1, Value *V2,\n                                       Instruction *FMFSource,\n                                       const Twine &Name = \"\") {\n    return CreateWithCopiedFlags(Instruction::FMul, V1, V2, FMFSource, Name);\n  }\n  static BinaryOperator *CreateFDivFMF(Value *V1, Value *V2,\n                                       Instruction *FMFSource,\n                                       const Twine &Name = \"\") {\n    return CreateWithCopiedFlags(Instruction::FDiv, V1, V2, FMFSource, Name);\n  }\n  static BinaryOperator *CreateFRemFMF(Value *V1, Value *V2,\n                                       Instruction *FMFSource,\n                                       const Twine &Name = \"\") {\n    return CreateWithCopiedFlags(Instruction::FRem, V1, V2, FMFSource, Name);\n  }\n\n  static BinaryOperator *CreateNSW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name = \"\") {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name);\n    BO->setHasNoSignedWrap(true);\n    return BO;\n  }\n  static BinaryOperator *CreateNSW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name, BasicBlock *BB) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, BB);\n    BO->setHasNoSignedWrap(true);\n    return BO;\n  }\n  static BinaryOperator *CreateNSW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name, Instruction *I) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, I);\n    BO->setHasNoSignedWrap(true);\n    return BO;\n  }\n\n  static BinaryOperator *CreateNUW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name = \"\") {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name);\n    BO->setHasNoUnsignedWrap(true);\n    return BO;\n  }\n  static BinaryOperator *CreateNUW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name, BasicBlock *BB) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, BB);\n    BO->setHasNoUnsignedWrap(true);\n    return BO;\n  }\n  static BinaryOperator *CreateNUW(BinaryOps Opc, Value *V1, Value *V2,\n                                   const Twine &Name, Instruction *I) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, I);\n    BO->setHasNoUnsignedWrap(true);\n    return BO;\n  }\n\n  static BinaryOperator *CreateExact(BinaryOps Opc, Value *V1, Value *V2,\n                                     const Twine &Name = \"\") {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name);\n    BO->setIsExact(true);\n    return BO;\n  }\n  static BinaryOperator *CreateExact(BinaryOps Opc, Value *V1, Value *V2,\n                                     const Twine &Name, BasicBlock *BB) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, BB);\n    BO->setIsExact(true);\n    return BO;\n  }\n  static BinaryOperator *CreateExact(BinaryOps Opc, Value *V1, Value *V2,\n                                     const Twine &Name, Instruction *I) {\n    BinaryOperator *BO = Create(Opc, V1, V2, Name, I);\n    BO->setIsExact(true);\n    return BO;\n  }\n\n#define DEFINE_HELPERS(OPC, NUWNSWEXACT)                                       \\\n  static BinaryOperator *Create##NUWNSWEXACT##OPC(Value *V1, Value *V2,        \\\n                                                  const Twine &Name = \"\") {    \\\n    return Create##NUWNSWEXACT(Instruction::OPC, V1, V2, Name);                \\\n  }                                                                            \\\n  static BinaryOperator *Create##NUWNSWEXACT##OPC(                             \\\n      Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) {               \\\n    return Create##NUWNSWEXACT(Instruction::OPC, V1, V2, Name, BB);            \\\n  }                                                                            \\\n  static BinaryOperator *Create##NUWNSWEXACT##OPC(                             \\\n      Value *V1, Value *V2, const Twine &Name, Instruction *I) {               \\\n    return Create##NUWNSWEXACT(Instruction::OPC, V1, V2, Name, I);             \\\n  }\n\n  DEFINE_HELPERS(Add, NSW) // CreateNSWAdd\n  DEFINE_HELPERS(Add, NUW) // CreateNUWAdd\n  DEFINE_HELPERS(Sub, NSW) // CreateNSWSub\n  DEFINE_HELPERS(Sub, NUW) // CreateNUWSub\n  DEFINE_HELPERS(Mul, NSW) // CreateNSWMul\n  DEFINE_HELPERS(Mul, NUW) // CreateNUWMul\n  DEFINE_HELPERS(Shl, NSW) // CreateNSWShl\n  DEFINE_HELPERS(Shl, NUW) // CreateNUWShl\n\n  DEFINE_HELPERS(SDiv, Exact)  // CreateExactSDiv\n  DEFINE_HELPERS(UDiv, Exact)  // CreateExactUDiv\n  DEFINE_HELPERS(AShr, Exact)  // CreateExactAShr\n  DEFINE_HELPERS(LShr, Exact)  // CreateExactLShr\n\n#undef DEFINE_HELPERS\n\n  /// Helper functions to construct and inspect unary operations (NEG and NOT)\n  /// via binary operators SUB and XOR:\n  ///\n  /// Create the NEG and NOT instructions out of SUB and XOR instructions.\n  ///\n  static BinaryOperator *CreateNeg(Value *Op, const Twine &Name = \"\",\n                                   Instruction *InsertBefore = nullptr);\n  static BinaryOperator *CreateNeg(Value *Op, const Twine &Name,\n                                   BasicBlock *InsertAtEnd);\n  static BinaryOperator *CreateNSWNeg(Value *Op, const Twine &Name = \"\",\n                                      Instruction *InsertBefore = nullptr);\n  static BinaryOperator *CreateNSWNeg(Value *Op, const Twine &Name,\n                                      BasicBlock *InsertAtEnd);\n  static BinaryOperator *CreateNUWNeg(Value *Op, const Twine &Name = \"\",\n                                      Instruction *InsertBefore = nullptr);\n  static BinaryOperator *CreateNUWNeg(Value *Op, const Twine &Name,\n                                      BasicBlock *InsertAtEnd);\n  static BinaryOperator *CreateNot(Value *Op, const Twine &Name = \"\",\n                                   Instruction *InsertBefore = nullptr);\n  static BinaryOperator *CreateNot(Value *Op, const Twine &Name,\n                                   BasicBlock *InsertAtEnd);\n\n  BinaryOps getOpcode() const {\n    return static_cast<BinaryOps>(Instruction::getOpcode());\n  }\n\n  /// Exchange the two operands to this instruction.\n  /// This instruction is safe to use on any binary instruction and\n  /// does not modify the semantics of the instruction.  If the instruction\n  /// cannot be reversed (ie, it's a Div), then return true.\n  ///\n  bool swapOperands();\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->isBinaryOp();\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<BinaryOperator> :\n  public FixedNumOperandTraits<BinaryOperator, 2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(BinaryOperator, Value)\n\n//===----------------------------------------------------------------------===//\n//                               CastInst Class\n//===----------------------------------------------------------------------===//\n\n/// This is the base class for all instructions that perform data\n/// casts. It is simply provided so that instruction category testing\n/// can be performed with code like:\n///\n/// if (isa<CastInst>(Instr)) { ... }\n/// Base class of casting instructions.\nclass CastInst : public UnaryInstruction {\nprotected:\n  /// Constructor with insert-before-instruction semantics for subclasses\n  CastInst(Type *Ty, unsigned iType, Value *S,\n           const Twine &NameStr = \"\", Instruction *InsertBefore = nullptr)\n    : UnaryInstruction(Ty, iType, S, InsertBefore) {\n    setName(NameStr);\n  }\n  /// Constructor with insert-at-end-of-block semantics for subclasses\n  CastInst(Type *Ty, unsigned iType, Value *S,\n           const Twine &NameStr, BasicBlock *InsertAtEnd)\n    : UnaryInstruction(Ty, iType, S, InsertAtEnd) {\n    setName(NameStr);\n  }\n\npublic:\n  /// Provides a way to construct any of the CastInst subclasses using an\n  /// opcode instead of the subclass's constructor. The opcode must be in the\n  /// CastOps category (Instruction::isCast(opcode) returns true). This\n  /// constructor has insert-before-instruction semantics to automatically\n  /// insert the new CastInst before InsertBefore (if it is non-null).\n  /// Construct any of the CastInst subclasses\n  static CastInst *Create(\n    Instruction::CastOps,    ///< The opcode of the cast instruction\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n  /// Provides a way to construct any of the CastInst subclasses using an\n  /// opcode instead of the subclass's constructor. The opcode must be in the\n  /// CastOps category. This constructor has insert-at-end-of-block semantics\n  /// to automatically insert the new CastInst at the end of InsertAtEnd (if\n  /// its non-null).\n  /// Construct any of the CastInst subclasses\n  static CastInst *Create(\n    Instruction::CastOps,    ///< The opcode for the cast instruction\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a ZExt or BitCast cast instruction\n  static CastInst *CreateZExtOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a ZExt or BitCast cast instruction\n  static CastInst *CreateZExtOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a SExt or BitCast cast instruction\n  static CastInst *CreateSExtOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a SExt or BitCast cast instruction\n  static CastInst *CreateSExtOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a BitCast AddrSpaceCast, or a PtrToInt cast instruction.\n  static CastInst *CreatePointerCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a BitCast, AddrSpaceCast or a PtrToInt cast instruction.\n  static CastInst *CreatePointerCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a BitCast or an AddrSpaceCast cast instruction.\n  static CastInst *CreatePointerBitCastOrAddrSpaceCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a BitCast or an AddrSpaceCast cast instruction.\n  static CastInst *CreatePointerBitCastOrAddrSpaceCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a BitCast, a PtrToInt, or an IntToPTr cast instruction.\n  ///\n  /// If the value is a pointer type and the destination an integer type,\n  /// creates a PtrToInt cast. If the value is an integer type and the\n  /// destination a pointer type, creates an IntToPtr cast. Otherwise, creates\n  /// a bitcast.\n  static CastInst *CreateBitOrPointerCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a ZExt, BitCast, or Trunc for int -> int casts.\n  static CastInst *CreateIntegerCast(\n    Value *S,                ///< The pointer value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    bool isSigned,           ///< Whether to regard S as signed or not\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a ZExt, BitCast, or Trunc for int -> int casts.\n  static CastInst *CreateIntegerCast(\n    Value *S,                ///< The integer value to be casted (operand 0)\n    Type *Ty,          ///< The integer type to which operand is casted\n    bool isSigned,           ///< Whether to regard S as signed or not\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create an FPExt, BitCast, or FPTrunc for fp -> fp casts\n  static CastInst *CreateFPCast(\n    Value *S,                ///< The floating point value to be casted\n    Type *Ty,          ///< The floating point type to cast to\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create an FPExt, BitCast, or FPTrunc for fp -> fp casts\n  static CastInst *CreateFPCast(\n    Value *S,                ///< The floating point value to be casted\n    Type *Ty,          ///< The floating point type to cast to\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Create a Trunc or BitCast cast instruction\n  static CastInst *CreateTruncOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which cast should be made\n    const Twine &Name = \"\", ///< Name for the instruction\n    Instruction *InsertBefore = nullptr ///< Place to insert the instruction\n  );\n\n  /// Create a Trunc or BitCast cast instruction\n  static CastInst *CreateTruncOrBitCast(\n    Value *S,                ///< The value to be casted (operand 0)\n    Type *Ty,          ///< The type to which operand is casted\n    const Twine &Name, ///< The name for the instruction\n    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into\n  );\n\n  /// Check whether a bitcast between these types is valid\n  static bool isBitCastable(\n    Type *SrcTy, ///< The Type from which the value should be cast.\n    Type *DestTy ///< The Type to which the value should be cast.\n  );\n\n  /// Check whether a bitcast, inttoptr, or ptrtoint cast between these\n  /// types is valid and a no-op.\n  ///\n  /// This ensures that any pointer<->integer cast has enough bits in the\n  /// integer and any other cast is a bitcast.\n  static bool isBitOrNoopPointerCastable(\n      Type *SrcTy,  ///< The Type from which the value should be cast.\n      Type *DestTy, ///< The Type to which the value should be cast.\n      const DataLayout &DL);\n\n  /// Returns the opcode necessary to cast Val into Ty using usual casting\n  /// rules.\n  /// Infer the opcode for cast operand and type\n  static Instruction::CastOps getCastOpcode(\n    const Value *Val, ///< The value to cast\n    bool SrcIsSigned, ///< Whether to treat the source as signed\n    Type *Ty,   ///< The Type to which the value should be casted\n    bool DstIsSigned  ///< Whether to treate the dest. as signed\n  );\n\n  /// There are several places where we need to know if a cast instruction\n  /// only deals with integer source and destination types. To simplify that\n  /// logic, this method is provided.\n  /// @returns true iff the cast has only integral typed operand and dest type.\n  /// Determine if this is an integer-only cast.\n  bool isIntegerCast() const;\n\n  /// A lossless cast is one that does not alter the basic value. It implies\n  /// a no-op cast but is more stringent, preventing things like int->float,\n  /// long->double, or int->ptr.\n  /// @returns true iff the cast is lossless.\n  /// Determine if this is a lossless cast.\n  bool isLosslessCast() const;\n\n  /// A no-op cast is one that can be effected without changing any bits.\n  /// It implies that the source and destination types are the same size. The\n  /// DataLayout argument is to determine the pointer size when examining casts\n  /// involving Integer and Pointer types. They are no-op casts if the integer\n  /// is the same size as the pointer. However, pointer size varies with\n  /// platform.  Note that a precondition of this method is that the cast is\n  /// legal - i.e. the instruction formed with these operands would verify.\n  static bool isNoopCast(\n    Instruction::CastOps Opcode, ///< Opcode of cast\n    Type *SrcTy,         ///< SrcTy of cast\n    Type *DstTy,         ///< DstTy of cast\n    const DataLayout &DL ///< DataLayout to get the Int Ptr type from.\n  );\n\n  /// Determine if this cast is a no-op cast.\n  ///\n  /// \\param DL is the DataLayout to determine pointer size.\n  bool isNoopCast(const DataLayout &DL) const;\n\n  /// Determine how a pair of casts can be eliminated, if they can be at all.\n  /// This is a helper function for both CastInst and ConstantExpr.\n  /// @returns 0 if the CastInst pair can't be eliminated, otherwise\n  /// returns Instruction::CastOps value for a cast that can replace\n  /// the pair, casting SrcTy to DstTy.\n  /// Determine if a cast pair is eliminable\n  static unsigned isEliminableCastPair(\n    Instruction::CastOps firstOpcode,  ///< Opcode of first cast\n    Instruction::CastOps secondOpcode, ///< Opcode of second cast\n    Type *SrcTy, ///< SrcTy of 1st cast\n    Type *MidTy, ///< DstTy of 1st cast & SrcTy of 2nd cast\n    Type *DstTy, ///< DstTy of 2nd cast\n    Type *SrcIntPtrTy, ///< Integer type corresponding to Ptr SrcTy, or null\n    Type *MidIntPtrTy, ///< Integer type corresponding to Ptr MidTy, or null\n    Type *DstIntPtrTy  ///< Integer type corresponding to Ptr DstTy, or null\n  );\n\n  /// Return the opcode of this CastInst\n  Instruction::CastOps getOpcode() const {\n    return Instruction::CastOps(Instruction::getOpcode());\n  }\n\n  /// Return the source type, as a convenience\n  Type* getSrcTy() const { return getOperand(0)->getType(); }\n  /// Return the destination type, as a convenience\n  Type* getDestTy() const { return getType(); }\n\n  /// This method can be used to determine if a cast from SrcTy to DstTy using\n  /// Opcode op is valid or not.\n  /// @returns true iff the proposed cast is valid.\n  /// Determine if a cast is valid without creating one.\n  static bool castIsValid(Instruction::CastOps op, Type *SrcTy, Type *DstTy);\n  static bool castIsValid(Instruction::CastOps op, Value *S, Type *DstTy) {\n    return castIsValid(op, S->getType(), DstTy);\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->isCast();\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                               CmpInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class is the base class for the comparison instructions.\n/// Abstract base class of comparison instructions.\nclass CmpInst : public Instruction {\npublic:\n  /// This enumeration lists the possible predicates for CmpInst subclasses.\n  /// Values in the range 0-31 are reserved for FCmpInst, while values in the\n  /// range 32-64 are reserved for ICmpInst. This is necessary to ensure the\n  /// predicate values are not overlapping between the classes.\n  ///\n  /// Some passes (e.g. InstCombine) depend on the bit-wise characteristics of\n  /// FCMP_* values. Changing the bit patterns requires a potential change to\n  /// those passes.\n  enum Predicate : unsigned {\n    // Opcode            U L G E    Intuitive operation\n    FCMP_FALSE = 0, ///< 0 0 0 0    Always false (always folded)\n    FCMP_OEQ = 1,   ///< 0 0 0 1    True if ordered and equal\n    FCMP_OGT = 2,   ///< 0 0 1 0    True if ordered and greater than\n    FCMP_OGE = 3,   ///< 0 0 1 1    True if ordered and greater than or equal\n    FCMP_OLT = 4,   ///< 0 1 0 0    True if ordered and less than\n    FCMP_OLE = 5,   ///< 0 1 0 1    True if ordered and less than or equal\n    FCMP_ONE = 6,   ///< 0 1 1 0    True if ordered and operands are unequal\n    FCMP_ORD = 7,   ///< 0 1 1 1    True if ordered (no nans)\n    FCMP_UNO = 8,   ///< 1 0 0 0    True if unordered: isnan(X) | isnan(Y)\n    FCMP_UEQ = 9,   ///< 1 0 0 1    True if unordered or equal\n    FCMP_UGT = 10,  ///< 1 0 1 0    True if unordered or greater than\n    FCMP_UGE = 11,  ///< 1 0 1 1    True if unordered, greater than, or equal\n    FCMP_ULT = 12,  ///< 1 1 0 0    True if unordered or less than\n    FCMP_ULE = 13,  ///< 1 1 0 1    True if unordered, less than, or equal\n    FCMP_UNE = 14,  ///< 1 1 1 0    True if unordered or not equal\n    FCMP_TRUE = 15, ///< 1 1 1 1    Always true (always folded)\n    FIRST_FCMP_PREDICATE = FCMP_FALSE,\n    LAST_FCMP_PREDICATE = FCMP_TRUE,\n    BAD_FCMP_PREDICATE = FCMP_TRUE + 1,\n    ICMP_EQ = 32,  ///< equal\n    ICMP_NE = 33,  ///< not equal\n    ICMP_UGT = 34, ///< unsigned greater than\n    ICMP_UGE = 35, ///< unsigned greater or equal\n    ICMP_ULT = 36, ///< unsigned less than\n    ICMP_ULE = 37, ///< unsigned less or equal\n    ICMP_SGT = 38, ///< signed greater than\n    ICMP_SGE = 39, ///< signed greater or equal\n    ICMP_SLT = 40, ///< signed less than\n    ICMP_SLE = 41, ///< signed less or equal\n    FIRST_ICMP_PREDICATE = ICMP_EQ,\n    LAST_ICMP_PREDICATE = ICMP_SLE,\n    BAD_ICMP_PREDICATE = ICMP_SLE + 1\n  };\n  using PredicateField =\n      Bitfield::Element<Predicate, 0, 6, LAST_ICMP_PREDICATE>;\n\nprotected:\n  CmpInst(Type *ty, Instruction::OtherOps op, Predicate pred,\n          Value *LHS, Value *RHS, const Twine &Name = \"\",\n          Instruction *InsertBefore = nullptr,\n          Instruction *FlagsSource = nullptr);\n\n  CmpInst(Type *ty, Instruction::OtherOps op, Predicate pred,\n          Value *LHS, Value *RHS, const Twine &Name,\n          BasicBlock *InsertAtEnd);\n\npublic:\n  // allocate space for exactly two operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 2);\n  }\n\n  /// Construct a compare instruction, given the opcode, the predicate and\n  /// the two operands.  Optionally (if InstBefore is specified) insert the\n  /// instruction into a BasicBlock right before the specified instruction.\n  /// The specified Instruction is allowed to be a dereferenced end iterator.\n  /// Create a CmpInst\n  static CmpInst *Create(OtherOps Op,\n                         Predicate predicate, Value *S1,\n                         Value *S2, const Twine &Name = \"\",\n                         Instruction *InsertBefore = nullptr);\n\n  /// Construct a compare instruction, given the opcode, the predicate and the\n  /// two operands.  Also automatically insert this instruction to the end of\n  /// the BasicBlock specified.\n  /// Create a CmpInst\n  static CmpInst *Create(OtherOps Op, Predicate predicate, Value *S1,\n                         Value *S2, const Twine &Name, BasicBlock *InsertAtEnd);\n\n  /// Get the opcode casted to the right type\n  OtherOps getOpcode() const {\n    return static_cast<OtherOps>(Instruction::getOpcode());\n  }\n\n  /// Return the predicate for this instruction.\n  Predicate getPredicate() const { return getSubclassData<PredicateField>(); }\n\n  /// Set the predicate for this instruction to the specified value.\n  void setPredicate(Predicate P) { setSubclassData<PredicateField>(P); }\n\n  static bool isFPPredicate(Predicate P) {\n    static_assert(FIRST_FCMP_PREDICATE == 0,\n                  \"FIRST_FCMP_PREDICATE is required to be 0\");\n    return P <= LAST_FCMP_PREDICATE;\n  }\n\n  static bool isIntPredicate(Predicate P) {\n    return P >= FIRST_ICMP_PREDICATE && P <= LAST_ICMP_PREDICATE;\n  }\n\n  static StringRef getPredicateName(Predicate P);\n\n  bool isFPPredicate() const { return isFPPredicate(getPredicate()); }\n  bool isIntPredicate() const { return isIntPredicate(getPredicate()); }\n\n  /// For example, EQ -> NE, UGT -> ULE, SLT -> SGE,\n  ///              OEQ -> UNE, UGT -> OLE, OLT -> UGE, etc.\n  /// @returns the inverse predicate for the instruction's current predicate.\n  /// Return the inverse of the instruction's predicate.\n  Predicate getInversePredicate() const {\n    return getInversePredicate(getPredicate());\n  }\n\n  /// For example, EQ -> NE, UGT -> ULE, SLT -> SGE,\n  ///              OEQ -> UNE, UGT -> OLE, OLT -> UGE, etc.\n  /// @returns the inverse predicate for predicate provided in \\p pred.\n  /// Return the inverse of a given predicate\n  static Predicate getInversePredicate(Predicate pred);\n\n  /// For example, EQ->EQ, SLE->SGE, ULT->UGT,\n  ///              OEQ->OEQ, ULE->UGE, OLT->OGT, etc.\n  /// @returns the predicate that would be the result of exchanging the two\n  /// operands of the CmpInst instruction without changing the result\n  /// produced.\n  /// Return the predicate as if the operands were swapped\n  Predicate getSwappedPredicate() const {\n    return getSwappedPredicate(getPredicate());\n  }\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// Return the predicate as if the operands were swapped.\n  static Predicate getSwappedPredicate(Predicate pred);\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// @returns true if the comparison predicate is strict, false otherwise.\n  static bool isStrictPredicate(Predicate predicate);\n\n  /// @returns true if the comparison predicate is strict, false otherwise.\n  /// Determine if this instruction is using an strict comparison predicate.\n  bool isStrictPredicate() const { return isStrictPredicate(getPredicate()); }\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// @returns true if the comparison predicate is non-strict, false otherwise.\n  static bool isNonStrictPredicate(Predicate predicate);\n\n  /// @returns true if the comparison predicate is non-strict, false otherwise.\n  /// Determine if this instruction is using an non-strict comparison predicate.\n  bool isNonStrictPredicate() const {\n    return isNonStrictPredicate(getPredicate());\n  }\n\n  /// For example, SGE -> SGT, SLE -> SLT, ULE -> ULT, UGE -> UGT.\n  /// Returns the strict version of non-strict comparisons.\n  Predicate getStrictPredicate() const {\n    return getStrictPredicate(getPredicate());\n  }\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// @returns the strict version of comparison provided in \\p pred.\n  /// If \\p pred is not a strict comparison predicate, returns \\p pred.\n  /// Returns the strict version of non-strict comparisons.\n  static Predicate getStrictPredicate(Predicate pred);\n\n  /// For example, SGT -> SGE, SLT -> SLE, ULT -> ULE, UGT -> UGE.\n  /// Returns the non-strict version of strict comparisons.\n  Predicate getNonStrictPredicate() const {\n    return getNonStrictPredicate(getPredicate());\n  }\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// @returns the non-strict version of comparison provided in \\p pred.\n  /// If \\p pred is not a strict comparison predicate, returns \\p pred.\n  /// Returns the non-strict version of strict comparisons.\n  static Predicate getNonStrictPredicate(Predicate pred);\n\n  /// This is a static version that you can use without an instruction\n  /// available.\n  /// Return the flipped strictness of predicate\n  static Predicate getFlippedStrictnessPredicate(Predicate pred);\n\n  /// For predicate of kind \"is X or equal to 0\" returns the predicate \"is X\".\n  /// For predicate of kind \"is X\" returns the predicate \"is X or equal to 0\".\n  /// does not support other kind of predicates.\n  /// @returns the predicate that does not contains is equal to zero if\n  /// it had and vice versa.\n  /// Return the flipped strictness of predicate\n  Predicate getFlippedStrictnessPredicate() const {\n    return getFlippedStrictnessPredicate(getPredicate());\n  }\n\n  /// Provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// This is just a convenience that dispatches to the subclasses.\n  /// Swap the operands and adjust predicate accordingly to retain\n  /// the same comparison.\n  void swapOperands();\n\n  /// This is just a convenience that dispatches to the subclasses.\n  /// Determine if this CmpInst is commutative.\n  bool isCommutative() const;\n\n  /// Determine if this is an equals/not equals predicate.\n  /// This is a static version that you can use without an instruction\n  /// available.\n  static bool isEquality(Predicate pred);\n\n  /// Determine if this is an equals/not equals predicate.\n  bool isEquality() const { return isEquality(getPredicate()); }\n\n  /// Return true if the predicate is relational (not EQ or NE).\n  static bool isRelational(Predicate P) { return !isEquality(P); }\n\n  /// Return true if the predicate is relational (not EQ or NE).\n  bool isRelational() const { return !isEquality(); }\n\n  /// @returns true if the comparison is signed, false otherwise.\n  /// Determine if this instruction is using a signed comparison.\n  bool isSigned() const {\n    return isSigned(getPredicate());\n  }\n\n  /// @returns true if the comparison is unsigned, false otherwise.\n  /// Determine if this instruction is using an unsigned comparison.\n  bool isUnsigned() const {\n    return isUnsigned(getPredicate());\n  }\n\n  /// For example, ULT->SLT, ULE->SLE, UGT->SGT, UGE->SGE, SLT->Failed assert\n  /// @returns the signed version of the unsigned predicate pred.\n  /// return the signed version of a predicate\n  static Predicate getSignedPredicate(Predicate pred);\n\n  /// For example, ULT->SLT, ULE->SLE, UGT->SGT, UGE->SGE, SLT->Failed assert\n  /// @returns the signed version of the predicate for this instruction (which\n  /// has to be an unsigned predicate).\n  /// return the signed version of a predicate\n  Predicate getSignedPredicate() {\n    return getSignedPredicate(getPredicate());\n  }\n\n  /// For example, SLT->ULT, SLE->ULE, SGT->UGT, SGE->UGE, ULT->Failed assert\n  /// @returns the unsigned version of the signed predicate pred.\n  static Predicate getUnsignedPredicate(Predicate pred);\n\n  /// For example, SLT->ULT, SLE->ULE, SGT->UGT, SGE->UGE, ULT->Failed assert\n  /// @returns the unsigned version of the predicate for this instruction (which\n  /// has to be an signed predicate).\n  /// return the unsigned version of a predicate\n  Predicate getUnsignedPredicate() {\n    return getUnsignedPredicate(getPredicate());\n  }\n\n  /// For example, SLT->ULT, ULT->SLT, SLE->ULE, ULE->SLE, EQ->Failed assert\n  /// @returns the unsigned version of the signed predicate pred or\n  ///          the signed version of the signed predicate pred.\n  static Predicate getFlippedSignednessPredicate(Predicate pred);\n\n  /// For example, SLT->ULT, ULT->SLT, SLE->ULE, ULE->SLE, EQ->Failed assert\n  /// @returns the unsigned version of the signed predicate pred or\n  ///          the signed version of the signed predicate pred.\n  Predicate getFlippedSignednessPredicate() {\n    return getFlippedSignednessPredicate(getPredicate());\n  }\n\n  /// This is just a convenience.\n  /// Determine if this is true when both operands are the same.\n  bool isTrueWhenEqual() const {\n    return isTrueWhenEqual(getPredicate());\n  }\n\n  /// This is just a convenience.\n  /// Determine if this is false when both operands are the same.\n  bool isFalseWhenEqual() const {\n    return isFalseWhenEqual(getPredicate());\n  }\n\n  /// @returns true if the predicate is unsigned, false otherwise.\n  /// Determine if the predicate is an unsigned operation.\n  static bool isUnsigned(Predicate predicate);\n\n  /// @returns true if the predicate is signed, false otherwise.\n  /// Determine if the predicate is an signed operation.\n  static bool isSigned(Predicate predicate);\n\n  /// Determine if the predicate is an ordered operation.\n  static bool isOrdered(Predicate predicate);\n\n  /// Determine if the predicate is an unordered operation.\n  static bool isUnordered(Predicate predicate);\n\n  /// Determine if the predicate is true when comparing a value with itself.\n  static bool isTrueWhenEqual(Predicate predicate);\n\n  /// Determine if the predicate is false when comparing a value with itself.\n  static bool isFalseWhenEqual(Predicate predicate);\n\n  /// Determine if Pred1 implies Pred2 is true when two compares have matching\n  /// operands.\n  static bool isImpliedTrueByMatchingCmp(Predicate Pred1, Predicate Pred2);\n\n  /// Determine if Pred1 implies Pred2 is false when two compares have matching\n  /// operands.\n  static bool isImpliedFalseByMatchingCmp(Predicate Pred1, Predicate Pred2);\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::ICmp ||\n           I->getOpcode() == Instruction::FCmp;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\n  /// Create a result type for fcmp/icmp\n  static Type* makeCmpResultType(Type* opnd_type) {\n    if (VectorType* vt = dyn_cast<VectorType>(opnd_type)) {\n      return VectorType::get(Type::getInt1Ty(opnd_type->getContext()),\n                             vt->getElementCount());\n    }\n    return Type::getInt1Ty(opnd_type->getContext());\n  }\n\nprivate:\n  // Shadow Value::setValueSubclassData with a private forwarding method so that\n  // subclasses cannot accidentally use it.\n  void setValueSubclassData(unsigned short D) {\n    Value::setValueSubclassData(D);\n  }\n};\n\n// FIXME: these are redundant if CmpInst < BinaryOperator\ntemplate <>\nstruct OperandTraits<CmpInst> : public FixedNumOperandTraits<CmpInst, 2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(CmpInst, Value)\n\n/// A lightweight accessor for an operand bundle meant to be passed\n/// around by value.\nstruct OperandBundleUse {\n  ArrayRef<Use> Inputs;\n\n  OperandBundleUse() = default;\n  explicit OperandBundleUse(StringMapEntry<uint32_t> *Tag, ArrayRef<Use> Inputs)\n      : Inputs(Inputs), Tag(Tag) {}\n\n  /// Return true if the operand at index \\p Idx in this operand bundle\n  /// has the attribute A.\n  bool operandHasAttr(unsigned Idx, Attribute::AttrKind A) const {\n    if (isDeoptOperandBundle())\n      if (A == Attribute::ReadOnly || A == Attribute::NoCapture)\n        return Inputs[Idx]->getType()->isPointerTy();\n\n    // Conservative answer:  no operands have any attributes.\n    return false;\n  }\n\n  /// Return the tag of this operand bundle as a string.\n  StringRef getTagName() const {\n    return Tag->getKey();\n  }\n\n  /// Return the tag of this operand bundle as an integer.\n  ///\n  /// Operand bundle tags are interned by LLVMContextImpl::getOrInsertBundleTag,\n  /// and this function returns the unique integer getOrInsertBundleTag\n  /// associated the tag of this operand bundle to.\n  uint32_t getTagID() const {\n    return Tag->getValue();\n  }\n\n  /// Return true if this is a \"deopt\" operand bundle.\n  bool isDeoptOperandBundle() const {\n    return getTagID() == LLVMContext::OB_deopt;\n  }\n\n  /// Return true if this is a \"funclet\" operand bundle.\n  bool isFuncletOperandBundle() const {\n    return getTagID() == LLVMContext::OB_funclet;\n  }\n\n  /// Return true if this is a \"cfguardtarget\" operand bundle.\n  bool isCFGuardTargetOperandBundle() const {\n    return getTagID() == LLVMContext::OB_cfguardtarget;\n  }\n\nprivate:\n  /// Pointer to an entry in LLVMContextImpl::getOrInsertBundleTag.\n  StringMapEntry<uint32_t> *Tag;\n};\n\n/// A container for an operand bundle being viewed as a set of values\n/// rather than a set of uses.\n///\n/// Unlike OperandBundleUse, OperandBundleDefT owns the memory it carries, and\n/// so it is possible to create and pass around \"self-contained\" instances of\n/// OperandBundleDef and ConstOperandBundleDef.\ntemplate <typename InputTy> class OperandBundleDefT {\n  std::string Tag;\n  std::vector<InputTy> Inputs;\n\npublic:\n  explicit OperandBundleDefT(std::string Tag, std::vector<InputTy> Inputs)\n      : Tag(std::move(Tag)), Inputs(std::move(Inputs)) {}\n  explicit OperandBundleDefT(std::string Tag, ArrayRef<InputTy> Inputs)\n      : Tag(std::move(Tag)), Inputs(Inputs) {}\n\n  explicit OperandBundleDefT(const OperandBundleUse &OBU) {\n    Tag = std::string(OBU.getTagName());\n    llvm::append_range(Inputs, OBU.Inputs);\n  }\n\n  ArrayRef<InputTy> inputs() const { return Inputs; }\n\n  using input_iterator = typename std::vector<InputTy>::const_iterator;\n\n  size_t input_size() const { return Inputs.size(); }\n  input_iterator input_begin() const { return Inputs.begin(); }\n  input_iterator input_end() const { return Inputs.end(); }\n\n  StringRef getTag() const { return Tag; }\n};\n\nusing OperandBundleDef = OperandBundleDefT<Value *>;\nusing ConstOperandBundleDef = OperandBundleDefT<const Value *>;\n\n//===----------------------------------------------------------------------===//\n//                               CallBase Class\n//===----------------------------------------------------------------------===//\n\n/// Base class for all callable instructions (InvokeInst and CallInst)\n/// Holds everything related to calling a function.\n///\n/// All call-like instructions are required to use a common operand layout:\n/// - Zero or more arguments to the call,\n/// - Zero or more operand bundles with zero or more operand inputs each\n///   bundle,\n/// - Zero or more subclass controlled operands\n/// - The called function.\n///\n/// This allows this base class to easily access the called function and the\n/// start of the arguments without knowing how many other operands a particular\n/// subclass requires. Note that accessing the end of the argument list isn't\n/// as cheap as most other operations on the base class.\nclass CallBase : public Instruction {\nprotected:\n  // The first two bits are reserved by CallInst for fast retrieval,\n  using CallInstReservedField = Bitfield::Element<unsigned, 0, 2>;\n  using CallingConvField =\n      Bitfield::Element<CallingConv::ID, CallInstReservedField::NextBit, 10,\n                        CallingConv::MaxID>;\n  static_assert(\n      Bitfield::areContiguous<CallInstReservedField, CallingConvField>(),\n      \"Bitfields must be contiguous\");\n\n  /// The last operand is the called operand.\n  static constexpr int CalledOperandOpEndIdx = -1;\n\n  AttributeList Attrs; ///< parameter attributes for callable\n  FunctionType *FTy;\n\n  template <class... ArgsTy>\n  CallBase(AttributeList const &A, FunctionType *FT, ArgsTy &&... Args)\n      : Instruction(std::forward<ArgsTy>(Args)...), Attrs(A), FTy(FT) {}\n\n  using Instruction::Instruction;\n\n  bool hasDescriptor() const { return Value::HasDescriptor; }\n\n  unsigned getNumSubclassExtraOperands() const {\n    switch (getOpcode()) {\n    case Instruction::Call:\n      return 0;\n    case Instruction::Invoke:\n      return 2;\n    case Instruction::CallBr:\n      return getNumSubclassExtraOperandsDynamic();\n    }\n    llvm_unreachable(\"Invalid opcode!\");\n  }\n\n  /// Get the number of extra operands for instructions that don't have a fixed\n  /// number of extra operands.\n  unsigned getNumSubclassExtraOperandsDynamic() const;\n\npublic:\n  using Instruction::getContext;\n\n  /// Create a clone of \\p CB with a different set of operand bundles and\n  /// insert it before \\p InsertPt.\n  ///\n  /// The returned call instruction is identical \\p CB in every way except that\n  /// the operand bundles for the new instruction are set to the operand bundles\n  /// in \\p Bundles.\n  static CallBase *Create(CallBase *CB, ArrayRef<OperandBundleDef> Bundles,\n                          Instruction *InsertPt = nullptr);\n\n  /// Create a clone of \\p CB with the operand bundle with the tag matching\n  /// \\p Bundle's tag replaced with Bundle, and insert it before \\p InsertPt.\n  ///\n  /// The returned call instruction is identical \\p CI in every way except that\n  /// the specified operand bundle has been replaced.\n  static CallBase *Create(CallBase *CB,\n                          OperandBundleDef Bundle,\n                          Instruction *InsertPt = nullptr);\n\n  /// Create a clone of \\p CB with operand bundle \\p OB added.\n  static CallBase *addOperandBundle(CallBase *CB, uint32_t ID,\n                                    OperandBundleDef OB,\n                                    Instruction *InsertPt = nullptr);\n\n  /// Create a clone of \\p CB with operand bundle \\p ID removed.\n  static CallBase *removeOperandBundle(CallBase *CB, uint32_t ID,\n                                       Instruction *InsertPt = nullptr);\n\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Call ||\n           I->getOpcode() == Instruction::Invoke ||\n           I->getOpcode() == Instruction::CallBr;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\n  FunctionType *getFunctionType() const { return FTy; }\n\n  void mutateFunctionType(FunctionType *FTy) {\n    Value::mutateType(FTy->getReturnType());\n    this->FTy = FTy;\n  }\n\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// data_operands_begin/data_operands_end - Return iterators iterating over\n  /// the call / invoke argument list and bundle operands.  For invokes, this is\n  /// the set of instruction operands except the invoke target and the two\n  /// successor blocks; and for calls this is the set of instruction operands\n  /// except the call target.\n  User::op_iterator data_operands_begin() { return op_begin(); }\n  User::const_op_iterator data_operands_begin() const {\n    return const_cast<CallBase *>(this)->data_operands_begin();\n  }\n  User::op_iterator data_operands_end() {\n    // Walk from the end of the operands over the called operand and any\n    // subclass operands.\n    return op_end() - getNumSubclassExtraOperands() - 1;\n  }\n  User::const_op_iterator data_operands_end() const {\n    return const_cast<CallBase *>(this)->data_operands_end();\n  }\n  iterator_range<User::op_iterator> data_ops() {\n    return make_range(data_operands_begin(), data_operands_end());\n  }\n  iterator_range<User::const_op_iterator> data_ops() const {\n    return make_range(data_operands_begin(), data_operands_end());\n  }\n  bool data_operands_empty() const {\n    return data_operands_end() == data_operands_begin();\n  }\n  unsigned data_operands_size() const {\n    return std::distance(data_operands_begin(), data_operands_end());\n  }\n\n  bool isDataOperand(const Use *U) const {\n    assert(this == U->getUser() &&\n           \"Only valid to query with a use of this instruction!\");\n    return data_operands_begin() <= U && U < data_operands_end();\n  }\n  bool isDataOperand(Value::const_user_iterator UI) const {\n    return isDataOperand(&UI.getUse());\n  }\n\n  /// Given a value use iterator, return the data operand corresponding to it.\n  /// Iterator must actually correspond to a data operand.\n  unsigned getDataOperandNo(Value::const_user_iterator UI) const {\n    return getDataOperandNo(&UI.getUse());\n  }\n\n  /// Given a use for a data operand, get the data operand number that\n  /// corresponds to it.\n  unsigned getDataOperandNo(const Use *U) const {\n    assert(isDataOperand(U) && \"Data operand # out of range!\");\n    return U - data_operands_begin();\n  }\n\n  /// Return the iterator pointing to the beginning of the argument list.\n  User::op_iterator arg_begin() { return op_begin(); }\n  User::const_op_iterator arg_begin() const {\n    return const_cast<CallBase *>(this)->arg_begin();\n  }\n\n  /// Return the iterator pointing to the end of the argument list.\n  User::op_iterator arg_end() {\n    // From the end of the data operands, walk backwards past the bundle\n    // operands.\n    return data_operands_end() - getNumTotalBundleOperands();\n  }\n  User::const_op_iterator arg_end() const {\n    return const_cast<CallBase *>(this)->arg_end();\n  }\n\n  /// Iteration adapter for range-for loops.\n  iterator_range<User::op_iterator> args() {\n    return make_range(arg_begin(), arg_end());\n  }\n  iterator_range<User::const_op_iterator> args() const {\n    return make_range(arg_begin(), arg_end());\n  }\n  bool arg_empty() const { return arg_end() == arg_begin(); }\n  unsigned arg_size() const { return arg_end() - arg_begin(); }\n\n  // Legacy API names that duplicate the above and will be removed once users\n  // are migrated.\n  iterator_range<User::op_iterator> arg_operands() {\n    return make_range(arg_begin(), arg_end());\n  }\n  iterator_range<User::const_op_iterator> arg_operands() const {\n    return make_range(arg_begin(), arg_end());\n  }\n  unsigned getNumArgOperands() const { return arg_size(); }\n\n  Value *getArgOperand(unsigned i) const {\n    assert(i < getNumArgOperands() && \"Out of bounds!\");\n    return getOperand(i);\n  }\n\n  void setArgOperand(unsigned i, Value *v) {\n    assert(i < getNumArgOperands() && \"Out of bounds!\");\n    setOperand(i, v);\n  }\n\n  /// Wrappers for getting the \\c Use of a call argument.\n  const Use &getArgOperandUse(unsigned i) const {\n    assert(i < getNumArgOperands() && \"Out of bounds!\");\n    return User::getOperandUse(i);\n  }\n  Use &getArgOperandUse(unsigned i) {\n    assert(i < getNumArgOperands() && \"Out of bounds!\");\n    return User::getOperandUse(i);\n  }\n\n  bool isArgOperand(const Use *U) const {\n    assert(this == U->getUser() &&\n           \"Only valid to query with a use of this instruction!\");\n    return arg_begin() <= U && U < arg_end();\n  }\n  bool isArgOperand(Value::const_user_iterator UI) const {\n    return isArgOperand(&UI.getUse());\n  }\n\n  /// Given a use for a arg operand, get the arg operand number that\n  /// corresponds to it.\n  unsigned getArgOperandNo(const Use *U) const {\n    assert(isArgOperand(U) && \"Arg operand # out of range!\");\n    return U - arg_begin();\n  }\n\n  /// Given a value use iterator, return the arg operand number corresponding to\n  /// it. Iterator must actually correspond to a data operand.\n  unsigned getArgOperandNo(Value::const_user_iterator UI) const {\n    return getArgOperandNo(&UI.getUse());\n  }\n\n  /// Returns true if this CallSite passes the given Value* as an argument to\n  /// the called function.\n  bool hasArgument(const Value *V) const {\n    return llvm::is_contained(args(), V);\n  }\n\n  Value *getCalledOperand() const { return Op<CalledOperandOpEndIdx>(); }\n\n  const Use &getCalledOperandUse() const { return Op<CalledOperandOpEndIdx>(); }\n  Use &getCalledOperandUse() { return Op<CalledOperandOpEndIdx>(); }\n\n  /// Returns the function called, or null if this is an\n  /// indirect function invocation.\n  Function *getCalledFunction() const {\n    return dyn_cast_or_null<Function>(getCalledOperand());\n  }\n\n  /// Return true if the callsite is an indirect call.\n  bool isIndirectCall() const;\n\n  /// Determine whether the passed iterator points to the callee operand's Use.\n  bool isCallee(Value::const_user_iterator UI) const {\n    return isCallee(&UI.getUse());\n  }\n\n  /// Determine whether this Use is the callee operand's Use.\n  bool isCallee(const Use *U) const { return &getCalledOperandUse() == U; }\n\n  /// Helper to get the caller (the parent function).\n  Function *getCaller();\n  const Function *getCaller() const {\n    return const_cast<CallBase *>(this)->getCaller();\n  }\n\n  /// Tests if this call site must be tail call optimized. Only a CallInst can\n  /// be tail call optimized.\n  bool isMustTailCall() const;\n\n  /// Tests if this call site is marked as a tail call.\n  bool isTailCall() const;\n\n  /// Returns the intrinsic ID of the intrinsic called or\n  /// Intrinsic::not_intrinsic if the called function is not an intrinsic, or if\n  /// this is an indirect call.\n  Intrinsic::ID getIntrinsicID() const;\n\n  void setCalledOperand(Value *V) { Op<CalledOperandOpEndIdx>() = V; }\n\n  /// Sets the function called, including updating the function type.\n  void setCalledFunction(Function *Fn) {\n    setCalledFunction(Fn->getFunctionType(), Fn);\n  }\n\n  /// Sets the function called, including updating the function type.\n  void setCalledFunction(FunctionCallee Fn) {\n    setCalledFunction(Fn.getFunctionType(), Fn.getCallee());\n  }\n\n  /// Sets the function called, including updating to the specified function\n  /// type.\n  void setCalledFunction(FunctionType *FTy, Value *Fn) {\n    this->FTy = FTy;\n    assert(FTy == cast<FunctionType>(\n                      cast<PointerType>(Fn->getType())->getElementType()));\n    // This function doesn't mutate the return type, only the function\n    // type. Seems broken, but I'm just gonna stick an assert in for now.\n    assert(getType() == FTy->getReturnType());\n    setCalledOperand(Fn);\n  }\n\n  CallingConv::ID getCallingConv() const {\n    return getSubclassData<CallingConvField>();\n  }\n\n  void setCallingConv(CallingConv::ID CC) {\n    setSubclassData<CallingConvField>(CC);\n  }\n\n  /// Check if this call is an inline asm statement.\n  bool isInlineAsm() const { return isa<InlineAsm>(getCalledOperand()); }\n\n  /// \\name Attribute API\n  ///\n  /// These methods access and modify attributes on this call (including\n  /// looking through to the attributes on the called function when necessary).\n  ///@{\n\n  /// Return the parameter attributes for this call.\n  ///\n  AttributeList getAttributes() const { return Attrs; }\n\n  /// Set the parameter attributes for this call.\n  ///\n  void setAttributes(AttributeList A) { Attrs = A; }\n\n  /// Determine whether this call has the given attribute. If it does not\n  /// then determine if the called function has the attribute, but only if\n  /// the attribute is allowed for the call.\n  bool hasFnAttr(Attribute::AttrKind Kind) const {\n    assert(Kind != Attribute::NoBuiltin &&\n           \"Use CallBase::isNoBuiltin() to check for Attribute::NoBuiltin\");\n    return hasFnAttrImpl(Kind);\n  }\n\n  /// Determine whether this call has the given attribute. If it does not\n  /// then determine if the called function has the attribute, but only if\n  /// the attribute is allowed for the call.\n  bool hasFnAttr(StringRef Kind) const { return hasFnAttrImpl(Kind); }\n\n  /// adds the attribute to the list of attributes.\n  void addAttribute(unsigned i, Attribute::AttrKind Kind) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addAttribute(getContext(), i, Kind);\n    setAttributes(PAL);\n  }\n\n  /// adds the attribute to the list of attributes.\n  void addAttribute(unsigned i, Attribute Attr) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addAttribute(getContext(), i, Attr);\n    setAttributes(PAL);\n  }\n\n  /// Adds the attribute to the indicated argument\n  void addParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addParamAttribute(getContext(), ArgNo, Kind);\n    setAttributes(PAL);\n  }\n\n  /// Adds the attribute to the indicated argument\n  void addParamAttr(unsigned ArgNo, Attribute Attr) {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addParamAttribute(getContext(), ArgNo, Attr);\n    setAttributes(PAL);\n  }\n\n  /// removes the attribute from the list of attributes.\n  void removeAttribute(unsigned i, Attribute::AttrKind Kind) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.removeAttribute(getContext(), i, Kind);\n    setAttributes(PAL);\n  }\n\n  /// removes the attribute from the list of attributes.\n  void removeAttribute(unsigned i, StringRef Kind) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.removeAttribute(getContext(), i, Kind);\n    setAttributes(PAL);\n  }\n\n  void removeAttributes(unsigned i, const AttrBuilder &Attrs) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.removeAttributes(getContext(), i, Attrs);\n    setAttributes(PAL);\n  }\n\n  /// Removes the attribute from the given argument\n  void removeParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    AttributeList PAL = getAttributes();\n    PAL = PAL.removeParamAttribute(getContext(), ArgNo, Kind);\n    setAttributes(PAL);\n  }\n\n  /// Removes the attribute from the given argument\n  void removeParamAttr(unsigned ArgNo, StringRef Kind) {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    AttributeList PAL = getAttributes();\n    PAL = PAL.removeParamAttribute(getContext(), ArgNo, Kind);\n    setAttributes(PAL);\n  }\n\n  /// adds the dereferenceable attribute to the list of attributes.\n  void addDereferenceableAttr(unsigned i, uint64_t Bytes) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addDereferenceableAttr(getContext(), i, Bytes);\n    setAttributes(PAL);\n  }\n\n  /// adds the dereferenceable_or_null attribute to the list of\n  /// attributes.\n  void addDereferenceableOrNullAttr(unsigned i, uint64_t Bytes) {\n    AttributeList PAL = getAttributes();\n    PAL = PAL.addDereferenceableOrNullAttr(getContext(), i, Bytes);\n    setAttributes(PAL);\n  }\n\n  /// Determine whether the return value has the given attribute.\n  bool hasRetAttr(Attribute::AttrKind Kind) const {\n    return hasRetAttrImpl(Kind);\n  }\n  /// Determine whether the return value has the given attribute.\n  bool hasRetAttr(StringRef Kind) const { return hasRetAttrImpl(Kind); }\n\n  /// Determine whether the argument or parameter has the given attribute.\n  bool paramHasAttr(unsigned ArgNo, Attribute::AttrKind Kind) const;\n\n  /// Get the attribute of a given kind at a position.\n  Attribute getAttribute(unsigned i, Attribute::AttrKind Kind) const {\n    return getAttributes().getAttribute(i, Kind);\n  }\n\n  /// Get the attribute of a given kind at a position.\n  Attribute getAttribute(unsigned i, StringRef Kind) const {\n    return getAttributes().getAttribute(i, Kind);\n  }\n\n  /// Get the attribute of a given kind from a given arg\n  Attribute getParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) const {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    return getAttributes().getParamAttr(ArgNo, Kind);\n  }\n\n  /// Get the attribute of a given kind from a given arg\n  Attribute getParamAttr(unsigned ArgNo, StringRef Kind) const {\n    assert(ArgNo < getNumArgOperands() && \"Out of bounds\");\n    return getAttributes().getParamAttr(ArgNo, Kind);\n  }\n\n  /// Return true if the data operand at index \\p i has the attribute \\p\n  /// A.\n  ///\n  /// Data operands include call arguments and values used in operand bundles,\n  /// but does not include the callee operand.  This routine dispatches to the\n  /// underlying AttributeList or the OperandBundleUser as appropriate.\n  ///\n  /// The index \\p i is interpreted as\n  ///\n  ///  \\p i == Attribute::ReturnIndex  -> the return value\n  ///  \\p i in [1, arg_size + 1)  -> argument number (\\p i - 1)\n  ///  \\p i in [arg_size + 1, data_operand_size + 1) -> bundle operand at index\n  ///     (\\p i - 1) in the operand list.\n  bool dataOperandHasImpliedAttr(unsigned i, Attribute::AttrKind Kind) const {\n    // Note that we have to add one because `i` isn't zero-indexed.\n    assert(i < (getNumArgOperands() + getNumTotalBundleOperands() + 1) &&\n           \"Data operand index out of bounds!\");\n\n    // The attribute A can either be directly specified, if the operand in\n    // question is a call argument; or be indirectly implied by the kind of its\n    // containing operand bundle, if the operand is a bundle operand.\n\n    if (i == AttributeList::ReturnIndex)\n      return hasRetAttr(Kind);\n\n    // FIXME: Avoid these i - 1 calculations and update the API to use\n    // zero-based indices.\n    if (i < (getNumArgOperands() + 1))\n      return paramHasAttr(i - 1, Kind);\n\n    assert(hasOperandBundles() && i >= (getBundleOperandsStartIndex() + 1) &&\n           \"Must be either a call argument or an operand bundle!\");\n    return bundleOperandHasAttr(i - 1, Kind);\n  }\n\n  /// Determine whether this data operand is not captured.\n  // FIXME: Once this API is no longer duplicated in `CallSite`, rename this to\n  // better indicate that this may return a conservative answer.\n  bool doesNotCapture(unsigned OpNo) const {\n    return dataOperandHasImpliedAttr(OpNo + 1, Attribute::NoCapture);\n  }\n\n  /// Determine whether this argument is passed by value.\n  bool isByValArgument(unsigned ArgNo) const {\n    return paramHasAttr(ArgNo, Attribute::ByVal);\n  }\n\n  /// Determine whether this argument is passed in an alloca.\n  bool isInAllocaArgument(unsigned ArgNo) const {\n    return paramHasAttr(ArgNo, Attribute::InAlloca);\n  }\n\n  /// Determine whether this argument is passed by value, in an alloca, or is\n  /// preallocated.\n  bool isPassPointeeByValueArgument(unsigned ArgNo) const {\n    return paramHasAttr(ArgNo, Attribute::ByVal) ||\n           paramHasAttr(ArgNo, Attribute::InAlloca) ||\n           paramHasAttr(ArgNo, Attribute::Preallocated);\n  }\n\n  /// Determine whether passing undef to this argument is undefined behavior.\n  /// If passing undef to this argument is UB, passing poison is UB as well\n  /// because poison is more undefined than undef.\n  bool isPassingUndefUB(unsigned ArgNo) const {\n    return paramHasAttr(ArgNo, Attribute::NoUndef) ||\n           // dereferenceable implies noundef.\n           paramHasAttr(ArgNo, Attribute::Dereferenceable) ||\n           // dereferenceable implies noundef, and null is a well-defined value.\n           paramHasAttr(ArgNo, Attribute::DereferenceableOrNull);\n  }\n\n  /// Determine if there are is an inalloca argument. Only the last argument can\n  /// have the inalloca attribute.\n  bool hasInAllocaArgument() const {\n    return !arg_empty() && paramHasAttr(arg_size() - 1, Attribute::InAlloca);\n  }\n\n  // FIXME: Once this API is no longer duplicated in `CallSite`, rename this to\n  // better indicate that this may return a conservative answer.\n  bool doesNotAccessMemory(unsigned OpNo) const {\n    return dataOperandHasImpliedAttr(OpNo + 1, Attribute::ReadNone);\n  }\n\n  // FIXME: Once this API is no longer duplicated in `CallSite`, rename this to\n  // better indicate that this may return a conservative answer.\n  bool onlyReadsMemory(unsigned OpNo) const {\n    return dataOperandHasImpliedAttr(OpNo + 1, Attribute::ReadOnly) ||\n           dataOperandHasImpliedAttr(OpNo + 1, Attribute::ReadNone);\n  }\n\n  // FIXME: Once this API is no longer duplicated in `CallSite`, rename this to\n  // better indicate that this may return a conservative answer.\n  bool doesNotReadMemory(unsigned OpNo) const {\n    return dataOperandHasImpliedAttr(OpNo + 1, Attribute::WriteOnly) ||\n           dataOperandHasImpliedAttr(OpNo + 1, Attribute::ReadNone);\n  }\n\n  LLVM_ATTRIBUTE_DEPRECATED(unsigned getRetAlignment() const,\n                            \"Use getRetAlign() instead\") {\n    if (const auto MA = Attrs.getRetAlignment())\n      return MA->value();\n    return 0;\n  }\n\n  /// Extract the alignment of the return value.\n  MaybeAlign getRetAlign() const { return Attrs.getRetAlignment(); }\n\n  /// Extract the alignment for a call or parameter (0=unknown).\n  LLVM_ATTRIBUTE_DEPRECATED(unsigned getParamAlignment(unsigned ArgNo) const,\n                            \"Use getParamAlign() instead\") {\n    if (const auto MA = Attrs.getParamAlignment(ArgNo))\n      return MA->value();\n    return 0;\n  }\n\n  /// Extract the alignment for a call or parameter (0=unknown).\n  MaybeAlign getParamAlign(unsigned ArgNo) const {\n    return Attrs.getParamAlignment(ArgNo);\n  }\n\n  /// Extract the byval type for a call or parameter.\n  Type *getParamByValType(unsigned ArgNo) const {\n    Type *Ty = Attrs.getParamByValType(ArgNo);\n    return Ty ? Ty : getArgOperand(ArgNo)->getType()->getPointerElementType();\n  }\n\n  /// Extract the preallocated type for a call or parameter.\n  Type *getParamPreallocatedType(unsigned ArgNo) const {\n    Type *Ty = Attrs.getParamPreallocatedType(ArgNo);\n    return Ty ? Ty : getArgOperand(ArgNo)->getType()->getPointerElementType();\n  }\n\n  /// Extract the number of dereferenceable bytes for a call or\n  /// parameter (0=unknown).\n  uint64_t getDereferenceableBytes(unsigned i) const {\n    return Attrs.getDereferenceableBytes(i);\n  }\n\n  /// Extract the number of dereferenceable_or_null bytes for a call or\n  /// parameter (0=unknown).\n  uint64_t getDereferenceableOrNullBytes(unsigned i) const {\n    return Attrs.getDereferenceableOrNullBytes(i);\n  }\n\n  /// Return true if the return value is known to be not null.\n  /// This may be because it has the nonnull attribute, or because at least\n  /// one byte is dereferenceable and the pointer is in addrspace(0).\n  bool isReturnNonNull() const;\n\n  /// Determine if the return value is marked with NoAlias attribute.\n  bool returnDoesNotAlias() const {\n    return Attrs.hasAttribute(AttributeList::ReturnIndex, Attribute::NoAlias);\n  }\n\n  /// If one of the arguments has the 'returned' attribute, returns its\n  /// operand value. Otherwise, return nullptr.\n  Value *getReturnedArgOperand() const;\n\n  /// Return true if the call should not be treated as a call to a\n  /// builtin.\n  bool isNoBuiltin() const {\n    return hasFnAttrImpl(Attribute::NoBuiltin) &&\n           !hasFnAttrImpl(Attribute::Builtin);\n  }\n\n  /// Determine if the call requires strict floating point semantics.\n  bool isStrictFP() const { return hasFnAttr(Attribute::StrictFP); }\n\n  /// Return true if the call should not be inlined.\n  bool isNoInline() const { return hasFnAttr(Attribute::NoInline); }\n  void setIsNoInline() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::NoInline);\n  }\n  /// Determine if the call does not access memory.\n  bool doesNotAccessMemory() const { return hasFnAttr(Attribute::ReadNone); }\n  void setDoesNotAccessMemory() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::ReadNone);\n  }\n\n  /// Determine if the call does not access or only reads memory.\n  bool onlyReadsMemory() const {\n    return doesNotAccessMemory() || hasFnAttr(Attribute::ReadOnly);\n  }\n\n  void setOnlyReadsMemory() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::ReadOnly);\n  }\n\n  /// Determine if the call does not access or only writes memory.\n  bool doesNotReadMemory() const {\n    return doesNotAccessMemory() || hasFnAttr(Attribute::WriteOnly);\n  }\n  void setDoesNotReadMemory() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::WriteOnly);\n  }\n\n  /// Determine if the call can access memmory only using pointers based\n  /// on its arguments.\n  bool onlyAccessesArgMemory() const {\n    return hasFnAttr(Attribute::ArgMemOnly);\n  }\n  void setOnlyAccessesArgMemory() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::ArgMemOnly);\n  }\n\n  /// Determine if the function may only access memory that is\n  /// inaccessible from the IR.\n  bool onlyAccessesInaccessibleMemory() const {\n    return hasFnAttr(Attribute::InaccessibleMemOnly);\n  }\n  void setOnlyAccessesInaccessibleMemory() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::InaccessibleMemOnly);\n  }\n\n  /// Determine if the function may only access memory that is\n  /// either inaccessible from the IR or pointed to by its arguments.\n  bool onlyAccessesInaccessibleMemOrArgMem() const {\n    return hasFnAttr(Attribute::InaccessibleMemOrArgMemOnly);\n  }\n  void setOnlyAccessesInaccessibleMemOrArgMem() {\n    addAttribute(AttributeList::FunctionIndex,\n                 Attribute::InaccessibleMemOrArgMemOnly);\n  }\n  /// Determine if the call cannot return.\n  bool doesNotReturn() const { return hasFnAttr(Attribute::NoReturn); }\n  void setDoesNotReturn() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::NoReturn);\n  }\n\n  /// Determine if the call should not perform indirect branch tracking.\n  bool doesNoCfCheck() const { return hasFnAttr(Attribute::NoCfCheck); }\n\n  /// Determine if the call cannot unwind.\n  bool doesNotThrow() const { return hasFnAttr(Attribute::NoUnwind); }\n  void setDoesNotThrow() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::NoUnwind);\n  }\n\n  /// Determine if the invoke cannot be duplicated.\n  bool cannotDuplicate() const { return hasFnAttr(Attribute::NoDuplicate); }\n  void setCannotDuplicate() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::NoDuplicate);\n  }\n\n  /// Determine if the call cannot be tail merged.\n  bool cannotMerge() const { return hasFnAttr(Attribute::NoMerge); }\n  void setCannotMerge() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::NoMerge);\n  }\n\n  /// Determine if the invoke is convergent\n  bool isConvergent() const { return hasFnAttr(Attribute::Convergent); }\n  void setConvergent() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::Convergent);\n  }\n  void setNotConvergent() {\n    removeAttribute(AttributeList::FunctionIndex, Attribute::Convergent);\n  }\n\n  /// Determine if the call returns a structure through first\n  /// pointer argument.\n  bool hasStructRetAttr() const {\n    if (getNumArgOperands() == 0)\n      return false;\n\n    // Be friendly and also check the callee.\n    return paramHasAttr(0, Attribute::StructRet);\n  }\n\n  /// Determine if any call argument is an aggregate passed by value.\n  bool hasByValArgument() const {\n    return Attrs.hasAttrSomewhere(Attribute::ByVal);\n  }\n\n  ///@{\n  // End of attribute API.\n\n  /// \\name Operand Bundle API\n  ///\n  /// This group of methods provides the API to access and manipulate operand\n  /// bundles on this call.\n  /// @{\n\n  /// Return the number of operand bundles associated with this User.\n  unsigned getNumOperandBundles() const {\n    return std::distance(bundle_op_info_begin(), bundle_op_info_end());\n  }\n\n  /// Return true if this User has any operand bundles.\n  bool hasOperandBundles() const { return getNumOperandBundles() != 0; }\n\n  /// Return the index of the first bundle operand in the Use array.\n  unsigned getBundleOperandsStartIndex() const {\n    assert(hasOperandBundles() && \"Don't call otherwise!\");\n    return bundle_op_info_begin()->Begin;\n  }\n\n  /// Return the index of the last bundle operand in the Use array.\n  unsigned getBundleOperandsEndIndex() const {\n    assert(hasOperandBundles() && \"Don't call otherwise!\");\n    return bundle_op_info_end()[-1].End;\n  }\n\n  /// Return true if the operand at index \\p Idx is a bundle operand.\n  bool isBundleOperand(unsigned Idx) const {\n    return hasOperandBundles() && Idx >= getBundleOperandsStartIndex() &&\n           Idx < getBundleOperandsEndIndex();\n  }\n\n  /// Returns true if the use is a bundle operand.\n  bool isBundleOperand(const Use *U) const {\n    assert(this == U->getUser() &&\n           \"Only valid to query with a use of this instruction!\");\n    return hasOperandBundles() && isBundleOperand(U - op_begin());\n  }\n  bool isBundleOperand(Value::const_user_iterator UI) const {\n    return isBundleOperand(&UI.getUse());\n  }\n\n  /// Return the total number operands (not operand bundles) used by\n  /// every operand bundle in this OperandBundleUser.\n  unsigned getNumTotalBundleOperands() const {\n    if (!hasOperandBundles())\n      return 0;\n\n    unsigned Begin = getBundleOperandsStartIndex();\n    unsigned End = getBundleOperandsEndIndex();\n\n    assert(Begin <= End && \"Should be!\");\n    return End - Begin;\n  }\n\n  /// Return the operand bundle at a specific index.\n  OperandBundleUse getOperandBundleAt(unsigned Index) const {\n    assert(Index < getNumOperandBundles() && \"Index out of bounds!\");\n    return operandBundleFromBundleOpInfo(*(bundle_op_info_begin() + Index));\n  }\n\n  /// Return the number of operand bundles with the tag Name attached to\n  /// this instruction.\n  unsigned countOperandBundlesOfType(StringRef Name) const {\n    unsigned Count = 0;\n    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i)\n      if (getOperandBundleAt(i).getTagName() == Name)\n        Count++;\n\n    return Count;\n  }\n\n  /// Return the number of operand bundles with the tag ID attached to\n  /// this instruction.\n  unsigned countOperandBundlesOfType(uint32_t ID) const {\n    unsigned Count = 0;\n    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i)\n      if (getOperandBundleAt(i).getTagID() == ID)\n        Count++;\n\n    return Count;\n  }\n\n  /// Return an operand bundle by name, if present.\n  ///\n  /// It is an error to call this for operand bundle types that may have\n  /// multiple instances of them on the same instruction.\n  Optional<OperandBundleUse> getOperandBundle(StringRef Name) const {\n    assert(countOperandBundlesOfType(Name) < 2 && \"Precondition violated!\");\n\n    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i) {\n      OperandBundleUse U = getOperandBundleAt(i);\n      if (U.getTagName() == Name)\n        return U;\n    }\n\n    return None;\n  }\n\n  /// Return an operand bundle by tag ID, if present.\n  ///\n  /// It is an error to call this for operand bundle types that may have\n  /// multiple instances of them on the same instruction.\n  Optional<OperandBundleUse> getOperandBundle(uint32_t ID) const {\n    assert(countOperandBundlesOfType(ID) < 2 && \"Precondition violated!\");\n\n    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i) {\n      OperandBundleUse U = getOperandBundleAt(i);\n      if (U.getTagID() == ID)\n        return U;\n    }\n\n    return None;\n  }\n\n  /// Return the list of operand bundles attached to this instruction as\n  /// a vector of OperandBundleDefs.\n  ///\n  /// This function copies the OperandBundeUse instances associated with this\n  /// OperandBundleUser to a vector of OperandBundleDefs.  Note:\n  /// OperandBundeUses and OperandBundleDefs are non-trivially *different*\n  /// representations of operand bundles (see documentation above).\n  void getOperandBundlesAsDefs(SmallVectorImpl<OperandBundleDef> &Defs) const;\n\n  /// Return the operand bundle for the operand at index OpIdx.\n  ///\n  /// It is an error to call this with an OpIdx that does not correspond to an\n  /// bundle operand.\n  OperandBundleUse getOperandBundleForOperand(unsigned OpIdx) const {\n    return operandBundleFromBundleOpInfo(getBundleOpInfoForOperand(OpIdx));\n  }\n\n  /// Return true if this operand bundle user has operand bundles that\n  /// may read from the heap.\n  bool hasReadingOperandBundles() const {\n    // Implementation note: this is a conservative implementation of operand\n    // bundle semantics, where *any* operand bundle forces a callsite to be at\n    // least readonly.\n    return hasOperandBundles();\n  }\n\n  /// Return true if this operand bundle user has operand bundles that\n  /// may write to the heap.\n  bool hasClobberingOperandBundles() const {\n    for (auto &BOI : bundle_op_infos()) {\n      if (BOI.Tag->second == LLVMContext::OB_deopt ||\n          BOI.Tag->second == LLVMContext::OB_funclet)\n        continue;\n\n      // This instruction has an operand bundle that is not known to us.\n      // Assume the worst.\n      return true;\n    }\n\n    return false;\n  }\n\n  /// Return true if the bundle operand at index \\p OpIdx has the\n  /// attribute \\p A.\n  bool bundleOperandHasAttr(unsigned OpIdx,  Attribute::AttrKind A) const {\n    auto &BOI = getBundleOpInfoForOperand(OpIdx);\n    auto OBU = operandBundleFromBundleOpInfo(BOI);\n    return OBU.operandHasAttr(OpIdx - BOI.Begin, A);\n  }\n\n  /// Return true if \\p Other has the same sequence of operand bundle\n  /// tags with the same number of operands on each one of them as this\n  /// OperandBundleUser.\n  bool hasIdenticalOperandBundleSchema(const CallBase &Other) const {\n    if (getNumOperandBundles() != Other.getNumOperandBundles())\n      return false;\n\n    return std::equal(bundle_op_info_begin(), bundle_op_info_end(),\n                      Other.bundle_op_info_begin());\n  }\n\n  /// Return true if this operand bundle user contains operand bundles\n  /// with tags other than those specified in \\p IDs.\n  bool hasOperandBundlesOtherThan(ArrayRef<uint32_t> IDs) const {\n    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i) {\n      uint32_t ID = getOperandBundleAt(i).getTagID();\n      if (!is_contained(IDs, ID))\n        return true;\n    }\n    return false;\n  }\n\n  /// Is the function attribute S disallowed by some operand bundle on\n  /// this operand bundle user?\n  bool isFnAttrDisallowedByOpBundle(StringRef S) const {\n    // Operand bundles only possibly disallow readnone, readonly and argmemonly\n    // attributes.  All String attributes are fine.\n    return false;\n  }\n\n  /// Is the function attribute A disallowed by some operand bundle on\n  /// this operand bundle user?\n  bool isFnAttrDisallowedByOpBundle(Attribute::AttrKind A) const {\n    switch (A) {\n    default:\n      return false;\n\n    case Attribute::InaccessibleMemOrArgMemOnly:\n      return hasReadingOperandBundles();\n\n    case Attribute::InaccessibleMemOnly:\n      return hasReadingOperandBundles();\n\n    case Attribute::ArgMemOnly:\n      return hasReadingOperandBundles();\n\n    case Attribute::ReadNone:\n      return hasReadingOperandBundles();\n\n    case Attribute::ReadOnly:\n      return hasClobberingOperandBundles();\n    }\n\n    llvm_unreachable(\"switch has a default case!\");\n  }\n\n  /// Used to keep track of an operand bundle.  See the main comment on\n  /// OperandBundleUser above.\n  struct BundleOpInfo {\n    /// The operand bundle tag, interned by\n    /// LLVMContextImpl::getOrInsertBundleTag.\n    StringMapEntry<uint32_t> *Tag;\n\n    /// The index in the Use& vector where operands for this operand\n    /// bundle starts.\n    uint32_t Begin;\n\n    /// The index in the Use& vector where operands for this operand\n    /// bundle ends.\n    uint32_t End;\n\n    bool operator==(const BundleOpInfo &Other) const {\n      return Tag == Other.Tag && Begin == Other.Begin && End == Other.End;\n    }\n  };\n\n  /// Simple helper function to map a BundleOpInfo to an\n  /// OperandBundleUse.\n  OperandBundleUse\n  operandBundleFromBundleOpInfo(const BundleOpInfo &BOI) const {\n    auto begin = op_begin();\n    ArrayRef<Use> Inputs(begin + BOI.Begin, begin + BOI.End);\n    return OperandBundleUse(BOI.Tag, Inputs);\n  }\n\n  using bundle_op_iterator = BundleOpInfo *;\n  using const_bundle_op_iterator = const BundleOpInfo *;\n\n  /// Return the start of the list of BundleOpInfo instances associated\n  /// with this OperandBundleUser.\n  ///\n  /// OperandBundleUser uses the descriptor area co-allocated with the host User\n  /// to store some meta information about which operands are \"normal\" operands,\n  /// and which ones belong to some operand bundle.\n  ///\n  /// The layout of an operand bundle user is\n  ///\n  ///          +-----------uint32_t End-------------------------------------+\n  ///          |                                                            |\n  ///          |  +--------uint32_t Begin--------------------+              |\n  ///          |  |                                          |              |\n  ///          ^  ^                                          v              v\n  ///  |------|------|----|----|----|----|----|---------|----|---------|----|-----\n  ///  | BOI0 | BOI1 | .. | DU | U0 | U1 | .. | BOI0_U0 | .. | BOI1_U0 | .. | Un\n  ///  |------|------|----|----|----|----|----|---------|----|---------|----|-----\n  ///   v  v                                  ^              ^\n  ///   |  |                                  |              |\n  ///   |  +--------uint32_t Begin------------+              |\n  ///   |                                                    |\n  ///   +-----------uint32_t End-----------------------------+\n  ///\n  ///\n  /// BOI0, BOI1 ... are descriptions of operand bundles in this User's use\n  /// list. These descriptions are installed and managed by this class, and\n  /// they're all instances of OperandBundleUser<T>::BundleOpInfo.\n  ///\n  /// DU is an additional descriptor installed by User's 'operator new' to keep\n  /// track of the 'BOI0 ... BOIN' co-allocation.  OperandBundleUser does not\n  /// access or modify DU in any way, it's an implementation detail private to\n  /// User.\n  ///\n  /// The regular Use& vector for the User starts at U0.  The operand bundle\n  /// uses are part of the Use& vector, just like normal uses.  In the diagram\n  /// above, the operand bundle uses start at BOI0_U0.  Each instance of\n  /// BundleOpInfo has information about a contiguous set of uses constituting\n  /// an operand bundle, and the total set of operand bundle uses themselves\n  /// form a contiguous set of uses (i.e. there are no gaps between uses\n  /// corresponding to individual operand bundles).\n  ///\n  /// This class does not know the location of the set of operand bundle uses\n  /// within the use list -- that is decided by the User using this class via\n  /// the BeginIdx argument in populateBundleOperandInfos.\n  ///\n  /// Currently operand bundle users with hung-off operands are not supported.\n  bundle_op_iterator bundle_op_info_begin() {\n    if (!hasDescriptor())\n      return nullptr;\n\n    uint8_t *BytesBegin = getDescriptor().begin();\n    return reinterpret_cast<bundle_op_iterator>(BytesBegin);\n  }\n\n  /// Return the start of the list of BundleOpInfo instances associated\n  /// with this OperandBundleUser.\n  const_bundle_op_iterator bundle_op_info_begin() const {\n    auto *NonConstThis = const_cast<CallBase *>(this);\n    return NonConstThis->bundle_op_info_begin();\n  }\n\n  /// Return the end of the list of BundleOpInfo instances associated\n  /// with this OperandBundleUser.\n  bundle_op_iterator bundle_op_info_end() {\n    if (!hasDescriptor())\n      return nullptr;\n\n    uint8_t *BytesEnd = getDescriptor().end();\n    return reinterpret_cast<bundle_op_iterator>(BytesEnd);\n  }\n\n  /// Return the end of the list of BundleOpInfo instances associated\n  /// with this OperandBundleUser.\n  const_bundle_op_iterator bundle_op_info_end() const {\n    auto *NonConstThis = const_cast<CallBase *>(this);\n    return NonConstThis->bundle_op_info_end();\n  }\n\n  /// Return the range [\\p bundle_op_info_begin, \\p bundle_op_info_end).\n  iterator_range<bundle_op_iterator> bundle_op_infos() {\n    return make_range(bundle_op_info_begin(), bundle_op_info_end());\n  }\n\n  /// Return the range [\\p bundle_op_info_begin, \\p bundle_op_info_end).\n  iterator_range<const_bundle_op_iterator> bundle_op_infos() const {\n    return make_range(bundle_op_info_begin(), bundle_op_info_end());\n  }\n\n  /// Populate the BundleOpInfo instances and the Use& vector from \\p\n  /// Bundles.  Return the op_iterator pointing to the Use& one past the last\n  /// last bundle operand use.\n  ///\n  /// Each \\p OperandBundleDef instance is tracked by a OperandBundleInfo\n  /// instance allocated in this User's descriptor.\n  op_iterator populateBundleOperandInfos(ArrayRef<OperandBundleDef> Bundles,\n                                         const unsigned BeginIndex);\n\npublic:\n  /// Return the BundleOpInfo for the operand at index OpIdx.\n  ///\n  /// It is an error to call this with an OpIdx that does not correspond to an\n  /// bundle operand.\n  BundleOpInfo &getBundleOpInfoForOperand(unsigned OpIdx);\n  const BundleOpInfo &getBundleOpInfoForOperand(unsigned OpIdx) const {\n    return const_cast<CallBase *>(this)->getBundleOpInfoForOperand(OpIdx);\n  }\n\nprotected:\n  /// Return the total number of values used in \\p Bundles.\n  static unsigned CountBundleInputs(ArrayRef<OperandBundleDef> Bundles) {\n    unsigned Total = 0;\n    for (auto &B : Bundles)\n      Total += B.input_size();\n    return Total;\n  }\n\n  /// @}\n  // End of operand bundle API.\n\nprivate:\n  bool hasFnAttrOnCalledFunction(Attribute::AttrKind Kind) const;\n  bool hasFnAttrOnCalledFunction(StringRef Kind) const;\n\n  template <typename AttrKind> bool hasFnAttrImpl(AttrKind Kind) const {\n    if (Attrs.hasFnAttribute(Kind))\n      return true;\n\n    // Operand bundles override attributes on the called function, but don't\n    // override attributes directly present on the call instruction.\n    if (isFnAttrDisallowedByOpBundle(Kind))\n      return false;\n\n    return hasFnAttrOnCalledFunction(Kind);\n  }\n\n  /// Determine whether the return value has the given attribute. Supports\n  /// Attribute::AttrKind and StringRef as \\p AttrKind types.\n  template <typename AttrKind> bool hasRetAttrImpl(AttrKind Kind) const {\n    if (Attrs.hasAttribute(AttributeList::ReturnIndex, Kind))\n      return true;\n\n    // Look at the callee, if available.\n    if (const Function *F = getCalledFunction())\n      return F->getAttributes().hasAttribute(AttributeList::ReturnIndex, Kind);\n    return false;\n  }\n};\n\ntemplate <>\nstruct OperandTraits<CallBase> : public VariadicOperandTraits<CallBase, 1> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(CallBase, Value)\n\n//===----------------------------------------------------------------------===//\n//                           FuncletPadInst Class\n//===----------------------------------------------------------------------===//\nclass FuncletPadInst : public Instruction {\nprivate:\n  FuncletPadInst(const FuncletPadInst &CPI);\n\n  explicit FuncletPadInst(Instruction::FuncletPadOps Op, Value *ParentPad,\n                          ArrayRef<Value *> Args, unsigned Values,\n                          const Twine &NameStr, Instruction *InsertBefore);\n  explicit FuncletPadInst(Instruction::FuncletPadOps Op, Value *ParentPad,\n                          ArrayRef<Value *> Args, unsigned Values,\n                          const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  void init(Value *ParentPad, ArrayRef<Value *> Args, const Twine &NameStr);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n  friend class CatchPadInst;\n  friend class CleanupPadInst;\n\n  FuncletPadInst *cloneImpl() const;\n\npublic:\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// getNumArgOperands - Return the number of funcletpad arguments.\n  ///\n  unsigned getNumArgOperands() const { return getNumOperands() - 1; }\n\n  /// Convenience accessors\n\n  /// Return the outer EH-pad this funclet is nested within.\n  ///\n  /// Note: This returns the associated CatchSwitchInst if this FuncletPadInst\n  /// is a CatchPadInst.\n  Value *getParentPad() const { return Op<-1>(); }\n  void setParentPad(Value *ParentPad) {\n    assert(ParentPad);\n    Op<-1>() = ParentPad;\n  }\n\n  /// getArgOperand/setArgOperand - Return/set the i-th funcletpad argument.\n  ///\n  Value *getArgOperand(unsigned i) const { return getOperand(i); }\n  void setArgOperand(unsigned i, Value *v) { setOperand(i, v); }\n\n  /// arg_operands - iteration adapter for range-for loops.\n  op_range arg_operands() { return op_range(op_begin(), op_end() - 1); }\n\n  /// arg_operands - iteration adapter for range-for loops.\n  const_op_range arg_operands() const {\n    return const_op_range(op_begin(), op_end() - 1);\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) { return I->isFuncletPad(); }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<FuncletPadInst>\n    : public VariadicOperandTraits<FuncletPadInst, /*MINARITY=*/1> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(FuncletPadInst, Value)\n\n} // end namespace llvm\n\n#endif // LLVM_IR_INSTRTYPES_H\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "content": "//===- llvm/Instructions.h - Instruction subclass definitions ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file exposes the class definitions of all of the subclasses of the\n// Instruction class.  This is meant to be an easy way to get access to all\n// instruction subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_INSTRUCTIONS_H\n#define LLVM_IR_INSTRUCTIONS_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Bitfields.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/CallingConv.h\"\n#include \"llvm/IR/CFG.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/OperandTraits.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n\nnamespace llvm {\n\nclass APInt;\nclass ConstantInt;\nclass DataLayout;\nclass LLVMContext;\n\n//===----------------------------------------------------------------------===//\n//                                AllocaInst Class\n//===----------------------------------------------------------------------===//\n\n/// an instruction to allocate memory on the stack\nclass AllocaInst : public UnaryInstruction {\n  Type *AllocatedType;\n\n  using AlignmentField = AlignmentBitfieldElementT<0>;\n  using UsedWithInAllocaField = BoolBitfieldElementT<AlignmentField::NextBit>;\n  using SwiftErrorField = BoolBitfieldElementT<UsedWithInAllocaField::NextBit>;\n  static_assert(Bitfield::areContiguous<AlignmentField, UsedWithInAllocaField,\n                                        SwiftErrorField>(),\n                \"Bitfields must be contiguous\");\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  AllocaInst *cloneImpl() const;\n\npublic:\n  explicit AllocaInst(Type *Ty, unsigned AddrSpace, Value *ArraySize,\n                      const Twine &Name, Instruction *InsertBefore);\n  AllocaInst(Type *Ty, unsigned AddrSpace, Value *ArraySize,\n             const Twine &Name, BasicBlock *InsertAtEnd);\n\n  AllocaInst(Type *Ty, unsigned AddrSpace, const Twine &Name,\n             Instruction *InsertBefore);\n  AllocaInst(Type *Ty, unsigned AddrSpace,\n             const Twine &Name, BasicBlock *InsertAtEnd);\n\n  AllocaInst(Type *Ty, unsigned AddrSpace, Value *ArraySize, Align Align,\n             const Twine &Name = \"\", Instruction *InsertBefore = nullptr);\n  AllocaInst(Type *Ty, unsigned AddrSpace, Value *ArraySize, Align Align,\n             const Twine &Name, BasicBlock *InsertAtEnd);\n\n  /// Return true if there is an allocation size parameter to the allocation\n  /// instruction that is not 1.\n  bool isArrayAllocation() const;\n\n  /// Get the number of elements allocated. For a simple allocation of a single\n  /// element, this will return a constant 1 value.\n  const Value *getArraySize() const { return getOperand(0); }\n  Value *getArraySize() { return getOperand(0); }\n\n  /// Overload to return most specific pointer type.\n  PointerType *getType() const {\n    return cast<PointerType>(Instruction::getType());\n  }\n\n  /// Get allocation size in bits. Returns None if size can't be determined,\n  /// e.g. in case of a VLA.\n  Optional<TypeSize> getAllocationSizeInBits(const DataLayout &DL) const;\n\n  /// Return the type that is being allocated by the instruction.\n  Type *getAllocatedType() const { return AllocatedType; }\n  /// for use only in special circumstances that need to generically\n  /// transform a whole instruction (eg: IR linking and vectorization).\n  void setAllocatedType(Type *Ty) { AllocatedType = Ty; }\n\n  /// Return the alignment of the memory that is being allocated by the\n  /// instruction.\n  Align getAlign() const {\n    return Align(1ULL << getSubclassData<AlignmentField>());\n  }\n\n  void setAlignment(Align Align) {\n    setSubclassData<AlignmentField>(Log2(Align));\n  }\n\n  // FIXME: Remove this one transition to Align is over.\n  unsigned getAlignment() const { return getAlign().value(); }\n\n  /// Return true if this alloca is in the entry block of the function and is a\n  /// constant size. If so, the code generator will fold it into the\n  /// prolog/epilog code, so it is basically free.\n  bool isStaticAlloca() const;\n\n  /// Return true if this alloca is used as an inalloca argument to a call. Such\n  /// allocas are never considered static even if they are in the entry block.\n  bool isUsedWithInAlloca() const {\n    return getSubclassData<UsedWithInAllocaField>();\n  }\n\n  /// Specify whether this alloca is used to represent the arguments to a call.\n  void setUsedWithInAlloca(bool V) {\n    setSubclassData<UsedWithInAllocaField>(V);\n  }\n\n  /// Return true if this alloca is used as a swifterror argument to a call.\n  bool isSwiftError() const { return getSubclassData<SwiftErrorField>(); }\n  /// Specify whether this alloca is used to represent a swifterror.\n  void setSwiftError(bool V) { setSubclassData<SwiftErrorField>(V); }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return (I->getOpcode() == Instruction::Alloca);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                LoadInst Class\n//===----------------------------------------------------------------------===//\n\n/// An instruction for reading from memory. This uses the SubclassData field in\n/// Value to store whether or not the load is volatile.\nclass LoadInst : public UnaryInstruction {\n  using VolatileField = BoolBitfieldElementT<0>;\n  using AlignmentField = AlignmentBitfieldElementT<VolatileField::NextBit>;\n  using OrderingField = AtomicOrderingBitfieldElementT<AlignmentField::NextBit>;\n  static_assert(\n      Bitfield::areContiguous<VolatileField, AlignmentField, OrderingField>(),\n      \"Bitfields must be contiguous\");\n\n  void AssertOK();\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  LoadInst *cloneImpl() const;\n\npublic:\n  LoadInst(Type *Ty, Value *Ptr, const Twine &NameStr,\n           Instruction *InsertBefore);\n  LoadInst(Type *Ty, Value *Ptr, const Twine &NameStr, BasicBlock *InsertAtEnd);\n  LoadInst(Type *Ty, Value *Ptr, const Twine &NameStr, bool isVolatile,\n           Instruction *InsertBefore);\n  LoadInst(Type *Ty, Value *Ptr, const Twine &NameStr, bool isVolatile,\n           BasicBlock *InsertAtEnd);\n  LoadInst(Type *Ty, Value *Ptr, const Twine &NameStr, bool isVolatile,\n           Align Align, Instruction *InsertBefore = nullptr);\n  LoadInst(Type *Ty, Value *Ptr, const Twine &NameStr, bool isVolatile,\n           Align Align, BasicBlock *InsertAtEnd);\n  LoadInst(Type *Ty, Value *Ptr, const Twine &NameStr, bool isVolatile,\n           Align Align, AtomicOrdering Order,\n           SyncScope::ID SSID = SyncScope::System,\n           Instruction *InsertBefore = nullptr);\n  LoadInst(Type *Ty, Value *Ptr, const Twine &NameStr, bool isVolatile,\n           Align Align, AtomicOrdering Order, SyncScope::ID SSID,\n           BasicBlock *InsertAtEnd);\n\n  /// Return true if this is a load from a volatile memory location.\n  bool isVolatile() const { return getSubclassData<VolatileField>(); }\n\n  /// Specify whether this is a volatile load or not.\n  void setVolatile(bool V) { setSubclassData<VolatileField>(V); }\n\n  /// Return the alignment of the access that is being performed.\n  /// FIXME: Remove this function once transition to Align is over.\n  /// Use getAlign() instead.\n  unsigned getAlignment() const { return getAlign().value(); }\n\n  /// Return the alignment of the access that is being performed.\n  Align getAlign() const {\n    return Align(1ULL << (getSubclassData<AlignmentField>()));\n  }\n\n  void setAlignment(Align Align) {\n    setSubclassData<AlignmentField>(Log2(Align));\n  }\n\n  /// Returns the ordering constraint of this load instruction.\n  AtomicOrdering getOrdering() const {\n    return getSubclassData<OrderingField>();\n  }\n  /// Sets the ordering constraint of this load instruction.  May not be Release\n  /// or AcquireRelease.\n  void setOrdering(AtomicOrdering Ordering) {\n    setSubclassData<OrderingField>(Ordering);\n  }\n\n  /// Returns the synchronization scope ID of this load instruction.\n  SyncScope::ID getSyncScopeID() const {\n    return SSID;\n  }\n\n  /// Sets the synchronization scope ID of this load instruction.\n  void setSyncScopeID(SyncScope::ID SSID) {\n    this->SSID = SSID;\n  }\n\n  /// Sets the ordering constraint and the synchronization scope ID of this load\n  /// instruction.\n  void setAtomic(AtomicOrdering Ordering,\n                 SyncScope::ID SSID = SyncScope::System) {\n    setOrdering(Ordering);\n    setSyncScopeID(SSID);\n  }\n\n  bool isSimple() const { return !isAtomic() && !isVolatile(); }\n\n  bool isUnordered() const {\n    return (getOrdering() == AtomicOrdering::NotAtomic ||\n            getOrdering() == AtomicOrdering::Unordered) &&\n           !isVolatile();\n  }\n\n  Value *getPointerOperand() { return getOperand(0); }\n  const Value *getPointerOperand() const { return getOperand(0); }\n  static unsigned getPointerOperandIndex() { return 0U; }\n  Type *getPointerOperandType() const { return getPointerOperand()->getType(); }\n\n  /// Returns the address space of the pointer operand.\n  unsigned getPointerAddressSpace() const {\n    return getPointerOperandType()->getPointerAddressSpace();\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Load;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n\n  /// The synchronization scope ID of this load instruction.  Not quite enough\n  /// room in SubClassData for everything, so synchronization scope ID gets its\n  /// own field.\n  SyncScope::ID SSID;\n};\n\n//===----------------------------------------------------------------------===//\n//                                StoreInst Class\n//===----------------------------------------------------------------------===//\n\n/// An instruction for storing to memory.\nclass StoreInst : public Instruction {\n  using VolatileField = BoolBitfieldElementT<0>;\n  using AlignmentField = AlignmentBitfieldElementT<VolatileField::NextBit>;\n  using OrderingField = AtomicOrderingBitfieldElementT<AlignmentField::NextBit>;\n  static_assert(\n      Bitfield::areContiguous<VolatileField, AlignmentField, OrderingField>(),\n      \"Bitfields must be contiguous\");\n\n  void AssertOK();\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  StoreInst *cloneImpl() const;\n\npublic:\n  StoreInst(Value *Val, Value *Ptr, Instruction *InsertBefore);\n  StoreInst(Value *Val, Value *Ptr, BasicBlock *InsertAtEnd);\n  StoreInst(Value *Val, Value *Ptr, bool isVolatile, Instruction *InsertBefore);\n  StoreInst(Value *Val, Value *Ptr, bool isVolatile, BasicBlock *InsertAtEnd);\n  StoreInst(Value *Val, Value *Ptr, bool isVolatile, Align Align,\n            Instruction *InsertBefore = nullptr);\n  StoreInst(Value *Val, Value *Ptr, bool isVolatile, Align Align,\n            BasicBlock *InsertAtEnd);\n  StoreInst(Value *Val, Value *Ptr, bool isVolatile, Align Align,\n            AtomicOrdering Order, SyncScope::ID SSID = SyncScope::System,\n            Instruction *InsertBefore = nullptr);\n  StoreInst(Value *Val, Value *Ptr, bool isVolatile, Align Align,\n            AtomicOrdering Order, SyncScope::ID SSID, BasicBlock *InsertAtEnd);\n\n  // allocate space for exactly two operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 2);\n  }\n\n  /// Return true if this is a store to a volatile memory location.\n  bool isVolatile() const { return getSubclassData<VolatileField>(); }\n\n  /// Specify whether this is a volatile store or not.\n  void setVolatile(bool V) { setSubclassData<VolatileField>(V); }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Return the alignment of the access that is being performed\n  /// FIXME: Remove this function once transition to Align is over.\n  /// Use getAlign() instead.\n  unsigned getAlignment() const { return getAlign().value(); }\n\n  Align getAlign() const {\n    return Align(1ULL << (getSubclassData<AlignmentField>()));\n  }\n\n  void setAlignment(Align Align) {\n    setSubclassData<AlignmentField>(Log2(Align));\n  }\n\n  /// Returns the ordering constraint of this store instruction.\n  AtomicOrdering getOrdering() const {\n    return getSubclassData<OrderingField>();\n  }\n\n  /// Sets the ordering constraint of this store instruction.  May not be\n  /// Acquire or AcquireRelease.\n  void setOrdering(AtomicOrdering Ordering) {\n    setSubclassData<OrderingField>(Ordering);\n  }\n\n  /// Returns the synchronization scope ID of this store instruction.\n  SyncScope::ID getSyncScopeID() const {\n    return SSID;\n  }\n\n  /// Sets the synchronization scope ID of this store instruction.\n  void setSyncScopeID(SyncScope::ID SSID) {\n    this->SSID = SSID;\n  }\n\n  /// Sets the ordering constraint and the synchronization scope ID of this\n  /// store instruction.\n  void setAtomic(AtomicOrdering Ordering,\n                 SyncScope::ID SSID = SyncScope::System) {\n    setOrdering(Ordering);\n    setSyncScopeID(SSID);\n  }\n\n  bool isSimple() const { return !isAtomic() && !isVolatile(); }\n\n  bool isUnordered() const {\n    return (getOrdering() == AtomicOrdering::NotAtomic ||\n            getOrdering() == AtomicOrdering::Unordered) &&\n           !isVolatile();\n  }\n\n  Value *getValueOperand() { return getOperand(0); }\n  const Value *getValueOperand() const { return getOperand(0); }\n\n  Value *getPointerOperand() { return getOperand(1); }\n  const Value *getPointerOperand() const { return getOperand(1); }\n  static unsigned getPointerOperandIndex() { return 1U; }\n  Type *getPointerOperandType() const { return getPointerOperand()->getType(); }\n\n  /// Returns the address space of the pointer operand.\n  unsigned getPointerAddressSpace() const {\n    return getPointerOperandType()->getPointerAddressSpace();\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Store;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n\n  /// The synchronization scope ID of this store instruction.  Not quite enough\n  /// room in SubClassData for everything, so synchronization scope ID gets its\n  /// own field.\n  SyncScope::ID SSID;\n};\n\ntemplate <>\nstruct OperandTraits<StoreInst> : public FixedNumOperandTraits<StoreInst, 2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(StoreInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                                FenceInst Class\n//===----------------------------------------------------------------------===//\n\n/// An instruction for ordering other memory operations.\nclass FenceInst : public Instruction {\n  using OrderingField = AtomicOrderingBitfieldElementT<0>;\n\n  void Init(AtomicOrdering Ordering, SyncScope::ID SSID);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  FenceInst *cloneImpl() const;\n\npublic:\n  // Ordering may only be Acquire, Release, AcquireRelease, or\n  // SequentiallyConsistent.\n  FenceInst(LLVMContext &C, AtomicOrdering Ordering,\n            SyncScope::ID SSID = SyncScope::System,\n            Instruction *InsertBefore = nullptr);\n  FenceInst(LLVMContext &C, AtomicOrdering Ordering, SyncScope::ID SSID,\n            BasicBlock *InsertAtEnd);\n\n  // allocate space for exactly zero operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 0);\n  }\n\n  /// Returns the ordering constraint of this fence instruction.\n  AtomicOrdering getOrdering() const {\n    return getSubclassData<OrderingField>();\n  }\n\n  /// Sets the ordering constraint of this fence instruction.  May only be\n  /// Acquire, Release, AcquireRelease, or SequentiallyConsistent.\n  void setOrdering(AtomicOrdering Ordering) {\n    setSubclassData<OrderingField>(Ordering);\n  }\n\n  /// Returns the synchronization scope ID of this fence instruction.\n  SyncScope::ID getSyncScopeID() const {\n    return SSID;\n  }\n\n  /// Sets the synchronization scope ID of this fence instruction.\n  void setSyncScopeID(SyncScope::ID SSID) {\n    this->SSID = SSID;\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Fence;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n\n  /// The synchronization scope ID of this fence instruction.  Not quite enough\n  /// room in SubClassData for everything, so synchronization scope ID gets its\n  /// own field.\n  SyncScope::ID SSID;\n};\n\n//===----------------------------------------------------------------------===//\n//                                AtomicCmpXchgInst Class\n//===----------------------------------------------------------------------===//\n\n/// An instruction that atomically checks whether a\n/// specified value is in a memory location, and, if it is, stores a new value\n/// there. The value returned by this instruction is a pair containing the\n/// original value as first element, and an i1 indicating success (true) or\n/// failure (false) as second element.\n///\nclass AtomicCmpXchgInst : public Instruction {\n  void Init(Value *Ptr, Value *Cmp, Value *NewVal, Align Align,\n            AtomicOrdering SuccessOrdering, AtomicOrdering FailureOrdering,\n            SyncScope::ID SSID);\n\n  template <unsigned Offset>\n  using AtomicOrderingBitfieldElement =\n      typename Bitfield::Element<AtomicOrdering, Offset, 3,\n                                 AtomicOrdering::LAST>;\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  AtomicCmpXchgInst *cloneImpl() const;\n\npublic:\n  AtomicCmpXchgInst(Value *Ptr, Value *Cmp, Value *NewVal, Align Alignment,\n                    AtomicOrdering SuccessOrdering,\n                    AtomicOrdering FailureOrdering, SyncScope::ID SSID,\n                    Instruction *InsertBefore = nullptr);\n  AtomicCmpXchgInst(Value *Ptr, Value *Cmp, Value *NewVal, Align Alignment,\n                    AtomicOrdering SuccessOrdering,\n                    AtomicOrdering FailureOrdering, SyncScope::ID SSID,\n                    BasicBlock *InsertAtEnd);\n\n  // allocate space for exactly three operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 3);\n  }\n\n  using VolatileField = BoolBitfieldElementT<0>;\n  using WeakField = BoolBitfieldElementT<VolatileField::NextBit>;\n  using SuccessOrderingField =\n      AtomicOrderingBitfieldElementT<WeakField::NextBit>;\n  using FailureOrderingField =\n      AtomicOrderingBitfieldElementT<SuccessOrderingField::NextBit>;\n  using AlignmentField =\n      AlignmentBitfieldElementT<FailureOrderingField::NextBit>;\n  static_assert(\n      Bitfield::areContiguous<VolatileField, WeakField, SuccessOrderingField,\n                              FailureOrderingField, AlignmentField>(),\n      \"Bitfields must be contiguous\");\n\n  /// Return the alignment of the memory that is being allocated by the\n  /// instruction.\n  Align getAlign() const {\n    return Align(1ULL << getSubclassData<AlignmentField>());\n  }\n\n  void setAlignment(Align Align) {\n    setSubclassData<AlignmentField>(Log2(Align));\n  }\n\n  /// Return true if this is a cmpxchg from a volatile memory\n  /// location.\n  ///\n  bool isVolatile() const { return getSubclassData<VolatileField>(); }\n\n  /// Specify whether this is a volatile cmpxchg.\n  ///\n  void setVolatile(bool V) { setSubclassData<VolatileField>(V); }\n\n  /// Return true if this cmpxchg may spuriously fail.\n  bool isWeak() const { return getSubclassData<WeakField>(); }\n\n  void setWeak(bool IsWeak) { setSubclassData<WeakField>(IsWeak); }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Returns the success ordering constraint of this cmpxchg instruction.\n  AtomicOrdering getSuccessOrdering() const {\n    return getSubclassData<SuccessOrderingField>();\n  }\n\n  /// Sets the success ordering constraint of this cmpxchg instruction.\n  void setSuccessOrdering(AtomicOrdering Ordering) {\n    assert(Ordering != AtomicOrdering::NotAtomic &&\n           \"CmpXchg instructions can only be atomic.\");\n    setSubclassData<SuccessOrderingField>(Ordering);\n  }\n\n  /// Returns the failure ordering constraint of this cmpxchg instruction.\n  AtomicOrdering getFailureOrdering() const {\n    return getSubclassData<FailureOrderingField>();\n  }\n\n  /// Sets the failure ordering constraint of this cmpxchg instruction.\n  void setFailureOrdering(AtomicOrdering Ordering) {\n    assert(Ordering != AtomicOrdering::NotAtomic &&\n           \"CmpXchg instructions can only be atomic.\");\n    setSubclassData<FailureOrderingField>(Ordering);\n  }\n\n  /// Returns the synchronization scope ID of this cmpxchg instruction.\n  SyncScope::ID getSyncScopeID() const {\n    return SSID;\n  }\n\n  /// Sets the synchronization scope ID of this cmpxchg instruction.\n  void setSyncScopeID(SyncScope::ID SSID) {\n    this->SSID = SSID;\n  }\n\n  Value *getPointerOperand() { return getOperand(0); }\n  const Value *getPointerOperand() const { return getOperand(0); }\n  static unsigned getPointerOperandIndex() { return 0U; }\n\n  Value *getCompareOperand() { return getOperand(1); }\n  const Value *getCompareOperand() const { return getOperand(1); }\n\n  Value *getNewValOperand() { return getOperand(2); }\n  const Value *getNewValOperand() const { return getOperand(2); }\n\n  /// Returns the address space of the pointer operand.\n  unsigned getPointerAddressSpace() const {\n    return getPointerOperand()->getType()->getPointerAddressSpace();\n  }\n\n  /// Returns the strongest permitted ordering on failure, given the\n  /// desired ordering on success.\n  ///\n  /// If the comparison in a cmpxchg operation fails, there is no atomic store\n  /// so release semantics cannot be provided. So this function drops explicit\n  /// Release requests from the AtomicOrdering. A SequentiallyConsistent\n  /// operation would remain SequentiallyConsistent.\n  static AtomicOrdering\n  getStrongestFailureOrdering(AtomicOrdering SuccessOrdering) {\n    switch (SuccessOrdering) {\n    default:\n      llvm_unreachable(\"invalid cmpxchg success ordering\");\n    case AtomicOrdering::Release:\n    case AtomicOrdering::Monotonic:\n      return AtomicOrdering::Monotonic;\n    case AtomicOrdering::AcquireRelease:\n    case AtomicOrdering::Acquire:\n      return AtomicOrdering::Acquire;\n    case AtomicOrdering::SequentiallyConsistent:\n      return AtomicOrdering::SequentiallyConsistent;\n    }\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::AtomicCmpXchg;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n\n  /// The synchronization scope ID of this cmpxchg instruction.  Not quite\n  /// enough room in SubClassData for everything, so synchronization scope ID\n  /// gets its own field.\n  SyncScope::ID SSID;\n};\n\ntemplate <>\nstruct OperandTraits<AtomicCmpXchgInst> :\n    public FixedNumOperandTraits<AtomicCmpXchgInst, 3> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(AtomicCmpXchgInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                                AtomicRMWInst Class\n//===----------------------------------------------------------------------===//\n\n/// an instruction that atomically reads a memory location,\n/// combines it with another value, and then stores the result back.  Returns\n/// the old value.\n///\nclass AtomicRMWInst : public Instruction {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  AtomicRMWInst *cloneImpl() const;\n\npublic:\n  /// This enumeration lists the possible modifications atomicrmw can make.  In\n  /// the descriptions, 'p' is the pointer to the instruction's memory location,\n  /// 'old' is the initial value of *p, and 'v' is the other value passed to the\n  /// instruction.  These instructions always return 'old'.\n  enum BinOp : unsigned {\n    /// *p = v\n    Xchg,\n    /// *p = old + v\n    Add,\n    /// *p = old - v\n    Sub,\n    /// *p = old & v\n    And,\n    /// *p = ~(old & v)\n    Nand,\n    /// *p = old | v\n    Or,\n    /// *p = old ^ v\n    Xor,\n    /// *p = old >signed v ? old : v\n    Max,\n    /// *p = old <signed v ? old : v\n    Min,\n    /// *p = old >unsigned v ? old : v\n    UMax,\n    /// *p = old <unsigned v ? old : v\n    UMin,\n\n    /// *p = old + v\n    FAdd,\n\n    /// *p = old - v\n    FSub,\n\n    FIRST_BINOP = Xchg,\n    LAST_BINOP = FSub,\n    BAD_BINOP\n  };\n\nprivate:\n  template <unsigned Offset>\n  using AtomicOrderingBitfieldElement =\n      typename Bitfield::Element<AtomicOrdering, Offset, 3,\n                                 AtomicOrdering::LAST>;\n\n  template <unsigned Offset>\n  using BinOpBitfieldElement =\n      typename Bitfield::Element<BinOp, Offset, 4, BinOp::LAST_BINOP>;\n\npublic:\n  AtomicRMWInst(BinOp Operation, Value *Ptr, Value *Val, Align Alignment,\n                AtomicOrdering Ordering, SyncScope::ID SSID,\n                Instruction *InsertBefore = nullptr);\n  AtomicRMWInst(BinOp Operation, Value *Ptr, Value *Val, Align Alignment,\n                AtomicOrdering Ordering, SyncScope::ID SSID,\n                BasicBlock *InsertAtEnd);\n\n  // allocate space for exactly two operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 2);\n  }\n\n  using VolatileField = BoolBitfieldElementT<0>;\n  using AtomicOrderingField =\n      AtomicOrderingBitfieldElementT<VolatileField::NextBit>;\n  using OperationField = BinOpBitfieldElement<AtomicOrderingField::NextBit>;\n  using AlignmentField = AlignmentBitfieldElementT<OperationField::NextBit>;\n  static_assert(Bitfield::areContiguous<VolatileField, AtomicOrderingField,\n                                        OperationField, AlignmentField>(),\n                \"Bitfields must be contiguous\");\n\n  BinOp getOperation() const { return getSubclassData<OperationField>(); }\n\n  static StringRef getOperationName(BinOp Op);\n\n  static bool isFPOperation(BinOp Op) {\n    switch (Op) {\n    case AtomicRMWInst::FAdd:\n    case AtomicRMWInst::FSub:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  void setOperation(BinOp Operation) {\n    setSubclassData<OperationField>(Operation);\n  }\n\n  /// Return the alignment of the memory that is being allocated by the\n  /// instruction.\n  Align getAlign() const {\n    return Align(1ULL << getSubclassData<AlignmentField>());\n  }\n\n  void setAlignment(Align Align) {\n    setSubclassData<AlignmentField>(Log2(Align));\n  }\n\n  /// Return true if this is a RMW on a volatile memory location.\n  ///\n  bool isVolatile() const { return getSubclassData<VolatileField>(); }\n\n  /// Specify whether this is a volatile RMW or not.\n  ///\n  void setVolatile(bool V) { setSubclassData<VolatileField>(V); }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Returns the ordering constraint of this rmw instruction.\n  AtomicOrdering getOrdering() const {\n    return getSubclassData<AtomicOrderingField>();\n  }\n\n  /// Sets the ordering constraint of this rmw instruction.\n  void setOrdering(AtomicOrdering Ordering) {\n    assert(Ordering != AtomicOrdering::NotAtomic &&\n           \"atomicrmw instructions can only be atomic.\");\n    setSubclassData<AtomicOrderingField>(Ordering);\n  }\n\n  /// Returns the synchronization scope ID of this rmw instruction.\n  SyncScope::ID getSyncScopeID() const {\n    return SSID;\n  }\n\n  /// Sets the synchronization scope ID of this rmw instruction.\n  void setSyncScopeID(SyncScope::ID SSID) {\n    this->SSID = SSID;\n  }\n\n  Value *getPointerOperand() { return getOperand(0); }\n  const Value *getPointerOperand() const { return getOperand(0); }\n  static unsigned getPointerOperandIndex() { return 0U; }\n\n  Value *getValOperand() { return getOperand(1); }\n  const Value *getValOperand() const { return getOperand(1); }\n\n  /// Returns the address space of the pointer operand.\n  unsigned getPointerAddressSpace() const {\n    return getPointerOperand()->getType()->getPointerAddressSpace();\n  }\n\n  bool isFloatingPointOperation() const {\n    return isFPOperation(getOperation());\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::AtomicRMW;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  void Init(BinOp Operation, Value *Ptr, Value *Val, Align Align,\n            AtomicOrdering Ordering, SyncScope::ID SSID);\n\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n\n  /// The synchronization scope ID of this rmw instruction.  Not quite enough\n  /// room in SubClassData for everything, so synchronization scope ID gets its\n  /// own field.\n  SyncScope::ID SSID;\n};\n\ntemplate <>\nstruct OperandTraits<AtomicRMWInst>\n    : public FixedNumOperandTraits<AtomicRMWInst,2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(AtomicRMWInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                             GetElementPtrInst Class\n//===----------------------------------------------------------------------===//\n\n// checkGEPType - Simple wrapper function to give a better assertion failure\n// message on bad indexes for a gep instruction.\n//\ninline Type *checkGEPType(Type *Ty) {\n  assert(Ty && \"Invalid GetElementPtrInst indices for type!\");\n  return Ty;\n}\n\n/// an instruction for type-safe pointer arithmetic to\n/// access elements of arrays and structs\n///\nclass GetElementPtrInst : public Instruction {\n  Type *SourceElementType;\n  Type *ResultElementType;\n\n  GetElementPtrInst(const GetElementPtrInst &GEPI);\n\n  /// Constructors - Create a getelementptr instruction with a base pointer an\n  /// list of indices. The first ctor can optionally insert before an existing\n  /// instruction, the second appends the new instruction to the specified\n  /// BasicBlock.\n  inline GetElementPtrInst(Type *PointeeType, Value *Ptr,\n                           ArrayRef<Value *> IdxList, unsigned Values,\n                           const Twine &NameStr, Instruction *InsertBefore);\n  inline GetElementPtrInst(Type *PointeeType, Value *Ptr,\n                           ArrayRef<Value *> IdxList, unsigned Values,\n                           const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  void init(Value *Ptr, ArrayRef<Value *> IdxList, const Twine &NameStr);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  GetElementPtrInst *cloneImpl() const;\n\npublic:\n  static GetElementPtrInst *Create(Type *PointeeType, Value *Ptr,\n                                   ArrayRef<Value *> IdxList,\n                                   const Twine &NameStr = \"\",\n                                   Instruction *InsertBefore = nullptr) {\n    unsigned Values = 1 + unsigned(IdxList.size());\n    if (!PointeeType)\n      PointeeType =\n          cast<PointerType>(Ptr->getType()->getScalarType())->getElementType();\n    else\n      assert(\n          PointeeType ==\n          cast<PointerType>(Ptr->getType()->getScalarType())->getElementType());\n    return new (Values) GetElementPtrInst(PointeeType, Ptr, IdxList, Values,\n                                          NameStr, InsertBefore);\n  }\n\n  static GetElementPtrInst *Create(Type *PointeeType, Value *Ptr,\n                                   ArrayRef<Value *> IdxList,\n                                   const Twine &NameStr,\n                                   BasicBlock *InsertAtEnd) {\n    unsigned Values = 1 + unsigned(IdxList.size());\n    if (!PointeeType)\n      PointeeType =\n          cast<PointerType>(Ptr->getType()->getScalarType())->getElementType();\n    else\n      assert(\n          PointeeType ==\n          cast<PointerType>(Ptr->getType()->getScalarType())->getElementType());\n    return new (Values) GetElementPtrInst(PointeeType, Ptr, IdxList, Values,\n                                          NameStr, InsertAtEnd);\n  }\n\n  /// Create an \"inbounds\" getelementptr. See the documentation for the\n  /// \"inbounds\" flag in LangRef.html for details.\n  static GetElementPtrInst *CreateInBounds(Value *Ptr,\n                                           ArrayRef<Value *> IdxList,\n                                           const Twine &NameStr = \"\",\n                                           Instruction *InsertBefore = nullptr){\n    return CreateInBounds(nullptr, Ptr, IdxList, NameStr, InsertBefore);\n  }\n\n  static GetElementPtrInst *\n  CreateInBounds(Type *PointeeType, Value *Ptr, ArrayRef<Value *> IdxList,\n                 const Twine &NameStr = \"\",\n                 Instruction *InsertBefore = nullptr) {\n    GetElementPtrInst *GEP =\n        Create(PointeeType, Ptr, IdxList, NameStr, InsertBefore);\n    GEP->setIsInBounds(true);\n    return GEP;\n  }\n\n  static GetElementPtrInst *CreateInBounds(Value *Ptr,\n                                           ArrayRef<Value *> IdxList,\n                                           const Twine &NameStr,\n                                           BasicBlock *InsertAtEnd) {\n    return CreateInBounds(nullptr, Ptr, IdxList, NameStr, InsertAtEnd);\n  }\n\n  static GetElementPtrInst *CreateInBounds(Type *PointeeType, Value *Ptr,\n                                           ArrayRef<Value *> IdxList,\n                                           const Twine &NameStr,\n                                           BasicBlock *InsertAtEnd) {\n    GetElementPtrInst *GEP =\n        Create(PointeeType, Ptr, IdxList, NameStr, InsertAtEnd);\n    GEP->setIsInBounds(true);\n    return GEP;\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  Type *getSourceElementType() const { return SourceElementType; }\n\n  void setSourceElementType(Type *Ty) { SourceElementType = Ty; }\n  void setResultElementType(Type *Ty) { ResultElementType = Ty; }\n\n  Type *getResultElementType() const {\n    assert(ResultElementType ==\n           cast<PointerType>(getType()->getScalarType())->getElementType());\n    return ResultElementType;\n  }\n\n  /// Returns the address space of this instruction's pointer type.\n  unsigned getAddressSpace() const {\n    // Note that this is always the same as the pointer operand's address space\n    // and that is cheaper to compute, so cheat here.\n    return getPointerAddressSpace();\n  }\n\n  /// Returns the result type of a getelementptr with the given source\n  /// element type and indexes.\n  ///\n  /// Null is returned if the indices are invalid for the specified\n  /// source element type.\n  static Type *getIndexedType(Type *Ty, ArrayRef<Value *> IdxList);\n  static Type *getIndexedType(Type *Ty, ArrayRef<Constant *> IdxList);\n  static Type *getIndexedType(Type *Ty, ArrayRef<uint64_t> IdxList);\n\n  /// Return the type of the element at the given index of an indexable\n  /// type.  This is equivalent to \"getIndexedType(Agg, {Zero, Idx})\".\n  ///\n  /// Returns null if the type can't be indexed, or the given index is not\n  /// legal for the given type.\n  static Type *getTypeAtIndex(Type *Ty, Value *Idx);\n  static Type *getTypeAtIndex(Type *Ty, uint64_t Idx);\n\n  inline op_iterator       idx_begin()       { return op_begin()+1; }\n  inline const_op_iterator idx_begin() const { return op_begin()+1; }\n  inline op_iterator       idx_end()         { return op_end(); }\n  inline const_op_iterator idx_end()   const { return op_end(); }\n\n  inline iterator_range<op_iterator> indices() {\n    return make_range(idx_begin(), idx_end());\n  }\n\n  inline iterator_range<const_op_iterator> indices() const {\n    return make_range(idx_begin(), idx_end());\n  }\n\n  Value *getPointerOperand() {\n    return getOperand(0);\n  }\n  const Value *getPointerOperand() const {\n    return getOperand(0);\n  }\n  static unsigned getPointerOperandIndex() {\n    return 0U;    // get index for modifying correct operand.\n  }\n\n  /// Method to return the pointer operand as a\n  /// PointerType.\n  Type *getPointerOperandType() const {\n    return getPointerOperand()->getType();\n  }\n\n  /// Returns the address space of the pointer operand.\n  unsigned getPointerAddressSpace() const {\n    return getPointerOperandType()->getPointerAddressSpace();\n  }\n\n  /// Returns the pointer type returned by the GEP\n  /// instruction, which may be a vector of pointers.\n  static Type *getGEPReturnType(Type *ElTy, Value *Ptr,\n                                ArrayRef<Value *> IdxList) {\n    Type *PtrTy = PointerType::get(checkGEPType(getIndexedType(ElTy, IdxList)),\n                                   Ptr->getType()->getPointerAddressSpace());\n    // Vector GEP\n    if (auto *PtrVTy = dyn_cast<VectorType>(Ptr->getType())) {\n      ElementCount EltCount = PtrVTy->getElementCount();\n      return VectorType::get(PtrTy, EltCount);\n    }\n    for (Value *Index : IdxList)\n      if (auto *IndexVTy = dyn_cast<VectorType>(Index->getType())) {\n        ElementCount EltCount = IndexVTy->getElementCount();\n        return VectorType::get(PtrTy, EltCount);\n      }\n    // Scalar GEP\n    return PtrTy;\n  }\n\n  unsigned getNumIndices() const {  // Note: always non-negative\n    return getNumOperands() - 1;\n  }\n\n  bool hasIndices() const {\n    return getNumOperands() > 1;\n  }\n\n  /// Return true if all of the indices of this GEP are\n  /// zeros.  If so, the result pointer and the first operand have the same\n  /// value, just potentially different types.\n  bool hasAllZeroIndices() const;\n\n  /// Return true if all of the indices of this GEP are\n  /// constant integers.  If so, the result pointer and the first operand have\n  /// a constant offset between them.\n  bool hasAllConstantIndices() const;\n\n  /// Set or clear the inbounds flag on this GEP instruction.\n  /// See LangRef.html for the meaning of inbounds on a getelementptr.\n  void setIsInBounds(bool b = true);\n\n  /// Determine whether the GEP has the inbounds flag.\n  bool isInBounds() const;\n\n  /// Accumulate the constant address offset of this GEP if possible.\n  ///\n  /// This routine accepts an APInt into which it will accumulate the constant\n  /// offset of this GEP if the GEP is in fact constant. If the GEP is not\n  /// all-constant, it returns false and the value of the offset APInt is\n  /// undefined (it is *not* preserved!). The APInt passed into this routine\n  /// must be at least as wide as the IntPtr type for the address space of\n  /// the base GEP pointer.\n  bool accumulateConstantOffset(const DataLayout &DL, APInt &Offset) const;\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return (I->getOpcode() == Instruction::GetElementPtr);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<GetElementPtrInst> :\n  public VariadicOperandTraits<GetElementPtrInst, 1> {\n};\n\nGetElementPtrInst::GetElementPtrInst(Type *PointeeType, Value *Ptr,\n                                     ArrayRef<Value *> IdxList, unsigned Values,\n                                     const Twine &NameStr,\n                                     Instruction *InsertBefore)\n    : Instruction(getGEPReturnType(PointeeType, Ptr, IdxList), GetElementPtr,\n                  OperandTraits<GetElementPtrInst>::op_end(this) - Values,\n                  Values, InsertBefore),\n      SourceElementType(PointeeType),\n      ResultElementType(getIndexedType(PointeeType, IdxList)) {\n  assert(ResultElementType ==\n         cast<PointerType>(getType()->getScalarType())->getElementType());\n  init(Ptr, IdxList, NameStr);\n}\n\nGetElementPtrInst::GetElementPtrInst(Type *PointeeType, Value *Ptr,\n                                     ArrayRef<Value *> IdxList, unsigned Values,\n                                     const Twine &NameStr,\n                                     BasicBlock *InsertAtEnd)\n    : Instruction(getGEPReturnType(PointeeType, Ptr, IdxList), GetElementPtr,\n                  OperandTraits<GetElementPtrInst>::op_end(this) - Values,\n                  Values, InsertAtEnd),\n      SourceElementType(PointeeType),\n      ResultElementType(getIndexedType(PointeeType, IdxList)) {\n  assert(ResultElementType ==\n         cast<PointerType>(getType()->getScalarType())->getElementType());\n  init(Ptr, IdxList, NameStr);\n}\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(GetElementPtrInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                               ICmpInst Class\n//===----------------------------------------------------------------------===//\n\n/// This instruction compares its operands according to the predicate given\n/// to the constructor. It only operates on integers or pointers. The operands\n/// must be identical types.\n/// Represent an integer comparison operator.\nclass ICmpInst: public CmpInst {\n  void AssertOK() {\n    assert(isIntPredicate() &&\n           \"Invalid ICmp predicate value\");\n    assert(getOperand(0)->getType() == getOperand(1)->getType() &&\n          \"Both operands to ICmp instruction are not of the same type!\");\n    // Check that the operands are the right type\n    assert((getOperand(0)->getType()->isIntOrIntVectorTy() ||\n            getOperand(0)->getType()->isPtrOrPtrVectorTy()) &&\n           \"Invalid operand types for ICmp instruction\");\n  }\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical ICmpInst\n  ICmpInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics.\n  ICmpInst(\n    Instruction *InsertBefore,  ///< Where to insert\n    Predicate pred,  ///< The predicate to use for the comparison\n    Value *LHS,      ///< The left-hand-side of the expression\n    Value *RHS,      ///< The right-hand-side of the expression\n    const Twine &NameStr = \"\"  ///< Name of the instruction\n  ) : CmpInst(makeCmpResultType(LHS->getType()),\n              Instruction::ICmp, pred, LHS, RHS, NameStr,\n              InsertBefore) {\n#ifndef NDEBUG\n  AssertOK();\n#endif\n  }\n\n  /// Constructor with insert-at-end semantics.\n  ICmpInst(\n    BasicBlock &InsertAtEnd, ///< Block to insert into.\n    Predicate pred,  ///< The predicate to use for the comparison\n    Value *LHS,      ///< The left-hand-side of the expression\n    Value *RHS,      ///< The right-hand-side of the expression\n    const Twine &NameStr = \"\"  ///< Name of the instruction\n  ) : CmpInst(makeCmpResultType(LHS->getType()),\n              Instruction::ICmp, pred, LHS, RHS, NameStr,\n              &InsertAtEnd) {\n#ifndef NDEBUG\n  AssertOK();\n#endif\n  }\n\n  /// Constructor with no-insertion semantics\n  ICmpInst(\n    Predicate pred, ///< The predicate to use for the comparison\n    Value *LHS,     ///< The left-hand-side of the expression\n    Value *RHS,     ///< The right-hand-side of the expression\n    const Twine &NameStr = \"\" ///< Name of the instruction\n  ) : CmpInst(makeCmpResultType(LHS->getType()),\n              Instruction::ICmp, pred, LHS, RHS, NameStr) {\n#ifndef NDEBUG\n  AssertOK();\n#endif\n  }\n\n  /// For example, EQ->EQ, SLE->SLE, UGT->SGT, etc.\n  /// @returns the predicate that would be the result if the operand were\n  /// regarded as signed.\n  /// Return the signed version of the predicate\n  Predicate getSignedPredicate() const {\n    return getSignedPredicate(getPredicate());\n  }\n\n  /// This is a static version that you can use without an instruction.\n  /// Return the signed version of the predicate.\n  static Predicate getSignedPredicate(Predicate pred);\n\n  /// For example, EQ->EQ, SLE->ULE, UGT->UGT, etc.\n  /// @returns the predicate that would be the result if the operand were\n  /// regarded as unsigned.\n  /// Return the unsigned version of the predicate\n  Predicate getUnsignedPredicate() const {\n    return getUnsignedPredicate(getPredicate());\n  }\n\n  /// This is a static version that you can use without an instruction.\n  /// Return the unsigned version of the predicate.\n  static Predicate getUnsignedPredicate(Predicate pred);\n\n  /// Return true if this predicate is either EQ or NE.  This also\n  /// tests for commutativity.\n  static bool isEquality(Predicate P) {\n    return P == ICMP_EQ || P == ICMP_NE;\n  }\n\n  /// Return true if this predicate is either EQ or NE.  This also\n  /// tests for commutativity.\n  bool isEquality() const {\n    return isEquality(getPredicate());\n  }\n\n  /// @returns true if the predicate of this ICmpInst is commutative\n  /// Determine if this relation is commutative.\n  bool isCommutative() const { return isEquality(); }\n\n  /// Return true if the predicate is relational (not EQ or NE).\n  ///\n  bool isRelational() const {\n    return !isEquality();\n  }\n\n  /// Return true if the predicate is relational (not EQ or NE).\n  ///\n  static bool isRelational(Predicate P) {\n    return !isEquality(P);\n  }\n\n  /// Return true if the predicate is SGT or UGT.\n  ///\n  static bool isGT(Predicate P) {\n    return P == ICMP_SGT || P == ICMP_UGT;\n  }\n\n  /// Return true if the predicate is SLT or ULT.\n  ///\n  static bool isLT(Predicate P) {\n    return P == ICMP_SLT || P == ICMP_ULT;\n  }\n\n  /// Return true if the predicate is SGE or UGE.\n  ///\n  static bool isGE(Predicate P) {\n    return P == ICMP_SGE || P == ICMP_UGE;\n  }\n\n  /// Return true if the predicate is SLE or ULE.\n  ///\n  static bool isLE(Predicate P) {\n    return P == ICMP_SLE || P == ICMP_ULE;\n  }\n\n  /// Exchange the two operands to this instruction in such a way that it does\n  /// not modify the semantics of the instruction. The predicate value may be\n  /// changed to retain the same result if the predicate is order dependent\n  /// (e.g. ult).\n  /// Swap operands and adjust predicate.\n  void swapOperands() {\n    setPredicate(getSwappedPredicate());\n    Op<0>().swap(Op<1>());\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::ICmp;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                               FCmpInst Class\n//===----------------------------------------------------------------------===//\n\n/// This instruction compares its operands according to the predicate given\n/// to the constructor. It only operates on floating point values or packed\n/// vectors of floating point values. The operands must be identical types.\n/// Represents a floating point comparison operator.\nclass FCmpInst: public CmpInst {\n  void AssertOK() {\n    assert(isFPPredicate() && \"Invalid FCmp predicate value\");\n    assert(getOperand(0)->getType() == getOperand(1)->getType() &&\n           \"Both operands to FCmp instruction are not of the same type!\");\n    // Check that the operands are the right type\n    assert(getOperand(0)->getType()->isFPOrFPVectorTy() &&\n           \"Invalid operand types for FCmp instruction\");\n  }\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical FCmpInst\n  FCmpInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics.\n  FCmpInst(\n    Instruction *InsertBefore, ///< Where to insert\n    Predicate pred,  ///< The predicate to use for the comparison\n    Value *LHS,      ///< The left-hand-side of the expression\n    Value *RHS,      ///< The right-hand-side of the expression\n    const Twine &NameStr = \"\"  ///< Name of the instruction\n  ) : CmpInst(makeCmpResultType(LHS->getType()),\n              Instruction::FCmp, pred, LHS, RHS, NameStr,\n              InsertBefore) {\n    AssertOK();\n  }\n\n  /// Constructor with insert-at-end semantics.\n  FCmpInst(\n    BasicBlock &InsertAtEnd, ///< Block to insert into.\n    Predicate pred,  ///< The predicate to use for the comparison\n    Value *LHS,      ///< The left-hand-side of the expression\n    Value *RHS,      ///< The right-hand-side of the expression\n    const Twine &NameStr = \"\"  ///< Name of the instruction\n  ) : CmpInst(makeCmpResultType(LHS->getType()),\n              Instruction::FCmp, pred, LHS, RHS, NameStr,\n              &InsertAtEnd) {\n    AssertOK();\n  }\n\n  /// Constructor with no-insertion semantics\n  FCmpInst(\n    Predicate Pred, ///< The predicate to use for the comparison\n    Value *LHS,     ///< The left-hand-side of the expression\n    Value *RHS,     ///< The right-hand-side of the expression\n    const Twine &NameStr = \"\", ///< Name of the instruction\n    Instruction *FlagsSource = nullptr\n  ) : CmpInst(makeCmpResultType(LHS->getType()), Instruction::FCmp, Pred, LHS,\n              RHS, NameStr, nullptr, FlagsSource) {\n    AssertOK();\n  }\n\n  /// @returns true if the predicate of this instruction is EQ or NE.\n  /// Determine if this is an equality predicate.\n  static bool isEquality(Predicate Pred) {\n    return Pred == FCMP_OEQ || Pred == FCMP_ONE || Pred == FCMP_UEQ ||\n           Pred == FCMP_UNE;\n  }\n\n  /// @returns true if the predicate of this instruction is EQ or NE.\n  /// Determine if this is an equality predicate.\n  bool isEquality() const { return isEquality(getPredicate()); }\n\n  /// @returns true if the predicate of this instruction is commutative.\n  /// Determine if this is a commutative predicate.\n  bool isCommutative() const {\n    return isEquality() ||\n           getPredicate() == FCMP_FALSE ||\n           getPredicate() == FCMP_TRUE ||\n           getPredicate() == FCMP_ORD ||\n           getPredicate() == FCMP_UNO;\n  }\n\n  /// @returns true if the predicate is relational (not EQ or NE).\n  /// Determine if this a relational predicate.\n  bool isRelational() const { return !isEquality(); }\n\n  /// Exchange the two operands to this instruction in such a way that it does\n  /// not modify the semantics of the instruction. The predicate value may be\n  /// changed to retain the same result if the predicate is order dependent\n  /// (e.g. ult).\n  /// Swap operands and adjust predicate.\n  void swapOperands() {\n    setPredicate(getSwappedPredicate());\n    Op<0>().swap(Op<1>());\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::FCmp;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// This class represents a function call, abstracting a target\n/// machine's calling convention.  This class uses low bit of the SubClassData\n/// field to indicate whether or not this is a tail call.  The rest of the bits\n/// hold the calling convention of the call.\n///\nclass CallInst : public CallBase {\n  CallInst(const CallInst &CI);\n\n  /// Construct a CallInst given a range of arguments.\n  /// Construct a CallInst from a range of arguments\n  inline CallInst(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                  ArrayRef<OperandBundleDef> Bundles, const Twine &NameStr,\n                  Instruction *InsertBefore);\n\n  inline CallInst(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                  const Twine &NameStr, Instruction *InsertBefore)\n      : CallInst(Ty, Func, Args, None, NameStr, InsertBefore) {}\n\n  /// Construct a CallInst given a range of arguments.\n  /// Construct a CallInst from a range of arguments\n  inline CallInst(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                  ArrayRef<OperandBundleDef> Bundles, const Twine &NameStr,\n                  BasicBlock *InsertAtEnd);\n\n  explicit CallInst(FunctionType *Ty, Value *F, const Twine &NameStr,\n                    Instruction *InsertBefore);\n\n  CallInst(FunctionType *ty, Value *F, const Twine &NameStr,\n           BasicBlock *InsertAtEnd);\n\n  void init(FunctionType *FTy, Value *Func, ArrayRef<Value *> Args,\n            ArrayRef<OperandBundleDef> Bundles, const Twine &NameStr);\n  void init(FunctionType *FTy, Value *Func, const Twine &NameStr);\n\n  /// Compute the number of operands to allocate.\n  static int ComputeNumOperands(int NumArgs, int NumBundleInputs = 0) {\n    // We need one operand for the called function, plus the input operand\n    // counts provided.\n    return 1 + NumArgs + NumBundleInputs;\n  }\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  CallInst *cloneImpl() const;\n\npublic:\n  static CallInst *Create(FunctionType *Ty, Value *F, const Twine &NameStr = \"\",\n                          Instruction *InsertBefore = nullptr) {\n    return new (ComputeNumOperands(0)) CallInst(Ty, F, NameStr, InsertBefore);\n  }\n\n  static CallInst *Create(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                          const Twine &NameStr,\n                          Instruction *InsertBefore = nullptr) {\n    return new (ComputeNumOperands(Args.size()))\n        CallInst(Ty, Func, Args, None, NameStr, InsertBefore);\n  }\n\n  static CallInst *Create(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                          ArrayRef<OperandBundleDef> Bundles = None,\n                          const Twine &NameStr = \"\",\n                          Instruction *InsertBefore = nullptr) {\n    const int NumOperands =\n        ComputeNumOperands(Args.size(), CountBundleInputs(Bundles));\n    const unsigned DescriptorBytes = Bundles.size() * sizeof(BundleOpInfo);\n\n    return new (NumOperands, DescriptorBytes)\n        CallInst(Ty, Func, Args, Bundles, NameStr, InsertBefore);\n  }\n\n  static CallInst *Create(FunctionType *Ty, Value *F, const Twine &NameStr,\n                          BasicBlock *InsertAtEnd) {\n    return new (ComputeNumOperands(0)) CallInst(Ty, F, NameStr, InsertAtEnd);\n  }\n\n  static CallInst *Create(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                          const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    return new (ComputeNumOperands(Args.size()))\n        CallInst(Ty, Func, Args, None, NameStr, InsertAtEnd);\n  }\n\n  static CallInst *Create(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                          ArrayRef<OperandBundleDef> Bundles,\n                          const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    const int NumOperands =\n        ComputeNumOperands(Args.size(), CountBundleInputs(Bundles));\n    const unsigned DescriptorBytes = Bundles.size() * sizeof(BundleOpInfo);\n\n    return new (NumOperands, DescriptorBytes)\n        CallInst(Ty, Func, Args, Bundles, NameStr, InsertAtEnd);\n  }\n\n  static CallInst *Create(FunctionCallee Func, const Twine &NameStr = \"\",\n                          Instruction *InsertBefore = nullptr) {\n    return Create(Func.getFunctionType(), Func.getCallee(), NameStr,\n                  InsertBefore);\n  }\n\n  static CallInst *Create(FunctionCallee Func, ArrayRef<Value *> Args,\n                          ArrayRef<OperandBundleDef> Bundles = None,\n                          const Twine &NameStr = \"\",\n                          Instruction *InsertBefore = nullptr) {\n    return Create(Func.getFunctionType(), Func.getCallee(), Args, Bundles,\n                  NameStr, InsertBefore);\n  }\n\n  static CallInst *Create(FunctionCallee Func, ArrayRef<Value *> Args,\n                          const Twine &NameStr,\n                          Instruction *InsertBefore = nullptr) {\n    return Create(Func.getFunctionType(), Func.getCallee(), Args, NameStr,\n                  InsertBefore);\n  }\n\n  static CallInst *Create(FunctionCallee Func, const Twine &NameStr,\n                          BasicBlock *InsertAtEnd) {\n    return Create(Func.getFunctionType(), Func.getCallee(), NameStr,\n                  InsertAtEnd);\n  }\n\n  static CallInst *Create(FunctionCallee Func, ArrayRef<Value *> Args,\n                          const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    return Create(Func.getFunctionType(), Func.getCallee(), Args, NameStr,\n                  InsertAtEnd);\n  }\n\n  static CallInst *Create(FunctionCallee Func, ArrayRef<Value *> Args,\n                          ArrayRef<OperandBundleDef> Bundles,\n                          const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    return Create(Func.getFunctionType(), Func.getCallee(), Args, Bundles,\n                  NameStr, InsertAtEnd);\n  }\n\n  /// Create a clone of \\p CI with a different set of operand bundles and\n  /// insert it before \\p InsertPt.\n  ///\n  /// The returned call instruction is identical \\p CI in every way except that\n  /// the operand bundles for the new instruction are set to the operand bundles\n  /// in \\p Bundles.\n  static CallInst *Create(CallInst *CI, ArrayRef<OperandBundleDef> Bundles,\n                          Instruction *InsertPt = nullptr);\n\n  /// Generate the IR for a call to malloc:\n  /// 1. Compute the malloc call's argument as the specified type's size,\n  ///    possibly multiplied by the array size if the array size is not\n  ///    constant 1.\n  /// 2. Call malloc with that argument.\n  /// 3. Bitcast the result of the malloc call to the specified type.\n  static Instruction *CreateMalloc(Instruction *InsertBefore, Type *IntPtrTy,\n                                   Type *AllocTy, Value *AllocSize,\n                                   Value *ArraySize = nullptr,\n                                   Function *MallocF = nullptr,\n                                   const Twine &Name = \"\");\n  static Instruction *CreateMalloc(BasicBlock *InsertAtEnd, Type *IntPtrTy,\n                                   Type *AllocTy, Value *AllocSize,\n                                   Value *ArraySize = nullptr,\n                                   Function *MallocF = nullptr,\n                                   const Twine &Name = \"\");\n  static Instruction *CreateMalloc(Instruction *InsertBefore, Type *IntPtrTy,\n                                   Type *AllocTy, Value *AllocSize,\n                                   Value *ArraySize = nullptr,\n                                   ArrayRef<OperandBundleDef> Bundles = None,\n                                   Function *MallocF = nullptr,\n                                   const Twine &Name = \"\");\n  static Instruction *CreateMalloc(BasicBlock *InsertAtEnd, Type *IntPtrTy,\n                                   Type *AllocTy, Value *AllocSize,\n                                   Value *ArraySize = nullptr,\n                                   ArrayRef<OperandBundleDef> Bundles = None,\n                                   Function *MallocF = nullptr,\n                                   const Twine &Name = \"\");\n  /// Generate the IR for a call to the builtin free function.\n  static Instruction *CreateFree(Value *Source, Instruction *InsertBefore);\n  static Instruction *CreateFree(Value *Source, BasicBlock *InsertAtEnd);\n  static Instruction *CreateFree(Value *Source,\n                                 ArrayRef<OperandBundleDef> Bundles,\n                                 Instruction *InsertBefore);\n  static Instruction *CreateFree(Value *Source,\n                                 ArrayRef<OperandBundleDef> Bundles,\n                                 BasicBlock *InsertAtEnd);\n\n  // Note that 'musttail' implies 'tail'.\n  enum TailCallKind : unsigned {\n    TCK_None = 0,\n    TCK_Tail = 1,\n    TCK_MustTail = 2,\n    TCK_NoTail = 3,\n    TCK_LAST = TCK_NoTail\n  };\n\n  using TailCallKindField = Bitfield::Element<TailCallKind, 0, 2, TCK_LAST>;\n  static_assert(\n      Bitfield::areContiguous<TailCallKindField, CallBase::CallingConvField>(),\n      \"Bitfields must be contiguous\");\n\n  TailCallKind getTailCallKind() const {\n    return getSubclassData<TailCallKindField>();\n  }\n\n  bool isTailCall() const {\n    TailCallKind Kind = getTailCallKind();\n    return Kind == TCK_Tail || Kind == TCK_MustTail;\n  }\n\n  bool isMustTailCall() const { return getTailCallKind() == TCK_MustTail; }\n\n  bool isNoTailCall() const { return getTailCallKind() == TCK_NoTail; }\n\n  void setTailCallKind(TailCallKind TCK) {\n    setSubclassData<TailCallKindField>(TCK);\n  }\n\n  void setTailCall(bool IsTc = true) {\n    setTailCallKind(IsTc ? TCK_Tail : TCK_None);\n  }\n\n  /// Return true if the call can return twice\n  bool canReturnTwice() const { return hasFnAttr(Attribute::ReturnsTwice); }\n  void setCanReturnTwice() {\n    addAttribute(AttributeList::FunctionIndex, Attribute::ReturnsTwice);\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Call;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\n  /// Updates profile metadata by scaling it by \\p S / \\p T.\n  void updateProfWeight(uint64_t S, uint64_t T);\n\nprivate:\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n};\n\nCallInst::CallInst(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                   ArrayRef<OperandBundleDef> Bundles, const Twine &NameStr,\n                   BasicBlock *InsertAtEnd)\n    : CallBase(Ty->getReturnType(), Instruction::Call,\n               OperandTraits<CallBase>::op_end(this) -\n                   (Args.size() + CountBundleInputs(Bundles) + 1),\n               unsigned(Args.size() + CountBundleInputs(Bundles) + 1),\n               InsertAtEnd) {\n  init(Ty, Func, Args, Bundles, NameStr);\n}\n\nCallInst::CallInst(FunctionType *Ty, Value *Func, ArrayRef<Value *> Args,\n                   ArrayRef<OperandBundleDef> Bundles, const Twine &NameStr,\n                   Instruction *InsertBefore)\n    : CallBase(Ty->getReturnType(), Instruction::Call,\n               OperandTraits<CallBase>::op_end(this) -\n                   (Args.size() + CountBundleInputs(Bundles) + 1),\n               unsigned(Args.size() + CountBundleInputs(Bundles) + 1),\n               InsertBefore) {\n  init(Ty, Func, Args, Bundles, NameStr);\n}\n\n//===----------------------------------------------------------------------===//\n//                               SelectInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents the LLVM 'select' instruction.\n///\nclass SelectInst : public Instruction {\n  SelectInst(Value *C, Value *S1, Value *S2, const Twine &NameStr,\n             Instruction *InsertBefore)\n    : Instruction(S1->getType(), Instruction::Select,\n                  &Op<0>(), 3, InsertBefore) {\n    init(C, S1, S2);\n    setName(NameStr);\n  }\n\n  SelectInst(Value *C, Value *S1, Value *S2, const Twine &NameStr,\n             BasicBlock *InsertAtEnd)\n    : Instruction(S1->getType(), Instruction::Select,\n                  &Op<0>(), 3, InsertAtEnd) {\n    init(C, S1, S2);\n    setName(NameStr);\n  }\n\n  void init(Value *C, Value *S1, Value *S2) {\n    assert(!areInvalidOperands(C, S1, S2) && \"Invalid operands for select\");\n    Op<0>() = C;\n    Op<1>() = S1;\n    Op<2>() = S2;\n  }\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  SelectInst *cloneImpl() const;\n\npublic:\n  static SelectInst *Create(Value *C, Value *S1, Value *S2,\n                            const Twine &NameStr = \"\",\n                            Instruction *InsertBefore = nullptr,\n                            Instruction *MDFrom = nullptr) {\n    SelectInst *Sel = new(3) SelectInst(C, S1, S2, NameStr, InsertBefore);\n    if (MDFrom)\n      Sel->copyMetadata(*MDFrom);\n    return Sel;\n  }\n\n  static SelectInst *Create(Value *C, Value *S1, Value *S2,\n                            const Twine &NameStr,\n                            BasicBlock *InsertAtEnd) {\n    return new(3) SelectInst(C, S1, S2, NameStr, InsertAtEnd);\n  }\n\n  const Value *getCondition() const { return Op<0>(); }\n  const Value *getTrueValue() const { return Op<1>(); }\n  const Value *getFalseValue() const { return Op<2>(); }\n  Value *getCondition() { return Op<0>(); }\n  Value *getTrueValue() { return Op<1>(); }\n  Value *getFalseValue() { return Op<2>(); }\n\n  void setCondition(Value *V) { Op<0>() = V; }\n  void setTrueValue(Value *V) { Op<1>() = V; }\n  void setFalseValue(Value *V) { Op<2>() = V; }\n\n  /// Swap the true and false values of the select instruction.\n  /// This doesn't swap prof metadata.\n  void swapValues() { Op<1>().swap(Op<2>()); }\n\n  /// Return a string if the specified operands are invalid\n  /// for a select operation, otherwise return null.\n  static const char *areInvalidOperands(Value *Cond, Value *True, Value *False);\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  OtherOps getOpcode() const {\n    return static_cast<OtherOps>(Instruction::getOpcode());\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Select;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<SelectInst> : public FixedNumOperandTraits<SelectInst, 3> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(SelectInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                                VAArgInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents the va_arg llvm instruction, which returns\n/// an argument of the specified type given a va_list and increments that list\n///\nclass VAArgInst : public UnaryInstruction {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  VAArgInst *cloneImpl() const;\n\npublic:\n  VAArgInst(Value *List, Type *Ty, const Twine &NameStr = \"\",\n             Instruction *InsertBefore = nullptr)\n    : UnaryInstruction(Ty, VAArg, List, InsertBefore) {\n    setName(NameStr);\n  }\n\n  VAArgInst(Value *List, Type *Ty, const Twine &NameStr,\n            BasicBlock *InsertAtEnd)\n    : UnaryInstruction(Ty, VAArg, List, InsertAtEnd) {\n    setName(NameStr);\n  }\n\n  Value *getPointerOperand() { return getOperand(0); }\n  const Value *getPointerOperand() const { return getOperand(0); }\n  static unsigned getPointerOperandIndex() { return 0U; }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == VAArg;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                ExtractElementInst Class\n//===----------------------------------------------------------------------===//\n\n/// This instruction extracts a single (scalar)\n/// element from a VectorType value\n///\nclass ExtractElementInst : public Instruction {\n  ExtractElementInst(Value *Vec, Value *Idx, const Twine &NameStr = \"\",\n                     Instruction *InsertBefore = nullptr);\n  ExtractElementInst(Value *Vec, Value *Idx, const Twine &NameStr,\n                     BasicBlock *InsertAtEnd);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  ExtractElementInst *cloneImpl() const;\n\npublic:\n  static ExtractElementInst *Create(Value *Vec, Value *Idx,\n                                   const Twine &NameStr = \"\",\n                                   Instruction *InsertBefore = nullptr) {\n    return new(2) ExtractElementInst(Vec, Idx, NameStr, InsertBefore);\n  }\n\n  static ExtractElementInst *Create(Value *Vec, Value *Idx,\n                                   const Twine &NameStr,\n                                   BasicBlock *InsertAtEnd) {\n    return new(2) ExtractElementInst(Vec, Idx, NameStr, InsertAtEnd);\n  }\n\n  /// Return true if an extractelement instruction can be\n  /// formed with the specified operands.\n  static bool isValidOperands(const Value *Vec, const Value *Idx);\n\n  Value *getVectorOperand() { return Op<0>(); }\n  Value *getIndexOperand() { return Op<1>(); }\n  const Value *getVectorOperand() const { return Op<0>(); }\n  const Value *getIndexOperand() const { return Op<1>(); }\n\n  VectorType *getVectorOperandType() const {\n    return cast<VectorType>(getVectorOperand()->getType());\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::ExtractElement;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<ExtractElementInst> :\n  public FixedNumOperandTraits<ExtractElementInst, 2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(ExtractElementInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                                InsertElementInst Class\n//===----------------------------------------------------------------------===//\n\n/// This instruction inserts a single (scalar)\n/// element into a VectorType value\n///\nclass InsertElementInst : public Instruction {\n  InsertElementInst(Value *Vec, Value *NewElt, Value *Idx,\n                    const Twine &NameStr = \"\",\n                    Instruction *InsertBefore = nullptr);\n  InsertElementInst(Value *Vec, Value *NewElt, Value *Idx, const Twine &NameStr,\n                    BasicBlock *InsertAtEnd);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  InsertElementInst *cloneImpl() const;\n\npublic:\n  static InsertElementInst *Create(Value *Vec, Value *NewElt, Value *Idx,\n                                   const Twine &NameStr = \"\",\n                                   Instruction *InsertBefore = nullptr) {\n    return new(3) InsertElementInst(Vec, NewElt, Idx, NameStr, InsertBefore);\n  }\n\n  static InsertElementInst *Create(Value *Vec, Value *NewElt, Value *Idx,\n                                   const Twine &NameStr,\n                                   BasicBlock *InsertAtEnd) {\n    return new(3) InsertElementInst(Vec, NewElt, Idx, NameStr, InsertAtEnd);\n  }\n\n  /// Return true if an insertelement instruction can be\n  /// formed with the specified operands.\n  static bool isValidOperands(const Value *Vec, const Value *NewElt,\n                              const Value *Idx);\n\n  /// Overload to return most specific vector type.\n  ///\n  VectorType *getType() const {\n    return cast<VectorType>(Instruction::getType());\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::InsertElement;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<InsertElementInst> :\n  public FixedNumOperandTraits<InsertElementInst, 3> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(InsertElementInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                           ShuffleVectorInst Class\n//===----------------------------------------------------------------------===//\n\nconstexpr int UndefMaskElem = -1;\n\n/// This instruction constructs a fixed permutation of two\n/// input vectors.\n///\n/// For each element of the result vector, the shuffle mask selects an element\n/// from one of the input vectors to copy to the result. Non-negative elements\n/// in the mask represent an index into the concatenated pair of input vectors.\n/// UndefMaskElem (-1) specifies that the result element is undefined.\n///\n/// For scalable vectors, all the elements of the mask must be 0 or -1. This\n/// requirement may be relaxed in the future.\nclass ShuffleVectorInst : public Instruction {\n  SmallVector<int, 4> ShuffleMask;\n  Constant *ShuffleMaskForBitcode;\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  ShuffleVectorInst *cloneImpl() const;\n\npublic:\n  ShuffleVectorInst(Value *V1, Value *V2, Value *Mask,\n                    const Twine &NameStr = \"\",\n                    Instruction *InsertBefor = nullptr);\n  ShuffleVectorInst(Value *V1, Value *V2, Value *Mask,\n                    const Twine &NameStr, BasicBlock *InsertAtEnd);\n  ShuffleVectorInst(Value *V1, Value *V2, ArrayRef<int> Mask,\n                    const Twine &NameStr = \"\",\n                    Instruction *InsertBefor = nullptr);\n  ShuffleVectorInst(Value *V1, Value *V2, ArrayRef<int> Mask,\n                    const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  void *operator new(size_t s) { return User::operator new(s, 2); }\n\n  /// Swap the operands and adjust the mask to preserve the semantics\n  /// of the instruction.\n  void commute();\n\n  /// Return true if a shufflevector instruction can be\n  /// formed with the specified operands.\n  static bool isValidOperands(const Value *V1, const Value *V2,\n                              const Value *Mask);\n  static bool isValidOperands(const Value *V1, const Value *V2,\n                              ArrayRef<int> Mask);\n\n  /// Overload to return most specific vector type.\n  ///\n  VectorType *getType() const {\n    return cast<VectorType>(Instruction::getType());\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Return the shuffle mask value of this instruction for the given element\n  /// index. Return UndefMaskElem if the element is undef.\n  int getMaskValue(unsigned Elt) const { return ShuffleMask[Elt]; }\n\n  /// Convert the input shuffle mask operand to a vector of integers. Undefined\n  /// elements of the mask are returned as UndefMaskElem.\n  static void getShuffleMask(const Constant *Mask,\n                             SmallVectorImpl<int> &Result);\n\n  /// Return the mask for this instruction as a vector of integers. Undefined\n  /// elements of the mask are returned as UndefMaskElem.\n  void getShuffleMask(SmallVectorImpl<int> &Result) const {\n    Result.assign(ShuffleMask.begin(), ShuffleMask.end());\n  }\n\n  /// Return the mask for this instruction, for use in bitcode.\n  ///\n  /// TODO: This is temporary until we decide a new bitcode encoding for\n  /// shufflevector.\n  Constant *getShuffleMaskForBitcode() const { return ShuffleMaskForBitcode; }\n\n  static Constant *convertShuffleMaskForBitcode(ArrayRef<int> Mask,\n                                                Type *ResultTy);\n\n  void setShuffleMask(ArrayRef<int> Mask);\n\n  ArrayRef<int> getShuffleMask() const { return ShuffleMask; }\n\n  /// Return true if this shuffle returns a vector with a different number of\n  /// elements than its source vectors.\n  /// Examples: shufflevector <4 x n> A, <4 x n> B, <1,2,3>\n  ///           shufflevector <4 x n> A, <4 x n> B, <1,2,3,4,5>\n  bool changesLength() const {\n    unsigned NumSourceElts = cast<VectorType>(Op<0>()->getType())\n                                 ->getElementCount()\n                                 .getKnownMinValue();\n    unsigned NumMaskElts = ShuffleMask.size();\n    return NumSourceElts != NumMaskElts;\n  }\n\n  /// Return true if this shuffle returns a vector with a greater number of\n  /// elements than its source vectors.\n  /// Example: shufflevector <2 x n> A, <2 x n> B, <1,2,3>\n  bool increasesLength() const {\n    unsigned NumSourceElts = cast<VectorType>(Op<0>()->getType())\n                                 ->getElementCount()\n                                 .getKnownMinValue();\n    unsigned NumMaskElts = ShuffleMask.size();\n    return NumSourceElts < NumMaskElts;\n  }\n\n  /// Return true if this shuffle mask chooses elements from exactly one source\n  /// vector.\n  /// Example: <7,5,undef,7>\n  /// This assumes that vector operands are the same length as the mask.\n  static bool isSingleSourceMask(ArrayRef<int> Mask);\n  static bool isSingleSourceMask(const Constant *Mask) {\n    assert(Mask->getType()->isVectorTy() && \"Shuffle needs vector constant.\");\n    SmallVector<int, 16> MaskAsInts;\n    getShuffleMask(Mask, MaskAsInts);\n    return isSingleSourceMask(MaskAsInts);\n  }\n\n  /// Return true if this shuffle chooses elements from exactly one source\n  /// vector without changing the length of that vector.\n  /// Example: shufflevector <4 x n> A, <4 x n> B, <3,0,undef,3>\n  /// TODO: Optionally allow length-changing shuffles.\n  bool isSingleSource() const {\n    return !changesLength() && isSingleSourceMask(ShuffleMask);\n  }\n\n  /// Return true if this shuffle mask chooses elements from exactly one source\n  /// vector without lane crossings. A shuffle using this mask is not\n  /// necessarily a no-op because it may change the number of elements from its\n  /// input vectors or it may provide demanded bits knowledge via undef lanes.\n  /// Example: <undef,undef,2,3>\n  static bool isIdentityMask(ArrayRef<int> Mask);\n  static bool isIdentityMask(const Constant *Mask) {\n    assert(Mask->getType()->isVectorTy() && \"Shuffle needs vector constant.\");\n    SmallVector<int, 16> MaskAsInts;\n    getShuffleMask(Mask, MaskAsInts);\n    return isIdentityMask(MaskAsInts);\n  }\n\n  /// Return true if this shuffle chooses elements from exactly one source\n  /// vector without lane crossings and does not change the number of elements\n  /// from its input vectors.\n  /// Example: shufflevector <4 x n> A, <4 x n> B, <4,undef,6,undef>\n  bool isIdentity() const {\n    return !changesLength() && isIdentityMask(ShuffleMask);\n  }\n\n  /// Return true if this shuffle lengthens exactly one source vector with\n  /// undefs in the high elements.\n  bool isIdentityWithPadding() const;\n\n  /// Return true if this shuffle extracts the first N elements of exactly one\n  /// source vector.\n  bool isIdentityWithExtract() const;\n\n  /// Return true if this shuffle concatenates its 2 source vectors. This\n  /// returns false if either input is undefined. In that case, the shuffle is\n  /// is better classified as an identity with padding operation.\n  bool isConcat() const;\n\n  /// Return true if this shuffle mask chooses elements from its source vectors\n  /// without lane crossings. A shuffle using this mask would be\n  /// equivalent to a vector select with a constant condition operand.\n  /// Example: <4,1,6,undef>\n  /// This returns false if the mask does not choose from both input vectors.\n  /// In that case, the shuffle is better classified as an identity shuffle.\n  /// This assumes that vector operands are the same length as the mask\n  /// (a length-changing shuffle can never be equivalent to a vector select).\n  static bool isSelectMask(ArrayRef<int> Mask);\n  static bool isSelectMask(const Constant *Mask) {\n    assert(Mask->getType()->isVectorTy() && \"Shuffle needs vector constant.\");\n    SmallVector<int, 16> MaskAsInts;\n    getShuffleMask(Mask, MaskAsInts);\n    return isSelectMask(MaskAsInts);\n  }\n\n  /// Return true if this shuffle chooses elements from its source vectors\n  /// without lane crossings and all operands have the same number of elements.\n  /// In other words, this shuffle is equivalent to a vector select with a\n  /// constant condition operand.\n  /// Example: shufflevector <4 x n> A, <4 x n> B, <undef,1,6,3>\n  /// This returns false if the mask does not choose from both input vectors.\n  /// In that case, the shuffle is better classified as an identity shuffle.\n  /// TODO: Optionally allow length-changing shuffles.\n  bool isSelect() const {\n    return !changesLength() && isSelectMask(ShuffleMask);\n  }\n\n  /// Return true if this shuffle mask swaps the order of elements from exactly\n  /// one source vector.\n  /// Example: <7,6,undef,4>\n  /// This assumes that vector operands are the same length as the mask.\n  static bool isReverseMask(ArrayRef<int> Mask);\n  static bool isReverseMask(const Constant *Mask) {\n    assert(Mask->getType()->isVectorTy() && \"Shuffle needs vector constant.\");\n    SmallVector<int, 16> MaskAsInts;\n    getShuffleMask(Mask, MaskAsInts);\n    return isReverseMask(MaskAsInts);\n  }\n\n  /// Return true if this shuffle swaps the order of elements from exactly\n  /// one source vector.\n  /// Example: shufflevector <4 x n> A, <4 x n> B, <3,undef,1,undef>\n  /// TODO: Optionally allow length-changing shuffles.\n  bool isReverse() const {\n    return !changesLength() && isReverseMask(ShuffleMask);\n  }\n\n  /// Return true if this shuffle mask chooses all elements with the same value\n  /// as the first element of exactly one source vector.\n  /// Example: <4,undef,undef,4>\n  /// This assumes that vector operands are the same length as the mask.\n  static bool isZeroEltSplatMask(ArrayRef<int> Mask);\n  static bool isZeroEltSplatMask(const Constant *Mask) {\n    assert(Mask->getType()->isVectorTy() && \"Shuffle needs vector constant.\");\n    SmallVector<int, 16> MaskAsInts;\n    getShuffleMask(Mask, MaskAsInts);\n    return isZeroEltSplatMask(MaskAsInts);\n  }\n\n  /// Return true if all elements of this shuffle are the same value as the\n  /// first element of exactly one source vector without changing the length\n  /// of that vector.\n  /// Example: shufflevector <4 x n> A, <4 x n> B, <undef,0,undef,0>\n  /// TODO: Optionally allow length-changing shuffles.\n  /// TODO: Optionally allow splats from other elements.\n  bool isZeroEltSplat() const {\n    return !changesLength() && isZeroEltSplatMask(ShuffleMask);\n  }\n\n  /// Return true if this shuffle mask is a transpose mask.\n  /// Transpose vector masks transpose a 2xn matrix. They read corresponding\n  /// even- or odd-numbered vector elements from two n-dimensional source\n  /// vectors and write each result into consecutive elements of an\n  /// n-dimensional destination vector. Two shuffles are necessary to complete\n  /// the transpose, one for the even elements and another for the odd elements.\n  /// This description closely follows how the TRN1 and TRN2 AArch64\n  /// instructions operate.\n  ///\n  /// For example, a simple 2x2 matrix can be transposed with:\n  ///\n  ///   ; Original matrix\n  ///   m0 = < a, b >\n  ///   m1 = < c, d >\n  ///\n  ///   ; Transposed matrix\n  ///   t0 = < a, c > = shufflevector m0, m1, < 0, 2 >\n  ///   t1 = < b, d > = shufflevector m0, m1, < 1, 3 >\n  ///\n  /// For matrices having greater than n columns, the resulting nx2 transposed\n  /// matrix is stored in two result vectors such that one vector contains\n  /// interleaved elements from all the even-numbered rows and the other vector\n  /// contains interleaved elements from all the odd-numbered rows. For example,\n  /// a 2x4 matrix can be transposed with:\n  ///\n  ///   ; Original matrix\n  ///   m0 = < a, b, c, d >\n  ///   m1 = < e, f, g, h >\n  ///\n  ///   ; Transposed matrix\n  ///   t0 = < a, e, c, g > = shufflevector m0, m1 < 0, 4, 2, 6 >\n  ///   t1 = < b, f, d, h > = shufflevector m0, m1 < 1, 5, 3, 7 >\n  static bool isTransposeMask(ArrayRef<int> Mask);\n  static bool isTransposeMask(const Constant *Mask) {\n    assert(Mask->getType()->isVectorTy() && \"Shuffle needs vector constant.\");\n    SmallVector<int, 16> MaskAsInts;\n    getShuffleMask(Mask, MaskAsInts);\n    return isTransposeMask(MaskAsInts);\n  }\n\n  /// Return true if this shuffle transposes the elements of its inputs without\n  /// changing the length of the vectors. This operation may also be known as a\n  /// merge or interleave. See the description for isTransposeMask() for the\n  /// exact specification.\n  /// Example: shufflevector <4 x n> A, <4 x n> B, <0,4,2,6>\n  bool isTranspose() const {\n    return !changesLength() && isTransposeMask(ShuffleMask);\n  }\n\n  /// Return true if this shuffle mask is an extract subvector mask.\n  /// A valid extract subvector mask returns a smaller vector from a single\n  /// source operand. The base extraction index is returned as well.\n  static bool isExtractSubvectorMask(ArrayRef<int> Mask, int NumSrcElts,\n                                     int &Index);\n  static bool isExtractSubvectorMask(const Constant *Mask, int NumSrcElts,\n                                     int &Index) {\n    assert(Mask->getType()->isVectorTy() && \"Shuffle needs vector constant.\");\n    // Not possible to express a shuffle mask for a scalable vector for this\n    // case.\n    if (isa<ScalableVectorType>(Mask->getType()))\n      return false;\n    SmallVector<int, 16> MaskAsInts;\n    getShuffleMask(Mask, MaskAsInts);\n    return isExtractSubvectorMask(MaskAsInts, NumSrcElts, Index);\n  }\n\n  /// Return true if this shuffle mask is an extract subvector mask.\n  bool isExtractSubvectorMask(int &Index) const {\n    // Not possible to express a shuffle mask for a scalable vector for this\n    // case.\n    if (isa<ScalableVectorType>(getType()))\n      return false;\n\n    int NumSrcElts =\n        cast<FixedVectorType>(Op<0>()->getType())->getNumElements();\n    return isExtractSubvectorMask(ShuffleMask, NumSrcElts, Index);\n  }\n\n  /// Change values in a shuffle permute mask assuming the two vector operands\n  /// of length InVecNumElts have swapped position.\n  static void commuteShuffleMask(MutableArrayRef<int> Mask,\n                                 unsigned InVecNumElts) {\n    for (int &Idx : Mask) {\n      if (Idx == -1)\n        continue;\n      Idx = Idx < (int)InVecNumElts ? Idx + InVecNumElts : Idx - InVecNumElts;\n      assert(Idx >= 0 && Idx < (int)InVecNumElts * 2 &&\n             \"shufflevector mask index out of range\");\n    }\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::ShuffleVector;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<ShuffleVectorInst>\n    : public FixedNumOperandTraits<ShuffleVectorInst, 2> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(ShuffleVectorInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                                ExtractValueInst Class\n//===----------------------------------------------------------------------===//\n\n/// This instruction extracts a struct member or array\n/// element value from an aggregate value.\n///\nclass ExtractValueInst : public UnaryInstruction {\n  SmallVector<unsigned, 4> Indices;\n\n  ExtractValueInst(const ExtractValueInst &EVI);\n\n  /// Constructors - Create a extractvalue instruction with a base aggregate\n  /// value and a list of indices.  The first ctor can optionally insert before\n  /// an existing instruction, the second appends the new instruction to the\n  /// specified BasicBlock.\n  inline ExtractValueInst(Value *Agg,\n                          ArrayRef<unsigned> Idxs,\n                          const Twine &NameStr,\n                          Instruction *InsertBefore);\n  inline ExtractValueInst(Value *Agg,\n                          ArrayRef<unsigned> Idxs,\n                          const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  void init(ArrayRef<unsigned> Idxs, const Twine &NameStr);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  ExtractValueInst *cloneImpl() const;\n\npublic:\n  static ExtractValueInst *Create(Value *Agg,\n                                  ArrayRef<unsigned> Idxs,\n                                  const Twine &NameStr = \"\",\n                                  Instruction *InsertBefore = nullptr) {\n    return new\n      ExtractValueInst(Agg, Idxs, NameStr, InsertBefore);\n  }\n\n  static ExtractValueInst *Create(Value *Agg,\n                                  ArrayRef<unsigned> Idxs,\n                                  const Twine &NameStr,\n                                  BasicBlock *InsertAtEnd) {\n    return new ExtractValueInst(Agg, Idxs, NameStr, InsertAtEnd);\n  }\n\n  /// Returns the type of the element that would be extracted\n  /// with an extractvalue instruction with the specified parameters.\n  ///\n  /// Null is returned if the indices are invalid for the specified type.\n  static Type *getIndexedType(Type *Agg, ArrayRef<unsigned> Idxs);\n\n  using idx_iterator = const unsigned*;\n\n  inline idx_iterator idx_begin() const { return Indices.begin(); }\n  inline idx_iterator idx_end()   const { return Indices.end(); }\n  inline iterator_range<idx_iterator> indices() const {\n    return make_range(idx_begin(), idx_end());\n  }\n\n  Value *getAggregateOperand() {\n    return getOperand(0);\n  }\n  const Value *getAggregateOperand() const {\n    return getOperand(0);\n  }\n  static unsigned getAggregateOperandIndex() {\n    return 0U;                      // get index for modifying correct operand\n  }\n\n  ArrayRef<unsigned> getIndices() const {\n    return Indices;\n  }\n\n  unsigned getNumIndices() const {\n    return (unsigned)Indices.size();\n  }\n\n  bool hasIndices() const {\n    return true;\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::ExtractValue;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\nExtractValueInst::ExtractValueInst(Value *Agg,\n                                   ArrayRef<unsigned> Idxs,\n                                   const Twine &NameStr,\n                                   Instruction *InsertBefore)\n  : UnaryInstruction(checkGEPType(getIndexedType(Agg->getType(), Idxs)),\n                     ExtractValue, Agg, InsertBefore) {\n  init(Idxs, NameStr);\n}\n\nExtractValueInst::ExtractValueInst(Value *Agg,\n                                   ArrayRef<unsigned> Idxs,\n                                   const Twine &NameStr,\n                                   BasicBlock *InsertAtEnd)\n  : UnaryInstruction(checkGEPType(getIndexedType(Agg->getType(), Idxs)),\n                     ExtractValue, Agg, InsertAtEnd) {\n  init(Idxs, NameStr);\n}\n\n//===----------------------------------------------------------------------===//\n//                                InsertValueInst Class\n//===----------------------------------------------------------------------===//\n\n/// This instruction inserts a struct field of array element\n/// value into an aggregate value.\n///\nclass InsertValueInst : public Instruction {\n  SmallVector<unsigned, 4> Indices;\n\n  InsertValueInst(const InsertValueInst &IVI);\n\n  /// Constructors - Create a insertvalue instruction with a base aggregate\n  /// value, a value to insert, and a list of indices.  The first ctor can\n  /// optionally insert before an existing instruction, the second appends\n  /// the new instruction to the specified BasicBlock.\n  inline InsertValueInst(Value *Agg, Value *Val,\n                         ArrayRef<unsigned> Idxs,\n                         const Twine &NameStr,\n                         Instruction *InsertBefore);\n  inline InsertValueInst(Value *Agg, Value *Val,\n                         ArrayRef<unsigned> Idxs,\n                         const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  /// Constructors - These two constructors are convenience methods because one\n  /// and two index insertvalue instructions are so common.\n  InsertValueInst(Value *Agg, Value *Val, unsigned Idx,\n                  const Twine &NameStr = \"\",\n                  Instruction *InsertBefore = nullptr);\n  InsertValueInst(Value *Agg, Value *Val, unsigned Idx, const Twine &NameStr,\n                  BasicBlock *InsertAtEnd);\n\n  void init(Value *Agg, Value *Val, ArrayRef<unsigned> Idxs,\n            const Twine &NameStr);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  InsertValueInst *cloneImpl() const;\n\npublic:\n  // allocate space for exactly two operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 2);\n  }\n\n  static InsertValueInst *Create(Value *Agg, Value *Val,\n                                 ArrayRef<unsigned> Idxs,\n                                 const Twine &NameStr = \"\",\n                                 Instruction *InsertBefore = nullptr) {\n    return new InsertValueInst(Agg, Val, Idxs, NameStr, InsertBefore);\n  }\n\n  static InsertValueInst *Create(Value *Agg, Value *Val,\n                                 ArrayRef<unsigned> Idxs,\n                                 const Twine &NameStr,\n                                 BasicBlock *InsertAtEnd) {\n    return new InsertValueInst(Agg, Val, Idxs, NameStr, InsertAtEnd);\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  using idx_iterator = const unsigned*;\n\n  inline idx_iterator idx_begin() const { return Indices.begin(); }\n  inline idx_iterator idx_end()   const { return Indices.end(); }\n  inline iterator_range<idx_iterator> indices() const {\n    return make_range(idx_begin(), idx_end());\n  }\n\n  Value *getAggregateOperand() {\n    return getOperand(0);\n  }\n  const Value *getAggregateOperand() const {\n    return getOperand(0);\n  }\n  static unsigned getAggregateOperandIndex() {\n    return 0U;                      // get index for modifying correct operand\n  }\n\n  Value *getInsertedValueOperand() {\n    return getOperand(1);\n  }\n  const Value *getInsertedValueOperand() const {\n    return getOperand(1);\n  }\n  static unsigned getInsertedValueOperandIndex() {\n    return 1U;                      // get index for modifying correct operand\n  }\n\n  ArrayRef<unsigned> getIndices() const {\n    return Indices;\n  }\n\n  unsigned getNumIndices() const {\n    return (unsigned)Indices.size();\n  }\n\n  bool hasIndices() const {\n    return true;\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::InsertValue;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<InsertValueInst> :\n  public FixedNumOperandTraits<InsertValueInst, 2> {\n};\n\nInsertValueInst::InsertValueInst(Value *Agg,\n                                 Value *Val,\n                                 ArrayRef<unsigned> Idxs,\n                                 const Twine &NameStr,\n                                 Instruction *InsertBefore)\n  : Instruction(Agg->getType(), InsertValue,\n                OperandTraits<InsertValueInst>::op_begin(this),\n                2, InsertBefore) {\n  init(Agg, Val, Idxs, NameStr);\n}\n\nInsertValueInst::InsertValueInst(Value *Agg,\n                                 Value *Val,\n                                 ArrayRef<unsigned> Idxs,\n                                 const Twine &NameStr,\n                                 BasicBlock *InsertAtEnd)\n  : Instruction(Agg->getType(), InsertValue,\n                OperandTraits<InsertValueInst>::op_begin(this),\n                2, InsertAtEnd) {\n  init(Agg, Val, Idxs, NameStr);\n}\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(InsertValueInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                               PHINode Class\n//===----------------------------------------------------------------------===//\n\n// PHINode - The PHINode class is used to represent the magical mystical PHI\n// node, that can not exist in nature, but can be synthesized in a computer\n// scientist's overactive imagination.\n//\nclass PHINode : public Instruction {\n  /// The number of operands actually allocated.  NumOperands is\n  /// the number actually in use.\n  unsigned ReservedSpace;\n\n  PHINode(const PHINode &PN);\n\n  explicit PHINode(Type *Ty, unsigned NumReservedValues,\n                   const Twine &NameStr = \"\",\n                   Instruction *InsertBefore = nullptr)\n    : Instruction(Ty, Instruction::PHI, nullptr, 0, InsertBefore),\n      ReservedSpace(NumReservedValues) {\n    setName(NameStr);\n    allocHungoffUses(ReservedSpace);\n  }\n\n  PHINode(Type *Ty, unsigned NumReservedValues, const Twine &NameStr,\n          BasicBlock *InsertAtEnd)\n    : Instruction(Ty, Instruction::PHI, nullptr, 0, InsertAtEnd),\n      ReservedSpace(NumReservedValues) {\n    setName(NameStr);\n    allocHungoffUses(ReservedSpace);\n  }\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  PHINode *cloneImpl() const;\n\n  // allocHungoffUses - this is more complicated than the generic\n  // User::allocHungoffUses, because we have to allocate Uses for the incoming\n  // values and pointers to the incoming blocks, all in one allocation.\n  void allocHungoffUses(unsigned N) {\n    User::allocHungoffUses(N, /* IsPhi */ true);\n  }\n\npublic:\n  /// Constructors - NumReservedValues is a hint for the number of incoming\n  /// edges that this phi node will have (use 0 if you really have no idea).\n  static PHINode *Create(Type *Ty, unsigned NumReservedValues,\n                         const Twine &NameStr = \"\",\n                         Instruction *InsertBefore = nullptr) {\n    return new PHINode(Ty, NumReservedValues, NameStr, InsertBefore);\n  }\n\n  static PHINode *Create(Type *Ty, unsigned NumReservedValues,\n                         const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    return new PHINode(Ty, NumReservedValues, NameStr, InsertAtEnd);\n  }\n\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  // Block iterator interface. This provides access to the list of incoming\n  // basic blocks, which parallels the list of incoming values.\n\n  using block_iterator = BasicBlock **;\n  using const_block_iterator = BasicBlock * const *;\n\n  block_iterator block_begin() {\n    return reinterpret_cast<block_iterator>(op_begin() + ReservedSpace);\n  }\n\n  const_block_iterator block_begin() const {\n    return reinterpret_cast<const_block_iterator>(op_begin() + ReservedSpace);\n  }\n\n  block_iterator block_end() {\n    return block_begin() + getNumOperands();\n  }\n\n  const_block_iterator block_end() const {\n    return block_begin() + getNumOperands();\n  }\n\n  iterator_range<block_iterator> blocks() {\n    return make_range(block_begin(), block_end());\n  }\n\n  iterator_range<const_block_iterator> blocks() const {\n    return make_range(block_begin(), block_end());\n  }\n\n  op_range incoming_values() { return operands(); }\n\n  const_op_range incoming_values() const { return operands(); }\n\n  /// Return the number of incoming edges\n  ///\n  unsigned getNumIncomingValues() const { return getNumOperands(); }\n\n  /// Return incoming value number x\n  ///\n  Value *getIncomingValue(unsigned i) const {\n    return getOperand(i);\n  }\n  void setIncomingValue(unsigned i, Value *V) {\n    assert(V && \"PHI node got a null value!\");\n    assert(getType() == V->getType() &&\n           \"All operands to PHI node must be the same type as the PHI node!\");\n    setOperand(i, V);\n  }\n\n  static unsigned getOperandNumForIncomingValue(unsigned i) {\n    return i;\n  }\n\n  static unsigned getIncomingValueNumForOperand(unsigned i) {\n    return i;\n  }\n\n  /// Return incoming basic block number @p i.\n  ///\n  BasicBlock *getIncomingBlock(unsigned i) const {\n    return block_begin()[i];\n  }\n\n  /// Return incoming basic block corresponding\n  /// to an operand of the PHI.\n  ///\n  BasicBlock *getIncomingBlock(const Use &U) const {\n    assert(this == U.getUser() && \"Iterator doesn't point to PHI's Uses?\");\n    return getIncomingBlock(unsigned(&U - op_begin()));\n  }\n\n  /// Return incoming basic block corresponding\n  /// to value use iterator.\n  ///\n  BasicBlock *getIncomingBlock(Value::const_user_iterator I) const {\n    return getIncomingBlock(I.getUse());\n  }\n\n  void setIncomingBlock(unsigned i, BasicBlock *BB) {\n    assert(BB && \"PHI node got a null basic block!\");\n    block_begin()[i] = BB;\n  }\n\n  /// Replace every incoming basic block \\p Old to basic block \\p New.\n  void replaceIncomingBlockWith(const BasicBlock *Old, BasicBlock *New) {\n    assert(New && Old && \"PHI node got a null basic block!\");\n    for (unsigned Op = 0, NumOps = getNumOperands(); Op != NumOps; ++Op)\n      if (getIncomingBlock(Op) == Old)\n        setIncomingBlock(Op, New);\n  }\n\n  /// Add an incoming value to the end of the PHI list\n  ///\n  void addIncoming(Value *V, BasicBlock *BB) {\n    if (getNumOperands() == ReservedSpace)\n      growOperands();  // Get more space!\n    // Initialize some new operands.\n    setNumHungOffUseOperands(getNumOperands() + 1);\n    setIncomingValue(getNumOperands() - 1, V);\n    setIncomingBlock(getNumOperands() - 1, BB);\n  }\n\n  /// Remove an incoming value.  This is useful if a\n  /// predecessor basic block is deleted.  The value removed is returned.\n  ///\n  /// If the last incoming value for a PHI node is removed (and DeletePHIIfEmpty\n  /// is true), the PHI node is destroyed and any uses of it are replaced with\n  /// dummy values.  The only time there should be zero incoming values to a PHI\n  /// node is when the block is dead, so this strategy is sound.\n  ///\n  Value *removeIncomingValue(unsigned Idx, bool DeletePHIIfEmpty = true);\n\n  Value *removeIncomingValue(const BasicBlock *BB, bool DeletePHIIfEmpty=true) {\n    int Idx = getBasicBlockIndex(BB);\n    assert(Idx >= 0 && \"Invalid basic block argument to remove!\");\n    return removeIncomingValue(Idx, DeletePHIIfEmpty);\n  }\n\n  /// Return the first index of the specified basic\n  /// block in the value list for this PHI.  Returns -1 if no instance.\n  ///\n  int getBasicBlockIndex(const BasicBlock *BB) const {\n    for (unsigned i = 0, e = getNumOperands(); i != e; ++i)\n      if (block_begin()[i] == BB)\n        return i;\n    return -1;\n  }\n\n  Value *getIncomingValueForBlock(const BasicBlock *BB) const {\n    int Idx = getBasicBlockIndex(BB);\n    assert(Idx >= 0 && \"Invalid basic block argument!\");\n    return getIncomingValue(Idx);\n  }\n\n  /// Set every incoming value(s) for block \\p BB to \\p V.\n  void setIncomingValueForBlock(const BasicBlock *BB, Value *V) {\n    assert(BB && \"PHI node got a null basic block!\");\n    bool Found = false;\n    for (unsigned Op = 0, NumOps = getNumOperands(); Op != NumOps; ++Op)\n      if (getIncomingBlock(Op) == BB) {\n        Found = true;\n        setIncomingValue(Op, V);\n      }\n    (void)Found;\n    assert(Found && \"Invalid basic block argument to set!\");\n  }\n\n  /// If the specified PHI node always merges together the\n  /// same value, return the value, otherwise return null.\n  Value *hasConstantValue() const;\n\n  /// Whether the specified PHI node always merges\n  /// together the same value, assuming undefs are equal to a unique\n  /// non-undef value.\n  bool hasConstantOrUndefValue() const;\n\n  /// If the PHI node is complete which means all of its parent's predecessors\n  /// have incoming value in this PHI, return true, otherwise return false.\n  bool isComplete() const {\n    return llvm::all_of(predecessors(getParent()),\n                        [this](const BasicBlock *Pred) {\n                          return getBasicBlockIndex(Pred) >= 0;\n                        });\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::PHI;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  void growOperands();\n};\n\ntemplate <>\nstruct OperandTraits<PHINode> : public HungoffOperandTraits<2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(PHINode, Value)\n\n//===----------------------------------------------------------------------===//\n//                           LandingPadInst Class\n//===----------------------------------------------------------------------===//\n\n//===---------------------------------------------------------------------------\n/// The landingpad instruction holds all of the information\n/// necessary to generate correct exception handling. The landingpad instruction\n/// cannot be moved from the top of a landing pad block, which itself is\n/// accessible only from the 'unwind' edge of an invoke. This uses the\n/// SubclassData field in Value to store whether or not the landingpad is a\n/// cleanup.\n///\nclass LandingPadInst : public Instruction {\n  using CleanupField = BoolBitfieldElementT<0>;\n\n  /// The number of operands actually allocated.  NumOperands is\n  /// the number actually in use.\n  unsigned ReservedSpace;\n\n  LandingPadInst(const LandingPadInst &LP);\n\npublic:\n  enum ClauseType { Catch, Filter };\n\nprivate:\n  explicit LandingPadInst(Type *RetTy, unsigned NumReservedValues,\n                          const Twine &NameStr, Instruction *InsertBefore);\n  explicit LandingPadInst(Type *RetTy, unsigned NumReservedValues,\n                          const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  // Allocate space for exactly zero operands.\n  void *operator new(size_t s) {\n    return User::operator new(s);\n  }\n\n  void growOperands(unsigned Size);\n  void init(unsigned NumReservedValues, const Twine &NameStr);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  LandingPadInst *cloneImpl() const;\n\npublic:\n  /// Constructors - NumReservedClauses is a hint for the number of incoming\n  /// clauses that this landingpad will have (use 0 if you really have no idea).\n  static LandingPadInst *Create(Type *RetTy, unsigned NumReservedClauses,\n                                const Twine &NameStr = \"\",\n                                Instruction *InsertBefore = nullptr);\n  static LandingPadInst *Create(Type *RetTy, unsigned NumReservedClauses,\n                                const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Return 'true' if this landingpad instruction is a\n  /// cleanup. I.e., it should be run when unwinding even if its landing pad\n  /// doesn't catch the exception.\n  bool isCleanup() const { return getSubclassData<CleanupField>(); }\n\n  /// Indicate that this landingpad instruction is a cleanup.\n  void setCleanup(bool V) { setSubclassData<CleanupField>(V); }\n\n  /// Add a catch or filter clause to the landing pad.\n  void addClause(Constant *ClauseVal);\n\n  /// Get the value of the clause at index Idx. Use isCatch/isFilter to\n  /// determine what type of clause this is.\n  Constant *getClause(unsigned Idx) const {\n    return cast<Constant>(getOperandList()[Idx]);\n  }\n\n  /// Return 'true' if the clause and index Idx is a catch clause.\n  bool isCatch(unsigned Idx) const {\n    return !isa<ArrayType>(getOperandList()[Idx]->getType());\n  }\n\n  /// Return 'true' if the clause and index Idx is a filter clause.\n  bool isFilter(unsigned Idx) const {\n    return isa<ArrayType>(getOperandList()[Idx]->getType());\n  }\n\n  /// Get the number of clauses for this landing pad.\n  unsigned getNumClauses() const { return getNumOperands(); }\n\n  /// Grow the size of the operand list to accommodate the new\n  /// number of clauses.\n  void reserveClauses(unsigned Size) { growOperands(Size); }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::LandingPad;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<LandingPadInst> : public HungoffOperandTraits<1> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(LandingPadInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                               ReturnInst Class\n//===----------------------------------------------------------------------===//\n\n//===---------------------------------------------------------------------------\n/// Return a value (possibly void), from a function.  Execution\n/// does not continue in this function any longer.\n///\nclass ReturnInst : public Instruction {\n  ReturnInst(const ReturnInst &RI);\n\nprivate:\n  // ReturnInst constructors:\n  // ReturnInst()                  - 'ret void' instruction\n  // ReturnInst(    null)          - 'ret void' instruction\n  // ReturnInst(Value* X)          - 'ret X'    instruction\n  // ReturnInst(    null, Inst *I) - 'ret void' instruction, insert before I\n  // ReturnInst(Value* X, Inst *I) - 'ret X'    instruction, insert before I\n  // ReturnInst(    null, BB *B)   - 'ret void' instruction, insert @ end of B\n  // ReturnInst(Value* X, BB *B)   - 'ret X'    instruction, insert @ end of B\n  //\n  // NOTE: If the Value* passed is of type void then the constructor behaves as\n  // if it was passed NULL.\n  explicit ReturnInst(LLVMContext &C, Value *retVal = nullptr,\n                      Instruction *InsertBefore = nullptr);\n  ReturnInst(LLVMContext &C, Value *retVal, BasicBlock *InsertAtEnd);\n  explicit ReturnInst(LLVMContext &C, BasicBlock *InsertAtEnd);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  ReturnInst *cloneImpl() const;\n\npublic:\n  static ReturnInst* Create(LLVMContext &C, Value *retVal = nullptr,\n                            Instruction *InsertBefore = nullptr) {\n    return new(!!retVal) ReturnInst(C, retVal, InsertBefore);\n  }\n\n  static ReturnInst* Create(LLVMContext &C, Value *retVal,\n                            BasicBlock *InsertAtEnd) {\n    return new(!!retVal) ReturnInst(C, retVal, InsertAtEnd);\n  }\n\n  static ReturnInst* Create(LLVMContext &C, BasicBlock *InsertAtEnd) {\n    return new(0) ReturnInst(C, InsertAtEnd);\n  }\n\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Convenience accessor. Returns null if there is no return value.\n  Value *getReturnValue() const {\n    return getNumOperands() != 0 ? getOperand(0) : nullptr;\n  }\n\n  unsigned getNumSuccessors() const { return 0; }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return (I->getOpcode() == Instruction::Ret);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  BasicBlock *getSuccessor(unsigned idx) const {\n    llvm_unreachable(\"ReturnInst has no successors!\");\n  }\n\n  void setSuccessor(unsigned idx, BasicBlock *B) {\n    llvm_unreachable(\"ReturnInst has no successors!\");\n  }\n};\n\ntemplate <>\nstruct OperandTraits<ReturnInst> : public VariadicOperandTraits<ReturnInst> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(ReturnInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                               BranchInst Class\n//===----------------------------------------------------------------------===//\n\n//===---------------------------------------------------------------------------\n/// Conditional or Unconditional Branch instruction.\n///\nclass BranchInst : public Instruction {\n  /// Ops list - Branches are strange.  The operands are ordered:\n  ///  [Cond, FalseDest,] TrueDest.  This makes some accessors faster because\n  /// they don't have to check for cond/uncond branchness. These are mostly\n  /// accessed relative from op_end().\n  BranchInst(const BranchInst &BI);\n  // BranchInst constructors (where {B, T, F} are blocks, and C is a condition):\n  // BranchInst(BB *B)                           - 'br B'\n  // BranchInst(BB* T, BB *F, Value *C)          - 'br C, T, F'\n  // BranchInst(BB* B, Inst *I)                  - 'br B'        insert before I\n  // BranchInst(BB* T, BB *F, Value *C, Inst *I) - 'br C, T, F', insert before I\n  // BranchInst(BB* B, BB *I)                    - 'br B'        insert at end\n  // BranchInst(BB* T, BB *F, Value *C, BB *I)   - 'br C, T, F', insert at end\n  explicit BranchInst(BasicBlock *IfTrue, Instruction *InsertBefore = nullptr);\n  BranchInst(BasicBlock *IfTrue, BasicBlock *IfFalse, Value *Cond,\n             Instruction *InsertBefore = nullptr);\n  BranchInst(BasicBlock *IfTrue, BasicBlock *InsertAtEnd);\n  BranchInst(BasicBlock *IfTrue, BasicBlock *IfFalse, Value *Cond,\n             BasicBlock *InsertAtEnd);\n\n  void AssertOK();\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  BranchInst *cloneImpl() const;\n\npublic:\n  /// Iterator type that casts an operand to a basic block.\n  ///\n  /// This only makes sense because the successors are stored as adjacent\n  /// operands for branch instructions.\n  struct succ_op_iterator\n      : iterator_adaptor_base<succ_op_iterator, value_op_iterator,\n                              std::random_access_iterator_tag, BasicBlock *,\n                              ptrdiff_t, BasicBlock *, BasicBlock *> {\n    explicit succ_op_iterator(value_op_iterator I) : iterator_adaptor_base(I) {}\n\n    BasicBlock *operator*() const { return cast<BasicBlock>(*I); }\n    BasicBlock *operator->() const { return operator*(); }\n  };\n\n  /// The const version of `succ_op_iterator`.\n  struct const_succ_op_iterator\n      : iterator_adaptor_base<const_succ_op_iterator, const_value_op_iterator,\n                              std::random_access_iterator_tag,\n                              const BasicBlock *, ptrdiff_t, const BasicBlock *,\n                              const BasicBlock *> {\n    explicit const_succ_op_iterator(const_value_op_iterator I)\n        : iterator_adaptor_base(I) {}\n\n    const BasicBlock *operator*() const { return cast<BasicBlock>(*I); }\n    const BasicBlock *operator->() const { return operator*(); }\n  };\n\n  static BranchInst *Create(BasicBlock *IfTrue,\n                            Instruction *InsertBefore = nullptr) {\n    return new(1) BranchInst(IfTrue, InsertBefore);\n  }\n\n  static BranchInst *Create(BasicBlock *IfTrue, BasicBlock *IfFalse,\n                            Value *Cond, Instruction *InsertBefore = nullptr) {\n    return new(3) BranchInst(IfTrue, IfFalse, Cond, InsertBefore);\n  }\n\n  static BranchInst *Create(BasicBlock *IfTrue, BasicBlock *InsertAtEnd) {\n    return new(1) BranchInst(IfTrue, InsertAtEnd);\n  }\n\n  static BranchInst *Create(BasicBlock *IfTrue, BasicBlock *IfFalse,\n                            Value *Cond, BasicBlock *InsertAtEnd) {\n    return new(3) BranchInst(IfTrue, IfFalse, Cond, InsertAtEnd);\n  }\n\n  /// Transparently provide more efficient getOperand methods.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  bool isUnconditional() const { return getNumOperands() == 1; }\n  bool isConditional()   const { return getNumOperands() == 3; }\n\n  Value *getCondition() const {\n    assert(isConditional() && \"Cannot get condition of an uncond branch!\");\n    return Op<-3>();\n  }\n\n  void setCondition(Value *V) {\n    assert(isConditional() && \"Cannot set condition of unconditional branch!\");\n    Op<-3>() = V;\n  }\n\n  unsigned getNumSuccessors() const { return 1+isConditional(); }\n\n  BasicBlock *getSuccessor(unsigned i) const {\n    assert(i < getNumSuccessors() && \"Successor # out of range for Branch!\");\n    return cast_or_null<BasicBlock>((&Op<-1>() - i)->get());\n  }\n\n  void setSuccessor(unsigned idx, BasicBlock *NewSucc) {\n    assert(idx < getNumSuccessors() && \"Successor # out of range for Branch!\");\n    *(&Op<-1>() - idx) = NewSucc;\n  }\n\n  /// Swap the successors of this branch instruction.\n  ///\n  /// Swaps the successors of the branch instruction. This also swaps any\n  /// branch weight metadata associated with the instruction so that it\n  /// continues to map correctly to each operand.\n  void swapSuccessors();\n\n  iterator_range<succ_op_iterator> successors() {\n    return make_range(\n        succ_op_iterator(std::next(value_op_begin(), isConditional() ? 1 : 0)),\n        succ_op_iterator(value_op_end()));\n  }\n\n  iterator_range<const_succ_op_iterator> successors() const {\n    return make_range(const_succ_op_iterator(\n                          std::next(value_op_begin(), isConditional() ? 1 : 0)),\n                      const_succ_op_iterator(value_op_end()));\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return (I->getOpcode() == Instruction::Br);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<BranchInst> : public VariadicOperandTraits<BranchInst, 1> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(BranchInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                               SwitchInst Class\n//===----------------------------------------------------------------------===//\n\n//===---------------------------------------------------------------------------\n/// Multiway switch\n///\nclass SwitchInst : public Instruction {\n  unsigned ReservedSpace;\n\n  // Operand[0]    = Value to switch on\n  // Operand[1]    = Default basic block destination\n  // Operand[2n  ] = Value to match\n  // Operand[2n+1] = BasicBlock to go to on match\n  SwitchInst(const SwitchInst &SI);\n\n  /// Create a new switch instruction, specifying a value to switch on and a\n  /// default destination. The number of additional cases can be specified here\n  /// to make memory allocation more efficient. This constructor can also\n  /// auto-insert before another instruction.\n  SwitchInst(Value *Value, BasicBlock *Default, unsigned NumCases,\n             Instruction *InsertBefore);\n\n  /// Create a new switch instruction, specifying a value to switch on and a\n  /// default destination. The number of additional cases can be specified here\n  /// to make memory allocation more efficient. This constructor also\n  /// auto-inserts at the end of the specified BasicBlock.\n  SwitchInst(Value *Value, BasicBlock *Default, unsigned NumCases,\n             BasicBlock *InsertAtEnd);\n\n  // allocate space for exactly zero operands\n  void *operator new(size_t s) {\n    return User::operator new(s);\n  }\n\n  void init(Value *Value, BasicBlock *Default, unsigned NumReserved);\n  void growOperands();\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  SwitchInst *cloneImpl() const;\n\npublic:\n  // -2\n  static const unsigned DefaultPseudoIndex = static_cast<unsigned>(~0L-1);\n\n  template <typename CaseHandleT> class CaseIteratorImpl;\n\n  /// A handle to a particular switch case. It exposes a convenient interface\n  /// to both the case value and the successor block.\n  ///\n  /// We define this as a template and instantiate it to form both a const and\n  /// non-const handle.\n  template <typename SwitchInstT, typename ConstantIntT, typename BasicBlockT>\n  class CaseHandleImpl {\n    // Directly befriend both const and non-const iterators.\n    friend class SwitchInst::CaseIteratorImpl<\n        CaseHandleImpl<SwitchInstT, ConstantIntT, BasicBlockT>>;\n\n  protected:\n    // Expose the switch type we're parameterized with to the iterator.\n    using SwitchInstType = SwitchInstT;\n\n    SwitchInstT *SI;\n    ptrdiff_t Index;\n\n    CaseHandleImpl() = default;\n    CaseHandleImpl(SwitchInstT *SI, ptrdiff_t Index) : SI(SI), Index(Index) {}\n\n  public:\n    /// Resolves case value for current case.\n    ConstantIntT *getCaseValue() const {\n      assert((unsigned)Index < SI->getNumCases() &&\n             \"Index out the number of cases.\");\n      return reinterpret_cast<ConstantIntT *>(SI->getOperand(2 + Index * 2));\n    }\n\n    /// Resolves successor for current case.\n    BasicBlockT *getCaseSuccessor() const {\n      assert(((unsigned)Index < SI->getNumCases() ||\n              (unsigned)Index == DefaultPseudoIndex) &&\n             \"Index out the number of cases.\");\n      return SI->getSuccessor(getSuccessorIndex());\n    }\n\n    /// Returns number of current case.\n    unsigned getCaseIndex() const { return Index; }\n\n    /// Returns successor index for current case successor.\n    unsigned getSuccessorIndex() const {\n      assert(((unsigned)Index == DefaultPseudoIndex ||\n              (unsigned)Index < SI->getNumCases()) &&\n             \"Index out the number of cases.\");\n      return (unsigned)Index != DefaultPseudoIndex ? Index + 1 : 0;\n    }\n\n    bool operator==(const CaseHandleImpl &RHS) const {\n      assert(SI == RHS.SI && \"Incompatible operators.\");\n      return Index == RHS.Index;\n    }\n  };\n\n  using ConstCaseHandle =\n      CaseHandleImpl<const SwitchInst, const ConstantInt, const BasicBlock>;\n\n  class CaseHandle\n      : public CaseHandleImpl<SwitchInst, ConstantInt, BasicBlock> {\n    friend class SwitchInst::CaseIteratorImpl<CaseHandle>;\n\n  public:\n    CaseHandle(SwitchInst *SI, ptrdiff_t Index) : CaseHandleImpl(SI, Index) {}\n\n    /// Sets the new value for current case.\n    void setValue(ConstantInt *V) {\n      assert((unsigned)Index < SI->getNumCases() &&\n             \"Index out the number of cases.\");\n      SI->setOperand(2 + Index*2, reinterpret_cast<Value*>(V));\n    }\n\n    /// Sets the new successor for current case.\n    void setSuccessor(BasicBlock *S) {\n      SI->setSuccessor(getSuccessorIndex(), S);\n    }\n  };\n\n  template <typename CaseHandleT>\n  class CaseIteratorImpl\n      : public iterator_facade_base<CaseIteratorImpl<CaseHandleT>,\n                                    std::random_access_iterator_tag,\n                                    CaseHandleT> {\n    using SwitchInstT = typename CaseHandleT::SwitchInstType;\n\n    CaseHandleT Case;\n\n  public:\n    /// Default constructed iterator is in an invalid state until assigned to\n    /// a case for a particular switch.\n    CaseIteratorImpl() = default;\n\n    /// Initializes case iterator for given SwitchInst and for given\n    /// case number.\n    CaseIteratorImpl(SwitchInstT *SI, unsigned CaseNum) : Case(SI, CaseNum) {}\n\n    /// Initializes case iterator for given SwitchInst and for given\n    /// successor index.\n    static CaseIteratorImpl fromSuccessorIndex(SwitchInstT *SI,\n                                               unsigned SuccessorIndex) {\n      assert(SuccessorIndex < SI->getNumSuccessors() &&\n             \"Successor index # out of range!\");\n      return SuccessorIndex != 0 ? CaseIteratorImpl(SI, SuccessorIndex - 1)\n                                 : CaseIteratorImpl(SI, DefaultPseudoIndex);\n    }\n\n    /// Support converting to the const variant. This will be a no-op for const\n    /// variant.\n    operator CaseIteratorImpl<ConstCaseHandle>() const {\n      return CaseIteratorImpl<ConstCaseHandle>(Case.SI, Case.Index);\n    }\n\n    CaseIteratorImpl &operator+=(ptrdiff_t N) {\n      // Check index correctness after addition.\n      // Note: Index == getNumCases() means end().\n      assert(Case.Index + N >= 0 &&\n             (unsigned)(Case.Index + N) <= Case.SI->getNumCases() &&\n             \"Case.Index out the number of cases.\");\n      Case.Index += N;\n      return *this;\n    }\n    CaseIteratorImpl &operator-=(ptrdiff_t N) {\n      // Check index correctness after subtraction.\n      // Note: Case.Index == getNumCases() means end().\n      assert(Case.Index - N >= 0 &&\n             (unsigned)(Case.Index - N) <= Case.SI->getNumCases() &&\n             \"Case.Index out the number of cases.\");\n      Case.Index -= N;\n      return *this;\n    }\n    ptrdiff_t operator-(const CaseIteratorImpl &RHS) const {\n      assert(Case.SI == RHS.Case.SI && \"Incompatible operators.\");\n      return Case.Index - RHS.Case.Index;\n    }\n    bool operator==(const CaseIteratorImpl &RHS) const {\n      return Case == RHS.Case;\n    }\n    bool operator<(const CaseIteratorImpl &RHS) const {\n      assert(Case.SI == RHS.Case.SI && \"Incompatible operators.\");\n      return Case.Index < RHS.Case.Index;\n    }\n    CaseHandleT &operator*() { return Case; }\n    const CaseHandleT &operator*() const { return Case; }\n  };\n\n  using CaseIt = CaseIteratorImpl<CaseHandle>;\n  using ConstCaseIt = CaseIteratorImpl<ConstCaseHandle>;\n\n  static SwitchInst *Create(Value *Value, BasicBlock *Default,\n                            unsigned NumCases,\n                            Instruction *InsertBefore = nullptr) {\n    return new SwitchInst(Value, Default, NumCases, InsertBefore);\n  }\n\n  static SwitchInst *Create(Value *Value, BasicBlock *Default,\n                            unsigned NumCases, BasicBlock *InsertAtEnd) {\n    return new SwitchInst(Value, Default, NumCases, InsertAtEnd);\n  }\n\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  // Accessor Methods for Switch stmt\n  Value *getCondition() const { return getOperand(0); }\n  void setCondition(Value *V) { setOperand(0, V); }\n\n  BasicBlock *getDefaultDest() const {\n    return cast<BasicBlock>(getOperand(1));\n  }\n\n  void setDefaultDest(BasicBlock *DefaultCase) {\n    setOperand(1, reinterpret_cast<Value*>(DefaultCase));\n  }\n\n  /// Return the number of 'cases' in this switch instruction, excluding the\n  /// default case.\n  unsigned getNumCases() const {\n    return getNumOperands()/2 - 1;\n  }\n\n  /// Returns a read/write iterator that points to the first case in the\n  /// SwitchInst.\n  CaseIt case_begin() {\n    return CaseIt(this, 0);\n  }\n\n  /// Returns a read-only iterator that points to the first case in the\n  /// SwitchInst.\n  ConstCaseIt case_begin() const {\n    return ConstCaseIt(this, 0);\n  }\n\n  /// Returns a read/write iterator that points one past the last in the\n  /// SwitchInst.\n  CaseIt case_end() {\n    return CaseIt(this, getNumCases());\n  }\n\n  /// Returns a read-only iterator that points one past the last in the\n  /// SwitchInst.\n  ConstCaseIt case_end() const {\n    return ConstCaseIt(this, getNumCases());\n  }\n\n  /// Iteration adapter for range-for loops.\n  iterator_range<CaseIt> cases() {\n    return make_range(case_begin(), case_end());\n  }\n\n  /// Constant iteration adapter for range-for loops.\n  iterator_range<ConstCaseIt> cases() const {\n    return make_range(case_begin(), case_end());\n  }\n\n  /// Returns an iterator that points to the default case.\n  /// Note: this iterator allows to resolve successor only. Attempt\n  /// to resolve case value causes an assertion.\n  /// Also note, that increment and decrement also causes an assertion and\n  /// makes iterator invalid.\n  CaseIt case_default() {\n    return CaseIt(this, DefaultPseudoIndex);\n  }\n  ConstCaseIt case_default() const {\n    return ConstCaseIt(this, DefaultPseudoIndex);\n  }\n\n  /// Search all of the case values for the specified constant. If it is\n  /// explicitly handled, return the case iterator of it, otherwise return\n  /// default case iterator to indicate that it is handled by the default\n  /// handler.\n  CaseIt findCaseValue(const ConstantInt *C) {\n    CaseIt I = llvm::find_if(\n        cases(), [C](CaseHandle &Case) { return Case.getCaseValue() == C; });\n    if (I != case_end())\n      return I;\n\n    return case_default();\n  }\n  ConstCaseIt findCaseValue(const ConstantInt *C) const {\n    ConstCaseIt I = llvm::find_if(cases(), [C](ConstCaseHandle &Case) {\n      return Case.getCaseValue() == C;\n    });\n    if (I != case_end())\n      return I;\n\n    return case_default();\n  }\n\n  /// Finds the unique case value for a given successor. Returns null if the\n  /// successor is not found, not unique, or is the default case.\n  ConstantInt *findCaseDest(BasicBlock *BB) {\n    if (BB == getDefaultDest())\n      return nullptr;\n\n    ConstantInt *CI = nullptr;\n    for (auto Case : cases()) {\n      if (Case.getCaseSuccessor() != BB)\n        continue;\n\n      if (CI)\n        return nullptr; // Multiple cases lead to BB.\n\n      CI = Case.getCaseValue();\n    }\n\n    return CI;\n  }\n\n  /// Add an entry to the switch instruction.\n  /// Note:\n  /// This action invalidates case_end(). Old case_end() iterator will\n  /// point to the added case.\n  void addCase(ConstantInt *OnVal, BasicBlock *Dest);\n\n  /// This method removes the specified case and its successor from the switch\n  /// instruction. Note that this operation may reorder the remaining cases at\n  /// index idx and above.\n  /// Note:\n  /// This action invalidates iterators for all cases following the one removed,\n  /// including the case_end() iterator. It returns an iterator for the next\n  /// case.\n  CaseIt removeCase(CaseIt I);\n\n  unsigned getNumSuccessors() const { return getNumOperands()/2; }\n  BasicBlock *getSuccessor(unsigned idx) const {\n    assert(idx < getNumSuccessors() &&\"Successor idx out of range for switch!\");\n    return cast<BasicBlock>(getOperand(idx*2+1));\n  }\n  void setSuccessor(unsigned idx, BasicBlock *NewSucc) {\n    assert(idx < getNumSuccessors() && \"Successor # out of range for switch!\");\n    setOperand(idx * 2 + 1, NewSucc);\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Switch;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n/// A wrapper class to simplify modification of SwitchInst cases along with\n/// their prof branch_weights metadata.\nclass SwitchInstProfUpdateWrapper {\n  SwitchInst &SI;\n  Optional<SmallVector<uint32_t, 8> > Weights = None;\n  bool Changed = false;\n\nprotected:\n  static MDNode *getProfBranchWeightsMD(const SwitchInst &SI);\n\n  MDNode *buildProfBranchWeightsMD();\n\n  void init();\n\npublic:\n  using CaseWeightOpt = Optional<uint32_t>;\n  SwitchInst *operator->() { return &SI; }\n  SwitchInst &operator*() { return SI; }\n  operator SwitchInst *() { return &SI; }\n\n  SwitchInstProfUpdateWrapper(SwitchInst &SI) : SI(SI) { init(); }\n\n  ~SwitchInstProfUpdateWrapper() {\n    if (Changed)\n      SI.setMetadata(LLVMContext::MD_prof, buildProfBranchWeightsMD());\n  }\n\n  /// Delegate the call to the underlying SwitchInst::removeCase() and remove\n  /// correspondent branch weight.\n  SwitchInst::CaseIt removeCase(SwitchInst::CaseIt I);\n\n  /// Delegate the call to the underlying SwitchInst::addCase() and set the\n  /// specified branch weight for the added case.\n  void addCase(ConstantInt *OnVal, BasicBlock *Dest, CaseWeightOpt W);\n\n  /// Delegate the call to the underlying SwitchInst::eraseFromParent() and mark\n  /// this object to not touch the underlying SwitchInst in destructor.\n  SymbolTableList<Instruction>::iterator eraseFromParent();\n\n  void setSuccessorWeight(unsigned idx, CaseWeightOpt W);\n  CaseWeightOpt getSuccessorWeight(unsigned idx);\n\n  static CaseWeightOpt getSuccessorWeight(const SwitchInst &SI, unsigned idx);\n};\n\ntemplate <>\nstruct OperandTraits<SwitchInst> : public HungoffOperandTraits<2> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(SwitchInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                             IndirectBrInst Class\n//===----------------------------------------------------------------------===//\n\n//===---------------------------------------------------------------------------\n/// Indirect Branch Instruction.\n///\nclass IndirectBrInst : public Instruction {\n  unsigned ReservedSpace;\n\n  // Operand[0]   = Address to jump to\n  // Operand[n+1] = n-th destination\n  IndirectBrInst(const IndirectBrInst &IBI);\n\n  /// Create a new indirectbr instruction, specifying an\n  /// Address to jump to.  The number of expected destinations can be specified\n  /// here to make memory allocation more efficient.  This constructor can also\n  /// autoinsert before another instruction.\n  IndirectBrInst(Value *Address, unsigned NumDests, Instruction *InsertBefore);\n\n  /// Create a new indirectbr instruction, specifying an\n  /// Address to jump to.  The number of expected destinations can be specified\n  /// here to make memory allocation more efficient.  This constructor also\n  /// autoinserts at the end of the specified BasicBlock.\n  IndirectBrInst(Value *Address, unsigned NumDests, BasicBlock *InsertAtEnd);\n\n  // allocate space for exactly zero operands\n  void *operator new(size_t s) {\n    return User::operator new(s);\n  }\n\n  void init(Value *Address, unsigned NumDests);\n  void growOperands();\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  IndirectBrInst *cloneImpl() const;\n\npublic:\n  /// Iterator type that casts an operand to a basic block.\n  ///\n  /// This only makes sense because the successors are stored as adjacent\n  /// operands for indirectbr instructions.\n  struct succ_op_iterator\n      : iterator_adaptor_base<succ_op_iterator, value_op_iterator,\n                              std::random_access_iterator_tag, BasicBlock *,\n                              ptrdiff_t, BasicBlock *, BasicBlock *> {\n    explicit succ_op_iterator(value_op_iterator I) : iterator_adaptor_base(I) {}\n\n    BasicBlock *operator*() const { return cast<BasicBlock>(*I); }\n    BasicBlock *operator->() const { return operator*(); }\n  };\n\n  /// The const version of `succ_op_iterator`.\n  struct const_succ_op_iterator\n      : iterator_adaptor_base<const_succ_op_iterator, const_value_op_iterator,\n                              std::random_access_iterator_tag,\n                              const BasicBlock *, ptrdiff_t, const BasicBlock *,\n                              const BasicBlock *> {\n    explicit const_succ_op_iterator(const_value_op_iterator I)\n        : iterator_adaptor_base(I) {}\n\n    const BasicBlock *operator*() const { return cast<BasicBlock>(*I); }\n    const BasicBlock *operator->() const { return operator*(); }\n  };\n\n  static IndirectBrInst *Create(Value *Address, unsigned NumDests,\n                                Instruction *InsertBefore = nullptr) {\n    return new IndirectBrInst(Address, NumDests, InsertBefore);\n  }\n\n  static IndirectBrInst *Create(Value *Address, unsigned NumDests,\n                                BasicBlock *InsertAtEnd) {\n    return new IndirectBrInst(Address, NumDests, InsertAtEnd);\n  }\n\n  /// Provide fast operand accessors.\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  // Accessor Methods for IndirectBrInst instruction.\n  Value *getAddress() { return getOperand(0); }\n  const Value *getAddress() const { return getOperand(0); }\n  void setAddress(Value *V) { setOperand(0, V); }\n\n  /// return the number of possible destinations in this\n  /// indirectbr instruction.\n  unsigned getNumDestinations() const { return getNumOperands()-1; }\n\n  /// Return the specified destination.\n  BasicBlock *getDestination(unsigned i) { return getSuccessor(i); }\n  const BasicBlock *getDestination(unsigned i) const { return getSuccessor(i); }\n\n  /// Add a destination.\n  ///\n  void addDestination(BasicBlock *Dest);\n\n  /// This method removes the specified successor from the\n  /// indirectbr instruction.\n  void removeDestination(unsigned i);\n\n  unsigned getNumSuccessors() const { return getNumOperands()-1; }\n  BasicBlock *getSuccessor(unsigned i) const {\n    return cast<BasicBlock>(getOperand(i+1));\n  }\n  void setSuccessor(unsigned i, BasicBlock *NewSucc) {\n    setOperand(i + 1, NewSucc);\n  }\n\n  iterator_range<succ_op_iterator> successors() {\n    return make_range(succ_op_iterator(std::next(value_op_begin())),\n                      succ_op_iterator(value_op_end()));\n  }\n\n  iterator_range<const_succ_op_iterator> successors() const {\n    return make_range(const_succ_op_iterator(std::next(value_op_begin())),\n                      const_succ_op_iterator(value_op_end()));\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::IndirectBr;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<IndirectBrInst> : public HungoffOperandTraits<1> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(IndirectBrInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                               InvokeInst Class\n//===----------------------------------------------------------------------===//\n\n/// Invoke instruction.  The SubclassData field is used to hold the\n/// calling convention of the call.\n///\nclass InvokeInst : public CallBase {\n  /// The number of operands for this call beyond the called function,\n  /// arguments, and operand bundles.\n  static constexpr int NumExtraOperands = 2;\n\n  /// The index from the end of the operand array to the normal destination.\n  static constexpr int NormalDestOpEndIdx = -3;\n\n  /// The index from the end of the operand array to the unwind destination.\n  static constexpr int UnwindDestOpEndIdx = -2;\n\n  InvokeInst(const InvokeInst &BI);\n\n  /// Construct an InvokeInst given a range of arguments.\n  ///\n  /// Construct an InvokeInst from a range of arguments\n  inline InvokeInst(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n                    BasicBlock *IfException, ArrayRef<Value *> Args,\n                    ArrayRef<OperandBundleDef> Bundles, int NumOperands,\n                    const Twine &NameStr, Instruction *InsertBefore);\n\n  inline InvokeInst(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n                    BasicBlock *IfException, ArrayRef<Value *> Args,\n                    ArrayRef<OperandBundleDef> Bundles, int NumOperands,\n                    const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  void init(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n            BasicBlock *IfException, ArrayRef<Value *> Args,\n            ArrayRef<OperandBundleDef> Bundles, const Twine &NameStr);\n\n  /// Compute the number of operands to allocate.\n  static int ComputeNumOperands(int NumArgs, int NumBundleInputs = 0) {\n    // We need one operand for the called function, plus our extra operands and\n    // the input operand counts provided.\n    return 1 + NumExtraOperands + NumArgs + NumBundleInputs;\n  }\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  InvokeInst *cloneImpl() const;\n\npublic:\n  static InvokeInst *Create(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n                            BasicBlock *IfException, ArrayRef<Value *> Args,\n                            const Twine &NameStr,\n                            Instruction *InsertBefore = nullptr) {\n    int NumOperands = ComputeNumOperands(Args.size());\n    return new (NumOperands)\n        InvokeInst(Ty, Func, IfNormal, IfException, Args, None, NumOperands,\n                   NameStr, InsertBefore);\n  }\n\n  static InvokeInst *Create(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n                            BasicBlock *IfException, ArrayRef<Value *> Args,\n                            ArrayRef<OperandBundleDef> Bundles = None,\n                            const Twine &NameStr = \"\",\n                            Instruction *InsertBefore = nullptr) {\n    int NumOperands =\n        ComputeNumOperands(Args.size(), CountBundleInputs(Bundles));\n    unsigned DescriptorBytes = Bundles.size() * sizeof(BundleOpInfo);\n\n    return new (NumOperands, DescriptorBytes)\n        InvokeInst(Ty, Func, IfNormal, IfException, Args, Bundles, NumOperands,\n                   NameStr, InsertBefore);\n  }\n\n  static InvokeInst *Create(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n                            BasicBlock *IfException, ArrayRef<Value *> Args,\n                            const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    int NumOperands = ComputeNumOperands(Args.size());\n    return new (NumOperands)\n        InvokeInst(Ty, Func, IfNormal, IfException, Args, None, NumOperands,\n                   NameStr, InsertAtEnd);\n  }\n\n  static InvokeInst *Create(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n                            BasicBlock *IfException, ArrayRef<Value *> Args,\n                            ArrayRef<OperandBundleDef> Bundles,\n                            const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    int NumOperands =\n        ComputeNumOperands(Args.size(), CountBundleInputs(Bundles));\n    unsigned DescriptorBytes = Bundles.size() * sizeof(BundleOpInfo);\n\n    return new (NumOperands, DescriptorBytes)\n        InvokeInst(Ty, Func, IfNormal, IfException, Args, Bundles, NumOperands,\n                   NameStr, InsertAtEnd);\n  }\n\n  static InvokeInst *Create(FunctionCallee Func, BasicBlock *IfNormal,\n                            BasicBlock *IfException, ArrayRef<Value *> Args,\n                            const Twine &NameStr,\n                            Instruction *InsertBefore = nullptr) {\n    return Create(Func.getFunctionType(), Func.getCallee(), IfNormal,\n                  IfException, Args, None, NameStr, InsertBefore);\n  }\n\n  static InvokeInst *Create(FunctionCallee Func, BasicBlock *IfNormal,\n                            BasicBlock *IfException, ArrayRef<Value *> Args,\n                            ArrayRef<OperandBundleDef> Bundles = None,\n                            const Twine &NameStr = \"\",\n                            Instruction *InsertBefore = nullptr) {\n    return Create(Func.getFunctionType(), Func.getCallee(), IfNormal,\n                  IfException, Args, Bundles, NameStr, InsertBefore);\n  }\n\n  static InvokeInst *Create(FunctionCallee Func, BasicBlock *IfNormal,\n                            BasicBlock *IfException, ArrayRef<Value *> Args,\n                            const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    return Create(Func.getFunctionType(), Func.getCallee(), IfNormal,\n                  IfException, Args, NameStr, InsertAtEnd);\n  }\n\n  static InvokeInst *Create(FunctionCallee Func, BasicBlock *IfNormal,\n                            BasicBlock *IfException, ArrayRef<Value *> Args,\n                            ArrayRef<OperandBundleDef> Bundles,\n                            const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    return Create(Func.getFunctionType(), Func.getCallee(), IfNormal,\n                  IfException, Args, Bundles, NameStr, InsertAtEnd);\n  }\n\n  /// Create a clone of \\p II with a different set of operand bundles and\n  /// insert it before \\p InsertPt.\n  ///\n  /// The returned invoke instruction is identical to \\p II in every way except\n  /// that the operand bundles for the new instruction are set to the operand\n  /// bundles in \\p Bundles.\n  static InvokeInst *Create(InvokeInst *II, ArrayRef<OperandBundleDef> Bundles,\n                            Instruction *InsertPt = nullptr);\n\n  // get*Dest - Return the destination basic blocks...\n  BasicBlock *getNormalDest() const {\n    return cast<BasicBlock>(Op<NormalDestOpEndIdx>());\n  }\n  BasicBlock *getUnwindDest() const {\n    return cast<BasicBlock>(Op<UnwindDestOpEndIdx>());\n  }\n  void setNormalDest(BasicBlock *B) {\n    Op<NormalDestOpEndIdx>() = reinterpret_cast<Value *>(B);\n  }\n  void setUnwindDest(BasicBlock *B) {\n    Op<UnwindDestOpEndIdx>() = reinterpret_cast<Value *>(B);\n  }\n\n  /// Get the landingpad instruction from the landing pad\n  /// block (the unwind destination).\n  LandingPadInst *getLandingPadInst() const;\n\n  BasicBlock *getSuccessor(unsigned i) const {\n    assert(i < 2 && \"Successor # out of range for invoke!\");\n    return i == 0 ? getNormalDest() : getUnwindDest();\n  }\n\n  void setSuccessor(unsigned i, BasicBlock *NewSucc) {\n    assert(i < 2 && \"Successor # out of range for invoke!\");\n    if (i == 0)\n      setNormalDest(NewSucc);\n    else\n      setUnwindDest(NewSucc);\n  }\n\n  unsigned getNumSuccessors() const { return 2; }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return (I->getOpcode() == Instruction::Invoke);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n};\n\nInvokeInst::InvokeInst(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n                       BasicBlock *IfException, ArrayRef<Value *> Args,\n                       ArrayRef<OperandBundleDef> Bundles, int NumOperands,\n                       const Twine &NameStr, Instruction *InsertBefore)\n    : CallBase(Ty->getReturnType(), Instruction::Invoke,\n               OperandTraits<CallBase>::op_end(this) - NumOperands, NumOperands,\n               InsertBefore) {\n  init(Ty, Func, IfNormal, IfException, Args, Bundles, NameStr);\n}\n\nInvokeInst::InvokeInst(FunctionType *Ty, Value *Func, BasicBlock *IfNormal,\n                       BasicBlock *IfException, ArrayRef<Value *> Args,\n                       ArrayRef<OperandBundleDef> Bundles, int NumOperands,\n                       const Twine &NameStr, BasicBlock *InsertAtEnd)\n    : CallBase(Ty->getReturnType(), Instruction::Invoke,\n               OperandTraits<CallBase>::op_end(this) - NumOperands, NumOperands,\n               InsertAtEnd) {\n  init(Ty, Func, IfNormal, IfException, Args, Bundles, NameStr);\n}\n\n//===----------------------------------------------------------------------===//\n//                              CallBrInst Class\n//===----------------------------------------------------------------------===//\n\n/// CallBr instruction, tracking function calls that may not return control but\n/// instead transfer it to a third location. The SubclassData field is used to\n/// hold the calling convention of the call.\n///\nclass CallBrInst : public CallBase {\n\n  unsigned NumIndirectDests;\n\n  CallBrInst(const CallBrInst &BI);\n\n  /// Construct a CallBrInst given a range of arguments.\n  ///\n  /// Construct a CallBrInst from a range of arguments\n  inline CallBrInst(FunctionType *Ty, Value *Func, BasicBlock *DefaultDest,\n                    ArrayRef<BasicBlock *> IndirectDests,\n                    ArrayRef<Value *> Args,\n                    ArrayRef<OperandBundleDef> Bundles, int NumOperands,\n                    const Twine &NameStr, Instruction *InsertBefore);\n\n  inline CallBrInst(FunctionType *Ty, Value *Func, BasicBlock *DefaultDest,\n                    ArrayRef<BasicBlock *> IndirectDests,\n                    ArrayRef<Value *> Args,\n                    ArrayRef<OperandBundleDef> Bundles, int NumOperands,\n                    const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  void init(FunctionType *FTy, Value *Func, BasicBlock *DefaultDest,\n            ArrayRef<BasicBlock *> IndirectDests, ArrayRef<Value *> Args,\n            ArrayRef<OperandBundleDef> Bundles, const Twine &NameStr);\n\n  /// Should the Indirect Destinations change, scan + update the Arg list.\n  void updateArgBlockAddresses(unsigned i, BasicBlock *B);\n\n  /// Compute the number of operands to allocate.\n  static int ComputeNumOperands(int NumArgs, int NumIndirectDests,\n                                int NumBundleInputs = 0) {\n    // We need one operand for the called function, plus our extra operands and\n    // the input operand counts provided.\n    return 2 + NumIndirectDests + NumArgs + NumBundleInputs;\n  }\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  CallBrInst *cloneImpl() const;\n\npublic:\n  static CallBrInst *Create(FunctionType *Ty, Value *Func,\n                            BasicBlock *DefaultDest,\n                            ArrayRef<BasicBlock *> IndirectDests,\n                            ArrayRef<Value *> Args, const Twine &NameStr,\n                            Instruction *InsertBefore = nullptr) {\n    int NumOperands = ComputeNumOperands(Args.size(), IndirectDests.size());\n    return new (NumOperands)\n        CallBrInst(Ty, Func, DefaultDest, IndirectDests, Args, None,\n                   NumOperands, NameStr, InsertBefore);\n  }\n\n  static CallBrInst *Create(FunctionType *Ty, Value *Func,\n                            BasicBlock *DefaultDest,\n                            ArrayRef<BasicBlock *> IndirectDests,\n                            ArrayRef<Value *> Args,\n                            ArrayRef<OperandBundleDef> Bundles = None,\n                            const Twine &NameStr = \"\",\n                            Instruction *InsertBefore = nullptr) {\n    int NumOperands = ComputeNumOperands(Args.size(), IndirectDests.size(),\n                                         CountBundleInputs(Bundles));\n    unsigned DescriptorBytes = Bundles.size() * sizeof(BundleOpInfo);\n\n    return new (NumOperands, DescriptorBytes)\n        CallBrInst(Ty, Func, DefaultDest, IndirectDests, Args, Bundles,\n                   NumOperands, NameStr, InsertBefore);\n  }\n\n  static CallBrInst *Create(FunctionType *Ty, Value *Func,\n                            BasicBlock *DefaultDest,\n                            ArrayRef<BasicBlock *> IndirectDests,\n                            ArrayRef<Value *> Args, const Twine &NameStr,\n                            BasicBlock *InsertAtEnd) {\n    int NumOperands = ComputeNumOperands(Args.size(), IndirectDests.size());\n    return new (NumOperands)\n        CallBrInst(Ty, Func, DefaultDest, IndirectDests, Args, None,\n                   NumOperands, NameStr, InsertAtEnd);\n  }\n\n  static CallBrInst *Create(FunctionType *Ty, Value *Func,\n                            BasicBlock *DefaultDest,\n                            ArrayRef<BasicBlock *> IndirectDests,\n                            ArrayRef<Value *> Args,\n                            ArrayRef<OperandBundleDef> Bundles,\n                            const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    int NumOperands = ComputeNumOperands(Args.size(), IndirectDests.size(),\n                                         CountBundleInputs(Bundles));\n    unsigned DescriptorBytes = Bundles.size() * sizeof(BundleOpInfo);\n\n    return new (NumOperands, DescriptorBytes)\n        CallBrInst(Ty, Func, DefaultDest, IndirectDests, Args, Bundles,\n                   NumOperands, NameStr, InsertAtEnd);\n  }\n\n  static CallBrInst *Create(FunctionCallee Func, BasicBlock *DefaultDest,\n                            ArrayRef<BasicBlock *> IndirectDests,\n                            ArrayRef<Value *> Args, const Twine &NameStr,\n                            Instruction *InsertBefore = nullptr) {\n    return Create(Func.getFunctionType(), Func.getCallee(), DefaultDest,\n                  IndirectDests, Args, NameStr, InsertBefore);\n  }\n\n  static CallBrInst *Create(FunctionCallee Func, BasicBlock *DefaultDest,\n                            ArrayRef<BasicBlock *> IndirectDests,\n                            ArrayRef<Value *> Args,\n                            ArrayRef<OperandBundleDef> Bundles = None,\n                            const Twine &NameStr = \"\",\n                            Instruction *InsertBefore = nullptr) {\n    return Create(Func.getFunctionType(), Func.getCallee(), DefaultDest,\n                  IndirectDests, Args, Bundles, NameStr, InsertBefore);\n  }\n\n  static CallBrInst *Create(FunctionCallee Func, BasicBlock *DefaultDest,\n                            ArrayRef<BasicBlock *> IndirectDests,\n                            ArrayRef<Value *> Args, const Twine &NameStr,\n                            BasicBlock *InsertAtEnd) {\n    return Create(Func.getFunctionType(), Func.getCallee(), DefaultDest,\n                  IndirectDests, Args, NameStr, InsertAtEnd);\n  }\n\n  static CallBrInst *Create(FunctionCallee Func,\n                            BasicBlock *DefaultDest,\n                            ArrayRef<BasicBlock *> IndirectDests,\n                            ArrayRef<Value *> Args,\n                            ArrayRef<OperandBundleDef> Bundles,\n                            const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    return Create(Func.getFunctionType(), Func.getCallee(), DefaultDest,\n                  IndirectDests, Args, Bundles, NameStr, InsertAtEnd);\n  }\n\n  /// Create a clone of \\p CBI with a different set of operand bundles and\n  /// insert it before \\p InsertPt.\n  ///\n  /// The returned callbr instruction is identical to \\p CBI in every way\n  /// except that the operand bundles for the new instruction are set to the\n  /// operand bundles in \\p Bundles.\n  static CallBrInst *Create(CallBrInst *CBI,\n                            ArrayRef<OperandBundleDef> Bundles,\n                            Instruction *InsertPt = nullptr);\n\n  /// Return the number of callbr indirect dest labels.\n  ///\n  unsigned getNumIndirectDests() const { return NumIndirectDests; }\n\n  /// getIndirectDestLabel - Return the i-th indirect dest label.\n  ///\n  Value *getIndirectDestLabel(unsigned i) const {\n    assert(i < getNumIndirectDests() && \"Out of bounds!\");\n    return getOperand(i + getNumArgOperands() + getNumTotalBundleOperands() +\n                      1);\n  }\n\n  Value *getIndirectDestLabelUse(unsigned i) const {\n    assert(i < getNumIndirectDests() && \"Out of bounds!\");\n    return getOperandUse(i + getNumArgOperands() + getNumTotalBundleOperands() +\n                         1);\n  }\n\n  // Return the destination basic blocks...\n  BasicBlock *getDefaultDest() const {\n    return cast<BasicBlock>(*(&Op<-1>() - getNumIndirectDests() - 1));\n  }\n  BasicBlock *getIndirectDest(unsigned i) const {\n    return cast_or_null<BasicBlock>(*(&Op<-1>() - getNumIndirectDests() + i));\n  }\n  SmallVector<BasicBlock *, 16> getIndirectDests() const {\n    SmallVector<BasicBlock *, 16> IndirectDests;\n    for (unsigned i = 0, e = getNumIndirectDests(); i < e; ++i)\n      IndirectDests.push_back(getIndirectDest(i));\n    return IndirectDests;\n  }\n  void setDefaultDest(BasicBlock *B) {\n    *(&Op<-1>() - getNumIndirectDests() - 1) = reinterpret_cast<Value *>(B);\n  }\n  void setIndirectDest(unsigned i, BasicBlock *B) {\n    updateArgBlockAddresses(i, B);\n    *(&Op<-1>() - getNumIndirectDests() + i) = reinterpret_cast<Value *>(B);\n  }\n\n  BasicBlock *getSuccessor(unsigned i) const {\n    assert(i < getNumSuccessors() + 1 &&\n           \"Successor # out of range for callbr!\");\n    return i == 0 ? getDefaultDest() : getIndirectDest(i - 1);\n  }\n\n  void setSuccessor(unsigned i, BasicBlock *NewSucc) {\n    assert(i < getNumIndirectDests() + 1 &&\n           \"Successor # out of range for callbr!\");\n    return i == 0 ? setDefaultDest(NewSucc) : setIndirectDest(i - 1, NewSucc);\n  }\n\n  unsigned getNumSuccessors() const { return getNumIndirectDests() + 1; }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return (I->getOpcode() == Instruction::CallBr);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n};\n\nCallBrInst::CallBrInst(FunctionType *Ty, Value *Func, BasicBlock *DefaultDest,\n                       ArrayRef<BasicBlock *> IndirectDests,\n                       ArrayRef<Value *> Args,\n                       ArrayRef<OperandBundleDef> Bundles, int NumOperands,\n                       const Twine &NameStr, Instruction *InsertBefore)\n    : CallBase(Ty->getReturnType(), Instruction::CallBr,\n               OperandTraits<CallBase>::op_end(this) - NumOperands, NumOperands,\n               InsertBefore) {\n  init(Ty, Func, DefaultDest, IndirectDests, Args, Bundles, NameStr);\n}\n\nCallBrInst::CallBrInst(FunctionType *Ty, Value *Func, BasicBlock *DefaultDest,\n                       ArrayRef<BasicBlock *> IndirectDests,\n                       ArrayRef<Value *> Args,\n                       ArrayRef<OperandBundleDef> Bundles, int NumOperands,\n                       const Twine &NameStr, BasicBlock *InsertAtEnd)\n    : CallBase(Ty->getReturnType(), Instruction::CallBr,\n               OperandTraits<CallBase>::op_end(this) - NumOperands, NumOperands,\n               InsertAtEnd) {\n  init(Ty, Func, DefaultDest, IndirectDests, Args, Bundles, NameStr);\n}\n\n//===----------------------------------------------------------------------===//\n//                              ResumeInst Class\n//===----------------------------------------------------------------------===//\n\n//===---------------------------------------------------------------------------\n/// Resume the propagation of an exception.\n///\nclass ResumeInst : public Instruction {\n  ResumeInst(const ResumeInst &RI);\n\n  explicit ResumeInst(Value *Exn, Instruction *InsertBefore=nullptr);\n  ResumeInst(Value *Exn, BasicBlock *InsertAtEnd);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  ResumeInst *cloneImpl() const;\n\npublic:\n  static ResumeInst *Create(Value *Exn, Instruction *InsertBefore = nullptr) {\n    return new(1) ResumeInst(Exn, InsertBefore);\n  }\n\n  static ResumeInst *Create(Value *Exn, BasicBlock *InsertAtEnd) {\n    return new(1) ResumeInst(Exn, InsertAtEnd);\n  }\n\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Convenience accessor.\n  Value *getValue() const { return Op<0>(); }\n\n  unsigned getNumSuccessors() const { return 0; }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Resume;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  BasicBlock *getSuccessor(unsigned idx) const {\n    llvm_unreachable(\"ResumeInst has no successors!\");\n  }\n\n  void setSuccessor(unsigned idx, BasicBlock *NewSucc) {\n    llvm_unreachable(\"ResumeInst has no successors!\");\n  }\n};\n\ntemplate <>\nstruct OperandTraits<ResumeInst> :\n    public FixedNumOperandTraits<ResumeInst, 1> {\n};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(ResumeInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                         CatchSwitchInst Class\n//===----------------------------------------------------------------------===//\nclass CatchSwitchInst : public Instruction {\n  using UnwindDestField = BoolBitfieldElementT<0>;\n\n  /// The number of operands actually allocated.  NumOperands is\n  /// the number actually in use.\n  unsigned ReservedSpace;\n\n  // Operand[0] = Outer scope\n  // Operand[1] = Unwind block destination\n  // Operand[n] = BasicBlock to go to on match\n  CatchSwitchInst(const CatchSwitchInst &CSI);\n\n  /// Create a new switch instruction, specifying a\n  /// default destination.  The number of additional handlers can be specified\n  /// here to make memory allocation more efficient.\n  /// This constructor can also autoinsert before another instruction.\n  CatchSwitchInst(Value *ParentPad, BasicBlock *UnwindDest,\n                  unsigned NumHandlers, const Twine &NameStr,\n                  Instruction *InsertBefore);\n\n  /// Create a new switch instruction, specifying a\n  /// default destination.  The number of additional handlers can be specified\n  /// here to make memory allocation more efficient.\n  /// This constructor also autoinserts at the end of the specified BasicBlock.\n  CatchSwitchInst(Value *ParentPad, BasicBlock *UnwindDest,\n                  unsigned NumHandlers, const Twine &NameStr,\n                  BasicBlock *InsertAtEnd);\n\n  // allocate space for exactly zero operands\n  void *operator new(size_t s) { return User::operator new(s); }\n\n  void init(Value *ParentPad, BasicBlock *UnwindDest, unsigned NumReserved);\n  void growOperands(unsigned Size);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  CatchSwitchInst *cloneImpl() const;\n\npublic:\n  static CatchSwitchInst *Create(Value *ParentPad, BasicBlock *UnwindDest,\n                                 unsigned NumHandlers,\n                                 const Twine &NameStr = \"\",\n                                 Instruction *InsertBefore = nullptr) {\n    return new CatchSwitchInst(ParentPad, UnwindDest, NumHandlers, NameStr,\n                               InsertBefore);\n  }\n\n  static CatchSwitchInst *Create(Value *ParentPad, BasicBlock *UnwindDest,\n                                 unsigned NumHandlers, const Twine &NameStr,\n                                 BasicBlock *InsertAtEnd) {\n    return new CatchSwitchInst(ParentPad, UnwindDest, NumHandlers, NameStr,\n                               InsertAtEnd);\n  }\n\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  // Accessor Methods for CatchSwitch stmt\n  Value *getParentPad() const { return getOperand(0); }\n  void setParentPad(Value *ParentPad) { setOperand(0, ParentPad); }\n\n  // Accessor Methods for CatchSwitch stmt\n  bool hasUnwindDest() const { return getSubclassData<UnwindDestField>(); }\n  bool unwindsToCaller() const { return !hasUnwindDest(); }\n  BasicBlock *getUnwindDest() const {\n    if (hasUnwindDest())\n      return cast<BasicBlock>(getOperand(1));\n    return nullptr;\n  }\n  void setUnwindDest(BasicBlock *UnwindDest) {\n    assert(UnwindDest);\n    assert(hasUnwindDest());\n    setOperand(1, UnwindDest);\n  }\n\n  /// return the number of 'handlers' in this catchswitch\n  /// instruction, except the default handler\n  unsigned getNumHandlers() const {\n    if (hasUnwindDest())\n      return getNumOperands() - 2;\n    return getNumOperands() - 1;\n  }\n\nprivate:\n  static BasicBlock *handler_helper(Value *V) { return cast<BasicBlock>(V); }\n  static const BasicBlock *handler_helper(const Value *V) {\n    return cast<BasicBlock>(V);\n  }\n\npublic:\n  using DerefFnTy = BasicBlock *(*)(Value *);\n  using handler_iterator = mapped_iterator<op_iterator, DerefFnTy>;\n  using handler_range = iterator_range<handler_iterator>;\n  using ConstDerefFnTy = const BasicBlock *(*)(const Value *);\n  using const_handler_iterator =\n      mapped_iterator<const_op_iterator, ConstDerefFnTy>;\n  using const_handler_range = iterator_range<const_handler_iterator>;\n\n  /// Returns an iterator that points to the first handler in CatchSwitchInst.\n  handler_iterator handler_begin() {\n    op_iterator It = op_begin() + 1;\n    if (hasUnwindDest())\n      ++It;\n    return handler_iterator(It, DerefFnTy(handler_helper));\n  }\n\n  /// Returns an iterator that points to the first handler in the\n  /// CatchSwitchInst.\n  const_handler_iterator handler_begin() const {\n    const_op_iterator It = op_begin() + 1;\n    if (hasUnwindDest())\n      ++It;\n    return const_handler_iterator(It, ConstDerefFnTy(handler_helper));\n  }\n\n  /// Returns a read-only iterator that points one past the last\n  /// handler in the CatchSwitchInst.\n  handler_iterator handler_end() {\n    return handler_iterator(op_end(), DerefFnTy(handler_helper));\n  }\n\n  /// Returns an iterator that points one past the last handler in the\n  /// CatchSwitchInst.\n  const_handler_iterator handler_end() const {\n    return const_handler_iterator(op_end(), ConstDerefFnTy(handler_helper));\n  }\n\n  /// iteration adapter for range-for loops.\n  handler_range handlers() {\n    return make_range(handler_begin(), handler_end());\n  }\n\n  /// iteration adapter for range-for loops.\n  const_handler_range handlers() const {\n    return make_range(handler_begin(), handler_end());\n  }\n\n  /// Add an entry to the switch instruction...\n  /// Note:\n  /// This action invalidates handler_end(). Old handler_end() iterator will\n  /// point to the added handler.\n  void addHandler(BasicBlock *Dest);\n\n  void removeHandler(handler_iterator HI);\n\n  unsigned getNumSuccessors() const { return getNumOperands() - 1; }\n  BasicBlock *getSuccessor(unsigned Idx) const {\n    assert(Idx < getNumSuccessors() &&\n           \"Successor # out of range for catchswitch!\");\n    return cast<BasicBlock>(getOperand(Idx + 1));\n  }\n  void setSuccessor(unsigned Idx, BasicBlock *NewSucc) {\n    assert(Idx < getNumSuccessors() &&\n           \"Successor # out of range for catchswitch!\");\n    setOperand(Idx + 1, NewSucc);\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::CatchSwitch;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\ntemplate <>\nstruct OperandTraits<CatchSwitchInst> : public HungoffOperandTraits<2> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(CatchSwitchInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                               CleanupPadInst Class\n//===----------------------------------------------------------------------===//\nclass CleanupPadInst : public FuncletPadInst {\nprivate:\n  explicit CleanupPadInst(Value *ParentPad, ArrayRef<Value *> Args,\n                          unsigned Values, const Twine &NameStr,\n                          Instruction *InsertBefore)\n      : FuncletPadInst(Instruction::CleanupPad, ParentPad, Args, Values,\n                       NameStr, InsertBefore) {}\n  explicit CleanupPadInst(Value *ParentPad, ArrayRef<Value *> Args,\n                          unsigned Values, const Twine &NameStr,\n                          BasicBlock *InsertAtEnd)\n      : FuncletPadInst(Instruction::CleanupPad, ParentPad, Args, Values,\n                       NameStr, InsertAtEnd) {}\n\npublic:\n  static CleanupPadInst *Create(Value *ParentPad, ArrayRef<Value *> Args = None,\n                                const Twine &NameStr = \"\",\n                                Instruction *InsertBefore = nullptr) {\n    unsigned Values = 1 + Args.size();\n    return new (Values)\n        CleanupPadInst(ParentPad, Args, Values, NameStr, InsertBefore);\n  }\n\n  static CleanupPadInst *Create(Value *ParentPad, ArrayRef<Value *> Args,\n                                const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    unsigned Values = 1 + Args.size();\n    return new (Values)\n        CleanupPadInst(ParentPad, Args, Values, NameStr, InsertAtEnd);\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::CleanupPad;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                               CatchPadInst Class\n//===----------------------------------------------------------------------===//\nclass CatchPadInst : public FuncletPadInst {\nprivate:\n  explicit CatchPadInst(Value *CatchSwitch, ArrayRef<Value *> Args,\n                        unsigned Values, const Twine &NameStr,\n                        Instruction *InsertBefore)\n      : FuncletPadInst(Instruction::CatchPad, CatchSwitch, Args, Values,\n                       NameStr, InsertBefore) {}\n  explicit CatchPadInst(Value *CatchSwitch, ArrayRef<Value *> Args,\n                        unsigned Values, const Twine &NameStr,\n                        BasicBlock *InsertAtEnd)\n      : FuncletPadInst(Instruction::CatchPad, CatchSwitch, Args, Values,\n                       NameStr, InsertAtEnd) {}\n\npublic:\n  static CatchPadInst *Create(Value *CatchSwitch, ArrayRef<Value *> Args,\n                              const Twine &NameStr = \"\",\n                              Instruction *InsertBefore = nullptr) {\n    unsigned Values = 1 + Args.size();\n    return new (Values)\n        CatchPadInst(CatchSwitch, Args, Values, NameStr, InsertBefore);\n  }\n\n  static CatchPadInst *Create(Value *CatchSwitch, ArrayRef<Value *> Args,\n                              const Twine &NameStr, BasicBlock *InsertAtEnd) {\n    unsigned Values = 1 + Args.size();\n    return new (Values)\n        CatchPadInst(CatchSwitch, Args, Values, NameStr, InsertAtEnd);\n  }\n\n  /// Convenience accessors\n  CatchSwitchInst *getCatchSwitch() const {\n    return cast<CatchSwitchInst>(Op<-1>());\n  }\n  void setCatchSwitch(Value *CatchSwitch) {\n    assert(CatchSwitch);\n    Op<-1>() = CatchSwitch;\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::CatchPad;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                               CatchReturnInst Class\n//===----------------------------------------------------------------------===//\n\nclass CatchReturnInst : public Instruction {\n  CatchReturnInst(const CatchReturnInst &RI);\n  CatchReturnInst(Value *CatchPad, BasicBlock *BB, Instruction *InsertBefore);\n  CatchReturnInst(Value *CatchPad, BasicBlock *BB, BasicBlock *InsertAtEnd);\n\n  void init(Value *CatchPad, BasicBlock *BB);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  CatchReturnInst *cloneImpl() const;\n\npublic:\n  static CatchReturnInst *Create(Value *CatchPad, BasicBlock *BB,\n                                 Instruction *InsertBefore = nullptr) {\n    assert(CatchPad);\n    assert(BB);\n    return new (2) CatchReturnInst(CatchPad, BB, InsertBefore);\n  }\n\n  static CatchReturnInst *Create(Value *CatchPad, BasicBlock *BB,\n                                 BasicBlock *InsertAtEnd) {\n    assert(CatchPad);\n    assert(BB);\n    return new (2) CatchReturnInst(CatchPad, BB, InsertAtEnd);\n  }\n\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  /// Convenience accessors.\n  CatchPadInst *getCatchPad() const { return cast<CatchPadInst>(Op<0>()); }\n  void setCatchPad(CatchPadInst *CatchPad) {\n    assert(CatchPad);\n    Op<0>() = CatchPad;\n  }\n\n  BasicBlock *getSuccessor() const { return cast<BasicBlock>(Op<1>()); }\n  void setSuccessor(BasicBlock *NewSucc) {\n    assert(NewSucc);\n    Op<1>() = NewSucc;\n  }\n  unsigned getNumSuccessors() const { return 1; }\n\n  /// Get the parentPad of this catchret's catchpad's catchswitch.\n  /// The successor block is implicitly a member of this funclet.\n  Value *getCatchSwitchParentPad() const {\n    return getCatchPad()->getCatchSwitch()->getParentPad();\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return (I->getOpcode() == Instruction::CatchRet);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  BasicBlock *getSuccessor(unsigned Idx) const {\n    assert(Idx < getNumSuccessors() && \"Successor # out of range for catchret!\");\n    return getSuccessor();\n  }\n\n  void setSuccessor(unsigned Idx, BasicBlock *B) {\n    assert(Idx < getNumSuccessors() && \"Successor # out of range for catchret!\");\n    setSuccessor(B);\n  }\n};\n\ntemplate <>\nstruct OperandTraits<CatchReturnInst>\n    : public FixedNumOperandTraits<CatchReturnInst, 2> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(CatchReturnInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                               CleanupReturnInst Class\n//===----------------------------------------------------------------------===//\n\nclass CleanupReturnInst : public Instruction {\n  using UnwindDestField = BoolBitfieldElementT<0>;\n\nprivate:\n  CleanupReturnInst(const CleanupReturnInst &RI);\n  CleanupReturnInst(Value *CleanupPad, BasicBlock *UnwindBB, unsigned Values,\n                    Instruction *InsertBefore = nullptr);\n  CleanupReturnInst(Value *CleanupPad, BasicBlock *UnwindBB, unsigned Values,\n                    BasicBlock *InsertAtEnd);\n\n  void init(Value *CleanupPad, BasicBlock *UnwindBB);\n\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  CleanupReturnInst *cloneImpl() const;\n\npublic:\n  static CleanupReturnInst *Create(Value *CleanupPad,\n                                   BasicBlock *UnwindBB = nullptr,\n                                   Instruction *InsertBefore = nullptr) {\n    assert(CleanupPad);\n    unsigned Values = 1;\n    if (UnwindBB)\n      ++Values;\n    return new (Values)\n        CleanupReturnInst(CleanupPad, UnwindBB, Values, InsertBefore);\n  }\n\n  static CleanupReturnInst *Create(Value *CleanupPad, BasicBlock *UnwindBB,\n                                   BasicBlock *InsertAtEnd) {\n    assert(CleanupPad);\n    unsigned Values = 1;\n    if (UnwindBB)\n      ++Values;\n    return new (Values)\n        CleanupReturnInst(CleanupPad, UnwindBB, Values, InsertAtEnd);\n  }\n\n  /// Provide fast operand accessors\n  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);\n\n  bool hasUnwindDest() const { return getSubclassData<UnwindDestField>(); }\n  bool unwindsToCaller() const { return !hasUnwindDest(); }\n\n  /// Convenience accessor.\n  CleanupPadInst *getCleanupPad() const {\n    return cast<CleanupPadInst>(Op<0>());\n  }\n  void setCleanupPad(CleanupPadInst *CleanupPad) {\n    assert(CleanupPad);\n    Op<0>() = CleanupPad;\n  }\n\n  unsigned getNumSuccessors() const { return hasUnwindDest() ? 1 : 0; }\n\n  BasicBlock *getUnwindDest() const {\n    return hasUnwindDest() ? cast<BasicBlock>(Op<1>()) : nullptr;\n  }\n  void setUnwindDest(BasicBlock *NewDest) {\n    assert(NewDest);\n    assert(hasUnwindDest());\n    Op<1>() = NewDest;\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return (I->getOpcode() == Instruction::CleanupRet);\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  BasicBlock *getSuccessor(unsigned Idx) const {\n    assert(Idx == 0);\n    return getUnwindDest();\n  }\n\n  void setSuccessor(unsigned Idx, BasicBlock *B) {\n    assert(Idx == 0);\n    setUnwindDest(B);\n  }\n\n  // Shadow Instruction::setInstructionSubclassData with a private forwarding\n  // method so that subclasses cannot accidentally use it.\n  template <typename Bitfield>\n  void setSubclassData(typename Bitfield::Type Value) {\n    Instruction::setSubclassData<Bitfield>(Value);\n  }\n};\n\ntemplate <>\nstruct OperandTraits<CleanupReturnInst>\n    : public VariadicOperandTraits<CleanupReturnInst, /*MINARITY=*/1> {};\n\nDEFINE_TRANSPARENT_OPERAND_ACCESSORS(CleanupReturnInst, Value)\n\n//===----------------------------------------------------------------------===//\n//                           UnreachableInst Class\n//===----------------------------------------------------------------------===//\n\n//===---------------------------------------------------------------------------\n/// This function has undefined behavior.  In particular, the\n/// presence of this instruction indicates some higher level knowledge that the\n/// end of the block cannot be reached.\n///\nclass UnreachableInst : public Instruction {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  UnreachableInst *cloneImpl() const;\n\npublic:\n  explicit UnreachableInst(LLVMContext &C, Instruction *InsertBefore = nullptr);\n  explicit UnreachableInst(LLVMContext &C, BasicBlock *InsertAtEnd);\n\n  // allocate space for exactly zero operands\n  void *operator new(size_t s) {\n    return User::operator new(s, 0);\n  }\n\n  unsigned getNumSuccessors() const { return 0; }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Instruction::Unreachable;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\nprivate:\n  BasicBlock *getSuccessor(unsigned idx) const {\n    llvm_unreachable(\"UnreachableInst has no successors!\");\n  }\n\n  void setSuccessor(unsigned idx, BasicBlock *B) {\n    llvm_unreachable(\"UnreachableInst has no successors!\");\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 TruncInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a truncation of integer types.\nclass TruncInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical TruncInst\n  TruncInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  TruncInst(\n    Value *S,                           ///< The value to be truncated\n    Type *Ty,                           ///< The (smaller) type to truncate to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  TruncInst(\n    Value *S,                     ///< The value to be truncated\n    Type *Ty,                     ///< The (smaller) type to truncate to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == Trunc;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 ZExtInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents zero extension of integer types.\nclass ZExtInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical ZExtInst\n  ZExtInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  ZExtInst(\n    Value *S,                           ///< The value to be zero extended\n    Type *Ty,                           ///< The type to zero extend to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end semantics.\n  ZExtInst(\n    Value *S,                     ///< The value to be zero extended\n    Type *Ty,                     ///< The type to zero extend to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == ZExt;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 SExtInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a sign extension of integer types.\nclass SExtInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical SExtInst\n  SExtInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  SExtInst(\n    Value *S,                           ///< The value to be sign extended\n    Type *Ty,                           ///< The type to sign extend to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  SExtInst(\n    Value *S,                     ///< The value to be sign extended\n    Type *Ty,                     ///< The type to sign extend to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == SExt;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 FPTruncInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a truncation of floating point types.\nclass FPTruncInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical FPTruncInst\n  FPTruncInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  FPTruncInst(\n    Value *S,                           ///< The value to be truncated\n    Type *Ty,                           ///< The type to truncate to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-before-instruction semantics\n  FPTruncInst(\n    Value *S,                     ///< The value to be truncated\n    Type *Ty,                     ///< The type to truncate to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == FPTrunc;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 FPExtInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents an extension of floating point types.\nclass FPExtInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical FPExtInst\n  FPExtInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  FPExtInst(\n    Value *S,                           ///< The value to be extended\n    Type *Ty,                           ///< The type to extend to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  FPExtInst(\n    Value *S,                     ///< The value to be extended\n    Type *Ty,                     ///< The type to extend to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == FPExt;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 UIToFPInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a cast unsigned integer to floating point.\nclass UIToFPInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical UIToFPInst\n  UIToFPInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  UIToFPInst(\n    Value *S,                           ///< The value to be converted\n    Type *Ty,                           ///< The type to convert to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  UIToFPInst(\n    Value *S,                     ///< The value to be converted\n    Type *Ty,                     ///< The type to convert to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == UIToFP;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 SIToFPInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a cast from signed integer to floating point.\nclass SIToFPInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical SIToFPInst\n  SIToFPInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  SIToFPInst(\n    Value *S,                           ///< The value to be converted\n    Type *Ty,                           ///< The type to convert to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  SIToFPInst(\n    Value *S,                     ///< The value to be converted\n    Type *Ty,                     ///< The type to convert to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == SIToFP;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 FPToUIInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a cast from floating point to unsigned integer\nclass FPToUIInst  : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical FPToUIInst\n  FPToUIInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  FPToUIInst(\n    Value *S,                           ///< The value to be converted\n    Type *Ty,                           ///< The type to convert to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  FPToUIInst(\n    Value *S,                     ///< The value to be converted\n    Type *Ty,                     ///< The type to convert to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< Where to insert the new instruction\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == FPToUI;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 FPToSIInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a cast from floating point to signed integer.\nclass FPToSIInst  : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical FPToSIInst\n  FPToSIInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  FPToSIInst(\n    Value *S,                           ///< The value to be converted\n    Type *Ty,                           ///< The type to convert to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  FPToSIInst(\n    Value *S,                     ///< The value to be converted\n    Type *Ty,                     ///< The type to convert to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == FPToSI;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 IntToPtrInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a cast from an integer to a pointer.\nclass IntToPtrInst : public CastInst {\npublic:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Constructor with insert-before-instruction semantics\n  IntToPtrInst(\n    Value *S,                           ///< The value to be converted\n    Type *Ty,                           ///< The type to convert to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  IntToPtrInst(\n    Value *S,                     ///< The value to be converted\n    Type *Ty,                     ///< The type to convert to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Clone an identical IntToPtrInst.\n  IntToPtrInst *cloneImpl() const;\n\n  /// Returns the address space of this instruction's pointer type.\n  unsigned getAddressSpace() const {\n    return getType()->getPointerAddressSpace();\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == IntToPtr;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                                 PtrToIntInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a cast from a pointer to an integer.\nclass PtrToIntInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical PtrToIntInst.\n  PtrToIntInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  PtrToIntInst(\n    Value *S,                           ///< The value to be converted\n    Type *Ty,                           ///< The type to convert to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  PtrToIntInst(\n    Value *S,                     ///< The value to be converted\n    Type *Ty,                     ///< The type to convert to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  /// Gets the pointer operand.\n  Value *getPointerOperand() { return getOperand(0); }\n  /// Gets the pointer operand.\n  const Value *getPointerOperand() const { return getOperand(0); }\n  /// Gets the operand index of the pointer operand.\n  static unsigned getPointerOperandIndex() { return 0U; }\n\n  /// Returns the address space of the pointer operand.\n  unsigned getPointerAddressSpace() const {\n    return getPointerOperand()->getType()->getPointerAddressSpace();\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == PtrToInt;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                             BitCastInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a no-op cast from one type to another.\nclass BitCastInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical BitCastInst.\n  BitCastInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  BitCastInst(\n    Value *S,                           ///< The value to be casted\n    Type *Ty,                           ///< The type to casted to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  BitCastInst(\n    Value *S,                     ///< The value to be casted\n    Type *Ty,                     ///< The type to casted to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == BitCast;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//                          AddrSpaceCastInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a conversion between pointers from one address space\n/// to another.\nclass AddrSpaceCastInst : public CastInst {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical AddrSpaceCastInst.\n  AddrSpaceCastInst *cloneImpl() const;\n\npublic:\n  /// Constructor with insert-before-instruction semantics\n  AddrSpaceCastInst(\n    Value *S,                           ///< The value to be casted\n    Type *Ty,                           ///< The type to casted to\n    const Twine &NameStr = \"\",          ///< A name for the new instruction\n    Instruction *InsertBefore = nullptr ///< Where to insert the new instruction\n  );\n\n  /// Constructor with insert-at-end-of-block semantics\n  AddrSpaceCastInst(\n    Value *S,                     ///< The value to be casted\n    Type *Ty,                     ///< The type to casted to\n    const Twine &NameStr,         ///< A name for the new instruction\n    BasicBlock *InsertAtEnd       ///< The block to insert the instruction into\n  );\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const Instruction *I) {\n    return I->getOpcode() == AddrSpaceCast;\n  }\n  static bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n\n  /// Gets the pointer operand.\n  Value *getPointerOperand() {\n    return getOperand(0);\n  }\n\n  /// Gets the pointer operand.\n  const Value *getPointerOperand() const {\n    return getOperand(0);\n  }\n\n  /// Gets the operand index of the pointer operand.\n  static unsigned getPointerOperandIndex() {\n    return 0U;\n  }\n\n  /// Returns the address space of the pointer operand.\n  unsigned getSrcAddressSpace() const {\n    return getPointerOperand()->getType()->getPointerAddressSpace();\n  }\n\n  /// Returns the address space of the result.\n  unsigned getDestAddressSpace() const {\n    return getType()->getPointerAddressSpace();\n  }\n};\n\n/// A helper function that returns the pointer operand of a load or store\n/// instruction. Returns nullptr if not load or store.\ninline const Value *getLoadStorePointerOperand(const Value *V) {\n  if (auto *Load = dyn_cast<LoadInst>(V))\n    return Load->getPointerOperand();\n  if (auto *Store = dyn_cast<StoreInst>(V))\n    return Store->getPointerOperand();\n  return nullptr;\n}\ninline Value *getLoadStorePointerOperand(Value *V) {\n  return const_cast<Value *>(\n      getLoadStorePointerOperand(static_cast<const Value *>(V)));\n}\n\n/// A helper function that returns the pointer operand of a load, store\n/// or GEP instruction. Returns nullptr if not load, store, or GEP.\ninline const Value *getPointerOperand(const Value *V) {\n  if (auto *Ptr = getLoadStorePointerOperand(V))\n    return Ptr;\n  if (auto *Gep = dyn_cast<GetElementPtrInst>(V))\n    return Gep->getPointerOperand();\n  return nullptr;\n}\ninline Value *getPointerOperand(Value *V) {\n  return const_cast<Value *>(getPointerOperand(static_cast<const Value *>(V)));\n}\n\n/// A helper function that returns the alignment of load or store instruction.\ninline Align getLoadStoreAlignment(Value *I) {\n  assert((isa<LoadInst>(I) || isa<StoreInst>(I)) &&\n         \"Expected Load or Store instruction\");\n  if (auto *LI = dyn_cast<LoadInst>(I))\n    return LI->getAlign();\n  return cast<StoreInst>(I)->getAlign();\n}\n\n/// A helper function that returns the address space of the pointer operand of\n/// load or store instruction.\ninline unsigned getLoadStoreAddressSpace(Value *I) {\n  assert((isa<LoadInst>(I) || isa<StoreInst>(I)) &&\n         \"Expected Load or Store instruction\");\n  if (auto *LI = dyn_cast<LoadInst>(I))\n    return LI->getPointerAddressSpace();\n  return cast<StoreInst>(I)->getPointerAddressSpace();\n}\n\n//===----------------------------------------------------------------------===//\n//                              FreezeInst Class\n//===----------------------------------------------------------------------===//\n\n/// This class represents a freeze function that returns random concrete\n/// value if an operand is either a poison value or an undef value\nclass FreezeInst : public UnaryInstruction {\nprotected:\n  // Note: Instruction needs to be a friend here to call cloneImpl.\n  friend class Instruction;\n\n  /// Clone an identical FreezeInst\n  FreezeInst *cloneImpl() const;\n\npublic:\n  explicit FreezeInst(Value *S,\n                      const Twine &NameStr = \"\",\n                      Instruction *InsertBefore = nullptr);\n  FreezeInst(Value *S, const Twine &NameStr, BasicBlock *InsertAtEnd);\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static inline bool classof(const Instruction *I) {\n    return I->getOpcode() == Freeze;\n  }\n  static inline bool classof(const Value *V) {\n    return isa<Instruction>(V) && classof(cast<Instruction>(V));\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_INSTRUCTIONS_H\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h", "content": "//===-- llvm/IntrinsicInst.h - Intrinsic Instruction Wrappers ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines classes that make it really easy to deal with intrinsic\n// functions with the isa/dyncast family of functions.  In particular, this\n// allows you to do things like:\n//\n//     if (MemCpyInst *MCI = dyn_cast<MemCpyInst>(Inst))\n//        ... MCI->getDest() ... MCI->getSource() ...\n//\n// All intrinsic function calls are instances of the call instruction, so these\n// are all subclasses of the CallInst class.  Note that none of these classes\n// has state or virtual methods, which is an important part of this gross/neat\n// hack working.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_IR_INTRINSICINST_H\n#define LLVM_IR_INTRINSICINST_H\n\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/FPEnv.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GlobalVariable.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <cstdint>\n\nnamespace llvm {\n\n/// A wrapper class for inspecting calls to intrinsic functions.\n/// This allows the standard isa/dyncast/cast functionality to work with calls\n/// to intrinsic functions.\nclass IntrinsicInst : public CallInst {\npublic:\n  IntrinsicInst() = delete;\n  IntrinsicInst(const IntrinsicInst &) = delete;\n  IntrinsicInst &operator=(const IntrinsicInst &) = delete;\n\n  /// Return the intrinsic ID of this intrinsic.\n  Intrinsic::ID getIntrinsicID() const {\n    return getCalledFunction()->getIntrinsicID();\n  }\n\n  /// Return true if swapping the first two arguments to the intrinsic produces\n  /// the same result.\n  bool isCommutative() const {\n    switch (getIntrinsicID()) {\n    case Intrinsic::maxnum:\n    case Intrinsic::minnum:\n    case Intrinsic::maximum:\n    case Intrinsic::minimum:\n    case Intrinsic::smax:\n    case Intrinsic::smin:\n    case Intrinsic::umax:\n    case Intrinsic::umin:\n    case Intrinsic::sadd_sat:\n    case Intrinsic::uadd_sat:\n    case Intrinsic::sadd_with_overflow:\n    case Intrinsic::uadd_with_overflow:\n    case Intrinsic::smul_with_overflow:\n    case Intrinsic::umul_with_overflow:\n    case Intrinsic::smul_fix:\n    case Intrinsic::umul_fix:\n    case Intrinsic::smul_fix_sat:\n    case Intrinsic::umul_fix_sat:\n    case Intrinsic::fma:\n    case Intrinsic::fmuladd:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  // Checks if the intrinsic is an annotation.\n  bool isAssumeLikeIntrinsic() const {\n    switch (getIntrinsicID()) {\n    default: break;\n    case Intrinsic::assume:\n    case Intrinsic::sideeffect:\n    case Intrinsic::pseudoprobe:\n    case Intrinsic::dbg_declare:\n    case Intrinsic::dbg_value:\n    case Intrinsic::dbg_label:\n    case Intrinsic::invariant_start:\n    case Intrinsic::invariant_end:\n    case Intrinsic::lifetime_start:\n    case Intrinsic::lifetime_end:\n    case Intrinsic::experimental_noalias_scope_decl:\n    case Intrinsic::objectsize:\n    case Intrinsic::ptr_annotation:\n    case Intrinsic::var_annotation:\n      return true;\n    }\n    return false;\n  }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const CallInst *I) {\n    if (const Function *CF = I->getCalledFunction())\n      return CF->isIntrinsic();\n    return false;\n  }\n  static bool classof(const Value *V) {\n    return isa<CallInst>(V) && classof(cast<CallInst>(V));\n  }\n};\n\n/// Check if \\p ID corresponds to a debug info intrinsic.\nstatic inline bool isDbgInfoIntrinsic(Intrinsic::ID ID) {\n  switch (ID) {\n  case Intrinsic::dbg_declare:\n  case Intrinsic::dbg_value:\n  case Intrinsic::dbg_addr:\n  case Intrinsic::dbg_label:\n    return true;\n  default:\n    return false;\n  }\n}\n\n/// This is the common base class for debug info intrinsics.\nclass DbgInfoIntrinsic : public IntrinsicInst {\npublic:\n  /// \\name Casting methods\n  /// @{\n  static bool classof(const IntrinsicInst *I) {\n    return isDbgInfoIntrinsic(I->getIntrinsicID());\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n  /// @}\n};\n\n/// This is the common base class for debug info intrinsics for variables.\nclass DbgVariableIntrinsic : public DbgInfoIntrinsic {\npublic:\n  // Iterator for ValueAsMetadata that internally uses direct pointer iteration\n  // over either a ValueAsMetadata* or a ValueAsMetadata**, dereferencing to the\n  // ValueAsMetadata .\n  class location_op_iterator\n      : public iterator_facade_base<location_op_iterator,\n                                    std::bidirectional_iterator_tag, Value *> {\n    PointerUnion<ValueAsMetadata *, ValueAsMetadata **> I;\n\n  public:\n    location_op_iterator(ValueAsMetadata *SingleIter) : I(SingleIter) {}\n    location_op_iterator(ValueAsMetadata **MultiIter) : I(MultiIter) {}\n\n    location_op_iterator(const location_op_iterator &R) : I(R.I) {}\n    location_op_iterator &operator=(const location_op_iterator &R) {\n      I = R.I;\n      return *this;\n    }\n    bool operator==(const location_op_iterator &RHS) const {\n      return I == RHS.I;\n    }\n    const Value *operator*() const {\n      ValueAsMetadata *VAM = I.is<ValueAsMetadata *>()\n                                 ? I.get<ValueAsMetadata *>()\n                                 : *I.get<ValueAsMetadata **>();\n      return VAM->getValue();\n    };\n    Value *operator*() {\n      ValueAsMetadata *VAM = I.is<ValueAsMetadata *>()\n                                 ? I.get<ValueAsMetadata *>()\n                                 : *I.get<ValueAsMetadata **>();\n      return VAM->getValue();\n    }\n    location_op_iterator &operator++() {\n      if (I.is<ValueAsMetadata *>())\n        I = I.get<ValueAsMetadata *>() + 1;\n      else\n        I = I.get<ValueAsMetadata **>() + 1;\n      return *this;\n    }\n    location_op_iterator &operator--() {\n      if (I.is<ValueAsMetadata *>())\n        I = I.get<ValueAsMetadata *>() - 1;\n      else\n        I = I.get<ValueAsMetadata **>() - 1;\n      return *this;\n    }\n  };\n\n  /// Get the locations corresponding to the variable referenced by the debug\n  /// info intrinsic.  Depending on the intrinsic, this could be the\n  /// variable's value or its address.\n  iterator_range<location_op_iterator> location_ops() const;\n\n  Value *getVariableLocationOp(unsigned OpIdx) const;\n\n  void replaceVariableLocationOp(Value *OldValue, Value *NewValue);\n  void replaceVariableLocationOp(unsigned OpIdx, Value *NewValue);\n\n  void setVariable(DILocalVariable *NewVar) {\n    setArgOperand(1, MetadataAsValue::get(NewVar->getContext(), NewVar));\n  }\n\n  void setExpression(DIExpression *NewExpr) {\n    setArgOperand(2, MetadataAsValue::get(NewExpr->getContext(), NewExpr));\n  }\n\n  unsigned getNumVariableLocationOps() const {\n    if (hasArgList())\n      return cast<DIArgList>(getRawLocation())->getArgs().size();\n    return 1;\n  }\n\n  bool hasArgList() const { return isa<DIArgList>(getRawLocation()); }\n\n  /// Does this describe the address of a local variable. True for dbg.addr\n  /// and dbg.declare, but not dbg.value, which describes its value.\n  bool isAddressOfVariable() const {\n    return getIntrinsicID() != Intrinsic::dbg_value;\n  }\n\n  void setUndef() {\n    // TODO: When/if we remove duplicate values from DIArgLists, we don't need\n    // this set anymore.\n    SmallPtrSet<Value *, 4> RemovedValues;\n    for (Value *OldValue : location_ops()) {\n      if (!RemovedValues.insert(OldValue).second)\n        continue;\n      Value *Undef = UndefValue::get(OldValue->getType());\n      replaceVariableLocationOp(OldValue, Undef);\n    }\n  }\n\n  bool isUndef() const {\n    return (getNumVariableLocationOps() == 0 &&\n            !getExpression()->isComplex()) ||\n           any_of(location_ops(), [](Value *V) { return isa<UndefValue>(V); });\n  }\n\n  DILocalVariable *getVariable() const {\n    return cast<DILocalVariable>(getRawVariable());\n  }\n\n  DIExpression *getExpression() const {\n    return cast<DIExpression>(getRawExpression());\n  }\n\n  Metadata *getRawLocation() const {\n    return cast<MetadataAsValue>(getArgOperand(0))->getMetadata();\n  }\n\n  Metadata *getRawVariable() const {\n    return cast<MetadataAsValue>(getArgOperand(1))->getMetadata();\n  }\n\n  Metadata *getRawExpression() const {\n    return cast<MetadataAsValue>(getArgOperand(2))->getMetadata();\n  }\n\n  /// Get the size (in bits) of the variable, or fragment of the variable that\n  /// is described.\n  Optional<uint64_t> getFragmentSizeInBits() const;\n\n  /// \\name Casting methods\n  /// @{\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::dbg_declare:\n    case Intrinsic::dbg_value:\n    case Intrinsic::dbg_addr:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n  /// @}\nprivate:\n  void setArgOperand(unsigned i, Value *v) {\n    DbgInfoIntrinsic::setArgOperand(i, v);\n  }\n  void setOperand(unsigned i, Value *v) { DbgInfoIntrinsic::setOperand(i, v); }\n};\n\n/// This represents the llvm.dbg.declare instruction.\nclass DbgDeclareInst : public DbgVariableIntrinsic {\npublic:\n  Value *getAddress() const {\n    assert(getNumVariableLocationOps() == 1 &&\n           \"dbg.declare must have exactly 1 location operand.\");\n    return getVariableLocationOp(0);\n  }\n\n  /// \\name Casting methods\n  /// @{\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::dbg_declare;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n  /// @}\n};\n\n/// This represents the llvm.dbg.addr instruction.\nclass DbgAddrIntrinsic : public DbgVariableIntrinsic {\npublic:\n  Value *getAddress() const {\n    assert(getNumVariableLocationOps() == 1 &&\n           \"dbg.addr must have exactly 1 location operand.\");\n    return getVariableLocationOp(0);\n  }\n\n  /// \\name Casting methods\n  /// @{\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::dbg_addr;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This represents the llvm.dbg.value instruction.\nclass DbgValueInst : public DbgVariableIntrinsic {\npublic:\n  // The default argument should only be used in ISel, and the default option\n  // should be removed once ISel support for multiple location ops is complete.\n  Value *getValue(unsigned OpIdx = 0) const {\n    return getVariableLocationOp(OpIdx);\n  }\n  iterator_range<location_op_iterator> getValues() const {\n    return location_ops();\n  }\n\n  /// \\name Casting methods\n  /// @{\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::dbg_value;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n  /// @}\n};\n\n/// This represents the llvm.dbg.label instruction.\nclass DbgLabelInst : public DbgInfoIntrinsic {\npublic:\n  DILabel *getLabel() const { return cast<DILabel>(getRawLabel()); }\n\n  Metadata *getRawLabel() const {\n    return cast<MetadataAsValue>(getArgOperand(0))->getMetadata();\n  }\n\n  /// Methods for support type inquiry through isa, cast, and dyn_cast:\n  /// @{\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::dbg_label;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n  /// @}\n};\n\n/// This is the common base class for vector predication intrinsics.\nclass VPIntrinsic : public IntrinsicInst {\npublic:\n  static Optional<int> GetMaskParamPos(Intrinsic::ID IntrinsicID);\n  static Optional<int> GetVectorLengthParamPos(Intrinsic::ID IntrinsicID);\n\n  /// The llvm.vp.* intrinsics for this instruction Opcode\n  static Intrinsic::ID GetForOpcode(unsigned OC);\n\n  // Whether \\p ID is a VP intrinsic ID.\n  static bool IsVPIntrinsic(Intrinsic::ID);\n\n  /// \\return the mask parameter or nullptr.\n  Value *getMaskParam() const;\n\n  /// \\return the vector length parameter or nullptr.\n  Value *getVectorLengthParam() const;\n\n  /// \\return whether the vector length param can be ignored.\n  bool canIgnoreVectorLengthParam() const;\n\n  /// \\return the static element count (vector number of elements) the vector\n  /// length parameter applies to.\n  ElementCount getStaticVectorLength() const;\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I) {\n    return IsVPIntrinsic(I->getIntrinsicID());\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  // Equivalent non-predicated opcode\n  unsigned getFunctionalOpcode() const {\n    return GetFunctionalOpcodeForVP(getIntrinsicID());\n  }\n\n  // Equivalent non-predicated opcode\n  static unsigned GetFunctionalOpcodeForVP(Intrinsic::ID ID);\n};\n\n/// This is the common base class for constrained floating point intrinsics.\nclass ConstrainedFPIntrinsic : public IntrinsicInst {\npublic:\n  bool isUnaryOp() const;\n  bool isTernaryOp() const;\n  Optional<RoundingMode> getRoundingMode() const;\n  Optional<fp::ExceptionBehavior> getExceptionBehavior() const;\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I);\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// Constrained floating point compare intrinsics.\nclass ConstrainedFPCmpIntrinsic : public ConstrainedFPIntrinsic {\npublic:\n  FCmpInst::Predicate getPredicate() const;\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::experimental_constrained_fcmp:\n    case Intrinsic::experimental_constrained_fcmps:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class represents an intrinsic that is based on a binary operation.\n/// This includes op.with.overflow and saturating add/sub intrinsics.\nclass BinaryOpIntrinsic : public IntrinsicInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::uadd_with_overflow:\n    case Intrinsic::sadd_with_overflow:\n    case Intrinsic::usub_with_overflow:\n    case Intrinsic::ssub_with_overflow:\n    case Intrinsic::umul_with_overflow:\n    case Intrinsic::smul_with_overflow:\n    case Intrinsic::uadd_sat:\n    case Intrinsic::sadd_sat:\n    case Intrinsic::usub_sat:\n    case Intrinsic::ssub_sat:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  Value *getLHS() const { return const_cast<Value *>(getArgOperand(0)); }\n  Value *getRHS() const { return const_cast<Value *>(getArgOperand(1)); }\n\n  /// Returns the binary operation underlying the intrinsic.\n  Instruction::BinaryOps getBinaryOp() const;\n\n  /// Whether the intrinsic is signed or unsigned.\n  bool isSigned() const;\n\n  /// Returns one of OBO::NoSignedWrap or OBO::NoUnsignedWrap.\n  unsigned getNoWrapKind() const;\n};\n\n/// Represents an op.with.overflow intrinsic.\nclass WithOverflowInst : public BinaryOpIntrinsic {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::uadd_with_overflow:\n    case Intrinsic::sadd_with_overflow:\n    case Intrinsic::usub_with_overflow:\n    case Intrinsic::ssub_with_overflow:\n    case Intrinsic::umul_with_overflow:\n    case Intrinsic::smul_with_overflow:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// Represents a saturating add/sub intrinsic.\nclass SaturatingInst : public BinaryOpIntrinsic {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::uadd_sat:\n    case Intrinsic::sadd_sat:\n    case Intrinsic::usub_sat:\n    case Intrinsic::ssub_sat:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// Common base class for all memory intrinsics. Simply provides\n/// common methods.\n/// Written as CRTP to avoid a common base class amongst the\n/// three atomicity hierarchies.\ntemplate <typename Derived> class MemIntrinsicBase : public IntrinsicInst {\nprivate:\n  enum { ARG_DEST = 0, ARG_LENGTH = 2 };\n\npublic:\n  Value *getRawDest() const {\n    return const_cast<Value *>(getArgOperand(ARG_DEST));\n  }\n  const Use &getRawDestUse() const { return getArgOperandUse(ARG_DEST); }\n  Use &getRawDestUse() { return getArgOperandUse(ARG_DEST); }\n\n  Value *getLength() const {\n    return const_cast<Value *>(getArgOperand(ARG_LENGTH));\n  }\n  const Use &getLengthUse() const { return getArgOperandUse(ARG_LENGTH); }\n  Use &getLengthUse() { return getArgOperandUse(ARG_LENGTH); }\n\n  /// This is just like getRawDest, but it strips off any cast\n  /// instructions (including addrspacecast) that feed it, giving the\n  /// original input.  The returned value is guaranteed to be a pointer.\n  Value *getDest() const { return getRawDest()->stripPointerCasts(); }\n\n  unsigned getDestAddressSpace() const {\n    return cast<PointerType>(getRawDest()->getType())->getAddressSpace();\n  }\n\n  /// FIXME: Remove this function once transition to Align is over.\n  /// Use getDestAlign() instead.\n  unsigned getDestAlignment() const {\n    if (auto MA = getParamAlign(ARG_DEST))\n      return MA->value();\n    return 0;\n  }\n  MaybeAlign getDestAlign() const { return getParamAlign(ARG_DEST); }\n\n  /// Set the specified arguments of the instruction.\n  void setDest(Value *Ptr) {\n    assert(getRawDest()->getType() == Ptr->getType() &&\n           \"setDest called with pointer of wrong type!\");\n    setArgOperand(ARG_DEST, Ptr);\n  }\n\n  /// FIXME: Remove this function once transition to Align is over.\n  /// Use the version that takes MaybeAlign instead of this one.\n  void setDestAlignment(unsigned Alignment) {\n    setDestAlignment(MaybeAlign(Alignment));\n  }\n  void setDestAlignment(MaybeAlign Alignment) {\n    removeParamAttr(ARG_DEST, Attribute::Alignment);\n    if (Alignment)\n      addParamAttr(ARG_DEST,\n                   Attribute::getWithAlignment(getContext(), *Alignment));\n  }\n  void setDestAlignment(Align Alignment) {\n    removeParamAttr(ARG_DEST, Attribute::Alignment);\n    addParamAttr(ARG_DEST,\n                 Attribute::getWithAlignment(getContext(), Alignment));\n  }\n\n  void setLength(Value *L) {\n    assert(getLength()->getType() == L->getType() &&\n           \"setLength called with value of wrong type!\");\n    setArgOperand(ARG_LENGTH, L);\n  }\n};\n\n/// Common base class for all memory transfer intrinsics. Simply provides\n/// common methods.\ntemplate <class BaseCL> class MemTransferBase : public BaseCL {\nprivate:\n  enum { ARG_SOURCE = 1 };\n\npublic:\n  /// Return the arguments to the instruction.\n  Value *getRawSource() const {\n    return const_cast<Value *>(BaseCL::getArgOperand(ARG_SOURCE));\n  }\n  const Use &getRawSourceUse() const {\n    return BaseCL::getArgOperandUse(ARG_SOURCE);\n  }\n  Use &getRawSourceUse() { return BaseCL::getArgOperandUse(ARG_SOURCE); }\n\n  /// This is just like getRawSource, but it strips off any cast\n  /// instructions that feed it, giving the original input.  The returned\n  /// value is guaranteed to be a pointer.\n  Value *getSource() const { return getRawSource()->stripPointerCasts(); }\n\n  unsigned getSourceAddressSpace() const {\n    return cast<PointerType>(getRawSource()->getType())->getAddressSpace();\n  }\n\n  /// FIXME: Remove this function once transition to Align is over.\n  /// Use getSourceAlign() instead.\n  unsigned getSourceAlignment() const {\n    if (auto MA = BaseCL::getParamAlign(ARG_SOURCE))\n      return MA->value();\n    return 0;\n  }\n\n  MaybeAlign getSourceAlign() const {\n    return BaseCL::getParamAlign(ARG_SOURCE);\n  }\n\n  void setSource(Value *Ptr) {\n    assert(getRawSource()->getType() == Ptr->getType() &&\n           \"setSource called with pointer of wrong type!\");\n    BaseCL::setArgOperand(ARG_SOURCE, Ptr);\n  }\n\n  /// FIXME: Remove this function once transition to Align is over.\n  /// Use the version that takes MaybeAlign instead of this one.\n  void setSourceAlignment(unsigned Alignment) {\n    setSourceAlignment(MaybeAlign(Alignment));\n  }\n  void setSourceAlignment(MaybeAlign Alignment) {\n    BaseCL::removeParamAttr(ARG_SOURCE, Attribute::Alignment);\n    if (Alignment)\n      BaseCL::addParamAttr(ARG_SOURCE, Attribute::getWithAlignment(\n                                           BaseCL::getContext(), *Alignment));\n  }\n  void setSourceAlignment(Align Alignment) {\n    BaseCL::removeParamAttr(ARG_SOURCE, Attribute::Alignment);\n    BaseCL::addParamAttr(ARG_SOURCE, Attribute::getWithAlignment(\n                                         BaseCL::getContext(), Alignment));\n  }\n};\n\n/// Common base class for all memset intrinsics. Simply provides\n/// common methods.\ntemplate <class BaseCL> class MemSetBase : public BaseCL {\nprivate:\n  enum { ARG_VALUE = 1 };\n\npublic:\n  Value *getValue() const {\n    return const_cast<Value *>(BaseCL::getArgOperand(ARG_VALUE));\n  }\n  const Use &getValueUse() const { return BaseCL::getArgOperandUse(ARG_VALUE); }\n  Use &getValueUse() { return BaseCL::getArgOperandUse(ARG_VALUE); }\n\n  void setValue(Value *Val) {\n    assert(getValue()->getType() == Val->getType() &&\n           \"setValue called with value of wrong type!\");\n    BaseCL::setArgOperand(ARG_VALUE, Val);\n  }\n};\n\n// The common base class for the atomic memset/memmove/memcpy intrinsics\n// i.e. llvm.element.unordered.atomic.memset/memcpy/memmove\nclass AtomicMemIntrinsic : public MemIntrinsicBase<AtomicMemIntrinsic> {\nprivate:\n  enum { ARG_ELEMENTSIZE = 3 };\n\npublic:\n  Value *getRawElementSizeInBytes() const {\n    return const_cast<Value *>(getArgOperand(ARG_ELEMENTSIZE));\n  }\n\n  ConstantInt *getElementSizeInBytesCst() const {\n    return cast<ConstantInt>(getRawElementSizeInBytes());\n  }\n\n  uint32_t getElementSizeInBytes() const {\n    return getElementSizeInBytesCst()->getZExtValue();\n  }\n\n  void setElementSizeInBytes(Constant *V) {\n    assert(V->getType() == Type::getInt8Ty(getContext()) &&\n           \"setElementSizeInBytes called with value of wrong type!\");\n    setArgOperand(ARG_ELEMENTSIZE, V);\n  }\n\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memcpy_element_unordered_atomic:\n    case Intrinsic::memmove_element_unordered_atomic:\n    case Intrinsic::memset_element_unordered_atomic:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class represents atomic memset intrinsic\n// i.e. llvm.element.unordered.atomic.memset\nclass AtomicMemSetInst : public MemSetBase<AtomicMemIntrinsic> {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::memset_element_unordered_atomic;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n// This class wraps the atomic memcpy/memmove intrinsics\n// i.e. llvm.element.unordered.atomic.memcpy/memmove\nclass AtomicMemTransferInst : public MemTransferBase<AtomicMemIntrinsic> {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memcpy_element_unordered_atomic:\n    case Intrinsic::memmove_element_unordered_atomic:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class represents the atomic memcpy intrinsic\n/// i.e. llvm.element.unordered.atomic.memcpy\nclass AtomicMemCpyInst : public AtomicMemTransferInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::memcpy_element_unordered_atomic;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class represents the atomic memmove intrinsic\n/// i.e. llvm.element.unordered.atomic.memmove\nclass AtomicMemMoveInst : public AtomicMemTransferInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::memmove_element_unordered_atomic;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This is the common base class for memset/memcpy/memmove.\nclass MemIntrinsic : public MemIntrinsicBase<MemIntrinsic> {\nprivate:\n  enum { ARG_VOLATILE = 3 };\n\npublic:\n  ConstantInt *getVolatileCst() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(ARG_VOLATILE)));\n  }\n\n  bool isVolatile() const { return !getVolatileCst()->isZero(); }\n\n  void setVolatile(Constant *V) { setArgOperand(ARG_VOLATILE, V); }\n\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memcpy:\n    case Intrinsic::memmove:\n    case Intrinsic::memset:\n    case Intrinsic::memcpy_inline:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class wraps the llvm.memset intrinsic.\nclass MemSetInst : public MemSetBase<MemIntrinsic> {\npublic:\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::memset;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class wraps the llvm.memcpy/memmove intrinsics.\nclass MemTransferInst : public MemTransferBase<MemIntrinsic> {\npublic:\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memcpy:\n    case Intrinsic::memmove:\n    case Intrinsic::memcpy_inline:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class wraps the llvm.memcpy intrinsic.\nclass MemCpyInst : public MemTransferInst {\npublic:\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::memcpy;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class wraps the llvm.memmove intrinsic.\nclass MemMoveInst : public MemTransferInst {\npublic:\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::memmove;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class wraps the llvm.memcpy.inline intrinsic.\nclass MemCpyInlineInst : public MemTransferInst {\npublic:\n  ConstantInt *getLength() const {\n    return cast<ConstantInt>(MemTransferInst::getLength());\n  }\n  // Methods for support type inquiry through isa, cast, and dyn_cast:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::memcpy_inline;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n// The common base class for any memset/memmove/memcpy intrinsics;\n// whether they be atomic or non-atomic.\n// i.e. llvm.element.unordered.atomic.memset/memcpy/memmove\n//  and llvm.memset/memcpy/memmove\nclass AnyMemIntrinsic : public MemIntrinsicBase<AnyMemIntrinsic> {\npublic:\n  bool isVolatile() const {\n    // Only the non-atomic intrinsics can be volatile\n    if (auto *MI = dyn_cast<MemIntrinsic>(this))\n      return MI->isVolatile();\n    return false;\n  }\n\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memcpy:\n    case Intrinsic::memcpy_inline:\n    case Intrinsic::memmove:\n    case Intrinsic::memset:\n    case Intrinsic::memcpy_element_unordered_atomic:\n    case Intrinsic::memmove_element_unordered_atomic:\n    case Intrinsic::memset_element_unordered_atomic:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class represents any memset intrinsic\n// i.e. llvm.element.unordered.atomic.memset\n// and  llvm.memset\nclass AnyMemSetInst : public MemSetBase<AnyMemIntrinsic> {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memset:\n    case Intrinsic::memset_element_unordered_atomic:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n// This class wraps any memcpy/memmove intrinsics\n// i.e. llvm.element.unordered.atomic.memcpy/memmove\n// and  llvm.memcpy/memmove\nclass AnyMemTransferInst : public MemTransferBase<AnyMemIntrinsic> {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memcpy:\n    case Intrinsic::memcpy_inline:\n    case Intrinsic::memmove:\n    case Intrinsic::memcpy_element_unordered_atomic:\n    case Intrinsic::memmove_element_unordered_atomic:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class represents any memcpy intrinsic\n/// i.e. llvm.element.unordered.atomic.memcpy\n///  and llvm.memcpy\nclass AnyMemCpyInst : public AnyMemTransferInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memcpy:\n    case Intrinsic::memcpy_inline:\n    case Intrinsic::memcpy_element_unordered_atomic:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This class represents any memmove intrinsic\n/// i.e. llvm.element.unordered.atomic.memmove\n///  and llvm.memmove\nclass AnyMemMoveInst : public AnyMemTransferInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    switch (I->getIntrinsicID()) {\n    case Intrinsic::memmove:\n    case Intrinsic::memmove_element_unordered_atomic:\n      return true;\n    default:\n      return false;\n    }\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This represents the llvm.va_start intrinsic.\nclass VAStartInst : public IntrinsicInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::vastart;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  Value *getArgList() const { return const_cast<Value *>(getArgOperand(0)); }\n};\n\n/// This represents the llvm.va_end intrinsic.\nclass VAEndInst : public IntrinsicInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::vaend;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  Value *getArgList() const { return const_cast<Value *>(getArgOperand(0)); }\n};\n\n/// This represents the llvm.va_copy intrinsic.\nclass VACopyInst : public IntrinsicInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::vacopy;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  Value *getDest() const { return const_cast<Value *>(getArgOperand(0)); }\n  Value *getSrc() const { return const_cast<Value *>(getArgOperand(1)); }\n};\n\n/// This represents the llvm.instrprof_increment intrinsic.\nclass InstrProfIncrementInst : public IntrinsicInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::instrprof_increment;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  GlobalVariable *getName() const {\n    return cast<GlobalVariable>(\n        const_cast<Value *>(getArgOperand(0))->stripPointerCasts());\n  }\n\n  ConstantInt *getHash() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(1)));\n  }\n\n  ConstantInt *getNumCounters() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(2)));\n  }\n\n  ConstantInt *getIndex() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(3)));\n  }\n\n  Value *getStep() const;\n};\n\nclass InstrProfIncrementInstStep : public InstrProfIncrementInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::instrprof_increment_step;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n};\n\n/// This represents the llvm.instrprof_value_profile intrinsic.\nclass InstrProfValueProfileInst : public IntrinsicInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::instrprof_value_profile;\n  }\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  GlobalVariable *getName() const {\n    return cast<GlobalVariable>(\n        const_cast<Value *>(getArgOperand(0))->stripPointerCasts());\n  }\n\n  ConstantInt *getHash() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(1)));\n  }\n\n  Value *getTargetValue() const {\n    return cast<Value>(const_cast<Value *>(getArgOperand(2)));\n  }\n\n  ConstantInt *getValueKind() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(3)));\n  }\n\n  // Returns the value site index.\n  ConstantInt *getIndex() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(4)));\n  }\n};\n\nclass PseudoProbeInst : public IntrinsicInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::pseudoprobe;\n  }\n\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  ConstantInt *getFuncGuid() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(0)));\n  }\n\n  ConstantInt *getIndex() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(1)));\n  }\n\n  ConstantInt *getAttributes() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(2)));\n  }\n\n  ConstantInt *getFactor() const {\n    return cast<ConstantInt>(const_cast<Value *>(getArgOperand(3)));\n  }\n};\n\nclass NoAliasScopeDeclInst : public IntrinsicInst {\npublic:\n  static bool classof(const IntrinsicInst *I) {\n    return I->getIntrinsicID() == Intrinsic::experimental_noalias_scope_decl;\n  }\n\n  static bool classof(const Value *V) {\n    return isa<IntrinsicInst>(V) && classof(cast<IntrinsicInst>(V));\n  }\n\n  MDNode *getScopeList() const {\n    auto *MV =\n        cast<MetadataAsValue>(getOperand(Intrinsic::NoAliasScopeDeclScopeArg));\n    return cast<MDNode>(MV->getMetadata());\n  }\n\n  void setScopeList(MDNode *ScopeList) {\n    setOperand(Intrinsic::NoAliasScopeDeclScopeArg,\n               MetadataAsValue::get(getContext(), ScopeList));\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_IR_INTRINSICINST_H\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CFGUpdate.h", "content": "//===- CFGUpdate.h - Encode a CFG Edge Update. ------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a CFG Edge Update: Insert or Delete, and two Nodes as the\n// Edge ends.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_CFGUPDATE_H\n#define LLVM_SUPPORT_CFGUPDATE_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace llvm {\nnamespace cfg {\nenum class UpdateKind : unsigned char { Insert, Delete };\n\ntemplate <typename NodePtr> class Update {\n  using NodeKindPair = PointerIntPair<NodePtr, 1, UpdateKind>;\n  NodePtr From;\n  NodeKindPair ToAndKind;\n\npublic:\n  Update(UpdateKind Kind, NodePtr From, NodePtr To)\n      : From(From), ToAndKind(To, Kind) {}\n\n  UpdateKind getKind() const { return ToAndKind.getInt(); }\n  NodePtr getFrom() const { return From; }\n  NodePtr getTo() const { return ToAndKind.getPointer(); }\n  bool operator==(const Update &RHS) const {\n    return From == RHS.From && ToAndKind == RHS.ToAndKind;\n  }\n\n  void print(raw_ostream &OS) const {\n    OS << (getKind() == UpdateKind::Insert ? \"Insert \" : \"Delete \");\n    getFrom()->printAsOperand(OS, false);\n    OS << \" -> \";\n    getTo()->printAsOperand(OS, false);\n  }\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\n  LLVM_DUMP_METHOD void dump() const { print(dbgs()); }\n#endif\n};\n\n// LegalizeUpdates function simplifies updates assuming a graph structure.\n// This function serves double purpose:\n// a) It removes redundant updates, which makes it easier to reverse-apply\n//    them when traversing CFG.\n// b) It optimizes away updates that cancel each other out, as the end result\n//    is the same.\ntemplate <typename NodePtr>\nvoid LegalizeUpdates(ArrayRef<Update<NodePtr>> AllUpdates,\n                     SmallVectorImpl<Update<NodePtr>> &Result,\n                     bool InverseGraph, bool ReverseResultOrder = false) {\n  // Count the total number of inserions of each edge.\n  // Each insertion adds 1 and deletion subtracts 1. The end number should be\n  // one of {-1 (deletion), 0 (NOP), +1 (insertion)}. Otherwise, the sequence\n  // of updates contains multiple updates of the same kind and we assert for\n  // that case.\n  SmallDenseMap<std::pair<NodePtr, NodePtr>, int, 4> Operations;\n  Operations.reserve(AllUpdates.size());\n\n  for (const auto &U : AllUpdates) {\n    NodePtr From = U.getFrom();\n    NodePtr To = U.getTo();\n    if (InverseGraph)\n      std::swap(From, To); // Reverse edge for postdominators.\n\n    Operations[{From, To}] += (U.getKind() == UpdateKind::Insert ? 1 : -1);\n  }\n\n  Result.clear();\n  Result.reserve(Operations.size());\n  for (auto &Op : Operations) {\n    const int NumInsertions = Op.second;\n    assert(std::abs(NumInsertions) <= 1 && \"Unbalanced operations!\");\n    if (NumInsertions == 0)\n      continue;\n    const UpdateKind UK =\n        NumInsertions > 0 ? UpdateKind::Insert : UpdateKind::Delete;\n    Result.push_back({UK, Op.first.first, Op.first.second});\n  }\n\n  // Make the order consistent by not relying on pointer values within the\n  // set. Reuse the old Operations map.\n  // In the future, we should sort by something else to minimize the amount\n  // of work needed to perform the series of updates.\n  for (size_t i = 0, e = AllUpdates.size(); i != e; ++i) {\n    const auto &U = AllUpdates[i];\n    if (!InverseGraph)\n      Operations[{U.getFrom(), U.getTo()}] = int(i);\n    else\n      Operations[{U.getTo(), U.getFrom()}] = int(i);\n  }\n\n  llvm::sort(Result, [&](const Update<NodePtr> &A, const Update<NodePtr> &B) {\n    const auto &OpA = Operations[{A.getFrom(), A.getTo()}];\n    const auto &OpB = Operations[{B.getFrom(), B.getTo()}];\n    return ReverseResultOrder ? OpA < OpB : OpA > OpB;\n  });\n}\n\n} // end namespace cfg\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_CFGUPDATE_H\n"}, "48": {"id": 48, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "content": "//===- InstructionCost.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file\n/// This file defines an InstructionCost class that is used when calculating\n/// the cost of an instruction, or a group of instructions. In addition to a\n/// numeric value representing the cost the class also contains a state that\n/// can be used to encode particular properties, i.e. a cost being invalid or\n/// unknown.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_INSTRUCTIONCOST_H\n#define LLVM_SUPPORT_INSTRUCTIONCOST_H\n\n#include \"llvm/ADT/Optional.h\"\n\nnamespace llvm {\n\nclass raw_ostream;\n\nclass InstructionCost {\npublic:\n  using CostType = int;\n\n  /// These states can currently be used to indicate whether a cost is valid or\n  /// invalid. Examples of an invalid cost might be where the cost is\n  /// prohibitively expensive and the user wants to prevent certain\n  /// optimizations being performed. Or perhaps the cost is simply unknown\n  /// because the operation makes no sense in certain circumstances. These\n  /// states can be expanded in future to support other cases if necessary.\n  enum CostState { Valid, Invalid };\n\nprivate:\n  CostType Value = 0;\n  CostState State = Valid;\n\n  void propagateState(const InstructionCost &RHS) {\n    if (RHS.State == Invalid)\n      State = Invalid;\n  }\n\npublic:\n  // A default constructed InstructionCost is a valid zero cost\n  InstructionCost() = default;\n\n  InstructionCost(CostState) = delete;\n  InstructionCost(CostType Val) : Value(Val), State(Valid) {}\n\n  static InstructionCost getInvalid(CostType Val = 0) {\n    InstructionCost Tmp(Val);\n    Tmp.setInvalid();\n    return Tmp;\n  }\n\n  bool isValid() const { return State == Valid; }\n  void setValid() { State = Valid; }\n  void setInvalid() { State = Invalid; }\n  CostState getState() const { return State; }\n\n  /// This function is intended to be used as sparingly as possible, since the\n  /// class provides the full range of operator support required for arithmetic\n  /// and comparisons.\n  Optional<CostType> getValue() const {\n    if (isValid())\n      return Value;\n    return None;\n  }\n\n  /// For all of the arithmetic operators provided here any invalid state is\n  /// perpetuated and cannot be removed. Once a cost becomes invalid it stays\n  /// invalid, and it also inherits any invalid state from the RHS. Regardless\n  /// of the state, arithmetic and comparisons work on the actual values in the\n  /// same way as they would on a basic type, such as integer.\n\n  InstructionCost &operator+=(const InstructionCost &RHS) {\n    propagateState(RHS);\n    Value += RHS.Value;\n    return *this;\n  }\n\n  InstructionCost &operator+=(const CostType RHS) {\n    InstructionCost RHS2(RHS);\n    *this += RHS2;\n    return *this;\n  }\n\n  InstructionCost &operator-=(const InstructionCost &RHS) {\n    propagateState(RHS);\n    Value -= RHS.Value;\n    return *this;\n  }\n\n  InstructionCost &operator-=(const CostType RHS) {\n    InstructionCost RHS2(RHS);\n    *this -= RHS2;\n    return *this;\n  }\n\n  InstructionCost &operator*=(const InstructionCost &RHS) {\n    propagateState(RHS);\n    Value *= RHS.Value;\n    return *this;\n  }\n\n  InstructionCost &operator*=(const CostType RHS) {\n    InstructionCost RHS2(RHS);\n    *this *= RHS2;\n    return *this;\n  }\n\n  InstructionCost &operator/=(const InstructionCost &RHS) {\n    propagateState(RHS);\n    Value /= RHS.Value;\n    return *this;\n  }\n\n  InstructionCost &operator/=(const CostType RHS) {\n    InstructionCost RHS2(RHS);\n    *this /= RHS2;\n    return *this;\n  }\n\n  InstructionCost &operator++() {\n    *this += 1;\n    return *this;\n  }\n\n  InstructionCost operator++(int) {\n    InstructionCost Copy = *this;\n    ++*this;\n    return Copy;\n  }\n\n  InstructionCost &operator--() {\n    *this -= 1;\n    return *this;\n  }\n\n  InstructionCost operator--(int) {\n    InstructionCost Copy = *this;\n    --*this;\n    return Copy;\n  }\n\n  /// For the comparison operators we have chosen to use lexicographical\n  /// ordering where valid costs are always considered to be less than invalid\n  /// costs. This avoids having to add asserts to the comparison operators that\n  /// the states are valid and users can test for validity of the cost\n  /// explicitly.\n  bool operator<(const InstructionCost &RHS) const {\n    if (State != RHS.State)\n      return State < RHS.State;\n    return Value < RHS.Value;\n  }\n\n  // Implement in terms of operator< to ensure that the two comparisons stay in\n  // sync\n  bool operator==(const InstructionCost &RHS) const {\n    return !(*this < RHS) && !(RHS < *this);\n  }\n\n  bool operator!=(const InstructionCost &RHS) const { return !(*this == RHS); }\n\n  bool operator==(const CostType RHS) const {\n    InstructionCost RHS2(RHS);\n    return *this == RHS2;\n  }\n\n  bool operator!=(const CostType RHS) const { return !(*this == RHS); }\n\n  bool operator>(const InstructionCost &RHS) const { return RHS < *this; }\n\n  bool operator<=(const InstructionCost &RHS) const { return !(RHS < *this); }\n\n  bool operator>=(const InstructionCost &RHS) const { return !(*this < RHS); }\n\n  bool operator<(const CostType RHS) const {\n    InstructionCost RHS2(RHS);\n    return *this < RHS2;\n  }\n\n  bool operator>(const CostType RHS) const {\n    InstructionCost RHS2(RHS);\n    return *this > RHS2;\n  }\n\n  bool operator<=(const CostType RHS) const {\n    InstructionCost RHS2(RHS);\n    return *this <= RHS2;\n  }\n\n  bool operator>=(const CostType RHS) const {\n    InstructionCost RHS2(RHS);\n    return *this >= RHS2;\n  }\n\n  void print(raw_ostream &OS) const;\n};\n\ninline InstructionCost operator+(const InstructionCost &LHS,\n                                 const InstructionCost &RHS) {\n  InstructionCost LHS2(LHS);\n  LHS2 += RHS;\n  return LHS2;\n}\n\ninline InstructionCost operator-(const InstructionCost &LHS,\n                                 const InstructionCost &RHS) {\n  InstructionCost LHS2(LHS);\n  LHS2 -= RHS;\n  return LHS2;\n}\n\ninline InstructionCost operator*(const InstructionCost &LHS,\n                                 const InstructionCost &RHS) {\n  InstructionCost LHS2(LHS);\n  LHS2 *= RHS;\n  return LHS2;\n}\n\ninline InstructionCost operator/(const InstructionCost &LHS,\n                                 const InstructionCost &RHS) {\n  InstructionCost LHS2(LHS);\n  LHS2 /= RHS;\n  return LHS2;\n}\n\ninline raw_ostream &operator<<(raw_ostream &OS, const InstructionCost &V) {\n  V.print(OS);\n  return OS;\n}\n\n} // namespace llvm\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 7, "line": 161}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 7, "line": 161}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h", "reportHash": "a7ea8be0987f58ec79f90578653c5901", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 161}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h", "reportHash": "e77757f2622d50d440be5dbc4ff3389c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 164}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 7, "line": 164}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h", "reportHash": "c51b5fe824f0eb1a2fad1df281b28225", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 7, "line": 164}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h", "reportHash": "ef6f5649e0294414ff243d289efbdeda", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 24, "line": 243}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 24, "line": 243}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h", "reportHash": "8d2f37911debaa60acef15c5340efc6b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 24, "line": 243}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h", "reportHash": "43730b88ff2baa8b1107bed866e230a4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 24, "line": 246}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 24, "line": 246}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h", "reportHash": "b06dcf260652d9806a9ab19cc0ea8da1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 24, "line": 246}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h", "reportHash": "e7082d86ff4ecd64203da26ce0474057", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 175}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 25, "line": 175}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h", "reportHash": "500a69849d642dcda30145093365ab2d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 175}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h", "reportHash": "efa4df2a5d4b58f7e520c3d2382268dc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 179}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 25, "line": 179}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h", "reportHash": "55dfb0d6691fbbbd7b88f6c2badd6a5d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 179}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h", "reportHash": "af8406eeac3bfb34f64de935663bfc94", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 310}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 25, "line": 310}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h", "reportHash": "3aa1ccdc8f34b321aed77a7000ecbbc5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 310}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h", "reportHash": "235047e1b4048cef9f0a9584d4317220", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 26, "line": 884}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 26, "line": 884}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h", "reportHash": "3930d0a5c100e43f28b7441bdff352d5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 26, "line": 884}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h", "reportHash": "60720117963c792b9c5a4bc4795451d5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 26, "line": 895}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 26, "line": 895}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h", "reportHash": "e1ca107fa7251ecc1aef0edcbcc7f24b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 26, "line": 895}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h", "reportHash": "eb1b555e918169fa943d5d201209ee26", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 27, "line": 75}, "message": "'llvm/IR/Attributes.inc' file not found"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Attributes.h", "reportHash": "028601b7c3bb82de45631257f6da885e", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 15, "file": 29, "line": 71}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 29, "line": 71}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/CFG.h", "reportHash": "434cea1f6018c7c852d1d3b5dbd8d1b0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 71}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/CFG.h", "reportHash": "7fe624704f58f3f4a962cb6589271253", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 72}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 29, "line": 72}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/CFG.h", "reportHash": "495437b07a3a26ce41bc90a6362915fd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 72}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/CFG.h", "reportHash": "486e75d9624ebca8b214428d613a7428", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 200}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 29, "line": 200}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/CFG.h", "reportHash": "bcc8d07e3a644590fe1a77874606ae0d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 200}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/CFG.h", "reportHash": "3886665ec8c42a5ad6c8426069a14825", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 207}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 29, "line": 207}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/CFG.h", "reportHash": "2caa70721cb25a9a8365b4fed5cd7952", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 29, "line": 207}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/CFG.h", "reportHash": "b28d460763e3d744a70d4edea2774121", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 30, "line": 257}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 30, "line": 257}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ConstantRange.h", "reportHash": "18954a5e83dccda84d798585300fe592", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 30, "line": 257}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ConstantRange.h", "reportHash": "9fcbe32c5c6b24b4ce013dc51a436364", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 30, "line": 260}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 30, "line": 260}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ConstantRange.h", "reportHash": "affd28deac59a0dd57a2125c04bcafc2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 30, "line": 260}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/ConstantRange.h", "reportHash": "2f59499b27aed2749e3465edce489d63", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 34, "line": 2118}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 34, "line": 2118}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/InstrTypes.h", "reportHash": "939c77c6eed70a21ce3a9ac4d807ad30", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 34, "line": 2118}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/InstrTypes.h", "reportHash": "9d2abc4363c5d6308054094e6f355607", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 3240}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 35, "line": 3240}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "13f65df7cd11c792578ae89d9b315605", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 3240}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "bed8f6f00b939b84203dce9650403bb1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 3325}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 35, "line": 3325}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "390d8e30a1d8e7aa3a06edc66c4130e1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 3325}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "39716dffe879a8391268c3a3e4165192", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 3328}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 35, "line": 3328}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "da9ff56efe0c0dee7ea7bbeb79273581", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 35, "line": 3328}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/Instructions.h", "reportHash": "fb792b5836e4f811a10544a192c1af9c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 36, "line": 167}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 36, "line": 167}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h", "reportHash": "a7719a1b09507846cc62fc4a19e73c6c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 36, "line": 167}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h", "reportHash": "c2967d5151d7e86ded810ffd2719a0c7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 44, "line": 39}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 44, "line": 39}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CFGUpdate.h", "reportHash": "02ffb593e50e0fdf5e658f63e7d82179", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 44, "line": 39}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/CFGUpdate.h", "reportHash": "93ab2fedddeea114223034ec81a1ee2b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 155}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 48, "line": 155}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "929c65f971b18fb87907f109274cdcf7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 155}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "aaff78f38c05ecfffcbf06c899006ed0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 163}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 48, "line": 163}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "7e58a63bee25631e4096923d44b3c308", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 163}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "147e3a9e070aeffde1c9f15b33cc5816", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 167}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 48, "line": 167}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "382c6bd884437e7368ebb6c7aa83d1be", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 167}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "cc48cddc4da76818b2b2b43b8a9768b8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 169}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 48, "line": 169}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "6643d83283f9f27d6a3e1336efeda4ad", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 169}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "8b1d3c18261fb95c86bb649f9f44813f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 174}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 48, "line": 174}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "e2c50cfaa101e185b132cd13dc7471b6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 174}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "c817d820f3dc521b70b61b77fd241e72", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 176}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 48, "line": 176}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "b63f13caeed0f6439908ebe38383e721", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 176}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "c72cb6efcd308ac00af3f46822aa0542", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 178}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 48, "line": 178}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "bae3369fe83ca8760a93838f487e7112", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 178}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "64027354c95f340080a046bc6fab92bb", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 180}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 48, "line": 180}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "0c7248841d1db88acb1a1a994d1d7f6f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 180}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "6bcb983bfb274ceee0097a15b8ecd69a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 182}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 48, "line": 182}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "07039907579bd8d39959f62f95c707c0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 182}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "cd04ef15912a0ed5fbac56618c759061", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 187}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 48, "line": 187}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "1757db77f5d7360665320cb0d6d57e66", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 187}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "61171b46cc2265d870fd5ce09c45790f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 192}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 48, "line": 192}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "49eda84dff8d94e859d20226e1bd58f4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 192}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "257345e0b8ec7386638fff846dcacef7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 197}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 48, "line": 197}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "d2c3f6e7f2dcdbcf6e9688318a37a933", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 48, "line": 197}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/InstructionCost.h", "reportHash": "ea7b0b09dc5ffac6716a851807715c23", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
