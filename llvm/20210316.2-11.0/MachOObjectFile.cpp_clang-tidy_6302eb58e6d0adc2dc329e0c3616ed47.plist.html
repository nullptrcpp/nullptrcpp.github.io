<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Object/MachOObjectFile.cpp", "content": "//===- MachOObjectFile.cpp - Mach-O object file binding -------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the MachOObjectFile class, which binds the MachOObject\n// class to the generic ObjectFile wrapper.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/BinaryFormat/MachO.h\"\n#include \"llvm/Object/Error.h\"\n#include \"llvm/Object/MachO.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Object/SymbolicFile.h\"\n#include \"llvm/Support/DataExtractor.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/Host.h\"\n#include \"llvm/Support/LEB128.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/SwapByteOrder.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <limits>\n#include <list>\n#include <memory>\n#include <string>\n#include <system_error>\n\nusing namespace llvm;\nusing namespace object;\n\nnamespace {\n\n  struct section_base {\n    char sectname[16];\n    char segname[16];\n  };\n\n} // end anonymous namespace\n\nstatic Error malformedError(const Twine &Msg) {\n  return make_error<GenericBinaryError>(\"truncated or malformed object (\" +\n                                            Msg + \")\",\n                                        object_error::parse_failed);\n}\n\n// FIXME: Replace all uses of this function with getStructOrErr.\ntemplate <typename T>\nstatic T getStruct(const MachOObjectFile &O, const char *P) {\n  // Don't read before the beginning or past the end of the file\n  if (P < O.getData().begin() || P + sizeof(T) > O.getData().end())\n    report_fatal_error(\"Malformed MachO file.\");\n\n  T Cmd;\n  memcpy(&Cmd, P, sizeof(T));\n  if (O.isLittleEndian() != sys::IsLittleEndianHost)\n    MachO::swapStruct(Cmd);\n  return Cmd;\n}\n\ntemplate <typename T>\nstatic Expected<T> getStructOrErr(const MachOObjectFile &O, const char *P) {\n  // Don't read before the beginning or past the end of the file\n  if (P < O.getData().begin() || P + sizeof(T) > O.getData().end())\n    return malformedError(\"Structure read out-of-range\");\n\n  T Cmd;\n  memcpy(&Cmd, P, sizeof(T));\n  if (O.isLittleEndian() != sys::IsLittleEndianHost)\n    MachO::swapStruct(Cmd);\n  return Cmd;\n}\n\nstatic const char *\ngetSectionPtr(const MachOObjectFile &O, MachOObjectFile::LoadCommandInfo L,\n              unsigned Sec) {\n  uintptr_t CommandAddr = reinterpret_cast<uintptr_t>(L.Ptr);\n\n  bool Is64 = O.is64Bit();\n  unsigned SegmentLoadSize = Is64 ? sizeof(MachO::segment_command_64) :\n                                    sizeof(MachO::segment_command);\n  unsigned SectionSize = Is64 ? sizeof(MachO::section_64) :\n                                sizeof(MachO::section);\n\n  uintptr_t SectionAddr = CommandAddr + SegmentLoadSize + Sec * SectionSize;\n  return reinterpret_cast<const char*>(SectionAddr);\n}\n\nstatic const char *getPtr(const MachOObjectFile &O, size_t Offset) {\n  assert(Offset <= O.getData().size());\n  return O.getData().data() + Offset;\n}\n\nstatic MachO::nlist_base\ngetSymbolTableEntryBase(const MachOObjectFile &O, DataRefImpl DRI) {\n  const char *P = reinterpret_cast<const char *>(DRI.p);\n  return getStruct<MachO::nlist_base>(O, P);\n}\n\nstatic StringRef parseSegmentOrSectionName(const char *P) {\n  if (P[15] == 0)\n    // Null terminated.\n    return P;\n  // Not null terminated, so this is a 16 char string.\n  return StringRef(P, 16);\n}\n\nstatic unsigned getCPUType(const MachOObjectFile &O) {\n  return O.getHeader().cputype;\n}\n\nstatic unsigned getCPUSubType(const MachOObjectFile &O) {\n  return O.getHeader().cpusubtype;\n}\n\nstatic uint32_t\ngetPlainRelocationAddress(const MachO::any_relocation_info &RE) {\n  return RE.r_word0;\n}\n\nstatic unsigned\ngetScatteredRelocationAddress(const MachO::any_relocation_info &RE) {\n  return RE.r_word0 & 0xffffff;\n}\n\nstatic bool getPlainRelocationPCRel(const MachOObjectFile &O,\n                                    const MachO::any_relocation_info &RE) {\n  if (O.isLittleEndian())\n    return (RE.r_word1 >> 24) & 1;\n  return (RE.r_word1 >> 7) & 1;\n}\n\nstatic bool\ngetScatteredRelocationPCRel(const MachO::any_relocation_info &RE) {\n  return (RE.r_word0 >> 30) & 1;\n}\n\nstatic unsigned getPlainRelocationLength(const MachOObjectFile &O,\n                                         const MachO::any_relocation_info &RE) {\n  if (O.isLittleEndian())\n    return (RE.r_word1 >> 25) & 3;\n  return (RE.r_word1 >> 5) & 3;\n}\n\nstatic unsigned\ngetScatteredRelocationLength(const MachO::any_relocation_info &RE) {\n  return (RE.r_word0 >> 28) & 3;\n}\n\nstatic unsigned getPlainRelocationType(const MachOObjectFile &O,\n                                       const MachO::any_relocation_info &RE) {\n  if (O.isLittleEndian())\n    return RE.r_word1 >> 28;\n  return RE.r_word1 & 0xf;\n}\n\nstatic uint32_t getSectionFlags(const MachOObjectFile &O,\n                                DataRefImpl Sec) {\n  if (O.is64Bit()) {\n    MachO::section_64 Sect = O.getSection64(Sec);\n    return Sect.flags;\n  }\n  MachO::section Sect = O.getSection(Sec);\n  return Sect.flags;\n}\n\nstatic Expected<MachOObjectFile::LoadCommandInfo>\ngetLoadCommandInfo(const MachOObjectFile &Obj, const char *Ptr,\n                   uint32_t LoadCommandIndex) {\n  if (auto CmdOrErr = getStructOrErr<MachO::load_command>(Obj, Ptr)) {\n    if (CmdOrErr->cmdsize + Ptr > Obj.getData().end())\n      return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                            \" extends past end of file\");\n    if (CmdOrErr->cmdsize < 8)\n      return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                            \" with size less than 8 bytes\");\n    return MachOObjectFile::LoadCommandInfo({Ptr, *CmdOrErr});\n  } else\n    return CmdOrErr.takeError();\n}\n\nstatic Expected<MachOObjectFile::LoadCommandInfo>\ngetFirstLoadCommandInfo(const MachOObjectFile &Obj) {\n  unsigned HeaderSize = Obj.is64Bit() ? sizeof(MachO::mach_header_64)\n                                      : sizeof(MachO::mach_header);\n  if (sizeof(MachO::load_command) > Obj.getHeader().sizeofcmds)\n    return malformedError(\"load command 0 extends past the end all load \"\n                          \"commands in the file\");\n  return getLoadCommandInfo(Obj, getPtr(Obj, HeaderSize), 0);\n}\n\nstatic Expected<MachOObjectFile::LoadCommandInfo>\ngetNextLoadCommandInfo(const MachOObjectFile &Obj, uint32_t LoadCommandIndex,\n                       const MachOObjectFile::LoadCommandInfo &L) {\n  unsigned HeaderSize = Obj.is64Bit() ? sizeof(MachO::mach_header_64)\n                                      : sizeof(MachO::mach_header);\n  if (L.Ptr + L.C.cmdsize + sizeof(MachO::load_command) >\n      Obj.getData().data() + HeaderSize + Obj.getHeader().sizeofcmds)\n    return malformedError(\"load command \" + Twine(LoadCommandIndex + 1) +\n                          \" extends past the end all load commands in the file\");\n  return getLoadCommandInfo(Obj, L.Ptr + L.C.cmdsize, LoadCommandIndex + 1);\n}\n\ntemplate <typename T>\nstatic void parseHeader(const MachOObjectFile &Obj, T &Header,\n                        Error &Err) {\n  if (sizeof(T) > Obj.getData().size()) {\n    Err = malformedError(\"the mach header extends past the end of the \"\n                         \"file\");\n    return;\n  }\n  if (auto HeaderOrErr = getStructOrErr<T>(Obj, getPtr(Obj, 0)))\n    Header = *HeaderOrErr;\n  else\n    Err = HeaderOrErr.takeError();\n}\n\n// This is used to check for overlapping of Mach-O elements.\nstruct MachOElement {\n  uint64_t Offset;\n  uint64_t Size;\n  const char *Name;\n};\n\nstatic Error checkOverlappingElement(std::list<MachOElement> &Elements,\n                                     uint64_t Offset, uint64_t Size,\n                                     const char *Name) {\n  if (Size == 0)\n    return Error::success();\n\n  for (auto it=Elements.begin() ; it != Elements.end(); ++it) {\n    auto E = *it;\n    if ((Offset >= E.Offset && Offset < E.Offset + E.Size) ||\n        (Offset + Size > E.Offset && Offset + Size < E.Offset + E.Size) ||\n        (Offset <= E.Offset && Offset + Size >= E.Offset + E.Size))\n      return malformedError(Twine(Name) + \" at offset \" + Twine(Offset) +\n                            \" with a size of \" + Twine(Size) + \", overlaps \" +\n                            E.Name + \" at offset \" + Twine(E.Offset) + \" with \"\n                            \"a size of \" + Twine(E.Size));\n    auto nt = it;\n    nt++;\n    if (nt != Elements.end()) {\n      auto N = *nt;\n      if (Offset + Size <= N.Offset) {\n        Elements.insert(nt, {Offset, Size, Name});\n        return Error::success();\n      }\n    }\n  }\n  Elements.push_back({Offset, Size, Name});\n  return Error::success();\n}\n\n// Parses LC_SEGMENT or LC_SEGMENT_64 load command, adds addresses of all\n// sections to \\param Sections, and optionally sets\n// \\param IsPageZeroSegment to true.\ntemplate <typename Segment, typename Section>\nstatic Error parseSegmentLoadCommand(\n    const MachOObjectFile &Obj, const MachOObjectFile::LoadCommandInfo &Load,\n    SmallVectorImpl<const char *> &Sections, bool &IsPageZeroSegment,\n    uint32_t LoadCommandIndex, const char *CmdName, uint64_t SizeOfHeaders,\n    std::list<MachOElement> &Elements) {\n  const unsigned SegmentLoadSize = sizeof(Segment);\n  if (Load.C.cmdsize < SegmentLoadSize)\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                          \" \" + CmdName + \" cmdsize too small\");\n  if (auto SegOrErr = getStructOrErr<Segment>(Obj, Load.Ptr)) {\n    Segment S = SegOrErr.get();\n    const unsigned SectionSize = sizeof(Section);\n    uint64_t FileSize = Obj.getData().size();\n    if (S.nsects > std::numeric_limits<uint32_t>::max() / SectionSize ||\n        S.nsects * SectionSize > Load.C.cmdsize - SegmentLoadSize)\n      return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                            \" inconsistent cmdsize in \" + CmdName +\n                            \" for the number of sections\");\n    for (unsigned J = 0; J < S.nsects; ++J) {\n      const char *Sec = getSectionPtr(Obj, Load, J);\n      Sections.push_back(Sec);\n      auto SectionOrErr = getStructOrErr<Section>(Obj, Sec);\n      if (!SectionOrErr)\n        return SectionOrErr.takeError();\n      Section s = SectionOrErr.get();\n      if (Obj.getHeader().filetype != MachO::MH_DYLIB_STUB &&\n          Obj.getHeader().filetype != MachO::MH_DSYM &&\n          s.flags != MachO::S_ZEROFILL &&\n          s.flags != MachO::S_THREAD_LOCAL_ZEROFILL &&\n          s.offset > FileSize)\n        return malformedError(\"offset field of section \" + Twine(J) + \" in \" +\n                              CmdName + \" command \" + Twine(LoadCommandIndex) +\n                              \" extends past the end of the file\");\n      if (Obj.getHeader().filetype != MachO::MH_DYLIB_STUB &&\n          Obj.getHeader().filetype != MachO::MH_DSYM &&\n          s.flags != MachO::S_ZEROFILL &&\n          s.flags != MachO::S_THREAD_LOCAL_ZEROFILL && S.fileoff == 0 &&\n          s.offset < SizeOfHeaders && s.size != 0)\n        return malformedError(\"offset field of section \" + Twine(J) + \" in \" +\n                              CmdName + \" command \" + Twine(LoadCommandIndex) +\n                              \" not past the headers of the file\");\n      uint64_t BigSize = s.offset;\n      BigSize += s.size;\n      if (Obj.getHeader().filetype != MachO::MH_DYLIB_STUB &&\n          Obj.getHeader().filetype != MachO::MH_DSYM &&\n          s.flags != MachO::S_ZEROFILL &&\n          s.flags != MachO::S_THREAD_LOCAL_ZEROFILL &&\n          BigSize > FileSize)\n        return malformedError(\"offset field plus size field of section \" +\n                              Twine(J) + \" in \" + CmdName + \" command \" +\n                              Twine(LoadCommandIndex) +\n                              \" extends past the end of the file\");\n      if (Obj.getHeader().filetype != MachO::MH_DYLIB_STUB &&\n          Obj.getHeader().filetype != MachO::MH_DSYM &&\n          s.flags != MachO::S_ZEROFILL &&\n          s.flags != MachO::S_THREAD_LOCAL_ZEROFILL &&\n          s.size > S.filesize)\n        return malformedError(\"size field of section \" +\n                              Twine(J) + \" in \" + CmdName + \" command \" +\n                              Twine(LoadCommandIndex) +\n                              \" greater than the segment\");\n      if (Obj.getHeader().filetype != MachO::MH_DYLIB_STUB &&\n          Obj.getHeader().filetype != MachO::MH_DSYM && s.size != 0 &&\n          s.addr < S.vmaddr)\n        return malformedError(\"addr field of section \" + Twine(J) + \" in \" +\n                              CmdName + \" command \" + Twine(LoadCommandIndex) +\n                              \" less than the segment's vmaddr\");\n      BigSize = s.addr;\n      BigSize += s.size;\n      uint64_t BigEnd = S.vmaddr;\n      BigEnd += S.vmsize;\n      if (S.vmsize != 0 && s.size != 0 && BigSize > BigEnd)\n        return malformedError(\"addr field plus size of section \" + Twine(J) +\n                              \" in \" + CmdName + \" command \" +\n                              Twine(LoadCommandIndex) +\n                              \" greater than than \"\n                              \"the segment's vmaddr plus vmsize\");\n      if (Obj.getHeader().filetype != MachO::MH_DYLIB_STUB &&\n          Obj.getHeader().filetype != MachO::MH_DSYM &&\n          s.flags != MachO::S_ZEROFILL &&\n          s.flags != MachO::S_THREAD_LOCAL_ZEROFILL)\n        if (Error Err = checkOverlappingElement(Elements, s.offset, s.size,\n                                                \"section contents\"))\n          return Err;\n      if (s.reloff > FileSize)\n        return malformedError(\"reloff field of section \" + Twine(J) + \" in \" +\n                              CmdName + \" command \" + Twine(LoadCommandIndex) +\n                              \" extends past the end of the file\");\n      BigSize = s.nreloc;\n      BigSize *= sizeof(struct MachO::relocation_info);\n      BigSize += s.reloff;\n      if (BigSize > FileSize)\n        return malformedError(\"reloff field plus nreloc field times sizeof(\"\n                              \"struct relocation_info) of section \" +\n                              Twine(J) + \" in \" + CmdName + \" command \" +\n                              Twine(LoadCommandIndex) +\n                              \" extends past the end of the file\");\n      if (Error Err = checkOverlappingElement(Elements, s.reloff, s.nreloc *\n                                              sizeof(struct\n                                              MachO::relocation_info),\n                                              \"section relocation entries\"))\n        return Err;\n    }\n    if (S.fileoff > FileSize)\n      return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                            \" fileoff field in \" + CmdName +\n                            \" extends past the end of the file\");\n    uint64_t BigSize = S.fileoff;\n    BigSize += S.filesize;\n    if (BigSize > FileSize)\n      return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                            \" fileoff field plus filesize field in \" +\n                            CmdName + \" extends past the end of the file\");\n    if (S.vmsize != 0 && S.filesize > S.vmsize)\n      return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                            \" filesize field in \" + CmdName +\n                            \" greater than vmsize field\");\n    IsPageZeroSegment |= StringRef(\"__PAGEZERO\").equals(S.segname);\n  } else\n    return SegOrErr.takeError();\n\n  return Error::success();\n}\n\nstatic Error checkSymtabCommand(const MachOObjectFile &Obj,\n                                const MachOObjectFile::LoadCommandInfo &Load,\n                                uint32_t LoadCommandIndex,\n                                const char **SymtabLoadCmd,\n                                std::list<MachOElement> &Elements) {\n  if (Load.C.cmdsize < sizeof(MachO::symtab_command))\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                          \" LC_SYMTAB cmdsize too small\");\n  if (*SymtabLoadCmd != nullptr)\n    return malformedError(\"more than one LC_SYMTAB command\");\n  auto SymtabOrErr = getStructOrErr<MachO::symtab_command>(Obj, Load.Ptr);\n  if (!SymtabOrErr)\n    return SymtabOrErr.takeError();\n  MachO::symtab_command Symtab = SymtabOrErr.get();\n  if (Symtab.cmdsize != sizeof(MachO::symtab_command))\n    return malformedError(\"LC_SYMTAB command \" + Twine(LoadCommandIndex) +\n                          \" has incorrect cmdsize\");\n  uint64_t FileSize = Obj.getData().size();\n  if (Symtab.symoff > FileSize)\n    return malformedError(\"symoff field of LC_SYMTAB command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end \"\n                          \"of the file\");\n  uint64_t SymtabSize = Symtab.nsyms;\n  const char *struct_nlist_name;\n  if (Obj.is64Bit()) {\n    SymtabSize *= sizeof(MachO::nlist_64);\n    struct_nlist_name = \"struct nlist_64\";\n  } else {\n    SymtabSize *= sizeof(MachO::nlist);\n    struct_nlist_name = \"struct nlist\";\n  }\n  uint64_t BigSize = SymtabSize;\n  BigSize += Symtab.symoff;\n  if (BigSize > FileSize)\n    return malformedError(\"symoff field plus nsyms field times sizeof(\" +\n                          Twine(struct_nlist_name) + \") of LC_SYMTAB command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end \"\n                          \"of the file\");\n  if (Error Err = checkOverlappingElement(Elements, Symtab.symoff, SymtabSize,\n                                          \"symbol table\"))\n    return Err;\n  if (Symtab.stroff > FileSize)\n    return malformedError(\"stroff field of LC_SYMTAB command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end \"\n                          \"of the file\");\n  BigSize = Symtab.stroff;\n  BigSize += Symtab.strsize;\n  if (BigSize > FileSize)\n    return malformedError(\"stroff field plus strsize field of LC_SYMTAB \"\n                          \"command \" + Twine(LoadCommandIndex) + \" extends \"\n                          \"past the end of the file\");\n  if (Error Err = checkOverlappingElement(Elements, Symtab.stroff,\n                                          Symtab.strsize, \"string table\"))\n    return Err;\n  *SymtabLoadCmd = Load.Ptr;\n  return Error::success();\n}\n\nstatic Error checkDysymtabCommand(const MachOObjectFile &Obj,\n                                  const MachOObjectFile::LoadCommandInfo &Load,\n                                  uint32_t LoadCommandIndex,\n                                  const char **DysymtabLoadCmd,\n                                  std::list<MachOElement> &Elements) {\n  if (Load.C.cmdsize < sizeof(MachO::dysymtab_command))\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                          \" LC_DYSYMTAB cmdsize too small\");\n  if (*DysymtabLoadCmd != nullptr)\n    return malformedError(\"more than one LC_DYSYMTAB command\");\n  auto DysymtabOrErr =\n    getStructOrErr<MachO::dysymtab_command>(Obj, Load.Ptr);\n  if (!DysymtabOrErr)\n    return DysymtabOrErr.takeError();\n  MachO::dysymtab_command Dysymtab = DysymtabOrErr.get();\n  if (Dysymtab.cmdsize != sizeof(MachO::dysymtab_command))\n    return malformedError(\"LC_DYSYMTAB command \" + Twine(LoadCommandIndex) +\n                          \" has incorrect cmdsize\");\n  uint64_t FileSize = Obj.getData().size();\n  if (Dysymtab.tocoff > FileSize)\n    return malformedError(\"tocoff field of LC_DYSYMTAB command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  uint64_t BigSize = Dysymtab.ntoc;\n  BigSize *= sizeof(MachO::dylib_table_of_contents);\n  BigSize += Dysymtab.tocoff;\n  if (BigSize > FileSize)\n    return malformedError(\"tocoff field plus ntoc field times sizeof(struct \"\n                          \"dylib_table_of_contents) of LC_DYSYMTAB command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  if (Error Err = checkOverlappingElement(Elements, Dysymtab.tocoff,\n                                          Dysymtab.ntoc * sizeof(struct\n                                          MachO::dylib_table_of_contents),\n                                          \"table of contents\"))\n    return Err;\n  if (Dysymtab.modtaboff > FileSize)\n    return malformedError(\"modtaboff field of LC_DYSYMTAB command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  BigSize = Dysymtab.nmodtab;\n  const char *struct_dylib_module_name;\n  uint64_t sizeof_modtab;\n  if (Obj.is64Bit()) {\n    sizeof_modtab = sizeof(MachO::dylib_module_64);\n    struct_dylib_module_name = \"struct dylib_module_64\";\n  } else {\n    sizeof_modtab = sizeof(MachO::dylib_module);\n    struct_dylib_module_name = \"struct dylib_module\";\n  }\n  BigSize *= sizeof_modtab;\n  BigSize += Dysymtab.modtaboff;\n  if (BigSize > FileSize)\n    return malformedError(\"modtaboff field plus nmodtab field times sizeof(\" +\n                          Twine(struct_dylib_module_name) + \") of LC_DYSYMTAB \"\n                          \"command \" + Twine(LoadCommandIndex) + \" extends \"\n                          \"past the end of the file\");\n  if (Error Err = checkOverlappingElement(Elements, Dysymtab.modtaboff,\n                                          Dysymtab.nmodtab * sizeof_modtab,\n                                          \"module table\"))\n    return Err;\n  if (Dysymtab.extrefsymoff > FileSize)\n    return malformedError(\"extrefsymoff field of LC_DYSYMTAB command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  BigSize = Dysymtab.nextrefsyms;\n  BigSize *= sizeof(MachO::dylib_reference);\n  BigSize += Dysymtab.extrefsymoff;\n  if (BigSize > FileSize)\n    return malformedError(\"extrefsymoff field plus nextrefsyms field times \"\n                          \"sizeof(struct dylib_reference) of LC_DYSYMTAB \"\n                          \"command \" + Twine(LoadCommandIndex) + \" extends \"\n                          \"past the end of the file\");\n  if (Error Err = checkOverlappingElement(Elements, Dysymtab.extrefsymoff,\n                                          Dysymtab.nextrefsyms *\n                                              sizeof(MachO::dylib_reference),\n                                          \"reference table\"))\n    return Err;\n  if (Dysymtab.indirectsymoff > FileSize)\n    return malformedError(\"indirectsymoff field of LC_DYSYMTAB command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  BigSize = Dysymtab.nindirectsyms;\n  BigSize *= sizeof(uint32_t);\n  BigSize += Dysymtab.indirectsymoff;\n  if (BigSize > FileSize)\n    return malformedError(\"indirectsymoff field plus nindirectsyms field times \"\n                          \"sizeof(uint32_t) of LC_DYSYMTAB command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  if (Error Err = checkOverlappingElement(Elements, Dysymtab.indirectsymoff,\n                                          Dysymtab.nindirectsyms *\n                                          sizeof(uint32_t),\n                                          \"indirect table\"))\n    return Err;\n  if (Dysymtab.extreloff > FileSize)\n    return malformedError(\"extreloff field of LC_DYSYMTAB command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  BigSize = Dysymtab.nextrel;\n  BigSize *= sizeof(MachO::relocation_info);\n  BigSize += Dysymtab.extreloff;\n  if (BigSize > FileSize)\n    return malformedError(\"extreloff field plus nextrel field times sizeof\"\n                          \"(struct relocation_info) of LC_DYSYMTAB command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  if (Error Err = checkOverlappingElement(Elements, Dysymtab.extreloff,\n                                          Dysymtab.nextrel *\n                                              sizeof(MachO::relocation_info),\n                                          \"external relocation table\"))\n    return Err;\n  if (Dysymtab.locreloff > FileSize)\n    return malformedError(\"locreloff field of LC_DYSYMTAB command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  BigSize = Dysymtab.nlocrel;\n  BigSize *= sizeof(MachO::relocation_info);\n  BigSize += Dysymtab.locreloff;\n  if (BigSize > FileSize)\n    return malformedError(\"locreloff field plus nlocrel field times sizeof\"\n                          \"(struct relocation_info) of LC_DYSYMTAB command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  if (Error Err = checkOverlappingElement(Elements, Dysymtab.locreloff,\n                                          Dysymtab.nlocrel *\n                                              sizeof(MachO::relocation_info),\n                                          \"local relocation table\"))\n    return Err;\n  *DysymtabLoadCmd = Load.Ptr;\n  return Error::success();\n}\n\nstatic Error checkLinkeditDataCommand(const MachOObjectFile &Obj,\n                                 const MachOObjectFile::LoadCommandInfo &Load,\n                                 uint32_t LoadCommandIndex,\n                                 const char **LoadCmd, const char *CmdName,\n                                 std::list<MachOElement> &Elements,\n                                 const char *ElementName) {\n  if (Load.C.cmdsize < sizeof(MachO::linkedit_data_command))\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) + \" \" +\n                          CmdName + \" cmdsize too small\");\n  if (*LoadCmd != nullptr)\n    return malformedError(\"more than one \" + Twine(CmdName) + \" command\");\n  auto LinkDataOrError =\n    getStructOrErr<MachO::linkedit_data_command>(Obj, Load.Ptr);\n  if (!LinkDataOrError)\n    return LinkDataOrError.takeError();\n  MachO::linkedit_data_command LinkData = LinkDataOrError.get();\n  if (LinkData.cmdsize != sizeof(MachO::linkedit_data_command))\n    return malformedError(Twine(CmdName) + \" command \" +\n                          Twine(LoadCommandIndex) + \" has incorrect cmdsize\");\n  uint64_t FileSize = Obj.getData().size();\n  if (LinkData.dataoff > FileSize)\n    return malformedError(\"dataoff field of \" + Twine(CmdName) + \" command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  uint64_t BigSize = LinkData.dataoff;\n  BigSize += LinkData.datasize;\n  if (BigSize > FileSize)\n    return malformedError(\"dataoff field plus datasize field of \" +\n                          Twine(CmdName) + \" command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  if (Error Err = checkOverlappingElement(Elements, LinkData.dataoff,\n                                          LinkData.datasize, ElementName))\n    return Err;\n  *LoadCmd = Load.Ptr;\n  return Error::success();\n}\n\nstatic Error checkDyldInfoCommand(const MachOObjectFile &Obj,\n                                  const MachOObjectFile::LoadCommandInfo &Load,\n                                  uint32_t LoadCommandIndex,\n                                  const char **LoadCmd, const char *CmdName,\n                                  std::list<MachOElement> &Elements) {\n  if (Load.C.cmdsize < sizeof(MachO::dyld_info_command))\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) + \" \" +\n                          CmdName + \" cmdsize too small\");\n  if (*LoadCmd != nullptr)\n    return malformedError(\"more than one LC_DYLD_INFO and or LC_DYLD_INFO_ONLY \"\n                          \"command\");\n  auto DyldInfoOrErr =\n    getStructOrErr<MachO::dyld_info_command>(Obj, Load.Ptr);\n  if (!DyldInfoOrErr)\n    return DyldInfoOrErr.takeError();\n  MachO::dyld_info_command DyldInfo = DyldInfoOrErr.get();\n  if (DyldInfo.cmdsize != sizeof(MachO::dyld_info_command))\n    return malformedError(Twine(CmdName) + \" command \" +\n                          Twine(LoadCommandIndex) + \" has incorrect cmdsize\");\n  uint64_t FileSize = Obj.getData().size();\n  if (DyldInfo.rebase_off > FileSize)\n    return malformedError(\"rebase_off field of \" + Twine(CmdName) +\n                          \" command \" + Twine(LoadCommandIndex) + \" extends \"\n                          \"past the end of the file\");\n  uint64_t BigSize = DyldInfo.rebase_off;\n  BigSize += DyldInfo.rebase_size;\n  if (BigSize > FileSize)\n    return malformedError(\"rebase_off field plus rebase_size field of \" +\n                          Twine(CmdName) + \" command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  if (Error Err = checkOverlappingElement(Elements, DyldInfo.rebase_off,\n                                          DyldInfo.rebase_size,\n                                          \"dyld rebase info\"))\n    return Err;\n  if (DyldInfo.bind_off > FileSize)\n    return malformedError(\"bind_off field of \" + Twine(CmdName) +\n                          \" command \" + Twine(LoadCommandIndex) + \" extends \"\n                          \"past the end of the file\");\n  BigSize = DyldInfo.bind_off;\n  BigSize += DyldInfo.bind_size;\n  if (BigSize > FileSize)\n    return malformedError(\"bind_off field plus bind_size field of \" +\n                          Twine(CmdName) + \" command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  if (Error Err = checkOverlappingElement(Elements, DyldInfo.bind_off,\n                                          DyldInfo.bind_size,\n                                          \"dyld bind info\"))\n    return Err;\n  if (DyldInfo.weak_bind_off > FileSize)\n    return malformedError(\"weak_bind_off field of \" + Twine(CmdName) +\n                          \" command \" + Twine(LoadCommandIndex) + \" extends \"\n                          \"past the end of the file\");\n  BigSize = DyldInfo.weak_bind_off;\n  BigSize += DyldInfo.weak_bind_size;\n  if (BigSize > FileSize)\n    return malformedError(\"weak_bind_off field plus weak_bind_size field of \" +\n                          Twine(CmdName) + \" command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  if (Error Err = checkOverlappingElement(Elements, DyldInfo.weak_bind_off,\n                                          DyldInfo.weak_bind_size,\n                                          \"dyld weak bind info\"))\n    return Err;\n  if (DyldInfo.lazy_bind_off > FileSize)\n    return malformedError(\"lazy_bind_off field of \" + Twine(CmdName) +\n                          \" command \" + Twine(LoadCommandIndex) + \" extends \"\n                          \"past the end of the file\");\n  BigSize = DyldInfo.lazy_bind_off;\n  BigSize += DyldInfo.lazy_bind_size;\n  if (BigSize > FileSize)\n    return malformedError(\"lazy_bind_off field plus lazy_bind_size field of \" +\n                          Twine(CmdName) + \" command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  if (Error Err = checkOverlappingElement(Elements, DyldInfo.lazy_bind_off,\n                                          DyldInfo.lazy_bind_size,\n                                          \"dyld lazy bind info\"))\n    return Err;\n  if (DyldInfo.export_off > FileSize)\n    return malformedError(\"export_off field of \" + Twine(CmdName) +\n                          \" command \" + Twine(LoadCommandIndex) + \" extends \"\n                          \"past the end of the file\");\n  BigSize = DyldInfo.export_off;\n  BigSize += DyldInfo.export_size;\n  if (BigSize > FileSize)\n    return malformedError(\"export_off field plus export_size field of \" +\n                          Twine(CmdName) + \" command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  if (Error Err = checkOverlappingElement(Elements, DyldInfo.export_off,\n                                          DyldInfo.export_size,\n                                          \"dyld export info\"))\n    return Err;\n  *LoadCmd = Load.Ptr;\n  return Error::success();\n}\n\nstatic Error checkDylibCommand(const MachOObjectFile &Obj,\n                               const MachOObjectFile::LoadCommandInfo &Load,\n                               uint32_t LoadCommandIndex, const char *CmdName) {\n  if (Load.C.cmdsize < sizeof(MachO::dylib_command))\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) + \" \" +\n                          CmdName + \" cmdsize too small\");\n  auto CommandOrErr = getStructOrErr<MachO::dylib_command>(Obj, Load.Ptr);\n  if (!CommandOrErr)\n    return CommandOrErr.takeError();\n  MachO::dylib_command D = CommandOrErr.get();\n  if (D.dylib.name < sizeof(MachO::dylib_command))\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) + \" \" +\n                          CmdName + \" name.offset field too small, not past \"\n                          \"the end of the dylib_command struct\");\n  if (D.dylib.name >= D.cmdsize)\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) + \" \" +\n                          CmdName + \" name.offset field extends past the end \"\n                          \"of the load command\");\n  // Make sure there is a null between the starting offset of the name and\n  // the end of the load command.\n  uint32_t i;\n  const char *P = (const char *)Load.Ptr;\n  for (i = D.dylib.name; i < D.cmdsize; i++)\n    if (P[i] == '\\0')\n      break;\n  if (i >= D.cmdsize)\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) + \" \" +\n                          CmdName + \" library name extends past the end of the \"\n                          \"load command\");\n  return Error::success();\n}\n\nstatic Error checkDylibIdCommand(const MachOObjectFile &Obj,\n                                 const MachOObjectFile::LoadCommandInfo &Load,\n                                 uint32_t LoadCommandIndex,\n                                 const char **LoadCmd) {\n  if (Error Err = checkDylibCommand(Obj, Load, LoadCommandIndex,\n                                     \"LC_ID_DYLIB\"))\n    return Err;\n  if (*LoadCmd != nullptr)\n    return malformedError(\"more than one LC_ID_DYLIB command\");\n  if (Obj.getHeader().filetype != MachO::MH_DYLIB &&\n      Obj.getHeader().filetype != MachO::MH_DYLIB_STUB)\n    return malformedError(\"LC_ID_DYLIB load command in non-dynamic library \"\n                          \"file type\");\n  *LoadCmd = Load.Ptr;\n  return Error::success();\n}\n\nstatic Error checkDyldCommand(const MachOObjectFile &Obj,\n                              const MachOObjectFile::LoadCommandInfo &Load,\n                              uint32_t LoadCommandIndex, const char *CmdName) {\n  if (Load.C.cmdsize < sizeof(MachO::dylinker_command))\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) + \" \" +\n                          CmdName + \" cmdsize too small\");\n  auto CommandOrErr = getStructOrErr<MachO::dylinker_command>(Obj, Load.Ptr);\n  if (!CommandOrErr)\n    return CommandOrErr.takeError();\n  MachO::dylinker_command D = CommandOrErr.get();\n  if (D.name < sizeof(MachO::dylinker_command))\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) + \" \" +\n                          CmdName + \" name.offset field too small, not past \"\n                          \"the end of the dylinker_command struct\");\n  if (D.name >= D.cmdsize)\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) + \" \" +\n                          CmdName + \" name.offset field extends past the end \"\n                          \"of the load command\");\n  // Make sure there is a null between the starting offset of the name and\n  // the end of the load command.\n  uint32_t i;\n  const char *P = (const char *)Load.Ptr;\n  for (i = D.name; i < D.cmdsize; i++)\n    if (P[i] == '\\0')\n      break;\n  if (i >= D.cmdsize)\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) + \" \" +\n                          CmdName + \" dyld name extends past the end of the \"\n                          \"load command\");\n  return Error::success();\n}\n\nstatic Error checkVersCommand(const MachOObjectFile &Obj,\n                              const MachOObjectFile::LoadCommandInfo &Load,\n                              uint32_t LoadCommandIndex,\n                              const char **LoadCmd, const char *CmdName) {\n  if (Load.C.cmdsize != sizeof(MachO::version_min_command))\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) + \" \" +\n                          CmdName + \" has incorrect cmdsize\");\n  if (*LoadCmd != nullptr)\n    return malformedError(\"more than one LC_VERSION_MIN_MACOSX, \"\n                          \"LC_VERSION_MIN_IPHONEOS, LC_VERSION_MIN_TVOS or \"\n                          \"LC_VERSION_MIN_WATCHOS command\");\n  *LoadCmd = Load.Ptr;\n  return Error::success();\n}\n\nstatic Error checkNoteCommand(const MachOObjectFile &Obj,\n                              const MachOObjectFile::LoadCommandInfo &Load,\n                              uint32_t LoadCommandIndex,\n                              std::list<MachOElement> &Elements) {\n  if (Load.C.cmdsize != sizeof(MachO::note_command))\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                          \" LC_NOTE has incorrect cmdsize\");\n  auto NoteCmdOrErr = getStructOrErr<MachO::note_command>(Obj, Load.Ptr);\n  if (!NoteCmdOrErr)\n    return NoteCmdOrErr.takeError();\n  MachO::note_command Nt = NoteCmdOrErr.get();\n  uint64_t FileSize = Obj.getData().size();\n  if (Nt.offset > FileSize)\n    return malformedError(\"offset field of LC_NOTE command \" +\n                          Twine(LoadCommandIndex) + \" extends \"\n                          \"past the end of the file\");\n  uint64_t BigSize = Nt.offset;\n  BigSize += Nt.size;\n  if (BigSize > FileSize)\n    return malformedError(\"size field plus offset field of LC_NOTE command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  if (Error Err = checkOverlappingElement(Elements, Nt.offset, Nt.size,\n                                          \"LC_NOTE data\"))\n    return Err;\n  return Error::success();\n}\n\nstatic Error\nparseBuildVersionCommand(const MachOObjectFile &Obj,\n                         const MachOObjectFile::LoadCommandInfo &Load,\n                         SmallVectorImpl<const char*> &BuildTools,\n                         uint32_t LoadCommandIndex) {\n  auto BVCOrErr =\n    getStructOrErr<MachO::build_version_command>(Obj, Load.Ptr);\n  if (!BVCOrErr)\n    return BVCOrErr.takeError();\n  MachO::build_version_command BVC = BVCOrErr.get();\n  if (Load.C.cmdsize !=\n      sizeof(MachO::build_version_command) +\n          BVC.ntools * sizeof(MachO::build_tool_version))\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                          \" LC_BUILD_VERSION_COMMAND has incorrect cmdsize\");\n\n  auto Start = Load.Ptr + sizeof(MachO::build_version_command);\n  BuildTools.resize(BVC.ntools);\n  for (unsigned i = 0; i < BVC.ntools; ++i)\n    BuildTools[i] = Start + i * sizeof(MachO::build_tool_version);\n\n  return Error::success();\n}\n\nstatic Error checkRpathCommand(const MachOObjectFile &Obj,\n                               const MachOObjectFile::LoadCommandInfo &Load,\n                               uint32_t LoadCommandIndex) {\n  if (Load.C.cmdsize < sizeof(MachO::rpath_command))\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                          \" LC_RPATH cmdsize too small\");\n  auto ROrErr = getStructOrErr<MachO::rpath_command>(Obj, Load.Ptr);\n  if (!ROrErr)\n    return ROrErr.takeError();\n  MachO::rpath_command R = ROrErr.get();\n  if (R.path < sizeof(MachO::rpath_command))\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                          \" LC_RPATH path.offset field too small, not past \"\n                          \"the end of the rpath_command struct\");\n  if (R.path >= R.cmdsize)\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                          \" LC_RPATH path.offset field extends past the end \"\n                          \"of the load command\");\n  // Make sure there is a null between the starting offset of the path and\n  // the end of the load command.\n  uint32_t i;\n  const char *P = (const char *)Load.Ptr;\n  for (i = R.path; i < R.cmdsize; i++)\n    if (P[i] == '\\0')\n      break;\n  if (i >= R.cmdsize)\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                          \" LC_RPATH library name extends past the end of the \"\n                          \"load command\");\n  return Error::success();\n}\n\nstatic Error checkEncryptCommand(const MachOObjectFile &Obj,\n                                 const MachOObjectFile::LoadCommandInfo &Load,\n                                 uint32_t LoadCommandIndex,\n                                 uint64_t cryptoff, uint64_t cryptsize,\n                                 const char **LoadCmd, const char *CmdName) {\n  if (*LoadCmd != nullptr)\n    return malformedError(\"more than one LC_ENCRYPTION_INFO and or \"\n                          \"LC_ENCRYPTION_INFO_64 command\");\n  uint64_t FileSize = Obj.getData().size();\n  if (cryptoff > FileSize)\n    return malformedError(\"cryptoff field of \" + Twine(CmdName) +\n                          \" command \" + Twine(LoadCommandIndex) + \" extends \"\n                          \"past the end of the file\");\n  uint64_t BigSize = cryptoff;\n  BigSize += cryptsize;\n  if (BigSize > FileSize)\n    return malformedError(\"cryptoff field plus cryptsize field of \" +\n                          Twine(CmdName) + \" command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  *LoadCmd = Load.Ptr;\n  return Error::success();\n}\n\nstatic Error checkLinkerOptCommand(const MachOObjectFile &Obj,\n                                   const MachOObjectFile::LoadCommandInfo &Load,\n                                   uint32_t LoadCommandIndex) {\n  if (Load.C.cmdsize < sizeof(MachO::linker_option_command))\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                          \" LC_LINKER_OPTION cmdsize too small\");\n  auto LinkOptionOrErr =\n    getStructOrErr<MachO::linker_option_command>(Obj, Load.Ptr);\n  if (!LinkOptionOrErr)\n    return LinkOptionOrErr.takeError();\n  MachO::linker_option_command L = LinkOptionOrErr.get();\n  // Make sure the count of strings is correct.\n  const char *string = (const char *)Load.Ptr +\n                       sizeof(struct MachO::linker_option_command);\n  uint32_t left = L.cmdsize - sizeof(struct MachO::linker_option_command);\n  uint32_t i = 0;\n  while (left > 0) {\n    while (*string == '\\0' && left > 0) {\n      string++;\n      left--;\n    }\n    if (left > 0) {\n      i++;\n      uint32_t NullPos = StringRef(string, left).find('\\0');\n      if (0xffffffff == NullPos)\n        return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                              \" LC_LINKER_OPTION string #\" + Twine(i) +\n                              \" is not NULL terminated\");\n      uint32_t len = std::min(NullPos, left) + 1;\n      string += len;\n      left -= len;\n    }\n  }\n  if (L.count != i)\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                          \" LC_LINKER_OPTION string count \" + Twine(L.count) +\n                          \" does not match number of strings\");\n  return Error::success();\n}\n\nstatic Error checkSubCommand(const MachOObjectFile &Obj,\n                             const MachOObjectFile::LoadCommandInfo &Load,\n                             uint32_t LoadCommandIndex, const char *CmdName,\n                             size_t SizeOfCmd, const char *CmdStructName,\n                             uint32_t PathOffset, const char *PathFieldName) {\n  if (PathOffset < SizeOfCmd)\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) + \" \" +\n                          CmdName + \" \" + PathFieldName + \".offset field too \"\n                          \"small, not past the end of the \" + CmdStructName);\n  if (PathOffset >= Load.C.cmdsize)\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) + \" \" +\n                          CmdName + \" \" + PathFieldName + \".offset field \"\n                          \"extends past the end of the load command\");\n  // Make sure there is a null between the starting offset of the path and\n  // the end of the load command.\n  uint32_t i;\n  const char *P = (const char *)Load.Ptr;\n  for (i = PathOffset; i < Load.C.cmdsize; i++)\n    if (P[i] == '\\0')\n      break;\n  if (i >= Load.C.cmdsize)\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) + \" \" +\n                          CmdName + \" \" + PathFieldName + \" name extends past \"\n                          \"the end of the load command\");\n  return Error::success();\n}\n\nstatic Error checkThreadCommand(const MachOObjectFile &Obj,\n                                const MachOObjectFile::LoadCommandInfo &Load,\n                                uint32_t LoadCommandIndex,\n                                const char *CmdName) {\n  if (Load.C.cmdsize < sizeof(MachO::thread_command))\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                          CmdName + \" cmdsize too small\");\n  auto ThreadCommandOrErr =\n    getStructOrErr<MachO::thread_command>(Obj, Load.Ptr);\n  if (!ThreadCommandOrErr)\n    return ThreadCommandOrErr.takeError();\n  MachO::thread_command T = ThreadCommandOrErr.get();\n  const char *state = Load.Ptr + sizeof(MachO::thread_command);\n  const char *end = Load.Ptr + T.cmdsize;\n  uint32_t nflavor = 0;\n  uint32_t cputype = getCPUType(Obj);\n  while (state < end) {\n    if(state + sizeof(uint32_t) > end)\n      return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                            \"flavor in \" + CmdName + \" extends past end of \"\n                            \"command\");\n    uint32_t flavor;\n    memcpy(&flavor, state, sizeof(uint32_t));\n    if (Obj.isLittleEndian() != sys::IsLittleEndianHost)\n      sys::swapByteOrder(flavor);\n    state += sizeof(uint32_t);\n\n    if(state + sizeof(uint32_t) > end)\n      return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                            \" count in \" + CmdName + \" extends past end of \"\n                            \"command\");\n    uint32_t count;\n    memcpy(&count, state, sizeof(uint32_t));\n    if (Obj.isLittleEndian() != sys::IsLittleEndianHost)\n      sys::swapByteOrder(count);\n    state += sizeof(uint32_t);\n\n    if (cputype == MachO::CPU_TYPE_I386) {\n      if (flavor == MachO::x86_THREAD_STATE32) {\n        if (count != MachO::x86_THREAD_STATE32_COUNT)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" count not x86_THREAD_STATE32_COUNT for \"\n                                \"flavor number \" + Twine(nflavor) + \" which is \"\n                                \"a x86_THREAD_STATE32 flavor in \" + CmdName +\n                                \" command\");\n        if (state + sizeof(MachO::x86_thread_state32_t) > end)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" x86_THREAD_STATE32 extends past end of \"\n                                \"command in \" + CmdName + \" command\");\n        state += sizeof(MachO::x86_thread_state32_t);\n      } else {\n        return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                              \" unknown flavor (\" + Twine(flavor) + \") for \"\n                              \"flavor number \" + Twine(nflavor) + \" in \" +\n                              CmdName + \" command\");\n      }\n    } else if (cputype == MachO::CPU_TYPE_X86_64) {\n      if (flavor == MachO::x86_THREAD_STATE) {\n        if (count != MachO::x86_THREAD_STATE_COUNT)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" count not x86_THREAD_STATE_COUNT for \"\n                                \"flavor number \" + Twine(nflavor) + \" which is \"\n                                \"a x86_THREAD_STATE flavor in \" + CmdName +\n                                \" command\");\n        if (state + sizeof(MachO::x86_thread_state_t) > end)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" x86_THREAD_STATE extends past end of \"\n                                \"command in \" + CmdName + \" command\");\n        state += sizeof(MachO::x86_thread_state_t);\n      } else if (flavor == MachO::x86_FLOAT_STATE) {\n        if (count != MachO::x86_FLOAT_STATE_COUNT)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" count not x86_FLOAT_STATE_COUNT for \"\n                                \"flavor number \" + Twine(nflavor) + \" which is \"\n                                \"a x86_FLOAT_STATE flavor in \" + CmdName +\n                                \" command\");\n        if (state + sizeof(MachO::x86_float_state_t) > end)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" x86_FLOAT_STATE extends past end of \"\n                                \"command in \" + CmdName + \" command\");\n        state += sizeof(MachO::x86_float_state_t);\n      } else if (flavor == MachO::x86_EXCEPTION_STATE) {\n        if (count != MachO::x86_EXCEPTION_STATE_COUNT)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" count not x86_EXCEPTION_STATE_COUNT for \"\n                                \"flavor number \" + Twine(nflavor) + \" which is \"\n                                \"a x86_EXCEPTION_STATE flavor in \" + CmdName +\n                                \" command\");\n        if (state + sizeof(MachO::x86_exception_state_t) > end)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" x86_EXCEPTION_STATE extends past end of \"\n                                \"command in \" + CmdName + \" command\");\n        state += sizeof(MachO::x86_exception_state_t);\n      } else if (flavor == MachO::x86_THREAD_STATE64) {\n        if (count != MachO::x86_THREAD_STATE64_COUNT)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" count not x86_THREAD_STATE64_COUNT for \"\n                                \"flavor number \" + Twine(nflavor) + \" which is \"\n                                \"a x86_THREAD_STATE64 flavor in \" + CmdName +\n                                \" command\");\n        if (state + sizeof(MachO::x86_thread_state64_t) > end)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" x86_THREAD_STATE64 extends past end of \"\n                                \"command in \" + CmdName + \" command\");\n        state += sizeof(MachO::x86_thread_state64_t);\n      } else if (flavor == MachO::x86_EXCEPTION_STATE64) {\n        if (count != MachO::x86_EXCEPTION_STATE64_COUNT)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" count not x86_EXCEPTION_STATE64_COUNT for \"\n                                \"flavor number \" + Twine(nflavor) + \" which is \"\n                                \"a x86_EXCEPTION_STATE64 flavor in \" + CmdName +\n                                \" command\");\n        if (state + sizeof(MachO::x86_exception_state64_t) > end)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" x86_EXCEPTION_STATE64 extends past end of \"\n                                \"command in \" + CmdName + \" command\");\n        state += sizeof(MachO::x86_exception_state64_t);\n      } else {\n        return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                              \" unknown flavor (\" + Twine(flavor) + \") for \"\n                              \"flavor number \" + Twine(nflavor) + \" in \" +\n                              CmdName + \" command\");\n      }\n    } else if (cputype == MachO::CPU_TYPE_ARM) {\n      if (flavor == MachO::ARM_THREAD_STATE) {\n        if (count != MachO::ARM_THREAD_STATE_COUNT)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" count not ARM_THREAD_STATE_COUNT for \"\n                                \"flavor number \" + Twine(nflavor) + \" which is \"\n                                \"a ARM_THREAD_STATE flavor in \" + CmdName +\n                                \" command\");\n        if (state + sizeof(MachO::arm_thread_state32_t) > end)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" ARM_THREAD_STATE extends past end of \"\n                                \"command in \" + CmdName + \" command\");\n        state += sizeof(MachO::arm_thread_state32_t);\n      } else {\n        return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                              \" unknown flavor (\" + Twine(flavor) + \") for \"\n                              \"flavor number \" + Twine(nflavor) + \" in \" +\n                              CmdName + \" command\");\n      }\n    } else if (cputype == MachO::CPU_TYPE_ARM64 ||\n               cputype == MachO::CPU_TYPE_ARM64_32) {\n      if (flavor == MachO::ARM_THREAD_STATE64) {\n        if (count != MachO::ARM_THREAD_STATE64_COUNT)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" count not ARM_THREAD_STATE64_COUNT for \"\n                                \"flavor number \" + Twine(nflavor) + \" which is \"\n                                \"a ARM_THREAD_STATE64 flavor in \" + CmdName +\n                                \" command\");\n        if (state + sizeof(MachO::arm_thread_state64_t) > end)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" ARM_THREAD_STATE64 extends past end of \"\n                                \"command in \" + CmdName + \" command\");\n        state += sizeof(MachO::arm_thread_state64_t);\n      } else {\n        return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                              \" unknown flavor (\" + Twine(flavor) + \") for \"\n                              \"flavor number \" + Twine(nflavor) + \" in \" +\n                              CmdName + \" command\");\n      }\n    } else if (cputype == MachO::CPU_TYPE_POWERPC) {\n      if (flavor == MachO::PPC_THREAD_STATE) {\n        if (count != MachO::PPC_THREAD_STATE_COUNT)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" count not PPC_THREAD_STATE_COUNT for \"\n                                \"flavor number \" + Twine(nflavor) + \" which is \"\n                                \"a PPC_THREAD_STATE flavor in \" + CmdName +\n                                \" command\");\n        if (state + sizeof(MachO::ppc_thread_state32_t) > end)\n          return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                                \" PPC_THREAD_STATE extends past end of \"\n                                \"command in \" + CmdName + \" command\");\n        state += sizeof(MachO::ppc_thread_state32_t);\n      } else {\n        return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                              \" unknown flavor (\" + Twine(flavor) + \") for \"\n                              \"flavor number \" + Twine(nflavor) + \" in \" +\n                              CmdName + \" command\");\n      }\n    } else {\n      return malformedError(\"unknown cputype (\" + Twine(cputype) + \") load \"\n                            \"command \" + Twine(LoadCommandIndex) + \" for \" +\n                            CmdName + \" command can't be checked\");\n    }\n    nflavor++;\n  }\n  return Error::success();\n}\n\nstatic Error checkTwoLevelHintsCommand(const MachOObjectFile &Obj,\n                                       const MachOObjectFile::LoadCommandInfo\n                                         &Load,\n                                       uint32_t LoadCommandIndex,\n                                       const char **LoadCmd,\n                                       std::list<MachOElement> &Elements) {\n  if (Load.C.cmdsize != sizeof(MachO::twolevel_hints_command))\n    return malformedError(\"load command \" + Twine(LoadCommandIndex) +\n                          \" LC_TWOLEVEL_HINTS has incorrect cmdsize\");\n  if (*LoadCmd != nullptr)\n    return malformedError(\"more than one LC_TWOLEVEL_HINTS command\");\n  auto HintsOrErr = getStructOrErr<MachO::twolevel_hints_command>(Obj, Load.Ptr);\n  if(!HintsOrErr)\n    return HintsOrErr.takeError();\n  MachO::twolevel_hints_command Hints = HintsOrErr.get();\n  uint64_t FileSize = Obj.getData().size();\n  if (Hints.offset > FileSize)\n    return malformedError(\"offset field of LC_TWOLEVEL_HINTS command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  uint64_t BigSize = Hints.nhints;\n  BigSize *= sizeof(MachO::twolevel_hint);\n  BigSize += Hints.offset;\n  if (BigSize > FileSize)\n    return malformedError(\"offset field plus nhints times sizeof(struct \"\n                          \"twolevel_hint) field of LC_TWOLEVEL_HINTS command \" +\n                          Twine(LoadCommandIndex) + \" extends past the end of \"\n                          \"the file\");\n  if (Error Err = checkOverlappingElement(Elements, Hints.offset, Hints.nhints *\n                                          sizeof(MachO::twolevel_hint),\n                                          \"two level hints\"))\n    return Err;\n  *LoadCmd = Load.Ptr;\n  return Error::success();\n}\n\n// Returns true if the libObject code does not support the load command and its\n// contents.  The cmd value it is treated as an unknown load command but with\n// an error message that says the cmd value is obsolete.\nstatic bool isLoadCommandObsolete(uint32_t cmd) {\n  if (cmd == MachO::LC_SYMSEG ||\n      cmd == MachO::LC_LOADFVMLIB ||\n      cmd == MachO::LC_IDFVMLIB ||\n      cmd == MachO::LC_IDENT ||\n      cmd == MachO::LC_FVMFILE ||\n      cmd == MachO::LC_PREPAGE ||\n      cmd == MachO::LC_PREBOUND_DYLIB ||\n      cmd == MachO::LC_TWOLEVEL_HINTS ||\n      cmd == MachO::LC_PREBIND_CKSUM)\n    return true;\n  return false;\n}\n\nExpected<std::unique_ptr<MachOObjectFile>>\nMachOObjectFile::create(MemoryBufferRef Object, bool IsLittleEndian,\n                        bool Is64Bits, uint32_t UniversalCputype,\n                        uint32_t UniversalIndex) {\n  Error Err = Error::success();\n  std::unique_ptr<MachOObjectFile> Obj(\n      new MachOObjectFile(std::move(Object), IsLittleEndian,\n                          Is64Bits, Err, UniversalCputype,\n                          UniversalIndex));\n  if (Err)\n    return std::move(Err);\n  return std::move(Obj);\n}\n\nMachOObjectFile::MachOObjectFile(MemoryBufferRef Object, bool IsLittleEndian,\n                                 bool Is64bits, Error &Err,\n                                 uint32_t UniversalCputype,\n                                 uint32_t UniversalIndex)\n    : ObjectFile(getMachOType(IsLittleEndian, Is64bits), Object) {\n  ErrorAsOutParameter ErrAsOutParam(&Err);\n  uint64_t SizeOfHeaders;\n  uint32_t cputype;\n  if (is64Bit()) {\n    parseHeader(*this, Header64, Err);\n    SizeOfHeaders = sizeof(MachO::mach_header_64);\n    cputype = Header64.cputype;\n  } else {\n    parseHeader(*this, Header, Err);\n    SizeOfHeaders = sizeof(MachO::mach_header);\n    cputype = Header.cputype;\n  }\n  if (Err)\n    return;\n  SizeOfHeaders += getHeader().sizeofcmds;\n  if (getData().data() + SizeOfHeaders > getData().end()) {\n    Err = malformedError(\"load commands extend past the end of the file\");\n    return;\n  }\n  if (UniversalCputype != 0 && cputype != UniversalCputype) {\n    Err = malformedError(\"universal header architecture: \" +\n                         Twine(UniversalIndex) + \"'s cputype does not match \"\n                         \"object file's mach header\");\n    return;\n  }\n  std::list<MachOElement> Elements;\n  Elements.push_back({0, SizeOfHeaders, \"Mach-O headers\"});\n\n  uint32_t LoadCommandCount = getHeader().ncmds;\n  LoadCommandInfo Load;\n  if (LoadCommandCount != 0) {\n    if (auto LoadOrErr = getFirstLoadCommandInfo(*this))\n      Load = *LoadOrErr;\n    else {\n      Err = LoadOrErr.takeError();\n      return;\n    }\n  }\n\n  const char *DyldIdLoadCmd = nullptr;\n  const char *FuncStartsLoadCmd = nullptr;\n  const char *SplitInfoLoadCmd = nullptr;\n  const char *CodeSignDrsLoadCmd = nullptr;\n  const char *CodeSignLoadCmd = nullptr;\n  const char *VersLoadCmd = nullptr;\n  const char *SourceLoadCmd = nullptr;\n  const char *EntryPointLoadCmd = nullptr;\n  const char *EncryptLoadCmd = nullptr;\n  const char *RoutinesLoadCmd = nullptr;\n  const char *UnixThreadLoadCmd = nullptr;\n  const char *TwoLevelHintsLoadCmd = nullptr;\n  for (unsigned I = 0; I < LoadCommandCount; ++I) {\n    if (is64Bit()) {\n      if (Load.C.cmdsize % 8 != 0) {\n        // We have a hack here to allow 64-bit Mach-O core files to have\n        // LC_THREAD commands that are only a multiple of 4 and not 8 to be\n        // allowed since the macOS kernel produces them.\n        if (getHeader().filetype != MachO::MH_CORE ||\n            Load.C.cmd != MachO::LC_THREAD || Load.C.cmdsize % 4) {\n          Err = malformedError(\"load command \" + Twine(I) + \" cmdsize not a \"\n                               \"multiple of 8\");\n          return;\n        }\n      }\n    } else {\n      if (Load.C.cmdsize % 4 != 0) {\n        Err = malformedError(\"load command \" + Twine(I) + \" cmdsize not a \"\n                             \"multiple of 4\");\n        return;\n      }\n    }\n    LoadCommands.push_back(Load);\n    if (Load.C.cmd == MachO::LC_SYMTAB) {\n      if ((Err = checkSymtabCommand(*this, Load, I, &SymtabLoadCmd, Elements)))\n        return;\n    } else if (Load.C.cmd == MachO::LC_DYSYMTAB) {\n      if ((Err = checkDysymtabCommand(*this, Load, I, &DysymtabLoadCmd,\n                                      Elements)))\n        return;\n    } else if (Load.C.cmd == MachO::LC_DATA_IN_CODE) {\n      if ((Err = checkLinkeditDataCommand(*this, Load, I, &DataInCodeLoadCmd,\n                                          \"LC_DATA_IN_CODE\", Elements,\n                                          \"data in code info\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_LINKER_OPTIMIZATION_HINT) {\n      if ((Err = checkLinkeditDataCommand(*this, Load, I, &LinkOptHintsLoadCmd,\n                                          \"LC_LINKER_OPTIMIZATION_HINT\",\n                                          Elements, \"linker optimization \"\n                                          \"hints\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_FUNCTION_STARTS) {\n      if ((Err = checkLinkeditDataCommand(*this, Load, I, &FuncStartsLoadCmd,\n                                          \"LC_FUNCTION_STARTS\", Elements,\n                                          \"function starts data\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_SEGMENT_SPLIT_INFO) {\n      if ((Err = checkLinkeditDataCommand(*this, Load, I, &SplitInfoLoadCmd,\n                                          \"LC_SEGMENT_SPLIT_INFO\", Elements,\n                                          \"split info data\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_DYLIB_CODE_SIGN_DRS) {\n      if ((Err = checkLinkeditDataCommand(*this, Load, I, &CodeSignDrsLoadCmd,\n                                          \"LC_DYLIB_CODE_SIGN_DRS\", Elements,\n                                          \"code signing RDs data\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_CODE_SIGNATURE) {\n      if ((Err = checkLinkeditDataCommand(*this, Load, I, &CodeSignLoadCmd,\n                                          \"LC_CODE_SIGNATURE\", Elements,\n                                          \"code signature data\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_DYLD_INFO) {\n      if ((Err = checkDyldInfoCommand(*this, Load, I, &DyldInfoLoadCmd,\n                                      \"LC_DYLD_INFO\", Elements)))\n        return;\n    } else if (Load.C.cmd == MachO::LC_DYLD_INFO_ONLY) {\n      if ((Err = checkDyldInfoCommand(*this, Load, I, &DyldInfoLoadCmd,\n                                      \"LC_DYLD_INFO_ONLY\", Elements)))\n        return;\n    } else if (Load.C.cmd == MachO::LC_UUID) {\n      if (Load.C.cmdsize != sizeof(MachO::uuid_command)) {\n        Err = malformedError(\"LC_UUID command \" + Twine(I) + \" has incorrect \"\n                             \"cmdsize\");\n        return;\n      }\n      if (UuidLoadCmd) {\n        Err = malformedError(\"more than one LC_UUID command\");\n        return;\n      }\n      UuidLoadCmd = Load.Ptr;\n    } else if (Load.C.cmd == MachO::LC_SEGMENT_64) {\n      if ((Err = parseSegmentLoadCommand<MachO::segment_command_64,\n                                         MachO::section_64>(\n                   *this, Load, Sections, HasPageZeroSegment, I,\n                   \"LC_SEGMENT_64\", SizeOfHeaders, Elements)))\n        return;\n    } else if (Load.C.cmd == MachO::LC_SEGMENT) {\n      if ((Err = parseSegmentLoadCommand<MachO::segment_command,\n                                         MachO::section>(\n                   *this, Load, Sections, HasPageZeroSegment, I,\n                   \"LC_SEGMENT\", SizeOfHeaders, Elements)))\n        return;\n    } else if (Load.C.cmd == MachO::LC_ID_DYLIB) {\n      if ((Err = checkDylibIdCommand(*this, Load, I, &DyldIdLoadCmd)))\n        return;\n    } else if (Load.C.cmd == MachO::LC_LOAD_DYLIB) {\n      if ((Err = checkDylibCommand(*this, Load, I, \"LC_LOAD_DYLIB\")))\n        return;\n      Libraries.push_back(Load.Ptr);\n    } else if (Load.C.cmd == MachO::LC_LOAD_WEAK_DYLIB) {\n      if ((Err = checkDylibCommand(*this, Load, I, \"LC_LOAD_WEAK_DYLIB\")))\n        return;\n      Libraries.push_back(Load.Ptr);\n    } else if (Load.C.cmd == MachO::LC_LAZY_LOAD_DYLIB) {\n      if ((Err = checkDylibCommand(*this, Load, I, \"LC_LAZY_LOAD_DYLIB\")))\n        return;\n      Libraries.push_back(Load.Ptr);\n    } else if (Load.C.cmd == MachO::LC_REEXPORT_DYLIB) {\n      if ((Err = checkDylibCommand(*this, Load, I, \"LC_REEXPORT_DYLIB\")))\n        return;\n      Libraries.push_back(Load.Ptr);\n    } else if (Load.C.cmd == MachO::LC_LOAD_UPWARD_DYLIB) {\n      if ((Err = checkDylibCommand(*this, Load, I, \"LC_LOAD_UPWARD_DYLIB\")))\n        return;\n      Libraries.push_back(Load.Ptr);\n    } else if (Load.C.cmd == MachO::LC_ID_DYLINKER) {\n      if ((Err = checkDyldCommand(*this, Load, I, \"LC_ID_DYLINKER\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_LOAD_DYLINKER) {\n      if ((Err = checkDyldCommand(*this, Load, I, \"LC_LOAD_DYLINKER\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_DYLD_ENVIRONMENT) {\n      if ((Err = checkDyldCommand(*this, Load, I, \"LC_DYLD_ENVIRONMENT\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_VERSION_MIN_MACOSX) {\n      if ((Err = checkVersCommand(*this, Load, I, &VersLoadCmd,\n                                  \"LC_VERSION_MIN_MACOSX\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_VERSION_MIN_IPHONEOS) {\n      if ((Err = checkVersCommand(*this, Load, I, &VersLoadCmd,\n                                  \"LC_VERSION_MIN_IPHONEOS\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_VERSION_MIN_TVOS) {\n      if ((Err = checkVersCommand(*this, Load, I, &VersLoadCmd,\n                                  \"LC_VERSION_MIN_TVOS\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_VERSION_MIN_WATCHOS) {\n      if ((Err = checkVersCommand(*this, Load, I, &VersLoadCmd,\n                                  \"LC_VERSION_MIN_WATCHOS\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_NOTE) {\n      if ((Err = checkNoteCommand(*this, Load, I, Elements)))\n        return;\n    } else if (Load.C.cmd == MachO::LC_BUILD_VERSION) {\n      if ((Err = parseBuildVersionCommand(*this, Load, BuildTools, I)))\n        return;\n    } else if (Load.C.cmd == MachO::LC_RPATH) {\n      if ((Err = checkRpathCommand(*this, Load, I)))\n        return;\n    } else if (Load.C.cmd == MachO::LC_SOURCE_VERSION) {\n      if (Load.C.cmdsize != sizeof(MachO::source_version_command)) {\n        Err = malformedError(\"LC_SOURCE_VERSION command \" + Twine(I) +\n                             \" has incorrect cmdsize\");\n        return;\n      }\n      if (SourceLoadCmd) {\n        Err = malformedError(\"more than one LC_SOURCE_VERSION command\");\n        return;\n      }\n      SourceLoadCmd = Load.Ptr;\n    } else if (Load.C.cmd == MachO::LC_MAIN) {\n      if (Load.C.cmdsize != sizeof(MachO::entry_point_command)) {\n        Err = malformedError(\"LC_MAIN command \" + Twine(I) +\n                             \" has incorrect cmdsize\");\n        return;\n      }\n      if (EntryPointLoadCmd) {\n        Err = malformedError(\"more than one LC_MAIN command\");\n        return;\n      }\n      EntryPointLoadCmd = Load.Ptr;\n    } else if (Load.C.cmd == MachO::LC_ENCRYPTION_INFO) {\n      if (Load.C.cmdsize != sizeof(MachO::encryption_info_command)) {\n        Err = malformedError(\"LC_ENCRYPTION_INFO command \" + Twine(I) +\n                             \" has incorrect cmdsize\");\n        return;\n      }\n      MachO::encryption_info_command E =\n        getStruct<MachO::encryption_info_command>(*this, Load.Ptr);\n      if ((Err = checkEncryptCommand(*this, Load, I, E.cryptoff, E.cryptsize,\n                                     &EncryptLoadCmd, \"LC_ENCRYPTION_INFO\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_ENCRYPTION_INFO_64) {\n      if (Load.C.cmdsize != sizeof(MachO::encryption_info_command_64)) {\n        Err = malformedError(\"LC_ENCRYPTION_INFO_64 command \" + Twine(I) +\n                             \" has incorrect cmdsize\");\n        return;\n      }\n      MachO::encryption_info_command_64 E =\n        getStruct<MachO::encryption_info_command_64>(*this, Load.Ptr);\n      if ((Err = checkEncryptCommand(*this, Load, I, E.cryptoff, E.cryptsize,\n                                     &EncryptLoadCmd, \"LC_ENCRYPTION_INFO_64\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_LINKER_OPTION) {\n      if ((Err = checkLinkerOptCommand(*this, Load, I)))\n        return;\n    } else if (Load.C.cmd == MachO::LC_SUB_FRAMEWORK) {\n      if (Load.C.cmdsize < sizeof(MachO::sub_framework_command)) {\n        Err =  malformedError(\"load command \" + Twine(I) +\n                              \" LC_SUB_FRAMEWORK cmdsize too small\");\n        return;\n      }\n      MachO::sub_framework_command S =\n        getStruct<MachO::sub_framework_command>(*this, Load.Ptr);\n      if ((Err = checkSubCommand(*this, Load, I, \"LC_SUB_FRAMEWORK\",\n                                 sizeof(MachO::sub_framework_command),\n                                 \"sub_framework_command\", S.umbrella,\n                                 \"umbrella\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_SUB_UMBRELLA) {\n      if (Load.C.cmdsize < sizeof(MachO::sub_umbrella_command)) {\n        Err =  malformedError(\"load command \" + Twine(I) +\n                              \" LC_SUB_UMBRELLA cmdsize too small\");\n        return;\n      }\n      MachO::sub_umbrella_command S =\n        getStruct<MachO::sub_umbrella_command>(*this, Load.Ptr);\n      if ((Err = checkSubCommand(*this, Load, I, \"LC_SUB_UMBRELLA\",\n                                 sizeof(MachO::sub_umbrella_command),\n                                 \"sub_umbrella_command\", S.sub_umbrella,\n                                 \"sub_umbrella\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_SUB_LIBRARY) {\n      if (Load.C.cmdsize < sizeof(MachO::sub_library_command)) {\n        Err =  malformedError(\"load command \" + Twine(I) +\n                              \" LC_SUB_LIBRARY cmdsize too small\");\n        return;\n      }\n      MachO::sub_library_command S =\n        getStruct<MachO::sub_library_command>(*this, Load.Ptr);\n      if ((Err = checkSubCommand(*this, Load, I, \"LC_SUB_LIBRARY\",\n                                 sizeof(MachO::sub_library_command),\n                                 \"sub_library_command\", S.sub_library,\n                                 \"sub_library\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_SUB_CLIENT) {\n      if (Load.C.cmdsize < sizeof(MachO::sub_client_command)) {\n        Err =  malformedError(\"load command \" + Twine(I) +\n                              \" LC_SUB_CLIENT cmdsize too small\");\n        return;\n      }\n      MachO::sub_client_command S =\n        getStruct<MachO::sub_client_command>(*this, Load.Ptr);\n      if ((Err = checkSubCommand(*this, Load, I, \"LC_SUB_CLIENT\",\n                                 sizeof(MachO::sub_client_command),\n                                 \"sub_client_command\", S.client, \"client\")))\n        return;\n    } else if (Load.C.cmd == MachO::LC_ROUTINES) {\n      if (Load.C.cmdsize != sizeof(MachO::routines_command)) {\n        Err = malformedError(\"LC_ROUTINES command \" + Twine(I) +\n                             \" has incorrect cmdsize\");\n        return;\n      }\n      if (RoutinesLoadCmd) {\n        Err = malformedError(\"more than one LC_ROUTINES and or LC_ROUTINES_64 \"\n                             \"command\");\n        return;\n      }\n      RoutinesLoadCmd = Load.Ptr;\n    } else if (Load.C.cmd == MachO::LC_ROUTINES_64) {\n      if (Load.C.cmdsize != sizeof(MachO::routines_command_64)) {\n        Err = malformedError(\"LC_ROUTINES_64 command \" + Twine(I) +\n                             \" has incorrect cmdsize\");\n        return;\n      }\n      if (RoutinesLoadCmd) {\n        Err = malformedError(\"more than one LC_ROUTINES_64 and or LC_ROUTINES \"\n                             \"command\");\n        return;\n      }\n      RoutinesLoadCmd = Load.Ptr;\n    } else if (Load.C.cmd == MachO::LC_UNIXTHREAD) {\n      if ((Err = checkThreadCommand(*this, Load, I, \"LC_UNIXTHREAD\")))\n        return;\n      if (UnixThreadLoadCmd) {\n        Err = malformedError(\"more than one LC_UNIXTHREAD command\");\n        return;\n      }\n      UnixThreadLoadCmd = Load.Ptr;\n    } else if (Load.C.cmd == MachO::LC_THREAD) {\n      if ((Err = checkThreadCommand(*this, Load, I, \"LC_THREAD\")))\n        return;\n    // Note: LC_TWOLEVEL_HINTS is really obsolete and is not supported.\n    } else if (Load.C.cmd == MachO::LC_TWOLEVEL_HINTS) {\n       if ((Err = checkTwoLevelHintsCommand(*this, Load, I,\n                                            &TwoLevelHintsLoadCmd, Elements)))\n         return;\n    } else if (Load.C.cmd == MachO::LC_IDENT) {\n      // Note: LC_IDENT is ignored.\n      continue;\n    } else if (isLoadCommandObsolete(Load.C.cmd)) {\n      Err = malformedError(\"load command \" + Twine(I) + \" for cmd value of: \" +\n                           Twine(Load.C.cmd) + \" is obsolete and not \"\n                           \"supported\");\n      return;\n    }\n    // TODO: generate a error for unknown load commands by default.  But still\n    // need work out an approach to allow or not allow unknown values like this\n    // as an option for some uses like lldb.\n    if (I < LoadCommandCount - 1) {\n      if (auto LoadOrErr = getNextLoadCommandInfo(*this, I, Load))\n        Load = *LoadOrErr;\n      else {\n        Err = LoadOrErr.takeError();\n        return;\n      }\n    }\n  }\n  if (!SymtabLoadCmd) {\n    if (DysymtabLoadCmd) {\n      Err = malformedError(\"contains LC_DYSYMTAB load command without a \"\n                           \"LC_SYMTAB load command\");\n      return;\n    }\n  } else if (DysymtabLoadCmd) {\n    MachO::symtab_command Symtab =\n      getStruct<MachO::symtab_command>(*this, SymtabLoadCmd);\n    MachO::dysymtab_command Dysymtab =\n      getStruct<MachO::dysymtab_command>(*this, DysymtabLoadCmd);\n    if (Dysymtab.nlocalsym != 0 && Dysymtab.ilocalsym > Symtab.nsyms) {\n      Err = malformedError(\"ilocalsym in LC_DYSYMTAB load command \"\n                           \"extends past the end of the symbol table\");\n      return;\n    }\n    uint64_t BigSize = Dysymtab.ilocalsym;\n    BigSize += Dysymtab.nlocalsym;\n    if (Dysymtab.nlocalsym != 0 && BigSize > Symtab.nsyms) {\n      Err = malformedError(\"ilocalsym plus nlocalsym in LC_DYSYMTAB load \"\n                           \"command extends past the end of the symbol table\");\n      return;\n    }\n    if (Dysymtab.nextdefsym != 0 && Dysymtab.iextdefsym > Symtab.nsyms) {\n      Err = malformedError(\"iextdefsym in LC_DYSYMTAB load command \"\n                           \"extends past the end of the symbol table\");\n      return;\n    }\n    BigSize = Dysymtab.iextdefsym;\n    BigSize += Dysymtab.nextdefsym;\n    if (Dysymtab.nextdefsym != 0 && BigSize > Symtab.nsyms) {\n      Err = malformedError(\"iextdefsym plus nextdefsym in LC_DYSYMTAB \"\n                           \"load command extends past the end of the symbol \"\n                           \"table\");\n      return;\n    }\n    if (Dysymtab.nundefsym != 0 && Dysymtab.iundefsym > Symtab.nsyms) {\n      Err = malformedError(\"iundefsym in LC_DYSYMTAB load command \"\n                           \"extends past the end of the symbol table\");\n      return;\n    }\n    BigSize = Dysymtab.iundefsym;\n    BigSize += Dysymtab.nundefsym;\n    if (Dysymtab.nundefsym != 0 && BigSize > Symtab.nsyms) {\n      Err = malformedError(\"iundefsym plus nundefsym in LC_DYSYMTAB load \"\n                           \" command extends past the end of the symbol table\");\n      return;\n    }\n  }\n  if ((getHeader().filetype == MachO::MH_DYLIB ||\n       getHeader().filetype == MachO::MH_DYLIB_STUB) &&\n       DyldIdLoadCmd == nullptr) {\n    Err = malformedError(\"no LC_ID_DYLIB load command in dynamic library \"\n                         \"filetype\");\n    return;\n  }\n  assert(LoadCommands.size() == LoadCommandCount);\n\n  Err = Error::success();\n}\n\nError MachOObjectFile::checkSymbolTable() const {\n  uint32_t Flags = 0;\n  if (is64Bit()) {\n    MachO::mach_header_64 H_64 = MachOObjectFile::getHeader64();\n    Flags = H_64.flags;\n  } else {\n    MachO::mach_header H = MachOObjectFile::getHeader();\n    Flags = H.flags;\n  }\n  uint8_t NType = 0;\n  uint8_t NSect = 0;\n  uint16_t NDesc = 0;\n  uint32_t NStrx = 0;\n  uint64_t NValue = 0;\n  uint32_t SymbolIndex = 0;\n  MachO::symtab_command S = getSymtabLoadCommand();\n  for (const SymbolRef &Symbol : symbols()) {\n    DataRefImpl SymDRI = Symbol.getRawDataRefImpl();\n    if (is64Bit()) {\n      MachO::nlist_64 STE_64 = getSymbol64TableEntry(SymDRI);\n      NType = STE_64.n_type;\n      NSect = STE_64.n_sect;\n      NDesc = STE_64.n_desc;\n      NStrx = STE_64.n_strx;\n      NValue = STE_64.n_value;\n    } else {\n      MachO::nlist STE = getSymbolTableEntry(SymDRI);\n      NType = STE.n_type;\n      NSect = STE.n_sect;\n      NDesc = STE.n_desc;\n      NStrx = STE.n_strx;\n      NValue = STE.n_value;\n    }\n    if ((NType & MachO::N_STAB) == 0) {\n      if ((NType & MachO::N_TYPE) == MachO::N_SECT) {\n        if (NSect == 0 || NSect > Sections.size())\n          return malformedError(\"bad section index: \" + Twine((int)NSect) +\n                                \" for symbol at index \" + Twine(SymbolIndex));\n      }\n      if ((NType & MachO::N_TYPE) == MachO::N_INDR) {\n        if (NValue >= S.strsize)\n          return malformedError(\"bad n_value: \" + Twine((int)NValue) + \" past \"\n                                \"the end of string table, for N_INDR symbol at \"\n                                \"index \" + Twine(SymbolIndex));\n      }\n      if ((Flags & MachO::MH_TWOLEVEL) == MachO::MH_TWOLEVEL &&\n          (((NType & MachO::N_TYPE) == MachO::N_UNDF && NValue == 0) ||\n           (NType & MachO::N_TYPE) == MachO::N_PBUD)) {\n            uint32_t LibraryOrdinal = MachO::GET_LIBRARY_ORDINAL(NDesc);\n            if (LibraryOrdinal != 0 &&\n                LibraryOrdinal != MachO::EXECUTABLE_ORDINAL &&\n                LibraryOrdinal != MachO::DYNAMIC_LOOKUP_ORDINAL &&\n                LibraryOrdinal - 1 >= Libraries.size() ) {\n              return malformedError(\"bad library ordinal: \" + Twine(LibraryOrdinal) +\n                                    \" for symbol at index \" + Twine(SymbolIndex));\n            }\n          }\n    }\n    if (NStrx >= S.strsize)\n      return malformedError(\"bad string table index: \" + Twine((int)NStrx) +\n                            \" past the end of string table, for symbol at \"\n                            \"index \" + Twine(SymbolIndex));\n    SymbolIndex++;\n  }\n  return Error::success();\n}\n\nvoid MachOObjectFile::moveSymbolNext(DataRefImpl &Symb) const {\n  unsigned SymbolTableEntrySize = is64Bit() ?\n    sizeof(MachO::nlist_64) :\n    sizeof(MachO::nlist);\n  Symb.p += SymbolTableEntrySize;\n}\n\nExpected<StringRef> MachOObjectFile::getSymbolName(DataRefImpl Symb) const {\n  StringRef StringTable = getStringTableData();\n  MachO::nlist_base Entry = getSymbolTableEntryBase(*this, Symb);\n  if (Entry.n_strx == 0)\n    // A n_strx value of 0 indicates that no name is associated with a\n    // particular symbol table entry.\n    return StringRef();\n  const char *Start = &StringTable.data()[Entry.n_strx];\n  if (Start < getData().begin() || Start >= getData().end()) {\n    return malformedError(\"bad string index: \" + Twine(Entry.n_strx) +\n                          \" for symbol at index \" + Twine(getSymbolIndex(Symb)));\n  }\n  return StringRef(Start);\n}\n\nunsigned MachOObjectFile::getSectionType(SectionRef Sec) const {\n  DataRefImpl DRI = Sec.getRawDataRefImpl();\n  uint32_t Flags = getSectionFlags(*this, DRI);\n  return Flags & MachO::SECTION_TYPE;\n}\n\nuint64_t MachOObjectFile::getNValue(DataRefImpl Sym) const {\n  if (is64Bit()) {\n    MachO::nlist_64 Entry = getSymbol64TableEntry(Sym);\n    return Entry.n_value;\n  }\n  MachO::nlist Entry = getSymbolTableEntry(Sym);\n  return Entry.n_value;\n}\n\n// getIndirectName() returns the name of the alias'ed symbol who's string table\n// index is in the n_value field.\nstd::error_code MachOObjectFile::getIndirectName(DataRefImpl Symb,\n                                                 StringRef &Res) const {\n  StringRef StringTable = getStringTableData();\n  MachO::nlist_base Entry = getSymbolTableEntryBase(*this, Symb);\n  if ((Entry.n_type & MachO::N_TYPE) != MachO::N_INDR)\n    return object_error::parse_failed;\n  uint64_t NValue = getNValue(Symb);\n  if (NValue >= StringTable.size())\n    return object_error::parse_failed;\n  const char *Start = &StringTable.data()[NValue];\n  Res = StringRef(Start);\n  return std::error_code();\n}\n\nuint64_t MachOObjectFile::getSymbolValueImpl(DataRefImpl Sym) const {\n  return getNValue(Sym);\n}\n\nExpected<uint64_t> MachOObjectFile::getSymbolAddress(DataRefImpl Sym) const {\n  return getSymbolValue(Sym);\n}\n\nuint32_t MachOObjectFile::getSymbolAlignment(DataRefImpl DRI) const {\n  uint32_t Flags = cantFail(getSymbolFlags(DRI));\n  if (Flags & SymbolRef::SF_Common) {\n    MachO::nlist_base Entry = getSymbolTableEntryBase(*this, DRI);\n    return 1 << MachO::GET_COMM_ALIGN(Entry.n_desc);\n  }\n  return 0;\n}\n\nuint64_t MachOObjectFile::getCommonSymbolSizeImpl(DataRefImpl DRI) const {\n  return getNValue(DRI);\n}\n\nExpected<SymbolRef::Type>\nMachOObjectFile::getSymbolType(DataRefImpl Symb) const {\n  MachO::nlist_base Entry = getSymbolTableEntryBase(*this, Symb);\n  uint8_t n_type = Entry.n_type;\n\n  // If this is a STAB debugging symbol, we can do nothing more.\n  if (n_type & MachO::N_STAB)\n    return SymbolRef::ST_Debug;\n\n  switch (n_type & MachO::N_TYPE) {\n    case MachO::N_UNDF :\n      return SymbolRef::ST_Unknown;\n    case MachO::N_SECT :\n      Expected<section_iterator> SecOrError = getSymbolSection(Symb);\n      if (!SecOrError)\n        return SecOrError.takeError();\n      section_iterator Sec = *SecOrError;\n      if (Sec->isData() || Sec->isBSS())\n        return SymbolRef::ST_Data;\n      return SymbolRef::ST_Function;\n  }\n  return SymbolRef::ST_Other;\n}\n\nExpected<uint32_t> MachOObjectFile::getSymbolFlags(DataRefImpl DRI) const {\n  MachO::nlist_base Entry = getSymbolTableEntryBase(*this, DRI);\n\n  uint8_t MachOType = Entry.n_type;\n  uint16_t MachOFlags = Entry.n_desc;\n\n  uint32_t Result = SymbolRef::SF_None;\n\n  if ((MachOType & MachO::N_TYPE) == MachO::N_INDR)\n    Result |= SymbolRef::SF_Indirect;\n\n  if (MachOType & MachO::N_STAB)\n    Result |= SymbolRef::SF_FormatSpecific;\n\n  if (MachOType & MachO::N_EXT) {\n    Result |= SymbolRef::SF_Global;\n    if ((MachOType & MachO::N_TYPE) == MachO::N_UNDF) {\n      if (getNValue(DRI))\n        Result |= SymbolRef::SF_Common;\n      else\n        Result |= SymbolRef::SF_Undefined;\n    }\n\n    if (!(MachOType & MachO::N_PEXT))\n      Result |= SymbolRef::SF_Exported;\n  }\n\n  if (MachOFlags & (MachO::N_WEAK_REF | MachO::N_WEAK_DEF))\n    Result |= SymbolRef::SF_Weak;\n\n  if (MachOFlags & (MachO::N_ARM_THUMB_DEF))\n    Result |= SymbolRef::SF_Thumb;\n\n  if ((MachOType & MachO::N_TYPE) == MachO::N_ABS)\n    Result |= SymbolRef::SF_Absolute;\n\n  return Result;\n}\n\nExpected<section_iterator>\nMachOObjectFile::getSymbolSection(DataRefImpl Symb) const {\n  MachO::nlist_base Entry = getSymbolTableEntryBase(*this, Symb);\n  uint8_t index = Entry.n_sect;\n\n  if (index == 0)\n    return section_end();\n  DataRefImpl DRI;\n  DRI.d.a = index - 1;\n  if (DRI.d.a >= Sections.size()){\n    return malformedError(\"bad section index: \" + Twine((int)index) +\n                          \" for symbol at index \" + Twine(getSymbolIndex(Symb)));\n  }\n  return section_iterator(SectionRef(DRI, this));\n}\n\nunsigned MachOObjectFile::getSymbolSectionID(SymbolRef Sym) const {\n  MachO::nlist_base Entry =\n      getSymbolTableEntryBase(*this, Sym.getRawDataRefImpl());\n  return Entry.n_sect - 1;\n}\n\nvoid MachOObjectFile::moveSectionNext(DataRefImpl &Sec) const {\n  Sec.d.a++;\n}\n\nExpected<StringRef> MachOObjectFile::getSectionName(DataRefImpl Sec) const {\n  ArrayRef<char> Raw = getSectionRawName(Sec);\n  return parseSegmentOrSectionName(Raw.data());\n}\n\nuint64_t MachOObjectFile::getSectionAddress(DataRefImpl Sec) const {\n  if (is64Bit())\n    return getSection64(Sec).addr;\n  return getSection(Sec).addr;\n}\n\nuint64_t MachOObjectFile::getSectionIndex(DataRefImpl Sec) const {\n  return Sec.d.a;\n}\n\nuint64_t MachOObjectFile::getSectionSize(DataRefImpl Sec) const {\n  // In the case if a malformed Mach-O file where the section offset is past\n  // the end of the file or some part of the section size is past the end of\n  // the file return a size of zero or a size that covers the rest of the file\n  // but does not extend past the end of the file.\n  uint32_t SectOffset, SectType;\n  uint64_t SectSize;\n\n  if (is64Bit()) {\n    MachO::section_64 Sect = getSection64(Sec);\n    SectOffset = Sect.offset;\n    SectSize = Sect.size;\n    SectType = Sect.flags & MachO::SECTION_TYPE;\n  } else {\n    MachO::section Sect = getSection(Sec);\n    SectOffset = Sect.offset;\n    SectSize = Sect.size;\n    SectType = Sect.flags & MachO::SECTION_TYPE;\n  }\n  if (SectType == MachO::S_ZEROFILL || SectType == MachO::S_GB_ZEROFILL)\n    return SectSize;\n  uint64_t FileSize = getData().size();\n  if (SectOffset > FileSize)\n    return 0;\n  if (FileSize - SectOffset < SectSize)\n    return FileSize - SectOffset;\n  return SectSize;\n}\n\nArrayRef<uint8_t> MachOObjectFile::getSectionContents(uint32_t Offset,\n                                                      uint64_t Size) const {\n  return arrayRefFromStringRef(getData().substr(Offset, Size));\n}\n\nExpected<ArrayRef<uint8_t>>\nMachOObjectFile::getSectionContents(DataRefImpl Sec) const {\n  uint32_t Offset;\n  uint64_t Size;\n\n  if (is64Bit()) {\n    MachO::section_64 Sect = getSection64(Sec);\n    Offset = Sect.offset;\n    Size = Sect.size;\n  } else {\n    MachO::section Sect = getSection(Sec);\n    Offset = Sect.offset;\n    Size = Sect.size;\n  }\n\n  return getSectionContents(Offset, Size);\n}\n\nuint64_t MachOObjectFile::getSectionAlignment(DataRefImpl Sec) const {\n  uint32_t Align;\n  if (is64Bit()) {\n    MachO::section_64 Sect = getSection64(Sec);\n    Align = Sect.align;\n  } else {\n    MachO::section Sect = getSection(Sec);\n    Align = Sect.align;\n  }\n\n  return uint64_t(1) << Align;\n}\n\nExpected<SectionRef> MachOObjectFile::getSection(unsigned SectionIndex) const {\n  if (SectionIndex < 1 || SectionIndex > Sections.size())\n    return malformedError(\"bad section index: \" + Twine((int)SectionIndex));\n\n  DataRefImpl DRI;\n  DRI.d.a = SectionIndex - 1;\n  return SectionRef(DRI, this);\n}\n\nExpected<SectionRef> MachOObjectFile::getSection(StringRef SectionName) const {\n  for (const SectionRef &Section : sections()) {\n    auto NameOrErr = Section.getName();\n    if (!NameOrErr)\n      return NameOrErr.takeError();\n    if (*NameOrErr == SectionName)\n      return Section;\n  }\n  return errorCodeToError(object_error::parse_failed);\n}\n\nbool MachOObjectFile::isSectionCompressed(DataRefImpl Sec) const {\n  return false;\n}\n\nbool MachOObjectFile::isSectionText(DataRefImpl Sec) const {\n  uint32_t Flags = getSectionFlags(*this, Sec);\n  return Flags & MachO::S_ATTR_PURE_INSTRUCTIONS;\n}\n\nbool MachOObjectFile::isSectionData(DataRefImpl Sec) const {\n  uint32_t Flags = getSectionFlags(*this, Sec);\n  unsigned SectionType = Flags & MachO::SECTION_TYPE;\n  return !(Flags & MachO::S_ATTR_PURE_INSTRUCTIONS) &&\n         !(SectionType == MachO::S_ZEROFILL ||\n           SectionType == MachO::S_GB_ZEROFILL);\n}\n\nbool MachOObjectFile::isSectionBSS(DataRefImpl Sec) const {\n  uint32_t Flags = getSectionFlags(*this, Sec);\n  unsigned SectionType = Flags & MachO::SECTION_TYPE;\n  return !(Flags & MachO::S_ATTR_PURE_INSTRUCTIONS) &&\n         (SectionType == MachO::S_ZEROFILL ||\n          SectionType == MachO::S_GB_ZEROFILL);\n}\n\nbool MachOObjectFile::isDebugSection(StringRef SectionName) const {\n  return SectionName.startswith(\"__debug\") ||\n         SectionName.startswith(\"__zdebug\") ||\n         SectionName.startswith(\"__apple\") || SectionName == \"__gdb_index\" ||\n         SectionName == \"__swift_ast\";\n}\n\nunsigned MachOObjectFile::getSectionID(SectionRef Sec) const {\n  return Sec.getRawDataRefImpl().d.a;\n}\n\nbool MachOObjectFile::isSectionVirtual(DataRefImpl Sec) const {\n  uint32_t Flags = getSectionFlags(*this, Sec);\n  unsigned SectionType = Flags & MachO::SECTION_TYPE;\n  return SectionType == MachO::S_ZEROFILL ||\n         SectionType == MachO::S_GB_ZEROFILL;\n}\n\nbool MachOObjectFile::isSectionBitcode(DataRefImpl Sec) const {\n  StringRef SegmentName = getSectionFinalSegmentName(Sec);\n  if (Expected<StringRef> NameOrErr = getSectionName(Sec))\n    return (SegmentName == \"__LLVM\" && *NameOrErr == \"__bitcode\");\n  return false;\n}\n\nbool MachOObjectFile::isSectionStripped(DataRefImpl Sec) const {\n  if (is64Bit())\n    return getSection64(Sec).offset == 0;\n  return getSection(Sec).offset == 0;\n}\n\nrelocation_iterator MachOObjectFile::section_rel_begin(DataRefImpl Sec) const {\n  DataRefImpl Ret;\n  Ret.d.a = Sec.d.a;\n  Ret.d.b = 0;\n  return relocation_iterator(RelocationRef(Ret, this));\n}\n\nrelocation_iterator\nMachOObjectFile::section_rel_end(DataRefImpl Sec) const {\n  uint32_t Num;\n  if (is64Bit()) {\n    MachO::section_64 Sect = getSection64(Sec);\n    Num = Sect.nreloc;\n  } else {\n    MachO::section Sect = getSection(Sec);\n    Num = Sect.nreloc;\n  }\n\n  DataRefImpl Ret;\n  Ret.d.a = Sec.d.a;\n  Ret.d.b = Num;\n  return relocation_iterator(RelocationRef(Ret, this));\n}\n\nrelocation_iterator MachOObjectFile::extrel_begin() const {\n  DataRefImpl Ret;\n  // for DYSYMTAB symbols, Ret.d.a == 0 for external relocations\n  Ret.d.a = 0; // Would normally be a section index.\n  Ret.d.b = 0; // Index into the external relocations\n  return relocation_iterator(RelocationRef(Ret, this));\n}\n\nrelocation_iterator MachOObjectFile::extrel_end() const {\n  MachO::dysymtab_command DysymtabLoadCmd = getDysymtabLoadCommand();\n  DataRefImpl Ret;\n  // for DYSYMTAB symbols, Ret.d.a == 0 for external relocations\n  Ret.d.a = 0; // Would normally be a section index.\n  Ret.d.b = DysymtabLoadCmd.nextrel; // Index into the external relocations\n  return relocation_iterator(RelocationRef(Ret, this));\n}\n\nrelocation_iterator MachOObjectFile::locrel_begin() const {\n  DataRefImpl Ret;\n  // for DYSYMTAB symbols, Ret.d.a == 1 for local relocations\n  Ret.d.a = 1; // Would normally be a section index.\n  Ret.d.b = 0; // Index into the local relocations\n  return relocation_iterator(RelocationRef(Ret, this));\n}\n\nrelocation_iterator MachOObjectFile::locrel_end() const {\n  MachO::dysymtab_command DysymtabLoadCmd = getDysymtabLoadCommand();\n  DataRefImpl Ret;\n  // for DYSYMTAB symbols, Ret.d.a == 1 for local relocations\n  Ret.d.a = 1; // Would normally be a section index.\n  Ret.d.b = DysymtabLoadCmd.nlocrel; // Index into the local relocations\n  return relocation_iterator(RelocationRef(Ret, this));\n}\n\nvoid MachOObjectFile::moveRelocationNext(DataRefImpl &Rel) const {\n  ++Rel.d.b;\n}\n\nuint64_t MachOObjectFile::getRelocationOffset(DataRefImpl Rel) const {\n  assert((getHeader().filetype == MachO::MH_OBJECT ||\n          getHeader().filetype == MachO::MH_KEXT_BUNDLE) &&\n         \"Only implemented for MH_OBJECT && MH_KEXT_BUNDLE\");\n  MachO::any_relocation_info RE = getRelocation(Rel);\n  return getAnyRelocationAddress(RE);\n}\n\nsymbol_iterator\nMachOObjectFile::getRelocationSymbol(DataRefImpl Rel) const {\n  MachO::any_relocation_info RE = getRelocation(Rel);\n  if (isRelocationScattered(RE))\n    return symbol_end();\n\n  uint32_t SymbolIdx = getPlainRelocationSymbolNum(RE);\n  bool isExtern = getPlainRelocationExternal(RE);\n  if (!isExtern)\n    return symbol_end();\n\n  MachO::symtab_command S = getSymtabLoadCommand();\n  unsigned SymbolTableEntrySize = is64Bit() ?\n    sizeof(MachO::nlist_64) :\n    sizeof(MachO::nlist);\n  uint64_t Offset = S.symoff + SymbolIdx * SymbolTableEntrySize;\n  DataRefImpl Sym;\n  Sym.p = reinterpret_cast<uintptr_t>(getPtr(*this, Offset));\n  return symbol_iterator(SymbolRef(Sym, this));\n}\n\nsection_iterator\nMachOObjectFile::getRelocationSection(DataRefImpl Rel) const {\n  return section_iterator(getAnyRelocationSection(getRelocation(Rel)));\n}\n\nuint64_t MachOObjectFile::getRelocationType(DataRefImpl Rel) const {\n  MachO::any_relocation_info RE = getRelocation(Rel);\n  return getAnyRelocationType(RE);\n}\n\nvoid MachOObjectFile::getRelocationTypeName(\n    DataRefImpl Rel, SmallVectorImpl<char> &Result) const {\n  StringRef res;\n  uint64_t RType = getRelocationType(Rel);\n\n  unsigned Arch = this->getArch();\n\n  switch (Arch) {\n    case Triple::x86: {\n      static const char *const Table[] =  {\n        \"GENERIC_RELOC_VANILLA\",\n        \"GENERIC_RELOC_PAIR\",\n        \"GENERIC_RELOC_SECTDIFF\",\n        \"GENERIC_RELOC_PB_LA_PTR\",\n        \"GENERIC_RELOC_LOCAL_SECTDIFF\",\n        \"GENERIC_RELOC_TLV\" };\n\n      if (RType > 5)\n        res = \"Unknown\";\n      else\n        res = Table[RType];\n      break;\n    }\n    case Triple::x86_64: {\n      static const char *const Table[] =  {\n        \"X86_64_RELOC_UNSIGNED\",\n        \"X86_64_RELOC_SIGNED\",\n        \"X86_64_RELOC_BRANCH\",\n        \"X86_64_RELOC_GOT_LOAD\",\n        \"X86_64_RELOC_GOT\",\n        \"X86_64_RELOC_SUBTRACTOR\",\n        \"X86_64_RELOC_SIGNED_1\",\n        \"X86_64_RELOC_SIGNED_2\",\n        \"X86_64_RELOC_SIGNED_4\",\n        \"X86_64_RELOC_TLV\" };\n\n      if (RType > 9)\n        res = \"Unknown\";\n      else\n        res = Table[RType];\n      break;\n    }\n    case Triple::arm: {\n      static const char *const Table[] =  {\n        \"ARM_RELOC_VANILLA\",\n        \"ARM_RELOC_PAIR\",\n        \"ARM_RELOC_SECTDIFF\",\n        \"ARM_RELOC_LOCAL_SECTDIFF\",\n        \"ARM_RELOC_PB_LA_PTR\",\n        \"ARM_RELOC_BR24\",\n        \"ARM_THUMB_RELOC_BR22\",\n        \"ARM_THUMB_32BIT_BRANCH\",\n        \"ARM_RELOC_HALF\",\n        \"ARM_RELOC_HALF_SECTDIFF\" };\n\n      if (RType > 9)\n        res = \"Unknown\";\n      else\n        res = Table[RType];\n      break;\n    }\n    case Triple::aarch64:\n    case Triple::aarch64_32: {\n      static const char *const Table[] = {\n        \"ARM64_RELOC_UNSIGNED\",           \"ARM64_RELOC_SUBTRACTOR\",\n        \"ARM64_RELOC_BRANCH26\",           \"ARM64_RELOC_PAGE21\",\n        \"ARM64_RELOC_PAGEOFF12\",          \"ARM64_RELOC_GOT_LOAD_PAGE21\",\n        \"ARM64_RELOC_GOT_LOAD_PAGEOFF12\", \"ARM64_RELOC_POINTER_TO_GOT\",\n        \"ARM64_RELOC_TLVP_LOAD_PAGE21\",   \"ARM64_RELOC_TLVP_LOAD_PAGEOFF12\",\n        \"ARM64_RELOC_ADDEND\"\n      };\n\n      if (RType >= array_lengthof(Table))\n        res = \"Unknown\";\n      else\n        res = Table[RType];\n      break;\n    }\n    case Triple::ppc: {\n      static const char *const Table[] =  {\n        \"PPC_RELOC_VANILLA\",\n        \"PPC_RELOC_PAIR\",\n        \"PPC_RELOC_BR14\",\n        \"PPC_RELOC_BR24\",\n        \"PPC_RELOC_HI16\",\n        \"PPC_RELOC_LO16\",\n        \"PPC_RELOC_HA16\",\n        \"PPC_RELOC_LO14\",\n        \"PPC_RELOC_SECTDIFF\",\n        \"PPC_RELOC_PB_LA_PTR\",\n        \"PPC_RELOC_HI16_SECTDIFF\",\n        \"PPC_RELOC_LO16_SECTDIFF\",\n        \"PPC_RELOC_HA16_SECTDIFF\",\n        \"PPC_RELOC_JBSR\",\n        \"PPC_RELOC_LO14_SECTDIFF\",\n        \"PPC_RELOC_LOCAL_SECTDIFF\" };\n\n      if (RType > 15)\n        res = \"Unknown\";\n      else\n        res = Table[RType];\n      break;\n    }\n    case Triple::UnknownArch:\n      res = \"Unknown\";\n      break;\n  }\n  Result.append(res.begin(), res.end());\n}\n\nuint8_t MachOObjectFile::getRelocationLength(DataRefImpl Rel) const {\n  MachO::any_relocation_info RE = getRelocation(Rel);\n  return getAnyRelocationLength(RE);\n}\n\n//\n// guessLibraryShortName() is passed a name of a dynamic library and returns a\n// guess on what the short name is.  Then name is returned as a substring of the\n// StringRef Name passed in.  The name of the dynamic library is recognized as\n// a framework if it has one of the two following forms:\n//      Foo.framework/Versions/A/Foo\n//      Foo.framework/Foo\n// Where A and Foo can be any string.  And may contain a trailing suffix\n// starting with an underbar.  If the Name is recognized as a framework then\n// isFramework is set to true else it is set to false.  If the Name has a\n// suffix then Suffix is set to the substring in Name that contains the suffix\n// else it is set to a NULL StringRef.\n//\n// The Name of the dynamic library is recognized as a library name if it has\n// one of the two following forms:\n//      libFoo.A.dylib\n//      libFoo.dylib\n//\n// The library may have a suffix trailing the name Foo of the form:\n//      libFoo_profile.A.dylib\n//      libFoo_profile.dylib\n// These dyld image suffixes are separated from the short name by a '_'\n// character. Because the '_' character is commonly used to separate words in\n// filenames guessLibraryShortName() cannot reliably separate a dylib's short\n// name from an arbitrary image suffix; imagine if both the short name and the\n// suffix contains an '_' character! To better deal with this ambiguity,\n// guessLibraryShortName() will recognize only \"_debug\" and \"_profile\" as valid\n// Suffix values. Calling code needs to be tolerant of guessLibraryShortName()\n// guessing incorrectly.\n//\n// The Name of the dynamic library is also recognized as a library name if it\n// has the following form:\n//      Foo.qtx\n//\n// If the Name of the dynamic library is none of the forms above then a NULL\n// StringRef is returned.\nStringRef MachOObjectFile::guessLibraryShortName(StringRef Name,\n                                                 bool &isFramework,\n                                                 StringRef &Suffix) {\n  StringRef Foo, F, DotFramework, V, Dylib, Lib, Dot, Qtx;\n  size_t a, b, c, d, Idx;\n\n  isFramework = false;\n  Suffix = StringRef();\n\n  // Pull off the last component and make Foo point to it\n  a = Name.rfind('/');\n  if (a == Name.npos || a == 0)\n    goto guess_library;\n  Foo = Name.slice(a+1, Name.npos);\n\n  // Look for a suffix starting with a '_'\n  Idx = Foo.rfind('_');\n  if (Idx != Foo.npos && Foo.size() >= 2) {\n    Suffix = Foo.slice(Idx, Foo.npos);\n    if (Suffix != \"_debug\" && Suffix != \"_profile\")\n      Suffix = StringRef();\n    else\n      Foo = Foo.slice(0, Idx);\n  }\n\n  // First look for the form Foo.framework/Foo\n  b = Name.rfind('/', a);\n  if (b == Name.npos)\n    Idx = 0;\n  else\n    Idx = b+1;\n  F = Name.slice(Idx, Idx + Foo.size());\n  DotFramework = Name.slice(Idx + Foo.size(),\n                            Idx + Foo.size() + sizeof(\".framework/\")-1);\n  if (F == Foo && DotFramework == \".framework/\") {\n    isFramework = true;\n    return Foo;\n  }\n\n  // Next look for the form Foo.framework/Versions/A/Foo\n  if (b == Name.npos)\n    goto guess_library;\n  c =  Name.rfind('/', b);\n  if (c == Name.npos || c == 0)\n    goto guess_library;\n  V = Name.slice(c+1, Name.npos);\n  if (!V.startswith(\"Versions/\"))\n    goto guess_library;\n  d =  Name.rfind('/', c);\n  if (d == Name.npos)\n    Idx = 0;\n  else\n    Idx = d+1;\n  F = Name.slice(Idx, Idx + Foo.size());\n  DotFramework = Name.slice(Idx + Foo.size(),\n                            Idx + Foo.size() + sizeof(\".framework/\")-1);\n  if (F == Foo && DotFramework == \".framework/\") {\n    isFramework = true;\n    return Foo;\n  }\n\nguess_library:\n  // pull off the suffix after the \".\" and make a point to it\n  a = Name.rfind('.');\n  if (a == Name.npos || a == 0)\n    return StringRef();\n  Dylib = Name.slice(a, Name.npos);\n  if (Dylib != \".dylib\")\n    goto guess_qtx;\n\n  // First pull off the version letter for the form Foo.A.dylib if any.\n  if (a >= 3) {\n    Dot = Name.slice(a-2, a-1);\n    if (Dot == \".\")\n      a = a - 2;\n  }\n\n  b = Name.rfind('/', a);\n  if (b == Name.npos)\n    b = 0;\n  else\n    b = b+1;\n  // ignore any suffix after an underbar like Foo_profile.A.dylib\n  Idx = Name.rfind('_');\n  if (Idx != Name.npos && Idx != b) {\n    Lib = Name.slice(b, Idx);\n    Suffix = Name.slice(Idx, a);\n    if (Suffix != \"_debug\" && Suffix != \"_profile\") {\n      Suffix = StringRef();\n      Lib = Name.slice(b, a);\n    }\n  }\n  else\n    Lib = Name.slice(b, a);\n  // There are incorrect library names of the form:\n  // libATS.A_profile.dylib so check for these.\n  if (Lib.size() >= 3) {\n    Dot = Lib.slice(Lib.size()-2, Lib.size()-1);\n    if (Dot == \".\")\n      Lib = Lib.slice(0, Lib.size()-2);\n  }\n  return Lib;\n\nguess_qtx:\n  Qtx = Name.slice(a, Name.npos);\n  if (Qtx != \".qtx\")\n    return StringRef();\n  b = Name.rfind('/', a);\n  if (b == Name.npos)\n    Lib = Name.slice(0, a);\n  else\n    Lib = Name.slice(b+1, a);\n  // There are library names of the form: QT.A.qtx so check for these.\n  if (Lib.size() >= 3) {\n    Dot = Lib.slice(Lib.size()-2, Lib.size()-1);\n    if (Dot == \".\")\n      Lib = Lib.slice(0, Lib.size()-2);\n  }\n  return Lib;\n}\n\n// getLibraryShortNameByIndex() is used to get the short name of the library\n// for an undefined symbol in a linked Mach-O binary that was linked with the\n// normal two-level namespace default (that is MH_TWOLEVEL in the header).\n// It is passed the index (0 - based) of the library as translated from\n// GET_LIBRARY_ORDINAL (1 - based).\nstd::error_code MachOObjectFile::getLibraryShortNameByIndex(unsigned Index,\n                                                         StringRef &Res) const {\n  if (Index >= Libraries.size())\n    return object_error::parse_failed;\n\n  // If the cache of LibrariesShortNames is not built up do that first for\n  // all the Libraries.\n  if (LibrariesShortNames.size() == 0) {\n    for (unsigned i = 0; i < Libraries.size(); i++) {\n      auto CommandOrErr =\n        getStructOrErr<MachO::dylib_command>(*this, Libraries[i]);\n      if (!CommandOrErr)\n        return object_error::parse_failed;\n      MachO::dylib_command D = CommandOrErr.get();\n      if (D.dylib.name >= D.cmdsize)\n        return object_error::parse_failed;\n      const char *P = (const char *)(Libraries[i]) + D.dylib.name;\n      StringRef Name = StringRef(P);\n      if (D.dylib.name+Name.size() >= D.cmdsize)\n        return object_error::parse_failed;\n      StringRef Suffix;\n      bool isFramework;\n      StringRef shortName = guessLibraryShortName(Name, isFramework, Suffix);\n      if (shortName.empty())\n        LibrariesShortNames.push_back(Name);\n      else\n        LibrariesShortNames.push_back(shortName);\n    }\n  }\n\n  Res = LibrariesShortNames[Index];\n  return std::error_code();\n}\n\nuint32_t MachOObjectFile::getLibraryCount() const {\n  return Libraries.size();\n}\n\nsection_iterator\nMachOObjectFile::getRelocationRelocatedSection(relocation_iterator Rel) const {\n  DataRefImpl Sec;\n  Sec.d.a = Rel->getRawDataRefImpl().d.a;\n  return section_iterator(SectionRef(Sec, this));\n}\n\nbasic_symbol_iterator MachOObjectFile::symbol_begin() const {\n  DataRefImpl DRI;\n  MachO::symtab_command Symtab = getSymtabLoadCommand();\n  if (!SymtabLoadCmd || Symtab.nsyms == 0)\n    return basic_symbol_iterator(SymbolRef(DRI, this));\n\n  return getSymbolByIndex(0);\n}\n\nbasic_symbol_iterator MachOObjectFile::symbol_end() const {\n  DataRefImpl DRI;\n  MachO::symtab_command Symtab = getSymtabLoadCommand();\n  if (!SymtabLoadCmd || Symtab.nsyms == 0)\n    return basic_symbol_iterator(SymbolRef(DRI, this));\n\n  unsigned SymbolTableEntrySize = is64Bit() ?\n    sizeof(MachO::nlist_64) :\n    sizeof(MachO::nlist);\n  unsigned Offset = Symtab.symoff +\n    Symtab.nsyms * SymbolTableEntrySize;\n  DRI.p = reinterpret_cast<uintptr_t>(getPtr(*this, Offset));\n  return basic_symbol_iterator(SymbolRef(DRI, this));\n}\n\nsymbol_iterator MachOObjectFile::getSymbolByIndex(unsigned Index) const {\n  MachO::symtab_command Symtab = getSymtabLoadCommand();\n  if (!SymtabLoadCmd || Index >= Symtab.nsyms)\n    report_fatal_error(\"Requested symbol index is out of range.\");\n  unsigned SymbolTableEntrySize =\n    is64Bit() ? sizeof(MachO::nlist_64) : sizeof(MachO::nlist);\n  DataRefImpl DRI;\n  DRI.p = reinterpret_cast<uintptr_t>(getPtr(*this, Symtab.symoff));\n  DRI.p += Index * SymbolTableEntrySize;\n  return basic_symbol_iterator(SymbolRef(DRI, this));\n}\n\nuint64_t MachOObjectFile::getSymbolIndex(DataRefImpl Symb) const {\n  MachO::symtab_command Symtab = getSymtabLoadCommand();\n  if (!SymtabLoadCmd)\n    report_fatal_error(\"getSymbolIndex() called with no symbol table symbol\");\n  unsigned SymbolTableEntrySize =\n    is64Bit() ? sizeof(MachO::nlist_64) : sizeof(MachO::nlist);\n  DataRefImpl DRIstart;\n  DRIstart.p = reinterpret_cast<uintptr_t>(getPtr(*this, Symtab.symoff));\n  uint64_t Index = (Symb.p - DRIstart.p) / SymbolTableEntrySize;\n  return Index;\n}\n\nsection_iterator MachOObjectFile::section_begin() const {\n  DataRefImpl DRI;\n  return section_iterator(SectionRef(DRI, this));\n}\n\nsection_iterator MachOObjectFile::section_end() const {\n  DataRefImpl DRI;\n  DRI.d.a = Sections.size();\n  return section_iterator(SectionRef(DRI, this));\n}\n\nuint8_t MachOObjectFile::getBytesInAddress() const {\n  return is64Bit() ? 8 : 4;\n}\n\nStringRef MachOObjectFile::getFileFormatName() const {\n  unsigned CPUType = getCPUType(*this);\n  if (!is64Bit()) {\n    switch (CPUType) {\n    case MachO::CPU_TYPE_I386:\n      return \"Mach-O 32-bit i386\";\n    case MachO::CPU_TYPE_ARM:\n      return \"Mach-O arm\";\n    case MachO::CPU_TYPE_ARM64_32:\n      return \"Mach-O arm64 (ILP32)\";\n    case MachO::CPU_TYPE_POWERPC:\n      return \"Mach-O 32-bit ppc\";\n    default:\n      return \"Mach-O 32-bit unknown\";\n    }\n  }\n\n  switch (CPUType) {\n  case MachO::CPU_TYPE_X86_64:\n    return \"Mach-O 64-bit x86-64\";\n  case MachO::CPU_TYPE_ARM64:\n    return \"Mach-O arm64\";\n  case MachO::CPU_TYPE_POWERPC64:\n    return \"Mach-O 64-bit ppc64\";\n  default:\n    return \"Mach-O 64-bit unknown\";\n  }\n}\n\nTriple::ArchType MachOObjectFile::getArch(uint32_t CPUType, uint32_t CPUSubType) {\n  switch (CPUType) {\n  case MachO::CPU_TYPE_I386:\n    return Triple::x86;\n  case MachO::CPU_TYPE_X86_64:\n    return Triple::x86_64;\n  case MachO::CPU_TYPE_ARM:\n    return Triple::arm;\n  case MachO::CPU_TYPE_ARM64:\n    return Triple::aarch64;\n  case MachO::CPU_TYPE_ARM64_32:\n    return Triple::aarch64_32;\n  case MachO::CPU_TYPE_POWERPC:\n    return Triple::ppc;\n  case MachO::CPU_TYPE_POWERPC64:\n    return Triple::ppc64;\n  default:\n    return Triple::UnknownArch;\n  }\n}\n\nTriple MachOObjectFile::getArchTriple(uint32_t CPUType, uint32_t CPUSubType,\n                                      const char **McpuDefault,\n                                      const char **ArchFlag) {\n  if (McpuDefault)\n    *McpuDefault = nullptr;\n  if (ArchFlag)\n    *ArchFlag = nullptr;\n\n  switch (CPUType) {\n  case MachO::CPU_TYPE_I386:\n    switch (CPUSubType & ~MachO::CPU_SUBTYPE_MASK) {\n    case MachO::CPU_SUBTYPE_I386_ALL:\n      if (ArchFlag)\n        *ArchFlag = \"i386\";\n      return Triple(\"i386-apple-darwin\");\n    default:\n      return Triple();\n    }\n  case MachO::CPU_TYPE_X86_64:\n    switch (CPUSubType & ~MachO::CPU_SUBTYPE_MASK) {\n    case MachO::CPU_SUBTYPE_X86_64_ALL:\n      if (ArchFlag)\n        *ArchFlag = \"x86_64\";\n      return Triple(\"x86_64-apple-darwin\");\n    case MachO::CPU_SUBTYPE_X86_64_H:\n      if (ArchFlag)\n        *ArchFlag = \"x86_64h\";\n      return Triple(\"x86_64h-apple-darwin\");\n    default:\n      return Triple();\n    }\n  case MachO::CPU_TYPE_ARM:\n    switch (CPUSubType & ~MachO::CPU_SUBTYPE_MASK) {\n    case MachO::CPU_SUBTYPE_ARM_V4T:\n      if (ArchFlag)\n        *ArchFlag = \"armv4t\";\n      return Triple(\"armv4t-apple-darwin\");\n    case MachO::CPU_SUBTYPE_ARM_V5TEJ:\n      if (ArchFlag)\n        *ArchFlag = \"armv5e\";\n      return Triple(\"armv5e-apple-darwin\");\n    case MachO::CPU_SUBTYPE_ARM_XSCALE:\n      if (ArchFlag)\n        *ArchFlag = \"xscale\";\n      return Triple(\"xscale-apple-darwin\");\n    case MachO::CPU_SUBTYPE_ARM_V6:\n      if (ArchFlag)\n        *ArchFlag = \"armv6\";\n      return Triple(\"armv6-apple-darwin\");\n    case MachO::CPU_SUBTYPE_ARM_V6M:\n      if (McpuDefault)\n        *McpuDefault = \"cortex-m0\";\n      if (ArchFlag)\n        *ArchFlag = \"armv6m\";\n      return Triple(\"armv6m-apple-darwin\");\n    case MachO::CPU_SUBTYPE_ARM_V7:\n      if (ArchFlag)\n        *ArchFlag = \"armv7\";\n      return Triple(\"armv7-apple-darwin\");\n    case MachO::CPU_SUBTYPE_ARM_V7EM:\n      if (McpuDefault)\n        *McpuDefault = \"cortex-m4\";\n      if (ArchFlag)\n        *ArchFlag = \"armv7em\";\n      return Triple(\"thumbv7em-apple-darwin\");\n    case MachO::CPU_SUBTYPE_ARM_V7K:\n      if (McpuDefault)\n        *McpuDefault = \"cortex-a7\";\n      if (ArchFlag)\n        *ArchFlag = \"armv7k\";\n      return Triple(\"armv7k-apple-darwin\");\n    case MachO::CPU_SUBTYPE_ARM_V7M:\n      if (McpuDefault)\n        *McpuDefault = \"cortex-m3\";\n      if (ArchFlag)\n        *ArchFlag = \"armv7m\";\n      return Triple(\"thumbv7m-apple-darwin\");\n    case MachO::CPU_SUBTYPE_ARM_V7S:\n      if (McpuDefault)\n        *McpuDefault = \"cortex-a7\";\n      if (ArchFlag)\n        *ArchFlag = \"armv7s\";\n      return Triple(\"armv7s-apple-darwin\");\n    default:\n      return Triple();\n    }\n  case MachO::CPU_TYPE_ARM64:\n    switch (CPUSubType & ~MachO::CPU_SUBTYPE_MASK) {\n    case MachO::CPU_SUBTYPE_ARM64_ALL:\n      if (McpuDefault)\n        *McpuDefault = \"cyclone\";\n      if (ArchFlag)\n        *ArchFlag = \"arm64\";\n      return Triple(\"arm64-apple-darwin\");\n    case MachO::CPU_SUBTYPE_ARM64E:\n      if (McpuDefault)\n        *McpuDefault = \"apple-a12\";\n      if (ArchFlag)\n        *ArchFlag = \"arm64e\";\n      return Triple(\"arm64e-apple-darwin\");\n    default:\n      return Triple();\n    }\n  case MachO::CPU_TYPE_ARM64_32:\n    switch (CPUSubType & ~MachO::CPU_SUBTYPE_MASK) {\n    case MachO::CPU_SUBTYPE_ARM64_32_V8:\n      if (McpuDefault)\n        *McpuDefault = \"cyclone\";\n      if (ArchFlag)\n        *ArchFlag = \"arm64_32\";\n      return Triple(\"arm64_32-apple-darwin\");\n    default:\n      return Triple();\n    }\n  case MachO::CPU_TYPE_POWERPC:\n    switch (CPUSubType & ~MachO::CPU_SUBTYPE_MASK) {\n    case MachO::CPU_SUBTYPE_POWERPC_ALL:\n      if (ArchFlag)\n        *ArchFlag = \"ppc\";\n      return Triple(\"ppc-apple-darwin\");\n    default:\n      return Triple();\n    }\n  case MachO::CPU_TYPE_POWERPC64:\n    switch (CPUSubType & ~MachO::CPU_SUBTYPE_MASK) {\n    case MachO::CPU_SUBTYPE_POWERPC_ALL:\n      if (ArchFlag)\n        *ArchFlag = \"ppc64\";\n      return Triple(\"ppc64-apple-darwin\");\n    default:\n      return Triple();\n    }\n  default:\n    return Triple();\n  }\n}\n\nTriple MachOObjectFile::getHostArch() {\n  return Triple(sys::getDefaultTargetTriple());\n}\n\nbool MachOObjectFile::isValidArch(StringRef ArchFlag) {\n  auto validArchs = getValidArchs();\n  return llvm::is_contained(validArchs, ArchFlag);\n}\n\nArrayRef<StringRef> MachOObjectFile::getValidArchs() {\n  static const std::array<StringRef, 18> ValidArchs = {{\n      \"i386\",\n      \"x86_64\",\n      \"x86_64h\",\n      \"armv4t\",\n      \"arm\",\n      \"armv5e\",\n      \"armv6\",\n      \"armv6m\",\n      \"armv7\",\n      \"armv7em\",\n      \"armv7k\",\n      \"armv7m\",\n      \"armv7s\",\n      \"arm64\",\n      \"arm64e\",\n      \"arm64_32\",\n      \"ppc\",\n      \"ppc64\",\n  }};\n\n  return ValidArchs;\n}\n\nTriple::ArchType MachOObjectFile::getArch() const {\n  return getArch(getCPUType(*this), getCPUSubType(*this));\n}\n\nTriple MachOObjectFile::getArchTriple(const char **McpuDefault) const {\n  return getArchTriple(Header.cputype, Header.cpusubtype, McpuDefault);\n}\n\nrelocation_iterator MachOObjectFile::section_rel_begin(unsigned Index) const {\n  DataRefImpl DRI;\n  DRI.d.a = Index;\n  return section_rel_begin(DRI);\n}\n\nrelocation_iterator MachOObjectFile::section_rel_end(unsigned Index) const {\n  DataRefImpl DRI;\n  DRI.d.a = Index;\n  return section_rel_end(DRI);\n}\n\ndice_iterator MachOObjectFile::begin_dices() const {\n  DataRefImpl DRI;\n  if (!DataInCodeLoadCmd)\n    return dice_iterator(DiceRef(DRI, this));\n\n  MachO::linkedit_data_command DicLC = getDataInCodeLoadCommand();\n  DRI.p = reinterpret_cast<uintptr_t>(getPtr(*this, DicLC.dataoff));\n  return dice_iterator(DiceRef(DRI, this));\n}\n\ndice_iterator MachOObjectFile::end_dices() const {\n  DataRefImpl DRI;\n  if (!DataInCodeLoadCmd)\n    return dice_iterator(DiceRef(DRI, this));\n\n  MachO::linkedit_data_command DicLC = getDataInCodeLoadCommand();\n  unsigned Offset = DicLC.dataoff + DicLC.datasize;\n  DRI.p = reinterpret_cast<uintptr_t>(getPtr(*this, Offset));\n  return dice_iterator(DiceRef(DRI, this));\n}\n\nExportEntry::ExportEntry(Error *E, const MachOObjectFile *O,\n                         ArrayRef<uint8_t> T) : E(E), O(O), Trie(T) {}\n\nvoid ExportEntry::moveToFirst() {\n  ErrorAsOutParameter ErrAsOutParam(E);\n  pushNode(0);\n  if (*E)\n    return;\n  pushDownUntilBottom();\n}\n\nvoid ExportEntry::moveToEnd() {\n  Stack.clear();\n  Done = true;\n}\n\nbool ExportEntry::operator==(const ExportEntry &Other) const {\n  // Common case, one at end, other iterating from begin.\n  if (Done || Other.Done)\n    return (Done == Other.Done);\n  // Not equal if different stack sizes.\n  if (Stack.size() != Other.Stack.size())\n    return false;\n  // Not equal if different cumulative strings.\n  if (!CumulativeString.equals(Other.CumulativeString))\n    return false;\n  // Equal if all nodes in both stacks match.\n  for (unsigned i=0; i < Stack.size(); ++i) {\n    if (Stack[i].Start != Other.Stack[i].Start)\n      return false;\n  }\n  return true;\n}\n\nuint64_t ExportEntry::readULEB128(const uint8_t *&Ptr, const char **error) {\n  unsigned Count;\n  uint64_t Result = decodeULEB128(Ptr, &Count, Trie.end(), error);\n  Ptr += Count;\n  if (Ptr > Trie.end())\n    Ptr = Trie.end();\n  return Result;\n}\n\nStringRef ExportEntry::name() const {\n  return CumulativeString;\n}\n\nuint64_t ExportEntry::flags() const {\n  return Stack.back().Flags;\n}\n\nuint64_t ExportEntry::address() const {\n  return Stack.back().Address;\n}\n\nuint64_t ExportEntry::other() const {\n  return Stack.back().Other;\n}\n\nStringRef ExportEntry::otherName() const {\n  const char* ImportName = Stack.back().ImportName;\n  if (ImportName)\n    return StringRef(ImportName);\n  return StringRef();\n}\n\nuint32_t ExportEntry::nodeOffset() const {\n  return Stack.back().Start - Trie.begin();\n}\n\nExportEntry::NodeState::NodeState(const uint8_t *Ptr)\n    : Start(Ptr), Current(Ptr) {}\n\nvoid ExportEntry::pushNode(uint64_t offset) {\n  ErrorAsOutParameter ErrAsOutParam(E);\n  const uint8_t *Ptr = Trie.begin() + offset;\n  NodeState State(Ptr);\n  const char *error;\n  uint64_t ExportInfoSize = readULEB128(State.Current, &error);\n  if (error) {\n    *E = malformedError(\"export info size \" + Twine(error) +\n                        \" in export trie data at node: 0x\" +\n                        Twine::utohexstr(offset));\n    moveToEnd();\n    return;\n  }\n  State.IsExportNode = (ExportInfoSize != 0);\n  const uint8_t* Children = State.Current + ExportInfoSize;\n  if (Children > Trie.end()) {\n    *E = malformedError(\n        \"export info size: 0x\" + Twine::utohexstr(ExportInfoSize) +\n        \" in export trie data at node: 0x\" + Twine::utohexstr(offset) +\n        \" too big and extends past end of trie data\");\n    moveToEnd();\n    return;\n  }\n  if (State.IsExportNode) {\n    const uint8_t *ExportStart = State.Current;\n    State.Flags = readULEB128(State.Current, &error);\n    if (error) {\n      *E = malformedError(\"flags \" + Twine(error) +\n                          \" in export trie data at node: 0x\" +\n                          Twine::utohexstr(offset));\n      moveToEnd();\n      return;\n    }\n    uint64_t Kind = State.Flags & MachO::EXPORT_SYMBOL_FLAGS_KIND_MASK;\n    if (State.Flags != 0 &&\n        (Kind != MachO::EXPORT_SYMBOL_FLAGS_KIND_REGULAR &&\n         Kind != MachO::EXPORT_SYMBOL_FLAGS_KIND_ABSOLUTE &&\n         Kind != MachO::EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL)) {\n      *E = malformedError(\n          \"unsupported exported symbol kind: \" + Twine((int)Kind) +\n          \" in flags: 0x\" + Twine::utohexstr(State.Flags) +\n          \" in export trie data at node: 0x\" + Twine::utohexstr(offset));\n      moveToEnd();\n      return;\n    }\n    if (State.Flags & MachO::EXPORT_SYMBOL_FLAGS_REEXPORT) {\n      State.Address = 0;\n      State.Other = readULEB128(State.Current, &error); // dylib ordinal\n      if (error) {\n        *E = malformedError(\"dylib ordinal of re-export \" + Twine(error) +\n                            \" in export trie data at node: 0x\" +\n                            Twine::utohexstr(offset));\n        moveToEnd();\n        return;\n      }\n      if (O != nullptr) {\n        if (State.Other > O->getLibraryCount()) {\n          *E = malformedError(\n              \"bad library ordinal: \" + Twine((int)State.Other) + \" (max \" +\n              Twine((int)O->getLibraryCount()) +\n              \") in export trie data at node: 0x\" + Twine::utohexstr(offset));\n          moveToEnd();\n          return;\n        }\n      }\n      State.ImportName = reinterpret_cast<const char*>(State.Current);\n      if (*State.ImportName == '\\0') {\n        State.Current++;\n      } else {\n        const uint8_t *End = State.Current + 1;\n        if (End >= Trie.end()) {\n          *E = malformedError(\"import name of re-export in export trie data at \"\n                              \"node: 0x\" +\n                              Twine::utohexstr(offset) +\n                              \" starts past end of trie data\");\n          moveToEnd();\n          return;\n        }\n        while(*End != '\\0' && End < Trie.end())\n          End++;\n        if (*End != '\\0') {\n          *E = malformedError(\"import name of re-export in export trie data at \"\n                              \"node: 0x\" +\n                              Twine::utohexstr(offset) +\n                              \" extends past end of trie data\");\n          moveToEnd();\n          return;\n        }\n        State.Current = End + 1;\n      }\n    } else {\n      State.Address = readULEB128(State.Current, &error);\n      if (error) {\n        *E = malformedError(\"address \" + Twine(error) +\n                            \" in export trie data at node: 0x\" +\n                            Twine::utohexstr(offset));\n        moveToEnd();\n        return;\n      }\n      if (State.Flags & MachO::EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER) {\n        State.Other = readULEB128(State.Current, &error);\n        if (error) {\n          *E = malformedError(\"resolver of stub and resolver \" + Twine(error) +\n                              \" in export trie data at node: 0x\" +\n                              Twine::utohexstr(offset));\n          moveToEnd();\n          return;\n        }\n      }\n    }\n    if(ExportStart + ExportInfoSize != State.Current) {\n      *E = malformedError(\n          \"inconsistant export info size: 0x\" +\n          Twine::utohexstr(ExportInfoSize) + \" where actual size was: 0x\" +\n          Twine::utohexstr(State.Current - ExportStart) +\n          \" in export trie data at node: 0x\" + Twine::utohexstr(offset));\n      moveToEnd();\n      return;\n    }\n  }\n  State.ChildCount = *Children;\n  if (State.ChildCount != 0 && Children + 1 >= Trie.end()) {\n    *E = malformedError(\"byte for count of childern in export trie data at \"\n                        \"node: 0x\" +\n                        Twine::utohexstr(offset) +\n                        \" extends past end of trie data\");\n    moveToEnd();\n    return;\n  }\n  State.Current = Children + 1;\n  State.NextChildIndex = 0;\n  State.ParentStringLength = CumulativeString.size();\n  Stack.push_back(State);\n}\n\nvoid ExportEntry::pushDownUntilBottom() {\n  ErrorAsOutParameter ErrAsOutParam(E);\n  const char *error;\n  while (Stack.back().NextChildIndex < Stack.back().ChildCount) {\n    NodeState &Top = Stack.back();\n    CumulativeString.resize(Top.ParentStringLength);\n    for (;*Top.Current != 0 && Top.Current < Trie.end(); Top.Current++) {\n      char C = *Top.Current;\n      CumulativeString.push_back(C);\n    }\n    if (Top.Current >= Trie.end()) {\n      *E = malformedError(\"edge sub-string in export trie data at node: 0x\" +\n                          Twine::utohexstr(Top.Start - Trie.begin()) +\n                          \" for child #\" + Twine((int)Top.NextChildIndex) +\n                          \" extends past end of trie data\");\n      moveToEnd();\n      return;\n    }\n    Top.Current += 1;\n    uint64_t childNodeIndex = readULEB128(Top.Current, &error);\n    if (error) {\n      *E = malformedError(\"child node offset \" + Twine(error) +\n                          \" in export trie data at node: 0x\" +\n                          Twine::utohexstr(Top.Start - Trie.begin()));\n      moveToEnd();\n      return;\n    }\n    for (const NodeState &node : nodes()) {\n      if (node.Start == Trie.begin() + childNodeIndex){\n        *E = malformedError(\"loop in childern in export trie data at node: 0x\" +\n                            Twine::utohexstr(Top.Start - Trie.begin()) +\n                            \" back to node: 0x\" +\n                            Twine::utohexstr(childNodeIndex));\n        moveToEnd();\n        return;\n      }\n    }\n    Top.NextChildIndex += 1;\n    pushNode(childNodeIndex);\n    if (*E)\n      return;\n  }\n  if (!Stack.back().IsExportNode) {\n    *E = malformedError(\"node is not an export node in export trie data at \"\n                        \"node: 0x\" +\n                        Twine::utohexstr(Stack.back().Start - Trie.begin()));\n    moveToEnd();\n    return;\n  }\n}\n\n// We have a trie data structure and need a way to walk it that is compatible\n// with the C++ iterator model. The solution is a non-recursive depth first\n// traversal where the iterator contains a stack of parent nodes along with a\n// string that is the accumulation of all edge strings along the parent chain\n// to this point.\n//\n// There is one \"export\" node for each exported symbol.  But because some\n// symbols may be a prefix of another symbol (e.g. _dup and _dup2), an export\n// node may have child nodes too.\n//\n// The algorithm for moveNext() is to keep moving down the leftmost unvisited\n// child until hitting a node with no children (which is an export node or\n// else the trie is malformed). On the way down, each node is pushed on the\n// stack ivar.  If there is no more ways down, it pops up one and tries to go\n// down a sibling path until a childless node is reached.\nvoid ExportEntry::moveNext() {\n  assert(!Stack.empty() && \"ExportEntry::moveNext() with empty node stack\");\n  if (!Stack.back().IsExportNode) {\n    *E = malformedError(\"node is not an export node in export trie data at \"\n                        \"node: 0x\" +\n                        Twine::utohexstr(Stack.back().Start - Trie.begin()));\n    moveToEnd();\n    return;\n  }\n\n  Stack.pop_back();\n  while (!Stack.empty()) {\n    NodeState &Top = Stack.back();\n    if (Top.NextChildIndex < Top.ChildCount) {\n      pushDownUntilBottom();\n      // Now at the next export node.\n      return;\n    } else {\n      if (Top.IsExportNode) {\n        // This node has no children but is itself an export node.\n        CumulativeString.resize(Top.ParentStringLength);\n        return;\n      }\n      Stack.pop_back();\n    }\n  }\n  Done = true;\n}\n\niterator_range<export_iterator>\nMachOObjectFile::exports(Error &E, ArrayRef<uint8_t> Trie,\n                         const MachOObjectFile *O) {\n  ExportEntry Start(&E, O, Trie);\n  if (Trie.empty())\n    Start.moveToEnd();\n  else\n    Start.moveToFirst();\n\n  ExportEntry Finish(&E, O, Trie);\n  Finish.moveToEnd();\n\n  return make_range(export_iterator(Start), export_iterator(Finish));\n}\n\niterator_range<export_iterator> MachOObjectFile::exports(Error &Err) const {\n  return exports(Err, getDyldInfoExportsTrie(), this);\n}\n\nMachORebaseEntry::MachORebaseEntry(Error *E, const MachOObjectFile *O,\n                                   ArrayRef<uint8_t> Bytes, bool is64Bit)\n    : E(E), O(O), Opcodes(Bytes), Ptr(Bytes.begin()),\n      PointerSize(is64Bit ? 8 : 4) {}\n\nvoid MachORebaseEntry::moveToFirst() {\n  Ptr = Opcodes.begin();\n  moveNext();\n}\n\nvoid MachORebaseEntry::moveToEnd() {\n  Ptr = Opcodes.end();\n  RemainingLoopCount = 0;\n  Done = true;\n}\n\nvoid MachORebaseEntry::moveNext() {\n  ErrorAsOutParameter ErrAsOutParam(E);\n  // If in the middle of some loop, move to next rebasing in loop.\n  SegmentOffset += AdvanceAmount;\n  if (RemainingLoopCount) {\n    --RemainingLoopCount;\n    return;\n  }\n  // REBASE_OPCODE_DONE is only used for padding if we are not aligned to\n  // pointer size. Therefore it is possible to reach the end without ever having\n  // seen REBASE_OPCODE_DONE.\n  if (Ptr == Opcodes.end()) {\n    Done = true;\n    return;\n  }\n  bool More = true;\n  while (More) {\n    // Parse next opcode and set up next loop.\n    const uint8_t *OpcodeStart = Ptr;\n    uint8_t Byte = *Ptr++;\n    uint8_t ImmValue = Byte & MachO::REBASE_IMMEDIATE_MASK;\n    uint8_t Opcode = Byte & MachO::REBASE_OPCODE_MASK;\n    uint32_t Count, Skip;\n    const char *error = nullptr;\n    switch (Opcode) {\n    case MachO::REBASE_OPCODE_DONE:\n      More = false;\n      Done = true;\n      moveToEnd();\n      DEBUG_WITH_TYPE(\"mach-o-rebase\", dbgs() << \"REBASE_OPCODE_DONE\\n\");\n      break;\n    case MachO::REBASE_OPCODE_SET_TYPE_IMM:\n      RebaseType = ImmValue;\n      if (RebaseType > MachO::REBASE_TYPE_TEXT_PCREL32) {\n        *E = malformedError(\"for REBASE_OPCODE_SET_TYPE_IMM bad bind type: \" +\n                            Twine((int)RebaseType) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\n          \"mach-o-rebase\",\n          dbgs() << \"REBASE_OPCODE_SET_TYPE_IMM: \"\n                 << \"RebaseType=\" << (int) RebaseType << \"\\n\");\n      break;\n    case MachO::REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n      SegmentIndex = ImmValue;\n      SegmentOffset = readULEB128(&error);\n      if (error) {\n        *E = malformedError(\"for REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      error = O->RebaseEntryCheckSegAndOffsets(SegmentIndex, SegmentOffset,\n                                               PointerSize);\n      if (error) {\n        *E = malformedError(\"for REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\n          \"mach-o-rebase\",\n          dbgs() << \"REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB: \"\n                 << \"SegmentIndex=\" << SegmentIndex << \", \"\n                 << format(\"SegmentOffset=0x%06X\", SegmentOffset)\n                 << \"\\n\");\n      break;\n    case MachO::REBASE_OPCODE_ADD_ADDR_ULEB:\n      SegmentOffset += readULEB128(&error);\n      if (error) {\n        *E = malformedError(\"for REBASE_OPCODE_ADD_ADDR_ULEB \" + Twine(error) +\n                            \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      error = O->RebaseEntryCheckSegAndOffsets(SegmentIndex, SegmentOffset,\n                                               PointerSize);\n      if (error) {\n        *E = malformedError(\"for REBASE_OPCODE_ADD_ADDR_ULEB \" + Twine(error) +\n                            \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\"mach-o-rebase\",\n                      dbgs() << \"REBASE_OPCODE_ADD_ADDR_ULEB: \"\n                             << format(\"SegmentOffset=0x%06X\",\n                                       SegmentOffset) << \"\\n\");\n      break;\n    case MachO::REBASE_OPCODE_ADD_ADDR_IMM_SCALED:\n      SegmentOffset += ImmValue * PointerSize;\n      error = O->RebaseEntryCheckSegAndOffsets(SegmentIndex, SegmentOffset,\n                                               PointerSize);\n      if (error) {\n        *E = malformedError(\"for REBASE_OPCODE_ADD_ADDR_IMM_SCALED \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\"mach-o-rebase\",\n                      dbgs() << \"REBASE_OPCODE_ADD_ADDR_IMM_SCALED: \"\n                             << format(\"SegmentOffset=0x%06X\",\n                                       SegmentOffset) << \"\\n\");\n      break;\n    case MachO::REBASE_OPCODE_DO_REBASE_IMM_TIMES:\n      AdvanceAmount = PointerSize;\n      Skip = 0;\n      Count = ImmValue;\n      if (ImmValue != 0)\n        RemainingLoopCount = ImmValue - 1;\n      else\n        RemainingLoopCount = 0;\n      error = O->RebaseEntryCheckSegAndOffsets(SegmentIndex, SegmentOffset,\n                                               PointerSize, Count, Skip);\n      if (error) {\n        *E = malformedError(\"for REBASE_OPCODE_DO_REBASE_IMM_TIMES \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\n          \"mach-o-rebase\",\n          dbgs() << \"REBASE_OPCODE_DO_REBASE_IMM_TIMES: \"\n                 << format(\"SegmentOffset=0x%06X\", SegmentOffset)\n                 << \", AdvanceAmount=\" << AdvanceAmount\n                 << \", RemainingLoopCount=\" << RemainingLoopCount\n                 << \"\\n\");\n      return;\n    case MachO::REBASE_OPCODE_DO_REBASE_ULEB_TIMES:\n      AdvanceAmount = PointerSize;\n      Skip = 0;\n      Count = readULEB128(&error);\n      if (error) {\n        *E = malformedError(\"for REBASE_OPCODE_DO_REBASE_ULEB_TIMES \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      if (Count != 0)\n        RemainingLoopCount = Count - 1;\n      else\n        RemainingLoopCount = 0;\n      error = O->RebaseEntryCheckSegAndOffsets(SegmentIndex, SegmentOffset,\n                                               PointerSize, Count, Skip);\n      if (error) {\n        *E = malformedError(\"for REBASE_OPCODE_DO_REBASE_ULEB_TIMES \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\n          \"mach-o-rebase\",\n          dbgs() << \"REBASE_OPCODE_DO_REBASE_ULEB_TIMES: \"\n                 << format(\"SegmentOffset=0x%06X\", SegmentOffset)\n                 << \", AdvanceAmount=\" << AdvanceAmount\n                 << \", RemainingLoopCount=\" << RemainingLoopCount\n                 << \"\\n\");\n      return;\n    case MachO::REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB:\n      Skip = readULEB128(&error);\n      if (error) {\n        *E = malformedError(\"for REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      AdvanceAmount = Skip + PointerSize;\n      Count = 1;\n      RemainingLoopCount = 0;\n      error = O->RebaseEntryCheckSegAndOffsets(SegmentIndex, SegmentOffset,\n                                               PointerSize, Count, Skip);\n      if (error) {\n        *E = malformedError(\"for REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\n          \"mach-o-rebase\",\n          dbgs() << \"REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB: \"\n                 << format(\"SegmentOffset=0x%06X\", SegmentOffset)\n                 << \", AdvanceAmount=\" << AdvanceAmount\n                 << \", RemainingLoopCount=\" << RemainingLoopCount\n                 << \"\\n\");\n      return;\n    case MachO::REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB:\n      Count = readULEB128(&error);\n      if (error) {\n        *E = malformedError(\"for REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_\"\n                            \"ULEB \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      if (Count != 0)\n        RemainingLoopCount = Count - 1;\n      else\n        RemainingLoopCount = 0;\n      Skip = readULEB128(&error);\n      if (error) {\n        *E = malformedError(\"for REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_\"\n                            \"ULEB \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      AdvanceAmount = Skip + PointerSize;\n\n      error = O->RebaseEntryCheckSegAndOffsets(SegmentIndex, SegmentOffset,\n                                               PointerSize, Count, Skip);\n      if (error) {\n        *E = malformedError(\"for REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_\"\n                            \"ULEB \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\n          \"mach-o-rebase\",\n          dbgs() << \"REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB: \"\n                 << format(\"SegmentOffset=0x%06X\", SegmentOffset)\n                 << \", AdvanceAmount=\" << AdvanceAmount\n                 << \", RemainingLoopCount=\" << RemainingLoopCount\n                 << \"\\n\");\n      return;\n    default:\n      *E = malformedError(\"bad rebase info (bad opcode value 0x\" +\n                          Twine::utohexstr(Opcode) + \" for opcode at: 0x\" +\n                          Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n      moveToEnd();\n      return;\n    }\n  }\n}\n\nuint64_t MachORebaseEntry::readULEB128(const char **error) {\n  unsigned Count;\n  uint64_t Result = decodeULEB128(Ptr, &Count, Opcodes.end(), error);\n  Ptr += Count;\n  if (Ptr > Opcodes.end())\n    Ptr = Opcodes.end();\n  return Result;\n}\n\nint32_t MachORebaseEntry::segmentIndex() const { return SegmentIndex; }\n\nuint64_t MachORebaseEntry::segmentOffset() const { return SegmentOffset; }\n\nStringRef MachORebaseEntry::typeName() const {\n  switch (RebaseType) {\n  case MachO::REBASE_TYPE_POINTER:\n    return \"pointer\";\n  case MachO::REBASE_TYPE_TEXT_ABSOLUTE32:\n    return \"text abs32\";\n  case MachO::REBASE_TYPE_TEXT_PCREL32:\n    return \"text rel32\";\n  }\n  return \"unknown\";\n}\n\n// For use with the SegIndex of a checked Mach-O Rebase entry\n// to get the segment name.\nStringRef MachORebaseEntry::segmentName() const {\n  return O->BindRebaseSegmentName(SegmentIndex);\n}\n\n// For use with a SegIndex,SegOffset pair from a checked Mach-O Rebase entry\n// to get the section name.\nStringRef MachORebaseEntry::sectionName() const {\n  return O->BindRebaseSectionName(SegmentIndex, SegmentOffset);\n}\n\n// For use with a SegIndex,SegOffset pair from a checked Mach-O Rebase entry\n// to get the address.\nuint64_t MachORebaseEntry::address() const {\n  return O->BindRebaseAddress(SegmentIndex, SegmentOffset);\n}\n\nbool MachORebaseEntry::operator==(const MachORebaseEntry &Other) const {\n#ifdef EXPENSIVE_CHECKS\n  assert(Opcodes == Other.Opcodes && \"compare iterators of different files\");\n#else\n  assert(Opcodes.data() == Other.Opcodes.data() && \"compare iterators of different files\");\n#endif\n  return (Ptr == Other.Ptr) &&\n         (RemainingLoopCount == Other.RemainingLoopCount) &&\n         (Done == Other.Done);\n}\n\niterator_range<rebase_iterator>\nMachOObjectFile::rebaseTable(Error &Err, MachOObjectFile *O,\n                             ArrayRef<uint8_t> Opcodes, bool is64) {\n  if (O->BindRebaseSectionTable == nullptr)\n    O->BindRebaseSectionTable = std::make_unique<BindRebaseSegInfo>(O);\n  MachORebaseEntry Start(&Err, O, Opcodes, is64);\n  Start.moveToFirst();\n\n  MachORebaseEntry Finish(&Err, O, Opcodes, is64);\n  Finish.moveToEnd();\n\n  return make_range(rebase_iterator(Start), rebase_iterator(Finish));\n}\n\niterator_range<rebase_iterator> MachOObjectFile::rebaseTable(Error &Err) {\n  return rebaseTable(Err, this, getDyldInfoRebaseOpcodes(), is64Bit());\n}\n\nMachOBindEntry::MachOBindEntry(Error *E, const MachOObjectFile *O,\n                               ArrayRef<uint8_t> Bytes, bool is64Bit, Kind BK)\n    : E(E), O(O), Opcodes(Bytes), Ptr(Bytes.begin()),\n      PointerSize(is64Bit ? 8 : 4), TableKind(BK) {}\n\nvoid MachOBindEntry::moveToFirst() {\n  Ptr = Opcodes.begin();\n  moveNext();\n}\n\nvoid MachOBindEntry::moveToEnd() {\n  Ptr = Opcodes.end();\n  RemainingLoopCount = 0;\n  Done = true;\n}\n\nvoid MachOBindEntry::moveNext() {\n  ErrorAsOutParameter ErrAsOutParam(E);\n  // If in the middle of some loop, move to next binding in loop.\n  SegmentOffset += AdvanceAmount;\n  if (RemainingLoopCount) {\n    --RemainingLoopCount;\n    return;\n  }\n  // BIND_OPCODE_DONE is only used for padding if we are not aligned to\n  // pointer size. Therefore it is possible to reach the end without ever having\n  // seen BIND_OPCODE_DONE.\n  if (Ptr == Opcodes.end()) {\n    Done = true;\n    return;\n  }\n  bool More = true;\n  while (More) {\n    // Parse next opcode and set up next loop.\n    const uint8_t *OpcodeStart = Ptr;\n    uint8_t Byte = *Ptr++;\n    uint8_t ImmValue = Byte & MachO::BIND_IMMEDIATE_MASK;\n    uint8_t Opcode = Byte & MachO::BIND_OPCODE_MASK;\n    int8_t SignExtended;\n    const uint8_t *SymStart;\n    uint32_t Count, Skip;\n    const char *error = nullptr;\n    switch (Opcode) {\n    case MachO::BIND_OPCODE_DONE:\n      if (TableKind == Kind::Lazy) {\n        // Lazying bindings have a DONE opcode between entries.  Need to ignore\n        // it to advance to next entry.  But need not if this is last entry.\n        bool NotLastEntry = false;\n        for (const uint8_t *P = Ptr; P < Opcodes.end(); ++P) {\n          if (*P) {\n            NotLastEntry = true;\n          }\n        }\n        if (NotLastEntry)\n          break;\n      }\n      More = false;\n      moveToEnd();\n      DEBUG_WITH_TYPE(\"mach-o-bind\", dbgs() << \"BIND_OPCODE_DONE\\n\");\n      break;\n    case MachO::BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n      if (TableKind == Kind::Weak) {\n        *E = malformedError(\"BIND_OPCODE_SET_DYLIB_ORDINAL_IMM not allowed in \"\n                            \"weak bind table for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      Ordinal = ImmValue;\n      LibraryOrdinalSet = true;\n      if (ImmValue > O->getLibraryCount()) {\n        *E = malformedError(\"for BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB bad \"\n                            \"library ordinal: \" +\n                            Twine((int)ImmValue) + \" (max \" +\n                            Twine((int)O->getLibraryCount()) +\n                            \") for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\n          \"mach-o-bind\",\n          dbgs() << \"BIND_OPCODE_SET_DYLIB_ORDINAL_IMM: \"\n                 << \"Ordinal=\" << Ordinal << \"\\n\");\n      break;\n    case MachO::BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n      if (TableKind == Kind::Weak) {\n        *E = malformedError(\"BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB not allowed in \"\n                            \"weak bind table for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      Ordinal = readULEB128(&error);\n      LibraryOrdinalSet = true;\n      if (error) {\n        *E = malformedError(\"for BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      if (Ordinal > (int)O->getLibraryCount()) {\n        *E = malformedError(\"for BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB bad \"\n                            \"library ordinal: \" +\n                            Twine((int)Ordinal) + \" (max \" +\n                            Twine((int)O->getLibraryCount()) +\n                            \") for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\n          \"mach-o-bind\",\n          dbgs() << \"BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB: \"\n                 << \"Ordinal=\" << Ordinal << \"\\n\");\n      break;\n    case MachO::BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n      if (TableKind == Kind::Weak) {\n        *E = malformedError(\"BIND_OPCODE_SET_DYLIB_SPECIAL_IMM not allowed in \"\n                            \"weak bind table for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      if (ImmValue) {\n        SignExtended = MachO::BIND_OPCODE_MASK | ImmValue;\n        Ordinal = SignExtended;\n        if (Ordinal < MachO::BIND_SPECIAL_DYLIB_FLAT_LOOKUP) {\n          *E = malformedError(\"for BIND_OPCODE_SET_DYLIB_SPECIAL_IMM unknown \"\n                              \"special ordinal: \" +\n                              Twine((int)Ordinal) + \" for opcode at: 0x\" +\n                              Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n          moveToEnd();\n          return;\n        }\n      } else\n        Ordinal = 0;\n      LibraryOrdinalSet = true;\n      DEBUG_WITH_TYPE(\n          \"mach-o-bind\",\n          dbgs() << \"BIND_OPCODE_SET_DYLIB_SPECIAL_IMM: \"\n                 << \"Ordinal=\" << Ordinal << \"\\n\");\n      break;\n    case MachO::BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:\n      Flags = ImmValue;\n      SymStart = Ptr;\n      while (*Ptr && (Ptr < Opcodes.end())) {\n        ++Ptr;\n      }\n      if (Ptr == Opcodes.end()) {\n        *E = malformedError(\n            \"for BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM \"\n            \"symbol name extends past opcodes for opcode at: 0x\" +\n            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      SymbolName = StringRef(reinterpret_cast<const char*>(SymStart),\n                             Ptr-SymStart);\n      ++Ptr;\n      DEBUG_WITH_TYPE(\n          \"mach-o-bind\",\n          dbgs() << \"BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM: \"\n                 << \"SymbolName=\" << SymbolName << \"\\n\");\n      if (TableKind == Kind::Weak) {\n        if (ImmValue & MachO::BIND_SYMBOL_FLAGS_NON_WEAK_DEFINITION)\n          return;\n      }\n      break;\n    case MachO::BIND_OPCODE_SET_TYPE_IMM:\n      BindType = ImmValue;\n      if (ImmValue > MachO::BIND_TYPE_TEXT_PCREL32) {\n        *E = malformedError(\"for BIND_OPCODE_SET_TYPE_IMM bad bind type: \" +\n                            Twine((int)ImmValue) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\n          \"mach-o-bind\",\n          dbgs() << \"BIND_OPCODE_SET_TYPE_IMM: \"\n                 << \"BindType=\" << (int)BindType << \"\\n\");\n      break;\n    case MachO::BIND_OPCODE_SET_ADDEND_SLEB:\n      Addend = readSLEB128(&error);\n      if (error) {\n        *E = malformedError(\"for BIND_OPCODE_SET_ADDEND_SLEB \" + Twine(error) +\n                            \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\n          \"mach-o-bind\",\n          dbgs() << \"BIND_OPCODE_SET_ADDEND_SLEB: \"\n                 << \"Addend=\" << Addend << \"\\n\");\n      break;\n    case MachO::BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n      SegmentIndex = ImmValue;\n      SegmentOffset = readULEB128(&error);\n      if (error) {\n        *E = malformedError(\"for BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      error = O->BindEntryCheckSegAndOffsets(SegmentIndex, SegmentOffset,\n                                             PointerSize);\n      if (error) {\n        *E = malformedError(\"for BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\n          \"mach-o-bind\",\n          dbgs() << \"BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB: \"\n                 << \"SegmentIndex=\" << SegmentIndex << \", \"\n                 << format(\"SegmentOffset=0x%06X\", SegmentOffset)\n                 << \"\\n\");\n      break;\n    case MachO::BIND_OPCODE_ADD_ADDR_ULEB:\n      SegmentOffset += readULEB128(&error);\n      if (error) {\n        *E = malformedError(\"for BIND_OPCODE_ADD_ADDR_ULEB \" + Twine(error) +\n                            \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      error = O->BindEntryCheckSegAndOffsets(SegmentIndex, SegmentOffset,\n                                             PointerSize);\n      if (error) {\n        *E = malformedError(\"for BIND_OPCODE_ADD_ADDR_ULEB \" + Twine(error) +\n                            \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\"mach-o-bind\",\n                      dbgs() << \"BIND_OPCODE_ADD_ADDR_ULEB: \"\n                             << format(\"SegmentOffset=0x%06X\",\n                                       SegmentOffset) << \"\\n\");\n      break;\n    case MachO::BIND_OPCODE_DO_BIND:\n      AdvanceAmount = PointerSize;\n      RemainingLoopCount = 0;\n      error = O->BindEntryCheckSegAndOffsets(SegmentIndex, SegmentOffset,\n                                             PointerSize);\n      if (error) {\n        *E = malformedError(\"for BIND_OPCODE_DO_BIND \" + Twine(error) +\n                            \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      if (SymbolName == StringRef()) {\n        *E = malformedError(\n            \"for BIND_OPCODE_DO_BIND missing preceding \"\n            \"BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM for opcode at: 0x\" +\n            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      if (!LibraryOrdinalSet && TableKind != Kind::Weak) {\n        *E =\n            malformedError(\"for BIND_OPCODE_DO_BIND missing preceding \"\n                           \"BIND_OPCODE_SET_DYLIB_ORDINAL_* for opcode at: 0x\" +\n                           Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\"mach-o-bind\",\n                      dbgs() << \"BIND_OPCODE_DO_BIND: \"\n                             << format(\"SegmentOffset=0x%06X\",\n                                       SegmentOffset) << \"\\n\");\n      return;\n     case MachO::BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n      if (TableKind == Kind::Lazy) {\n        *E = malformedError(\"BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB not allowed in \"\n                            \"lazy bind table for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      error = O->BindEntryCheckSegAndOffsets(SegmentIndex, SegmentOffset,\n                                             PointerSize);\n      if (error) {\n        *E = malformedError(\"for BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      if (SymbolName == StringRef()) {\n        *E = malformedError(\n            \"for BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB missing \"\n            \"preceding BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM for opcode \"\n            \"at: 0x\" +\n            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      if (!LibraryOrdinalSet && TableKind != Kind::Weak) {\n        *E = malformedError(\n            \"for BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB missing \"\n            \"preceding BIND_OPCODE_SET_DYLIB_ORDINAL_* for opcode at: 0x\" +\n            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      AdvanceAmount = readULEB128(&error) + PointerSize;\n      if (error) {\n        *E = malformedError(\"for BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      // Note, this is not really an error until the next bind but make no sense\n      // for a BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB to not be followed by another\n      // bind operation.\n      error = O->BindEntryCheckSegAndOffsets(SegmentIndex, SegmentOffset +\n                                            AdvanceAmount, PointerSize);\n      if (error) {\n        *E = malformedError(\"for BIND_OPCODE_ADD_ADDR_ULEB (after adding \"\n                            \"ULEB) \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      RemainingLoopCount = 0;\n      DEBUG_WITH_TYPE(\n          \"mach-o-bind\",\n          dbgs() << \"BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB: \"\n                 << format(\"SegmentOffset=0x%06X\", SegmentOffset)\n                 << \", AdvanceAmount=\" << AdvanceAmount\n                 << \", RemainingLoopCount=\" << RemainingLoopCount\n                 << \"\\n\");\n      return;\n    case MachO::BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n      if (TableKind == Kind::Lazy) {\n        *E = malformedError(\"BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED not \"\n                            \"allowed in lazy bind table for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      if (SymbolName == StringRef()) {\n        *E = malformedError(\n            \"for BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED \"\n            \"missing preceding BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM for \"\n            \"opcode at: 0x\" +\n            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      if (!LibraryOrdinalSet && TableKind != Kind::Weak) {\n        *E = malformedError(\n            \"for BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED \"\n            \"missing preceding BIND_OPCODE_SET_DYLIB_ORDINAL_* for opcode \"\n            \"at: 0x\" +\n            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      AdvanceAmount = ImmValue * PointerSize + PointerSize;\n      RemainingLoopCount = 0;\n      error = O->BindEntryCheckSegAndOffsets(SegmentIndex, SegmentOffset +\n                                             AdvanceAmount, PointerSize);\n      if (error) {\n        *E = malformedError(\"for BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\"mach-o-bind\",\n                      dbgs()\n                      << \"BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED: \"\n                      << format(\"SegmentOffset=0x%06X\", SegmentOffset) << \"\\n\");\n      return;\n    case MachO::BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n      if (TableKind == Kind::Lazy) {\n        *E = malformedError(\"BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB not \"\n                            \"allowed in lazy bind table for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      Count = readULEB128(&error);\n      if (Count != 0)\n        RemainingLoopCount = Count - 1;\n      else\n        RemainingLoopCount = 0;\n      if (error) {\n        *E = malformedError(\"for BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB \"\n                            \" (count value) \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      Skip = readULEB128(&error);\n      AdvanceAmount = Skip + PointerSize;\n      if (error) {\n        *E = malformedError(\"for BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB \"\n                            \" (skip value) \" +\n                            Twine(error) + \" for opcode at: 0x\" +\n                            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      if (SymbolName == StringRef()) {\n        *E = malformedError(\n            \"for BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB \"\n            \"missing preceding BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM for \"\n            \"opcode at: 0x\" +\n            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      if (!LibraryOrdinalSet && TableKind != Kind::Weak) {\n        *E = malformedError(\n            \"for BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB \"\n            \"missing preceding BIND_OPCODE_SET_DYLIB_ORDINAL_* for opcode \"\n            \"at: 0x\" +\n            Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      error = O->BindEntryCheckSegAndOffsets(SegmentIndex, SegmentOffset,\n                                             PointerSize, Count, Skip);\n      if (error) {\n        *E =\n            malformedError(\"for BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB \" +\n                           Twine(error) + \" for opcode at: 0x\" +\n                           Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n        moveToEnd();\n        return;\n      }\n      DEBUG_WITH_TYPE(\n          \"mach-o-bind\",\n          dbgs() << \"BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB: \"\n                 << format(\"SegmentOffset=0x%06X\", SegmentOffset)\n                 << \", AdvanceAmount=\" << AdvanceAmount\n                 << \", RemainingLoopCount=\" << RemainingLoopCount\n                 << \"\\n\");\n      return;\n    default:\n      *E = malformedError(\"bad bind info (bad opcode value 0x\" +\n                          Twine::utohexstr(Opcode) + \" for opcode at: 0x\" +\n                          Twine::utohexstr(OpcodeStart - Opcodes.begin()));\n      moveToEnd();\n      return;\n    }\n  }\n}\n\nuint64_t MachOBindEntry::readULEB128(const char **error) {\n  unsigned Count;\n  uint64_t Result = decodeULEB128(Ptr, &Count, Opcodes.end(), error);\n  Ptr += Count;\n  if (Ptr > Opcodes.end())\n    Ptr = Opcodes.end();\n  return Result;\n}\n\nint64_t MachOBindEntry::readSLEB128(const char **error) {\n  unsigned Count;\n  int64_t Result = decodeSLEB128(Ptr, &Count, Opcodes.end(), error);\n  Ptr += Count;\n  if (Ptr > Opcodes.end())\n    Ptr = Opcodes.end();\n  return Result;\n}\n\nint32_t MachOBindEntry::segmentIndex() const { return SegmentIndex; }\n\nuint64_t MachOBindEntry::segmentOffset() const { return SegmentOffset; }\n\nStringRef MachOBindEntry::typeName() const {\n  switch (BindType) {\n  case MachO::BIND_TYPE_POINTER:\n    return \"pointer\";\n  case MachO::BIND_TYPE_TEXT_ABSOLUTE32:\n    return \"text abs32\";\n  case MachO::BIND_TYPE_TEXT_PCREL32:\n    return \"text rel32\";\n  }\n  return \"unknown\";\n}\n\nStringRef MachOBindEntry::symbolName() const { return SymbolName; }\n\nint64_t MachOBindEntry::addend() const { return Addend; }\n\nuint32_t MachOBindEntry::flags() const { return Flags; }\n\nint MachOBindEntry::ordinal() const { return Ordinal; }\n\n// For use with the SegIndex of a checked Mach-O Bind entry\n// to get the segment name.\nStringRef MachOBindEntry::segmentName() const {\n  return O->BindRebaseSegmentName(SegmentIndex);\n}\n\n// For use with a SegIndex,SegOffset pair from a checked Mach-O Bind entry\n// to get the section name.\nStringRef MachOBindEntry::sectionName() const {\n  return O->BindRebaseSectionName(SegmentIndex, SegmentOffset);\n}\n\n// For use with a SegIndex,SegOffset pair from a checked Mach-O Bind entry\n// to get the address.\nuint64_t MachOBindEntry::address() const {\n  return O->BindRebaseAddress(SegmentIndex, SegmentOffset);\n}\n\nbool MachOBindEntry::operator==(const MachOBindEntry &Other) const {\n#ifdef EXPENSIVE_CHECKS\n  assert(Opcodes == Other.Opcodes && \"compare iterators of different files\");\n#else\n  assert(Opcodes.data() == Other.Opcodes.data() && \"compare iterators of different files\");\n#endif\n  return (Ptr == Other.Ptr) &&\n         (RemainingLoopCount == Other.RemainingLoopCount) &&\n         (Done == Other.Done);\n}\n\n// Build table of sections so SegIndex/SegOffset pairs can be translated.\nBindRebaseSegInfo::BindRebaseSegInfo(const object::MachOObjectFile *Obj) {\n  uint32_t CurSegIndex = Obj->hasPageZeroSegment() ? 1 : 0;\n  StringRef CurSegName;\n  uint64_t CurSegAddress;\n  for (const SectionRef &Section : Obj->sections()) {\n    SectionInfo Info;\n    Expected<StringRef> NameOrErr = Section.getName();\n    if (!NameOrErr)\n      consumeError(NameOrErr.takeError());\n    else\n      Info.SectionName = *NameOrErr;\n    Info.Address = Section.getAddress();\n    Info.Size = Section.getSize();\n    Info.SegmentName =\n        Obj->getSectionFinalSegmentName(Section.getRawDataRefImpl());\n    if (!Info.SegmentName.equals(CurSegName)) {\n      ++CurSegIndex;\n      CurSegName = Info.SegmentName;\n      CurSegAddress = Info.Address;\n    }\n    Info.SegmentIndex = CurSegIndex - 1;\n    Info.OffsetInSegment = Info.Address - CurSegAddress;\n    Info.SegmentStartAddress = CurSegAddress;\n    Sections.push_back(Info);\n  }\n  MaxSegIndex = CurSegIndex;\n}\n\n// For use with a SegIndex, SegOffset, and PointerSize triple in\n// MachOBindEntry::moveNext() to validate a MachOBindEntry or MachORebaseEntry.\n//\n// Given a SegIndex, SegOffset, and PointerSize, verify a valid section exists\n// that fully contains a pointer at that location. Multiple fixups in a bind\n// (such as with the BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB opcode) can\n// be tested via the Count and Skip parameters.\nconst char * BindRebaseSegInfo::checkSegAndOffsets(int32_t SegIndex,\n                                                   uint64_t SegOffset,\n                                                   uint8_t PointerSize,\n                                                   uint32_t Count,\n                                                   uint32_t Skip) {\n  if (SegIndex == -1)\n    return \"missing preceding *_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\";\n  if (SegIndex >= MaxSegIndex)\n    return \"bad segIndex (too large)\";\n  for (uint32_t i = 0; i < Count; ++i) {\n    uint32_t Start = SegOffset + i * (PointerSize + Skip);\n    uint32_t End = Start + PointerSize;\n    bool Found = false;\n    for (const SectionInfo &SI : Sections) {\n      if (SI.SegmentIndex != SegIndex)\n        continue;\n      if ((SI.OffsetInSegment<=Start) && (Start<(SI.OffsetInSegment+SI.Size))) {\n        if (End <= SI.OffsetInSegment + SI.Size) {\n          Found = true;\n          break;\n        }\n        else\n          return \"bad offset, extends beyond section boundary\";\n      }\n    }\n    if (!Found)\n      return \"bad offset, not in section\";\n  }\n  return nullptr;\n}\n\n// For use with the SegIndex of a checked Mach-O Bind or Rebase entry\n// to get the segment name.\nStringRef BindRebaseSegInfo::segmentName(int32_t SegIndex) {\n  for (const SectionInfo &SI : Sections) {\n    if (SI.SegmentIndex == SegIndex)\n      return SI.SegmentName;\n  }\n  llvm_unreachable(\"invalid SegIndex\");\n}\n\n// For use with a SegIndex,SegOffset pair from a checked Mach-O Bind or Rebase\n// to get the SectionInfo.\nconst BindRebaseSegInfo::SectionInfo &BindRebaseSegInfo::findSection(\n                                     int32_t SegIndex, uint64_t SegOffset) {\n  for (const SectionInfo &SI : Sections) {\n    if (SI.SegmentIndex != SegIndex)\n      continue;\n    if (SI.OffsetInSegment > SegOffset)\n      continue;\n    if (SegOffset >= (SI.OffsetInSegment + SI.Size))\n      continue;\n    return SI;\n  }\n  llvm_unreachable(\"SegIndex and SegOffset not in any section\");\n}\n\n// For use with a SegIndex,SegOffset pair from a checked Mach-O Bind or Rebase\n// entry to get the section name.\nStringRef BindRebaseSegInfo::sectionName(int32_t SegIndex,\n                                         uint64_t SegOffset) {\n  return findSection(SegIndex, SegOffset).SectionName;\n}\n\n// For use with a SegIndex,SegOffset pair from a checked Mach-O Bind or Rebase\n// entry to get the address.\nuint64_t BindRebaseSegInfo::address(uint32_t SegIndex, uint64_t OffsetInSeg) {\n  const SectionInfo &SI = findSection(SegIndex, OffsetInSeg);\n  return SI.SegmentStartAddress + OffsetInSeg;\n}\n\niterator_range<bind_iterator>\nMachOObjectFile::bindTable(Error &Err, MachOObjectFile *O,\n                           ArrayRef<uint8_t> Opcodes, bool is64,\n                           MachOBindEntry::Kind BKind) {\n  if (O->BindRebaseSectionTable == nullptr)\n    O->BindRebaseSectionTable = std::make_unique<BindRebaseSegInfo>(O);\n  MachOBindEntry Start(&Err, O, Opcodes, is64, BKind);\n  Start.moveToFirst();\n\n  MachOBindEntry Finish(&Err, O, Opcodes, is64, BKind);\n  Finish.moveToEnd();\n\n  return make_range(bind_iterator(Start), bind_iterator(Finish));\n}\n\niterator_range<bind_iterator> MachOObjectFile::bindTable(Error &Err) {\n  return bindTable(Err, this, getDyldInfoBindOpcodes(), is64Bit(),\n                   MachOBindEntry::Kind::Regular);\n}\n\niterator_range<bind_iterator> MachOObjectFile::lazyBindTable(Error &Err) {\n  return bindTable(Err, this, getDyldInfoLazyBindOpcodes(), is64Bit(),\n                   MachOBindEntry::Kind::Lazy);\n}\n\niterator_range<bind_iterator> MachOObjectFile::weakBindTable(Error &Err) {\n  return bindTable(Err, this, getDyldInfoWeakBindOpcodes(), is64Bit(),\n                   MachOBindEntry::Kind::Weak);\n}\n\nMachOObjectFile::load_command_iterator\nMachOObjectFile::begin_load_commands() const {\n  return LoadCommands.begin();\n}\n\nMachOObjectFile::load_command_iterator\nMachOObjectFile::end_load_commands() const {\n  return LoadCommands.end();\n}\n\niterator_range<MachOObjectFile::load_command_iterator>\nMachOObjectFile::load_commands() const {\n  return make_range(begin_load_commands(), end_load_commands());\n}\n\nStringRef\nMachOObjectFile::getSectionFinalSegmentName(DataRefImpl Sec) const {\n  ArrayRef<char> Raw = getSectionRawFinalSegmentName(Sec);\n  return parseSegmentOrSectionName(Raw.data());\n}\n\nArrayRef<char>\nMachOObjectFile::getSectionRawName(DataRefImpl Sec) const {\n  assert(Sec.d.a < Sections.size() && \"Should have detected this earlier\");\n  const section_base *Base =\n    reinterpret_cast<const section_base *>(Sections[Sec.d.a]);\n  return makeArrayRef(Base->sectname);\n}\n\nArrayRef<char>\nMachOObjectFile::getSectionRawFinalSegmentName(DataRefImpl Sec) const {\n  assert(Sec.d.a < Sections.size() && \"Should have detected this earlier\");\n  const section_base *Base =\n    reinterpret_cast<const section_base *>(Sections[Sec.d.a]);\n  return makeArrayRef(Base->segname);\n}\n\nbool\nMachOObjectFile::isRelocationScattered(const MachO::any_relocation_info &RE)\n  const {\n  if (getCPUType(*this) == MachO::CPU_TYPE_X86_64)\n    return false;\n  return getPlainRelocationAddress(RE) & MachO::R_SCATTERED;\n}\n\nunsigned MachOObjectFile::getPlainRelocationSymbolNum(\n    const MachO::any_relocation_info &RE) const {\n  if (isLittleEndian())\n    return RE.r_word1 & 0xffffff;\n  return RE.r_word1 >> 8;\n}\n\nbool MachOObjectFile::getPlainRelocationExternal(\n    const MachO::any_relocation_info &RE) const {\n  if (isLittleEndian())\n    return (RE.r_word1 >> 27) & 1;\n  return (RE.r_word1 >> 4) & 1;\n}\n\nbool MachOObjectFile::getScatteredRelocationScattered(\n    const MachO::any_relocation_info &RE) const {\n  return RE.r_word0 >> 31;\n}\n\nuint32_t MachOObjectFile::getScatteredRelocationValue(\n    const MachO::any_relocation_info &RE) const {\n  return RE.r_word1;\n}\n\nuint32_t MachOObjectFile::getScatteredRelocationType(\n    const MachO::any_relocation_info &RE) const {\n  return (RE.r_word0 >> 24) & 0xf;\n}\n\nunsigned MachOObjectFile::getAnyRelocationAddress(\n    const MachO::any_relocation_info &RE) const {\n  if (isRelocationScattered(RE))\n    return getScatteredRelocationAddress(RE);\n  return getPlainRelocationAddress(RE);\n}\n\nunsigned MachOObjectFile::getAnyRelocationPCRel(\n    const MachO::any_relocation_info &RE) const {\n  if (isRelocationScattered(RE))\n    return getScatteredRelocationPCRel(RE);\n  return getPlainRelocationPCRel(*this, RE);\n}\n\nunsigned MachOObjectFile::getAnyRelocationLength(\n    const MachO::any_relocation_info &RE) const {\n  if (isRelocationScattered(RE))\n    return getScatteredRelocationLength(RE);\n  return getPlainRelocationLength(*this, RE);\n}\n\nunsigned\nMachOObjectFile::getAnyRelocationType(\n                                   const MachO::any_relocation_info &RE) const {\n  if (isRelocationScattered(RE))\n    return getScatteredRelocationType(RE);\n  return getPlainRelocationType(*this, RE);\n}\n\nSectionRef\nMachOObjectFile::getAnyRelocationSection(\n                                   const MachO::any_relocation_info &RE) const {\n  if (isRelocationScattered(RE) || getPlainRelocationExternal(RE))\n    return *section_end();\n  unsigned SecNum = getPlainRelocationSymbolNum(RE);\n  if (SecNum == MachO::R_ABS || SecNum > Sections.size())\n    return *section_end();\n  DataRefImpl DRI;\n  DRI.d.a = SecNum - 1;\n  return SectionRef(DRI, this);\n}\n\nMachO::section MachOObjectFile::getSection(DataRefImpl DRI) const {\n  assert(DRI.d.a < Sections.size() && \"Should have detected this earlier\");\n  return getStruct<MachO::section>(*this, Sections[DRI.d.a]);\n}\n\nMachO::section_64 MachOObjectFile::getSection64(DataRefImpl DRI) const {\n  assert(DRI.d.a < Sections.size() && \"Should have detected this earlier\");\n  return getStruct<MachO::section_64>(*this, Sections[DRI.d.a]);\n}\n\nMachO::section MachOObjectFile::getSection(const LoadCommandInfo &L,\n                                           unsigned Index) const {\n  const char *Sec = getSectionPtr(*this, L, Index);\n  return getStruct<MachO::section>(*this, Sec);\n}\n\nMachO::section_64 MachOObjectFile::getSection64(const LoadCommandInfo &L,\n                                                unsigned Index) const {\n  const char *Sec = getSectionPtr(*this, L, Index);\n  return getStruct<MachO::section_64>(*this, Sec);\n}\n\nMachO::nlist\nMachOObjectFile::getSymbolTableEntry(DataRefImpl DRI) const {\n  const char *P = reinterpret_cast<const char *>(DRI.p);\n  return getStruct<MachO::nlist>(*this, P);\n}\n\nMachO::nlist_64\nMachOObjectFile::getSymbol64TableEntry(DataRefImpl DRI) const {\n  const char *P = reinterpret_cast<const char *>(DRI.p);\n  return getStruct<MachO::nlist_64>(*this, P);\n}\n\nMachO::linkedit_data_command\nMachOObjectFile::getLinkeditDataLoadCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::linkedit_data_command>(*this, L.Ptr);\n}\n\nMachO::segment_command\nMachOObjectFile::getSegmentLoadCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::segment_command>(*this, L.Ptr);\n}\n\nMachO::segment_command_64\nMachOObjectFile::getSegment64LoadCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::segment_command_64>(*this, L.Ptr);\n}\n\nMachO::linker_option_command\nMachOObjectFile::getLinkerOptionLoadCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::linker_option_command>(*this, L.Ptr);\n}\n\nMachO::version_min_command\nMachOObjectFile::getVersionMinLoadCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::version_min_command>(*this, L.Ptr);\n}\n\nMachO::note_command\nMachOObjectFile::getNoteLoadCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::note_command>(*this, L.Ptr);\n}\n\nMachO::build_version_command\nMachOObjectFile::getBuildVersionLoadCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::build_version_command>(*this, L.Ptr);\n}\n\nMachO::build_tool_version\nMachOObjectFile::getBuildToolVersion(unsigned index) const {\n  return getStruct<MachO::build_tool_version>(*this, BuildTools[index]);\n}\n\nMachO::dylib_command\nMachOObjectFile::getDylibIDLoadCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::dylib_command>(*this, L.Ptr);\n}\n\nMachO::dyld_info_command\nMachOObjectFile::getDyldInfoLoadCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::dyld_info_command>(*this, L.Ptr);\n}\n\nMachO::dylinker_command\nMachOObjectFile::getDylinkerCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::dylinker_command>(*this, L.Ptr);\n}\n\nMachO::uuid_command\nMachOObjectFile::getUuidCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::uuid_command>(*this, L.Ptr);\n}\n\nMachO::rpath_command\nMachOObjectFile::getRpathCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::rpath_command>(*this, L.Ptr);\n}\n\nMachO::source_version_command\nMachOObjectFile::getSourceVersionCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::source_version_command>(*this, L.Ptr);\n}\n\nMachO::entry_point_command\nMachOObjectFile::getEntryPointCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::entry_point_command>(*this, L.Ptr);\n}\n\nMachO::encryption_info_command\nMachOObjectFile::getEncryptionInfoCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::encryption_info_command>(*this, L.Ptr);\n}\n\nMachO::encryption_info_command_64\nMachOObjectFile::getEncryptionInfoCommand64(const LoadCommandInfo &L) const {\n  return getStruct<MachO::encryption_info_command_64>(*this, L.Ptr);\n}\n\nMachO::sub_framework_command\nMachOObjectFile::getSubFrameworkCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::sub_framework_command>(*this, L.Ptr);\n}\n\nMachO::sub_umbrella_command\nMachOObjectFile::getSubUmbrellaCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::sub_umbrella_command>(*this, L.Ptr);\n}\n\nMachO::sub_library_command\nMachOObjectFile::getSubLibraryCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::sub_library_command>(*this, L.Ptr);\n}\n\nMachO::sub_client_command\nMachOObjectFile::getSubClientCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::sub_client_command>(*this, L.Ptr);\n}\n\nMachO::routines_command\nMachOObjectFile::getRoutinesCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::routines_command>(*this, L.Ptr);\n}\n\nMachO::routines_command_64\nMachOObjectFile::getRoutinesCommand64(const LoadCommandInfo &L) const {\n  return getStruct<MachO::routines_command_64>(*this, L.Ptr);\n}\n\nMachO::thread_command\nMachOObjectFile::getThreadCommand(const LoadCommandInfo &L) const {\n  return getStruct<MachO::thread_command>(*this, L.Ptr);\n}\n\nMachO::any_relocation_info\nMachOObjectFile::getRelocation(DataRefImpl Rel) const {\n  uint32_t Offset;\n  if (getHeader().filetype == MachO::MH_OBJECT) {\n    DataRefImpl Sec;\n    Sec.d.a = Rel.d.a;\n    if (is64Bit()) {\n      MachO::section_64 Sect = getSection64(Sec);\n      Offset = Sect.reloff;\n    } else {\n      MachO::section Sect = getSection(Sec);\n      Offset = Sect.reloff;\n    }\n  } else {\n    MachO::dysymtab_command DysymtabLoadCmd = getDysymtabLoadCommand();\n    if (Rel.d.a == 0)\n      Offset = DysymtabLoadCmd.extreloff; // Offset to the external relocations\n    else\n      Offset = DysymtabLoadCmd.locreloff; // Offset to the local relocations\n  }\n\n  auto P = reinterpret_cast<const MachO::any_relocation_info *>(\n      getPtr(*this, Offset)) + Rel.d.b;\n  return getStruct<MachO::any_relocation_info>(\n      *this, reinterpret_cast<const char *>(P));\n}\n\nMachO::data_in_code_entry\nMachOObjectFile::getDice(DataRefImpl Rel) const {\n  const char *P = reinterpret_cast<const char *>(Rel.p);\n  return getStruct<MachO::data_in_code_entry>(*this, P);\n}\n\nconst MachO::mach_header &MachOObjectFile::getHeader() const {\n  return Header;\n}\n\nconst MachO::mach_header_64 &MachOObjectFile::getHeader64() const {\n  assert(is64Bit());\n  return Header64;\n}\n\nuint32_t MachOObjectFile::getIndirectSymbolTableEntry(\n                                             const MachO::dysymtab_command &DLC,\n                                             unsigned Index) const {\n  uint64_t Offset = DLC.indirectsymoff + Index * sizeof(uint32_t);\n  return getStruct<uint32_t>(*this, getPtr(*this, Offset));\n}\n\nMachO::data_in_code_entry\nMachOObjectFile::getDataInCodeTableEntry(uint32_t DataOffset,\n                                         unsigned Index) const {\n  uint64_t Offset = DataOffset + Index * sizeof(MachO::data_in_code_entry);\n  return getStruct<MachO::data_in_code_entry>(*this, getPtr(*this, Offset));\n}\n\nMachO::symtab_command MachOObjectFile::getSymtabLoadCommand() const {\n  if (SymtabLoadCmd)\n    return getStruct<MachO::symtab_command>(*this, SymtabLoadCmd);\n\n  // If there is no SymtabLoadCmd return a load command with zero'ed fields.\n  MachO::symtab_command Cmd;\n  Cmd.cmd = MachO::LC_SYMTAB;\n  Cmd.cmdsize = sizeof(MachO::symtab_command);\n  Cmd.symoff = 0;\n  Cmd.nsyms = 0;\n  Cmd.stroff = 0;\n  Cmd.strsize = 0;\n  return Cmd;\n}\n\nMachO::dysymtab_command MachOObjectFile::getDysymtabLoadCommand() const {\n  if (DysymtabLoadCmd)\n    return getStruct<MachO::dysymtab_command>(*this, DysymtabLoadCmd);\n\n  // If there is no DysymtabLoadCmd return a load command with zero'ed fields.\n  MachO::dysymtab_command Cmd;\n  Cmd.cmd = MachO::LC_DYSYMTAB;\n  Cmd.cmdsize = sizeof(MachO::dysymtab_command);\n  Cmd.ilocalsym = 0;\n  Cmd.nlocalsym = 0;\n  Cmd.iextdefsym = 0;\n  Cmd.nextdefsym = 0;\n  Cmd.iundefsym = 0;\n  Cmd.nundefsym = 0;\n  Cmd.tocoff = 0;\n  Cmd.ntoc = 0;\n  Cmd.modtaboff = 0;\n  Cmd.nmodtab = 0;\n  Cmd.extrefsymoff = 0;\n  Cmd.nextrefsyms = 0;\n  Cmd.indirectsymoff = 0;\n  Cmd.nindirectsyms = 0;\n  Cmd.extreloff = 0;\n  Cmd.nextrel = 0;\n  Cmd.locreloff = 0;\n  Cmd.nlocrel = 0;\n  return Cmd;\n}\n\nMachO::linkedit_data_command\nMachOObjectFile::getDataInCodeLoadCommand() const {\n  if (DataInCodeLoadCmd)\n    return getStruct<MachO::linkedit_data_command>(*this, DataInCodeLoadCmd);\n\n  // If there is no DataInCodeLoadCmd return a load command with zero'ed fields.\n  MachO::linkedit_data_command Cmd;\n  Cmd.cmd = MachO::LC_DATA_IN_CODE;\n  Cmd.cmdsize = sizeof(MachO::linkedit_data_command);\n  Cmd.dataoff = 0;\n  Cmd.datasize = 0;\n  return Cmd;\n}\n\nMachO::linkedit_data_command\nMachOObjectFile::getLinkOptHintsLoadCommand() const {\n  if (LinkOptHintsLoadCmd)\n    return getStruct<MachO::linkedit_data_command>(*this, LinkOptHintsLoadCmd);\n\n  // If there is no LinkOptHintsLoadCmd return a load command with zero'ed\n  // fields.\n  MachO::linkedit_data_command Cmd;\n  Cmd.cmd = MachO::LC_LINKER_OPTIMIZATION_HINT;\n  Cmd.cmdsize = sizeof(MachO::linkedit_data_command);\n  Cmd.dataoff = 0;\n  Cmd.datasize = 0;\n  return Cmd;\n}\n\nArrayRef<uint8_t> MachOObjectFile::getDyldInfoRebaseOpcodes() const {\n  if (!DyldInfoLoadCmd)\n    return None;\n\n  auto DyldInfoOrErr =\n    getStructOrErr<MachO::dyld_info_command>(*this, DyldInfoLoadCmd);\n  if (!DyldInfoOrErr)\n    return None;\n  MachO::dyld_info_command DyldInfo = DyldInfoOrErr.get();\n  const uint8_t *Ptr =\n      reinterpret_cast<const uint8_t *>(getPtr(*this, DyldInfo.rebase_off));\n  return makeArrayRef(Ptr, DyldInfo.rebase_size);\n}\n\nArrayRef<uint8_t> MachOObjectFile::getDyldInfoBindOpcodes() const {\n  if (!DyldInfoLoadCmd)\n    return None;\n\n  auto DyldInfoOrErr =\n    getStructOrErr<MachO::dyld_info_command>(*this, DyldInfoLoadCmd);\n  if (!DyldInfoOrErr)\n    return None;\n  MachO::dyld_info_command DyldInfo = DyldInfoOrErr.get();\n  const uint8_t *Ptr =\n      reinterpret_cast<const uint8_t *>(getPtr(*this, DyldInfo.bind_off));\n  return makeArrayRef(Ptr, DyldInfo.bind_size);\n}\n\nArrayRef<uint8_t> MachOObjectFile::getDyldInfoWeakBindOpcodes() const {\n  if (!DyldInfoLoadCmd)\n    return None;\n\n  auto DyldInfoOrErr =\n    getStructOrErr<MachO::dyld_info_command>(*this, DyldInfoLoadCmd);\n  if (!DyldInfoOrErr)\n    return None;\n  MachO::dyld_info_command DyldInfo = DyldInfoOrErr.get();\n  const uint8_t *Ptr =\n      reinterpret_cast<const uint8_t *>(getPtr(*this, DyldInfo.weak_bind_off));\n  return makeArrayRef(Ptr, DyldInfo.weak_bind_size);\n}\n\nArrayRef<uint8_t> MachOObjectFile::getDyldInfoLazyBindOpcodes() const {\n  if (!DyldInfoLoadCmd)\n    return None;\n\n  auto DyldInfoOrErr =\n    getStructOrErr<MachO::dyld_info_command>(*this, DyldInfoLoadCmd);\n  if (!DyldInfoOrErr)\n    return None;\n  MachO::dyld_info_command DyldInfo = DyldInfoOrErr.get();\n  const uint8_t *Ptr =\n      reinterpret_cast<const uint8_t *>(getPtr(*this, DyldInfo.lazy_bind_off));\n  return makeArrayRef(Ptr, DyldInfo.lazy_bind_size);\n}\n\nArrayRef<uint8_t> MachOObjectFile::getDyldInfoExportsTrie() const {\n  if (!DyldInfoLoadCmd)\n    return None;\n\n  auto DyldInfoOrErr =\n    getStructOrErr<MachO::dyld_info_command>(*this, DyldInfoLoadCmd);\n  if (!DyldInfoOrErr)\n    return None;\n  MachO::dyld_info_command DyldInfo = DyldInfoOrErr.get();\n  const uint8_t *Ptr =\n      reinterpret_cast<const uint8_t *>(getPtr(*this, DyldInfo.export_off));\n  return makeArrayRef(Ptr, DyldInfo.export_size);\n}\n\nArrayRef<uint8_t> MachOObjectFile::getUuid() const {\n  if (!UuidLoadCmd)\n    return None;\n  // Returning a pointer is fine as uuid doesn't need endian swapping.\n  const char *Ptr = UuidLoadCmd + offsetof(MachO::uuid_command, uuid);\n  return makeArrayRef(reinterpret_cast<const uint8_t *>(Ptr), 16);\n}\n\nStringRef MachOObjectFile::getStringTableData() const {\n  MachO::symtab_command S = getSymtabLoadCommand();\n  return getData().substr(S.stroff, S.strsize);\n}\n\nbool MachOObjectFile::is64Bit() const {\n  return getType() == getMachOType(false, true) ||\n    getType() == getMachOType(true, true);\n}\n\nvoid MachOObjectFile::ReadULEB128s(uint64_t Index,\n                                   SmallVectorImpl<uint64_t> &Out) const {\n  DataExtractor extractor(ObjectFile::getData(), true, 0);\n\n  uint64_t offset = Index;\n  uint64_t data = 0;\n  while (uint64_t delta = extractor.getULEB128(&offset)) {\n    data += delta;\n    Out.push_back(data);\n  }\n}\n\nbool MachOObjectFile::isRelocatableObject() const {\n  return getHeader().filetype == MachO::MH_OBJECT;\n}\n\nExpected<std::unique_ptr<MachOObjectFile>>\nObjectFile::createMachOObjectFile(MemoryBufferRef Buffer,\n                                  uint32_t UniversalCputype,\n                                  uint32_t UniversalIndex) {\n  StringRef Magic = Buffer.getBuffer().slice(0, 4);\n  if (Magic == \"\\xFE\\xED\\xFA\\xCE\")\n    return MachOObjectFile::create(Buffer, false, false,\n                                   UniversalCputype, UniversalIndex);\n  if (Magic == \"\\xCE\\xFA\\xED\\xFE\")\n    return MachOObjectFile::create(Buffer, true, false,\n                                   UniversalCputype, UniversalIndex);\n  if (Magic == \"\\xFE\\xED\\xFA\\xCF\")\n    return MachOObjectFile::create(Buffer, false, true,\n                                   UniversalCputype, UniversalIndex);\n  if (Magic == \"\\xCF\\xFA\\xED\\xFE\")\n    return MachOObjectFile::create(Buffer, true, true,\n                                   UniversalCputype, UniversalIndex);\n  return make_error<GenericBinaryError>(\"Unrecognized MachO magic number\",\n                                        object_error::invalid_file_type);\n}\n\nStringRef MachOObjectFile::mapDebugSectionName(StringRef Name) const {\n  return StringSwitch<StringRef>(Name)\n      .Case(\"debug_str_offs\", \"debug_str_offsets\")\n      .Default(Name);\n}\n"}}, "reports": [{"events": [{"location": {"col": 19, "file": 16, "line": 2831}, "message": "mark 'noexcept'"}, {"location": {"col": 19, "file": 16, "line": 2831}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Object/MachOObjectFile.cpp", "reportHash": "22018ff0659e376be8a0f8fa62a006d0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 19, "file": 16, "line": 2831}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Object/MachOObjectFile.cpp", "reportHash": "7841f27f23b2ed5ec679e68237455895", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 16, "line": 3445}, "message": "mark 'noexcept'"}, {"location": {"col": 24, "file": 16, "line": 3445}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Object/MachOObjectFile.cpp", "reportHash": "8f9424be94cb58c4e13a41d3bfde58eb", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 24, "file": 16, "line": 3445}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Object/MachOObjectFile.cpp", "reportHash": "a8ff566a906ab88bfacf53a160a236f2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 16, "line": 3997}, "message": "mark 'noexcept'"}, {"location": {"col": 22, "file": 16, "line": 3997}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Object/MachOObjectFile.cpp", "reportHash": "b65b9a39c20a288ce7ebe88ec20ae8c1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 16, "line": 3997}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Object/MachOObjectFile.cpp", "reportHash": "ea6c50e1acea335a5dfb87a60e018bf9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
