<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Sema.h", "content": "//===--- Sema.h - Semantic Analysis & AST Building --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the Sema class, which performs semantic analysis and\n// builds ASTs.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_SEMA_H\n#define LLVM_CLANG_SEMA_SEMA_H\n\n#include \"clang/AST/ASTConcept.h\"\n#include \"clang/AST/ASTFwd.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/Availability.h\"\n#include \"clang/AST/ComparisonCategories.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprConcepts.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/AST/ExprOpenMP.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/LocInfoType.h\"\n#include \"clang/AST/MangleNumberingContext.h\"\n#include \"clang/AST/NSAPI.h\"\n#include \"clang/AST/PrettyPrinter.h\"\n#include \"clang/AST/StmtCXX.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/AST/TypeOrdering.h\"\n#include \"clang/Basic/BitmaskEnum.h\"\n#include \"clang/Basic/ExpressionTraits.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/OpenCLOptions.h\"\n#include \"clang/Basic/OpenMPKinds.h\"\n#include \"clang/Basic/PragmaKinds.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/TemplateKinds.h\"\n#include \"clang/Basic/TypeTraits.h\"\n#include \"clang/Sema/AnalysisBasedWarnings.h\"\n#include \"clang/Sema/CleanupInfo.h\"\n#include \"clang/Sema/DeclSpec.h\"\n#include \"clang/Sema/ExternalSemaSource.h\"\n#include \"clang/Sema/IdentifierResolver.h\"\n#include \"clang/Sema/ObjCMethodList.h\"\n#include \"clang/Sema/Ownership.h\"\n#include \"clang/Sema/Scope.h\"\n#include \"clang/Sema/SemaConcept.h\"\n#include \"clang/Sema/TypoCorrection.h\"\n#include \"clang/Sema/Weak.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/Frontend/OpenMP/OMPConstants.h\"\n#include <deque>\n#include <memory>\n#include <string>\n#include <tuple>\n#include <vector>\n\nnamespace llvm {\n  class APSInt;\n  template <typename ValueT> struct DenseMapInfo;\n  template <typename ValueT, typename ValueInfoT> class DenseSet;\n  class SmallBitVector;\n  struct InlineAsmIdentifierInfo;\n}\n\nnamespace clang {\n  class ADLResult;\n  class ASTConsumer;\n  class ASTContext;\n  class ASTMutationListener;\n  class ASTReader;\n  class ASTWriter;\n  class ArrayType;\n  class ParsedAttr;\n  class BindingDecl;\n  class BlockDecl;\n  class CapturedDecl;\n  class CXXBasePath;\n  class CXXBasePaths;\n  class CXXBindTemporaryExpr;\n  typedef SmallVector<CXXBaseSpecifier*, 4> CXXCastPath;\n  class CXXConstructorDecl;\n  class CXXConversionDecl;\n  class CXXDeleteExpr;\n  class CXXDestructorDecl;\n  class CXXFieldCollector;\n  class CXXMemberCallExpr;\n  class CXXMethodDecl;\n  class CXXScopeSpec;\n  class CXXTemporary;\n  class CXXTryStmt;\n  class CallExpr;\n  class ClassTemplateDecl;\n  class ClassTemplatePartialSpecializationDecl;\n  class ClassTemplateSpecializationDecl;\n  class VarTemplatePartialSpecializationDecl;\n  class CodeCompleteConsumer;\n  class CodeCompletionAllocator;\n  class CodeCompletionTUInfo;\n  class CodeCompletionResult;\n  class CoroutineBodyStmt;\n  class Decl;\n  class DeclAccessPair;\n  class DeclContext;\n  class DeclRefExpr;\n  class DeclaratorDecl;\n  class DeducedTemplateArgument;\n  class DependentDiagnostic;\n  class DesignatedInitExpr;\n  class Designation;\n  class EnableIfAttr;\n  class EnumConstantDecl;\n  class Expr;\n  class ExtVectorType;\n  class FormatAttr;\n  class FriendDecl;\n  class FunctionDecl;\n  class FunctionProtoType;\n  class FunctionTemplateDecl;\n  class ImplicitConversionSequence;\n  typedef MutableArrayRef<ImplicitConversionSequence> ConversionSequenceList;\n  class InitListExpr;\n  class InitializationKind;\n  class InitializationSequence;\n  class InitializedEntity;\n  class IntegerLiteral;\n  class LabelStmt;\n  class LambdaExpr;\n  class LangOptions;\n  class LocalInstantiationScope;\n  class LookupResult;\n  class MacroInfo;\n  typedef ArrayRef<std::pair<IdentifierInfo *, SourceLocation>> ModuleIdPath;\n  class ModuleLoader;\n  class MultiLevelTemplateArgumentList;\n  class NamedDecl;\n  class ObjCCategoryDecl;\n  class ObjCCategoryImplDecl;\n  class ObjCCompatibleAliasDecl;\n  class ObjCContainerDecl;\n  class ObjCImplDecl;\n  class ObjCImplementationDecl;\n  class ObjCInterfaceDecl;\n  class ObjCIvarDecl;\n  template <class T> class ObjCList;\n  class ObjCMessageExpr;\n  class ObjCMethodDecl;\n  class ObjCPropertyDecl;\n  class ObjCProtocolDecl;\n  class OMPThreadPrivateDecl;\n  class OMPRequiresDecl;\n  class OMPDeclareReductionDecl;\n  class OMPDeclareSimdDecl;\n  class OMPClause;\n  struct OMPVarListLocTy;\n  struct OverloadCandidate;\n  enum class OverloadCandidateParamOrder : char;\n  enum OverloadCandidateRewriteKind : unsigned;\n  class OverloadCandidateSet;\n  class OverloadExpr;\n  class ParenListExpr;\n  class ParmVarDecl;\n  class Preprocessor;\n  class PseudoDestructorTypeStorage;\n  class PseudoObjectExpr;\n  class QualType;\n  class StandardConversionSequence;\n  class Stmt;\n  class StringLiteral;\n  class SwitchStmt;\n  class TemplateArgument;\n  class TemplateArgumentList;\n  class TemplateArgumentLoc;\n  class TemplateDecl;\n  class TemplateInstantiationCallback;\n  class TemplateParameterList;\n  class TemplatePartialOrderingContext;\n  class TemplateTemplateParmDecl;\n  class Token;\n  class TypeAliasDecl;\n  class TypedefDecl;\n  class TypedefNameDecl;\n  class TypeLoc;\n  class TypoCorrectionConsumer;\n  class UnqualifiedId;\n  class UnresolvedLookupExpr;\n  class UnresolvedMemberExpr;\n  class UnresolvedSetImpl;\n  class UnresolvedSetIterator;\n  class UsingDecl;\n  class UsingShadowDecl;\n  class ValueDecl;\n  class VarDecl;\n  class VarTemplateSpecializationDecl;\n  class VisibilityAttr;\n  class VisibleDeclConsumer;\n  class IndirectFieldDecl;\n  struct DeductionFailureInfo;\n  class TemplateSpecCandidateSet;\n\nnamespace sema {\n  class AccessedEntity;\n  class BlockScopeInfo;\n  class Capture;\n  class CapturedRegionScopeInfo;\n  class CapturingScopeInfo;\n  class CompoundScopeInfo;\n  class DelayedDiagnostic;\n  class DelayedDiagnosticPool;\n  class FunctionScopeInfo;\n  class LambdaScopeInfo;\n  class PossiblyUnreachableDiag;\n  class SemaPPCallbacks;\n  class TemplateDeductionInfo;\n}\n\nnamespace threadSafety {\n  class BeforeSet;\n  void threadSafetyCleanup(BeforeSet* Cache);\n}\n\n// FIXME: No way to easily map from TemplateTypeParmTypes to\n// TemplateTypeParmDecls, so we have this horrible PointerUnion.\ntypedef std::pair<llvm::PointerUnion<const TemplateTypeParmType*, NamedDecl*>,\n                  SourceLocation> UnexpandedParameterPack;\n\n/// Describes whether we've seen any nullability information for the given\n/// file.\nstruct FileNullability {\n  /// The first pointer declarator (of any pointer kind) in the file that does\n  /// not have a corresponding nullability annotation.\n  SourceLocation PointerLoc;\n\n  /// The end location for the first pointer declarator in the file. Used for\n  /// placing fix-its.\n  SourceLocation PointerEndLoc;\n\n  /// Which kind of pointer declarator we saw.\n  uint8_t PointerKind;\n\n  /// Whether we saw any type nullability annotations in the given file.\n  bool SawTypeNullability = false;\n};\n\n/// A mapping from file IDs to a record of whether we've seen nullability\n/// information in that file.\nclass FileNullabilityMap {\n  /// A mapping from file IDs to the nullability information for each file ID.\n  llvm::DenseMap<FileID, FileNullability> Map;\n\n  /// A single-element cache based on the file ID.\n  struct {\n    FileID File;\n    FileNullability Nullability;\n  } Cache;\n\npublic:\n  FileNullability &operator[](FileID file) {\n    // Check the single-element cache.\n    if (file == Cache.File)\n      return Cache.Nullability;\n\n    // It's not in the single-element cache; flush the cache if we have one.\n    if (!Cache.File.isInvalid()) {\n      Map[Cache.File] = Cache.Nullability;\n    }\n\n    // Pull this entry into the cache.\n    Cache.File = file;\n    Cache.Nullability = Map[file];\n    return Cache.Nullability;\n  }\n};\n\n/// Keeps track of expected type during expression parsing. The type is tied to\n/// a particular token, all functions that update or consume the type take a\n/// start location of the token they are looking at as a parameter. This allows\n/// to avoid updating the type on hot paths in the parser.\nclass PreferredTypeBuilder {\npublic:\n  PreferredTypeBuilder() = default;\n  explicit PreferredTypeBuilder(QualType Type) : Type(Type) {}\n\n  void enterCondition(Sema &S, SourceLocation Tok);\n  void enterReturn(Sema &S, SourceLocation Tok);\n  void enterVariableInit(SourceLocation Tok, Decl *D);\n  /// Handles e.g. BaseType{ .D = Tok...\n  void enterDesignatedInitializer(SourceLocation Tok, QualType BaseType,\n                                  const Designation &D);\n  /// Computing a type for the function argument may require running\n  /// overloading, so we postpone its computation until it is actually needed.\n  ///\n  /// Clients should be very careful when using this funciton, as it stores a\n  /// function_ref, clients should make sure all calls to get() with the same\n  /// location happen while function_ref is alive.\n  void enterFunctionArgument(SourceLocation Tok,\n                             llvm::function_ref<QualType()> ComputeType);\n\n  void enterParenExpr(SourceLocation Tok, SourceLocation LParLoc);\n  void enterUnary(Sema &S, SourceLocation Tok, tok::TokenKind OpKind,\n                  SourceLocation OpLoc);\n  void enterBinary(Sema &S, SourceLocation Tok, Expr *LHS, tok::TokenKind Op);\n  void enterMemAccess(Sema &S, SourceLocation Tok, Expr *Base);\n  void enterSubscript(Sema &S, SourceLocation Tok, Expr *LHS);\n  /// Handles all type casts, including C-style cast, C++ casts, etc.\n  void enterTypeCast(SourceLocation Tok, QualType CastType);\n\n  QualType get(SourceLocation Tok) const {\n    if (Tok != ExpectedLoc)\n      return QualType();\n    if (!Type.isNull())\n      return Type;\n    if (ComputeType)\n      return ComputeType();\n    return QualType();\n  }\n\nprivate:\n  /// Start position of a token for which we store expected type.\n  SourceLocation ExpectedLoc;\n  /// Expected type for a token starting at ExpectedLoc.\n  QualType Type;\n  /// A function to compute expected type at ExpectedLoc. It is only considered\n  /// if Type is null.\n  llvm::function_ref<QualType()> ComputeType;\n};\n\n/// Sema - This implements semantic analysis and AST building for C.\nclass Sema final {\n  Sema(const Sema &) = delete;\n  void operator=(const Sema &) = delete;\n\n  /// A key method to reduce duplicate debug info from Sema.\n  virtual void anchor();\n\n  ///Source of additional semantic information.\n  ExternalSemaSource *ExternalSource;\n\n  ///Whether Sema has generated a multiplexer and has to delete it.\n  bool isMultiplexExternalSource;\n\n  static bool mightHaveNonExternalLinkage(const DeclaratorDecl *FD);\n\n  bool isVisibleSlow(const NamedDecl *D);\n\n  /// Determine whether two declarations should be linked together, given that\n  /// the old declaration might not be visible and the new declaration might\n  /// not have external linkage.\n  bool shouldLinkPossiblyHiddenDecl(const NamedDecl *Old,\n                                    const NamedDecl *New) {\n    if (isVisible(Old))\n     return true;\n    // See comment in below overload for why it's safe to compute the linkage\n    // of the new declaration here.\n    if (New->isExternallyDeclarable()) {\n      assert(Old->isExternallyDeclarable() &&\n             \"should not have found a non-externally-declarable previous decl\");\n      return true;\n    }\n    return false;\n  }\n  bool shouldLinkPossiblyHiddenDecl(LookupResult &Old, const NamedDecl *New);\n\n  void setupImplicitSpecialMemberType(CXXMethodDecl *SpecialMem,\n                                      QualType ResultTy,\n                                      ArrayRef<QualType> Args);\n\npublic:\n  /// The maximum alignment, same as in llvm::Value. We duplicate them here\n  /// because that allows us not to duplicate the constants in clang code,\n  /// which we must to since we can't directly use the llvm constants.\n  /// The value is verified against llvm here: lib/CodeGen/CGDecl.cpp\n  ///\n  /// This is the greatest alignment value supported by load, store, and alloca\n  /// instructions, and global values.\n  static const unsigned MaxAlignmentExponent = 29;\n  static const unsigned MaximumAlignment = 1u << MaxAlignmentExponent;\n\n  typedef OpaquePtr<DeclGroupRef> DeclGroupPtrTy;\n  typedef OpaquePtr<TemplateName> TemplateTy;\n  typedef OpaquePtr<QualType> TypeTy;\n\n  OpenCLOptions OpenCLFeatures;\n  FPOptions CurFPFeatures;\n\n  const LangOptions &LangOpts;\n  Preprocessor &PP;\n  ASTContext &Context;\n  ASTConsumer &Consumer;\n  DiagnosticsEngine &Diags;\n  SourceManager &SourceMgr;\n\n  /// Flag indicating whether or not to collect detailed statistics.\n  bool CollectStats;\n\n  /// Code-completion consumer.\n  CodeCompleteConsumer *CodeCompleter;\n\n  /// CurContext - This is the current declaration context of parsing.\n  DeclContext *CurContext;\n\n  /// Generally null except when we temporarily switch decl contexts,\n  /// like in \\see ActOnObjCTemporaryExitContainerContext.\n  DeclContext *OriginalLexicalContext;\n\n  /// VAListTagName - The declaration name corresponding to __va_list_tag.\n  /// This is used as part of a hack to omit that class from ADL results.\n  DeclarationName VAListTagName;\n\n  bool MSStructPragmaOn; // True when \\#pragma ms_struct on\n\n  /// Controls member pointer representation format under the MS ABI.\n  LangOptions::PragmaMSPointersToMembersKind\n      MSPointerToMemberRepresentationMethod;\n\n  /// Stack of active SEH __finally scopes.  Can be empty.\n  SmallVector<Scope*, 2> CurrentSEHFinally;\n\n  /// Source location for newly created implicit MSInheritanceAttrs\n  SourceLocation ImplicitMSInheritanceAttrLoc;\n\n  /// Holds TypoExprs that are created from `createDelayedTypo`. This is used by\n  /// `TransformTypos` in order to keep track of any TypoExprs that are created\n  /// recursively during typo correction and wipe them away if the correction\n  /// fails.\n  llvm::SmallVector<TypoExpr *, 2> TypoExprs;\n\n  /// pragma clang section kind\n  enum PragmaClangSectionKind {\n    PCSK_Invalid      = 0,\n    PCSK_BSS          = 1,\n    PCSK_Data         = 2,\n    PCSK_Rodata       = 3,\n    PCSK_Text         = 4,\n    PCSK_Relro        = 5\n   };\n\n  enum PragmaClangSectionAction {\n    PCSA_Set     = 0,\n    PCSA_Clear   = 1\n  };\n\n  struct PragmaClangSection {\n    std::string SectionName;\n    bool Valid = false;\n    SourceLocation PragmaLocation;\n  };\n\n   PragmaClangSection PragmaClangBSSSection;\n   PragmaClangSection PragmaClangDataSection;\n   PragmaClangSection PragmaClangRodataSection;\n   PragmaClangSection PragmaClangRelroSection;\n   PragmaClangSection PragmaClangTextSection;\n\n  enum PragmaMsStackAction {\n    PSK_Reset     = 0x0,                // #pragma ()\n    PSK_Set       = 0x1,                // #pragma (value)\n    PSK_Push      = 0x2,                // #pragma (push[, id])\n    PSK_Pop       = 0x4,                // #pragma (pop[, id])\n    PSK_Show      = 0x8,                // #pragma (show) -- only for \"pack\"!\n    PSK_Push_Set  = PSK_Push | PSK_Set, // #pragma (push[, id], value)\n    PSK_Pop_Set   = PSK_Pop | PSK_Set,  // #pragma (pop[, id], value)\n  };\n\n  // #pragma pack and align.\n  class AlignPackInfo {\n  public:\n    // `Native` represents default align mode, which may vary based on the\n    // platform.\n    enum Mode : unsigned char { Native, Natural, Packed, Mac68k };\n\n    // #pragma pack info constructor\n    AlignPackInfo(AlignPackInfo::Mode M, unsigned Num, bool IsXL)\n        : PackAttr(true), AlignMode(M), PackNumber(Num), XLStack(IsXL) {\n      assert(Num == PackNumber && \"The pack number has been truncated.\");\n    }\n\n    // #pragma align info constructor\n    AlignPackInfo(AlignPackInfo::Mode M, bool IsXL)\n        : PackAttr(false), AlignMode(M),\n          PackNumber(M == Packed ? 1 : UninitPackVal), XLStack(IsXL) {}\n\n    explicit AlignPackInfo(bool IsXL) : AlignPackInfo(Native, IsXL) {}\n\n    AlignPackInfo() : AlignPackInfo(Native, false) {}\n\n    // When a AlignPackInfo itself cannot be used, this returns an 32-bit\n    // integer encoding for it. This should only be passed to\n    // AlignPackInfo::getFromRawEncoding, it should not be inspected directly.\n    static uint32_t getRawEncoding(const AlignPackInfo &Info) {\n      std::uint32_t Encoding{};\n      if (Info.IsXLStack())\n        Encoding |= IsXLMask;\n\n      Encoding |= static_cast<uint32_t>(Info.getAlignMode()) << 1;\n\n      if (Info.IsPackAttr())\n        Encoding |= PackAttrMask;\n\n      Encoding |= static_cast<uint32_t>(Info.getPackNumber()) << 4;\n\n      return Encoding;\n    }\n\n    static AlignPackInfo getFromRawEncoding(unsigned Encoding) {\n      bool IsXL = static_cast<bool>(Encoding & IsXLMask);\n      AlignPackInfo::Mode M =\n          static_cast<AlignPackInfo::Mode>((Encoding & AlignModeMask) >> 1);\n      int PackNumber = (Encoding & PackNumMask) >> 4;\n\n      if (Encoding & PackAttrMask)\n        return AlignPackInfo(M, PackNumber, IsXL);\n\n      return AlignPackInfo(M, IsXL);\n    }\n\n    bool IsPackAttr() const { return PackAttr; }\n\n    bool IsAlignAttr() const { return !PackAttr; }\n\n    Mode getAlignMode() const { return AlignMode; }\n\n    unsigned getPackNumber() const { return PackNumber; }\n\n    bool IsPackSet() const {\n      // #pragma align, #pragma pack(), and #pragma pack(0) do not set the pack\n      // attriute on a decl.\n      return PackNumber != UninitPackVal && PackNumber != 0;\n    }\n\n    bool IsXLStack() const { return XLStack; }\n\n    bool operator==(const AlignPackInfo &Info) const {\n      return std::tie(AlignMode, PackNumber, PackAttr, XLStack) ==\n             std::tie(Info.AlignMode, Info.PackNumber, Info.PackAttr,\n                      Info.XLStack);\n    }\n\n    bool operator!=(const AlignPackInfo &Info) const {\n      return !(*this == Info);\n    }\n\n  private:\n    /// \\brief True if this is a pragma pack attribute,\n    ///         not a pragma align attribute.\n    bool PackAttr;\n\n    /// \\brief The alignment mode that is in effect.\n    Mode AlignMode;\n\n    /// \\brief The pack number of the stack.\n    unsigned char PackNumber;\n\n    /// \\brief True if it is a XL #pragma align/pack stack.\n    bool XLStack;\n\n    /// \\brief Uninitialized pack value.\n    static constexpr unsigned char UninitPackVal = -1;\n\n    // Masks to encode and decode an AlignPackInfo.\n    static constexpr uint32_t IsXLMask{0x0000'0001};\n    static constexpr uint32_t AlignModeMask{0x0000'0006};\n    static constexpr uint32_t PackAttrMask{0x00000'0008};\n    static constexpr uint32_t PackNumMask{0x0000'01F0};\n  };\n\n  template<typename ValueType>\n  struct PragmaStack {\n    struct Slot {\n      llvm::StringRef StackSlotLabel;\n      ValueType Value;\n      SourceLocation PragmaLocation;\n      SourceLocation PragmaPushLocation;\n      Slot(llvm::StringRef StackSlotLabel, ValueType Value,\n           SourceLocation PragmaLocation, SourceLocation PragmaPushLocation)\n          : StackSlotLabel(StackSlotLabel), Value(Value),\n            PragmaLocation(PragmaLocation),\n            PragmaPushLocation(PragmaPushLocation) {}\n    };\n\n    void Act(SourceLocation PragmaLocation, PragmaMsStackAction Action,\n             llvm::StringRef StackSlotLabel, ValueType Value) {\n      if (Action == PSK_Reset) {\n        CurrentValue = DefaultValue;\n        CurrentPragmaLocation = PragmaLocation;\n        return;\n      }\n      if (Action & PSK_Push)\n        Stack.emplace_back(StackSlotLabel, CurrentValue, CurrentPragmaLocation,\n                           PragmaLocation);\n      else if (Action & PSK_Pop) {\n        if (!StackSlotLabel.empty()) {\n          // If we've got a label, try to find it and jump there.\n          auto I = llvm::find_if(llvm::reverse(Stack), [&](const Slot &x) {\n            return x.StackSlotLabel == StackSlotLabel;\n          });\n          // If we found the label so pop from there.\n          if (I != Stack.rend()) {\n            CurrentValue = I->Value;\n            CurrentPragmaLocation = I->PragmaLocation;\n            Stack.erase(std::prev(I.base()), Stack.end());\n          }\n        } else if (!Stack.empty()) {\n          // We do not have a label, just pop the last entry.\n          CurrentValue = Stack.back().Value;\n          CurrentPragmaLocation = Stack.back().PragmaLocation;\n          Stack.pop_back();\n        }\n      }\n      if (Action & PSK_Set) {\n        CurrentValue = Value;\n        CurrentPragmaLocation = PragmaLocation;\n      }\n    }\n\n    // MSVC seems to add artificial slots to #pragma stacks on entering a C++\n    // method body to restore the stacks on exit, so it works like this:\n    //\n    //   struct S {\n    //     #pragma <name>(push, InternalPragmaSlot, <current_pragma_value>)\n    //     void Method {}\n    //     #pragma <name>(pop, InternalPragmaSlot)\n    //   };\n    //\n    // It works even with #pragma vtordisp, although MSVC doesn't support\n    //   #pragma vtordisp(push [, id], n)\n    // syntax.\n    //\n    // Push / pop a named sentinel slot.\n    void SentinelAction(PragmaMsStackAction Action, StringRef Label) {\n      assert((Action == PSK_Push || Action == PSK_Pop) &&\n             \"Can only push / pop #pragma stack sentinels!\");\n      Act(CurrentPragmaLocation, Action, Label, CurrentValue);\n    }\n\n    // Constructors.\n    explicit PragmaStack(const ValueType &Default)\n        : DefaultValue(Default), CurrentValue(Default) {}\n\n    bool hasValue() const { return CurrentValue != DefaultValue; }\n\n    SmallVector<Slot, 2> Stack;\n    ValueType DefaultValue; // Value used for PSK_Reset action.\n    ValueType CurrentValue;\n    SourceLocation CurrentPragmaLocation;\n  };\n  // FIXME: We should serialize / deserialize these if they occur in a PCH (but\n  // we shouldn't do so if they're in a module).\n\n  /// Whether to insert vtordisps prior to virtual bases in the Microsoft\n  /// C++ ABI.  Possible values are 0, 1, and 2, which mean:\n  ///\n  /// 0: Suppress all vtordisps\n  /// 1: Insert vtordisps in the presence of vbase overrides and non-trivial\n  ///    structors\n  /// 2: Always insert vtordisps to support RTTI on partially constructed\n  ///    objects\n  PragmaStack<MSVtorDispMode> VtorDispStack;\n  PragmaStack<AlignPackInfo> AlignPackStack;\n  // The current #pragma align/pack values and locations at each #include.\n  struct AlignPackIncludeState {\n    AlignPackInfo CurrentValue;\n    SourceLocation CurrentPragmaLocation;\n    bool HasNonDefaultValue, ShouldWarnOnInclude;\n  };\n  SmallVector<AlignPackIncludeState, 8> AlignPackIncludeStack;\n  // Segment #pragmas.\n  PragmaStack<StringLiteral *> DataSegStack;\n  PragmaStack<StringLiteral *> BSSSegStack;\n  PragmaStack<StringLiteral *> ConstSegStack;\n  PragmaStack<StringLiteral *> CodeSegStack;\n\n  // This stack tracks the current state of Sema.CurFPFeatures.\n  PragmaStack<FPOptionsOverride> FpPragmaStack;\n  FPOptionsOverride CurFPFeatureOverrides() {\n    FPOptionsOverride result;\n    if (!FpPragmaStack.hasValue()) {\n      result = FPOptionsOverride();\n    } else {\n      result = FpPragmaStack.CurrentValue;\n    }\n    return result;\n  }\n\n  // RAII object to push / pop sentinel slots for all MS #pragma stacks.\n  // Actions should be performed only if we enter / exit a C++ method body.\n  class PragmaStackSentinelRAII {\n  public:\n    PragmaStackSentinelRAII(Sema &S, StringRef SlotLabel, bool ShouldAct);\n    ~PragmaStackSentinelRAII();\n\n  private:\n    Sema &S;\n    StringRef SlotLabel;\n    bool ShouldAct;\n  };\n\n  /// A mapping that describes the nullability we've seen in each header file.\n  FileNullabilityMap NullabilityMap;\n\n  /// Last section used with #pragma init_seg.\n  StringLiteral *CurInitSeg;\n  SourceLocation CurInitSegLoc;\n\n  /// VisContext - Manages the stack for \\#pragma GCC visibility.\n  void *VisContext; // Really a \"PragmaVisStack*\"\n\n  /// This an attribute introduced by \\#pragma clang attribute.\n  struct PragmaAttributeEntry {\n    SourceLocation Loc;\n    ParsedAttr *Attribute;\n    SmallVector<attr::SubjectMatchRule, 4> MatchRules;\n    bool IsUsed;\n  };\n\n  /// A push'd group of PragmaAttributeEntries.\n  struct PragmaAttributeGroup {\n    /// The location of the push attribute.\n    SourceLocation Loc;\n    /// The namespace of this push group.\n    const IdentifierInfo *Namespace;\n    SmallVector<PragmaAttributeEntry, 2> Entries;\n  };\n\n  SmallVector<PragmaAttributeGroup, 2> PragmaAttributeStack;\n\n  /// The declaration that is currently receiving an attribute from the\n  /// #pragma attribute stack.\n  const Decl *PragmaAttributeCurrentTargetDecl;\n\n  /// This represents the last location of a \"#pragma clang optimize off\"\n  /// directive if such a directive has not been closed by an \"on\" yet. If\n  /// optimizations are currently \"on\", this is set to an invalid location.\n  SourceLocation OptimizeOffPragmaLocation;\n\n  /// Flag indicating if Sema is building a recovery call expression.\n  ///\n  /// This flag is used to avoid building recovery call expressions\n  /// if Sema is already doing so, which would cause infinite recursions.\n  bool IsBuildingRecoveryCallExpr;\n\n  /// Used to control the generation of ExprWithCleanups.\n  CleanupInfo Cleanup;\n\n  /// ExprCleanupObjects - This is the stack of objects requiring\n  /// cleanup that are created by the current full expression.\n  SmallVector<ExprWithCleanups::CleanupObject, 8> ExprCleanupObjects;\n\n  /// Store a set of either DeclRefExprs or MemberExprs that contain a reference\n  /// to a variable (constant) that may or may not be odr-used in this Expr, and\n  /// we won't know until all lvalue-to-rvalue and discarded value conversions\n  /// have been applied to all subexpressions of the enclosing full expression.\n  /// This is cleared at the end of each full expression.\n  using MaybeODRUseExprSet = llvm::SetVector<Expr *, SmallVector<Expr *, 4>,\n                                             llvm::SmallPtrSet<Expr *, 4>>;\n  MaybeODRUseExprSet MaybeODRUseExprs;\n\n  std::unique_ptr<sema::FunctionScopeInfo> CachedFunctionScope;\n\n  /// Stack containing information about each of the nested\n  /// function, block, and method scopes that are currently active.\n  SmallVector<sema::FunctionScopeInfo *, 4> FunctionScopes;\n\n  /// The index of the first FunctionScope that corresponds to the current\n  /// context.\n  unsigned FunctionScopesStart = 0;\n\n  ArrayRef<sema::FunctionScopeInfo*> getFunctionScopes() const {\n    return llvm::makeArrayRef(FunctionScopes.begin() + FunctionScopesStart,\n                              FunctionScopes.end());\n  }\n\n  /// Stack containing information needed when in C++2a an 'auto' is encountered\n  /// in a function declaration parameter type specifier in order to invent a\n  /// corresponding template parameter in the enclosing abbreviated function\n  /// template. This information is also present in LambdaScopeInfo, stored in\n  /// the FunctionScopes stack.\n  SmallVector<InventedTemplateParameterInfo, 4> InventedParameterInfos;\n\n  /// The index of the first InventedParameterInfo that refers to the current\n  /// context.\n  unsigned InventedParameterInfosStart = 0;\n\n  ArrayRef<InventedTemplateParameterInfo> getInventedParameterInfos() const {\n    return llvm::makeArrayRef(InventedParameterInfos.begin() +\n                                  InventedParameterInfosStart,\n                              InventedParameterInfos.end());\n  }\n\n  typedef LazyVector<TypedefNameDecl *, ExternalSemaSource,\n                     &ExternalSemaSource::ReadExtVectorDecls, 2, 2>\n    ExtVectorDeclsType;\n\n  /// ExtVectorDecls - This is a list all the extended vector types. This allows\n  /// us to associate a raw vector type with one of the ext_vector type names.\n  /// This is only necessary for issuing pretty diagnostics.\n  ExtVectorDeclsType ExtVectorDecls;\n\n  /// FieldCollector - Collects CXXFieldDecls during parsing of C++ classes.\n  std::unique_ptr<CXXFieldCollector> FieldCollector;\n\n  typedef llvm::SmallSetVector<NamedDecl *, 16> NamedDeclSetType;\n\n  /// Set containing all declared private fields that are not used.\n  NamedDeclSetType UnusedPrivateFields;\n\n  /// Set containing all typedefs that are likely unused.\n  llvm::SmallSetVector<const TypedefNameDecl *, 4>\n      UnusedLocalTypedefNameCandidates;\n\n  /// Delete-expressions to be analyzed at the end of translation unit\n  ///\n  /// This list contains class members, and locations of delete-expressions\n  /// that could not be proven as to whether they mismatch with new-expression\n  /// used in initializer of the field.\n  typedef std::pair<SourceLocation, bool> DeleteExprLoc;\n  typedef llvm::SmallVector<DeleteExprLoc, 4> DeleteLocs;\n  llvm::MapVector<FieldDecl *, DeleteLocs> DeleteExprs;\n\n  typedef llvm::SmallPtrSet<const CXXRecordDecl*, 8> RecordDeclSetTy;\n\n  /// PureVirtualClassDiagSet - a set of class declarations which we have\n  /// emitted a list of pure virtual functions. Used to prevent emitting the\n  /// same list more than once.\n  std::unique_ptr<RecordDeclSetTy> PureVirtualClassDiagSet;\n\n  /// ParsingInitForAutoVars - a set of declarations with auto types for which\n  /// we are currently parsing the initializer.\n  llvm::SmallPtrSet<const Decl*, 4> ParsingInitForAutoVars;\n\n  /// Look for a locally scoped extern \"C\" declaration by the given name.\n  NamedDecl *findLocallyScopedExternCDecl(DeclarationName Name);\n\n  typedef LazyVector<VarDecl *, ExternalSemaSource,\n                     &ExternalSemaSource::ReadTentativeDefinitions, 2, 2>\n    TentativeDefinitionsType;\n\n  /// All the tentative definitions encountered in the TU.\n  TentativeDefinitionsType TentativeDefinitions;\n\n  /// All the external declarations encoutered and used in the TU.\n  SmallVector<VarDecl *, 4> ExternalDeclarations;\n\n  typedef LazyVector<const DeclaratorDecl *, ExternalSemaSource,\n                     &ExternalSemaSource::ReadUnusedFileScopedDecls, 2, 2>\n    UnusedFileScopedDeclsType;\n\n  /// The set of file scoped decls seen so far that have not been used\n  /// and must warn if not used. Only contains the first declaration.\n  UnusedFileScopedDeclsType UnusedFileScopedDecls;\n\n  typedef LazyVector<CXXConstructorDecl *, ExternalSemaSource,\n                     &ExternalSemaSource::ReadDelegatingConstructors, 2, 2>\n    DelegatingCtorDeclsType;\n\n  /// All the delegating constructors seen so far in the file, used for\n  /// cycle detection at the end of the TU.\n  DelegatingCtorDeclsType DelegatingCtorDecls;\n\n  /// All the overriding functions seen during a class definition\n  /// that had their exception spec checks delayed, plus the overridden\n  /// function.\n  SmallVector<std::pair<const CXXMethodDecl*, const CXXMethodDecl*>, 2>\n    DelayedOverridingExceptionSpecChecks;\n\n  /// All the function redeclarations seen during a class definition that had\n  /// their exception spec checks delayed, plus the prior declaration they\n  /// should be checked against. Except during error recovery, the new decl\n  /// should always be a friend declaration, as that's the only valid way to\n  /// redeclare a special member before its class is complete.\n  SmallVector<std::pair<FunctionDecl*, FunctionDecl*>, 2>\n    DelayedEquivalentExceptionSpecChecks;\n\n  typedef llvm::MapVector<const FunctionDecl *,\n                          std::unique_ptr<LateParsedTemplate>>\n      LateParsedTemplateMapT;\n  LateParsedTemplateMapT LateParsedTemplateMap;\n\n  /// Callback to the parser to parse templated functions when needed.\n  typedef void LateTemplateParserCB(void *P, LateParsedTemplate &LPT);\n  typedef void LateTemplateParserCleanupCB(void *P);\n  LateTemplateParserCB *LateTemplateParser;\n  LateTemplateParserCleanupCB *LateTemplateParserCleanup;\n  void *OpaqueParser;\n\n  void SetLateTemplateParser(LateTemplateParserCB *LTP,\n                             LateTemplateParserCleanupCB *LTPCleanup,\n                             void *P) {\n    LateTemplateParser = LTP;\n    LateTemplateParserCleanup = LTPCleanup;\n    OpaqueParser = P;\n  }\n\n  class DelayedDiagnostics;\n\n  class DelayedDiagnosticsState {\n    sema::DelayedDiagnosticPool *SavedPool;\n    friend class Sema::DelayedDiagnostics;\n  };\n  typedef DelayedDiagnosticsState ParsingDeclState;\n  typedef DelayedDiagnosticsState ProcessingContextState;\n\n  /// A class which encapsulates the logic for delaying diagnostics\n  /// during parsing and other processing.\n  class DelayedDiagnostics {\n    /// The current pool of diagnostics into which delayed\n    /// diagnostics should go.\n    sema::DelayedDiagnosticPool *CurPool;\n\n  public:\n    DelayedDiagnostics() : CurPool(nullptr) {}\n\n    /// Adds a delayed diagnostic.\n    void add(const sema::DelayedDiagnostic &diag); // in DelayedDiagnostic.h\n\n    /// Determines whether diagnostics should be delayed.\n    bool shouldDelayDiagnostics() { return CurPool != nullptr; }\n\n    /// Returns the current delayed-diagnostics pool.\n    sema::DelayedDiagnosticPool *getCurrentPool() const {\n      return CurPool;\n    }\n\n    /// Enter a new scope.  Access and deprecation diagnostics will be\n    /// collected in this pool.\n    DelayedDiagnosticsState push(sema::DelayedDiagnosticPool &pool) {\n      DelayedDiagnosticsState state;\n      state.SavedPool = CurPool;\n      CurPool = &pool;\n      return state;\n    }\n\n    /// Leave a delayed-diagnostic state that was previously pushed.\n    /// Do not emit any of the diagnostics.  This is performed as part\n    /// of the bookkeeping of popping a pool \"properly\".\n    void popWithoutEmitting(DelayedDiagnosticsState state) {\n      CurPool = state.SavedPool;\n    }\n\n    /// Enter a new scope where access and deprecation diagnostics are\n    /// not delayed.\n    DelayedDiagnosticsState pushUndelayed() {\n      DelayedDiagnosticsState state;\n      state.SavedPool = CurPool;\n      CurPool = nullptr;\n      return state;\n    }\n\n    /// Undo a previous pushUndelayed().\n    void popUndelayed(DelayedDiagnosticsState state) {\n      assert(CurPool == nullptr);\n      CurPool = state.SavedPool;\n    }\n  } DelayedDiagnostics;\n\n  /// A RAII object to temporarily push a declaration context.\n  class ContextRAII {\n  private:\n    Sema &S;\n    DeclContext *SavedContext;\n    ProcessingContextState SavedContextState;\n    QualType SavedCXXThisTypeOverride;\n    unsigned SavedFunctionScopesStart;\n    unsigned SavedInventedParameterInfosStart;\n\n  public:\n    ContextRAII(Sema &S, DeclContext *ContextToPush, bool NewThisContext = true)\n      : S(S), SavedContext(S.CurContext),\n        SavedContextState(S.DelayedDiagnostics.pushUndelayed()),\n        SavedCXXThisTypeOverride(S.CXXThisTypeOverride),\n        SavedFunctionScopesStart(S.FunctionScopesStart),\n        SavedInventedParameterInfosStart(S.InventedParameterInfosStart)\n    {\n      assert(ContextToPush && \"pushing null context\");\n      S.CurContext = ContextToPush;\n      if (NewThisContext)\n        S.CXXThisTypeOverride = QualType();\n      // Any saved FunctionScopes do not refer to this context.\n      S.FunctionScopesStart = S.FunctionScopes.size();\n      S.InventedParameterInfosStart = S.InventedParameterInfos.size();\n    }\n\n    void pop() {\n      if (!SavedContext) return;\n      S.CurContext = SavedContext;\n      S.DelayedDiagnostics.popUndelayed(SavedContextState);\n      S.CXXThisTypeOverride = SavedCXXThisTypeOverride;\n      S.FunctionScopesStart = SavedFunctionScopesStart;\n      S.InventedParameterInfosStart = SavedInventedParameterInfosStart;\n      SavedContext = nullptr;\n    }\n\n    ~ContextRAII() {\n      pop();\n    }\n  };\n\n  /// Whether the AST is currently being rebuilt to correct immediate\n  /// invocations. Immediate invocation candidates and references to consteval\n  /// functions aren't tracked when this is set.\n  bool RebuildingImmediateInvocation = false;\n\n  /// Used to change context to isConstantEvaluated without pushing a heavy\n  /// ExpressionEvaluationContextRecord object.\n  bool isConstantEvaluatedOverride;\n\n  bool isConstantEvaluated() {\n    return ExprEvalContexts.back().isConstantEvaluated() ||\n           isConstantEvaluatedOverride;\n  }\n\n  /// RAII object to handle the state changes required to synthesize\n  /// a function body.\n  class SynthesizedFunctionScope {\n    Sema &S;\n    Sema::ContextRAII SavedContext;\n    bool PushedCodeSynthesisContext = false;\n\n  public:\n    SynthesizedFunctionScope(Sema &S, DeclContext *DC)\n        : S(S), SavedContext(S, DC) {\n      S.PushFunctionScope();\n      S.PushExpressionEvaluationContext(\n          Sema::ExpressionEvaluationContext::PotentiallyEvaluated);\n      if (auto *FD = dyn_cast<FunctionDecl>(DC))\n        FD->setWillHaveBody(true);\n      else\n        assert(isa<ObjCMethodDecl>(DC));\n    }\n\n    void addContextNote(SourceLocation UseLoc) {\n      assert(!PushedCodeSynthesisContext);\n\n      Sema::CodeSynthesisContext Ctx;\n      Ctx.Kind = Sema::CodeSynthesisContext::DefiningSynthesizedFunction;\n      Ctx.PointOfInstantiation = UseLoc;\n      Ctx.Entity = cast<Decl>(S.CurContext);\n      S.pushCodeSynthesisContext(Ctx);\n\n      PushedCodeSynthesisContext = true;\n    }\n\n    ~SynthesizedFunctionScope() {\n      if (PushedCodeSynthesisContext)\n        S.popCodeSynthesisContext();\n      if (auto *FD = dyn_cast<FunctionDecl>(S.CurContext))\n        FD->setWillHaveBody(false);\n      S.PopExpressionEvaluationContext();\n      S.PopFunctionScopeInfo();\n    }\n  };\n\n  /// WeakUndeclaredIdentifiers - Identifiers contained in\n  /// \\#pragma weak before declared. rare. may alias another\n  /// identifier, declared or undeclared\n  llvm::MapVector<IdentifierInfo *, WeakInfo> WeakUndeclaredIdentifiers;\n\n  /// ExtnameUndeclaredIdentifiers - Identifiers contained in\n  /// \\#pragma redefine_extname before declared.  Used in Solaris system headers\n  /// to define functions that occur in multiple standards to call the version\n  /// in the currently selected standard.\n  llvm::DenseMap<IdentifierInfo*,AsmLabelAttr*> ExtnameUndeclaredIdentifiers;\n\n\n  /// Load weak undeclared identifiers from the external source.\n  void LoadExternalWeakUndeclaredIdentifiers();\n\n  /// WeakTopLevelDecl - Translation-unit scoped declarations generated by\n  /// \\#pragma weak during processing of other Decls.\n  /// I couldn't figure out a clean way to generate these in-line, so\n  /// we store them here and handle separately -- which is a hack.\n  /// It would be best to refactor this.\n  SmallVector<Decl*,2> WeakTopLevelDecl;\n\n  IdentifierResolver IdResolver;\n\n  /// Translation Unit Scope - useful to Objective-C actions that need\n  /// to lookup file scope declarations in the \"ordinary\" C decl namespace.\n  /// For example, user-defined classes, built-in \"id\" type, etc.\n  Scope *TUScope;\n\n  /// The C++ \"std\" namespace, where the standard library resides.\n  LazyDeclPtr StdNamespace;\n\n  /// The C++ \"std::bad_alloc\" class, which is defined by the C++\n  /// standard library.\n  LazyDeclPtr StdBadAlloc;\n\n  /// The C++ \"std::align_val_t\" enum class, which is defined by the C++\n  /// standard library.\n  LazyDeclPtr StdAlignValT;\n\n  /// The C++ \"std::experimental\" namespace, where the experimental parts\n  /// of the standard library resides.\n  NamespaceDecl *StdExperimentalNamespaceCache;\n\n  /// The C++ \"std::initializer_list\" template, which is defined in\n  /// \\<initializer_list>.\n  ClassTemplateDecl *StdInitializerList;\n\n  /// The C++ \"std::coroutine_traits\" template, which is defined in\n  /// \\<coroutine_traits>\n  ClassTemplateDecl *StdCoroutineTraitsCache;\n\n  /// The C++ \"type_info\" declaration, which is defined in \\<typeinfo>.\n  RecordDecl *CXXTypeInfoDecl;\n\n  /// The MSVC \"_GUID\" struct, which is defined in MSVC header files.\n  RecordDecl *MSVCGuidDecl;\n\n  /// Caches identifiers/selectors for NSFoundation APIs.\n  std::unique_ptr<NSAPI> NSAPIObj;\n\n  /// The declaration of the Objective-C NSNumber class.\n  ObjCInterfaceDecl *NSNumberDecl;\n\n  /// The declaration of the Objective-C NSValue class.\n  ObjCInterfaceDecl *NSValueDecl;\n\n  /// Pointer to NSNumber type (NSNumber *).\n  QualType NSNumberPointer;\n\n  /// Pointer to NSValue type (NSValue *).\n  QualType NSValuePointer;\n\n  /// The Objective-C NSNumber methods used to create NSNumber literals.\n  ObjCMethodDecl *NSNumberLiteralMethods[NSAPI::NumNSNumberLiteralMethods];\n\n  /// The declaration of the Objective-C NSString class.\n  ObjCInterfaceDecl *NSStringDecl;\n\n  /// Pointer to NSString type (NSString *).\n  QualType NSStringPointer;\n\n  /// The declaration of the stringWithUTF8String: method.\n  ObjCMethodDecl *StringWithUTF8StringMethod;\n\n  /// The declaration of the valueWithBytes:objCType: method.\n  ObjCMethodDecl *ValueWithBytesObjCTypeMethod;\n\n  /// The declaration of the Objective-C NSArray class.\n  ObjCInterfaceDecl *NSArrayDecl;\n\n  /// The declaration of the arrayWithObjects:count: method.\n  ObjCMethodDecl *ArrayWithObjectsMethod;\n\n  /// The declaration of the Objective-C NSDictionary class.\n  ObjCInterfaceDecl *NSDictionaryDecl;\n\n  /// The declaration of the dictionaryWithObjects:forKeys:count: method.\n  ObjCMethodDecl *DictionaryWithObjectsMethod;\n\n  /// id<NSCopying> type.\n  QualType QIDNSCopying;\n\n  /// will hold 'respondsToSelector:'\n  Selector RespondsToSelectorSel;\n\n  /// A flag to remember whether the implicit forms of operator new and delete\n  /// have been declared.\n  bool GlobalNewDeleteDeclared;\n\n  /// Describes how the expressions currently being parsed are\n  /// evaluated at run-time, if at all.\n  enum class ExpressionEvaluationContext {\n    /// The current expression and its subexpressions occur within an\n    /// unevaluated operand (C++11 [expr]p7), such as the subexpression of\n    /// \\c sizeof, where the type of the expression may be significant but\n    /// no code will be generated to evaluate the value of the expression at\n    /// run time.\n    Unevaluated,\n\n    /// The current expression occurs within a braced-init-list within\n    /// an unevaluated operand. This is mostly like a regular unevaluated\n    /// context, except that we still instantiate constexpr functions that are\n    /// referenced here so that we can perform narrowing checks correctly.\n    UnevaluatedList,\n\n    /// The current expression occurs within a discarded statement.\n    /// This behaves largely similarly to an unevaluated operand in preventing\n    /// definitions from being required, but not in other ways.\n    DiscardedStatement,\n\n    /// The current expression occurs within an unevaluated\n    /// operand that unconditionally permits abstract references to\n    /// fields, such as a SIZE operator in MS-style inline assembly.\n    UnevaluatedAbstract,\n\n    /// The current context is \"potentially evaluated\" in C++11 terms,\n    /// but the expression is evaluated at compile-time (like the values of\n    /// cases in a switch statement).\n    ConstantEvaluated,\n\n    /// The current expression is potentially evaluated at run time,\n    /// which means that code may be generated to evaluate the value of the\n    /// expression at run time.\n    PotentiallyEvaluated,\n\n    /// The current expression is potentially evaluated, but any\n    /// declarations referenced inside that expression are only used if\n    /// in fact the current expression is used.\n    ///\n    /// This value is used when parsing default function arguments, for which\n    /// we would like to provide diagnostics (e.g., passing non-POD arguments\n    /// through varargs) but do not want to mark declarations as \"referenced\"\n    /// until the default argument is used.\n    PotentiallyEvaluatedIfUsed\n  };\n\n  using ImmediateInvocationCandidate = llvm::PointerIntPair<ConstantExpr *, 1>;\n\n  /// Data structure used to record current or nested\n  /// expression evaluation contexts.\n  struct ExpressionEvaluationContextRecord {\n    /// The expression evaluation context.\n    ExpressionEvaluationContext Context;\n\n    /// Whether the enclosing context needed a cleanup.\n    CleanupInfo ParentCleanup;\n\n    /// The number of active cleanup objects when we entered\n    /// this expression evaluation context.\n    unsigned NumCleanupObjects;\n\n    /// The number of typos encountered during this expression evaluation\n    /// context (i.e. the number of TypoExprs created).\n    unsigned NumTypos;\n\n    MaybeODRUseExprSet SavedMaybeODRUseExprs;\n\n    /// The lambdas that are present within this context, if it\n    /// is indeed an unevaluated context.\n    SmallVector<LambdaExpr *, 2> Lambdas;\n\n    /// The declaration that provides context for lambda expressions\n    /// and block literals if the normal declaration context does not\n    /// suffice, e.g., in a default function argument.\n    Decl *ManglingContextDecl;\n\n    /// If we are processing a decltype type, a set of call expressions\n    /// for which we have deferred checking the completeness of the return type.\n    SmallVector<CallExpr *, 8> DelayedDecltypeCalls;\n\n    /// If we are processing a decltype type, a set of temporary binding\n    /// expressions for which we have deferred checking the destructor.\n    SmallVector<CXXBindTemporaryExpr *, 8> DelayedDecltypeBinds;\n\n    llvm::SmallPtrSet<const Expr *, 8> PossibleDerefs;\n\n    /// Expressions appearing as the LHS of a volatile assignment in this\n    /// context. We produce a warning for these when popping the context if\n    /// they are not discarded-value expressions nor unevaluated operands.\n    SmallVector<Expr*, 2> VolatileAssignmentLHSs;\n\n    /// Set of candidates for starting an immediate invocation.\n    llvm::SmallVector<ImmediateInvocationCandidate, 4> ImmediateInvocationCandidates;\n\n    /// Set of DeclRefExprs referencing a consteval function when used in a\n    /// context not already known to be immediately invoked.\n    llvm::SmallPtrSet<DeclRefExpr *, 4> ReferenceToConsteval;\n\n    /// \\brief Describes whether we are in an expression constext which we have\n    /// to handle differently.\n    enum ExpressionKind {\n      EK_Decltype, EK_TemplateArgument, EK_Other\n    } ExprContext;\n\n    ExpressionEvaluationContextRecord(ExpressionEvaluationContext Context,\n                                      unsigned NumCleanupObjects,\n                                      CleanupInfo ParentCleanup,\n                                      Decl *ManglingContextDecl,\n                                      ExpressionKind ExprContext)\n        : Context(Context), ParentCleanup(ParentCleanup),\n          NumCleanupObjects(NumCleanupObjects), NumTypos(0),\n          ManglingContextDecl(ManglingContextDecl), ExprContext(ExprContext) {}\n\n    bool isUnevaluated() const {\n      return Context == ExpressionEvaluationContext::Unevaluated ||\n             Context == ExpressionEvaluationContext::UnevaluatedAbstract ||\n             Context == ExpressionEvaluationContext::UnevaluatedList;\n    }\n    bool isConstantEvaluated() const {\n      return Context == ExpressionEvaluationContext::ConstantEvaluated;\n    }\n  };\n\n  /// A stack of expression evaluation contexts.\n  SmallVector<ExpressionEvaluationContextRecord, 8> ExprEvalContexts;\n\n  /// Emit a warning for all pending noderef expressions that we recorded.\n  void WarnOnPendingNoDerefs(ExpressionEvaluationContextRecord &Rec);\n\n  /// Compute the mangling number context for a lambda expression or\n  /// block literal. Also return the extra mangling decl if any.\n  ///\n  /// \\param DC - The DeclContext containing the lambda expression or\n  /// block literal.\n  std::tuple<MangleNumberingContext *, Decl *>\n  getCurrentMangleNumberContext(const DeclContext *DC);\n\n\n  /// SpecialMemberOverloadResult - The overloading result for a special member\n  /// function.\n  ///\n  /// This is basically a wrapper around PointerIntPair. The lowest bits of the\n  /// integer are used to determine whether overload resolution succeeded.\n  class SpecialMemberOverloadResult {\n  public:\n    enum Kind {\n      NoMemberOrDeleted,\n      Ambiguous,\n      Success\n    };\n\n  private:\n    llvm::PointerIntPair<CXXMethodDecl*, 2> Pair;\n\n  public:\n    SpecialMemberOverloadResult() : Pair() {}\n    SpecialMemberOverloadResult(CXXMethodDecl *MD)\n        : Pair(MD, MD->isDeleted() ? NoMemberOrDeleted : Success) {}\n\n    CXXMethodDecl *getMethod() const { return Pair.getPointer(); }\n    void setMethod(CXXMethodDecl *MD) { Pair.setPointer(MD); }\n\n    Kind getKind() const { return static_cast<Kind>(Pair.getInt()); }\n    void setKind(Kind K) { Pair.setInt(K); }\n  };\n\n  class SpecialMemberOverloadResultEntry\n      : public llvm::FastFoldingSetNode,\n        public SpecialMemberOverloadResult {\n  public:\n    SpecialMemberOverloadResultEntry(const llvm::FoldingSetNodeID &ID)\n      : FastFoldingSetNode(ID)\n    {}\n  };\n\n  /// A cache of special member function overload resolution results\n  /// for C++ records.\n  llvm::FoldingSet<SpecialMemberOverloadResultEntry> SpecialMemberCache;\n\n  /// A cache of the flags available in enumerations with the flag_bits\n  /// attribute.\n  mutable llvm::DenseMap<const EnumDecl*, llvm::APInt> FlagBitsCache;\n\n  /// The kind of translation unit we are processing.\n  ///\n  /// When we're processing a complete translation unit, Sema will perform\n  /// end-of-translation-unit semantic tasks (such as creating\n  /// initializers for tentative definitions in C) once parsing has\n  /// completed. Modules and precompiled headers perform different kinds of\n  /// checks.\n  TranslationUnitKind TUKind;\n\n  llvm::BumpPtrAllocator BumpAlloc;\n\n  /// The number of SFINAE diagnostics that have been trapped.\n  unsigned NumSFINAEErrors;\n\n  typedef llvm::DenseMap<ParmVarDecl *, llvm::TinyPtrVector<ParmVarDecl *>>\n    UnparsedDefaultArgInstantiationsMap;\n\n  /// A mapping from parameters with unparsed default arguments to the\n  /// set of instantiations of each parameter.\n  ///\n  /// This mapping is a temporary data structure used when parsing\n  /// nested class templates or nested classes of class templates,\n  /// where we might end up instantiating an inner class before the\n  /// default arguments of its methods have been parsed.\n  UnparsedDefaultArgInstantiationsMap UnparsedDefaultArgInstantiations;\n\n  // Contains the locations of the beginning of unparsed default\n  // argument locations.\n  llvm::DenseMap<ParmVarDecl *, SourceLocation> UnparsedDefaultArgLocs;\n\n  /// UndefinedInternals - all the used, undefined objects which require a\n  /// definition in this translation unit.\n  llvm::MapVector<NamedDecl *, SourceLocation> UndefinedButUsed;\n\n  /// Determine if VD, which must be a variable or function, is an external\n  /// symbol that nonetheless can't be referenced from outside this translation\n  /// unit because its type has no linkage and it's not extern \"C\".\n  bool isExternalWithNoLinkageType(ValueDecl *VD);\n\n  /// Obtain a sorted list of functions that are undefined but ODR-used.\n  void getUndefinedButUsed(\n      SmallVectorImpl<std::pair<NamedDecl *, SourceLocation> > &Undefined);\n\n  /// Retrieves list of suspicious delete-expressions that will be checked at\n  /// the end of translation unit.\n  const llvm::MapVector<FieldDecl *, DeleteLocs> &\n  getMismatchingDeleteExpressions() const;\n\n  typedef std::pair<ObjCMethodList, ObjCMethodList> GlobalMethods;\n  typedef llvm::DenseMap<Selector, GlobalMethods> GlobalMethodPool;\n\n  /// Method Pool - allows efficient lookup when typechecking messages to \"id\".\n  /// We need to maintain a list, since selectors can have differing signatures\n  /// across classes. In Cocoa, this happens to be extremely uncommon (only 1%\n  /// of selectors are \"overloaded\").\n  /// At the head of the list it is recorded whether there were 0, 1, or >= 2\n  /// methods inside categories with a particular selector.\n  GlobalMethodPool MethodPool;\n\n  /// Method selectors used in a \\@selector expression. Used for implementation\n  /// of -Wselector.\n  llvm::MapVector<Selector, SourceLocation> ReferencedSelectors;\n\n  /// List of SourceLocations where 'self' is implicitly retained inside a\n  /// block.\n  llvm::SmallVector<std::pair<SourceLocation, const BlockDecl *>, 1>\n      ImplicitlyRetainedSelfLocs;\n\n  /// Kinds of C++ special members.\n  enum CXXSpecialMember {\n    CXXDefaultConstructor,\n    CXXCopyConstructor,\n    CXXMoveConstructor,\n    CXXCopyAssignment,\n    CXXMoveAssignment,\n    CXXDestructor,\n    CXXInvalid\n  };\n\n  typedef llvm::PointerIntPair<CXXRecordDecl *, 3, CXXSpecialMember>\n      SpecialMemberDecl;\n\n  /// The C++ special members which we are currently in the process of\n  /// declaring. If this process recursively triggers the declaration of the\n  /// same special member, we should act as if it is not yet declared.\n  llvm::SmallPtrSet<SpecialMemberDecl, 4> SpecialMembersBeingDeclared;\n\n  /// Kinds of defaulted comparison operator functions.\n  enum class DefaultedComparisonKind : unsigned char {\n    /// This is not a defaultable comparison operator.\n    None,\n    /// This is an operator== that should be implemented as a series of\n    /// subobject comparisons.\n    Equal,\n    /// This is an operator<=> that should be implemented as a series of\n    /// subobject comparisons.\n    ThreeWay,\n    /// This is an operator!= that should be implemented as a rewrite in terms\n    /// of a == comparison.\n    NotEqual,\n    /// This is an <, <=, >, or >= that should be implemented as a rewrite in\n    /// terms of a <=> comparison.\n    Relational,\n  };\n\n  /// The function definitions which were renamed as part of typo-correction\n  /// to match their respective declarations. We want to keep track of them\n  /// to ensure that we don't emit a \"redefinition\" error if we encounter a\n  /// correctly named definition after the renamed definition.\n  llvm::SmallPtrSet<const NamedDecl *, 4> TypoCorrectedFunctionDefinitions;\n\n  /// Stack of types that correspond to the parameter entities that are\n  /// currently being copy-initialized. Can be empty.\n  llvm::SmallVector<QualType, 4> CurrentParameterCopyTypes;\n\n  void ReadMethodPool(Selector Sel);\n  void updateOutOfDateSelector(Selector Sel);\n\n  /// Private Helper predicate to check for 'self'.\n  bool isSelfExpr(Expr *RExpr);\n  bool isSelfExpr(Expr *RExpr, const ObjCMethodDecl *Method);\n\n  /// Cause the active diagnostic on the DiagosticsEngine to be\n  /// emitted. This is closely coupled to the SemaDiagnosticBuilder class and\n  /// should not be used elsewhere.\n  void EmitCurrentDiagnostic(unsigned DiagID);\n\n  /// Records and restores the CurFPFeatures state on entry/exit of compound\n  /// statements.\n  class FPFeaturesStateRAII {\n  public:\n    FPFeaturesStateRAII(Sema &S) : S(S), OldFPFeaturesState(S.CurFPFeatures) {\n      OldOverrides = S.FpPragmaStack.CurrentValue;\n    }\n    ~FPFeaturesStateRAII() {\n      S.CurFPFeatures = OldFPFeaturesState;\n      S.FpPragmaStack.CurrentValue = OldOverrides;\n    }\n    FPOptionsOverride getOverrides() { return OldOverrides; }\n\n  private:\n    Sema& S;\n    FPOptions OldFPFeaturesState;\n    FPOptionsOverride OldOverrides;\n  };\n\n  void addImplicitTypedef(StringRef Name, QualType T);\n\n  bool WarnedStackExhausted = false;\n\npublic:\n  Sema(Preprocessor &pp, ASTContext &ctxt, ASTConsumer &consumer,\n       TranslationUnitKind TUKind = TU_Complete,\n       CodeCompleteConsumer *CompletionConsumer = nullptr);\n  ~Sema();\n\n  /// Perform initialization that occurs after the parser has been\n  /// initialized but before it parses anything.\n  void Initialize();\n\n  const LangOptions &getLangOpts() const { return LangOpts; }\n  OpenCLOptions &getOpenCLOptions() { return OpenCLFeatures; }\n  FPOptions     &getCurFPFeatures() { return CurFPFeatures; }\n\n  DiagnosticsEngine &getDiagnostics() const { return Diags; }\n  SourceManager &getSourceManager() const { return SourceMgr; }\n  Preprocessor &getPreprocessor() const { return PP; }\n  ASTContext &getASTContext() const { return Context; }\n  ASTConsumer &getASTConsumer() const { return Consumer; }\n  ASTMutationListener *getASTMutationListener() const;\n  ExternalSemaSource* getExternalSource() const { return ExternalSource; }\n\n  ///Registers an external source. If an external source already exists,\n  /// creates a multiplex external source and appends to it.\n  ///\n  ///\\param[in] E - A non-null external sema source.\n  ///\n  void addExternalSource(ExternalSemaSource *E);\n\n  void PrintStats() const;\n\n  /// Warn that the stack is nearly exhausted.\n  void warnStackExhausted(SourceLocation Loc);\n\n  /// Run some code with \"sufficient\" stack space. (Currently, at least 256K is\n  /// guaranteed). Produces a warning if we're low on stack space and allocates\n  /// more in that case. Use this in code that may recurse deeply (for example,\n  /// in template instantiation) to avoid stack overflow.\n  void runWithSufficientStackSpace(SourceLocation Loc,\n                                   llvm::function_ref<void()> Fn);\n\n  /// Helper class that creates diagnostics with optional\n  /// template instantiation stacks.\n  ///\n  /// This class provides a wrapper around the basic DiagnosticBuilder\n  /// class that emits diagnostics. ImmediateDiagBuilder is\n  /// responsible for emitting the diagnostic (as DiagnosticBuilder\n  /// does) and, if the diagnostic comes from inside a template\n  /// instantiation, printing the template instantiation stack as\n  /// well.\n  class ImmediateDiagBuilder : public DiagnosticBuilder {\n    Sema &SemaRef;\n    unsigned DiagID;\n\n  public:\n    ImmediateDiagBuilder(DiagnosticBuilder &DB, Sema &SemaRef, unsigned DiagID)\n        : DiagnosticBuilder(DB), SemaRef(SemaRef), DiagID(DiagID) {}\n    ImmediateDiagBuilder(DiagnosticBuilder &&DB, Sema &SemaRef, unsigned DiagID)\n        : DiagnosticBuilder(DB), SemaRef(SemaRef), DiagID(DiagID) {}\n\n    // This is a cunning lie. DiagnosticBuilder actually performs move\n    // construction in its copy constructor (but due to varied uses, it's not\n    // possible to conveniently express this as actual move construction). So\n    // the default copy ctor here is fine, because the base class disables the\n    // source anyway, so the user-defined ~ImmediateDiagBuilder is a safe no-op\n    // in that case anwyay.\n    ImmediateDiagBuilder(const ImmediateDiagBuilder &) = default;\n\n    ~ImmediateDiagBuilder() {\n      // If we aren't active, there is nothing to do.\n      if (!isActive()) return;\n\n      // Otherwise, we need to emit the diagnostic. First clear the diagnostic\n      // builder itself so it won't emit the diagnostic in its own destructor.\n      //\n      // This seems wasteful, in that as written the DiagnosticBuilder dtor will\n      // do its own needless checks to see if the diagnostic needs to be\n      // emitted. However, because we take care to ensure that the builder\n      // objects never escape, a sufficiently smart compiler will be able to\n      // eliminate that code.\n      Clear();\n\n      // Dispatch to Sema to emit the diagnostic.\n      SemaRef.EmitCurrentDiagnostic(DiagID);\n    }\n\n    /// Teach operator<< to produce an object of the correct type.\n    template <typename T>\n    friend const ImmediateDiagBuilder &\n    operator<<(const ImmediateDiagBuilder &Diag, const T &Value) {\n      const DiagnosticBuilder &BaseDiag = Diag;\n      BaseDiag << Value;\n      return Diag;\n    }\n\n    // It is necessary to limit this to rvalue reference to avoid calling this\n    // function with a bitfield lvalue argument since non-const reference to\n    // bitfield is not allowed.\n    template <typename T, typename = typename std::enable_if<\n                              !std::is_lvalue_reference<T>::value>::type>\n    const ImmediateDiagBuilder &operator<<(T &&V) const {\n      const DiagnosticBuilder &BaseDiag = *this;\n      BaseDiag << std::move(V);\n      return *this;\n    }\n  };\n\n  /// A generic diagnostic builder for errors which may or may not be deferred.\n  ///\n  /// In CUDA, there exist constructs (e.g. variable-length arrays, try/catch)\n  /// which are not allowed to appear inside __device__ functions and are\n  /// allowed to appear in __host__ __device__ functions only if the host+device\n  /// function is never codegen'ed.\n  ///\n  /// To handle this, we use the notion of \"deferred diagnostics\", where we\n  /// attach a diagnostic to a FunctionDecl that's emitted iff it's codegen'ed.\n  ///\n  /// This class lets you emit either a regular diagnostic, a deferred\n  /// diagnostic, or no diagnostic at all, according to an argument you pass to\n  /// its constructor, thus simplifying the process of creating these \"maybe\n  /// deferred\" diagnostics.\n  class SemaDiagnosticBuilder {\n  public:\n    enum Kind {\n      /// Emit no diagnostics.\n      K_Nop,\n      /// Emit the diagnostic immediately (i.e., behave like Sema::Diag()).\n      K_Immediate,\n      /// Emit the diagnostic immediately, and, if it's a warning or error, also\n      /// emit a call stack showing how this function can be reached by an a\n      /// priori known-emitted function.\n      K_ImmediateWithCallStack,\n      /// Create a deferred diagnostic, which is emitted only if the function\n      /// it's attached to is codegen'ed.  Also emit a call stack as with\n      /// K_ImmediateWithCallStack.\n      K_Deferred\n    };\n\n    SemaDiagnosticBuilder(Kind K, SourceLocation Loc, unsigned DiagID,\n                          FunctionDecl *Fn, Sema &S);\n    SemaDiagnosticBuilder(SemaDiagnosticBuilder &&D);\n    SemaDiagnosticBuilder(const SemaDiagnosticBuilder &) = default;\n    ~SemaDiagnosticBuilder();\n\n    bool isImmediate() const { return ImmediateDiag.hasValue(); }\n\n    /// Convertible to bool: True if we immediately emitted an error, false if\n    /// we didn't emit an error or we created a deferred error.\n    ///\n    /// Example usage:\n    ///\n    ///   if (SemaDiagnosticBuilder(...) << foo << bar)\n    ///     return ExprError();\n    ///\n    /// But see CUDADiagIfDeviceCode() and CUDADiagIfHostCode() -- you probably\n    /// want to use these instead of creating a SemaDiagnosticBuilder yourself.\n    operator bool() const { return isImmediate(); }\n\n    template <typename T>\n    friend const SemaDiagnosticBuilder &\n    operator<<(const SemaDiagnosticBuilder &Diag, const T &Value) {\n      if (Diag.ImmediateDiag.hasValue())\n        *Diag.ImmediateDiag << Value;\n      else if (Diag.PartialDiagId.hasValue())\n        Diag.S.DeviceDeferredDiags[Diag.Fn][*Diag.PartialDiagId].second\n            << Value;\n      return Diag;\n    }\n\n    // It is necessary to limit this to rvalue reference to avoid calling this\n    // function with a bitfield lvalue argument since non-const reference to\n    // bitfield is not allowed.\n    template <typename T, typename = typename std::enable_if<\n                              !std::is_lvalue_reference<T>::value>::type>\n    const SemaDiagnosticBuilder &operator<<(T &&V) const {\n      if (ImmediateDiag.hasValue())\n        *ImmediateDiag << std::move(V);\n      else if (PartialDiagId.hasValue())\n        S.DeviceDeferredDiags[Fn][*PartialDiagId].second << std::move(V);\n      return *this;\n    }\n\n    friend const SemaDiagnosticBuilder &\n    operator<<(const SemaDiagnosticBuilder &Diag, const PartialDiagnostic &PD) {\n      if (Diag.ImmediateDiag.hasValue())\n        PD.Emit(*Diag.ImmediateDiag);\n      else if (Diag.PartialDiagId.hasValue())\n        Diag.S.DeviceDeferredDiags[Diag.Fn][*Diag.PartialDiagId].second = PD;\n      return Diag;\n    }\n\n    void AddFixItHint(const FixItHint &Hint) const {\n      if (ImmediateDiag.hasValue())\n        ImmediateDiag->AddFixItHint(Hint);\n      else if (PartialDiagId.hasValue())\n        S.DeviceDeferredDiags[Fn][*PartialDiagId].second.AddFixItHint(Hint);\n    }\n\n    friend ExprResult ExprError(const SemaDiagnosticBuilder &) {\n      return ExprError();\n    }\n    friend StmtResult StmtError(const SemaDiagnosticBuilder &) {\n      return StmtError();\n    }\n    operator ExprResult() const { return ExprError(); }\n    operator StmtResult() const { return StmtError(); }\n    operator TypeResult() const { return TypeError(); }\n    operator DeclResult() const { return DeclResult(true); }\n    operator MemInitResult() const { return MemInitResult(true); }\n\n  private:\n    Sema &S;\n    SourceLocation Loc;\n    unsigned DiagID;\n    FunctionDecl *Fn;\n    bool ShowCallStack;\n\n    // Invariant: At most one of these Optionals has a value.\n    // FIXME: Switch these to a Variant once that exists.\n    llvm::Optional<ImmediateDiagBuilder> ImmediateDiag;\n    llvm::Optional<unsigned> PartialDiagId;\n  };\n\n  /// Is the last error level diagnostic immediate. This is used to determined\n  /// whether the next info diagnostic should be immediate.\n  bool IsLastErrorImmediate = true;\n\n  /// Emit a diagnostic.\n  SemaDiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID,\n                             bool DeferHint = false);\n\n  /// Emit a partial diagnostic.\n  SemaDiagnosticBuilder Diag(SourceLocation Loc, const PartialDiagnostic &PD,\n                             bool DeferHint = false);\n\n  /// Build a partial diagnostic.\n  PartialDiagnostic PDiag(unsigned DiagID = 0); // in SemaInternal.h\n\n  /// Whether uncompilable error has occurred. This includes error happens\n  /// in deferred diagnostics.\n  bool hasUncompilableErrorOccurred() const;\n\n  bool findMacroSpelling(SourceLocation &loc, StringRef name);\n\n  /// Get a string to suggest for zero-initialization of a type.\n  std::string\n  getFixItZeroInitializerForType(QualType T, SourceLocation Loc) const;\n  std::string getFixItZeroLiteralForType(QualType T, SourceLocation Loc) const;\n\n  /// Calls \\c Lexer::getLocForEndOfToken()\n  SourceLocation getLocForEndOfToken(SourceLocation Loc, unsigned Offset = 0);\n\n  /// Retrieve the module loader associated with the preprocessor.\n  ModuleLoader &getModuleLoader() const;\n\n  /// Invent a new identifier for parameters of abbreviated templates.\n  IdentifierInfo *\n  InventAbbreviatedTemplateParameterTypeName(IdentifierInfo *ParamName,\n                                             unsigned Index);\n\n  void emitAndClearUnusedLocalTypedefWarnings();\n\n  private:\n    /// Function or variable declarations to be checked for whether the deferred\n    /// diagnostics should be emitted.\n    SmallVector<Decl *, 4> DeclsToCheckForDeferredDiags;\n\n  public:\n  // Emit all deferred diagnostics.\n  void emitDeferredDiags();\n\n  enum TUFragmentKind {\n    /// The global module fragment, between 'module;' and a module-declaration.\n    Global,\n    /// A normal translation unit fragment. For a non-module unit, this is the\n    /// entire translation unit. Otherwise, it runs from the module-declaration\n    /// to the private-module-fragment (if any) or the end of the TU (if not).\n    Normal,\n    /// The private module fragment, between 'module :private;' and the end of\n    /// the translation unit.\n    Private\n  };\n\n  void ActOnStartOfTranslationUnit();\n  void ActOnEndOfTranslationUnit();\n  void ActOnEndOfTranslationUnitFragment(TUFragmentKind Kind);\n\n  void CheckDelegatingCtorCycles();\n\n  Scope *getScopeForContext(DeclContext *Ctx);\n\n  void PushFunctionScope();\n  void PushBlockScope(Scope *BlockScope, BlockDecl *Block);\n  sema::LambdaScopeInfo *PushLambdaScope();\n\n  /// This is used to inform Sema what the current TemplateParameterDepth\n  /// is during Parsing.  Currently it is used to pass on the depth\n  /// when parsing generic lambda 'auto' parameters.\n  void RecordParsingTemplateParameterDepth(unsigned Depth);\n\n  void PushCapturedRegionScope(Scope *RegionScope, CapturedDecl *CD,\n                               RecordDecl *RD, CapturedRegionKind K,\n                               unsigned OpenMPCaptureLevel = 0);\n\n  /// Custom deleter to allow FunctionScopeInfos to be kept alive for a short\n  /// time after they've been popped.\n  class PoppedFunctionScopeDeleter {\n    Sema *Self;\n\n  public:\n    explicit PoppedFunctionScopeDeleter(Sema *Self) : Self(Self) {}\n    void operator()(sema::FunctionScopeInfo *Scope) const;\n  };\n\n  using PoppedFunctionScopePtr =\n      std::unique_ptr<sema::FunctionScopeInfo, PoppedFunctionScopeDeleter>;\n\n  PoppedFunctionScopePtr\n  PopFunctionScopeInfo(const sema::AnalysisBasedWarnings::Policy *WP = nullptr,\n                       const Decl *D = nullptr,\n                       QualType BlockType = QualType());\n\n  sema::FunctionScopeInfo *getCurFunction() const {\n    return FunctionScopes.empty() ? nullptr : FunctionScopes.back();\n  }\n\n  sema::FunctionScopeInfo *getEnclosingFunction() const;\n\n  void setFunctionHasBranchIntoScope();\n  void setFunctionHasBranchProtectedScope();\n  void setFunctionHasIndirectGoto();\n\n  void PushCompoundScope(bool IsStmtExpr);\n  void PopCompoundScope();\n\n  sema::CompoundScopeInfo &getCurCompoundScope() const;\n\n  bool hasAnyUnrecoverableErrorsInThisFunction() const;\n\n  /// Retrieve the current block, if any.\n  sema::BlockScopeInfo *getCurBlock();\n\n  /// Get the innermost lambda enclosing the current location, if any. This\n  /// looks through intervening non-lambda scopes such as local functions and\n  /// blocks.\n  sema::LambdaScopeInfo *getEnclosingLambda() const;\n\n  /// Retrieve the current lambda scope info, if any.\n  /// \\param IgnoreNonLambdaCapturingScope true if should find the top-most\n  /// lambda scope info ignoring all inner capturing scopes that are not\n  /// lambda scopes.\n  sema::LambdaScopeInfo *\n  getCurLambda(bool IgnoreNonLambdaCapturingScope = false);\n\n  /// Retrieve the current generic lambda info, if any.\n  sema::LambdaScopeInfo *getCurGenericLambda();\n\n  /// Retrieve the current captured region, if any.\n  sema::CapturedRegionScopeInfo *getCurCapturedRegion();\n\n  /// WeakTopLevelDeclDecls - access to \\#pragma weak-generated Decls\n  SmallVectorImpl<Decl *> &WeakTopLevelDecls() { return WeakTopLevelDecl; }\n\n  /// Called before parsing a function declarator belonging to a function\n  /// declaration.\n  void ActOnStartFunctionDeclarationDeclarator(Declarator &D,\n                                               unsigned TemplateParameterDepth);\n\n  /// Called after parsing a function declarator belonging to a function\n  /// declaration.\n  void ActOnFinishFunctionDeclarationDeclarator(Declarator &D);\n\n  void ActOnComment(SourceRange Comment);\n\n  //===--------------------------------------------------------------------===//\n  // Type Analysis / Processing: SemaType.cpp.\n  //\n\n  QualType BuildQualifiedType(QualType T, SourceLocation Loc, Qualifiers Qs,\n                              const DeclSpec *DS = nullptr);\n  QualType BuildQualifiedType(QualType T, SourceLocation Loc, unsigned CVRA,\n                              const DeclSpec *DS = nullptr);\n  QualType BuildPointerType(QualType T,\n                            SourceLocation Loc, DeclarationName Entity);\n  QualType BuildReferenceType(QualType T, bool LValueRef,\n                              SourceLocation Loc, DeclarationName Entity);\n  QualType BuildArrayType(QualType T, ArrayType::ArraySizeModifier ASM,\n                          Expr *ArraySize, unsigned Quals,\n                          SourceRange Brackets, DeclarationName Entity);\n  QualType BuildVectorType(QualType T, Expr *VecSize, SourceLocation AttrLoc);\n  QualType BuildExtVectorType(QualType T, Expr *ArraySize,\n                              SourceLocation AttrLoc);\n  QualType BuildMatrixType(QualType T, Expr *NumRows, Expr *NumColumns,\n                           SourceLocation AttrLoc);\n\n  QualType BuildAddressSpaceAttr(QualType &T, LangAS ASIdx, Expr *AddrSpace,\n                                 SourceLocation AttrLoc);\n\n  /// Same as above, but constructs the AddressSpace index if not provided.\n  QualType BuildAddressSpaceAttr(QualType &T, Expr *AddrSpace,\n                                 SourceLocation AttrLoc);\n\n  bool CheckQualifiedFunctionForTypeId(QualType T, SourceLocation Loc);\n\n  bool CheckFunctionReturnType(QualType T, SourceLocation Loc);\n\n  /// Build a function type.\n  ///\n  /// This routine checks the function type according to C++ rules and\n  /// under the assumption that the result type and parameter types have\n  /// just been instantiated from a template. It therefore duplicates\n  /// some of the behavior of GetTypeForDeclarator, but in a much\n  /// simpler form that is only suitable for this narrow use case.\n  ///\n  /// \\param T The return type of the function.\n  ///\n  /// \\param ParamTypes The parameter types of the function. This array\n  /// will be modified to account for adjustments to the types of the\n  /// function parameters.\n  ///\n  /// \\param Loc The location of the entity whose type involves this\n  /// function type or, if there is no such entity, the location of the\n  /// type that will have function type.\n  ///\n  /// \\param Entity The name of the entity that involves the function\n  /// type, if known.\n  ///\n  /// \\param EPI Extra information about the function type. Usually this will\n  /// be taken from an existing function with the same prototype.\n  ///\n  /// \\returns A suitable function type, if there are no errors. The\n  /// unqualified type will always be a FunctionProtoType.\n  /// Otherwise, returns a NULL type.\n  QualType BuildFunctionType(QualType T,\n                             MutableArrayRef<QualType> ParamTypes,\n                             SourceLocation Loc, DeclarationName Entity,\n                             const FunctionProtoType::ExtProtoInfo &EPI);\n\n  QualType BuildMemberPointerType(QualType T, QualType Class,\n                                  SourceLocation Loc,\n                                  DeclarationName Entity);\n  QualType BuildBlockPointerType(QualType T,\n                                 SourceLocation Loc, DeclarationName Entity);\n  QualType BuildParenType(QualType T);\n  QualType BuildAtomicType(QualType T, SourceLocation Loc);\n  QualType BuildReadPipeType(QualType T,\n                         SourceLocation Loc);\n  QualType BuildWritePipeType(QualType T,\n                         SourceLocation Loc);\n  QualType BuildExtIntType(bool IsUnsigned, Expr *BitWidth, SourceLocation Loc);\n\n  TypeSourceInfo *GetTypeForDeclarator(Declarator &D, Scope *S);\n  TypeSourceInfo *GetTypeForDeclaratorCast(Declarator &D, QualType FromTy);\n\n  /// Package the given type and TSI into a ParsedType.\n  ParsedType CreateParsedType(QualType T, TypeSourceInfo *TInfo);\n  DeclarationNameInfo GetNameForDeclarator(Declarator &D);\n  DeclarationNameInfo GetNameFromUnqualifiedId(const UnqualifiedId &Name);\n  static QualType GetTypeFromParser(ParsedType Ty,\n                                    TypeSourceInfo **TInfo = nullptr);\n  CanThrowResult canThrow(const Stmt *E);\n  /// Determine whether the callee of a particular function call can throw.\n  /// E, D and Loc are all optional.\n  static CanThrowResult canCalleeThrow(Sema &S, const Expr *E, const Decl *D,\n                                       SourceLocation Loc = SourceLocation());\n  const FunctionProtoType *ResolveExceptionSpec(SourceLocation Loc,\n                                                const FunctionProtoType *FPT);\n  void UpdateExceptionSpec(FunctionDecl *FD,\n                           const FunctionProtoType::ExceptionSpecInfo &ESI);\n  bool CheckSpecifiedExceptionType(QualType &T, SourceRange Range);\n  bool CheckDistantExceptionSpec(QualType T);\n  bool CheckEquivalentExceptionSpec(FunctionDecl *Old, FunctionDecl *New);\n  bool CheckEquivalentExceptionSpec(\n      const FunctionProtoType *Old, SourceLocation OldLoc,\n      const FunctionProtoType *New, SourceLocation NewLoc);\n  bool CheckEquivalentExceptionSpec(\n      const PartialDiagnostic &DiagID, const PartialDiagnostic & NoteID,\n      const FunctionProtoType *Old, SourceLocation OldLoc,\n      const FunctionProtoType *New, SourceLocation NewLoc);\n  bool handlerCanCatch(QualType HandlerType, QualType ExceptionType);\n  bool CheckExceptionSpecSubset(const PartialDiagnostic &DiagID,\n                                const PartialDiagnostic &NestedDiagID,\n                                const PartialDiagnostic &NoteID,\n                                const PartialDiagnostic &NoThrowDiagID,\n                                const FunctionProtoType *Superset,\n                                SourceLocation SuperLoc,\n                                const FunctionProtoType *Subset,\n                                SourceLocation SubLoc);\n  bool CheckParamExceptionSpec(const PartialDiagnostic &NestedDiagID,\n                               const PartialDiagnostic &NoteID,\n                               const FunctionProtoType *Target,\n                               SourceLocation TargetLoc,\n                               const FunctionProtoType *Source,\n                               SourceLocation SourceLoc);\n\n  TypeResult ActOnTypeName(Scope *S, Declarator &D);\n\n  /// The parser has parsed the context-sensitive type 'instancetype'\n  /// in an Objective-C message declaration. Return the appropriate type.\n  ParsedType ActOnObjCInstanceType(SourceLocation Loc);\n\n  /// Abstract class used to diagnose incomplete types.\n  struct TypeDiagnoser {\n    TypeDiagnoser() {}\n\n    virtual void diagnose(Sema &S, SourceLocation Loc, QualType T) = 0;\n    virtual ~TypeDiagnoser() {}\n  };\n\n  static int getPrintable(int I) { return I; }\n  static unsigned getPrintable(unsigned I) { return I; }\n  static bool getPrintable(bool B) { return B; }\n  static const char * getPrintable(const char *S) { return S; }\n  static StringRef getPrintable(StringRef S) { return S; }\n  static const std::string &getPrintable(const std::string &S) { return S; }\n  static const IdentifierInfo *getPrintable(const IdentifierInfo *II) {\n    return II;\n  }\n  static DeclarationName getPrintable(DeclarationName N) { return N; }\n  static QualType getPrintable(QualType T) { return T; }\n  static SourceRange getPrintable(SourceRange R) { return R; }\n  static SourceRange getPrintable(SourceLocation L) { return L; }\n  static SourceRange getPrintable(const Expr *E) { return E->getSourceRange(); }\n  static SourceRange getPrintable(TypeLoc TL) { return TL.getSourceRange();}\n\n  template <typename... Ts> class BoundTypeDiagnoser : public TypeDiagnoser {\n  protected:\n    unsigned DiagID;\n    std::tuple<const Ts &...> Args;\n\n    template <std::size_t... Is>\n    void emit(const SemaDiagnosticBuilder &DB,\n              std::index_sequence<Is...>) const {\n      // Apply all tuple elements to the builder in order.\n      bool Dummy[] = {false, (DB << getPrintable(std::get<Is>(Args)))...};\n      (void)Dummy;\n    }\n\n  public:\n    BoundTypeDiagnoser(unsigned DiagID, const Ts &...Args)\n        : TypeDiagnoser(), DiagID(DiagID), Args(Args...) {\n      assert(DiagID != 0 && \"no diagnostic for type diagnoser\");\n    }\n\n    void diagnose(Sema &S, SourceLocation Loc, QualType T) override {\n      const SemaDiagnosticBuilder &DB = S.Diag(Loc, DiagID);\n      emit(DB, std::index_sequence_for<Ts...>());\n      DB << T;\n    }\n  };\n\n  /// Do a check to make sure \\p Name looks like a legal argument for the\n  /// swift_name attribute applied to decl \\p D.  Raise a diagnostic if the name\n  /// is invalid for the given declaration.\n  ///\n  /// \\p AL is used to provide caret diagnostics in case of a malformed name.\n  ///\n  /// \\returns true if the name is a valid swift name for \\p D, false otherwise.\n  bool DiagnoseSwiftName(Decl *D, StringRef Name, SourceLocation Loc,\n                         const ParsedAttr &AL, bool IsAsync);\n\n  /// A derivative of BoundTypeDiagnoser for which the diagnostic's type\n  /// parameter is preceded by a 0/1 enum that is 1 if the type is sizeless.\n  /// For example, a diagnostic with no other parameters would generally have\n  /// the form \"...%select{incomplete|sizeless}0 type %1...\".\n  template <typename... Ts>\n  class SizelessTypeDiagnoser : public BoundTypeDiagnoser<Ts...> {\n  public:\n    SizelessTypeDiagnoser(unsigned DiagID, const Ts &... Args)\n        : BoundTypeDiagnoser<Ts...>(DiagID, Args...) {}\n\n    void diagnose(Sema &S, SourceLocation Loc, QualType T) override {\n      const SemaDiagnosticBuilder &DB = S.Diag(Loc, this->DiagID);\n      this->emit(DB, std::index_sequence_for<Ts...>());\n      DB << T->isSizelessType() << T;\n    }\n  };\n\n  enum class CompleteTypeKind {\n    /// Apply the normal rules for complete types.  In particular,\n    /// treat all sizeless types as incomplete.\n    Normal,\n\n    /// Relax the normal rules for complete types so that they include\n    /// sizeless built-in types.\n    AcceptSizeless,\n\n    // FIXME: Eventually we should flip the default to Normal and opt in\n    // to AcceptSizeless rather than opt out of it.\n    Default = AcceptSizeless\n  };\n\nprivate:\n  /// Methods for marking which expressions involve dereferencing a pointer\n  /// marked with the 'noderef' attribute. Expressions are checked bottom up as\n  /// they are parsed, meaning that a noderef pointer may not be accessed. For\n  /// example, in `&*p` where `p` is a noderef pointer, we will first parse the\n  /// `*p`, but need to check that `address of` is called on it. This requires\n  /// keeping a container of all pending expressions and checking if the address\n  /// of them are eventually taken.\n  void CheckSubscriptAccessOfNoDeref(const ArraySubscriptExpr *E);\n  void CheckAddressOfNoDeref(const Expr *E);\n  void CheckMemberAccessOfNoDeref(const MemberExpr *E);\n\n  bool RequireCompleteTypeImpl(SourceLocation Loc, QualType T,\n                               CompleteTypeKind Kind, TypeDiagnoser *Diagnoser);\n\n  struct ModuleScope {\n    SourceLocation BeginLoc;\n    clang::Module *Module = nullptr;\n    bool ModuleInterface = false;\n    bool ImplicitGlobalModuleFragment = false;\n    VisibleModuleSet OuterVisibleModules;\n  };\n  /// The modules we're currently parsing.\n  llvm::SmallVector<ModuleScope, 16> ModuleScopes;\n\n  /// Namespace definitions that we will export when they finish.\n  llvm::SmallPtrSet<const NamespaceDecl*, 8> DeferredExportedNamespaces;\n\n  /// Get the module whose scope we are currently within.\n  Module *getCurrentModule() const {\n    return ModuleScopes.empty() ? nullptr : ModuleScopes.back().Module;\n  }\n\n  VisibleModuleSet VisibleModules;\n\npublic:\n  /// Get the module owning an entity.\n  Module *getOwningModule(const Decl *Entity) {\n    return Entity->getOwningModule();\n  }\n\n  /// Make a merged definition of an existing hidden definition \\p ND\n  /// visible at the specified location.\n  void makeMergedDefinitionVisible(NamedDecl *ND);\n\n  bool isModuleVisible(const Module *M, bool ModulePrivate = false);\n\n  // When loading a non-modular PCH files, this is used to restore module\n  // visibility.\n  void makeModuleVisible(Module *Mod, SourceLocation ImportLoc) {\n    VisibleModules.setVisible(Mod, ImportLoc);\n  }\n\n  /// Determine whether a declaration is visible to name lookup.\n  bool isVisible(const NamedDecl *D) {\n    return D->isUnconditionallyVisible() || isVisibleSlow(D);\n  }\n\n  /// Determine whether any declaration of an entity is visible.\n  bool\n  hasVisibleDeclaration(const NamedDecl *D,\n                        llvm::SmallVectorImpl<Module *> *Modules = nullptr) {\n    return isVisible(D) || hasVisibleDeclarationSlow(D, Modules);\n  }\n  bool hasVisibleDeclarationSlow(const NamedDecl *D,\n                                 llvm::SmallVectorImpl<Module *> *Modules);\n\n  bool hasVisibleMergedDefinition(NamedDecl *Def);\n  bool hasMergedDefinitionInCurrentModule(NamedDecl *Def);\n\n  /// Determine if \\p D and \\p Suggested have a structurally compatible\n  /// layout as described in C11 6.2.7/1.\n  bool hasStructuralCompatLayout(Decl *D, Decl *Suggested);\n\n  /// Determine if \\p D has a visible definition. If not, suggest a declaration\n  /// that should be made visible to expose the definition.\n  bool hasVisibleDefinition(NamedDecl *D, NamedDecl **Suggested,\n                            bool OnlyNeedComplete = false);\n  bool hasVisibleDefinition(const NamedDecl *D) {\n    NamedDecl *Hidden;\n    return hasVisibleDefinition(const_cast<NamedDecl*>(D), &Hidden);\n  }\n\n  /// Determine if the template parameter \\p D has a visible default argument.\n  bool\n  hasVisibleDefaultArgument(const NamedDecl *D,\n                            llvm::SmallVectorImpl<Module *> *Modules = nullptr);\n\n  /// Determine if there is a visible declaration of \\p D that is an explicit\n  /// specialization declaration for a specialization of a template. (For a\n  /// member specialization, use hasVisibleMemberSpecialization.)\n  bool hasVisibleExplicitSpecialization(\n      const NamedDecl *D, llvm::SmallVectorImpl<Module *> *Modules = nullptr);\n\n  /// Determine if there is a visible declaration of \\p D that is a member\n  /// specialization declaration (as opposed to an instantiated declaration).\n  bool hasVisibleMemberSpecialization(\n      const NamedDecl *D, llvm::SmallVectorImpl<Module *> *Modules = nullptr);\n\n  /// Determine if \\p A and \\p B are equivalent internal linkage declarations\n  /// from different modules, and thus an ambiguity error can be downgraded to\n  /// an extension warning.\n  bool isEquivalentInternalLinkageDeclaration(const NamedDecl *A,\n                                              const NamedDecl *B);\n  void diagnoseEquivalentInternalLinkageDeclarations(\n      SourceLocation Loc, const NamedDecl *D,\n      ArrayRef<const NamedDecl *> Equiv);\n\n  bool isUsualDeallocationFunction(const CXXMethodDecl *FD);\n\n  bool isCompleteType(SourceLocation Loc, QualType T,\n                      CompleteTypeKind Kind = CompleteTypeKind::Default) {\n    return !RequireCompleteTypeImpl(Loc, T, Kind, nullptr);\n  }\n  bool RequireCompleteType(SourceLocation Loc, QualType T,\n                           CompleteTypeKind Kind, TypeDiagnoser &Diagnoser);\n  bool RequireCompleteType(SourceLocation Loc, QualType T,\n                           CompleteTypeKind Kind, unsigned DiagID);\n\n  bool RequireCompleteType(SourceLocation Loc, QualType T,\n                           TypeDiagnoser &Diagnoser) {\n    return RequireCompleteType(Loc, T, CompleteTypeKind::Default, Diagnoser);\n  }\n  bool RequireCompleteType(SourceLocation Loc, QualType T, unsigned DiagID) {\n    return RequireCompleteType(Loc, T, CompleteTypeKind::Default, DiagID);\n  }\n\n  template <typename... Ts>\n  bool RequireCompleteType(SourceLocation Loc, QualType T, unsigned DiagID,\n                           const Ts &...Args) {\n    BoundTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireCompleteType(Loc, T, Diagnoser);\n  }\n\n  template <typename... Ts>\n  bool RequireCompleteSizedType(SourceLocation Loc, QualType T, unsigned DiagID,\n                                const Ts &... Args) {\n    SizelessTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireCompleteType(Loc, T, CompleteTypeKind::Normal, Diagnoser);\n  }\n\n  /// Get the type of expression E, triggering instantiation to complete the\n  /// type if necessary -- that is, if the expression refers to a templated\n  /// static data member of incomplete array type.\n  ///\n  /// May still return an incomplete type if instantiation was not possible or\n  /// if the type is incomplete for a different reason. Use\n  /// RequireCompleteExprType instead if a diagnostic is expected for an\n  /// incomplete expression type.\n  QualType getCompletedType(Expr *E);\n\n  void completeExprArrayBound(Expr *E);\n  bool RequireCompleteExprType(Expr *E, CompleteTypeKind Kind,\n                               TypeDiagnoser &Diagnoser);\n  bool RequireCompleteExprType(Expr *E, unsigned DiagID);\n\n  template <typename... Ts>\n  bool RequireCompleteExprType(Expr *E, unsigned DiagID, const Ts &...Args) {\n    BoundTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireCompleteExprType(E, CompleteTypeKind::Default, Diagnoser);\n  }\n\n  template <typename... Ts>\n  bool RequireCompleteSizedExprType(Expr *E, unsigned DiagID,\n                                    const Ts &... Args) {\n    SizelessTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireCompleteExprType(E, CompleteTypeKind::Normal, Diagnoser);\n  }\n\n  bool RequireLiteralType(SourceLocation Loc, QualType T,\n                          TypeDiagnoser &Diagnoser);\n  bool RequireLiteralType(SourceLocation Loc, QualType T, unsigned DiagID);\n\n  template <typename... Ts>\n  bool RequireLiteralType(SourceLocation Loc, QualType T, unsigned DiagID,\n                          const Ts &...Args) {\n    BoundTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireLiteralType(Loc, T, Diagnoser);\n  }\n\n  QualType getElaboratedType(ElaboratedTypeKeyword Keyword,\n                             const CXXScopeSpec &SS, QualType T,\n                             TagDecl *OwnedTagDecl = nullptr);\n\n  QualType BuildTypeofExprType(Expr *E, SourceLocation Loc);\n  /// If AsUnevaluated is false, E is treated as though it were an evaluated\n  /// context, such as when building a type for decltype(auto).\n  QualType BuildDecltypeType(Expr *E, SourceLocation Loc,\n                             bool AsUnevaluated = true);\n  QualType BuildUnaryTransformType(QualType BaseType,\n                                   UnaryTransformType::UTTKind UKind,\n                                   SourceLocation Loc);\n\n  //===--------------------------------------------------------------------===//\n  // Symbol table / Decl tracking callbacks: SemaDecl.cpp.\n  //\n\n  struct SkipBodyInfo {\n    SkipBodyInfo()\n        : ShouldSkip(false), CheckSameAsPrevious(false), Previous(nullptr),\n          New(nullptr) {}\n    bool ShouldSkip;\n    bool CheckSameAsPrevious;\n    NamedDecl *Previous;\n    NamedDecl *New;\n  };\n\n  DeclGroupPtrTy ConvertDeclToDeclGroup(Decl *Ptr, Decl *OwnedType = nullptr);\n\n  void DiagnoseUseOfUnimplementedSelectors();\n\n  bool isSimpleTypeSpecifier(tok::TokenKind Kind) const;\n\n  ParsedType getTypeName(const IdentifierInfo &II, SourceLocation NameLoc,\n                         Scope *S, CXXScopeSpec *SS = nullptr,\n                         bool isClassName = false, bool HasTrailingDot = false,\n                         ParsedType ObjectType = nullptr,\n                         bool IsCtorOrDtorName = false,\n                         bool WantNontrivialTypeSourceInfo = false,\n                         bool IsClassTemplateDeductionContext = true,\n                         IdentifierInfo **CorrectedII = nullptr);\n  TypeSpecifierType isTagName(IdentifierInfo &II, Scope *S);\n  bool isMicrosoftMissingTypename(const CXXScopeSpec *SS, Scope *S);\n  void DiagnoseUnknownTypeName(IdentifierInfo *&II,\n                               SourceLocation IILoc,\n                               Scope *S,\n                               CXXScopeSpec *SS,\n                               ParsedType &SuggestedType,\n                               bool IsTemplateName = false);\n\n  /// Attempt to behave like MSVC in situations where lookup of an unqualified\n  /// type name has failed in a dependent context. In these situations, we\n  /// automatically form a DependentTypeName that will retry lookup in a related\n  /// scope during instantiation.\n  ParsedType ActOnMSVCUnknownTypeName(const IdentifierInfo &II,\n                                      SourceLocation NameLoc,\n                                      bool IsTemplateTypeArg);\n\n  /// Describes the result of the name lookup and resolution performed\n  /// by \\c ClassifyName().\n  enum NameClassificationKind {\n    /// This name is not a type or template in this context, but might be\n    /// something else.\n    NC_Unknown,\n    /// Classification failed; an error has been produced.\n    NC_Error,\n    /// The name has been typo-corrected to a keyword.\n    NC_Keyword,\n    /// The name was classified as a type.\n    NC_Type,\n    /// The name was classified as a specific non-type, non-template\n    /// declaration. ActOnNameClassifiedAsNonType should be called to\n    /// convert the declaration to an expression.\n    NC_NonType,\n    /// The name was classified as an ADL-only function name.\n    /// ActOnNameClassifiedAsUndeclaredNonType should be called to convert the\n    /// result to an expression.\n    NC_UndeclaredNonType,\n    /// The name denotes a member of a dependent type that could not be\n    /// resolved. ActOnNameClassifiedAsDependentNonType should be called to\n    /// convert the result to an expression.\n    NC_DependentNonType,\n    /// The name was classified as an overload set, and an expression\n    /// representing that overload set has been formed.\n    /// ActOnNameClassifiedAsOverloadSet should be called to form a suitable\n    /// expression referencing the overload set.\n    NC_OverloadSet,\n    /// The name was classified as a template whose specializations are types.\n    NC_TypeTemplate,\n    /// The name was classified as a variable template name.\n    NC_VarTemplate,\n    /// The name was classified as a function template name.\n    NC_FunctionTemplate,\n    /// The name was classified as an ADL-only function template name.\n    NC_UndeclaredTemplate,\n    /// The name was classified as a concept name.\n    NC_Concept,\n  };\n\n  class NameClassification {\n    NameClassificationKind Kind;\n    union {\n      ExprResult Expr;\n      NamedDecl *NonTypeDecl;\n      TemplateName Template;\n      ParsedType Type;\n    };\n\n    explicit NameClassification(NameClassificationKind Kind) : Kind(Kind) {}\n\n  public:\n    NameClassification(ParsedType Type) : Kind(NC_Type), Type(Type) {}\n\n    NameClassification(const IdentifierInfo *Keyword) : Kind(NC_Keyword) {}\n\n    static NameClassification Error() {\n      return NameClassification(NC_Error);\n    }\n\n    static NameClassification Unknown() {\n      return NameClassification(NC_Unknown);\n    }\n\n    static NameClassification OverloadSet(ExprResult E) {\n      NameClassification Result(NC_OverloadSet);\n      Result.Expr = E;\n      return Result;\n    }\n\n    static NameClassification NonType(NamedDecl *D) {\n      NameClassification Result(NC_NonType);\n      Result.NonTypeDecl = D;\n      return Result;\n    }\n\n    static NameClassification UndeclaredNonType() {\n      return NameClassification(NC_UndeclaredNonType);\n    }\n\n    static NameClassification DependentNonType() {\n      return NameClassification(NC_DependentNonType);\n    }\n\n    static NameClassification TypeTemplate(TemplateName Name) {\n      NameClassification Result(NC_TypeTemplate);\n      Result.Template = Name;\n      return Result;\n    }\n\n    static NameClassification VarTemplate(TemplateName Name) {\n      NameClassification Result(NC_VarTemplate);\n      Result.Template = Name;\n      return Result;\n    }\n\n    static NameClassification FunctionTemplate(TemplateName Name) {\n      NameClassification Result(NC_FunctionTemplate);\n      Result.Template = Name;\n      return Result;\n    }\n\n    static NameClassification Concept(TemplateName Name) {\n      NameClassification Result(NC_Concept);\n      Result.Template = Name;\n      return Result;\n    }\n\n    static NameClassification UndeclaredTemplate(TemplateName Name) {\n      NameClassification Result(NC_UndeclaredTemplate);\n      Result.Template = Name;\n      return Result;\n    }\n\n    NameClassificationKind getKind() const { return Kind; }\n\n    ExprResult getExpression() const {\n      assert(Kind == NC_OverloadSet);\n      return Expr;\n    }\n\n    ParsedType getType() const {\n      assert(Kind == NC_Type);\n      return Type;\n    }\n\n    NamedDecl *getNonTypeDecl() const {\n      assert(Kind == NC_NonType);\n      return NonTypeDecl;\n    }\n\n    TemplateName getTemplateName() const {\n      assert(Kind == NC_TypeTemplate || Kind == NC_FunctionTemplate ||\n             Kind == NC_VarTemplate || Kind == NC_Concept ||\n             Kind == NC_UndeclaredTemplate);\n      return Template;\n    }\n\n    TemplateNameKind getTemplateNameKind() const {\n      switch (Kind) {\n      case NC_TypeTemplate:\n        return TNK_Type_template;\n      case NC_FunctionTemplate:\n        return TNK_Function_template;\n      case NC_VarTemplate:\n        return TNK_Var_template;\n      case NC_Concept:\n        return TNK_Concept_template;\n      case NC_UndeclaredTemplate:\n        return TNK_Undeclared_template;\n      default:\n        llvm_unreachable(\"unsupported name classification.\");\n      }\n    }\n  };\n\n  /// Perform name lookup on the given name, classifying it based on\n  /// the results of name lookup and the following token.\n  ///\n  /// This routine is used by the parser to resolve identifiers and help direct\n  /// parsing. When the identifier cannot be found, this routine will attempt\n  /// to correct the typo and classify based on the resulting name.\n  ///\n  /// \\param S The scope in which we're performing name lookup.\n  ///\n  /// \\param SS The nested-name-specifier that precedes the name.\n  ///\n  /// \\param Name The identifier. If typo correction finds an alternative name,\n  /// this pointer parameter will be updated accordingly.\n  ///\n  /// \\param NameLoc The location of the identifier.\n  ///\n  /// \\param NextToken The token following the identifier. Used to help\n  /// disambiguate the name.\n  ///\n  /// \\param CCC The correction callback, if typo correction is desired.\n  NameClassification ClassifyName(Scope *S, CXXScopeSpec &SS,\n                                  IdentifierInfo *&Name, SourceLocation NameLoc,\n                                  const Token &NextToken,\n                                  CorrectionCandidateCallback *CCC = nullptr);\n\n  /// Act on the result of classifying a name as an undeclared (ADL-only)\n  /// non-type declaration.\n  ExprResult ActOnNameClassifiedAsUndeclaredNonType(IdentifierInfo *Name,\n                                                    SourceLocation NameLoc);\n  /// Act on the result of classifying a name as an undeclared member of a\n  /// dependent base class.\n  ExprResult ActOnNameClassifiedAsDependentNonType(const CXXScopeSpec &SS,\n                                                   IdentifierInfo *Name,\n                                                   SourceLocation NameLoc,\n                                                   bool IsAddressOfOperand);\n  /// Act on the result of classifying a name as a specific non-type\n  /// declaration.\n  ExprResult ActOnNameClassifiedAsNonType(Scope *S, const CXXScopeSpec &SS,\n                                          NamedDecl *Found,\n                                          SourceLocation NameLoc,\n                                          const Token &NextToken);\n  /// Act on the result of classifying a name as an overload set.\n  ExprResult ActOnNameClassifiedAsOverloadSet(Scope *S, Expr *OverloadSet);\n\n  /// Describes the detailed kind of a template name. Used in diagnostics.\n  enum class TemplateNameKindForDiagnostics {\n    ClassTemplate,\n    FunctionTemplate,\n    VarTemplate,\n    AliasTemplate,\n    TemplateTemplateParam,\n    Concept,\n    DependentTemplate\n  };\n  TemplateNameKindForDiagnostics\n  getTemplateNameKindForDiagnostics(TemplateName Name);\n\n  /// Determine whether it's plausible that E was intended to be a\n  /// template-name.\n  bool mightBeIntendedToBeTemplateName(ExprResult E, bool &Dependent) {\n    if (!getLangOpts().CPlusPlus || E.isInvalid())\n      return false;\n    Dependent = false;\n    if (auto *DRE = dyn_cast<DeclRefExpr>(E.get()))\n      return !DRE->hasExplicitTemplateArgs();\n    if (auto *ME = dyn_cast<MemberExpr>(E.get()))\n      return !ME->hasExplicitTemplateArgs();\n    Dependent = true;\n    if (auto *DSDRE = dyn_cast<DependentScopeDeclRefExpr>(E.get()))\n      return !DSDRE->hasExplicitTemplateArgs();\n    if (auto *DSME = dyn_cast<CXXDependentScopeMemberExpr>(E.get()))\n      return !DSME->hasExplicitTemplateArgs();\n    // Any additional cases recognized here should also be handled by\n    // diagnoseExprIntendedAsTemplateName.\n    return false;\n  }\n  void diagnoseExprIntendedAsTemplateName(Scope *S, ExprResult TemplateName,\n                                          SourceLocation Less,\n                                          SourceLocation Greater);\n\n  Decl *ActOnDeclarator(Scope *S, Declarator &D);\n\n  NamedDecl *HandleDeclarator(Scope *S, Declarator &D,\n                              MultiTemplateParamsArg TemplateParameterLists);\n  void RegisterLocallyScopedExternCDecl(NamedDecl *ND, Scope *S);\n  bool DiagnoseClassNameShadow(DeclContext *DC, DeclarationNameInfo Info);\n  bool diagnoseQualifiedDeclaration(CXXScopeSpec &SS, DeclContext *DC,\n                                    DeclarationName Name, SourceLocation Loc,\n                                    bool IsTemplateId);\n  void\n  diagnoseIgnoredQualifiers(unsigned DiagID, unsigned Quals,\n                            SourceLocation FallbackLoc,\n                            SourceLocation ConstQualLoc = SourceLocation(),\n                            SourceLocation VolatileQualLoc = SourceLocation(),\n                            SourceLocation RestrictQualLoc = SourceLocation(),\n                            SourceLocation AtomicQualLoc = SourceLocation(),\n                            SourceLocation UnalignedQualLoc = SourceLocation());\n\n  static bool adjustContextForLocalExternDecl(DeclContext *&DC);\n  void DiagnoseFunctionSpecifiers(const DeclSpec &DS);\n  NamedDecl *getShadowedDeclaration(const TypedefNameDecl *D,\n                                    const LookupResult &R);\n  NamedDecl *getShadowedDeclaration(const VarDecl *D, const LookupResult &R);\n  NamedDecl *getShadowedDeclaration(const BindingDecl *D,\n                                    const LookupResult &R);\n  void CheckShadow(NamedDecl *D, NamedDecl *ShadowedDecl,\n                   const LookupResult &R);\n  void CheckShadow(Scope *S, VarDecl *D);\n\n  /// Warn if 'E', which is an expression that is about to be modified, refers\n  /// to a shadowing declaration.\n  void CheckShadowingDeclModification(Expr *E, SourceLocation Loc);\n\n  void DiagnoseShadowingLambdaDecls(const sema::LambdaScopeInfo *LSI);\n\nprivate:\n  /// Map of current shadowing declarations to shadowed declarations. Warn if\n  /// it looks like the user is trying to modify the shadowing declaration.\n  llvm::DenseMap<const NamedDecl *, const NamedDecl *> ShadowingDecls;\n\npublic:\n  void CheckCastAlign(Expr *Op, QualType T, SourceRange TRange);\n  void handleTagNumbering(const TagDecl *Tag, Scope *TagScope);\n  void setTagNameForLinkagePurposes(TagDecl *TagFromDeclSpec,\n                                    TypedefNameDecl *NewTD);\n  void CheckTypedefForVariablyModifiedType(Scope *S, TypedefNameDecl *D);\n  NamedDecl* ActOnTypedefDeclarator(Scope* S, Declarator& D, DeclContext* DC,\n                                    TypeSourceInfo *TInfo,\n                                    LookupResult &Previous);\n  NamedDecl* ActOnTypedefNameDecl(Scope* S, DeclContext* DC, TypedefNameDecl *D,\n                                  LookupResult &Previous, bool &Redeclaration);\n  NamedDecl *ActOnVariableDeclarator(Scope *S, Declarator &D, DeclContext *DC,\n                                     TypeSourceInfo *TInfo,\n                                     LookupResult &Previous,\n                                     MultiTemplateParamsArg TemplateParamLists,\n                                     bool &AddToScope,\n                                     ArrayRef<BindingDecl *> Bindings = None);\n  NamedDecl *\n  ActOnDecompositionDeclarator(Scope *S, Declarator &D,\n                               MultiTemplateParamsArg TemplateParamLists);\n  // Returns true if the variable declaration is a redeclaration\n  bool CheckVariableDeclaration(VarDecl *NewVD, LookupResult &Previous);\n  void CheckVariableDeclarationType(VarDecl *NewVD);\n  bool DeduceVariableDeclarationType(VarDecl *VDecl, bool DirectInit,\n                                     Expr *Init);\n  void CheckCompleteVariableDeclaration(VarDecl *VD);\n  void CheckCompleteDecompositionDeclaration(DecompositionDecl *DD);\n  void MaybeSuggestAddingStaticToDecl(const FunctionDecl *D);\n\n  NamedDecl* ActOnFunctionDeclarator(Scope* S, Declarator& D, DeclContext* DC,\n                                     TypeSourceInfo *TInfo,\n                                     LookupResult &Previous,\n                                     MultiTemplateParamsArg TemplateParamLists,\n                                     bool &AddToScope);\n  bool AddOverriddenMethods(CXXRecordDecl *DC, CXXMethodDecl *MD);\n\n  enum class CheckConstexprKind {\n    /// Diagnose issues that are non-constant or that are extensions.\n    Diagnose,\n    /// Identify whether this function satisfies the formal rules for constexpr\n    /// functions in the current lanugage mode (with no extensions).\n    CheckValid\n  };\n\n  bool CheckConstexprFunctionDefinition(const FunctionDecl *FD,\n                                        CheckConstexprKind Kind);\n\n  void DiagnoseHiddenVirtualMethods(CXXMethodDecl *MD);\n  void FindHiddenVirtualMethods(CXXMethodDecl *MD,\n                          SmallVectorImpl<CXXMethodDecl*> &OverloadedMethods);\n  void NoteHiddenVirtualMethods(CXXMethodDecl *MD,\n                          SmallVectorImpl<CXXMethodDecl*> &OverloadedMethods);\n  // Returns true if the function declaration is a redeclaration\n  bool CheckFunctionDeclaration(Scope *S,\n                                FunctionDecl *NewFD, LookupResult &Previous,\n                                bool IsMemberSpecialization);\n  bool shouldLinkDependentDeclWithPrevious(Decl *D, Decl *OldDecl);\n  bool canFullyTypeCheckRedeclaration(ValueDecl *NewD, ValueDecl *OldD,\n                                      QualType NewT, QualType OldT);\n  void CheckMain(FunctionDecl *FD, const DeclSpec &D);\n  void CheckMSVCRTEntryPoint(FunctionDecl *FD);\n  Attr *getImplicitCodeSegOrSectionAttrForFunction(const FunctionDecl *FD,\n                                                   bool IsDefinition);\n  void CheckFunctionOrTemplateParamDeclarator(Scope *S, Declarator &D);\n  Decl *ActOnParamDeclarator(Scope *S, Declarator &D);\n  ParmVarDecl *BuildParmVarDeclForTypedef(DeclContext *DC,\n                                          SourceLocation Loc,\n                                          QualType T);\n  ParmVarDecl *CheckParameter(DeclContext *DC, SourceLocation StartLoc,\n                              SourceLocation NameLoc, IdentifierInfo *Name,\n                              QualType T, TypeSourceInfo *TSInfo,\n                              StorageClass SC);\n  void ActOnParamDefaultArgument(Decl *param,\n                                 SourceLocation EqualLoc,\n                                 Expr *defarg);\n  void ActOnParamUnparsedDefaultArgument(Decl *param, SourceLocation EqualLoc,\n                                         SourceLocation ArgLoc);\n  void ActOnParamDefaultArgumentError(Decl *param, SourceLocation EqualLoc);\n  ExprResult ConvertParamDefaultArgument(const ParmVarDecl *Param,\n                                         Expr *DefaultArg,\n                                         SourceLocation EqualLoc);\n  void SetParamDefaultArgument(ParmVarDecl *Param, Expr *DefaultArg,\n                               SourceLocation EqualLoc);\n\n  // Contexts where using non-trivial C union types can be disallowed. This is\n  // passed to err_non_trivial_c_union_in_invalid_context.\n  enum NonTrivialCUnionContext {\n    // Function parameter.\n    NTCUC_FunctionParam,\n    // Function return.\n    NTCUC_FunctionReturn,\n    // Default-initialized object.\n    NTCUC_DefaultInitializedObject,\n    // Variable with automatic storage duration.\n    NTCUC_AutoVar,\n    // Initializer expression that might copy from another object.\n    NTCUC_CopyInit,\n    // Assignment.\n    NTCUC_Assignment,\n    // Compound literal.\n    NTCUC_CompoundLiteral,\n    // Block capture.\n    NTCUC_BlockCapture,\n    // lvalue-to-rvalue conversion of volatile type.\n    NTCUC_LValueToRValueVolatile,\n  };\n\n  /// Emit diagnostics if the initializer or any of its explicit or\n  /// implicitly-generated subexpressions require copying or\n  /// default-initializing a type that is or contains a C union type that is\n  /// non-trivial to copy or default-initialize.\n  void checkNonTrivialCUnionInInitializer(const Expr *Init, SourceLocation Loc);\n\n  // These flags are passed to checkNonTrivialCUnion.\n  enum NonTrivialCUnionKind {\n    NTCUK_Init = 0x1,\n    NTCUK_Destruct = 0x2,\n    NTCUK_Copy = 0x4,\n  };\n\n  /// Emit diagnostics if a non-trivial C union type or a struct that contains\n  /// a non-trivial C union is used in an invalid context.\n  void checkNonTrivialCUnion(QualType QT, SourceLocation Loc,\n                             NonTrivialCUnionContext UseContext,\n                             unsigned NonTrivialKind);\n\n  void AddInitializerToDecl(Decl *dcl, Expr *init, bool DirectInit);\n  void ActOnUninitializedDecl(Decl *dcl);\n  void ActOnInitializerError(Decl *Dcl);\n\n  void ActOnPureSpecifier(Decl *D, SourceLocation PureSpecLoc);\n  void ActOnCXXForRangeDecl(Decl *D);\n  StmtResult ActOnCXXForRangeIdentifier(Scope *S, SourceLocation IdentLoc,\n                                        IdentifierInfo *Ident,\n                                        ParsedAttributes &Attrs,\n                                        SourceLocation AttrEnd);\n  void SetDeclDeleted(Decl *dcl, SourceLocation DelLoc);\n  void SetDeclDefaulted(Decl *dcl, SourceLocation DefaultLoc);\n  void CheckStaticLocalForDllExport(VarDecl *VD);\n  void FinalizeDeclaration(Decl *D);\n  DeclGroupPtrTy FinalizeDeclaratorGroup(Scope *S, const DeclSpec &DS,\n                                         ArrayRef<Decl *> Group);\n  DeclGroupPtrTy BuildDeclaratorGroup(MutableArrayRef<Decl *> Group);\n\n  /// Should be called on all declarations that might have attached\n  /// documentation comments.\n  void ActOnDocumentableDecl(Decl *D);\n  void ActOnDocumentableDecls(ArrayRef<Decl *> Group);\n\n  void ActOnFinishKNRParamDeclarations(Scope *S, Declarator &D,\n                                       SourceLocation LocAfterDecls);\n  void CheckForFunctionRedefinition(\n      FunctionDecl *FD, const FunctionDecl *EffectiveDefinition = nullptr,\n      SkipBodyInfo *SkipBody = nullptr);\n  Decl *ActOnStartOfFunctionDef(Scope *S, Declarator &D,\n                                MultiTemplateParamsArg TemplateParamLists,\n                                SkipBodyInfo *SkipBody = nullptr);\n  Decl *ActOnStartOfFunctionDef(Scope *S, Decl *D,\n                                SkipBodyInfo *SkipBody = nullptr);\n  void ActOnStartTrailingRequiresClause(Scope *S, Declarator &D);\n  ExprResult ActOnFinishTrailingRequiresClause(ExprResult ConstraintExpr);\n  ExprResult ActOnRequiresClause(ExprResult ConstraintExpr);\n  void ActOnStartOfObjCMethodDef(Scope *S, Decl *D);\n  bool isObjCMethodDecl(Decl *D) {\n    return D && isa<ObjCMethodDecl>(D);\n  }\n\n  /// Determine whether we can delay parsing the body of a function or\n  /// function template until it is used, assuming we don't care about emitting\n  /// code for that function.\n  ///\n  /// This will be \\c false if we may need the body of the function in the\n  /// middle of parsing an expression (where it's impractical to switch to\n  /// parsing a different function), for instance, if it's constexpr in C++11\n  /// or has an 'auto' return type in C++14. These cases are essentially bugs.\n  bool canDelayFunctionBody(const Declarator &D);\n\n  /// Determine whether we can skip parsing the body of a function\n  /// definition, assuming we don't care about analyzing its body or emitting\n  /// code for that function.\n  ///\n  /// This will be \\c false only if we may need the body of the function in\n  /// order to parse the rest of the program (for instance, if it is\n  /// \\c constexpr in C++11 or has an 'auto' return type in C++14).\n  bool canSkipFunctionBody(Decl *D);\n\n  void computeNRVO(Stmt *Body, sema::FunctionScopeInfo *Scope);\n  Decl *ActOnFinishFunctionBody(Decl *Decl, Stmt *Body);\n  Decl *ActOnFinishFunctionBody(Decl *Decl, Stmt *Body, bool IsInstantiation);\n  Decl *ActOnSkippedFunctionBody(Decl *Decl);\n  void ActOnFinishInlineFunctionDef(FunctionDecl *D);\n\n  /// ActOnFinishDelayedAttribute - Invoked when we have finished parsing an\n  /// attribute for which parsing is delayed.\n  void ActOnFinishDelayedAttribute(Scope *S, Decl *D, ParsedAttributes &Attrs);\n\n  /// Diagnose any unused parameters in the given sequence of\n  /// ParmVarDecl pointers.\n  void DiagnoseUnusedParameters(ArrayRef<ParmVarDecl *> Parameters);\n\n  /// Diagnose whether the size of parameters or return value of a\n  /// function or obj-c method definition is pass-by-value and larger than a\n  /// specified threshold.\n  void\n  DiagnoseSizeOfParametersAndReturnValue(ArrayRef<ParmVarDecl *> Parameters,\n                                         QualType ReturnTy, NamedDecl *D);\n\n  void DiagnoseInvalidJumps(Stmt *Body);\n  Decl *ActOnFileScopeAsmDecl(Expr *expr,\n                              SourceLocation AsmLoc,\n                              SourceLocation RParenLoc);\n\n  /// Handle a C++11 empty-declaration and attribute-declaration.\n  Decl *ActOnEmptyDeclaration(Scope *S, const ParsedAttributesView &AttrList,\n                              SourceLocation SemiLoc);\n\n  enum class ModuleDeclKind {\n    Interface,      ///< 'export module X;'\n    Implementation, ///< 'module X;'\n  };\n\n  /// The parser has processed a module-declaration that begins the definition\n  /// of a module interface or implementation.\n  DeclGroupPtrTy ActOnModuleDecl(SourceLocation StartLoc,\n                                 SourceLocation ModuleLoc, ModuleDeclKind MDK,\n                                 ModuleIdPath Path, bool IsFirstDecl);\n\n  /// The parser has processed a global-module-fragment declaration that begins\n  /// the definition of the global module fragment of the current module unit.\n  /// \\param ModuleLoc The location of the 'module' keyword.\n  DeclGroupPtrTy ActOnGlobalModuleFragmentDecl(SourceLocation ModuleLoc);\n\n  /// The parser has processed a private-module-fragment declaration that begins\n  /// the definition of the private module fragment of the current module unit.\n  /// \\param ModuleLoc The location of the 'module' keyword.\n  /// \\param PrivateLoc The location of the 'private' keyword.\n  DeclGroupPtrTy ActOnPrivateModuleFragmentDecl(SourceLocation ModuleLoc,\n                                                SourceLocation PrivateLoc);\n\n  /// The parser has processed a module import declaration.\n  ///\n  /// \\param StartLoc The location of the first token in the declaration. This\n  ///        could be the location of an '@', 'export', or 'import'.\n  /// \\param ExportLoc The location of the 'export' keyword, if any.\n  /// \\param ImportLoc The location of the 'import' keyword.\n  /// \\param Path The module access path.\n  DeclResult ActOnModuleImport(SourceLocation StartLoc,\n                               SourceLocation ExportLoc,\n                               SourceLocation ImportLoc, ModuleIdPath Path);\n  DeclResult ActOnModuleImport(SourceLocation StartLoc,\n                               SourceLocation ExportLoc,\n                               SourceLocation ImportLoc, Module *M,\n                               ModuleIdPath Path = {});\n\n  /// The parser has processed a module import translated from a\n  /// #include or similar preprocessing directive.\n  void ActOnModuleInclude(SourceLocation DirectiveLoc, Module *Mod);\n  void BuildModuleInclude(SourceLocation DirectiveLoc, Module *Mod);\n\n  /// The parsed has entered a submodule.\n  void ActOnModuleBegin(SourceLocation DirectiveLoc, Module *Mod);\n  /// The parser has left a submodule.\n  void ActOnModuleEnd(SourceLocation DirectiveLoc, Module *Mod);\n\n  /// Create an implicit import of the given module at the given\n  /// source location, for error recovery, if possible.\n  ///\n  /// This routine is typically used when an entity found by name lookup\n  /// is actually hidden within a module that we know about but the user\n  /// has forgotten to import.\n  void createImplicitModuleImportForErrorRecovery(SourceLocation Loc,\n                                                  Module *Mod);\n\n  /// Kinds of missing import. Note, the values of these enumerators correspond\n  /// to %select values in diagnostics.\n  enum class MissingImportKind {\n    Declaration,\n    Definition,\n    DefaultArgument,\n    ExplicitSpecialization,\n    PartialSpecialization\n  };\n\n  /// Diagnose that the specified declaration needs to be visible but\n  /// isn't, and suggest a module import that would resolve the problem.\n  void diagnoseMissingImport(SourceLocation Loc, NamedDecl *Decl,\n                             MissingImportKind MIK, bool Recover = true);\n  void diagnoseMissingImport(SourceLocation Loc, NamedDecl *Decl,\n                             SourceLocation DeclLoc, ArrayRef<Module *> Modules,\n                             MissingImportKind MIK, bool Recover);\n\n  Decl *ActOnStartExportDecl(Scope *S, SourceLocation ExportLoc,\n                             SourceLocation LBraceLoc);\n  Decl *ActOnFinishExportDecl(Scope *S, Decl *ExportDecl,\n                              SourceLocation RBraceLoc);\n\n  /// We've found a use of a templated declaration that would trigger an\n  /// implicit instantiation. Check that any relevant explicit specializations\n  /// and partial specializations are visible, and diagnose if not.\n  void checkSpecializationVisibility(SourceLocation Loc, NamedDecl *Spec);\n\n  /// Retrieve a suitable printing policy for diagnostics.\n  PrintingPolicy getPrintingPolicy() const {\n    return getPrintingPolicy(Context, PP);\n  }\n\n  /// Retrieve a suitable printing policy for diagnostics.\n  static PrintingPolicy getPrintingPolicy(const ASTContext &Ctx,\n                                          const Preprocessor &PP);\n\n  /// Scope actions.\n  void ActOnPopScope(SourceLocation Loc, Scope *S);\n  void ActOnTranslationUnitScope(Scope *S);\n\n  Decl *ParsedFreeStandingDeclSpec(Scope *S, AccessSpecifier AS, DeclSpec &DS,\n                                   RecordDecl *&AnonRecord);\n  Decl *ParsedFreeStandingDeclSpec(Scope *S, AccessSpecifier AS, DeclSpec &DS,\n                                   MultiTemplateParamsArg TemplateParams,\n                                   bool IsExplicitInstantiation,\n                                   RecordDecl *&AnonRecord);\n\n  Decl *BuildAnonymousStructOrUnion(Scope *S, DeclSpec &DS,\n                                    AccessSpecifier AS,\n                                    RecordDecl *Record,\n                                    const PrintingPolicy &Policy);\n\n  Decl *BuildMicrosoftCAnonymousStruct(Scope *S, DeclSpec &DS,\n                                       RecordDecl *Record);\n\n  /// Common ways to introduce type names without a tag for use in diagnostics.\n  /// Keep in sync with err_tag_reference_non_tag.\n  enum NonTagKind {\n    NTK_NonStruct,\n    NTK_NonClass,\n    NTK_NonUnion,\n    NTK_NonEnum,\n    NTK_Typedef,\n    NTK_TypeAlias,\n    NTK_Template,\n    NTK_TypeAliasTemplate,\n    NTK_TemplateTemplateArgument,\n  };\n\n  /// Given a non-tag type declaration, returns an enum useful for indicating\n  /// what kind of non-tag type this is.\n  NonTagKind getNonTagTypeDeclKind(const Decl *D, TagTypeKind TTK);\n\n  bool isAcceptableTagRedeclaration(const TagDecl *Previous,\n                                    TagTypeKind NewTag, bool isDefinition,\n                                    SourceLocation NewTagLoc,\n                                    const IdentifierInfo *Name);\n\n  enum TagUseKind {\n    TUK_Reference,   // Reference to a tag:  'struct foo *X;'\n    TUK_Declaration, // Fwd decl of a tag:   'struct foo;'\n    TUK_Definition,  // Definition of a tag: 'struct foo { int X; } Y;'\n    TUK_Friend       // Friend declaration:  'friend struct foo;'\n  };\n\n  Decl *ActOnTag(Scope *S, unsigned TagSpec, TagUseKind TUK,\n                 SourceLocation KWLoc, CXXScopeSpec &SS, IdentifierInfo *Name,\n                 SourceLocation NameLoc, const ParsedAttributesView &Attr,\n                 AccessSpecifier AS, SourceLocation ModulePrivateLoc,\n                 MultiTemplateParamsArg TemplateParameterLists, bool &OwnedDecl,\n                 bool &IsDependent, SourceLocation ScopedEnumKWLoc,\n                 bool ScopedEnumUsesClassTag, TypeResult UnderlyingType,\n                 bool IsTypeSpecifier, bool IsTemplateParamOrArg,\n                 SkipBodyInfo *SkipBody = nullptr);\n\n  Decl *ActOnTemplatedFriendTag(Scope *S, SourceLocation FriendLoc,\n                                unsigned TagSpec, SourceLocation TagLoc,\n                                CXXScopeSpec &SS, IdentifierInfo *Name,\n                                SourceLocation NameLoc,\n                                const ParsedAttributesView &Attr,\n                                MultiTemplateParamsArg TempParamLists);\n\n  TypeResult ActOnDependentTag(Scope *S,\n                               unsigned TagSpec,\n                               TagUseKind TUK,\n                               const CXXScopeSpec &SS,\n                               IdentifierInfo *Name,\n                               SourceLocation TagLoc,\n                               SourceLocation NameLoc);\n\n  void ActOnDefs(Scope *S, Decl *TagD, SourceLocation DeclStart,\n                 IdentifierInfo *ClassName,\n                 SmallVectorImpl<Decl *> &Decls);\n  Decl *ActOnField(Scope *S, Decl *TagD, SourceLocation DeclStart,\n                   Declarator &D, Expr *BitfieldWidth);\n\n  FieldDecl *HandleField(Scope *S, RecordDecl *TagD, SourceLocation DeclStart,\n                         Declarator &D, Expr *BitfieldWidth,\n                         InClassInitStyle InitStyle,\n                         AccessSpecifier AS);\n  MSPropertyDecl *HandleMSProperty(Scope *S, RecordDecl *TagD,\n                                   SourceLocation DeclStart, Declarator &D,\n                                   Expr *BitfieldWidth,\n                                   InClassInitStyle InitStyle,\n                                   AccessSpecifier AS,\n                                   const ParsedAttr &MSPropertyAttr);\n\n  FieldDecl *CheckFieldDecl(DeclarationName Name, QualType T,\n                            TypeSourceInfo *TInfo,\n                            RecordDecl *Record, SourceLocation Loc,\n                            bool Mutable, Expr *BitfieldWidth,\n                            InClassInitStyle InitStyle,\n                            SourceLocation TSSL,\n                            AccessSpecifier AS, NamedDecl *PrevDecl,\n                            Declarator *D = nullptr);\n\n  bool CheckNontrivialField(FieldDecl *FD);\n  void DiagnoseNontrivial(const CXXRecordDecl *Record, CXXSpecialMember CSM);\n\n  enum TrivialABIHandling {\n    /// The triviality of a method unaffected by \"trivial_abi\".\n    TAH_IgnoreTrivialABI,\n\n    /// The triviality of a method affected by \"trivial_abi\".\n    TAH_ConsiderTrivialABI\n  };\n\n  bool SpecialMemberIsTrivial(CXXMethodDecl *MD, CXXSpecialMember CSM,\n                              TrivialABIHandling TAH = TAH_IgnoreTrivialABI,\n                              bool Diagnose = false);\n\n  /// For a defaulted function, the kind of defaulted function that it is.\n  class DefaultedFunctionKind {\n    CXXSpecialMember SpecialMember : 8;\n    DefaultedComparisonKind Comparison : 8;\n\n  public:\n    DefaultedFunctionKind()\n        : SpecialMember(CXXInvalid), Comparison(DefaultedComparisonKind::None) {\n    }\n    DefaultedFunctionKind(CXXSpecialMember CSM)\n        : SpecialMember(CSM), Comparison(DefaultedComparisonKind::None) {}\n    DefaultedFunctionKind(DefaultedComparisonKind Comp)\n        : SpecialMember(CXXInvalid), Comparison(Comp) {}\n\n    bool isSpecialMember() const { return SpecialMember != CXXInvalid; }\n    bool isComparison() const {\n      return Comparison != DefaultedComparisonKind::None;\n    }\n\n    explicit operator bool() const {\n      return isSpecialMember() || isComparison();\n    }\n\n    CXXSpecialMember asSpecialMember() const { return SpecialMember; }\n    DefaultedComparisonKind asComparison() const { return Comparison; }\n\n    /// Get the index of this function kind for use in diagnostics.\n    unsigned getDiagnosticIndex() const {\n      static_assert(CXXInvalid > CXXDestructor,\n                    \"invalid should have highest index\");\n      static_assert((unsigned)DefaultedComparisonKind::None == 0,\n                    \"none should be equal to zero\");\n      return SpecialMember + (unsigned)Comparison;\n    }\n  };\n\n  DefaultedFunctionKind getDefaultedFunctionKind(const FunctionDecl *FD);\n\n  CXXSpecialMember getSpecialMember(const CXXMethodDecl *MD) {\n    return getDefaultedFunctionKind(MD).asSpecialMember();\n  }\n  DefaultedComparisonKind getDefaultedComparisonKind(const FunctionDecl *FD) {\n    return getDefaultedFunctionKind(FD).asComparison();\n  }\n\n  void ActOnLastBitfield(SourceLocation DeclStart,\n                         SmallVectorImpl<Decl *> &AllIvarDecls);\n  Decl *ActOnIvar(Scope *S, SourceLocation DeclStart,\n                  Declarator &D, Expr *BitfieldWidth,\n                  tok::ObjCKeywordKind visibility);\n\n  // This is used for both record definitions and ObjC interface declarations.\n  void ActOnFields(Scope *S, SourceLocation RecLoc, Decl *TagDecl,\n                   ArrayRef<Decl *> Fields, SourceLocation LBrac,\n                   SourceLocation RBrac, const ParsedAttributesView &AttrList);\n\n  /// ActOnTagStartDefinition - Invoked when we have entered the\n  /// scope of a tag's definition (e.g., for an enumeration, class,\n  /// struct, or union).\n  void ActOnTagStartDefinition(Scope *S, Decl *TagDecl);\n\n  /// Perform ODR-like check for C/ObjC when merging tag types from modules.\n  /// Differently from C++, actually parse the body and reject / error out\n  /// in case of a structural mismatch.\n  bool ActOnDuplicateDefinition(DeclSpec &DS, Decl *Prev,\n                                SkipBodyInfo &SkipBody);\n\n  typedef void *SkippedDefinitionContext;\n\n  /// Invoked when we enter a tag definition that we're skipping.\n  SkippedDefinitionContext ActOnTagStartSkippedDefinition(Scope *S, Decl *TD);\n\n  Decl *ActOnObjCContainerStartDefinition(Decl *IDecl);\n\n  /// ActOnStartCXXMemberDeclarations - Invoked when we have parsed a\n  /// C++ record definition's base-specifiers clause and are starting its\n  /// member declarations.\n  void ActOnStartCXXMemberDeclarations(Scope *S, Decl *TagDecl,\n                                       SourceLocation FinalLoc,\n                                       bool IsFinalSpelledSealed,\n                                       SourceLocation LBraceLoc);\n\n  /// ActOnTagFinishDefinition - Invoked once we have finished parsing\n  /// the definition of a tag (enumeration, class, struct, or union).\n  void ActOnTagFinishDefinition(Scope *S, Decl *TagDecl,\n                                SourceRange BraceRange);\n\n  void ActOnTagFinishSkippedDefinition(SkippedDefinitionContext Context);\n\n  void ActOnObjCContainerFinishDefinition();\n\n  /// Invoked when we must temporarily exit the objective-c container\n  /// scope for parsing/looking-up C constructs.\n  ///\n  /// Must be followed by a call to \\see ActOnObjCReenterContainerContext\n  void ActOnObjCTemporaryExitContainerContext(DeclContext *DC);\n  void ActOnObjCReenterContainerContext(DeclContext *DC);\n\n  /// ActOnTagDefinitionError - Invoked when there was an unrecoverable\n  /// error parsing the definition of a tag.\n  void ActOnTagDefinitionError(Scope *S, Decl *TagDecl);\n\n  EnumConstantDecl *CheckEnumConstant(EnumDecl *Enum,\n                                      EnumConstantDecl *LastEnumConst,\n                                      SourceLocation IdLoc,\n                                      IdentifierInfo *Id,\n                                      Expr *val);\n  bool CheckEnumUnderlyingType(TypeSourceInfo *TI);\n  bool CheckEnumRedeclaration(SourceLocation EnumLoc, bool IsScoped,\n                              QualType EnumUnderlyingTy, bool IsFixed,\n                              const EnumDecl *Prev);\n\n  /// Determine whether the body of an anonymous enumeration should be skipped.\n  /// \\param II The name of the first enumerator.\n  SkipBodyInfo shouldSkipAnonEnumBody(Scope *S, IdentifierInfo *II,\n                                      SourceLocation IILoc);\n\n  Decl *ActOnEnumConstant(Scope *S, Decl *EnumDecl, Decl *LastEnumConstant,\n                          SourceLocation IdLoc, IdentifierInfo *Id,\n                          const ParsedAttributesView &Attrs,\n                          SourceLocation EqualLoc, Expr *Val);\n  void ActOnEnumBody(SourceLocation EnumLoc, SourceRange BraceRange,\n                     Decl *EnumDecl, ArrayRef<Decl *> Elements, Scope *S,\n                     const ParsedAttributesView &Attr);\n\n  /// Set the current declaration context until it gets popped.\n  void PushDeclContext(Scope *S, DeclContext *DC);\n  void PopDeclContext();\n\n  /// EnterDeclaratorContext - Used when we must lookup names in the context\n  /// of a declarator's nested name specifier.\n  void EnterDeclaratorContext(Scope *S, DeclContext *DC);\n  void ExitDeclaratorContext(Scope *S);\n\n  /// Enter a template parameter scope, after it's been associated with a particular\n  /// DeclContext. Causes lookup within the scope to chain through enclosing contexts\n  /// in the correct order.\n  void EnterTemplatedContext(Scope *S, DeclContext *DC);\n\n  /// Push the parameters of D, which must be a function, into scope.\n  void ActOnReenterFunctionContext(Scope* S, Decl* D);\n  void ActOnExitFunctionContext();\n\n  DeclContext *getFunctionLevelDeclContext();\n\n  /// getCurFunctionDecl - If inside of a function body, this returns a pointer\n  /// to the function decl for the function being parsed.  If we're currently\n  /// in a 'block', this returns the containing context.\n  FunctionDecl *getCurFunctionDecl();\n\n  /// getCurMethodDecl - If inside of a method body, this returns a pointer to\n  /// the method decl for the method being parsed.  If we're currently\n  /// in a 'block', this returns the containing context.\n  ObjCMethodDecl *getCurMethodDecl();\n\n  /// getCurFunctionOrMethodDecl - Return the Decl for the current ObjC method\n  /// or C function we're in, otherwise return null.  If we're currently\n  /// in a 'block', this returns the containing context.\n  NamedDecl *getCurFunctionOrMethodDecl();\n\n  /// Add this decl to the scope shadowed decl chains.\n  void PushOnScopeChains(NamedDecl *D, Scope *S, bool AddToContext = true);\n\n  /// isDeclInScope - If 'Ctx' is a function/method, isDeclInScope returns true\n  /// if 'D' is in Scope 'S', otherwise 'S' is ignored and isDeclInScope returns\n  /// true if 'D' belongs to the given declaration context.\n  ///\n  /// \\param AllowInlineNamespace If \\c true, allow the declaration to be in the\n  ///        enclosing namespace set of the context, rather than contained\n  ///        directly within it.\n  bool isDeclInScope(NamedDecl *D, DeclContext *Ctx, Scope *S = nullptr,\n                     bool AllowInlineNamespace = false);\n\n  /// Finds the scope corresponding to the given decl context, if it\n  /// happens to be an enclosing scope.  Otherwise return NULL.\n  static Scope *getScopeForDeclContext(Scope *S, DeclContext *DC);\n\n  /// Subroutines of ActOnDeclarator().\n  TypedefDecl *ParseTypedefDecl(Scope *S, Declarator &D, QualType T,\n                                TypeSourceInfo *TInfo);\n  bool isIncompatibleTypedef(TypeDecl *Old, TypedefNameDecl *New);\n\n  /// Describes the kind of merge to perform for availability\n  /// attributes (including \"deprecated\", \"unavailable\", and \"availability\").\n  enum AvailabilityMergeKind {\n    /// Don't merge availability attributes at all.\n    AMK_None,\n    /// Merge availability attributes for a redeclaration, which requires\n    /// an exact match.\n    AMK_Redeclaration,\n    /// Merge availability attributes for an override, which requires\n    /// an exact match or a weakening of constraints.\n    AMK_Override,\n    /// Merge availability attributes for an implementation of\n    /// a protocol requirement.\n    AMK_ProtocolImplementation,\n  };\n\n  /// Describes the kind of priority given to an availability attribute.\n  ///\n  /// The sum of priorities deteremines the final priority of the attribute.\n  /// The final priority determines how the attribute will be merged.\n  /// An attribute with a lower priority will always remove higher priority\n  /// attributes for the specified platform when it is being applied. An\n  /// attribute with a higher priority will not be applied if the declaration\n  /// already has an availability attribute with a lower priority for the\n  /// specified platform. The final prirority values are not expected to match\n  /// the values in this enumeration, but instead should be treated as a plain\n  /// integer value. This enumeration just names the priority weights that are\n  /// used to calculate that final vaue.\n  enum AvailabilityPriority : int {\n    /// The availability attribute was specified explicitly next to the\n    /// declaration.\n    AP_Explicit = 0,\n\n    /// The availability attribute was applied using '#pragma clang attribute'.\n    AP_PragmaClangAttribute = 1,\n\n    /// The availability attribute for a specific platform was inferred from\n    /// an availability attribute for another platform.\n    AP_InferredFromOtherPlatform = 2\n  };\n\n  /// Attribute merging methods. Return true if a new attribute was added.\n  AvailabilityAttr *\n  mergeAvailabilityAttr(NamedDecl *D, const AttributeCommonInfo &CI,\n                        IdentifierInfo *Platform, bool Implicit,\n                        VersionTuple Introduced, VersionTuple Deprecated,\n                        VersionTuple Obsoleted, bool IsUnavailable,\n                        StringRef Message, bool IsStrict, StringRef Replacement,\n                        AvailabilityMergeKind AMK, int Priority);\n  TypeVisibilityAttr *\n  mergeTypeVisibilityAttr(Decl *D, const AttributeCommonInfo &CI,\n                          TypeVisibilityAttr::VisibilityType Vis);\n  VisibilityAttr *mergeVisibilityAttr(Decl *D, const AttributeCommonInfo &CI,\n                                      VisibilityAttr::VisibilityType Vis);\n  UuidAttr *mergeUuidAttr(Decl *D, const AttributeCommonInfo &CI,\n                          StringRef UuidAsWritten, MSGuidDecl *GuidDecl);\n  DLLImportAttr *mergeDLLImportAttr(Decl *D, const AttributeCommonInfo &CI);\n  DLLExportAttr *mergeDLLExportAttr(Decl *D, const AttributeCommonInfo &CI);\n  MSInheritanceAttr *mergeMSInheritanceAttr(Decl *D,\n                                            const AttributeCommonInfo &CI,\n                                            bool BestCase,\n                                            MSInheritanceModel Model);\n  FormatAttr *mergeFormatAttr(Decl *D, const AttributeCommonInfo &CI,\n                              IdentifierInfo *Format, int FormatIdx,\n                              int FirstArg);\n  SectionAttr *mergeSectionAttr(Decl *D, const AttributeCommonInfo &CI,\n                                StringRef Name);\n  CodeSegAttr *mergeCodeSegAttr(Decl *D, const AttributeCommonInfo &CI,\n                                StringRef Name);\n  AlwaysInlineAttr *mergeAlwaysInlineAttr(Decl *D,\n                                          const AttributeCommonInfo &CI,\n                                          const IdentifierInfo *Ident);\n  MinSizeAttr *mergeMinSizeAttr(Decl *D, const AttributeCommonInfo &CI);\n  NoSpeculativeLoadHardeningAttr *\n  mergeNoSpeculativeLoadHardeningAttr(Decl *D,\n                                      const NoSpeculativeLoadHardeningAttr &AL);\n  SpeculativeLoadHardeningAttr *\n  mergeSpeculativeLoadHardeningAttr(Decl *D,\n                                    const SpeculativeLoadHardeningAttr &AL);\n  SwiftNameAttr *mergeSwiftNameAttr(Decl *D, const SwiftNameAttr &SNA,\n                                    StringRef Name);\n  OptimizeNoneAttr *mergeOptimizeNoneAttr(Decl *D,\n                                          const AttributeCommonInfo &CI);\n  InternalLinkageAttr *mergeInternalLinkageAttr(Decl *D, const ParsedAttr &AL);\n  InternalLinkageAttr *mergeInternalLinkageAttr(Decl *D,\n                                                const InternalLinkageAttr &AL);\n  CommonAttr *mergeCommonAttr(Decl *D, const ParsedAttr &AL);\n  CommonAttr *mergeCommonAttr(Decl *D, const CommonAttr &AL);\n  WebAssemblyImportNameAttr *mergeImportNameAttr(\n      Decl *D, const WebAssemblyImportNameAttr &AL);\n  WebAssemblyImportModuleAttr *mergeImportModuleAttr(\n      Decl *D, const WebAssemblyImportModuleAttr &AL);\n  EnforceTCBAttr *mergeEnforceTCBAttr(Decl *D, const EnforceTCBAttr &AL);\n  EnforceTCBLeafAttr *mergeEnforceTCBLeafAttr(Decl *D,\n                                              const EnforceTCBLeafAttr &AL);\n\n  void mergeDeclAttributes(NamedDecl *New, Decl *Old,\n                           AvailabilityMergeKind AMK = AMK_Redeclaration);\n  void MergeTypedefNameDecl(Scope *S, TypedefNameDecl *New,\n                            LookupResult &OldDecls);\n  bool MergeFunctionDecl(FunctionDecl *New, NamedDecl *&Old, Scope *S,\n                         bool MergeTypeWithOld);\n  bool MergeCompatibleFunctionDecls(FunctionDecl *New, FunctionDecl *Old,\n                                    Scope *S, bool MergeTypeWithOld);\n  void mergeObjCMethodDecls(ObjCMethodDecl *New, ObjCMethodDecl *Old);\n  void MergeVarDecl(VarDecl *New, LookupResult &Previous);\n  void MergeVarDeclTypes(VarDecl *New, VarDecl *Old, bool MergeTypeWithOld);\n  void MergeVarDeclExceptionSpecs(VarDecl *New, VarDecl *Old);\n  bool checkVarDeclRedefinition(VarDecl *OldDefn, VarDecl *NewDefn);\n  void notePreviousDefinition(const NamedDecl *Old, SourceLocation New);\n  bool MergeCXXFunctionDecl(FunctionDecl *New, FunctionDecl *Old, Scope *S);\n\n  // AssignmentAction - This is used by all the assignment diagnostic functions\n  // to represent what is actually causing the operation\n  enum AssignmentAction {\n    AA_Assigning,\n    AA_Passing,\n    AA_Returning,\n    AA_Converting,\n    AA_Initializing,\n    AA_Sending,\n    AA_Casting,\n    AA_Passing_CFAudited\n  };\n\n  /// C++ Overloading.\n  enum OverloadKind {\n    /// This is a legitimate overload: the existing declarations are\n    /// functions or function templates with different signatures.\n    Ovl_Overload,\n\n    /// This is not an overload because the signature exactly matches\n    /// an existing declaration.\n    Ovl_Match,\n\n    /// This is not an overload because the lookup results contain a\n    /// non-function.\n    Ovl_NonFunction\n  };\n  OverloadKind CheckOverload(Scope *S,\n                             FunctionDecl *New,\n                             const LookupResult &OldDecls,\n                             NamedDecl *&OldDecl,\n                             bool IsForUsingDecl);\n  bool IsOverload(FunctionDecl *New, FunctionDecl *Old, bool IsForUsingDecl,\n                  bool ConsiderCudaAttrs = true,\n                  bool ConsiderRequiresClauses = true);\n\n  enum class AllowedExplicit {\n    /// Allow no explicit functions to be used.\n    None,\n    /// Allow explicit conversion functions but not explicit constructors.\n    Conversions,\n    /// Allow both explicit conversion functions and explicit constructors.\n    All\n  };\n\n  ImplicitConversionSequence\n  TryImplicitConversion(Expr *From, QualType ToType,\n                        bool SuppressUserConversions,\n                        AllowedExplicit AllowExplicit,\n                        bool InOverloadResolution,\n                        bool CStyle,\n                        bool AllowObjCWritebackConversion);\n\n  bool IsIntegralPromotion(Expr *From, QualType FromType, QualType ToType);\n  bool IsFloatingPointPromotion(QualType FromType, QualType ToType);\n  bool IsComplexPromotion(QualType FromType, QualType ToType);\n  bool IsPointerConversion(Expr *From, QualType FromType, QualType ToType,\n                           bool InOverloadResolution,\n                           QualType& ConvertedType, bool &IncompatibleObjC);\n  bool isObjCPointerConversion(QualType FromType, QualType ToType,\n                               QualType& ConvertedType, bool &IncompatibleObjC);\n  bool isObjCWritebackConversion(QualType FromType, QualType ToType,\n                                 QualType &ConvertedType);\n  bool IsBlockPointerConversion(QualType FromType, QualType ToType,\n                                QualType& ConvertedType);\n  bool FunctionParamTypesAreEqual(const FunctionProtoType *OldType,\n                                  const FunctionProtoType *NewType,\n                                  unsigned *ArgPos = nullptr);\n  void HandleFunctionTypeMismatch(PartialDiagnostic &PDiag,\n                                  QualType FromType, QualType ToType);\n\n  void maybeExtendBlockObject(ExprResult &E);\n  CastKind PrepareCastToObjCObjectPointer(ExprResult &E);\n  bool CheckPointerConversion(Expr *From, QualType ToType,\n                              CastKind &Kind,\n                              CXXCastPath& BasePath,\n                              bool IgnoreBaseAccess,\n                              bool Diagnose = true);\n  bool IsMemberPointerConversion(Expr *From, QualType FromType, QualType ToType,\n                                 bool InOverloadResolution,\n                                 QualType &ConvertedType);\n  bool CheckMemberPointerConversion(Expr *From, QualType ToType,\n                                    CastKind &Kind,\n                                    CXXCastPath &BasePath,\n                                    bool IgnoreBaseAccess);\n  bool IsQualificationConversion(QualType FromType, QualType ToType,\n                                 bool CStyle, bool &ObjCLifetimeConversion);\n  bool IsFunctionConversion(QualType FromType, QualType ToType,\n                            QualType &ResultTy);\n  bool DiagnoseMultipleUserDefinedConversion(Expr *From, QualType ToType);\n  bool isSameOrCompatibleFunctionType(CanQualType Param, CanQualType Arg);\n\n  ExprResult PerformMoveOrCopyInitialization(const InitializedEntity &Entity,\n                                             const VarDecl *NRVOCandidate,\n                                             QualType ResultType,\n                                             Expr *Value,\n                                             bool AllowNRVO = true);\n\n  bool CanPerformAggregateInitializationForOverloadResolution(\n      const InitializedEntity &Entity, InitListExpr *From);\n\n  bool IsStringInit(Expr *Init, const ArrayType *AT);\n\n  bool CanPerformCopyInitialization(const InitializedEntity &Entity,\n                                    ExprResult Init);\n  ExprResult PerformCopyInitialization(const InitializedEntity &Entity,\n                                       SourceLocation EqualLoc,\n                                       ExprResult Init,\n                                       bool TopLevelOfInitList = false,\n                                       bool AllowExplicit = false);\n  ExprResult PerformObjectArgumentInitialization(Expr *From,\n                                                 NestedNameSpecifier *Qualifier,\n                                                 NamedDecl *FoundDecl,\n                                                 CXXMethodDecl *Method);\n\n  /// Check that the lifetime of the initializer (and its subobjects) is\n  /// sufficient for initializing the entity, and perform lifetime extension\n  /// (when permitted) if not.\n  void checkInitializerLifetime(const InitializedEntity &Entity, Expr *Init);\n\n  ExprResult PerformContextuallyConvertToBool(Expr *From);\n  ExprResult PerformContextuallyConvertToObjCPointer(Expr *From);\n\n  /// Contexts in which a converted constant expression is required.\n  enum CCEKind {\n    CCEK_CaseValue,   ///< Expression in a case label.\n    CCEK_Enumerator,  ///< Enumerator value with fixed underlying type.\n    CCEK_TemplateArg, ///< Value of a non-type template parameter.\n    CCEK_ArrayBound,  ///< Array bound in array declarator or new-expression.\n    CCEK_ConstexprIf, ///< Condition in a constexpr if statement.\n    CCEK_ExplicitBool ///< Condition in an explicit(bool) specifier.\n  };\n  ExprResult CheckConvertedConstantExpression(Expr *From, QualType T,\n                                              llvm::APSInt &Value, CCEKind CCE);\n  ExprResult CheckConvertedConstantExpression(Expr *From, QualType T,\n                                              APValue &Value, CCEKind CCE,\n                                              NamedDecl *Dest = nullptr);\n\n  /// Abstract base class used to perform a contextual implicit\n  /// conversion from an expression to any type passing a filter.\n  class ContextualImplicitConverter {\n  public:\n    bool Suppress;\n    bool SuppressConversion;\n\n    ContextualImplicitConverter(bool Suppress = false,\n                                bool SuppressConversion = false)\n        : Suppress(Suppress), SuppressConversion(SuppressConversion) {}\n\n    /// Determine whether the specified type is a valid destination type\n    /// for this conversion.\n    virtual bool match(QualType T) = 0;\n\n    /// Emits a diagnostic complaining that the expression does not have\n    /// integral or enumeration type.\n    virtual SemaDiagnosticBuilder\n    diagnoseNoMatch(Sema &S, SourceLocation Loc, QualType T) = 0;\n\n    /// Emits a diagnostic when the expression has incomplete class type.\n    virtual SemaDiagnosticBuilder\n    diagnoseIncomplete(Sema &S, SourceLocation Loc, QualType T) = 0;\n\n    /// Emits a diagnostic when the only matching conversion function\n    /// is explicit.\n    virtual SemaDiagnosticBuilder diagnoseExplicitConv(\n        Sema &S, SourceLocation Loc, QualType T, QualType ConvTy) = 0;\n\n    /// Emits a note for the explicit conversion function.\n    virtual SemaDiagnosticBuilder\n    noteExplicitConv(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) = 0;\n\n    /// Emits a diagnostic when there are multiple possible conversion\n    /// functions.\n    virtual SemaDiagnosticBuilder\n    diagnoseAmbiguous(Sema &S, SourceLocation Loc, QualType T) = 0;\n\n    /// Emits a note for one of the candidate conversions.\n    virtual SemaDiagnosticBuilder\n    noteAmbiguous(Sema &S, CXXConversionDecl *Conv, QualType ConvTy) = 0;\n\n    /// Emits a diagnostic when we picked a conversion function\n    /// (for cases when we are not allowed to pick a conversion function).\n    virtual SemaDiagnosticBuilder diagnoseConversion(\n        Sema &S, SourceLocation Loc, QualType T, QualType ConvTy) = 0;\n\n    virtual ~ContextualImplicitConverter() {}\n  };\n\n  class ICEConvertDiagnoser : public ContextualImplicitConverter {\n    bool AllowScopedEnumerations;\n\n  public:\n    ICEConvertDiagnoser(bool AllowScopedEnumerations,\n                        bool Suppress, bool SuppressConversion)\n        : ContextualImplicitConverter(Suppress, SuppressConversion),\n          AllowScopedEnumerations(AllowScopedEnumerations) {}\n\n    /// Match an integral or (possibly scoped) enumeration type.\n    bool match(QualType T) override;\n\n    SemaDiagnosticBuilder\n    diagnoseNoMatch(Sema &S, SourceLocation Loc, QualType T) override {\n      return diagnoseNotInt(S, Loc, T);\n    }\n\n    /// Emits a diagnostic complaining that the expression does not have\n    /// integral or enumeration type.\n    virtual SemaDiagnosticBuilder\n    diagnoseNotInt(Sema &S, SourceLocation Loc, QualType T) = 0;\n  };\n\n  /// Perform a contextual implicit conversion.\n  ExprResult PerformContextualImplicitConversion(\n      SourceLocation Loc, Expr *FromE, ContextualImplicitConverter &Converter);\n\n\n  enum ObjCSubscriptKind {\n    OS_Array,\n    OS_Dictionary,\n    OS_Error\n  };\n  ObjCSubscriptKind CheckSubscriptingKind(Expr *FromE);\n\n  // Note that LK_String is intentionally after the other literals, as\n  // this is used for diagnostics logic.\n  enum ObjCLiteralKind {\n    LK_Array,\n    LK_Dictionary,\n    LK_Numeric,\n    LK_Boxed,\n    LK_String,\n    LK_Block,\n    LK_None\n  };\n  ObjCLiteralKind CheckLiteralKind(Expr *FromE);\n\n  ExprResult PerformObjectMemberConversion(Expr *From,\n                                           NestedNameSpecifier *Qualifier,\n                                           NamedDecl *FoundDecl,\n                                           NamedDecl *Member);\n\n  // Members have to be NamespaceDecl* or TranslationUnitDecl*.\n  // TODO: make this is a typesafe union.\n  typedef llvm::SmallSetVector<DeclContext   *, 16> AssociatedNamespaceSet;\n  typedef llvm::SmallSetVector<CXXRecordDecl *, 16> AssociatedClassSet;\n\n  using ADLCallKind = CallExpr::ADLCallKind;\n\n  void AddOverloadCandidate(FunctionDecl *Function, DeclAccessPair FoundDecl,\n                            ArrayRef<Expr *> Args,\n                            OverloadCandidateSet &CandidateSet,\n                            bool SuppressUserConversions = false,\n                            bool PartialOverloading = false,\n                            bool AllowExplicit = true,\n                            bool AllowExplicitConversion = false,\n                            ADLCallKind IsADLCandidate = ADLCallKind::NotADL,\n                            ConversionSequenceList EarlyConversions = None,\n                            OverloadCandidateParamOrder PO = {});\n  void AddFunctionCandidates(const UnresolvedSetImpl &Functions,\n                      ArrayRef<Expr *> Args,\n                      OverloadCandidateSet &CandidateSet,\n                      TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr,\n                      bool SuppressUserConversions = false,\n                      bool PartialOverloading = false,\n                      bool FirstArgumentIsBase = false);\n  void AddMethodCandidate(DeclAccessPair FoundDecl,\n                          QualType ObjectType,\n                          Expr::Classification ObjectClassification,\n                          ArrayRef<Expr *> Args,\n                          OverloadCandidateSet& CandidateSet,\n                          bool SuppressUserConversion = false,\n                          OverloadCandidateParamOrder PO = {});\n  void AddMethodCandidate(CXXMethodDecl *Method,\n                          DeclAccessPair FoundDecl,\n                          CXXRecordDecl *ActingContext, QualType ObjectType,\n                          Expr::Classification ObjectClassification,\n                          ArrayRef<Expr *> Args,\n                          OverloadCandidateSet& CandidateSet,\n                          bool SuppressUserConversions = false,\n                          bool PartialOverloading = false,\n                          ConversionSequenceList EarlyConversions = None,\n                          OverloadCandidateParamOrder PO = {});\n  void AddMethodTemplateCandidate(FunctionTemplateDecl *MethodTmpl,\n                                  DeclAccessPair FoundDecl,\n                                  CXXRecordDecl *ActingContext,\n                                 TemplateArgumentListInfo *ExplicitTemplateArgs,\n                                  QualType ObjectType,\n                                  Expr::Classification ObjectClassification,\n                                  ArrayRef<Expr *> Args,\n                                  OverloadCandidateSet& CandidateSet,\n                                  bool SuppressUserConversions = false,\n                                  bool PartialOverloading = false,\n                                  OverloadCandidateParamOrder PO = {});\n  void AddTemplateOverloadCandidate(\n      FunctionTemplateDecl *FunctionTemplate, DeclAccessPair FoundDecl,\n      TemplateArgumentListInfo *ExplicitTemplateArgs, ArrayRef<Expr *> Args,\n      OverloadCandidateSet &CandidateSet, bool SuppressUserConversions = false,\n      bool PartialOverloading = false, bool AllowExplicit = true,\n      ADLCallKind IsADLCandidate = ADLCallKind::NotADL,\n      OverloadCandidateParamOrder PO = {});\n  bool CheckNonDependentConversions(\n      FunctionTemplateDecl *FunctionTemplate, ArrayRef<QualType> ParamTypes,\n      ArrayRef<Expr *> Args, OverloadCandidateSet &CandidateSet,\n      ConversionSequenceList &Conversions, bool SuppressUserConversions,\n      CXXRecordDecl *ActingContext = nullptr, QualType ObjectType = QualType(),\n      Expr::Classification ObjectClassification = {},\n      OverloadCandidateParamOrder PO = {});\n  void AddConversionCandidate(\n      CXXConversionDecl *Conversion, DeclAccessPair FoundDecl,\n      CXXRecordDecl *ActingContext, Expr *From, QualType ToType,\n      OverloadCandidateSet &CandidateSet, bool AllowObjCConversionOnExplicit,\n      bool AllowExplicit, bool AllowResultConversion = true);\n  void AddTemplateConversionCandidate(\n      FunctionTemplateDecl *FunctionTemplate, DeclAccessPair FoundDecl,\n      CXXRecordDecl *ActingContext, Expr *From, QualType ToType,\n      OverloadCandidateSet &CandidateSet, bool AllowObjCConversionOnExplicit,\n      bool AllowExplicit, bool AllowResultConversion = true);\n  void AddSurrogateCandidate(CXXConversionDecl *Conversion,\n                             DeclAccessPair FoundDecl,\n                             CXXRecordDecl *ActingContext,\n                             const FunctionProtoType *Proto,\n                             Expr *Object, ArrayRef<Expr *> Args,\n                             OverloadCandidateSet& CandidateSet);\n  void AddNonMemberOperatorCandidates(\n      const UnresolvedSetImpl &Functions, ArrayRef<Expr *> Args,\n      OverloadCandidateSet &CandidateSet,\n      TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr);\n  void AddMemberOperatorCandidates(OverloadedOperatorKind Op,\n                                   SourceLocation OpLoc, ArrayRef<Expr *> Args,\n                                   OverloadCandidateSet &CandidateSet,\n                                   OverloadCandidateParamOrder PO = {});\n  void AddBuiltinCandidate(QualType *ParamTys, ArrayRef<Expr *> Args,\n                           OverloadCandidateSet& CandidateSet,\n                           bool IsAssignmentOperator = false,\n                           unsigned NumContextualBoolArguments = 0);\n  void AddBuiltinOperatorCandidates(OverloadedOperatorKind Op,\n                                    SourceLocation OpLoc, ArrayRef<Expr *> Args,\n                                    OverloadCandidateSet& CandidateSet);\n  void AddArgumentDependentLookupCandidates(DeclarationName Name,\n                                            SourceLocation Loc,\n                                            ArrayRef<Expr *> Args,\n                                TemplateArgumentListInfo *ExplicitTemplateArgs,\n                                            OverloadCandidateSet& CandidateSet,\n                                            bool PartialOverloading = false);\n\n  // Emit as a 'note' the specific overload candidate\n  void NoteOverloadCandidate(\n      NamedDecl *Found, FunctionDecl *Fn,\n      OverloadCandidateRewriteKind RewriteKind = OverloadCandidateRewriteKind(),\n      QualType DestType = QualType(), bool TakingAddress = false);\n\n  // Emit as a series of 'note's all template and non-templates identified by\n  // the expression Expr\n  void NoteAllOverloadCandidates(Expr *E, QualType DestType = QualType(),\n                                 bool TakingAddress = false);\n\n  /// Check the enable_if expressions on the given function. Returns the first\n  /// failing attribute, or NULL if they were all successful.\n  EnableIfAttr *CheckEnableIf(FunctionDecl *Function, SourceLocation CallLoc,\n                              ArrayRef<Expr *> Args,\n                              bool MissingImplicitThis = false);\n\n  /// Find the failed Boolean condition within a given Boolean\n  /// constant expression, and describe it with a string.\n  std::pair<Expr *, std::string> findFailedBooleanCondition(Expr *Cond);\n\n  /// Emit diagnostics for the diagnose_if attributes on Function, ignoring any\n  /// non-ArgDependent DiagnoseIfAttrs.\n  ///\n  /// Argument-dependent diagnose_if attributes should be checked each time a\n  /// function is used as a direct callee of a function call.\n  ///\n  /// Returns true if any errors were emitted.\n  bool diagnoseArgDependentDiagnoseIfAttrs(const FunctionDecl *Function,\n                                           const Expr *ThisArg,\n                                           ArrayRef<const Expr *> Args,\n                                           SourceLocation Loc);\n\n  /// Emit diagnostics for the diagnose_if attributes on Function, ignoring any\n  /// ArgDependent DiagnoseIfAttrs.\n  ///\n  /// Argument-independent diagnose_if attributes should be checked on every use\n  /// of a function.\n  ///\n  /// Returns true if any errors were emitted.\n  bool diagnoseArgIndependentDiagnoseIfAttrs(const NamedDecl *ND,\n                                             SourceLocation Loc);\n\n  /// Returns whether the given function's address can be taken or not,\n  /// optionally emitting a diagnostic if the address can't be taken.\n  ///\n  /// Returns false if taking the address of the function is illegal.\n  bool checkAddressOfFunctionIsAvailable(const FunctionDecl *Function,\n                                         bool Complain = false,\n                                         SourceLocation Loc = SourceLocation());\n\n  // [PossiblyAFunctionType]  -->   [Return]\n  // NonFunctionType --> NonFunctionType\n  // R (A) --> R(A)\n  // R (*)(A) --> R (A)\n  // R (&)(A) --> R (A)\n  // R (S::*)(A) --> R (A)\n  QualType ExtractUnqualifiedFunctionType(QualType PossiblyAFunctionType);\n\n  FunctionDecl *\n  ResolveAddressOfOverloadedFunction(Expr *AddressOfExpr,\n                                     QualType TargetType,\n                                     bool Complain,\n                                     DeclAccessPair &Found,\n                                     bool *pHadMultipleCandidates = nullptr);\n\n  FunctionDecl *\n  resolveAddressOfSingleOverloadCandidate(Expr *E, DeclAccessPair &FoundResult);\n\n  bool resolveAndFixAddressOfSingleOverloadCandidate(\n      ExprResult &SrcExpr, bool DoFunctionPointerConversion = false);\n\n  FunctionDecl *\n  ResolveSingleFunctionTemplateSpecialization(OverloadExpr *ovl,\n                                              bool Complain = false,\n                                              DeclAccessPair *Found = nullptr);\n\n  bool ResolveAndFixSingleFunctionTemplateSpecialization(\n                      ExprResult &SrcExpr,\n                      bool DoFunctionPointerConverion = false,\n                      bool Complain = false,\n                      SourceRange OpRangeForComplaining = SourceRange(),\n                      QualType DestTypeForComplaining = QualType(),\n                      unsigned DiagIDForComplaining = 0);\n\n\n  Expr *FixOverloadedFunctionReference(Expr *E,\n                                       DeclAccessPair FoundDecl,\n                                       FunctionDecl *Fn);\n  ExprResult FixOverloadedFunctionReference(ExprResult,\n                                            DeclAccessPair FoundDecl,\n                                            FunctionDecl *Fn);\n\n  void AddOverloadedCallCandidates(UnresolvedLookupExpr *ULE,\n                                   ArrayRef<Expr *> Args,\n                                   OverloadCandidateSet &CandidateSet,\n                                   bool PartialOverloading = false);\n  void AddOverloadedCallCandidates(\n      LookupResult &R, TemplateArgumentListInfo *ExplicitTemplateArgs,\n      ArrayRef<Expr *> Args, OverloadCandidateSet &CandidateSet);\n\n  // An enum used to represent the different possible results of building a\n  // range-based for loop.\n  enum ForRangeStatus {\n    FRS_Success,\n    FRS_NoViableFunction,\n    FRS_DiagnosticIssued\n  };\n\n  ForRangeStatus BuildForRangeBeginEndCall(SourceLocation Loc,\n                                           SourceLocation RangeLoc,\n                                           const DeclarationNameInfo &NameInfo,\n                                           LookupResult &MemberLookup,\n                                           OverloadCandidateSet *CandidateSet,\n                                           Expr *Range, ExprResult *CallExpr);\n\n  ExprResult BuildOverloadedCallExpr(Scope *S, Expr *Fn,\n                                     UnresolvedLookupExpr *ULE,\n                                     SourceLocation LParenLoc,\n                                     MultiExprArg Args,\n                                     SourceLocation RParenLoc,\n                                     Expr *ExecConfig,\n                                     bool AllowTypoCorrection=true,\n                                     bool CalleesAddressIsTaken=false);\n\n  bool buildOverloadedCallSet(Scope *S, Expr *Fn, UnresolvedLookupExpr *ULE,\n                              MultiExprArg Args, SourceLocation RParenLoc,\n                              OverloadCandidateSet *CandidateSet,\n                              ExprResult *Result);\n\n  ExprResult CreateUnresolvedLookupExpr(CXXRecordDecl *NamingClass,\n                                        NestedNameSpecifierLoc NNSLoc,\n                                        DeclarationNameInfo DNI,\n                                        const UnresolvedSetImpl &Fns,\n                                        bool PerformADL = true);\n\n  ExprResult CreateOverloadedUnaryOp(SourceLocation OpLoc,\n                                     UnaryOperatorKind Opc,\n                                     const UnresolvedSetImpl &Fns,\n                                     Expr *input, bool RequiresADL = true);\n\n  void LookupOverloadedBinOp(OverloadCandidateSet &CandidateSet,\n                             OverloadedOperatorKind Op,\n                             const UnresolvedSetImpl &Fns,\n                             ArrayRef<Expr *> Args, bool RequiresADL = true);\n  ExprResult CreateOverloadedBinOp(SourceLocation OpLoc,\n                                   BinaryOperatorKind Opc,\n                                   const UnresolvedSetImpl &Fns,\n                                   Expr *LHS, Expr *RHS,\n                                   bool RequiresADL = true,\n                                   bool AllowRewrittenCandidates = true,\n                                   FunctionDecl *DefaultedFn = nullptr);\n  ExprResult BuildSynthesizedThreeWayComparison(SourceLocation OpLoc,\n                                                const UnresolvedSetImpl &Fns,\n                                                Expr *LHS, Expr *RHS,\n                                                FunctionDecl *DefaultedFn);\n\n  ExprResult CreateOverloadedArraySubscriptExpr(SourceLocation LLoc,\n                                                SourceLocation RLoc,\n                                                Expr *Base,Expr *Idx);\n\n  ExprResult BuildCallToMemberFunction(Scope *S, Expr *MemExpr,\n                                       SourceLocation LParenLoc,\n                                       MultiExprArg Args,\n                                       SourceLocation RParenLoc,\n                                       bool AllowRecovery = false);\n  ExprResult\n  BuildCallToObjectOfClassType(Scope *S, Expr *Object, SourceLocation LParenLoc,\n                               MultiExprArg Args,\n                               SourceLocation RParenLoc);\n\n  ExprResult BuildOverloadedArrowExpr(Scope *S, Expr *Base,\n                                      SourceLocation OpLoc,\n                                      bool *NoArrowOperatorFound = nullptr);\n\n  /// CheckCallReturnType - Checks that a call expression's return type is\n  /// complete. Returns true on failure. The location passed in is the location\n  /// that best represents the call.\n  bool CheckCallReturnType(QualType ReturnType, SourceLocation Loc,\n                           CallExpr *CE, FunctionDecl *FD);\n\n  /// Helpers for dealing with blocks and functions.\n  bool CheckParmsForFunctionDef(ArrayRef<ParmVarDecl *> Parameters,\n                                bool CheckParameterNames);\n  void CheckCXXDefaultArguments(FunctionDecl *FD);\n  void CheckExtraCXXDefaultArguments(Declarator &D);\n  Scope *getNonFieldDeclScope(Scope *S);\n\n  /// \\name Name lookup\n  ///\n  /// These routines provide name lookup that is used during semantic\n  /// analysis to resolve the various kinds of names (identifiers,\n  /// overloaded operator names, constructor names, etc.) into zero or\n  /// more declarations within a particular scope. The major entry\n  /// points are LookupName, which performs unqualified name lookup,\n  /// and LookupQualifiedName, which performs qualified name lookup.\n  ///\n  /// All name lookup is performed based on some specific criteria,\n  /// which specify what names will be visible to name lookup and how\n  /// far name lookup should work. These criteria are important both\n  /// for capturing language semantics (certain lookups will ignore\n  /// certain names, for example) and for performance, since name\n  /// lookup is often a bottleneck in the compilation of C++. Name\n  /// lookup criteria is specified via the LookupCriteria enumeration.\n  ///\n  /// The results of name lookup can vary based on the kind of name\n  /// lookup performed, the current language, and the translation\n  /// unit. In C, for example, name lookup will either return nothing\n  /// (no entity found) or a single declaration. In C++, name lookup\n  /// can additionally refer to a set of overloaded functions or\n  /// result in an ambiguity. All of the possible results of name\n  /// lookup are captured by the LookupResult class, which provides\n  /// the ability to distinguish among them.\n  //@{\n\n  /// Describes the kind of name lookup to perform.\n  enum LookupNameKind {\n    /// Ordinary name lookup, which finds ordinary names (functions,\n    /// variables, typedefs, etc.) in C and most kinds of names\n    /// (functions, variables, members, types, etc.) in C++.\n    LookupOrdinaryName = 0,\n    /// Tag name lookup, which finds the names of enums, classes,\n    /// structs, and unions.\n    LookupTagName,\n    /// Label name lookup.\n    LookupLabel,\n    /// Member name lookup, which finds the names of\n    /// class/struct/union members.\n    LookupMemberName,\n    /// Look up of an operator name (e.g., operator+) for use with\n    /// operator overloading. This lookup is similar to ordinary name\n    /// lookup, but will ignore any declarations that are class members.\n    LookupOperatorName,\n    /// Look up a name following ~ in a destructor name. This is an ordinary\n    /// lookup, but prefers tags to typedefs.\n    LookupDestructorName,\n    /// Look up of a name that precedes the '::' scope resolution\n    /// operator in C++. This lookup completely ignores operator, object,\n    /// function, and enumerator names (C++ [basic.lookup.qual]p1).\n    LookupNestedNameSpecifierName,\n    /// Look up a namespace name within a C++ using directive or\n    /// namespace alias definition, ignoring non-namespace names (C++\n    /// [basic.lookup.udir]p1).\n    LookupNamespaceName,\n    /// Look up all declarations in a scope with the given name,\n    /// including resolved using declarations.  This is appropriate\n    /// for checking redeclarations for a using declaration.\n    LookupUsingDeclName,\n    /// Look up an ordinary name that is going to be redeclared as a\n    /// name with linkage. This lookup ignores any declarations that\n    /// are outside of the current scope unless they have linkage. See\n    /// C99 6.2.2p4-5 and C++ [basic.link]p6.\n    LookupRedeclarationWithLinkage,\n    /// Look up a friend of a local class. This lookup does not look\n    /// outside the innermost non-class scope. See C++11 [class.friend]p11.\n    LookupLocalFriendName,\n    /// Look up the name of an Objective-C protocol.\n    LookupObjCProtocolName,\n    /// Look up implicit 'self' parameter of an objective-c method.\n    LookupObjCImplicitSelfParam,\n    /// Look up the name of an OpenMP user-defined reduction operation.\n    LookupOMPReductionName,\n    /// Look up the name of an OpenMP user-defined mapper.\n    LookupOMPMapperName,\n    /// Look up any declaration with any name.\n    LookupAnyName\n  };\n\n  /// Specifies whether (or how) name lookup is being performed for a\n  /// redeclaration (vs. a reference).\n  enum RedeclarationKind {\n    /// The lookup is a reference to this name that is not for the\n    /// purpose of redeclaring the name.\n    NotForRedeclaration = 0,\n    /// The lookup results will be used for redeclaration of a name,\n    /// if an entity by that name already exists and is visible.\n    ForVisibleRedeclaration,\n    /// The lookup results will be used for redeclaration of a name\n    /// with external linkage; non-visible lookup results with external linkage\n    /// may also be found.\n    ForExternalRedeclaration\n  };\n\n  RedeclarationKind forRedeclarationInCurContext() {\n    // A declaration with an owning module for linkage can never link against\n    // anything that is not visible. We don't need to check linkage here; if\n    // the context has internal linkage, redeclaration lookup won't find things\n    // from other TUs, and we can't safely compute linkage yet in general.\n    if (cast<Decl>(CurContext)\n            ->getOwningModuleForLinkage(/*IgnoreLinkage*/true))\n      return ForVisibleRedeclaration;\n    return ForExternalRedeclaration;\n  }\n\n  /// The possible outcomes of name lookup for a literal operator.\n  enum LiteralOperatorLookupResult {\n    /// The lookup resulted in an error.\n    LOLR_Error,\n    /// The lookup found no match but no diagnostic was issued.\n    LOLR_ErrorNoDiagnostic,\n    /// The lookup found a single 'cooked' literal operator, which\n    /// expects a normal literal to be built and passed to it.\n    LOLR_Cooked,\n    /// The lookup found a single 'raw' literal operator, which expects\n    /// a string literal containing the spelling of the literal token.\n    LOLR_Raw,\n    /// The lookup found an overload set of literal operator templates,\n    /// which expect the characters of the spelling of the literal token to be\n    /// passed as a non-type template argument pack.\n    LOLR_Template,\n    /// The lookup found an overload set of literal operator templates,\n    /// which expect the character type and characters of the spelling of the\n    /// string literal token to be passed as template arguments.\n    LOLR_StringTemplatePack,\n  };\n\n  SpecialMemberOverloadResult LookupSpecialMember(CXXRecordDecl *D,\n                                                  CXXSpecialMember SM,\n                                                  bool ConstArg,\n                                                  bool VolatileArg,\n                                                  bool RValueThis,\n                                                  bool ConstThis,\n                                                  bool VolatileThis);\n\n  typedef std::function<void(const TypoCorrection &)> TypoDiagnosticGenerator;\n  typedef std::function<ExprResult(Sema &, TypoExpr *, TypoCorrection)>\n      TypoRecoveryCallback;\n\nprivate:\n  bool CppLookupName(LookupResult &R, Scope *S);\n\n  struct TypoExprState {\n    std::unique_ptr<TypoCorrectionConsumer> Consumer;\n    TypoDiagnosticGenerator DiagHandler;\n    TypoRecoveryCallback RecoveryHandler;\n    TypoExprState();\n    TypoExprState(TypoExprState &&other) noexcept;\n    TypoExprState &operator=(TypoExprState &&other) noexcept;\n  };\n\n  /// The set of unhandled TypoExprs and their associated state.\n  llvm::MapVector<TypoExpr *, TypoExprState> DelayedTypos;\n\n  /// Creates a new TypoExpr AST node.\n  TypoExpr *createDelayedTypo(std::unique_ptr<TypoCorrectionConsumer> TCC,\n                              TypoDiagnosticGenerator TDG,\n                              TypoRecoveryCallback TRC, SourceLocation TypoLoc);\n\n  // The set of known/encountered (unique, canonicalized) NamespaceDecls.\n  //\n  // The boolean value will be true to indicate that the namespace was loaded\n  // from an AST/PCH file, or false otherwise.\n  llvm::MapVector<NamespaceDecl*, bool> KnownNamespaces;\n\n  /// Whether we have already loaded known namespaces from an extenal\n  /// source.\n  bool LoadedExternalKnownNamespaces;\n\n  /// Helper for CorrectTypo and CorrectTypoDelayed used to create and\n  /// populate a new TypoCorrectionConsumer. Returns nullptr if typo correction\n  /// should be skipped entirely.\n  std::unique_ptr<TypoCorrectionConsumer>\n  makeTypoCorrectionConsumer(const DeclarationNameInfo &Typo,\n                             Sema::LookupNameKind LookupKind, Scope *S,\n                             CXXScopeSpec *SS,\n                             CorrectionCandidateCallback &CCC,\n                             DeclContext *MemberContext, bool EnteringContext,\n                             const ObjCObjectPointerType *OPT,\n                             bool ErrorRecovery);\n\npublic:\n  const TypoExprState &getTypoExprState(TypoExpr *TE) const;\n\n  /// Clears the state of the given TypoExpr.\n  void clearDelayedTypo(TypoExpr *TE);\n\n  /// Look up a name, looking for a single declaration.  Return\n  /// null if the results were absent, ambiguous, or overloaded.\n  ///\n  /// It is preferable to use the elaborated form and explicitly handle\n  /// ambiguity and overloaded.\n  NamedDecl *LookupSingleName(Scope *S, DeclarationName Name,\n                              SourceLocation Loc,\n                              LookupNameKind NameKind,\n                              RedeclarationKind Redecl\n                                = NotForRedeclaration);\n  bool LookupBuiltin(LookupResult &R);\n  void LookupNecessaryTypesForBuiltin(Scope *S, unsigned ID);\n  bool LookupName(LookupResult &R, Scope *S,\n                  bool AllowBuiltinCreation = false);\n  bool LookupQualifiedName(LookupResult &R, DeclContext *LookupCtx,\n                           bool InUnqualifiedLookup = false);\n  bool LookupQualifiedName(LookupResult &R, DeclContext *LookupCtx,\n                           CXXScopeSpec &SS);\n  bool LookupParsedName(LookupResult &R, Scope *S, CXXScopeSpec *SS,\n                        bool AllowBuiltinCreation = false,\n                        bool EnteringContext = false);\n  ObjCProtocolDecl *LookupProtocol(IdentifierInfo *II, SourceLocation IdLoc,\n                                   RedeclarationKind Redecl\n                                     = NotForRedeclaration);\n  bool LookupInSuper(LookupResult &R, CXXRecordDecl *Class);\n\n  void LookupOverloadedOperatorName(OverloadedOperatorKind Op, Scope *S,\n                                    UnresolvedSetImpl &Functions);\n\n  LabelDecl *LookupOrCreateLabel(IdentifierInfo *II, SourceLocation IdentLoc,\n                                 SourceLocation GnuLabelLoc = SourceLocation());\n\n  DeclContextLookupResult LookupConstructors(CXXRecordDecl *Class);\n  CXXConstructorDecl *LookupDefaultConstructor(CXXRecordDecl *Class);\n  CXXConstructorDecl *LookupCopyingConstructor(CXXRecordDecl *Class,\n                                               unsigned Quals);\n  CXXMethodDecl *LookupCopyingAssignment(CXXRecordDecl *Class, unsigned Quals,\n                                         bool RValueThis, unsigned ThisQuals);\n  CXXConstructorDecl *LookupMovingConstructor(CXXRecordDecl *Class,\n                                              unsigned Quals);\n  CXXMethodDecl *LookupMovingAssignment(CXXRecordDecl *Class, unsigned Quals,\n                                        bool RValueThis, unsigned ThisQuals);\n  CXXDestructorDecl *LookupDestructor(CXXRecordDecl *Class);\n\n  bool checkLiteralOperatorId(const CXXScopeSpec &SS, const UnqualifiedId &Id);\n  LiteralOperatorLookupResult\n  LookupLiteralOperator(Scope *S, LookupResult &R, ArrayRef<QualType> ArgTys,\n                        bool AllowRaw, bool AllowTemplate,\n                        bool AllowStringTemplate, bool DiagnoseMissing,\n                        StringLiteral *StringLit = nullptr);\n  bool isKnownName(StringRef name);\n\n  /// Status of the function emission on the CUDA/HIP/OpenMP host/device attrs.\n  enum class FunctionEmissionStatus {\n    Emitted,\n    CUDADiscarded,     // Discarded due to CUDA/HIP hostness\n    OMPDiscarded,      // Discarded due to OpenMP hostness\n    TemplateDiscarded, // Discarded due to uninstantiated templates\n    Unknown,\n  };\n  FunctionEmissionStatus getEmissionStatus(FunctionDecl *Decl,\n                                           bool Final = false);\n\n  // Whether the callee should be ignored in CUDA/HIP/OpenMP host/device check.\n  bool shouldIgnoreInHostDeviceCheck(FunctionDecl *Callee);\n\n  void ArgumentDependentLookup(DeclarationName Name, SourceLocation Loc,\n                               ArrayRef<Expr *> Args, ADLResult &Functions);\n\n  void LookupVisibleDecls(Scope *S, LookupNameKind Kind,\n                          VisibleDeclConsumer &Consumer,\n                          bool IncludeGlobalScope = true,\n                          bool LoadExternal = true);\n  void LookupVisibleDecls(DeclContext *Ctx, LookupNameKind Kind,\n                          VisibleDeclConsumer &Consumer,\n                          bool IncludeGlobalScope = true,\n                          bool IncludeDependentBases = false,\n                          bool LoadExternal = true);\n\n  enum CorrectTypoKind {\n    CTK_NonError,     // CorrectTypo used in a non error recovery situation.\n    CTK_ErrorRecovery // CorrectTypo used in normal error recovery.\n  };\n\n  TypoCorrection CorrectTypo(const DeclarationNameInfo &Typo,\n                             Sema::LookupNameKind LookupKind,\n                             Scope *S, CXXScopeSpec *SS,\n                             CorrectionCandidateCallback &CCC,\n                             CorrectTypoKind Mode,\n                             DeclContext *MemberContext = nullptr,\n                             bool EnteringContext = false,\n                             const ObjCObjectPointerType *OPT = nullptr,\n                             bool RecordFailure = true);\n\n  TypoExpr *CorrectTypoDelayed(const DeclarationNameInfo &Typo,\n                               Sema::LookupNameKind LookupKind, Scope *S,\n                               CXXScopeSpec *SS,\n                               CorrectionCandidateCallback &CCC,\n                               TypoDiagnosticGenerator TDG,\n                               TypoRecoveryCallback TRC, CorrectTypoKind Mode,\n                               DeclContext *MemberContext = nullptr,\n                               bool EnteringContext = false,\n                               const ObjCObjectPointerType *OPT = nullptr);\n\n  /// Process any TypoExprs in the given Expr and its children,\n  /// generating diagnostics as appropriate and returning a new Expr if there\n  /// were typos that were all successfully corrected and ExprError if one or\n  /// more typos could not be corrected.\n  ///\n  /// \\param E The Expr to check for TypoExprs.\n  ///\n  /// \\param InitDecl A VarDecl to avoid because the Expr being corrected is its\n  /// initializer.\n  ///\n  /// \\param RecoverUncorrectedTypos If true, when typo correction fails, it\n  /// will rebuild the given Expr with all TypoExprs degraded to RecoveryExprs.\n  ///\n  /// \\param Filter A function applied to a newly rebuilt Expr to determine if\n  /// it is an acceptable/usable result from a single combination of typo\n  /// corrections. As long as the filter returns ExprError, different\n  /// combinations of corrections will be tried until all are exhausted.\n  ExprResult CorrectDelayedTyposInExpr(\n      Expr *E, VarDecl *InitDecl = nullptr,\n      bool RecoverUncorrectedTypos = false,\n      llvm::function_ref<ExprResult(Expr *)> Filter =\n          [](Expr *E) -> ExprResult { return E; });\n\n  ExprResult CorrectDelayedTyposInExpr(\n      ExprResult ER, VarDecl *InitDecl = nullptr,\n      bool RecoverUncorrectedTypos = false,\n      llvm::function_ref<ExprResult(Expr *)> Filter =\n          [](Expr *E) -> ExprResult { return E; }) {\n    return ER.isInvalid()\n               ? ER\n               : CorrectDelayedTyposInExpr(ER.get(), InitDecl,\n                                           RecoverUncorrectedTypos, Filter);\n  }\n\n  void diagnoseTypo(const TypoCorrection &Correction,\n                    const PartialDiagnostic &TypoDiag,\n                    bool ErrorRecovery = true);\n\n  void diagnoseTypo(const TypoCorrection &Correction,\n                    const PartialDiagnostic &TypoDiag,\n                    const PartialDiagnostic &PrevNote,\n                    bool ErrorRecovery = true);\n\n  void MarkTypoCorrectedFunctionDefinition(const NamedDecl *F);\n\n  void FindAssociatedClassesAndNamespaces(SourceLocation InstantiationLoc,\n                                          ArrayRef<Expr *> Args,\n                                   AssociatedNamespaceSet &AssociatedNamespaces,\n                                   AssociatedClassSet &AssociatedClasses);\n\n  void FilterLookupForScope(LookupResult &R, DeclContext *Ctx, Scope *S,\n                            bool ConsiderLinkage, bool AllowInlineNamespace);\n\n  bool CheckRedeclarationModuleOwnership(NamedDecl *New, NamedDecl *Old);\n\n  void DiagnoseAmbiguousLookup(LookupResult &Result);\n  //@}\n\n  /// Attempts to produce a RecoveryExpr after some AST node cannot be created.\n  ExprResult CreateRecoveryExpr(SourceLocation Begin, SourceLocation End,\n                                ArrayRef<Expr *> SubExprs,\n                                QualType T = QualType());\n\n  ObjCInterfaceDecl *getObjCInterfaceDecl(IdentifierInfo *&Id,\n                                          SourceLocation IdLoc,\n                                          bool TypoCorrection = false);\n  FunctionDecl *CreateBuiltin(IdentifierInfo *II, QualType Type, unsigned ID,\n                              SourceLocation Loc);\n  NamedDecl *LazilyCreateBuiltin(IdentifierInfo *II, unsigned ID,\n                                 Scope *S, bool ForRedeclaration,\n                                 SourceLocation Loc);\n  NamedDecl *ImplicitlyDefineFunction(SourceLocation Loc, IdentifierInfo &II,\n                                      Scope *S);\n  void AddKnownFunctionAttributesForReplaceableGlobalAllocationFunction(\n      FunctionDecl *FD);\n  void AddKnownFunctionAttributes(FunctionDecl *FD);\n\n  // More parsing and symbol table subroutines.\n\n  void ProcessPragmaWeak(Scope *S, Decl *D);\n  // Decl attributes - this routine is the top level dispatcher.\n  void ProcessDeclAttributes(Scope *S, Decl *D, const Declarator &PD);\n  // Helper for delayed processing of attributes.\n  void ProcessDeclAttributeDelayed(Decl *D,\n                                   const ParsedAttributesView &AttrList);\n  void ProcessDeclAttributeList(Scope *S, Decl *D, const ParsedAttributesView &AL,\n                             bool IncludeCXX11Attributes = true);\n  bool ProcessAccessDeclAttributeList(AccessSpecDecl *ASDecl,\n                                   const ParsedAttributesView &AttrList);\n\n  void checkUnusedDeclAttributes(Declarator &D);\n\n  /// Determine if type T is a valid subject for a nonnull and similar\n  /// attributes. By default, we look through references (the behavior used by\n  /// nonnull), but if the second parameter is true, then we treat a reference\n  /// type as valid.\n  bool isValidPointerAttrType(QualType T, bool RefOkay = false);\n\n  bool CheckRegparmAttr(const ParsedAttr &attr, unsigned &value);\n  bool CheckCallingConvAttr(const ParsedAttr &attr, CallingConv &CC,\n                            const FunctionDecl *FD = nullptr);\n  bool CheckAttrTarget(const ParsedAttr &CurrAttr);\n  bool CheckAttrNoArgs(const ParsedAttr &CurrAttr);\n  bool checkStringLiteralArgumentAttr(const ParsedAttr &Attr, unsigned ArgNum,\n                                      StringRef &Str,\n                                      SourceLocation *ArgLocation = nullptr);\n  bool checkSectionName(SourceLocation LiteralLoc, StringRef Str);\n  bool checkTargetAttr(SourceLocation LiteralLoc, StringRef Str);\n  bool checkMSInheritanceAttrOnDefinition(\n      CXXRecordDecl *RD, SourceRange Range, bool BestCase,\n      MSInheritanceModel SemanticSpelling);\n\n  void CheckAlignasUnderalignment(Decl *D);\n\n  /// Adjust the calling convention of a method to be the ABI default if it\n  /// wasn't specified explicitly.  This handles method types formed from\n  /// function type typedefs and typename template arguments.\n  void adjustMemberFunctionCC(QualType &T, bool IsStatic, bool IsCtorOrDtor,\n                              SourceLocation Loc);\n\n  // Check if there is an explicit attribute, but only look through parens.\n  // The intent is to look for an attribute on the current declarator, but not\n  // one that came from a typedef.\n  bool hasExplicitCallingConv(QualType T);\n\n  /// Get the outermost AttributedType node that sets a calling convention.\n  /// Valid types should not have multiple attributes with different CCs.\n  const AttributedType *getCallingConvAttributedType(QualType T) const;\n\n  /// Stmt attributes - this routine is the top level dispatcher.\n  StmtResult ProcessStmtAttributes(Stmt *Stmt,\n                                   const ParsedAttributesView &Attrs,\n                                   SourceRange Range);\n\n  void WarnConflictingTypedMethods(ObjCMethodDecl *Method,\n                                   ObjCMethodDecl *MethodDecl,\n                                   bool IsProtocolMethodDecl);\n\n  void CheckConflictingOverridingMethod(ObjCMethodDecl *Method,\n                                   ObjCMethodDecl *Overridden,\n                                   bool IsProtocolMethodDecl);\n\n  /// WarnExactTypedMethods - This routine issues a warning if method\n  /// implementation declaration matches exactly that of its declaration.\n  void WarnExactTypedMethods(ObjCMethodDecl *Method,\n                             ObjCMethodDecl *MethodDecl,\n                             bool IsProtocolMethodDecl);\n\n  typedef llvm::SmallPtrSet<Selector, 8> SelectorSet;\n\n  /// CheckImplementationIvars - This routine checks if the instance variables\n  /// listed in the implelementation match those listed in the interface.\n  void CheckImplementationIvars(ObjCImplementationDecl *ImpDecl,\n                                ObjCIvarDecl **Fields, unsigned nIvars,\n                                SourceLocation Loc);\n\n  /// ImplMethodsVsClassMethods - This is main routine to warn if any method\n  /// remains unimplemented in the class or category \\@implementation.\n  void ImplMethodsVsClassMethods(Scope *S, ObjCImplDecl* IMPDecl,\n                                 ObjCContainerDecl* IDecl,\n                                 bool IncompleteImpl = false);\n\n  /// DiagnoseUnimplementedProperties - This routine warns on those properties\n  /// which must be implemented by this implementation.\n  void DiagnoseUnimplementedProperties(Scope *S, ObjCImplDecl* IMPDecl,\n                                       ObjCContainerDecl *CDecl,\n                                       bool SynthesizeProperties);\n\n  /// Diagnose any null-resettable synthesized setters.\n  void diagnoseNullResettableSynthesizedSetters(const ObjCImplDecl *impDecl);\n\n  /// DefaultSynthesizeProperties - This routine default synthesizes all\n  /// properties which must be synthesized in the class's \\@implementation.\n  void DefaultSynthesizeProperties(Scope *S, ObjCImplDecl *IMPDecl,\n                                   ObjCInterfaceDecl *IDecl,\n                                   SourceLocation AtEnd);\n  void DefaultSynthesizeProperties(Scope *S, Decl *D, SourceLocation AtEnd);\n\n  /// IvarBacksCurrentMethodAccessor - This routine returns 'true' if 'IV' is\n  /// an ivar synthesized for 'Method' and 'Method' is a property accessor\n  /// declared in class 'IFace'.\n  bool IvarBacksCurrentMethodAccessor(ObjCInterfaceDecl *IFace,\n                                      ObjCMethodDecl *Method, ObjCIvarDecl *IV);\n\n  /// DiagnoseUnusedBackingIvarInAccessor - Issue an 'unused' warning if ivar which\n  /// backs the property is not used in the property's accessor.\n  void DiagnoseUnusedBackingIvarInAccessor(Scope *S,\n                                           const ObjCImplementationDecl *ImplD);\n\n  /// GetIvarBackingPropertyAccessor - If method is a property setter/getter and\n  /// it property has a backing ivar, returns this ivar; otherwise, returns NULL.\n  /// It also returns ivar's property on success.\n  ObjCIvarDecl *GetIvarBackingPropertyAccessor(const ObjCMethodDecl *Method,\n                                               const ObjCPropertyDecl *&PDecl) const;\n\n  /// Called by ActOnProperty to handle \\@property declarations in\n  /// class extensions.\n  ObjCPropertyDecl *HandlePropertyInClassExtension(Scope *S,\n                      SourceLocation AtLoc,\n                      SourceLocation LParenLoc,\n                      FieldDeclarator &FD,\n                      Selector GetterSel,\n                      SourceLocation GetterNameLoc,\n                      Selector SetterSel,\n                      SourceLocation SetterNameLoc,\n                      const bool isReadWrite,\n                      unsigned &Attributes,\n                      const unsigned AttributesAsWritten,\n                      QualType T,\n                      TypeSourceInfo *TSI,\n                      tok::ObjCKeywordKind MethodImplKind);\n\n  /// Called by ActOnProperty and HandlePropertyInClassExtension to\n  /// handle creating the ObjcPropertyDecl for a category or \\@interface.\n  ObjCPropertyDecl *CreatePropertyDecl(Scope *S,\n                                       ObjCContainerDecl *CDecl,\n                                       SourceLocation AtLoc,\n                                       SourceLocation LParenLoc,\n                                       FieldDeclarator &FD,\n                                       Selector GetterSel,\n                                       SourceLocation GetterNameLoc,\n                                       Selector SetterSel,\n                                       SourceLocation SetterNameLoc,\n                                       const bool isReadWrite,\n                                       const unsigned Attributes,\n                                       const unsigned AttributesAsWritten,\n                                       QualType T,\n                                       TypeSourceInfo *TSI,\n                                       tok::ObjCKeywordKind MethodImplKind,\n                                       DeclContext *lexicalDC = nullptr);\n\n  /// AtomicPropertySetterGetterRules - This routine enforces the rule (via\n  /// warning) when atomic property has one but not the other user-declared\n  /// setter or getter.\n  void AtomicPropertySetterGetterRules(ObjCImplDecl* IMPDecl,\n                                       ObjCInterfaceDecl* IDecl);\n\n  void DiagnoseOwningPropertyGetterSynthesis(const ObjCImplementationDecl *D);\n\n  void DiagnoseMissingDesignatedInitOverrides(\n                                          const ObjCImplementationDecl *ImplD,\n                                          const ObjCInterfaceDecl *IFD);\n\n  void DiagnoseDuplicateIvars(ObjCInterfaceDecl *ID, ObjCInterfaceDecl *SID);\n\n  enum MethodMatchStrategy {\n    MMS_loose,\n    MMS_strict\n  };\n\n  /// MatchTwoMethodDeclarations - Checks if two methods' type match and returns\n  /// true, or false, accordingly.\n  bool MatchTwoMethodDeclarations(const ObjCMethodDecl *Method,\n                                  const ObjCMethodDecl *PrevMethod,\n                                  MethodMatchStrategy strategy = MMS_strict);\n\n  /// MatchAllMethodDeclarations - Check methods declaraed in interface or\n  /// or protocol against those declared in their implementations.\n  void MatchAllMethodDeclarations(const SelectorSet &InsMap,\n                                  const SelectorSet &ClsMap,\n                                  SelectorSet &InsMapSeen,\n                                  SelectorSet &ClsMapSeen,\n                                  ObjCImplDecl* IMPDecl,\n                                  ObjCContainerDecl* IDecl,\n                                  bool &IncompleteImpl,\n                                  bool ImmediateClass,\n                                  bool WarnCategoryMethodImpl=false);\n\n  /// CheckCategoryVsClassMethodMatches - Checks that methods implemented in\n  /// category matches with those implemented in its primary class and\n  /// warns each time an exact match is found.\n  void CheckCategoryVsClassMethodMatches(ObjCCategoryImplDecl *CatIMP);\n\n  /// Add the given method to the list of globally-known methods.\n  void addMethodToGlobalList(ObjCMethodList *List, ObjCMethodDecl *Method);\n\n  /// Returns default addr space for method qualifiers.\n  LangAS getDefaultCXXMethodAddrSpace() const;\n\nprivate:\n  /// AddMethodToGlobalPool - Add an instance or factory method to the global\n  /// pool. See descriptoin of AddInstanceMethodToGlobalPool.\n  void AddMethodToGlobalPool(ObjCMethodDecl *Method, bool impl, bool instance);\n\n  /// LookupMethodInGlobalPool - Returns the instance or factory method and\n  /// optionally warns if there are multiple signatures.\n  ObjCMethodDecl *LookupMethodInGlobalPool(Selector Sel, SourceRange R,\n                                           bool receiverIdOrClass,\n                                           bool instance);\n\npublic:\n  /// - Returns instance or factory methods in global method pool for\n  /// given selector. It checks the desired kind first, if none is found, and\n  /// parameter checkTheOther is set, it then checks the other kind. If no such\n  /// method or only one method is found, function returns false; otherwise, it\n  /// returns true.\n  bool\n  CollectMultipleMethodsInGlobalPool(Selector Sel,\n                                     SmallVectorImpl<ObjCMethodDecl*>& Methods,\n                                     bool InstanceFirst, bool CheckTheOther,\n                                     const ObjCObjectType *TypeBound = nullptr);\n\n  bool\n  AreMultipleMethodsInGlobalPool(Selector Sel, ObjCMethodDecl *BestMethod,\n                                 SourceRange R, bool receiverIdOrClass,\n                                 SmallVectorImpl<ObjCMethodDecl*>& Methods);\n\n  void\n  DiagnoseMultipleMethodInGlobalPool(SmallVectorImpl<ObjCMethodDecl*> &Methods,\n                                     Selector Sel, SourceRange R,\n                                     bool receiverIdOrClass);\n\nprivate:\n  /// - Returns a selector which best matches given argument list or\n  /// nullptr if none could be found\n  ObjCMethodDecl *SelectBestMethod(Selector Sel, MultiExprArg Args,\n                                   bool IsInstance,\n                                   SmallVectorImpl<ObjCMethodDecl*>& Methods);\n\n\n  /// Record the typo correction failure and return an empty correction.\n  TypoCorrection FailedCorrection(IdentifierInfo *Typo, SourceLocation TypoLoc,\n                                  bool RecordFailure = true) {\n    if (RecordFailure)\n      TypoCorrectionFailures[Typo].insert(TypoLoc);\n    return TypoCorrection();\n  }\n\npublic:\n  /// AddInstanceMethodToGlobalPool - All instance methods in a translation\n  /// unit are added to a global pool. This allows us to efficiently associate\n  /// a selector with a method declaraation for purposes of typechecking\n  /// messages sent to \"id\" (where the class of the object is unknown).\n  void AddInstanceMethodToGlobalPool(ObjCMethodDecl *Method, bool impl=false) {\n    AddMethodToGlobalPool(Method, impl, /*instance*/true);\n  }\n\n  /// AddFactoryMethodToGlobalPool - Same as above, but for factory methods.\n  void AddFactoryMethodToGlobalPool(ObjCMethodDecl *Method, bool impl=false) {\n    AddMethodToGlobalPool(Method, impl, /*instance*/false);\n  }\n\n  /// AddAnyMethodToGlobalPool - Add any method, instance or factory to global\n  /// pool.\n  void AddAnyMethodToGlobalPool(Decl *D);\n\n  /// LookupInstanceMethodInGlobalPool - Returns the method and warns if\n  /// there are multiple signatures.\n  ObjCMethodDecl *LookupInstanceMethodInGlobalPool(Selector Sel, SourceRange R,\n                                                   bool receiverIdOrClass=false) {\n    return LookupMethodInGlobalPool(Sel, R, receiverIdOrClass,\n                                    /*instance*/true);\n  }\n\n  /// LookupFactoryMethodInGlobalPool - Returns the method and warns if\n  /// there are multiple signatures.\n  ObjCMethodDecl *LookupFactoryMethodInGlobalPool(Selector Sel, SourceRange R,\n                                                  bool receiverIdOrClass=false) {\n    return LookupMethodInGlobalPool(Sel, R, receiverIdOrClass,\n                                    /*instance*/false);\n  }\n\n  const ObjCMethodDecl *SelectorsForTypoCorrection(Selector Sel,\n                              QualType ObjectType=QualType());\n  /// LookupImplementedMethodInGlobalPool - Returns the method which has an\n  /// implementation.\n  ObjCMethodDecl *LookupImplementedMethodInGlobalPool(Selector Sel);\n\n  /// CollectIvarsToConstructOrDestruct - Collect those ivars which require\n  /// initialization.\n  void CollectIvarsToConstructOrDestruct(ObjCInterfaceDecl *OI,\n                                  SmallVectorImpl<ObjCIvarDecl*> &Ivars);\n\n  //===--------------------------------------------------------------------===//\n  // Statement Parsing Callbacks: SemaStmt.cpp.\npublic:\n  class FullExprArg {\n  public:\n    FullExprArg() : E(nullptr) { }\n    FullExprArg(Sema &actions) : E(nullptr) { }\n\n    ExprResult release() {\n      return E;\n    }\n\n    Expr *get() const { return E; }\n\n    Expr *operator->() {\n      return E;\n    }\n\n  private:\n    // FIXME: No need to make the entire Sema class a friend when it's just\n    // Sema::MakeFullExpr that needs access to the constructor below.\n    friend class Sema;\n\n    explicit FullExprArg(Expr *expr) : E(expr) {}\n\n    Expr *E;\n  };\n\n  FullExprArg MakeFullExpr(Expr *Arg) {\n    return MakeFullExpr(Arg, Arg ? Arg->getExprLoc() : SourceLocation());\n  }\n  FullExprArg MakeFullExpr(Expr *Arg, SourceLocation CC) {\n    return FullExprArg(\n        ActOnFinishFullExpr(Arg, CC, /*DiscardedValue*/ false).get());\n  }\n  FullExprArg MakeFullDiscardedValueExpr(Expr *Arg) {\n    ExprResult FE =\n        ActOnFinishFullExpr(Arg, Arg ? Arg->getExprLoc() : SourceLocation(),\n                            /*DiscardedValue*/ true);\n    return FullExprArg(FE.get());\n  }\n\n  StmtResult ActOnExprStmt(ExprResult Arg, bool DiscardedValue = true);\n  StmtResult ActOnExprStmtError();\n\n  StmtResult ActOnNullStmt(SourceLocation SemiLoc,\n                           bool HasLeadingEmptyMacro = false);\n\n  void ActOnStartOfCompoundStmt(bool IsStmtExpr);\n  void ActOnAfterCompoundStatementLeadingPragmas();\n  void ActOnFinishOfCompoundStmt();\n  StmtResult ActOnCompoundStmt(SourceLocation L, SourceLocation R,\n                               ArrayRef<Stmt *> Elts, bool isStmtExpr);\n\n  /// A RAII object to enter scope of a compound statement.\n  class CompoundScopeRAII {\n  public:\n    CompoundScopeRAII(Sema &S, bool IsStmtExpr = false) : S(S) {\n      S.ActOnStartOfCompoundStmt(IsStmtExpr);\n    }\n\n    ~CompoundScopeRAII() {\n      S.ActOnFinishOfCompoundStmt();\n    }\n\n  private:\n    Sema &S;\n  };\n\n  /// An RAII helper that pops function a function scope on exit.\n  struct FunctionScopeRAII {\n    Sema &S;\n    bool Active;\n    FunctionScopeRAII(Sema &S) : S(S), Active(true) {}\n    ~FunctionScopeRAII() {\n      if (Active)\n        S.PopFunctionScopeInfo();\n    }\n    void disable() { Active = false; }\n  };\n\n  StmtResult ActOnDeclStmt(DeclGroupPtrTy Decl,\n                                   SourceLocation StartLoc,\n                                   SourceLocation EndLoc);\n  void ActOnForEachDeclStmt(DeclGroupPtrTy Decl);\n  StmtResult ActOnForEachLValueExpr(Expr *E);\n  ExprResult ActOnCaseExpr(SourceLocation CaseLoc, ExprResult Val);\n  StmtResult ActOnCaseStmt(SourceLocation CaseLoc, ExprResult LHS,\n                           SourceLocation DotDotDotLoc, ExprResult RHS,\n                           SourceLocation ColonLoc);\n  void ActOnCaseStmtBody(Stmt *CaseStmt, Stmt *SubStmt);\n\n  StmtResult ActOnDefaultStmt(SourceLocation DefaultLoc,\n                                      SourceLocation ColonLoc,\n                                      Stmt *SubStmt, Scope *CurScope);\n  StmtResult ActOnLabelStmt(SourceLocation IdentLoc, LabelDecl *TheDecl,\n                            SourceLocation ColonLoc, Stmt *SubStmt);\n\n  StmtResult ActOnAttributedStmt(SourceLocation AttrLoc,\n                                 ArrayRef<const Attr*> Attrs,\n                                 Stmt *SubStmt);\n\n  class ConditionResult;\n  StmtResult ActOnIfStmt(SourceLocation IfLoc, bool IsConstexpr,\n                         SourceLocation LParenLoc, Stmt *InitStmt,\n                         ConditionResult Cond, SourceLocation RParenLoc,\n                         Stmt *ThenVal, SourceLocation ElseLoc, Stmt *ElseVal);\n  StmtResult BuildIfStmt(SourceLocation IfLoc, bool IsConstexpr,\n                         SourceLocation LParenLoc, Stmt *InitStmt,\n                         ConditionResult Cond, SourceLocation RParenLoc,\n                         Stmt *ThenVal, SourceLocation ElseLoc, Stmt *ElseVal);\n  StmtResult ActOnStartOfSwitchStmt(SourceLocation SwitchLoc,\n                                    SourceLocation LParenLoc, Stmt *InitStmt,\n                                    ConditionResult Cond,\n                                    SourceLocation RParenLoc);\n  StmtResult ActOnFinishSwitchStmt(SourceLocation SwitchLoc,\n                                           Stmt *Switch, Stmt *Body);\n  StmtResult ActOnWhileStmt(SourceLocation WhileLoc, SourceLocation LParenLoc,\n                            ConditionResult Cond, SourceLocation RParenLoc,\n                            Stmt *Body);\n  StmtResult ActOnDoStmt(SourceLocation DoLoc, Stmt *Body,\n                         SourceLocation WhileLoc, SourceLocation CondLParen,\n                         Expr *Cond, SourceLocation CondRParen);\n\n  StmtResult ActOnForStmt(SourceLocation ForLoc,\n                          SourceLocation LParenLoc,\n                          Stmt *First,\n                          ConditionResult Second,\n                          FullExprArg Third,\n                          SourceLocation RParenLoc,\n                          Stmt *Body);\n  ExprResult CheckObjCForCollectionOperand(SourceLocation forLoc,\n                                           Expr *collection);\n  StmtResult ActOnObjCForCollectionStmt(SourceLocation ForColLoc,\n                                        Stmt *First, Expr *collection,\n                                        SourceLocation RParenLoc);\n  StmtResult FinishObjCForCollectionStmt(Stmt *ForCollection, Stmt *Body);\n\n  enum BuildForRangeKind {\n    /// Initial building of a for-range statement.\n    BFRK_Build,\n    /// Instantiation or recovery rebuild of a for-range statement. Don't\n    /// attempt any typo-correction.\n    BFRK_Rebuild,\n    /// Determining whether a for-range statement could be built. Avoid any\n    /// unnecessary or irreversible actions.\n    BFRK_Check\n  };\n\n  StmtResult ActOnCXXForRangeStmt(Scope *S, SourceLocation ForLoc,\n                                  SourceLocation CoawaitLoc,\n                                  Stmt *InitStmt,\n                                  Stmt *LoopVar,\n                                  SourceLocation ColonLoc, Expr *Collection,\n                                  SourceLocation RParenLoc,\n                                  BuildForRangeKind Kind);\n  StmtResult BuildCXXForRangeStmt(SourceLocation ForLoc,\n                                  SourceLocation CoawaitLoc,\n                                  Stmt *InitStmt,\n                                  SourceLocation ColonLoc,\n                                  Stmt *RangeDecl, Stmt *Begin, Stmt *End,\n                                  Expr *Cond, Expr *Inc,\n                                  Stmt *LoopVarDecl,\n                                  SourceLocation RParenLoc,\n                                  BuildForRangeKind Kind);\n  StmtResult FinishCXXForRangeStmt(Stmt *ForRange, Stmt *Body);\n\n  StmtResult ActOnGotoStmt(SourceLocation GotoLoc,\n                           SourceLocation LabelLoc,\n                           LabelDecl *TheDecl);\n  StmtResult ActOnIndirectGotoStmt(SourceLocation GotoLoc,\n                                   SourceLocation StarLoc,\n                                   Expr *DestExp);\n  StmtResult ActOnContinueStmt(SourceLocation ContinueLoc, Scope *CurScope);\n  StmtResult ActOnBreakStmt(SourceLocation BreakLoc, Scope *CurScope);\n\n  void ActOnCapturedRegionStart(SourceLocation Loc, Scope *CurScope,\n                                CapturedRegionKind Kind, unsigned NumParams);\n  typedef std::pair<StringRef, QualType> CapturedParamNameType;\n  void ActOnCapturedRegionStart(SourceLocation Loc, Scope *CurScope,\n                                CapturedRegionKind Kind,\n                                ArrayRef<CapturedParamNameType> Params,\n                                unsigned OpenMPCaptureLevel = 0);\n  StmtResult ActOnCapturedRegionEnd(Stmt *S);\n  void ActOnCapturedRegionError();\n  RecordDecl *CreateCapturedStmtRecordDecl(CapturedDecl *&CD,\n                                           SourceLocation Loc,\n                                           unsigned NumParams);\n\n  enum CopyElisionSemanticsKind {\n    CES_Strict = 0,\n    CES_AllowParameters = 1,\n    CES_AllowDifferentTypes = 2,\n    CES_AllowExceptionVariables = 4,\n    CES_AllowRValueReferenceType = 8,\n    CES_ImplicitlyMovableCXX11CXX14CXX17 =\n        (CES_AllowParameters | CES_AllowDifferentTypes),\n    CES_ImplicitlyMovableCXX20 =\n        (CES_AllowParameters | CES_AllowDifferentTypes |\n         CES_AllowExceptionVariables | CES_AllowRValueReferenceType),\n  };\n\n  VarDecl *getCopyElisionCandidate(QualType ReturnType, Expr *E,\n                                   CopyElisionSemanticsKind CESK);\n  bool isCopyElisionCandidate(QualType ReturnType, const VarDecl *VD,\n                              CopyElisionSemanticsKind CESK);\n\n  StmtResult ActOnReturnStmt(SourceLocation ReturnLoc, Expr *RetValExp,\n                             Scope *CurScope);\n  StmtResult BuildReturnStmt(SourceLocation ReturnLoc, Expr *RetValExp);\n  StmtResult ActOnCapScopeReturnStmt(SourceLocation ReturnLoc, Expr *RetValExp);\n\n  StmtResult ActOnGCCAsmStmt(SourceLocation AsmLoc, bool IsSimple,\n                             bool IsVolatile, unsigned NumOutputs,\n                             unsigned NumInputs, IdentifierInfo **Names,\n                             MultiExprArg Constraints, MultiExprArg Exprs,\n                             Expr *AsmString, MultiExprArg Clobbers,\n                             unsigned NumLabels,\n                             SourceLocation RParenLoc);\n\n  void FillInlineAsmIdentifierInfo(Expr *Res,\n                                   llvm::InlineAsmIdentifierInfo &Info);\n  ExprResult LookupInlineAsmIdentifier(CXXScopeSpec &SS,\n                                       SourceLocation TemplateKWLoc,\n                                       UnqualifiedId &Id,\n                                       bool IsUnevaluatedContext);\n  bool LookupInlineAsmField(StringRef Base, StringRef Member,\n                            unsigned &Offset, SourceLocation AsmLoc);\n  ExprResult LookupInlineAsmVarDeclField(Expr *RefExpr, StringRef Member,\n                                         SourceLocation AsmLoc);\n  StmtResult ActOnMSAsmStmt(SourceLocation AsmLoc, SourceLocation LBraceLoc,\n                            ArrayRef<Token> AsmToks,\n                            StringRef AsmString,\n                            unsigned NumOutputs, unsigned NumInputs,\n                            ArrayRef<StringRef> Constraints,\n                            ArrayRef<StringRef> Clobbers,\n                            ArrayRef<Expr*> Exprs,\n                            SourceLocation EndLoc);\n  LabelDecl *GetOrCreateMSAsmLabel(StringRef ExternalLabelName,\n                                   SourceLocation Location,\n                                   bool AlwaysCreate);\n\n  VarDecl *BuildObjCExceptionDecl(TypeSourceInfo *TInfo, QualType ExceptionType,\n                                  SourceLocation StartLoc,\n                                  SourceLocation IdLoc, IdentifierInfo *Id,\n                                  bool Invalid = false);\n\n  Decl *ActOnObjCExceptionDecl(Scope *S, Declarator &D);\n\n  StmtResult ActOnObjCAtCatchStmt(SourceLocation AtLoc, SourceLocation RParen,\n                                  Decl *Parm, Stmt *Body);\n\n  StmtResult ActOnObjCAtFinallyStmt(SourceLocation AtLoc, Stmt *Body);\n\n  StmtResult ActOnObjCAtTryStmt(SourceLocation AtLoc, Stmt *Try,\n                                MultiStmtArg Catch, Stmt *Finally);\n\n  StmtResult BuildObjCAtThrowStmt(SourceLocation AtLoc, Expr *Throw);\n  StmtResult ActOnObjCAtThrowStmt(SourceLocation AtLoc, Expr *Throw,\n                                  Scope *CurScope);\n  ExprResult ActOnObjCAtSynchronizedOperand(SourceLocation atLoc,\n                                            Expr *operand);\n  StmtResult ActOnObjCAtSynchronizedStmt(SourceLocation AtLoc,\n                                         Expr *SynchExpr,\n                                         Stmt *SynchBody);\n\n  StmtResult ActOnObjCAutoreleasePoolStmt(SourceLocation AtLoc, Stmt *Body);\n\n  VarDecl *BuildExceptionDeclaration(Scope *S, TypeSourceInfo *TInfo,\n                                     SourceLocation StartLoc,\n                                     SourceLocation IdLoc,\n                                     IdentifierInfo *Id);\n\n  Decl *ActOnExceptionDeclarator(Scope *S, Declarator &D);\n\n  StmtResult ActOnCXXCatchBlock(SourceLocation CatchLoc,\n                                Decl *ExDecl, Stmt *HandlerBlock);\n  StmtResult ActOnCXXTryBlock(SourceLocation TryLoc, Stmt *TryBlock,\n                              ArrayRef<Stmt *> Handlers);\n\n  StmtResult ActOnSEHTryBlock(bool IsCXXTry, // try (true) or __try (false) ?\n                              SourceLocation TryLoc, Stmt *TryBlock,\n                              Stmt *Handler);\n  StmtResult ActOnSEHExceptBlock(SourceLocation Loc,\n                                 Expr *FilterExpr,\n                                 Stmt *Block);\n  void ActOnStartSEHFinallyBlock();\n  void ActOnAbortSEHFinallyBlock();\n  StmtResult ActOnFinishSEHFinallyBlock(SourceLocation Loc, Stmt *Block);\n  StmtResult ActOnSEHLeaveStmt(SourceLocation Loc, Scope *CurScope);\n\n  void DiagnoseReturnInConstructorExceptionHandler(CXXTryStmt *TryBlock);\n\n  bool ShouldWarnIfUnusedFileScopedDecl(const DeclaratorDecl *D) const;\n\n  /// If it's a file scoped decl that must warn if not used, keep track\n  /// of it.\n  void MarkUnusedFileScopedDecl(const DeclaratorDecl *D);\n\n  /// DiagnoseUnusedExprResult - If the statement passed in is an expression\n  /// whose result is unused, warn.\n  void DiagnoseUnusedExprResult(const Stmt *S);\n  void DiagnoseUnusedNestedTypedefs(const RecordDecl *D);\n  void DiagnoseUnusedDecl(const NamedDecl *ND);\n\n  /// Emit \\p DiagID if statement located on \\p StmtLoc has a suspicious null\n  /// statement as a \\p Body, and it is located on the same line.\n  ///\n  /// This helps prevent bugs due to typos, such as:\n  ///     if (condition);\n  ///       do_stuff();\n  void DiagnoseEmptyStmtBody(SourceLocation StmtLoc,\n                             const Stmt *Body,\n                             unsigned DiagID);\n\n  /// Warn if a for/while loop statement \\p S, which is followed by\n  /// \\p PossibleBody, has a suspicious null statement as a body.\n  void DiagnoseEmptyLoopBody(const Stmt *S,\n                             const Stmt *PossibleBody);\n\n  /// Warn if a value is moved to itself.\n  void DiagnoseSelfMove(const Expr *LHSExpr, const Expr *RHSExpr,\n                        SourceLocation OpLoc);\n\n  /// Warn if we're implicitly casting from a _Nullable pointer type to a\n  /// _Nonnull one.\n  void diagnoseNullableToNonnullConversion(QualType DstType, QualType SrcType,\n                                           SourceLocation Loc);\n\n  /// Warn when implicitly casting 0 to nullptr.\n  void diagnoseZeroToNullptrConversion(CastKind Kind, const Expr *E);\n\n  ParsingDeclState PushParsingDeclaration(sema::DelayedDiagnosticPool &pool) {\n    return DelayedDiagnostics.push(pool);\n  }\n  void PopParsingDeclaration(ParsingDeclState state, Decl *decl);\n\n  typedef ProcessingContextState ParsingClassState;\n  ParsingClassState PushParsingClass() {\n    ParsingClassDepth++;\n    return DelayedDiagnostics.pushUndelayed();\n  }\n  void PopParsingClass(ParsingClassState state) {\n    ParsingClassDepth--;\n    DelayedDiagnostics.popUndelayed(state);\n  }\n\n  void redelayDiagnostics(sema::DelayedDiagnosticPool &pool);\n\n  void DiagnoseAvailabilityOfDecl(NamedDecl *D, ArrayRef<SourceLocation> Locs,\n                                  const ObjCInterfaceDecl *UnknownObjCClass,\n                                  bool ObjCPropertyAccess,\n                                  bool AvoidPartialAvailabilityChecks = false,\n                                  ObjCInterfaceDecl *ClassReceiver = nullptr);\n\n  bool makeUnavailableInSystemHeader(SourceLocation loc,\n                                     UnavailableAttr::ImplicitReason reason);\n\n  /// Issue any -Wunguarded-availability warnings in \\c FD\n  void DiagnoseUnguardedAvailabilityViolations(Decl *FD);\n\n  void handleDelayedAvailabilityCheck(sema::DelayedDiagnostic &DD, Decl *Ctx);\n\n  //===--------------------------------------------------------------------===//\n  // Expression Parsing Callbacks: SemaExpr.cpp.\n\n  bool CanUseDecl(NamedDecl *D, bool TreatUnavailableAsInvalid);\n  bool DiagnoseUseOfDecl(NamedDecl *D, ArrayRef<SourceLocation> Locs,\n                         const ObjCInterfaceDecl *UnknownObjCClass = nullptr,\n                         bool ObjCPropertyAccess = false,\n                         bool AvoidPartialAvailabilityChecks = false,\n                         ObjCInterfaceDecl *ClassReciever = nullptr);\n  void NoteDeletedFunction(FunctionDecl *FD);\n  void NoteDeletedInheritingConstructor(CXXConstructorDecl *CD);\n  bool DiagnosePropertyAccessorMismatch(ObjCPropertyDecl *PD,\n                                        ObjCMethodDecl *Getter,\n                                        SourceLocation Loc);\n  void DiagnoseSentinelCalls(NamedDecl *D, SourceLocation Loc,\n                             ArrayRef<Expr *> Args);\n\n  void PushExpressionEvaluationContext(\n      ExpressionEvaluationContext NewContext, Decl *LambdaContextDecl = nullptr,\n      ExpressionEvaluationContextRecord::ExpressionKind Type =\n          ExpressionEvaluationContextRecord::EK_Other);\n  enum ReuseLambdaContextDecl_t { ReuseLambdaContextDecl };\n  void PushExpressionEvaluationContext(\n      ExpressionEvaluationContext NewContext, ReuseLambdaContextDecl_t,\n      ExpressionEvaluationContextRecord::ExpressionKind Type =\n          ExpressionEvaluationContextRecord::EK_Other);\n  void PopExpressionEvaluationContext();\n\n  void DiscardCleanupsInEvaluationContext();\n\n  ExprResult TransformToPotentiallyEvaluated(Expr *E);\n  ExprResult HandleExprEvaluationContextForTypeof(Expr *E);\n\n  ExprResult CheckUnevaluatedOperand(Expr *E);\n  void CheckUnusedVolatileAssignment(Expr *E);\n\n  ExprResult ActOnConstantExpression(ExprResult Res);\n\n  // Functions for marking a declaration referenced.  These functions also\n  // contain the relevant logic for marking if a reference to a function or\n  // variable is an odr-use (in the C++11 sense).  There are separate variants\n  // for expressions referring to a decl; these exist because odr-use marking\n  // needs to be delayed for some constant variables when we build one of the\n  // named expressions.\n  //\n  // MightBeOdrUse indicates whether the use could possibly be an odr-use, and\n  // should usually be true. This only needs to be set to false if the lack of\n  // odr-use cannot be determined from the current context (for instance,\n  // because the name denotes a virtual function and was written without an\n  // explicit nested-name-specifier).\n  void MarkAnyDeclReferenced(SourceLocation Loc, Decl *D, bool MightBeOdrUse);\n  void MarkFunctionReferenced(SourceLocation Loc, FunctionDecl *Func,\n                              bool MightBeOdrUse = true);\n  void MarkVariableReferenced(SourceLocation Loc, VarDecl *Var);\n  void MarkDeclRefReferenced(DeclRefExpr *E, const Expr *Base = nullptr);\n  void MarkMemberReferenced(MemberExpr *E);\n  void MarkFunctionParmPackReferenced(FunctionParmPackExpr *E);\n  void MarkCaptureUsedInEnclosingContext(VarDecl *Capture, SourceLocation Loc,\n                                         unsigned CapturingScopeIndex);\n\n  ExprResult CheckLValueToRValueConversionOperand(Expr *E);\n  void CleanupVarDeclMarking();\n\n  enum TryCaptureKind {\n    TryCapture_Implicit, TryCapture_ExplicitByVal, TryCapture_ExplicitByRef\n  };\n\n  /// Try to capture the given variable.\n  ///\n  /// \\param Var The variable to capture.\n  ///\n  /// \\param Loc The location at which the capture occurs.\n  ///\n  /// \\param Kind The kind of capture, which may be implicit (for either a\n  /// block or a lambda), or explicit by-value or by-reference (for a lambda).\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis, if one is provided in\n  /// an explicit lambda capture.\n  ///\n  /// \\param BuildAndDiagnose Whether we are actually supposed to add the\n  /// captures or diagnose errors. If false, this routine merely check whether\n  /// the capture can occur without performing the capture itself or complaining\n  /// if the variable cannot be captured.\n  ///\n  /// \\param CaptureType Will be set to the type of the field used to capture\n  /// this variable in the innermost block or lambda. Only valid when the\n  /// variable can be captured.\n  ///\n  /// \\param DeclRefType Will be set to the type of a reference to the capture\n  /// from within the current scope. Only valid when the variable can be\n  /// captured.\n  ///\n  /// \\param FunctionScopeIndexToStopAt If non-null, it points to the index\n  /// of the FunctionScopeInfo stack beyond which we do not attempt to capture.\n  /// This is useful when enclosing lambdas must speculatively capture\n  /// variables that may or may not be used in certain specializations of\n  /// a nested generic lambda.\n  ///\n  /// \\returns true if an error occurred (i.e., the variable cannot be\n  /// captured) and false if the capture succeeded.\n  bool tryCaptureVariable(VarDecl *Var, SourceLocation Loc, TryCaptureKind Kind,\n                          SourceLocation EllipsisLoc, bool BuildAndDiagnose,\n                          QualType &CaptureType,\n                          QualType &DeclRefType,\n                          const unsigned *const FunctionScopeIndexToStopAt);\n\n  /// Try to capture the given variable.\n  bool tryCaptureVariable(VarDecl *Var, SourceLocation Loc,\n                          TryCaptureKind Kind = TryCapture_Implicit,\n                          SourceLocation EllipsisLoc = SourceLocation());\n\n  /// Checks if the variable must be captured.\n  bool NeedToCaptureVariable(VarDecl *Var, SourceLocation Loc);\n\n  /// Given a variable, determine the type that a reference to that\n  /// variable will have in the given scope.\n  QualType getCapturedDeclRefType(VarDecl *Var, SourceLocation Loc);\n\n  /// Mark all of the declarations referenced within a particular AST node as\n  /// referenced. Used when template instantiation instantiates a non-dependent\n  /// type -- entities referenced by the type are now referenced.\n  void MarkDeclarationsReferencedInType(SourceLocation Loc, QualType T);\n  void MarkDeclarationsReferencedInExpr(Expr *E,\n                                        bool SkipLocalVariables = false);\n\n  /// Try to recover by turning the given expression into a\n  /// call.  Returns true if recovery was attempted or an error was\n  /// emitted; this may also leave the ExprResult invalid.\n  bool tryToRecoverWithCall(ExprResult &E, const PartialDiagnostic &PD,\n                            bool ForceComplain = false,\n                            bool (*IsPlausibleResult)(QualType) = nullptr);\n\n  /// Figure out if an expression could be turned into a call.\n  bool tryExprAsCall(Expr &E, QualType &ZeroArgCallReturnTy,\n                     UnresolvedSetImpl &NonTemplateOverloads);\n\n  /// Try to convert an expression \\p E to type \\p Ty. Returns the result of the\n  /// conversion.\n  ExprResult tryConvertExprToType(Expr *E, QualType Ty);\n\n  /// Conditionally issue a diagnostic based on the current\n  /// evaluation context.\n  ///\n  /// \\param Statement If Statement is non-null, delay reporting the\n  /// diagnostic until the function body is parsed, and then do a basic\n  /// reachability analysis to determine if the statement is reachable.\n  /// If it is unreachable, the diagnostic will not be emitted.\n  bool DiagRuntimeBehavior(SourceLocation Loc, const Stmt *Statement,\n                           const PartialDiagnostic &PD);\n  /// Similar, but diagnostic is only produced if all the specified statements\n  /// are reachable.\n  bool DiagRuntimeBehavior(SourceLocation Loc, ArrayRef<const Stmt*> Stmts,\n                           const PartialDiagnostic &PD);\n\n  // Primary Expressions.\n  SourceRange getExprRange(Expr *E) const;\n\n  ExprResult ActOnIdExpression(\n      Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,\n      UnqualifiedId &Id, bool HasTrailingLParen, bool IsAddressOfOperand,\n      CorrectionCandidateCallback *CCC = nullptr,\n      bool IsInlineAsmIdentifier = false, Token *KeywordReplacement = nullptr);\n\n  void DecomposeUnqualifiedId(const UnqualifiedId &Id,\n                              TemplateArgumentListInfo &Buffer,\n                              DeclarationNameInfo &NameInfo,\n                              const TemplateArgumentListInfo *&TemplateArgs);\n\n  bool DiagnoseDependentMemberLookup(LookupResult &R);\n\n  bool\n  DiagnoseEmptyLookup(Scope *S, CXXScopeSpec &SS, LookupResult &R,\n                      CorrectionCandidateCallback &CCC,\n                      TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr,\n                      ArrayRef<Expr *> Args = None, TypoExpr **Out = nullptr);\n\n  DeclResult LookupIvarInObjCMethod(LookupResult &Lookup, Scope *S,\n                                    IdentifierInfo *II);\n  ExprResult BuildIvarRefExpr(Scope *S, SourceLocation Loc, ObjCIvarDecl *IV);\n\n  ExprResult LookupInObjCMethod(LookupResult &LookUp, Scope *S,\n                                IdentifierInfo *II,\n                                bool AllowBuiltinCreation=false);\n\n  ExprResult ActOnDependentIdExpression(const CXXScopeSpec &SS,\n                                        SourceLocation TemplateKWLoc,\n                                        const DeclarationNameInfo &NameInfo,\n                                        bool isAddressOfOperand,\n                                const TemplateArgumentListInfo *TemplateArgs);\n\n  /// If \\p D cannot be odr-used in the current expression evaluation context,\n  /// return a reason explaining why. Otherwise, return NOUR_None.\n  NonOdrUseReason getNonOdrUseReasonInCurrentContext(ValueDecl *D);\n\n  DeclRefExpr *BuildDeclRefExpr(ValueDecl *D, QualType Ty, ExprValueKind VK,\n                                SourceLocation Loc,\n                                const CXXScopeSpec *SS = nullptr);\n  DeclRefExpr *\n  BuildDeclRefExpr(ValueDecl *D, QualType Ty, ExprValueKind VK,\n                   const DeclarationNameInfo &NameInfo,\n                   const CXXScopeSpec *SS = nullptr,\n                   NamedDecl *FoundD = nullptr,\n                   SourceLocation TemplateKWLoc = SourceLocation(),\n                   const TemplateArgumentListInfo *TemplateArgs = nullptr);\n  DeclRefExpr *\n  BuildDeclRefExpr(ValueDecl *D, QualType Ty, ExprValueKind VK,\n                   const DeclarationNameInfo &NameInfo,\n                   NestedNameSpecifierLoc NNS,\n                   NamedDecl *FoundD = nullptr,\n                   SourceLocation TemplateKWLoc = SourceLocation(),\n                   const TemplateArgumentListInfo *TemplateArgs = nullptr);\n\n  ExprResult\n  BuildAnonymousStructUnionMemberReference(\n      const CXXScopeSpec &SS,\n      SourceLocation nameLoc,\n      IndirectFieldDecl *indirectField,\n      DeclAccessPair FoundDecl = DeclAccessPair::make(nullptr, AS_none),\n      Expr *baseObjectExpr = nullptr,\n      SourceLocation opLoc = SourceLocation());\n\n  ExprResult BuildPossibleImplicitMemberExpr(\n      const CXXScopeSpec &SS, SourceLocation TemplateKWLoc, LookupResult &R,\n      const TemplateArgumentListInfo *TemplateArgs, const Scope *S,\n      UnresolvedLookupExpr *AsULE = nullptr);\n  ExprResult BuildImplicitMemberExpr(const CXXScopeSpec &SS,\n                                     SourceLocation TemplateKWLoc,\n                                     LookupResult &R,\n                                const TemplateArgumentListInfo *TemplateArgs,\n                                     bool IsDefiniteInstance,\n                                     const Scope *S);\n  bool UseArgumentDependentLookup(const CXXScopeSpec &SS,\n                                  const LookupResult &R,\n                                  bool HasTrailingLParen);\n\n  ExprResult\n  BuildQualifiedDeclarationNameExpr(CXXScopeSpec &SS,\n                                    const DeclarationNameInfo &NameInfo,\n                                    bool IsAddressOfOperand, const Scope *S,\n                                    TypeSourceInfo **RecoveryTSI = nullptr);\n\n  ExprResult BuildDependentDeclRefExpr(const CXXScopeSpec &SS,\n                                       SourceLocation TemplateKWLoc,\n                                const DeclarationNameInfo &NameInfo,\n                                const TemplateArgumentListInfo *TemplateArgs);\n\n  ExprResult BuildDeclarationNameExpr(const CXXScopeSpec &SS,\n                                      LookupResult &R,\n                                      bool NeedsADL,\n                                      bool AcceptInvalidDecl = false);\n  ExprResult BuildDeclarationNameExpr(\n      const CXXScopeSpec &SS, const DeclarationNameInfo &NameInfo, NamedDecl *D,\n      NamedDecl *FoundD = nullptr,\n      const TemplateArgumentListInfo *TemplateArgs = nullptr,\n      bool AcceptInvalidDecl = false);\n\n  ExprResult BuildLiteralOperatorCall(LookupResult &R,\n                      DeclarationNameInfo &SuffixInfo,\n                      ArrayRef<Expr *> Args,\n                      SourceLocation LitEndLoc,\n                      TemplateArgumentListInfo *ExplicitTemplateArgs = nullptr);\n\n  ExprResult BuildPredefinedExpr(SourceLocation Loc,\n                                 PredefinedExpr::IdentKind IK);\n  ExprResult ActOnPredefinedExpr(SourceLocation Loc, tok::TokenKind Kind);\n  ExprResult ActOnIntegerConstant(SourceLocation Loc, uint64_t Val);\n\n  bool CheckLoopHintExpr(Expr *E, SourceLocation Loc);\n\n  ExprResult ActOnNumericConstant(const Token &Tok, Scope *UDLScope = nullptr);\n  ExprResult ActOnCharacterConstant(const Token &Tok,\n                                    Scope *UDLScope = nullptr);\n  ExprResult ActOnParenExpr(SourceLocation L, SourceLocation R, Expr *E);\n  ExprResult ActOnParenListExpr(SourceLocation L,\n                                SourceLocation R,\n                                MultiExprArg Val);\n\n  /// ActOnStringLiteral - The specified tokens were lexed as pasted string\n  /// fragments (e.g. \"foo\" \"bar\" L\"baz\").\n  ExprResult ActOnStringLiteral(ArrayRef<Token> StringToks,\n                                Scope *UDLScope = nullptr);\n\n  ExprResult ActOnGenericSelectionExpr(SourceLocation KeyLoc,\n                                       SourceLocation DefaultLoc,\n                                       SourceLocation RParenLoc,\n                                       Expr *ControllingExpr,\n                                       ArrayRef<ParsedType> ArgTypes,\n                                       ArrayRef<Expr *> ArgExprs);\n  ExprResult CreateGenericSelectionExpr(SourceLocation KeyLoc,\n                                        SourceLocation DefaultLoc,\n                                        SourceLocation RParenLoc,\n                                        Expr *ControllingExpr,\n                                        ArrayRef<TypeSourceInfo *> Types,\n                                        ArrayRef<Expr *> Exprs);\n\n  // Binary/Unary Operators.  'Tok' is the token for the operator.\n  ExprResult CreateBuiltinUnaryOp(SourceLocation OpLoc, UnaryOperatorKind Opc,\n                                  Expr *InputExpr);\n  ExprResult BuildUnaryOp(Scope *S, SourceLocation OpLoc,\n                          UnaryOperatorKind Opc, Expr *Input);\n  ExprResult ActOnUnaryOp(Scope *S, SourceLocation OpLoc,\n                          tok::TokenKind Op, Expr *Input);\n\n  bool isQualifiedMemberAccess(Expr *E);\n  QualType CheckAddressOfOperand(ExprResult &Operand, SourceLocation OpLoc);\n\n  ExprResult CreateUnaryExprOrTypeTraitExpr(TypeSourceInfo *TInfo,\n                                            SourceLocation OpLoc,\n                                            UnaryExprOrTypeTrait ExprKind,\n                                            SourceRange R);\n  ExprResult CreateUnaryExprOrTypeTraitExpr(Expr *E, SourceLocation OpLoc,\n                                            UnaryExprOrTypeTrait ExprKind);\n  ExprResult\n    ActOnUnaryExprOrTypeTraitExpr(SourceLocation OpLoc,\n                                  UnaryExprOrTypeTrait ExprKind,\n                                  bool IsType, void *TyOrEx,\n                                  SourceRange ArgRange);\n\n  ExprResult CheckPlaceholderExpr(Expr *E);\n  bool CheckVecStepExpr(Expr *E);\n\n  bool CheckUnaryExprOrTypeTraitOperand(Expr *E, UnaryExprOrTypeTrait ExprKind);\n  bool CheckUnaryExprOrTypeTraitOperand(QualType ExprType, SourceLocation OpLoc,\n                                        SourceRange ExprRange,\n                                        UnaryExprOrTypeTrait ExprKind);\n  ExprResult ActOnSizeofParameterPackExpr(Scope *S,\n                                          SourceLocation OpLoc,\n                                          IdentifierInfo &Name,\n                                          SourceLocation NameLoc,\n                                          SourceLocation RParenLoc);\n  ExprResult ActOnPostfixUnaryOp(Scope *S, SourceLocation OpLoc,\n                                 tok::TokenKind Kind, Expr *Input);\n\n  ExprResult ActOnArraySubscriptExpr(Scope *S, Expr *Base, SourceLocation LLoc,\n                                     Expr *Idx, SourceLocation RLoc);\n  ExprResult CreateBuiltinArraySubscriptExpr(Expr *Base, SourceLocation LLoc,\n                                             Expr *Idx, SourceLocation RLoc);\n\n  ExprResult CreateBuiltinMatrixSubscriptExpr(Expr *Base, Expr *RowIdx,\n                                              Expr *ColumnIdx,\n                                              SourceLocation RBLoc);\n\n  ExprResult ActOnOMPArraySectionExpr(Expr *Base, SourceLocation LBLoc,\n                                      Expr *LowerBound,\n                                      SourceLocation ColonLocFirst,\n                                      SourceLocation ColonLocSecond,\n                                      Expr *Length, Expr *Stride,\n                                      SourceLocation RBLoc);\n  ExprResult ActOnOMPArrayShapingExpr(Expr *Base, SourceLocation LParenLoc,\n                                      SourceLocation RParenLoc,\n                                      ArrayRef<Expr *> Dims,\n                                      ArrayRef<SourceRange> Brackets);\n\n  /// Data structure for iterator expression.\n  struct OMPIteratorData {\n    IdentifierInfo *DeclIdent = nullptr;\n    SourceLocation DeclIdentLoc;\n    ParsedType Type;\n    OMPIteratorExpr::IteratorRange Range;\n    SourceLocation AssignLoc;\n    SourceLocation ColonLoc;\n    SourceLocation SecColonLoc;\n  };\n\n  ExprResult ActOnOMPIteratorExpr(Scope *S, SourceLocation IteratorKwLoc,\n                                  SourceLocation LLoc, SourceLocation RLoc,\n                                  ArrayRef<OMPIteratorData> Data);\n\n  // This struct is for use by ActOnMemberAccess to allow\n  // BuildMemberReferenceExpr to be able to reinvoke ActOnMemberAccess after\n  // changing the access operator from a '.' to a '->' (to see if that is the\n  // change needed to fix an error about an unknown member, e.g. when the class\n  // defines a custom operator->).\n  struct ActOnMemberAccessExtraArgs {\n    Scope *S;\n    UnqualifiedId &Id;\n    Decl *ObjCImpDecl;\n  };\n\n  ExprResult BuildMemberReferenceExpr(\n      Expr *Base, QualType BaseType, SourceLocation OpLoc, bool IsArrow,\n      CXXScopeSpec &SS, SourceLocation TemplateKWLoc,\n      NamedDecl *FirstQualifierInScope, const DeclarationNameInfo &NameInfo,\n      const TemplateArgumentListInfo *TemplateArgs,\n      const Scope *S,\n      ActOnMemberAccessExtraArgs *ExtraArgs = nullptr);\n\n  ExprResult\n  BuildMemberReferenceExpr(Expr *Base, QualType BaseType, SourceLocation OpLoc,\n                           bool IsArrow, const CXXScopeSpec &SS,\n                           SourceLocation TemplateKWLoc,\n                           NamedDecl *FirstQualifierInScope, LookupResult &R,\n                           const TemplateArgumentListInfo *TemplateArgs,\n                           const Scope *S,\n                           bool SuppressQualifierCheck = false,\n                           ActOnMemberAccessExtraArgs *ExtraArgs = nullptr);\n\n  ExprResult BuildFieldReferenceExpr(Expr *BaseExpr, bool IsArrow,\n                                     SourceLocation OpLoc,\n                                     const CXXScopeSpec &SS, FieldDecl *Field,\n                                     DeclAccessPair FoundDecl,\n                                     const DeclarationNameInfo &MemberNameInfo);\n\n  ExprResult PerformMemberExprBaseConversion(Expr *Base, bool IsArrow);\n\n  bool CheckQualifiedMemberReference(Expr *BaseExpr, QualType BaseType,\n                                     const CXXScopeSpec &SS,\n                                     const LookupResult &R);\n\n  ExprResult ActOnDependentMemberExpr(Expr *Base, QualType BaseType,\n                                      bool IsArrow, SourceLocation OpLoc,\n                                      const CXXScopeSpec &SS,\n                                      SourceLocation TemplateKWLoc,\n                                      NamedDecl *FirstQualifierInScope,\n                               const DeclarationNameInfo &NameInfo,\n                               const TemplateArgumentListInfo *TemplateArgs);\n\n  ExprResult ActOnMemberAccessExpr(Scope *S, Expr *Base,\n                                   SourceLocation OpLoc,\n                                   tok::TokenKind OpKind,\n                                   CXXScopeSpec &SS,\n                                   SourceLocation TemplateKWLoc,\n                                   UnqualifiedId &Member,\n                                   Decl *ObjCImpDecl);\n\n  MemberExpr *\n  BuildMemberExpr(Expr *Base, bool IsArrow, SourceLocation OpLoc,\n                  const CXXScopeSpec *SS, SourceLocation TemplateKWLoc,\n                  ValueDecl *Member, DeclAccessPair FoundDecl,\n                  bool HadMultipleCandidates,\n                  const DeclarationNameInfo &MemberNameInfo, QualType Ty,\n                  ExprValueKind VK, ExprObjectKind OK,\n                  const TemplateArgumentListInfo *TemplateArgs = nullptr);\n  MemberExpr *\n  BuildMemberExpr(Expr *Base, bool IsArrow, SourceLocation OpLoc,\n                  NestedNameSpecifierLoc NNS, SourceLocation TemplateKWLoc,\n                  ValueDecl *Member, DeclAccessPair FoundDecl,\n                  bool HadMultipleCandidates,\n                  const DeclarationNameInfo &MemberNameInfo, QualType Ty,\n                  ExprValueKind VK, ExprObjectKind OK,\n                  const TemplateArgumentListInfo *TemplateArgs = nullptr);\n\n  void ActOnDefaultCtorInitializers(Decl *CDtorDecl);\n  bool ConvertArgumentsForCall(CallExpr *Call, Expr *Fn,\n                               FunctionDecl *FDecl,\n                               const FunctionProtoType *Proto,\n                               ArrayRef<Expr *> Args,\n                               SourceLocation RParenLoc,\n                               bool ExecConfig = false);\n  void CheckStaticArrayArgument(SourceLocation CallLoc,\n                                ParmVarDecl *Param,\n                                const Expr *ArgExpr);\n\n  /// ActOnCallExpr - Handle a call to Fn with the specified array of arguments.\n  /// This provides the location of the left/right parens and a list of comma\n  /// locations.\n  ExprResult ActOnCallExpr(Scope *S, Expr *Fn, SourceLocation LParenLoc,\n                           MultiExprArg ArgExprs, SourceLocation RParenLoc,\n                           Expr *ExecConfig = nullptr);\n  ExprResult BuildCallExpr(Scope *S, Expr *Fn, SourceLocation LParenLoc,\n                           MultiExprArg ArgExprs, SourceLocation RParenLoc,\n                           Expr *ExecConfig = nullptr,\n                           bool IsExecConfig = false,\n                           bool AllowRecovery = false);\n  enum class AtomicArgumentOrder { API, AST };\n  ExprResult\n  BuildAtomicExpr(SourceRange CallRange, SourceRange ExprRange,\n                  SourceLocation RParenLoc, MultiExprArg Args,\n                  AtomicExpr::AtomicOp Op,\n                  AtomicArgumentOrder ArgOrder = AtomicArgumentOrder::API);\n  ExprResult\n  BuildResolvedCallExpr(Expr *Fn, NamedDecl *NDecl, SourceLocation LParenLoc,\n                        ArrayRef<Expr *> Arg, SourceLocation RParenLoc,\n                        Expr *Config = nullptr, bool IsExecConfig = false,\n                        ADLCallKind UsesADL = ADLCallKind::NotADL);\n\n  ExprResult ActOnCUDAExecConfigExpr(Scope *S, SourceLocation LLLLoc,\n                                     MultiExprArg ExecConfig,\n                                     SourceLocation GGGLoc);\n\n  ExprResult ActOnCastExpr(Scope *S, SourceLocation LParenLoc,\n                           Declarator &D, ParsedType &Ty,\n                           SourceLocation RParenLoc, Expr *CastExpr);\n  ExprResult BuildCStyleCastExpr(SourceLocation LParenLoc,\n                                 TypeSourceInfo *Ty,\n                                 SourceLocation RParenLoc,\n                                 Expr *Op);\n  CastKind PrepareScalarCast(ExprResult &src, QualType destType);\n\n  /// Build an altivec or OpenCL literal.\n  ExprResult BuildVectorLiteral(SourceLocation LParenLoc,\n                                SourceLocation RParenLoc, Expr *E,\n                                TypeSourceInfo *TInfo);\n\n  ExprResult MaybeConvertParenListExprToParenExpr(Scope *S, Expr *ME);\n\n  ExprResult ActOnCompoundLiteral(SourceLocation LParenLoc,\n                                  ParsedType Ty,\n                                  SourceLocation RParenLoc,\n                                  Expr *InitExpr);\n\n  ExprResult BuildCompoundLiteralExpr(SourceLocation LParenLoc,\n                                      TypeSourceInfo *TInfo,\n                                      SourceLocation RParenLoc,\n                                      Expr *LiteralExpr);\n\n  ExprResult ActOnInitList(SourceLocation LBraceLoc,\n                           MultiExprArg InitArgList,\n                           SourceLocation RBraceLoc);\n\n  ExprResult BuildInitList(SourceLocation LBraceLoc,\n                           MultiExprArg InitArgList,\n                           SourceLocation RBraceLoc);\n\n  ExprResult ActOnDesignatedInitializer(Designation &Desig,\n                                        SourceLocation EqualOrColonLoc,\n                                        bool GNUSyntax,\n                                        ExprResult Init);\n\nprivate:\n  static BinaryOperatorKind ConvertTokenKindToBinaryOpcode(tok::TokenKind Kind);\n\npublic:\n  ExprResult ActOnBinOp(Scope *S, SourceLocation TokLoc,\n                        tok::TokenKind Kind, Expr *LHSExpr, Expr *RHSExpr);\n  ExprResult BuildBinOp(Scope *S, SourceLocation OpLoc,\n                        BinaryOperatorKind Opc, Expr *LHSExpr, Expr *RHSExpr);\n  ExprResult CreateBuiltinBinOp(SourceLocation OpLoc, BinaryOperatorKind Opc,\n                                Expr *LHSExpr, Expr *RHSExpr);\n  void LookupBinOp(Scope *S, SourceLocation OpLoc, BinaryOperatorKind Opc,\n                   UnresolvedSetImpl &Functions);\n\n  void DiagnoseCommaOperator(const Expr *LHS, SourceLocation Loc);\n\n  /// ActOnConditionalOp - Parse a ?: operation.  Note that 'LHS' may be null\n  /// in the case of a the GNU conditional expr extension.\n  ExprResult ActOnConditionalOp(SourceLocation QuestionLoc,\n                                SourceLocation ColonLoc,\n                                Expr *CondExpr, Expr *LHSExpr, Expr *RHSExpr);\n\n  /// ActOnAddrLabel - Parse the GNU address of label extension: \"&&foo\".\n  ExprResult ActOnAddrLabel(SourceLocation OpLoc, SourceLocation LabLoc,\n                            LabelDecl *TheDecl);\n\n  void ActOnStartStmtExpr();\n  ExprResult ActOnStmtExpr(Scope *S, SourceLocation LPLoc, Stmt *SubStmt,\n                           SourceLocation RPLoc);\n  ExprResult BuildStmtExpr(SourceLocation LPLoc, Stmt *SubStmt,\n                           SourceLocation RPLoc, unsigned TemplateDepth);\n  // Handle the final expression in a statement expression.\n  ExprResult ActOnStmtExprResult(ExprResult E);\n  void ActOnStmtExprError();\n\n  // __builtin_offsetof(type, identifier(.identifier|[expr])*)\n  struct OffsetOfComponent {\n    SourceLocation LocStart, LocEnd;\n    bool isBrackets;  // true if [expr], false if .ident\n    union {\n      IdentifierInfo *IdentInfo;\n      Expr *E;\n    } U;\n  };\n\n  /// __builtin_offsetof(type, a.b[123][456].c)\n  ExprResult BuildBuiltinOffsetOf(SourceLocation BuiltinLoc,\n                                  TypeSourceInfo *TInfo,\n                                  ArrayRef<OffsetOfComponent> Components,\n                                  SourceLocation RParenLoc);\n  ExprResult ActOnBuiltinOffsetOf(Scope *S,\n                                  SourceLocation BuiltinLoc,\n                                  SourceLocation TypeLoc,\n                                  ParsedType ParsedArgTy,\n                                  ArrayRef<OffsetOfComponent> Components,\n                                  SourceLocation RParenLoc);\n\n  // __builtin_choose_expr(constExpr, expr1, expr2)\n  ExprResult ActOnChooseExpr(SourceLocation BuiltinLoc,\n                             Expr *CondExpr, Expr *LHSExpr,\n                             Expr *RHSExpr, SourceLocation RPLoc);\n\n  // __builtin_va_arg(expr, type)\n  ExprResult ActOnVAArg(SourceLocation BuiltinLoc, Expr *E, ParsedType Ty,\n                        SourceLocation RPLoc);\n  ExprResult BuildVAArgExpr(SourceLocation BuiltinLoc, Expr *E,\n                            TypeSourceInfo *TInfo, SourceLocation RPLoc);\n\n  // __builtin_LINE(), __builtin_FUNCTION(), __builtin_FILE(),\n  // __builtin_COLUMN()\n  ExprResult ActOnSourceLocExpr(SourceLocExpr::IdentKind Kind,\n                                SourceLocation BuiltinLoc,\n                                SourceLocation RPLoc);\n\n  // Build a potentially resolved SourceLocExpr.\n  ExprResult BuildSourceLocExpr(SourceLocExpr::IdentKind Kind,\n                                SourceLocation BuiltinLoc, SourceLocation RPLoc,\n                                DeclContext *ParentContext);\n\n  // __null\n  ExprResult ActOnGNUNullExpr(SourceLocation TokenLoc);\n\n  bool CheckCaseExpression(Expr *E);\n\n  /// Describes the result of an \"if-exists\" condition check.\n  enum IfExistsResult {\n    /// The symbol exists.\n    IER_Exists,\n\n    /// The symbol does not exist.\n    IER_DoesNotExist,\n\n    /// The name is a dependent name, so the results will differ\n    /// from one instantiation to the next.\n    IER_Dependent,\n\n    /// An error occurred.\n    IER_Error\n  };\n\n  IfExistsResult\n  CheckMicrosoftIfExistsSymbol(Scope *S, CXXScopeSpec &SS,\n                               const DeclarationNameInfo &TargetNameInfo);\n\n  IfExistsResult\n  CheckMicrosoftIfExistsSymbol(Scope *S, SourceLocation KeywordLoc,\n                               bool IsIfExists, CXXScopeSpec &SS,\n                               UnqualifiedId &Name);\n\n  StmtResult BuildMSDependentExistsStmt(SourceLocation KeywordLoc,\n                                        bool IsIfExists,\n                                        NestedNameSpecifierLoc QualifierLoc,\n                                        DeclarationNameInfo NameInfo,\n                                        Stmt *Nested);\n  StmtResult ActOnMSDependentExistsStmt(SourceLocation KeywordLoc,\n                                        bool IsIfExists,\n                                        CXXScopeSpec &SS, UnqualifiedId &Name,\n                                        Stmt *Nested);\n\n  //===------------------------- \"Block\" Extension ------------------------===//\n\n  /// ActOnBlockStart - This callback is invoked when a block literal is\n  /// started.\n  void ActOnBlockStart(SourceLocation CaretLoc, Scope *CurScope);\n\n  /// ActOnBlockArguments - This callback allows processing of block arguments.\n  /// If there are no arguments, this is still invoked.\n  void ActOnBlockArguments(SourceLocation CaretLoc, Declarator &ParamInfo,\n                           Scope *CurScope);\n\n  /// ActOnBlockError - If there is an error parsing a block, this callback\n  /// is invoked to pop the information about the block from the action impl.\n  void ActOnBlockError(SourceLocation CaretLoc, Scope *CurScope);\n\n  /// ActOnBlockStmtExpr - This is called when the body of a block statement\n  /// literal was successfully completed.  ^(int x){...}\n  ExprResult ActOnBlockStmtExpr(SourceLocation CaretLoc, Stmt *Body,\n                                Scope *CurScope);\n\n  //===---------------------------- Clang Extensions ----------------------===//\n\n  /// __builtin_convertvector(...)\n  ExprResult ActOnConvertVectorExpr(Expr *E, ParsedType ParsedDestTy,\n                                    SourceLocation BuiltinLoc,\n                                    SourceLocation RParenLoc);\n\n  //===---------------------------- OpenCL Features -----------------------===//\n\n  /// __builtin_astype(...)\n  ExprResult ActOnAsTypeExpr(Expr *E, ParsedType ParsedDestTy,\n                             SourceLocation BuiltinLoc,\n                             SourceLocation RParenLoc);\n\n  //===---------------------------- C++ Features --------------------------===//\n\n  // Act on C++ namespaces\n  Decl *ActOnStartNamespaceDef(Scope *S, SourceLocation InlineLoc,\n                               SourceLocation NamespaceLoc,\n                               SourceLocation IdentLoc, IdentifierInfo *Ident,\n                               SourceLocation LBrace,\n                               const ParsedAttributesView &AttrList,\n                               UsingDirectiveDecl *&UsingDecl);\n  void ActOnFinishNamespaceDef(Decl *Dcl, SourceLocation RBrace);\n\n  NamespaceDecl *getStdNamespace() const;\n  NamespaceDecl *getOrCreateStdNamespace();\n\n  NamespaceDecl *lookupStdExperimentalNamespace();\n\n  CXXRecordDecl *getStdBadAlloc() const;\n  EnumDecl *getStdAlignValT() const;\n\nprivate:\n  // A cache representing if we've fully checked the various comparison category\n  // types stored in ASTContext. The bit-index corresponds to the integer value\n  // of a ComparisonCategoryType enumerator.\n  llvm::SmallBitVector FullyCheckedComparisonCategories;\n\n  ValueDecl *tryLookupCtorInitMemberDecl(CXXRecordDecl *ClassDecl,\n                                         CXXScopeSpec &SS,\n                                         ParsedType TemplateTypeTy,\n                                         IdentifierInfo *MemberOrBase);\n\npublic:\n  enum class ComparisonCategoryUsage {\n    /// The '<=>' operator was used in an expression and a builtin operator\n    /// was selected.\n    OperatorInExpression,\n    /// A defaulted 'operator<=>' needed the comparison category. This\n    /// typically only applies to 'std::strong_ordering', due to the implicit\n    /// fallback return value.\n    DefaultedOperator,\n  };\n\n  /// Lookup the specified comparison category types in the standard\n  ///   library, an check the VarDecls possibly returned by the operator<=>\n  ///   builtins for that type.\n  ///\n  /// \\return The type of the comparison category type corresponding to the\n  ///   specified Kind, or a null type if an error occurs\n  QualType CheckComparisonCategoryType(ComparisonCategoryType Kind,\n                                       SourceLocation Loc,\n                                       ComparisonCategoryUsage Usage);\n\n  /// Tests whether Ty is an instance of std::initializer_list and, if\n  /// it is and Element is not NULL, assigns the element type to Element.\n  bool isStdInitializerList(QualType Ty, QualType *Element);\n\n  /// Looks for the std::initializer_list template and instantiates it\n  /// with Element, or emits an error if it's not found.\n  ///\n  /// \\returns The instantiated template, or null on error.\n  QualType BuildStdInitializerList(QualType Element, SourceLocation Loc);\n\n  /// Determine whether Ctor is an initializer-list constructor, as\n  /// defined in [dcl.init.list]p2.\n  bool isInitListConstructor(const FunctionDecl *Ctor);\n\n  Decl *ActOnUsingDirective(Scope *CurScope, SourceLocation UsingLoc,\n                            SourceLocation NamespcLoc, CXXScopeSpec &SS,\n                            SourceLocation IdentLoc,\n                            IdentifierInfo *NamespcName,\n                            const ParsedAttributesView &AttrList);\n\n  void PushUsingDirective(Scope *S, UsingDirectiveDecl *UDir);\n\n  Decl *ActOnNamespaceAliasDef(Scope *CurScope,\n                               SourceLocation NamespaceLoc,\n                               SourceLocation AliasLoc,\n                               IdentifierInfo *Alias,\n                               CXXScopeSpec &SS,\n                               SourceLocation IdentLoc,\n                               IdentifierInfo *Ident);\n\n  void HideUsingShadowDecl(Scope *S, UsingShadowDecl *Shadow);\n  bool CheckUsingShadowDecl(UsingDecl *UD, NamedDecl *Target,\n                            const LookupResult &PreviousDecls,\n                            UsingShadowDecl *&PrevShadow);\n  UsingShadowDecl *BuildUsingShadowDecl(Scope *S, UsingDecl *UD,\n                                        NamedDecl *Target,\n                                        UsingShadowDecl *PrevDecl);\n\n  bool CheckUsingDeclRedeclaration(SourceLocation UsingLoc,\n                                   bool HasTypenameKeyword,\n                                   const CXXScopeSpec &SS,\n                                   SourceLocation NameLoc,\n                                   const LookupResult &Previous);\n  bool CheckUsingDeclQualifier(SourceLocation UsingLoc,\n                               bool HasTypename,\n                               const CXXScopeSpec &SS,\n                               const DeclarationNameInfo &NameInfo,\n                               SourceLocation NameLoc);\n\n  NamedDecl *BuildUsingDeclaration(\n      Scope *S, AccessSpecifier AS, SourceLocation UsingLoc,\n      bool HasTypenameKeyword, SourceLocation TypenameLoc, CXXScopeSpec &SS,\n      DeclarationNameInfo NameInfo, SourceLocation EllipsisLoc,\n      const ParsedAttributesView &AttrList, bool IsInstantiation);\n  NamedDecl *BuildUsingPackDecl(NamedDecl *InstantiatedFrom,\n                                ArrayRef<NamedDecl *> Expansions);\n\n  bool CheckInheritingConstructorUsingDecl(UsingDecl *UD);\n\n  /// Given a derived-class using shadow declaration for a constructor and the\n  /// correspnding base class constructor, find or create the implicit\n  /// synthesized derived class constructor to use for this initialization.\n  CXXConstructorDecl *\n  findInheritingConstructor(SourceLocation Loc, CXXConstructorDecl *BaseCtor,\n                            ConstructorUsingShadowDecl *DerivedShadow);\n\n  Decl *ActOnUsingDeclaration(Scope *CurScope, AccessSpecifier AS,\n                              SourceLocation UsingLoc,\n                              SourceLocation TypenameLoc, CXXScopeSpec &SS,\n                              UnqualifiedId &Name, SourceLocation EllipsisLoc,\n                              const ParsedAttributesView &AttrList);\n  Decl *ActOnAliasDeclaration(Scope *CurScope, AccessSpecifier AS,\n                              MultiTemplateParamsArg TemplateParams,\n                              SourceLocation UsingLoc, UnqualifiedId &Name,\n                              const ParsedAttributesView &AttrList,\n                              TypeResult Type, Decl *DeclFromDeclSpec);\n\n  /// BuildCXXConstructExpr - Creates a complete call to a constructor,\n  /// including handling of its default argument expressions.\n  ///\n  /// \\param ConstructKind - a CXXConstructExpr::ConstructionKind\n  ExprResult\n  BuildCXXConstructExpr(SourceLocation ConstructLoc, QualType DeclInitType,\n                        NamedDecl *FoundDecl,\n                        CXXConstructorDecl *Constructor, MultiExprArg Exprs,\n                        bool HadMultipleCandidates, bool IsListInitialization,\n                        bool IsStdInitListInitialization,\n                        bool RequiresZeroInit, unsigned ConstructKind,\n                        SourceRange ParenRange);\n\n  /// Build a CXXConstructExpr whose constructor has already been resolved if\n  /// it denotes an inherited constructor.\n  ExprResult\n  BuildCXXConstructExpr(SourceLocation ConstructLoc, QualType DeclInitType,\n                        CXXConstructorDecl *Constructor, bool Elidable,\n                        MultiExprArg Exprs,\n                        bool HadMultipleCandidates, bool IsListInitialization,\n                        bool IsStdInitListInitialization,\n                        bool RequiresZeroInit, unsigned ConstructKind,\n                        SourceRange ParenRange);\n\n  // FIXME: Can we remove this and have the above BuildCXXConstructExpr check if\n  // the constructor can be elidable?\n  ExprResult\n  BuildCXXConstructExpr(SourceLocation ConstructLoc, QualType DeclInitType,\n                        NamedDecl *FoundDecl,\n                        CXXConstructorDecl *Constructor, bool Elidable,\n                        MultiExprArg Exprs, bool HadMultipleCandidates,\n                        bool IsListInitialization,\n                        bool IsStdInitListInitialization, bool RequiresZeroInit,\n                        unsigned ConstructKind, SourceRange ParenRange);\n\n  ExprResult BuildCXXDefaultInitExpr(SourceLocation Loc, FieldDecl *Field);\n\n\n  /// Instantiate or parse a C++ default argument expression as necessary.\n  /// Return true on error.\n  bool CheckCXXDefaultArgExpr(SourceLocation CallLoc, FunctionDecl *FD,\n                              ParmVarDecl *Param);\n\n  /// BuildCXXDefaultArgExpr - Creates a CXXDefaultArgExpr, instantiating\n  /// the default expr if needed.\n  ExprResult BuildCXXDefaultArgExpr(SourceLocation CallLoc,\n                                    FunctionDecl *FD,\n                                    ParmVarDecl *Param);\n\n  /// FinalizeVarWithDestructor - Prepare for calling destructor on the\n  /// constructed variable.\n  void FinalizeVarWithDestructor(VarDecl *VD, const RecordType *DeclInitType);\n\n  /// Helper class that collects exception specifications for\n  /// implicitly-declared special member functions.\n  class ImplicitExceptionSpecification {\n    // Pointer to allow copying\n    Sema *Self;\n    // We order exception specifications thus:\n    // noexcept is the most restrictive, but is only used in C++11.\n    // throw() comes next.\n    // Then a throw(collected exceptions)\n    // Finally no specification, which is expressed as noexcept(false).\n    // throw(...) is used instead if any called function uses it.\n    ExceptionSpecificationType ComputedEST;\n    llvm::SmallPtrSet<CanQualType, 4> ExceptionsSeen;\n    SmallVector<QualType, 4> Exceptions;\n\n    void ClearExceptions() {\n      ExceptionsSeen.clear();\n      Exceptions.clear();\n    }\n\n  public:\n    explicit ImplicitExceptionSpecification(Sema &Self)\n      : Self(&Self), ComputedEST(EST_BasicNoexcept) {\n      if (!Self.getLangOpts().CPlusPlus11)\n        ComputedEST = EST_DynamicNone;\n    }\n\n    /// Get the computed exception specification type.\n    ExceptionSpecificationType getExceptionSpecType() const {\n      assert(!isComputedNoexcept(ComputedEST) &&\n             \"noexcept(expr) should not be a possible result\");\n      return ComputedEST;\n    }\n\n    /// The number of exceptions in the exception specification.\n    unsigned size() const { return Exceptions.size(); }\n\n    /// The set of exceptions in the exception specification.\n    const QualType *data() const { return Exceptions.data(); }\n\n    /// Integrate another called method into the collected data.\n    void CalledDecl(SourceLocation CallLoc, const CXXMethodDecl *Method);\n\n    /// Integrate an invoked expression into the collected data.\n    void CalledExpr(Expr *E) { CalledStmt(E); }\n\n    /// Integrate an invoked statement into the collected data.\n    void CalledStmt(Stmt *S);\n\n    /// Overwrite an EPI's exception specification with this\n    /// computed exception specification.\n    FunctionProtoType::ExceptionSpecInfo getExceptionSpec() const {\n      FunctionProtoType::ExceptionSpecInfo ESI;\n      ESI.Type = getExceptionSpecType();\n      if (ESI.Type == EST_Dynamic) {\n        ESI.Exceptions = Exceptions;\n      } else if (ESI.Type == EST_None) {\n        /// C++11 [except.spec]p14:\n        ///   The exception-specification is noexcept(false) if the set of\n        ///   potential exceptions of the special member function contains \"any\"\n        ESI.Type = EST_NoexceptFalse;\n        ESI.NoexceptExpr = Self->ActOnCXXBoolLiteral(SourceLocation(),\n                                                     tok::kw_false).get();\n      }\n      return ESI;\n    }\n  };\n\n  /// Evaluate the implicit exception specification for a defaulted\n  /// special member function.\n  void EvaluateImplicitExceptionSpec(SourceLocation Loc, FunctionDecl *FD);\n\n  /// Check the given noexcept-specifier, convert its expression, and compute\n  /// the appropriate ExceptionSpecificationType.\n  ExprResult ActOnNoexceptSpec(SourceLocation NoexceptLoc, Expr *NoexceptExpr,\n                               ExceptionSpecificationType &EST);\n\n  /// Check the given exception-specification and update the\n  /// exception specification information with the results.\n  void checkExceptionSpecification(bool IsTopLevel,\n                                   ExceptionSpecificationType EST,\n                                   ArrayRef<ParsedType> DynamicExceptions,\n                                   ArrayRef<SourceRange> DynamicExceptionRanges,\n                                   Expr *NoexceptExpr,\n                                   SmallVectorImpl<QualType> &Exceptions,\n                                   FunctionProtoType::ExceptionSpecInfo &ESI);\n\n  /// Determine if we're in a case where we need to (incorrectly) eagerly\n  /// parse an exception specification to work around a libstdc++ bug.\n  bool isLibstdcxxEagerExceptionSpecHack(const Declarator &D);\n\n  /// Add an exception-specification to the given member function\n  /// (or member function template). The exception-specification was parsed\n  /// after the method itself was declared.\n  void actOnDelayedExceptionSpecification(Decl *Method,\n         ExceptionSpecificationType EST,\n         SourceRange SpecificationRange,\n         ArrayRef<ParsedType> DynamicExceptions,\n         ArrayRef<SourceRange> DynamicExceptionRanges,\n         Expr *NoexceptExpr);\n\n  class InheritedConstructorInfo;\n\n  /// Determine if a special member function should have a deleted\n  /// definition when it is defaulted.\n  bool ShouldDeleteSpecialMember(CXXMethodDecl *MD, CXXSpecialMember CSM,\n                                 InheritedConstructorInfo *ICI = nullptr,\n                                 bool Diagnose = false);\n\n  /// Produce notes explaining why a defaulted function was defined as deleted.\n  void DiagnoseDeletedDefaultedFunction(FunctionDecl *FD);\n\n  /// Declare the implicit default constructor for the given class.\n  ///\n  /// \\param ClassDecl The class declaration into which the implicit\n  /// default constructor will be added.\n  ///\n  /// \\returns The implicitly-declared default constructor.\n  CXXConstructorDecl *DeclareImplicitDefaultConstructor(\n                                                     CXXRecordDecl *ClassDecl);\n\n  /// DefineImplicitDefaultConstructor - Checks for feasibility of\n  /// defining this constructor as the default constructor.\n  void DefineImplicitDefaultConstructor(SourceLocation CurrentLocation,\n                                        CXXConstructorDecl *Constructor);\n\n  /// Declare the implicit destructor for the given class.\n  ///\n  /// \\param ClassDecl The class declaration into which the implicit\n  /// destructor will be added.\n  ///\n  /// \\returns The implicitly-declared destructor.\n  CXXDestructorDecl *DeclareImplicitDestructor(CXXRecordDecl *ClassDecl);\n\n  /// DefineImplicitDestructor - Checks for feasibility of\n  /// defining this destructor as the default destructor.\n  void DefineImplicitDestructor(SourceLocation CurrentLocation,\n                                CXXDestructorDecl *Destructor);\n\n  /// Build an exception spec for destructors that don't have one.\n  ///\n  /// C++11 says that user-defined destructors with no exception spec get one\n  /// that looks as if the destructor was implicitly declared.\n  void AdjustDestructorExceptionSpec(CXXDestructorDecl *Destructor);\n\n  /// Define the specified inheriting constructor.\n  void DefineInheritingConstructor(SourceLocation UseLoc,\n                                   CXXConstructorDecl *Constructor);\n\n  /// Declare the implicit copy constructor for the given class.\n  ///\n  /// \\param ClassDecl The class declaration into which the implicit\n  /// copy constructor will be added.\n  ///\n  /// \\returns The implicitly-declared copy constructor.\n  CXXConstructorDecl *DeclareImplicitCopyConstructor(CXXRecordDecl *ClassDecl);\n\n  /// DefineImplicitCopyConstructor - Checks for feasibility of\n  /// defining this constructor as the copy constructor.\n  void DefineImplicitCopyConstructor(SourceLocation CurrentLocation,\n                                     CXXConstructorDecl *Constructor);\n\n  /// Declare the implicit move constructor for the given class.\n  ///\n  /// \\param ClassDecl The Class declaration into which the implicit\n  /// move constructor will be added.\n  ///\n  /// \\returns The implicitly-declared move constructor, or NULL if it wasn't\n  /// declared.\n  CXXConstructorDecl *DeclareImplicitMoveConstructor(CXXRecordDecl *ClassDecl);\n\n  /// DefineImplicitMoveConstructor - Checks for feasibility of\n  /// defining this constructor as the move constructor.\n  void DefineImplicitMoveConstructor(SourceLocation CurrentLocation,\n                                     CXXConstructorDecl *Constructor);\n\n  /// Declare the implicit copy assignment operator for the given class.\n  ///\n  /// \\param ClassDecl The class declaration into which the implicit\n  /// copy assignment operator will be added.\n  ///\n  /// \\returns The implicitly-declared copy assignment operator.\n  CXXMethodDecl *DeclareImplicitCopyAssignment(CXXRecordDecl *ClassDecl);\n\n  /// Defines an implicitly-declared copy assignment operator.\n  void DefineImplicitCopyAssignment(SourceLocation CurrentLocation,\n                                    CXXMethodDecl *MethodDecl);\n\n  /// Declare the implicit move assignment operator for the given class.\n  ///\n  /// \\param ClassDecl The Class declaration into which the implicit\n  /// move assignment operator will be added.\n  ///\n  /// \\returns The implicitly-declared move assignment operator, or NULL if it\n  /// wasn't declared.\n  CXXMethodDecl *DeclareImplicitMoveAssignment(CXXRecordDecl *ClassDecl);\n\n  /// Defines an implicitly-declared move assignment operator.\n  void DefineImplicitMoveAssignment(SourceLocation CurrentLocation,\n                                    CXXMethodDecl *MethodDecl);\n\n  /// Force the declaration of any implicitly-declared members of this\n  /// class.\n  void ForceDeclarationOfImplicitMembers(CXXRecordDecl *Class);\n\n  /// Check a completed declaration of an implicit special member.\n  void CheckImplicitSpecialMemberDeclaration(Scope *S, FunctionDecl *FD);\n\n  /// Determine whether the given function is an implicitly-deleted\n  /// special member function.\n  bool isImplicitlyDeleted(FunctionDecl *FD);\n\n  /// Check whether 'this' shows up in the type of a static member\n  /// function after the (naturally empty) cv-qualifier-seq would be.\n  ///\n  /// \\returns true if an error occurred.\n  bool checkThisInStaticMemberFunctionType(CXXMethodDecl *Method);\n\n  /// Whether this' shows up in the exception specification of a static\n  /// member function.\n  bool checkThisInStaticMemberFunctionExceptionSpec(CXXMethodDecl *Method);\n\n  /// Check whether 'this' shows up in the attributes of the given\n  /// static member function.\n  ///\n  /// \\returns true if an error occurred.\n  bool checkThisInStaticMemberFunctionAttributes(CXXMethodDecl *Method);\n\n  /// MaybeBindToTemporary - If the passed in expression has a record type with\n  /// a non-trivial destructor, this will return CXXBindTemporaryExpr. Otherwise\n  /// it simply returns the passed in expression.\n  ExprResult MaybeBindToTemporary(Expr *E);\n\n  /// Wrap the expression in a ConstantExpr if it is a potential immediate\n  /// invocation.\n  ExprResult CheckForImmediateInvocation(ExprResult E, FunctionDecl *Decl);\n\n  bool CompleteConstructorCall(CXXConstructorDecl *Constructor,\n                               QualType DeclInitType, MultiExprArg ArgsPtr,\n                               SourceLocation Loc,\n                               SmallVectorImpl<Expr *> &ConvertedArgs,\n                               bool AllowExplicit = false,\n                               bool IsListInitialization = false);\n\n  ParsedType getInheritingConstructorName(CXXScopeSpec &SS,\n                                          SourceLocation NameLoc,\n                                          IdentifierInfo &Name);\n\n  ParsedType getConstructorName(IdentifierInfo &II, SourceLocation NameLoc,\n                                Scope *S, CXXScopeSpec &SS,\n                                bool EnteringContext);\n  ParsedType getDestructorName(SourceLocation TildeLoc,\n                               IdentifierInfo &II, SourceLocation NameLoc,\n                               Scope *S, CXXScopeSpec &SS,\n                               ParsedType ObjectType,\n                               bool EnteringContext);\n\n  ParsedType getDestructorTypeForDecltype(const DeclSpec &DS,\n                                          ParsedType ObjectType);\n\n  // Checks that reinterpret casts don't have undefined behavior.\n  void CheckCompatibleReinterpretCast(QualType SrcType, QualType DestType,\n                                      bool IsDereference, SourceRange Range);\n\n  /// ActOnCXXNamedCast - Parse\n  /// {dynamic,static,reinterpret,const,addrspace}_cast's.\n  ExprResult ActOnCXXNamedCast(SourceLocation OpLoc,\n                               tok::TokenKind Kind,\n                               SourceLocation LAngleBracketLoc,\n                               Declarator &D,\n                               SourceLocation RAngleBracketLoc,\n                               SourceLocation LParenLoc,\n                               Expr *E,\n                               SourceLocation RParenLoc);\n\n  ExprResult BuildCXXNamedCast(SourceLocation OpLoc,\n                               tok::TokenKind Kind,\n                               TypeSourceInfo *Ty,\n                               Expr *E,\n                               SourceRange AngleBrackets,\n                               SourceRange Parens);\n\n  ExprResult ActOnBuiltinBitCastExpr(SourceLocation KWLoc, Declarator &Dcl,\n                                     ExprResult Operand,\n                                     SourceLocation RParenLoc);\n\n  ExprResult BuildBuiltinBitCastExpr(SourceLocation KWLoc, TypeSourceInfo *TSI,\n                                     Expr *Operand, SourceLocation RParenLoc);\n\n  ExprResult BuildCXXTypeId(QualType TypeInfoType,\n                            SourceLocation TypeidLoc,\n                            TypeSourceInfo *Operand,\n                            SourceLocation RParenLoc);\n  ExprResult BuildCXXTypeId(QualType TypeInfoType,\n                            SourceLocation TypeidLoc,\n                            Expr *Operand,\n                            SourceLocation RParenLoc);\n\n  /// ActOnCXXTypeid - Parse typeid( something ).\n  ExprResult ActOnCXXTypeid(SourceLocation OpLoc,\n                            SourceLocation LParenLoc, bool isType,\n                            void *TyOrExpr,\n                            SourceLocation RParenLoc);\n\n  ExprResult BuildCXXUuidof(QualType TypeInfoType,\n                            SourceLocation TypeidLoc,\n                            TypeSourceInfo *Operand,\n                            SourceLocation RParenLoc);\n  ExprResult BuildCXXUuidof(QualType TypeInfoType,\n                            SourceLocation TypeidLoc,\n                            Expr *Operand,\n                            SourceLocation RParenLoc);\n\n  /// ActOnCXXUuidof - Parse __uuidof( something ).\n  ExprResult ActOnCXXUuidof(SourceLocation OpLoc,\n                            SourceLocation LParenLoc, bool isType,\n                            void *TyOrExpr,\n                            SourceLocation RParenLoc);\n\n  /// Handle a C++1z fold-expression: ( expr op ... op expr ).\n  ExprResult ActOnCXXFoldExpr(Scope *S, SourceLocation LParenLoc, Expr *LHS,\n                              tok::TokenKind Operator,\n                              SourceLocation EllipsisLoc, Expr *RHS,\n                              SourceLocation RParenLoc);\n  ExprResult BuildCXXFoldExpr(UnresolvedLookupExpr *Callee,\n                              SourceLocation LParenLoc, Expr *LHS,\n                              BinaryOperatorKind Operator,\n                              SourceLocation EllipsisLoc, Expr *RHS,\n                              SourceLocation RParenLoc,\n                              Optional<unsigned> NumExpansions);\n  ExprResult BuildEmptyCXXFoldExpr(SourceLocation EllipsisLoc,\n                                   BinaryOperatorKind Operator);\n\n  //// ActOnCXXThis -  Parse 'this' pointer.\n  ExprResult ActOnCXXThis(SourceLocation loc);\n\n  /// Build a CXXThisExpr and mark it referenced in the current context.\n  Expr *BuildCXXThisExpr(SourceLocation Loc, QualType Type, bool IsImplicit);\n  void MarkThisReferenced(CXXThisExpr *This);\n\n  /// Try to retrieve the type of the 'this' pointer.\n  ///\n  /// \\returns The type of 'this', if possible. Otherwise, returns a NULL type.\n  QualType getCurrentThisType();\n\n  /// When non-NULL, the C++ 'this' expression is allowed despite the\n  /// current context not being a non-static member function. In such cases,\n  /// this provides the type used for 'this'.\n  QualType CXXThisTypeOverride;\n\n  /// RAII object used to temporarily allow the C++ 'this' expression\n  /// to be used, with the given qualifiers on the current class type.\n  class CXXThisScopeRAII {\n    Sema &S;\n    QualType OldCXXThisTypeOverride;\n    bool Enabled;\n\n  public:\n    /// Introduce a new scope where 'this' may be allowed (when enabled),\n    /// using the given declaration (which is either a class template or a\n    /// class) along with the given qualifiers.\n    /// along with the qualifiers placed on '*this'.\n    CXXThisScopeRAII(Sema &S, Decl *ContextDecl, Qualifiers CXXThisTypeQuals,\n                     bool Enabled = true);\n\n    ~CXXThisScopeRAII();\n  };\n\n  /// Make sure the value of 'this' is actually available in the current\n  /// context, if it is a potentially evaluated context.\n  ///\n  /// \\param Loc The location at which the capture of 'this' occurs.\n  ///\n  /// \\param Explicit Whether 'this' is explicitly captured in a lambda\n  /// capture list.\n  ///\n  /// \\param FunctionScopeIndexToStopAt If non-null, it points to the index\n  /// of the FunctionScopeInfo stack beyond which we do not attempt to capture.\n  /// This is useful when enclosing lambdas must speculatively capture\n  /// 'this' that may or may not be used in certain specializations of\n  /// a nested generic lambda (depending on whether the name resolves to\n  /// a non-static member function or a static function).\n  /// \\return returns 'true' if failed, 'false' if success.\n  bool CheckCXXThisCapture(SourceLocation Loc, bool Explicit = false,\n      bool BuildAndDiagnose = true,\n      const unsigned *const FunctionScopeIndexToStopAt = nullptr,\n      bool ByCopy = false);\n\n  /// Determine whether the given type is the type of *this that is used\n  /// outside of the body of a member function for a type that is currently\n  /// being defined.\n  bool isThisOutsideMemberFunctionBody(QualType BaseType);\n\n  /// ActOnCXXBoolLiteral - Parse {true,false} literals.\n  ExprResult ActOnCXXBoolLiteral(SourceLocation OpLoc, tok::TokenKind Kind);\n\n\n  /// ActOnObjCBoolLiteral - Parse {__objc_yes,__objc_no} literals.\n  ExprResult ActOnObjCBoolLiteral(SourceLocation OpLoc, tok::TokenKind Kind);\n\n  ExprResult\n  ActOnObjCAvailabilityCheckExpr(llvm::ArrayRef<AvailabilitySpec> AvailSpecs,\n                                 SourceLocation AtLoc, SourceLocation RParen);\n\n  /// ActOnCXXNullPtrLiteral - Parse 'nullptr'.\n  ExprResult ActOnCXXNullPtrLiteral(SourceLocation Loc);\n\n  //// ActOnCXXThrow -  Parse throw expressions.\n  ExprResult ActOnCXXThrow(Scope *S, SourceLocation OpLoc, Expr *expr);\n  ExprResult BuildCXXThrow(SourceLocation OpLoc, Expr *Ex,\n                           bool IsThrownVarInScope);\n  bool CheckCXXThrowOperand(SourceLocation ThrowLoc, QualType ThrowTy, Expr *E);\n\n  /// ActOnCXXTypeConstructExpr - Parse construction of a specified type.\n  /// Can be interpreted either as function-style casting (\"int(x)\")\n  /// or class type construction (\"ClassType(x,y,z)\")\n  /// or creation of a value-initialized type (\"int()\").\n  ExprResult ActOnCXXTypeConstructExpr(ParsedType TypeRep,\n                                       SourceLocation LParenOrBraceLoc,\n                                       MultiExprArg Exprs,\n                                       SourceLocation RParenOrBraceLoc,\n                                       bool ListInitialization);\n\n  ExprResult BuildCXXTypeConstructExpr(TypeSourceInfo *Type,\n                                       SourceLocation LParenLoc,\n                                       MultiExprArg Exprs,\n                                       SourceLocation RParenLoc,\n                                       bool ListInitialization);\n\n  /// ActOnCXXNew - Parsed a C++ 'new' expression.\n  ExprResult ActOnCXXNew(SourceLocation StartLoc, bool UseGlobal,\n                         SourceLocation PlacementLParen,\n                         MultiExprArg PlacementArgs,\n                         SourceLocation PlacementRParen,\n                         SourceRange TypeIdParens, Declarator &D,\n                         Expr *Initializer);\n  ExprResult BuildCXXNew(SourceRange Range, bool UseGlobal,\n                         SourceLocation PlacementLParen,\n                         MultiExprArg PlacementArgs,\n                         SourceLocation PlacementRParen,\n                         SourceRange TypeIdParens,\n                         QualType AllocType,\n                         TypeSourceInfo *AllocTypeInfo,\n                         Optional<Expr *> ArraySize,\n                         SourceRange DirectInitRange,\n                         Expr *Initializer);\n\n  /// Determine whether \\p FD is an aligned allocation or deallocation\n  /// function that is unavailable.\n  bool isUnavailableAlignedAllocationFunction(const FunctionDecl &FD) const;\n\n  /// Produce diagnostics if \\p FD is an aligned allocation or deallocation\n  /// function that is unavailable.\n  void diagnoseUnavailableAlignedAllocation(const FunctionDecl &FD,\n                                            SourceLocation Loc);\n\n  bool CheckAllocatedType(QualType AllocType, SourceLocation Loc,\n                          SourceRange R);\n\n  /// The scope in which to find allocation functions.\n  enum AllocationFunctionScope {\n    /// Only look for allocation functions in the global scope.\n    AFS_Global,\n    /// Only look for allocation functions in the scope of the\n    /// allocated class.\n    AFS_Class,\n    /// Look for allocation functions in both the global scope\n    /// and in the scope of the allocated class.\n    AFS_Both\n  };\n\n  /// Finds the overloads of operator new and delete that are appropriate\n  /// for the allocation.\n  bool FindAllocationFunctions(SourceLocation StartLoc, SourceRange Range,\n                               AllocationFunctionScope NewScope,\n                               AllocationFunctionScope DeleteScope,\n                               QualType AllocType, bool IsArray,\n                               bool &PassAlignment, MultiExprArg PlaceArgs,\n                               FunctionDecl *&OperatorNew,\n                               FunctionDecl *&OperatorDelete,\n                               bool Diagnose = true);\n  void DeclareGlobalNewDelete();\n  void DeclareGlobalAllocationFunction(DeclarationName Name, QualType Return,\n                                       ArrayRef<QualType> Params);\n\n  bool FindDeallocationFunction(SourceLocation StartLoc, CXXRecordDecl *RD,\n                                DeclarationName Name, FunctionDecl* &Operator,\n                                bool Diagnose = true);\n  FunctionDecl *FindUsualDeallocationFunction(SourceLocation StartLoc,\n                                              bool CanProvideSize,\n                                              bool Overaligned,\n                                              DeclarationName Name);\n  FunctionDecl *FindDeallocationFunctionForDestructor(SourceLocation StartLoc,\n                                                      CXXRecordDecl *RD);\n\n  /// ActOnCXXDelete - Parsed a C++ 'delete' expression\n  ExprResult ActOnCXXDelete(SourceLocation StartLoc,\n                            bool UseGlobal, bool ArrayForm,\n                            Expr *Operand);\n  void CheckVirtualDtorCall(CXXDestructorDecl *dtor, SourceLocation Loc,\n                            bool IsDelete, bool CallCanBeVirtual,\n                            bool WarnOnNonAbstractTypes,\n                            SourceLocation DtorLoc);\n\n  ExprResult ActOnNoexceptExpr(SourceLocation KeyLoc, SourceLocation LParen,\n                               Expr *Operand, SourceLocation RParen);\n  ExprResult BuildCXXNoexceptExpr(SourceLocation KeyLoc, Expr *Operand,\n                                  SourceLocation RParen);\n\n  /// Parsed one of the type trait support pseudo-functions.\n  ExprResult ActOnTypeTrait(TypeTrait Kind, SourceLocation KWLoc,\n                            ArrayRef<ParsedType> Args,\n                            SourceLocation RParenLoc);\n  ExprResult BuildTypeTrait(TypeTrait Kind, SourceLocation KWLoc,\n                            ArrayRef<TypeSourceInfo *> Args,\n                            SourceLocation RParenLoc);\n\n  /// ActOnArrayTypeTrait - Parsed one of the binary type trait support\n  /// pseudo-functions.\n  ExprResult ActOnArrayTypeTrait(ArrayTypeTrait ATT,\n                                 SourceLocation KWLoc,\n                                 ParsedType LhsTy,\n                                 Expr *DimExpr,\n                                 SourceLocation RParen);\n\n  ExprResult BuildArrayTypeTrait(ArrayTypeTrait ATT,\n                                 SourceLocation KWLoc,\n                                 TypeSourceInfo *TSInfo,\n                                 Expr *DimExpr,\n                                 SourceLocation RParen);\n\n  /// ActOnExpressionTrait - Parsed one of the unary type trait support\n  /// pseudo-functions.\n  ExprResult ActOnExpressionTrait(ExpressionTrait OET,\n                                  SourceLocation KWLoc,\n                                  Expr *Queried,\n                                  SourceLocation RParen);\n\n  ExprResult BuildExpressionTrait(ExpressionTrait OET,\n                                  SourceLocation KWLoc,\n                                  Expr *Queried,\n                                  SourceLocation RParen);\n\n  ExprResult ActOnStartCXXMemberReference(Scope *S,\n                                          Expr *Base,\n                                          SourceLocation OpLoc,\n                                          tok::TokenKind OpKind,\n                                          ParsedType &ObjectType,\n                                          bool &MayBePseudoDestructor);\n\n  ExprResult BuildPseudoDestructorExpr(Expr *Base,\n                                       SourceLocation OpLoc,\n                                       tok::TokenKind OpKind,\n                                       const CXXScopeSpec &SS,\n                                       TypeSourceInfo *ScopeType,\n                                       SourceLocation CCLoc,\n                                       SourceLocation TildeLoc,\n                                     PseudoDestructorTypeStorage DestroyedType);\n\n  ExprResult ActOnPseudoDestructorExpr(Scope *S, Expr *Base,\n                                       SourceLocation OpLoc,\n                                       tok::TokenKind OpKind,\n                                       CXXScopeSpec &SS,\n                                       UnqualifiedId &FirstTypeName,\n                                       SourceLocation CCLoc,\n                                       SourceLocation TildeLoc,\n                                       UnqualifiedId &SecondTypeName);\n\n  ExprResult ActOnPseudoDestructorExpr(Scope *S, Expr *Base,\n                                       SourceLocation OpLoc,\n                                       tok::TokenKind OpKind,\n                                       SourceLocation TildeLoc,\n                                       const DeclSpec& DS);\n\n  /// MaybeCreateExprWithCleanups - If the current full-expression\n  /// requires any cleanups, surround it with a ExprWithCleanups node.\n  /// Otherwise, just returns the passed-in expression.\n  Expr *MaybeCreateExprWithCleanups(Expr *SubExpr);\n  Stmt *MaybeCreateStmtWithCleanups(Stmt *SubStmt);\n  ExprResult MaybeCreateExprWithCleanups(ExprResult SubExpr);\n\n  MaterializeTemporaryExpr *\n  CreateMaterializeTemporaryExpr(QualType T, Expr *Temporary,\n                                 bool BoundToLvalueReference);\n\n  ExprResult ActOnFinishFullExpr(Expr *Expr, bool DiscardedValue) {\n    return ActOnFinishFullExpr(\n        Expr, Expr ? Expr->getExprLoc() : SourceLocation(), DiscardedValue);\n  }\n  ExprResult ActOnFinishFullExpr(Expr *Expr, SourceLocation CC,\n                                 bool DiscardedValue, bool IsConstexpr = false);\n  StmtResult ActOnFinishFullStmt(Stmt *Stmt);\n\n  // Marks SS invalid if it represents an incomplete type.\n  bool RequireCompleteDeclContext(CXXScopeSpec &SS, DeclContext *DC);\n\n  DeclContext *computeDeclContext(QualType T);\n  DeclContext *computeDeclContext(const CXXScopeSpec &SS,\n                                  bool EnteringContext = false);\n  bool isDependentScopeSpecifier(const CXXScopeSpec &SS);\n  CXXRecordDecl *getCurrentInstantiationOf(NestedNameSpecifier *NNS);\n\n  /// The parser has parsed a global nested-name-specifier '::'.\n  ///\n  /// \\param CCLoc The location of the '::'.\n  ///\n  /// \\param SS The nested-name-specifier, which will be updated in-place\n  /// to reflect the parsed nested-name-specifier.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool ActOnCXXGlobalScopeSpecifier(SourceLocation CCLoc, CXXScopeSpec &SS);\n\n  /// The parser has parsed a '__super' nested-name-specifier.\n  ///\n  /// \\param SuperLoc The location of the '__super' keyword.\n  ///\n  /// \\param ColonColonLoc The location of the '::'.\n  ///\n  /// \\param SS The nested-name-specifier, which will be updated in-place\n  /// to reflect the parsed nested-name-specifier.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool ActOnSuperScopeSpecifier(SourceLocation SuperLoc,\n                                SourceLocation ColonColonLoc, CXXScopeSpec &SS);\n\n  bool isAcceptableNestedNameSpecifier(const NamedDecl *SD,\n                                       bool *CanCorrect = nullptr);\n  NamedDecl *FindFirstQualifierInScope(Scope *S, NestedNameSpecifier *NNS);\n\n  /// Keeps information about an identifier in a nested-name-spec.\n  ///\n  struct NestedNameSpecInfo {\n    /// The type of the object, if we're parsing nested-name-specifier in\n    /// a member access expression.\n    ParsedType ObjectType;\n\n    /// The identifier preceding the '::'.\n    IdentifierInfo *Identifier;\n\n    /// The location of the identifier.\n    SourceLocation IdentifierLoc;\n\n    /// The location of the '::'.\n    SourceLocation CCLoc;\n\n    /// Creates info object for the most typical case.\n    NestedNameSpecInfo(IdentifierInfo *II, SourceLocation IdLoc,\n             SourceLocation ColonColonLoc, ParsedType ObjectType = ParsedType())\n      : ObjectType(ObjectType), Identifier(II), IdentifierLoc(IdLoc),\n        CCLoc(ColonColonLoc) {\n    }\n\n    NestedNameSpecInfo(IdentifierInfo *II, SourceLocation IdLoc,\n                       SourceLocation ColonColonLoc, QualType ObjectType)\n      : ObjectType(ParsedType::make(ObjectType)), Identifier(II),\n        IdentifierLoc(IdLoc), CCLoc(ColonColonLoc) {\n    }\n  };\n\n  bool isNonTypeNestedNameSpecifier(Scope *S, CXXScopeSpec &SS,\n                                    NestedNameSpecInfo &IdInfo);\n\n  bool BuildCXXNestedNameSpecifier(Scope *S,\n                                   NestedNameSpecInfo &IdInfo,\n                                   bool EnteringContext,\n                                   CXXScopeSpec &SS,\n                                   NamedDecl *ScopeLookupResult,\n                                   bool ErrorRecoveryLookup,\n                                   bool *IsCorrectedToColon = nullptr,\n                                   bool OnlyNamespace = false);\n\n  /// The parser has parsed a nested-name-specifier 'identifier::'.\n  ///\n  /// \\param S The scope in which this nested-name-specifier occurs.\n  ///\n  /// \\param IdInfo Parser information about an identifier in the\n  /// nested-name-spec.\n  ///\n  /// \\param EnteringContext Whether we're entering the context nominated by\n  /// this nested-name-specifier.\n  ///\n  /// \\param SS The nested-name-specifier, which is both an input\n  /// parameter (the nested-name-specifier before this type) and an\n  /// output parameter (containing the full nested-name-specifier,\n  /// including this new type).\n  ///\n  /// \\param ErrorRecoveryLookup If true, then this method is called to improve\n  /// error recovery. In this case do not emit error message.\n  ///\n  /// \\param IsCorrectedToColon If not null, suggestions to replace '::' -> ':'\n  /// are allowed.  The bool value pointed by this parameter is set to 'true'\n  /// if the identifier is treated as if it was followed by ':', not '::'.\n  ///\n  /// \\param OnlyNamespace If true, only considers namespaces in lookup.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool ActOnCXXNestedNameSpecifier(Scope *S,\n                                   NestedNameSpecInfo &IdInfo,\n                                   bool EnteringContext,\n                                   CXXScopeSpec &SS,\n                                   bool ErrorRecoveryLookup = false,\n                                   bool *IsCorrectedToColon = nullptr,\n                                   bool OnlyNamespace = false);\n\n  ExprResult ActOnDecltypeExpression(Expr *E);\n\n  bool ActOnCXXNestedNameSpecifierDecltype(CXXScopeSpec &SS,\n                                           const DeclSpec &DS,\n                                           SourceLocation ColonColonLoc);\n\n  bool IsInvalidUnlessNestedName(Scope *S, CXXScopeSpec &SS,\n                                 NestedNameSpecInfo &IdInfo,\n                                 bool EnteringContext);\n\n  /// The parser has parsed a nested-name-specifier\n  /// 'template[opt] template-name < template-args >::'.\n  ///\n  /// \\param S The scope in which this nested-name-specifier occurs.\n  ///\n  /// \\param SS The nested-name-specifier, which is both an input\n  /// parameter (the nested-name-specifier before this type) and an\n  /// output parameter (containing the full nested-name-specifier,\n  /// including this new type).\n  ///\n  /// \\param TemplateKWLoc the location of the 'template' keyword, if any.\n  /// \\param TemplateName the template name.\n  /// \\param TemplateNameLoc The location of the template name.\n  /// \\param LAngleLoc The location of the opening angle bracket  ('<').\n  /// \\param TemplateArgs The template arguments.\n  /// \\param RAngleLoc The location of the closing angle bracket  ('>').\n  /// \\param CCLoc The location of the '::'.\n  ///\n  /// \\param EnteringContext Whether we're entering the context of the\n  /// nested-name-specifier.\n  ///\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool ActOnCXXNestedNameSpecifier(Scope *S,\n                                   CXXScopeSpec &SS,\n                                   SourceLocation TemplateKWLoc,\n                                   TemplateTy TemplateName,\n                                   SourceLocation TemplateNameLoc,\n                                   SourceLocation LAngleLoc,\n                                   ASTTemplateArgsPtr TemplateArgs,\n                                   SourceLocation RAngleLoc,\n                                   SourceLocation CCLoc,\n                                   bool EnteringContext);\n\n  /// Given a C++ nested-name-specifier, produce an annotation value\n  /// that the parser can use later to reconstruct the given\n  /// nested-name-specifier.\n  ///\n  /// \\param SS A nested-name-specifier.\n  ///\n  /// \\returns A pointer containing all of the information in the\n  /// nested-name-specifier \\p SS.\n  void *SaveNestedNameSpecifierAnnotation(CXXScopeSpec &SS);\n\n  /// Given an annotation pointer for a nested-name-specifier, restore\n  /// the nested-name-specifier structure.\n  ///\n  /// \\param Annotation The annotation pointer, produced by\n  /// \\c SaveNestedNameSpecifierAnnotation().\n  ///\n  /// \\param AnnotationRange The source range corresponding to the annotation.\n  ///\n  /// \\param SS The nested-name-specifier that will be updated with the contents\n  /// of the annotation pointer.\n  void RestoreNestedNameSpecifierAnnotation(void *Annotation,\n                                            SourceRange AnnotationRange,\n                                            CXXScopeSpec &SS);\n\n  bool ShouldEnterDeclaratorScope(Scope *S, const CXXScopeSpec &SS);\n\n  /// ActOnCXXEnterDeclaratorScope - Called when a C++ scope specifier (global\n  /// scope or nested-name-specifier) is parsed, part of a declarator-id.\n  /// After this method is called, according to [C++ 3.4.3p3], names should be\n  /// looked up in the declarator-id's scope, until the declarator is parsed and\n  /// ActOnCXXExitDeclaratorScope is called.\n  /// The 'SS' should be a non-empty valid CXXScopeSpec.\n  bool ActOnCXXEnterDeclaratorScope(Scope *S, CXXScopeSpec &SS);\n\n  /// ActOnCXXExitDeclaratorScope - Called when a declarator that previously\n  /// invoked ActOnCXXEnterDeclaratorScope(), is finished. 'SS' is the same\n  /// CXXScopeSpec that was passed to ActOnCXXEnterDeclaratorScope as well.\n  /// Used to indicate that names should revert to being looked up in the\n  /// defining scope.\n  void ActOnCXXExitDeclaratorScope(Scope *S, const CXXScopeSpec &SS);\n\n  /// ActOnCXXEnterDeclInitializer - Invoked when we are about to parse an\n  /// initializer for the declaration 'Dcl'.\n  /// After this method is called, according to [C++ 3.4.1p13], if 'Dcl' is a\n  /// static data member of class X, names should be looked up in the scope of\n  /// class X.\n  void ActOnCXXEnterDeclInitializer(Scope *S, Decl *Dcl);\n\n  /// ActOnCXXExitDeclInitializer - Invoked after we are finished parsing an\n  /// initializer for the declaration 'Dcl'.\n  void ActOnCXXExitDeclInitializer(Scope *S, Decl *Dcl);\n\n  /// Create a new lambda closure type.\n  CXXRecordDecl *createLambdaClosureType(SourceRange IntroducerRange,\n                                         TypeSourceInfo *Info,\n                                         bool KnownDependent,\n                                         LambdaCaptureDefault CaptureDefault);\n\n  /// Start the definition of a lambda expression.\n  CXXMethodDecl *startLambdaDefinition(CXXRecordDecl *Class,\n                                       SourceRange IntroducerRange,\n                                       TypeSourceInfo *MethodType,\n                                       SourceLocation EndLoc,\n                                       ArrayRef<ParmVarDecl *> Params,\n                                       ConstexprSpecKind ConstexprKind,\n                                       Expr *TrailingRequiresClause);\n\n  /// Number lambda for linkage purposes if necessary.\n  void handleLambdaNumbering(\n      CXXRecordDecl *Class, CXXMethodDecl *Method,\n      Optional<std::tuple<bool, unsigned, unsigned, Decl *>> Mangling = None);\n\n  /// Endow the lambda scope info with the relevant properties.\n  void buildLambdaScope(sema::LambdaScopeInfo *LSI,\n                        CXXMethodDecl *CallOperator,\n                        SourceRange IntroducerRange,\n                        LambdaCaptureDefault CaptureDefault,\n                        SourceLocation CaptureDefaultLoc,\n                        bool ExplicitParams,\n                        bool ExplicitResultType,\n                        bool Mutable);\n\n  /// Perform initialization analysis of the init-capture and perform\n  /// any implicit conversions such as an lvalue-to-rvalue conversion if\n  /// not being used to initialize a reference.\n  ParsedType actOnLambdaInitCaptureInitialization(\n      SourceLocation Loc, bool ByRef, SourceLocation EllipsisLoc,\n      IdentifierInfo *Id, LambdaCaptureInitKind InitKind, Expr *&Init) {\n    return ParsedType::make(buildLambdaInitCaptureInitialization(\n        Loc, ByRef, EllipsisLoc, None, Id,\n        InitKind != LambdaCaptureInitKind::CopyInit, Init));\n  }\n  QualType buildLambdaInitCaptureInitialization(\n      SourceLocation Loc, bool ByRef, SourceLocation EllipsisLoc,\n      Optional<unsigned> NumExpansions, IdentifierInfo *Id, bool DirectInit,\n      Expr *&Init);\n\n  /// Create a dummy variable within the declcontext of the lambda's\n  ///  call operator, for name lookup purposes for a lambda init capture.\n  ///\n  ///  CodeGen handles emission of lambda captures, ignoring these dummy\n  ///  variables appropriately.\n  VarDecl *createLambdaInitCaptureVarDecl(SourceLocation Loc,\n                                          QualType InitCaptureType,\n                                          SourceLocation EllipsisLoc,\n                                          IdentifierInfo *Id,\n                                          unsigned InitStyle, Expr *Init);\n\n  /// Add an init-capture to a lambda scope.\n  void addInitCapture(sema::LambdaScopeInfo *LSI, VarDecl *Var);\n\n  /// Note that we have finished the explicit captures for the\n  /// given lambda.\n  void finishLambdaExplicitCaptures(sema::LambdaScopeInfo *LSI);\n\n  /// \\brief This is called after parsing the explicit template parameter list\n  /// on a lambda (if it exists) in C++2a.\n  void ActOnLambdaExplicitTemplateParameterList(SourceLocation LAngleLoc,\n                                                ArrayRef<NamedDecl *> TParams,\n                                                SourceLocation RAngleLoc,\n                                                ExprResult RequiresClause);\n\n  /// Introduce the lambda parameters into scope.\n  void addLambdaParameters(\n      ArrayRef<LambdaIntroducer::LambdaCapture> Captures,\n      CXXMethodDecl *CallOperator, Scope *CurScope);\n\n  /// Deduce a block or lambda's return type based on the return\n  /// statements present in the body.\n  void deduceClosureReturnType(sema::CapturingScopeInfo &CSI);\n\n  /// ActOnStartOfLambdaDefinition - This is called just before we start\n  /// parsing the body of a lambda; it analyzes the explicit captures and\n  /// arguments, and sets up various data-structures for the body of the\n  /// lambda.\n  void ActOnStartOfLambdaDefinition(LambdaIntroducer &Intro,\n                                    Declarator &ParamInfo, Scope *CurScope);\n\n  /// ActOnLambdaError - If there is an error parsing a lambda, this callback\n  /// is invoked to pop the information about the lambda.\n  void ActOnLambdaError(SourceLocation StartLoc, Scope *CurScope,\n                        bool IsInstantiation = false);\n\n  /// ActOnLambdaExpr - This is called when the body of a lambda expression\n  /// was successfully completed.\n  ExprResult ActOnLambdaExpr(SourceLocation StartLoc, Stmt *Body,\n                             Scope *CurScope);\n\n  /// Does copying/destroying the captured variable have side effects?\n  bool CaptureHasSideEffects(const sema::Capture &From);\n\n  /// Diagnose if an explicit lambda capture is unused. Returns true if a\n  /// diagnostic is emitted.\n  bool DiagnoseUnusedLambdaCapture(SourceRange CaptureRange,\n                                   const sema::Capture &From);\n\n  /// Build a FieldDecl suitable to hold the given capture.\n  FieldDecl *BuildCaptureField(RecordDecl *RD, const sema::Capture &Capture);\n\n  /// Initialize the given capture with a suitable expression.\n  ExprResult BuildCaptureInit(const sema::Capture &Capture,\n                              SourceLocation ImplicitCaptureLoc,\n                              bool IsOpenMPMapping = false);\n\n  /// Complete a lambda-expression having processed and attached the\n  /// lambda body.\n  ExprResult BuildLambdaExpr(SourceLocation StartLoc, SourceLocation EndLoc,\n                             sema::LambdaScopeInfo *LSI);\n\n  /// Get the return type to use for a lambda's conversion function(s) to\n  /// function pointer type, given the type of the call operator.\n  QualType\n  getLambdaConversionFunctionResultType(const FunctionProtoType *CallOpType,\n                                        CallingConv CC);\n\n  /// Define the \"body\" of the conversion from a lambda object to a\n  /// function pointer.\n  ///\n  /// This routine doesn't actually define a sensible body; rather, it fills\n  /// in the initialization expression needed to copy the lambda object into\n  /// the block, and IR generation actually generates the real body of the\n  /// block pointer conversion.\n  void DefineImplicitLambdaToFunctionPointerConversion(\n         SourceLocation CurrentLoc, CXXConversionDecl *Conv);\n\n  /// Define the \"body\" of the conversion from a lambda object to a\n  /// block pointer.\n  ///\n  /// This routine doesn't actually define a sensible body; rather, it fills\n  /// in the initialization expression needed to copy the lambda object into\n  /// the block, and IR generation actually generates the real body of the\n  /// block pointer conversion.\n  void DefineImplicitLambdaToBlockPointerConversion(SourceLocation CurrentLoc,\n                                                    CXXConversionDecl *Conv);\n\n  ExprResult BuildBlockForLambdaConversion(SourceLocation CurrentLocation,\n                                           SourceLocation ConvLocation,\n                                           CXXConversionDecl *Conv,\n                                           Expr *Src);\n\n  /// Check whether the given expression is a valid constraint expression.\n  /// A diagnostic is emitted if it is not, false is returned, and\n  /// PossibleNonPrimary will be set to true if the failure might be due to a\n  /// non-primary expression being used as an atomic constraint.\n  bool CheckConstraintExpression(const Expr *CE, Token NextToken = Token(),\n                                 bool *PossibleNonPrimary = nullptr,\n                                 bool IsTrailingRequiresClause = false);\n\nprivate:\n  /// Caches pairs of template-like decls whose associated constraints were\n  /// checked for subsumption and whether or not the first's constraints did in\n  /// fact subsume the second's.\n  llvm::DenseMap<std::pair<NamedDecl *, NamedDecl *>, bool> SubsumptionCache;\n  /// Caches the normalized associated constraints of declarations (concepts or\n  /// constrained declarations). If an error occurred while normalizing the\n  /// associated constraints of the template or concept, nullptr will be cached\n  /// here.\n  llvm::DenseMap<NamedDecl *, NormalizedConstraint *>\n      NormalizationCache;\n\n  llvm::ContextualFoldingSet<ConstraintSatisfaction, const ASTContext &>\n      SatisfactionCache;\n\npublic:\n  const NormalizedConstraint *\n  getNormalizedAssociatedConstraints(\n      NamedDecl *ConstrainedDecl, ArrayRef<const Expr *> AssociatedConstraints);\n\n  /// \\brief Check whether the given declaration's associated constraints are\n  /// at least as constrained than another declaration's according to the\n  /// partial ordering of constraints.\n  ///\n  /// \\param Result If no error occurred, receives the result of true if D1 is\n  /// at least constrained than D2, and false otherwise.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool IsAtLeastAsConstrained(NamedDecl *D1, ArrayRef<const Expr *> AC1,\n                              NamedDecl *D2, ArrayRef<const Expr *> AC2,\n                              bool &Result);\n\n  /// If D1 was not at least as constrained as D2, but would've been if a pair\n  /// of atomic constraints involved had been declared in a concept and not\n  /// repeated in two separate places in code.\n  /// \\returns true if such a diagnostic was emitted, false otherwise.\n  bool MaybeEmitAmbiguousAtomicConstraintsDiagnostic(NamedDecl *D1,\n      ArrayRef<const Expr *> AC1, NamedDecl *D2, ArrayRef<const Expr *> AC2);\n\n  /// \\brief Check whether the given list of constraint expressions are\n  /// satisfied (as if in a 'conjunction') given template arguments.\n  /// \\param Template the template-like entity that triggered the constraints\n  /// check (either a concept or a constrained entity).\n  /// \\param ConstraintExprs a list of constraint expressions, treated as if\n  /// they were 'AND'ed together.\n  /// \\param TemplateArgs the list of template arguments to substitute into the\n  /// constraint expression.\n  /// \\param TemplateIDRange The source range of the template id that\n  /// caused the constraints check.\n  /// \\param Satisfaction if true is returned, will contain details of the\n  /// satisfaction, with enough information to diagnose an unsatisfied\n  /// expression.\n  /// \\returns true if an error occurred and satisfaction could not be checked,\n  /// false otherwise.\n  bool CheckConstraintSatisfaction(\n      const NamedDecl *Template, ArrayRef<const Expr *> ConstraintExprs,\n      ArrayRef<TemplateArgument> TemplateArgs,\n      SourceRange TemplateIDRange, ConstraintSatisfaction &Satisfaction);\n\n  /// \\brief Check whether the given non-dependent constraint expression is\n  /// satisfied. Returns false and updates Satisfaction with the satisfaction\n  /// verdict if successful, emits a diagnostic and returns true if an error\n  /// occured and satisfaction could not be determined.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool CheckConstraintSatisfaction(const Expr *ConstraintExpr,\n                                   ConstraintSatisfaction &Satisfaction);\n\n  /// Check whether the given function decl's trailing requires clause is\n  /// satisfied, if any. Returns false and updates Satisfaction with the\n  /// satisfaction verdict if successful, emits a diagnostic and returns true if\n  /// an error occured and satisfaction could not be determined.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool CheckFunctionConstraints(const FunctionDecl *FD,\n                                ConstraintSatisfaction &Satisfaction,\n                                SourceLocation UsageLoc = SourceLocation());\n\n\n  /// \\brief Ensure that the given template arguments satisfy the constraints\n  /// associated with the given template, emitting a diagnostic if they do not.\n  ///\n  /// \\param Template The template to which the template arguments are being\n  /// provided.\n  ///\n  /// \\param TemplateArgs The converted, canonicalized template arguments.\n  ///\n  /// \\param TemplateIDRange The source range of the template id that\n  /// caused the constraints check.\n  ///\n  /// \\returns true if the constrains are not satisfied or could not be checked\n  /// for satisfaction, false if the constraints are satisfied.\n  bool EnsureTemplateArgumentListConstraints(TemplateDecl *Template,\n                                       ArrayRef<TemplateArgument> TemplateArgs,\n                                             SourceRange TemplateIDRange);\n\n  /// \\brief Emit diagnostics explaining why a constraint expression was deemed\n  /// unsatisfied.\n  /// \\param First whether this is the first time an unsatisfied constraint is\n  /// diagnosed for this error.\n  void\n  DiagnoseUnsatisfiedConstraint(const ConstraintSatisfaction &Satisfaction,\n                                bool First = true);\n\n  /// \\brief Emit diagnostics explaining why a constraint expression was deemed\n  /// unsatisfied.\n  void\n  DiagnoseUnsatisfiedConstraint(const ASTConstraintSatisfaction &Satisfaction,\n                                bool First = true);\n\n  // ParseObjCStringLiteral - Parse Objective-C string literals.\n  ExprResult ParseObjCStringLiteral(SourceLocation *AtLocs,\n                                    ArrayRef<Expr *> Strings);\n\n  ExprResult BuildObjCStringLiteral(SourceLocation AtLoc, StringLiteral *S);\n\n  /// BuildObjCNumericLiteral - builds an ObjCBoxedExpr AST node for the\n  /// numeric literal expression. Type of the expression will be \"NSNumber *\"\n  /// or \"id\" if NSNumber is unavailable.\n  ExprResult BuildObjCNumericLiteral(SourceLocation AtLoc, Expr *Number);\n  ExprResult ActOnObjCBoolLiteral(SourceLocation AtLoc, SourceLocation ValueLoc,\n                                  bool Value);\n  ExprResult BuildObjCArrayLiteral(SourceRange SR, MultiExprArg Elements);\n\n  /// BuildObjCBoxedExpr - builds an ObjCBoxedExpr AST node for the\n  /// '@' prefixed parenthesized expression. The type of the expression will\n  /// either be \"NSNumber *\", \"NSString *\" or \"NSValue *\" depending on the type\n  /// of ValueType, which is allowed to be a built-in numeric type, \"char *\",\n  /// \"const char *\" or C structure with attribute 'objc_boxable'.\n  ExprResult BuildObjCBoxedExpr(SourceRange SR, Expr *ValueExpr);\n\n  ExprResult BuildObjCSubscriptExpression(SourceLocation RB, Expr *BaseExpr,\n                                          Expr *IndexExpr,\n                                          ObjCMethodDecl *getterMethod,\n                                          ObjCMethodDecl *setterMethod);\n\n  ExprResult BuildObjCDictionaryLiteral(SourceRange SR,\n                               MutableArrayRef<ObjCDictionaryElement> Elements);\n\n  ExprResult BuildObjCEncodeExpression(SourceLocation AtLoc,\n                                  TypeSourceInfo *EncodedTypeInfo,\n                                  SourceLocation RParenLoc);\n  ExprResult BuildCXXMemberCallExpr(Expr *Exp, NamedDecl *FoundDecl,\n                                    CXXConversionDecl *Method,\n                                    bool HadMultipleCandidates);\n\n  ExprResult ParseObjCEncodeExpression(SourceLocation AtLoc,\n                                       SourceLocation EncodeLoc,\n                                       SourceLocation LParenLoc,\n                                       ParsedType Ty,\n                                       SourceLocation RParenLoc);\n\n  /// ParseObjCSelectorExpression - Build selector expression for \\@selector\n  ExprResult ParseObjCSelectorExpression(Selector Sel,\n                                         SourceLocation AtLoc,\n                                         SourceLocation SelLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation RParenLoc,\n                                         bool WarnMultipleSelectors);\n\n  /// ParseObjCProtocolExpression - Build protocol expression for \\@protocol\n  ExprResult ParseObjCProtocolExpression(IdentifierInfo * ProtocolName,\n                                         SourceLocation AtLoc,\n                                         SourceLocation ProtoLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation ProtoIdLoc,\n                                         SourceLocation RParenLoc);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Declarations\n  //\n  Decl *ActOnStartLinkageSpecification(Scope *S,\n                                       SourceLocation ExternLoc,\n                                       Expr *LangStr,\n                                       SourceLocation LBraceLoc);\n  Decl *ActOnFinishLinkageSpecification(Scope *S,\n                                        Decl *LinkageSpec,\n                                        SourceLocation RBraceLoc);\n\n\n  //===--------------------------------------------------------------------===//\n  // C++ Classes\n  //\n  CXXRecordDecl *getCurrentClass(Scope *S, const CXXScopeSpec *SS);\n  bool isCurrentClassName(const IdentifierInfo &II, Scope *S,\n                          const CXXScopeSpec *SS = nullptr);\n  bool isCurrentClassNameTypo(IdentifierInfo *&II, const CXXScopeSpec *SS);\n\n  bool ActOnAccessSpecifier(AccessSpecifier Access, SourceLocation ASLoc,\n                            SourceLocation ColonLoc,\n                            const ParsedAttributesView &Attrs);\n\n  NamedDecl *ActOnCXXMemberDeclarator(Scope *S, AccessSpecifier AS,\n                                 Declarator &D,\n                                 MultiTemplateParamsArg TemplateParameterLists,\n                                 Expr *BitfieldWidth, const VirtSpecifiers &VS,\n                                 InClassInitStyle InitStyle);\n\n  void ActOnStartCXXInClassMemberInitializer();\n  void ActOnFinishCXXInClassMemberInitializer(Decl *VarDecl,\n                                              SourceLocation EqualLoc,\n                                              Expr *Init);\n\n  MemInitResult ActOnMemInitializer(Decl *ConstructorD,\n                                    Scope *S,\n                                    CXXScopeSpec &SS,\n                                    IdentifierInfo *MemberOrBase,\n                                    ParsedType TemplateTypeTy,\n                                    const DeclSpec &DS,\n                                    SourceLocation IdLoc,\n                                    SourceLocation LParenLoc,\n                                    ArrayRef<Expr *> Args,\n                                    SourceLocation RParenLoc,\n                                    SourceLocation EllipsisLoc);\n\n  MemInitResult ActOnMemInitializer(Decl *ConstructorD,\n                                    Scope *S,\n                                    CXXScopeSpec &SS,\n                                    IdentifierInfo *MemberOrBase,\n                                    ParsedType TemplateTypeTy,\n                                    const DeclSpec &DS,\n                                    SourceLocation IdLoc,\n                                    Expr *InitList,\n                                    SourceLocation EllipsisLoc);\n\n  MemInitResult BuildMemInitializer(Decl *ConstructorD,\n                                    Scope *S,\n                                    CXXScopeSpec &SS,\n                                    IdentifierInfo *MemberOrBase,\n                                    ParsedType TemplateTypeTy,\n                                    const DeclSpec &DS,\n                                    SourceLocation IdLoc,\n                                    Expr *Init,\n                                    SourceLocation EllipsisLoc);\n\n  MemInitResult BuildMemberInitializer(ValueDecl *Member,\n                                       Expr *Init,\n                                       SourceLocation IdLoc);\n\n  MemInitResult BuildBaseInitializer(QualType BaseType,\n                                     TypeSourceInfo *BaseTInfo,\n                                     Expr *Init,\n                                     CXXRecordDecl *ClassDecl,\n                                     SourceLocation EllipsisLoc);\n\n  MemInitResult BuildDelegatingInitializer(TypeSourceInfo *TInfo,\n                                           Expr *Init,\n                                           CXXRecordDecl *ClassDecl);\n\n  bool SetDelegatingInitializer(CXXConstructorDecl *Constructor,\n                                CXXCtorInitializer *Initializer);\n\n  bool SetCtorInitializers(CXXConstructorDecl *Constructor, bool AnyErrors,\n                           ArrayRef<CXXCtorInitializer *> Initializers = None);\n\n  void SetIvarInitializers(ObjCImplementationDecl *ObjCImplementation);\n\n\n  /// MarkBaseAndMemberDestructorsReferenced - Given a record decl,\n  /// mark all the non-trivial destructors of its members and bases as\n  /// referenced.\n  void MarkBaseAndMemberDestructorsReferenced(SourceLocation Loc,\n                                              CXXRecordDecl *Record);\n\n  /// Mark destructors of virtual bases of this class referenced. In the Itanium\n  /// C++ ABI, this is done when emitting a destructor for any non-abstract\n  /// class. In the Microsoft C++ ABI, this is done any time a class's\n  /// destructor is referenced.\n  void MarkVirtualBaseDestructorsReferenced(\n      SourceLocation Location, CXXRecordDecl *ClassDecl,\n      llvm::SmallPtrSetImpl<const RecordType *> *DirectVirtualBases = nullptr);\n\n  /// Do semantic checks to allow the complete destructor variant to be emitted\n  /// when the destructor is defined in another translation unit. In the Itanium\n  /// C++ ABI, destructor variants are emitted together. In the MS C++ ABI, they\n  /// can be emitted in separate TUs. To emit the complete variant, run a subset\n  /// of the checks performed when emitting a regular destructor.\n  void CheckCompleteDestructorVariant(SourceLocation CurrentLocation,\n                                      CXXDestructorDecl *Dtor);\n\n  /// The list of classes whose vtables have been used within\n  /// this translation unit, and the source locations at which the\n  /// first use occurred.\n  typedef std::pair<CXXRecordDecl*, SourceLocation> VTableUse;\n\n  /// The list of vtables that are required but have not yet been\n  /// materialized.\n  SmallVector<VTableUse, 16> VTableUses;\n\n  /// The set of classes whose vtables have been used within\n  /// this translation unit, and a bit that will be true if the vtable is\n  /// required to be emitted (otherwise, it should be emitted only if needed\n  /// by code generation).\n  llvm::DenseMap<CXXRecordDecl *, bool> VTablesUsed;\n\n  /// Load any externally-stored vtable uses.\n  void LoadExternalVTableUses();\n\n  /// Note that the vtable for the given class was used at the\n  /// given location.\n  void MarkVTableUsed(SourceLocation Loc, CXXRecordDecl *Class,\n                      bool DefinitionRequired = false);\n\n  /// Mark the exception specifications of all virtual member functions\n  /// in the given class as needed.\n  void MarkVirtualMemberExceptionSpecsNeeded(SourceLocation Loc,\n                                             const CXXRecordDecl *RD);\n\n  /// MarkVirtualMembersReferenced - Will mark all members of the given\n  /// CXXRecordDecl referenced.\n  void MarkVirtualMembersReferenced(SourceLocation Loc, const CXXRecordDecl *RD,\n                                    bool ConstexprOnly = false);\n\n  /// Define all of the vtables that have been used in this\n  /// translation unit and reference any virtual members used by those\n  /// vtables.\n  ///\n  /// \\returns true if any work was done, false otherwise.\n  bool DefineUsedVTables();\n\n  void AddImplicitlyDeclaredMembersToClass(CXXRecordDecl *ClassDecl);\n\n  void ActOnMemInitializers(Decl *ConstructorDecl,\n                            SourceLocation ColonLoc,\n                            ArrayRef<CXXCtorInitializer*> MemInits,\n                            bool AnyErrors);\n\n  /// Check class-level dllimport/dllexport attribute. The caller must\n  /// ensure that referenceDLLExportedClassMethods is called some point later\n  /// when all outer classes of Class are complete.\n  void checkClassLevelDLLAttribute(CXXRecordDecl *Class);\n  void checkClassLevelCodeSegAttribute(CXXRecordDecl *Class);\n\n  void referenceDLLExportedClassMethods();\n\n  void propagateDLLAttrToBaseClassTemplate(\n      CXXRecordDecl *Class, Attr *ClassAttr,\n      ClassTemplateSpecializationDecl *BaseTemplateSpec,\n      SourceLocation BaseLoc);\n\n  /// Add gsl::Pointer attribute to std::container::iterator\n  /// \\param ND The declaration that introduces the name\n  /// std::container::iterator. \\param UnderlyingRecord The record named by ND.\n  void inferGslPointerAttribute(NamedDecl *ND, CXXRecordDecl *UnderlyingRecord);\n\n  /// Add [[gsl::Owner]] and [[gsl::Pointer]] attributes for std:: types.\n  void inferGslOwnerPointerAttribute(CXXRecordDecl *Record);\n\n  /// Add [[gsl::Pointer]] attributes for std:: types.\n  void inferGslPointerAttribute(TypedefNameDecl *TD);\n\n  void CheckCompletedCXXClass(Scope *S, CXXRecordDecl *Record);\n\n  /// Check that the C++ class annoated with \"trivial_abi\" satisfies all the\n  /// conditions that are needed for the attribute to have an effect.\n  void checkIllFormedTrivialABIStruct(CXXRecordDecl &RD);\n\n  void ActOnFinishCXXMemberSpecification(Scope *S, SourceLocation RLoc,\n                                         Decl *TagDecl, SourceLocation LBrac,\n                                         SourceLocation RBrac,\n                                         const ParsedAttributesView &AttrList);\n  void ActOnFinishCXXMemberDecls();\n  void ActOnFinishCXXNonNestedClass();\n\n  void ActOnReenterCXXMethodParameter(Scope *S, ParmVarDecl *Param);\n  unsigned ActOnReenterTemplateScope(Decl *Template,\n                                     llvm::function_ref<Scope *()> EnterScope);\n  void ActOnStartDelayedMemberDeclarations(Scope *S, Decl *Record);\n  void ActOnStartDelayedCXXMethodDeclaration(Scope *S, Decl *Method);\n  void ActOnDelayedCXXMethodParameter(Scope *S, Decl *Param);\n  void ActOnFinishDelayedMemberDeclarations(Scope *S, Decl *Record);\n  void ActOnFinishDelayedCXXMethodDeclaration(Scope *S, Decl *Method);\n  void ActOnFinishDelayedMemberInitializers(Decl *Record);\n  void MarkAsLateParsedTemplate(FunctionDecl *FD, Decl *FnD,\n                                CachedTokens &Toks);\n  void UnmarkAsLateParsedTemplate(FunctionDecl *FD);\n  bool IsInsideALocalClassWithinATemplateFunction();\n\n  Decl *ActOnStaticAssertDeclaration(SourceLocation StaticAssertLoc,\n                                     Expr *AssertExpr,\n                                     Expr *AssertMessageExpr,\n                                     SourceLocation RParenLoc);\n  Decl *BuildStaticAssertDeclaration(SourceLocation StaticAssertLoc,\n                                     Expr *AssertExpr,\n                                     StringLiteral *AssertMessageExpr,\n                                     SourceLocation RParenLoc,\n                                     bool Failed);\n\n  FriendDecl *CheckFriendTypeDecl(SourceLocation LocStart,\n                                  SourceLocation FriendLoc,\n                                  TypeSourceInfo *TSInfo);\n  Decl *ActOnFriendTypeDecl(Scope *S, const DeclSpec &DS,\n                            MultiTemplateParamsArg TemplateParams);\n  NamedDecl *ActOnFriendFunctionDecl(Scope *S, Declarator &D,\n                                     MultiTemplateParamsArg TemplateParams);\n\n  QualType CheckConstructorDeclarator(Declarator &D, QualType R,\n                                      StorageClass& SC);\n  void CheckConstructor(CXXConstructorDecl *Constructor);\n  QualType CheckDestructorDeclarator(Declarator &D, QualType R,\n                                     StorageClass& SC);\n  bool CheckDestructor(CXXDestructorDecl *Destructor);\n  void CheckConversionDeclarator(Declarator &D, QualType &R,\n                                 StorageClass& SC);\n  Decl *ActOnConversionDeclarator(CXXConversionDecl *Conversion);\n  void CheckDeductionGuideDeclarator(Declarator &D, QualType &R,\n                                     StorageClass &SC);\n  void CheckDeductionGuideTemplate(FunctionTemplateDecl *TD);\n\n  void CheckExplicitlyDefaultedFunction(Scope *S, FunctionDecl *MD);\n\n  bool CheckExplicitlyDefaultedSpecialMember(CXXMethodDecl *MD,\n                                             CXXSpecialMember CSM);\n  void CheckDelayedMemberExceptionSpecs();\n\n  bool CheckExplicitlyDefaultedComparison(Scope *S, FunctionDecl *MD,\n                                          DefaultedComparisonKind DCK);\n  void DeclareImplicitEqualityComparison(CXXRecordDecl *RD,\n                                         FunctionDecl *Spaceship);\n  void DefineDefaultedComparison(SourceLocation Loc, FunctionDecl *FD,\n                                 DefaultedComparisonKind DCK);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Derived Classes\n  //\n\n  /// ActOnBaseSpecifier - Parsed a base specifier\n  CXXBaseSpecifier *CheckBaseSpecifier(CXXRecordDecl *Class,\n                                       SourceRange SpecifierRange,\n                                       bool Virtual, AccessSpecifier Access,\n                                       TypeSourceInfo *TInfo,\n                                       SourceLocation EllipsisLoc);\n\n  BaseResult ActOnBaseSpecifier(Decl *classdecl,\n                                SourceRange SpecifierRange,\n                                ParsedAttributes &Attrs,\n                                bool Virtual, AccessSpecifier Access,\n                                ParsedType basetype,\n                                SourceLocation BaseLoc,\n                                SourceLocation EllipsisLoc);\n\n  bool AttachBaseSpecifiers(CXXRecordDecl *Class,\n                            MutableArrayRef<CXXBaseSpecifier *> Bases);\n  void ActOnBaseSpecifiers(Decl *ClassDecl,\n                           MutableArrayRef<CXXBaseSpecifier *> Bases);\n\n  bool IsDerivedFrom(SourceLocation Loc, QualType Derived, QualType Base);\n  bool IsDerivedFrom(SourceLocation Loc, QualType Derived, QualType Base,\n                     CXXBasePaths &Paths);\n\n  // FIXME: I don't like this name.\n  void BuildBasePathArray(const CXXBasePaths &Paths, CXXCastPath &BasePath);\n\n  bool CheckDerivedToBaseConversion(QualType Derived, QualType Base,\n                                    SourceLocation Loc, SourceRange Range,\n                                    CXXCastPath *BasePath = nullptr,\n                                    bool IgnoreAccess = false);\n  bool CheckDerivedToBaseConversion(QualType Derived, QualType Base,\n                                    unsigned InaccessibleBaseID,\n                                    unsigned AmbiguousBaseConvID,\n                                    SourceLocation Loc, SourceRange Range,\n                                    DeclarationName Name,\n                                    CXXCastPath *BasePath,\n                                    bool IgnoreAccess = false);\n\n  std::string getAmbiguousPathsDisplayString(CXXBasePaths &Paths);\n\n  bool CheckOverridingFunctionAttributes(const CXXMethodDecl *New,\n                                         const CXXMethodDecl *Old);\n\n  /// CheckOverridingFunctionReturnType - Checks whether the return types are\n  /// covariant, according to C++ [class.virtual]p5.\n  bool CheckOverridingFunctionReturnType(const CXXMethodDecl *New,\n                                         const CXXMethodDecl *Old);\n\n  /// CheckOverridingFunctionExceptionSpec - Checks whether the exception\n  /// spec is a subset of base spec.\n  bool CheckOverridingFunctionExceptionSpec(const CXXMethodDecl *New,\n                                            const CXXMethodDecl *Old);\n\n  bool CheckPureMethod(CXXMethodDecl *Method, SourceRange InitRange);\n\n  /// CheckOverrideControl - Check C++11 override control semantics.\n  void CheckOverrideControl(NamedDecl *D);\n\n  /// DiagnoseAbsenceOfOverrideControl - Diagnose if 'override' keyword was\n  /// not used in the declaration of an overriding method.\n  void DiagnoseAbsenceOfOverrideControl(NamedDecl *D, bool Inconsistent);\n\n  /// CheckForFunctionMarkedFinal - Checks whether a virtual member function\n  /// overrides a virtual member function marked 'final', according to\n  /// C++11 [class.virtual]p4.\n  bool CheckIfOverriddenFunctionIsMarkedFinal(const CXXMethodDecl *New,\n                                              const CXXMethodDecl *Old);\n\n\n  //===--------------------------------------------------------------------===//\n  // C++ Access Control\n  //\n\n  enum AccessResult {\n    AR_accessible,\n    AR_inaccessible,\n    AR_dependent,\n    AR_delayed\n  };\n\n  bool SetMemberAccessSpecifier(NamedDecl *MemberDecl,\n                                NamedDecl *PrevMemberDecl,\n                                AccessSpecifier LexicalAS);\n\n  AccessResult CheckUnresolvedMemberAccess(UnresolvedMemberExpr *E,\n                                           DeclAccessPair FoundDecl);\n  AccessResult CheckUnresolvedLookupAccess(UnresolvedLookupExpr *E,\n                                           DeclAccessPair FoundDecl);\n  AccessResult CheckAllocationAccess(SourceLocation OperatorLoc,\n                                     SourceRange PlacementRange,\n                                     CXXRecordDecl *NamingClass,\n                                     DeclAccessPair FoundDecl,\n                                     bool Diagnose = true);\n  AccessResult CheckConstructorAccess(SourceLocation Loc,\n                                      CXXConstructorDecl *D,\n                                      DeclAccessPair FoundDecl,\n                                      const InitializedEntity &Entity,\n                                      bool IsCopyBindingRefToTemp = false);\n  AccessResult CheckConstructorAccess(SourceLocation Loc,\n                                      CXXConstructorDecl *D,\n                                      DeclAccessPair FoundDecl,\n                                      const InitializedEntity &Entity,\n                                      const PartialDiagnostic &PDiag);\n  AccessResult CheckDestructorAccess(SourceLocation Loc,\n                                     CXXDestructorDecl *Dtor,\n                                     const PartialDiagnostic &PDiag,\n                                     QualType objectType = QualType());\n  AccessResult CheckFriendAccess(NamedDecl *D);\n  AccessResult CheckMemberAccess(SourceLocation UseLoc,\n                                 CXXRecordDecl *NamingClass,\n                                 DeclAccessPair Found);\n  AccessResult\n  CheckStructuredBindingMemberAccess(SourceLocation UseLoc,\n                                     CXXRecordDecl *DecomposedClass,\n                                     DeclAccessPair Field);\n  AccessResult CheckMemberOperatorAccess(SourceLocation Loc,\n                                         Expr *ObjectExpr,\n                                         Expr *ArgExpr,\n                                         DeclAccessPair FoundDecl);\n  AccessResult CheckAddressOfMemberAccess(Expr *OvlExpr,\n                                          DeclAccessPair FoundDecl);\n  AccessResult CheckBaseClassAccess(SourceLocation AccessLoc,\n                                    QualType Base, QualType Derived,\n                                    const CXXBasePath &Path,\n                                    unsigned DiagID,\n                                    bool ForceCheck = false,\n                                    bool ForceUnprivileged = false);\n  void CheckLookupAccess(const LookupResult &R);\n  bool IsSimplyAccessible(NamedDecl *Decl, CXXRecordDecl *NamingClass,\n                          QualType BaseType);\n  bool isMemberAccessibleForDeletion(CXXRecordDecl *NamingClass,\n                                     DeclAccessPair Found, QualType ObjectType,\n                                     SourceLocation Loc,\n                                     const PartialDiagnostic &Diag);\n  bool isMemberAccessibleForDeletion(CXXRecordDecl *NamingClass,\n                                     DeclAccessPair Found,\n                                     QualType ObjectType) {\n    return isMemberAccessibleForDeletion(NamingClass, Found, ObjectType,\n                                         SourceLocation(), PDiag());\n  }\n\n  void HandleDependentAccessCheck(const DependentDiagnostic &DD,\n                         const MultiLevelTemplateArgumentList &TemplateArgs);\n  void PerformDependentDiagnostics(const DeclContext *Pattern,\n                        const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  void HandleDelayedAccessCheck(sema::DelayedDiagnostic &DD, Decl *Ctx);\n\n  /// When true, access checking violations are treated as SFINAE\n  /// failures rather than hard errors.\n  bool AccessCheckingSFINAE;\n\n  enum AbstractDiagSelID {\n    AbstractNone = -1,\n    AbstractReturnType,\n    AbstractParamType,\n    AbstractVariableType,\n    AbstractFieldType,\n    AbstractIvarType,\n    AbstractSynthesizedIvarType,\n    AbstractArrayType\n  };\n\n  bool isAbstractType(SourceLocation Loc, QualType T);\n  bool RequireNonAbstractType(SourceLocation Loc, QualType T,\n                              TypeDiagnoser &Diagnoser);\n  template <typename... Ts>\n  bool RequireNonAbstractType(SourceLocation Loc, QualType T, unsigned DiagID,\n                              const Ts &...Args) {\n    BoundTypeDiagnoser<Ts...> Diagnoser(DiagID, Args...);\n    return RequireNonAbstractType(Loc, T, Diagnoser);\n  }\n\n  void DiagnoseAbstractType(const CXXRecordDecl *RD);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Overloaded Operators [C++ 13.5]\n  //\n\n  bool CheckOverloadedOperatorDeclaration(FunctionDecl *FnDecl);\n\n  bool CheckLiteralOperatorDeclaration(FunctionDecl *FnDecl);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Templates [C++ 14]\n  //\n  void FilterAcceptableTemplateNames(LookupResult &R,\n                                     bool AllowFunctionTemplates = true,\n                                     bool AllowDependent = true);\n  bool hasAnyAcceptableTemplateNames(LookupResult &R,\n                                     bool AllowFunctionTemplates = true,\n                                     bool AllowDependent = true,\n                                     bool AllowNonTemplateFunctions = false);\n  /// Try to interpret the lookup result D as a template-name.\n  ///\n  /// \\param D A declaration found by name lookup.\n  /// \\param AllowFunctionTemplates Whether function templates should be\n  ///        considered valid results.\n  /// \\param AllowDependent Whether unresolved using declarations (that might\n  ///        name templates) should be considered valid results.\n  static NamedDecl *getAsTemplateNameDecl(NamedDecl *D,\n                                          bool AllowFunctionTemplates = true,\n                                          bool AllowDependent = true);\n\n  enum TemplateNameIsRequiredTag { TemplateNameIsRequired };\n  /// Whether and why a template name is required in this lookup.\n  class RequiredTemplateKind {\n  public:\n    /// Template name is required if TemplateKWLoc is valid.\n    RequiredTemplateKind(SourceLocation TemplateKWLoc = SourceLocation())\n        : TemplateKW(TemplateKWLoc) {}\n    /// Template name is unconditionally required.\n    RequiredTemplateKind(TemplateNameIsRequiredTag) : TemplateKW() {}\n\n    SourceLocation getTemplateKeywordLoc() const {\n      return TemplateKW.getValueOr(SourceLocation());\n    }\n    bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n    bool isRequired() const { return TemplateKW != SourceLocation(); }\n    explicit operator bool() const { return isRequired(); }\n\n  private:\n    llvm::Optional<SourceLocation> TemplateKW;\n  };\n\n  enum class AssumedTemplateKind {\n    /// This is not assumed to be a template name.\n    None,\n    /// This is assumed to be a template name because lookup found nothing.\n    FoundNothing,\n    /// This is assumed to be a template name because lookup found one or more\n    /// functions (but no function templates).\n    FoundFunctions,\n  };\n  bool LookupTemplateName(\n      LookupResult &R, Scope *S, CXXScopeSpec &SS, QualType ObjectType,\n      bool EnteringContext, bool &MemberOfUnknownSpecialization,\n      RequiredTemplateKind RequiredTemplate = SourceLocation(),\n      AssumedTemplateKind *ATK = nullptr, bool AllowTypoCorrection = true);\n\n  TemplateNameKind isTemplateName(Scope *S,\n                                  CXXScopeSpec &SS,\n                                  bool hasTemplateKeyword,\n                                  const UnqualifiedId &Name,\n                                  ParsedType ObjectType,\n                                  bool EnteringContext,\n                                  TemplateTy &Template,\n                                  bool &MemberOfUnknownSpecialization,\n                                  bool Disambiguation = false);\n\n  /// Try to resolve an undeclared template name as a type template.\n  ///\n  /// Sets II to the identifier corresponding to the template name, and updates\n  /// Name to a corresponding (typo-corrected) type template name and TNK to\n  /// the corresponding kind, if possible.\n  void ActOnUndeclaredTypeTemplateName(Scope *S, TemplateTy &Name,\n                                       TemplateNameKind &TNK,\n                                       SourceLocation NameLoc,\n                                       IdentifierInfo *&II);\n\n  bool resolveAssumedTemplateNameAsType(Scope *S, TemplateName &Name,\n                                        SourceLocation NameLoc,\n                                        bool Diagnose = true);\n\n  /// Determine whether a particular identifier might be the name in a C++1z\n  /// deduction-guide declaration.\n  bool isDeductionGuideName(Scope *S, const IdentifierInfo &Name,\n                            SourceLocation NameLoc,\n                            ParsedTemplateTy *Template = nullptr);\n\n  bool DiagnoseUnknownTemplateName(const IdentifierInfo &II,\n                                   SourceLocation IILoc,\n                                   Scope *S,\n                                   const CXXScopeSpec *SS,\n                                   TemplateTy &SuggestedTemplate,\n                                   TemplateNameKind &SuggestedKind);\n\n  bool DiagnoseUninstantiableTemplate(SourceLocation PointOfInstantiation,\n                                      NamedDecl *Instantiation,\n                                      bool InstantiatedFromMember,\n                                      const NamedDecl *Pattern,\n                                      const NamedDecl *PatternDef,\n                                      TemplateSpecializationKind TSK,\n                                      bool Complain = true);\n\n  void DiagnoseTemplateParameterShadow(SourceLocation Loc, Decl *PrevDecl);\n  TemplateDecl *AdjustDeclIfTemplate(Decl *&Decl);\n\n  NamedDecl *ActOnTypeParameter(Scope *S, bool Typename,\n                                SourceLocation EllipsisLoc,\n                                SourceLocation KeyLoc,\n                                IdentifierInfo *ParamName,\n                                SourceLocation ParamNameLoc,\n                                unsigned Depth, unsigned Position,\n                                SourceLocation EqualLoc,\n                                ParsedType DefaultArg, bool HasTypeConstraint);\n\n  bool ActOnTypeConstraint(const CXXScopeSpec &SS,\n                           TemplateIdAnnotation *TypeConstraint,\n                           TemplateTypeParmDecl *ConstrainedParameter,\n                           SourceLocation EllipsisLoc);\n\n  bool AttachTypeConstraint(NestedNameSpecifierLoc NS,\n                            DeclarationNameInfo NameInfo,\n                            ConceptDecl *NamedConcept,\n                            const TemplateArgumentListInfo *TemplateArgs,\n                            TemplateTypeParmDecl *ConstrainedParameter,\n                            SourceLocation EllipsisLoc);\n\n  bool AttachTypeConstraint(AutoTypeLoc TL,\n                            NonTypeTemplateParmDecl *ConstrainedParameter,\n                            SourceLocation EllipsisLoc);\n\n  bool RequireStructuralType(QualType T, SourceLocation Loc);\n\n  QualType CheckNonTypeTemplateParameterType(TypeSourceInfo *&TSI,\n                                             SourceLocation Loc);\n  QualType CheckNonTypeTemplateParameterType(QualType T, SourceLocation Loc);\n\n  NamedDecl *ActOnNonTypeTemplateParameter(Scope *S, Declarator &D,\n                                      unsigned Depth,\n                                      unsigned Position,\n                                      SourceLocation EqualLoc,\n                                      Expr *DefaultArg);\n  NamedDecl *ActOnTemplateTemplateParameter(Scope *S,\n                                       SourceLocation TmpLoc,\n                                       TemplateParameterList *Params,\n                                       SourceLocation EllipsisLoc,\n                                       IdentifierInfo *ParamName,\n                                       SourceLocation ParamNameLoc,\n                                       unsigned Depth,\n                                       unsigned Position,\n                                       SourceLocation EqualLoc,\n                                       ParsedTemplateArgument DefaultArg);\n\n  TemplateParameterList *\n  ActOnTemplateParameterList(unsigned Depth,\n                             SourceLocation ExportLoc,\n                             SourceLocation TemplateLoc,\n                             SourceLocation LAngleLoc,\n                             ArrayRef<NamedDecl *> Params,\n                             SourceLocation RAngleLoc,\n                             Expr *RequiresClause);\n\n  /// The context in which we are checking a template parameter list.\n  enum TemplateParamListContext {\n    TPC_ClassTemplate,\n    TPC_VarTemplate,\n    TPC_FunctionTemplate,\n    TPC_ClassTemplateMember,\n    TPC_FriendClassTemplate,\n    TPC_FriendFunctionTemplate,\n    TPC_FriendFunctionTemplateDefinition,\n    TPC_TypeAliasTemplate\n  };\n\n  bool CheckTemplateParameterList(TemplateParameterList *NewParams,\n                                  TemplateParameterList *OldParams,\n                                  TemplateParamListContext TPC,\n                                  SkipBodyInfo *SkipBody = nullptr);\n  TemplateParameterList *MatchTemplateParametersToScopeSpecifier(\n      SourceLocation DeclStartLoc, SourceLocation DeclLoc,\n      const CXXScopeSpec &SS, TemplateIdAnnotation *TemplateId,\n      ArrayRef<TemplateParameterList *> ParamLists,\n      bool IsFriend, bool &IsMemberSpecialization, bool &Invalid,\n      bool SuppressDiagnostic = false);\n\n  DeclResult CheckClassTemplate(\n      Scope *S, unsigned TagSpec, TagUseKind TUK, SourceLocation KWLoc,\n      CXXScopeSpec &SS, IdentifierInfo *Name, SourceLocation NameLoc,\n      const ParsedAttributesView &Attr, TemplateParameterList *TemplateParams,\n      AccessSpecifier AS, SourceLocation ModulePrivateLoc,\n      SourceLocation FriendLoc, unsigned NumOuterTemplateParamLists,\n      TemplateParameterList **OuterTemplateParamLists,\n      SkipBodyInfo *SkipBody = nullptr);\n\n  TemplateArgumentLoc getTrivialTemplateArgumentLoc(const TemplateArgument &Arg,\n                                                    QualType NTTPType,\n                                                    SourceLocation Loc);\n\n  /// Get a template argument mapping the given template parameter to itself,\n  /// e.g. for X in \\c template<int X>, this would return an expression template\n  /// argument referencing X.\n  TemplateArgumentLoc getIdentityTemplateArgumentLoc(NamedDecl *Param,\n                                                     SourceLocation Location);\n\n  void translateTemplateArguments(const ASTTemplateArgsPtr &In,\n                                  TemplateArgumentListInfo &Out);\n\n  ParsedTemplateArgument ActOnTemplateTypeArgument(TypeResult ParsedType);\n\n  void NoteAllFoundTemplates(TemplateName Name);\n\n  QualType CheckTemplateIdType(TemplateName Template,\n                               SourceLocation TemplateLoc,\n                              TemplateArgumentListInfo &TemplateArgs);\n\n  TypeResult\n  ActOnTemplateIdType(Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,\n                      TemplateTy Template, IdentifierInfo *TemplateII,\n                      SourceLocation TemplateIILoc, SourceLocation LAngleLoc,\n                      ASTTemplateArgsPtr TemplateArgs, SourceLocation RAngleLoc,\n                      bool IsCtorOrDtorName = false, bool IsClassName = false);\n\n  /// Parsed an elaborated-type-specifier that refers to a template-id,\n  /// such as \\c class T::template apply<U>.\n  TypeResult ActOnTagTemplateIdType(TagUseKind TUK,\n                                    TypeSpecifierType TagSpec,\n                                    SourceLocation TagLoc,\n                                    CXXScopeSpec &SS,\n                                    SourceLocation TemplateKWLoc,\n                                    TemplateTy TemplateD,\n                                    SourceLocation TemplateLoc,\n                                    SourceLocation LAngleLoc,\n                                    ASTTemplateArgsPtr TemplateArgsIn,\n                                    SourceLocation RAngleLoc);\n\n  DeclResult ActOnVarTemplateSpecialization(\n      Scope *S, Declarator &D, TypeSourceInfo *DI,\n      SourceLocation TemplateKWLoc, TemplateParameterList *TemplateParams,\n      StorageClass SC, bool IsPartialSpecialization);\n\n  /// Get the specialization of the given variable template corresponding to\n  /// the specified argument list, or a null-but-valid result if the arguments\n  /// are dependent.\n  DeclResult CheckVarTemplateId(VarTemplateDecl *Template,\n                                SourceLocation TemplateLoc,\n                                SourceLocation TemplateNameLoc,\n                                const TemplateArgumentListInfo &TemplateArgs);\n\n  /// Form a reference to the specialization of the given variable template\n  /// corresponding to the specified argument list, or a null-but-valid result\n  /// if the arguments are dependent.\n  ExprResult CheckVarTemplateId(const CXXScopeSpec &SS,\n                                const DeclarationNameInfo &NameInfo,\n                                VarTemplateDecl *Template,\n                                SourceLocation TemplateLoc,\n                                const TemplateArgumentListInfo *TemplateArgs);\n\n  ExprResult\n  CheckConceptTemplateId(const CXXScopeSpec &SS,\n                         SourceLocation TemplateKWLoc,\n                         const DeclarationNameInfo &ConceptNameInfo,\n                         NamedDecl *FoundDecl, ConceptDecl *NamedConcept,\n                         const TemplateArgumentListInfo *TemplateArgs);\n\n  void diagnoseMissingTemplateArguments(TemplateName Name, SourceLocation Loc);\n\n  ExprResult BuildTemplateIdExpr(const CXXScopeSpec &SS,\n                                 SourceLocation TemplateKWLoc,\n                                 LookupResult &R,\n                                 bool RequiresADL,\n                               const TemplateArgumentListInfo *TemplateArgs);\n\n  ExprResult BuildQualifiedTemplateIdExpr(CXXScopeSpec &SS,\n                                          SourceLocation TemplateKWLoc,\n                               const DeclarationNameInfo &NameInfo,\n                               const TemplateArgumentListInfo *TemplateArgs);\n\n  TemplateNameKind ActOnTemplateName(\n      Scope *S, CXXScopeSpec &SS, SourceLocation TemplateKWLoc,\n      const UnqualifiedId &Name, ParsedType ObjectType, bool EnteringContext,\n      TemplateTy &Template, bool AllowInjectedClassName = false);\n\n  DeclResult ActOnClassTemplateSpecialization(\n      Scope *S, unsigned TagSpec, TagUseKind TUK, SourceLocation KWLoc,\n      SourceLocation ModulePrivateLoc, CXXScopeSpec &SS,\n      TemplateIdAnnotation &TemplateId, const ParsedAttributesView &Attr,\n      MultiTemplateParamsArg TemplateParameterLists,\n      SkipBodyInfo *SkipBody = nullptr);\n\n  bool CheckTemplatePartialSpecializationArgs(SourceLocation Loc,\n                                              TemplateDecl *PrimaryTemplate,\n                                              unsigned NumExplicitArgs,\n                                              ArrayRef<TemplateArgument> Args);\n  void CheckTemplatePartialSpecialization(\n      ClassTemplatePartialSpecializationDecl *Partial);\n  void CheckTemplatePartialSpecialization(\n      VarTemplatePartialSpecializationDecl *Partial);\n\n  Decl *ActOnTemplateDeclarator(Scope *S,\n                                MultiTemplateParamsArg TemplateParameterLists,\n                                Declarator &D);\n\n  bool\n  CheckSpecializationInstantiationRedecl(SourceLocation NewLoc,\n                                         TemplateSpecializationKind NewTSK,\n                                         NamedDecl *PrevDecl,\n                                         TemplateSpecializationKind PrevTSK,\n                                         SourceLocation PrevPtOfInstantiation,\n                                         bool &SuppressNew);\n\n  bool CheckDependentFunctionTemplateSpecialization(FunctionDecl *FD,\n                    const TemplateArgumentListInfo &ExplicitTemplateArgs,\n                                                    LookupResult &Previous);\n\n  bool CheckFunctionTemplateSpecialization(\n      FunctionDecl *FD, TemplateArgumentListInfo *ExplicitTemplateArgs,\n      LookupResult &Previous, bool QualifiedFriend = false);\n  bool CheckMemberSpecialization(NamedDecl *Member, LookupResult &Previous);\n  void CompleteMemberSpecialization(NamedDecl *Member, LookupResult &Previous);\n\n  DeclResult ActOnExplicitInstantiation(\n      Scope *S, SourceLocation ExternLoc, SourceLocation TemplateLoc,\n      unsigned TagSpec, SourceLocation KWLoc, const CXXScopeSpec &SS,\n      TemplateTy Template, SourceLocation TemplateNameLoc,\n      SourceLocation LAngleLoc, ASTTemplateArgsPtr TemplateArgs,\n      SourceLocation RAngleLoc, const ParsedAttributesView &Attr);\n\n  DeclResult ActOnExplicitInstantiation(Scope *S, SourceLocation ExternLoc,\n                                        SourceLocation TemplateLoc,\n                                        unsigned TagSpec, SourceLocation KWLoc,\n                                        CXXScopeSpec &SS, IdentifierInfo *Name,\n                                        SourceLocation NameLoc,\n                                        const ParsedAttributesView &Attr);\n\n  DeclResult ActOnExplicitInstantiation(Scope *S,\n                                        SourceLocation ExternLoc,\n                                        SourceLocation TemplateLoc,\n                                        Declarator &D);\n\n  TemplateArgumentLoc\n  SubstDefaultTemplateArgumentIfAvailable(TemplateDecl *Template,\n                                          SourceLocation TemplateLoc,\n                                          SourceLocation RAngleLoc,\n                                          Decl *Param,\n                                          SmallVectorImpl<TemplateArgument>\n                                            &Converted,\n                                          bool &HasDefaultArg);\n\n  /// Specifies the context in which a particular template\n  /// argument is being checked.\n  enum CheckTemplateArgumentKind {\n    /// The template argument was specified in the code or was\n    /// instantiated with some deduced template arguments.\n    CTAK_Specified,\n\n    /// The template argument was deduced via template argument\n    /// deduction.\n    CTAK_Deduced,\n\n    /// The template argument was deduced from an array bound\n    /// via template argument deduction.\n    CTAK_DeducedFromArrayBound\n  };\n\n  bool CheckTemplateArgument(NamedDecl *Param,\n                             TemplateArgumentLoc &Arg,\n                             NamedDecl *Template,\n                             SourceLocation TemplateLoc,\n                             SourceLocation RAngleLoc,\n                             unsigned ArgumentPackIndex,\n                           SmallVectorImpl<TemplateArgument> &Converted,\n                             CheckTemplateArgumentKind CTAK = CTAK_Specified);\n\n  /// Check that the given template arguments can be be provided to\n  /// the given template, converting the arguments along the way.\n  ///\n  /// \\param Template The template to which the template arguments are being\n  /// provided.\n  ///\n  /// \\param TemplateLoc The location of the template name in the source.\n  ///\n  /// \\param TemplateArgs The list of template arguments. If the template is\n  /// a template template parameter, this function may extend the set of\n  /// template arguments to also include substituted, defaulted template\n  /// arguments.\n  ///\n  /// \\param PartialTemplateArgs True if the list of template arguments is\n  /// intentionally partial, e.g., because we're checking just the initial\n  /// set of template arguments.\n  ///\n  /// \\param Converted Will receive the converted, canonicalized template\n  /// arguments.\n  ///\n  /// \\param UpdateArgsWithConversions If \\c true, update \\p TemplateArgs to\n  /// contain the converted forms of the template arguments as written.\n  /// Otherwise, \\p TemplateArgs will not be modified.\n  ///\n  /// \\param ConstraintsNotSatisfied If provided, and an error occured, will\n  /// receive true if the cause for the error is the associated constraints of\n  /// the template not being satisfied by the template arguments.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool CheckTemplateArgumentList(TemplateDecl *Template,\n                                 SourceLocation TemplateLoc,\n                                 TemplateArgumentListInfo &TemplateArgs,\n                                 bool PartialTemplateArgs,\n                                 SmallVectorImpl<TemplateArgument> &Converted,\n                                 bool UpdateArgsWithConversions = true,\n                                 bool *ConstraintsNotSatisfied = nullptr);\n\n  bool CheckTemplateTypeArgument(TemplateTypeParmDecl *Param,\n                                 TemplateArgumentLoc &Arg,\n                           SmallVectorImpl<TemplateArgument> &Converted);\n\n  bool CheckTemplateArgument(TemplateTypeParmDecl *Param,\n                             TypeSourceInfo *Arg);\n  ExprResult CheckTemplateArgument(NonTypeTemplateParmDecl *Param,\n                                   QualType InstantiatedParamType, Expr *Arg,\n                                   TemplateArgument &Converted,\n                               CheckTemplateArgumentKind CTAK = CTAK_Specified);\n  bool CheckTemplateTemplateArgument(TemplateTemplateParmDecl *Param,\n                                     TemplateParameterList *Params,\n                                     TemplateArgumentLoc &Arg);\n\n  ExprResult\n  BuildExpressionFromDeclTemplateArgument(const TemplateArgument &Arg,\n                                          QualType ParamType,\n                                          SourceLocation Loc);\n  ExprResult\n  BuildExpressionFromIntegralTemplateArgument(const TemplateArgument &Arg,\n                                              SourceLocation Loc);\n\n  /// Enumeration describing how template parameter lists are compared\n  /// for equality.\n  enum TemplateParameterListEqualKind {\n    /// We are matching the template parameter lists of two templates\n    /// that might be redeclarations.\n    ///\n    /// \\code\n    /// template<typename T> struct X;\n    /// template<typename T> struct X;\n    /// \\endcode\n    TPL_TemplateMatch,\n\n    /// We are matching the template parameter lists of two template\n    /// template parameters as part of matching the template parameter lists\n    /// of two templates that might be redeclarations.\n    ///\n    /// \\code\n    /// template<template<int I> class TT> struct X;\n    /// template<template<int Value> class Other> struct X;\n    /// \\endcode\n    TPL_TemplateTemplateParmMatch,\n\n    /// We are matching the template parameter lists of a template\n    /// template argument against the template parameter lists of a template\n    /// template parameter.\n    ///\n    /// \\code\n    /// template<template<int Value> class Metafun> struct X;\n    /// template<int Value> struct integer_c;\n    /// X<integer_c> xic;\n    /// \\endcode\n    TPL_TemplateTemplateArgumentMatch\n  };\n\n  bool TemplateParameterListsAreEqual(TemplateParameterList *New,\n                                      TemplateParameterList *Old,\n                                      bool Complain,\n                                      TemplateParameterListEqualKind Kind,\n                                      SourceLocation TemplateArgLoc\n                                        = SourceLocation());\n\n  bool CheckTemplateDeclScope(Scope *S, TemplateParameterList *TemplateParams);\n\n  /// Called when the parser has parsed a C++ typename\n  /// specifier, e.g., \"typename T::type\".\n  ///\n  /// \\param S The scope in which this typename type occurs.\n  /// \\param TypenameLoc the location of the 'typename' keyword\n  /// \\param SS the nested-name-specifier following the typename (e.g., 'T::').\n  /// \\param II the identifier we're retrieving (e.g., 'type' in the example).\n  /// \\param IdLoc the location of the identifier.\n  TypeResult\n  ActOnTypenameType(Scope *S, SourceLocation TypenameLoc,\n                    const CXXScopeSpec &SS, const IdentifierInfo &II,\n                    SourceLocation IdLoc);\n\n  /// Called when the parser has parsed a C++ typename\n  /// specifier that ends in a template-id, e.g.,\n  /// \"typename MetaFun::template apply<T1, T2>\".\n  ///\n  /// \\param S The scope in which this typename type occurs.\n  /// \\param TypenameLoc the location of the 'typename' keyword\n  /// \\param SS the nested-name-specifier following the typename (e.g., 'T::').\n  /// \\param TemplateLoc the location of the 'template' keyword, if any.\n  /// \\param TemplateName The template name.\n  /// \\param TemplateII The identifier used to name the template.\n  /// \\param TemplateIILoc The location of the template name.\n  /// \\param LAngleLoc The location of the opening angle bracket  ('<').\n  /// \\param TemplateArgs The template arguments.\n  /// \\param RAngleLoc The location of the closing angle bracket  ('>').\n  TypeResult\n  ActOnTypenameType(Scope *S, SourceLocation TypenameLoc,\n                    const CXXScopeSpec &SS,\n                    SourceLocation TemplateLoc,\n                    TemplateTy TemplateName,\n                    IdentifierInfo *TemplateII,\n                    SourceLocation TemplateIILoc,\n                    SourceLocation LAngleLoc,\n                    ASTTemplateArgsPtr TemplateArgs,\n                    SourceLocation RAngleLoc);\n\n  QualType CheckTypenameType(ElaboratedTypeKeyword Keyword,\n                             SourceLocation KeywordLoc,\n                             NestedNameSpecifierLoc QualifierLoc,\n                             const IdentifierInfo &II,\n                             SourceLocation IILoc,\n                             TypeSourceInfo **TSI,\n                             bool DeducedTSTContext);\n\n  QualType CheckTypenameType(ElaboratedTypeKeyword Keyword,\n                             SourceLocation KeywordLoc,\n                             NestedNameSpecifierLoc QualifierLoc,\n                             const IdentifierInfo &II,\n                             SourceLocation IILoc,\n                             bool DeducedTSTContext = true);\n\n\n  TypeSourceInfo *RebuildTypeInCurrentInstantiation(TypeSourceInfo *T,\n                                                    SourceLocation Loc,\n                                                    DeclarationName Name);\n  bool RebuildNestedNameSpecifierInCurrentInstantiation(CXXScopeSpec &SS);\n\n  ExprResult RebuildExprInCurrentInstantiation(Expr *E);\n  bool RebuildTemplateParamsInCurrentInstantiation(\n                                                TemplateParameterList *Params);\n\n  std::string\n  getTemplateArgumentBindingsText(const TemplateParameterList *Params,\n                                  const TemplateArgumentList &Args);\n\n  std::string\n  getTemplateArgumentBindingsText(const TemplateParameterList *Params,\n                                  const TemplateArgument *Args,\n                                  unsigned NumArgs);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Concepts\n  //===--------------------------------------------------------------------===//\n  Decl *ActOnConceptDefinition(\n      Scope *S, MultiTemplateParamsArg TemplateParameterLists,\n      IdentifierInfo *Name, SourceLocation NameLoc, Expr *ConstraintExpr);\n\n  RequiresExprBodyDecl *\n  ActOnStartRequiresExpr(SourceLocation RequiresKWLoc,\n                         ArrayRef<ParmVarDecl *> LocalParameters,\n                         Scope *BodyScope);\n  void ActOnFinishRequiresExpr();\n  concepts::Requirement *ActOnSimpleRequirement(Expr *E);\n  concepts::Requirement *ActOnTypeRequirement(\n      SourceLocation TypenameKWLoc, CXXScopeSpec &SS, SourceLocation NameLoc,\n      IdentifierInfo *TypeName, TemplateIdAnnotation *TemplateId);\n  concepts::Requirement *ActOnCompoundRequirement(Expr *E,\n                                                  SourceLocation NoexceptLoc);\n  concepts::Requirement *\n  ActOnCompoundRequirement(\n      Expr *E, SourceLocation NoexceptLoc, CXXScopeSpec &SS,\n      TemplateIdAnnotation *TypeConstraint, unsigned Depth);\n  concepts::Requirement *ActOnNestedRequirement(Expr *Constraint);\n  concepts::ExprRequirement *\n  BuildExprRequirement(\n      Expr *E, bool IsSatisfied, SourceLocation NoexceptLoc,\n      concepts::ExprRequirement::ReturnTypeRequirement ReturnTypeRequirement);\n  concepts::ExprRequirement *\n  BuildExprRequirement(\n      concepts::Requirement::SubstitutionDiagnostic *ExprSubstDiag,\n      bool IsSatisfied, SourceLocation NoexceptLoc,\n      concepts::ExprRequirement::ReturnTypeRequirement ReturnTypeRequirement);\n  concepts::TypeRequirement *BuildTypeRequirement(TypeSourceInfo *Type);\n  concepts::TypeRequirement *\n  BuildTypeRequirement(\n      concepts::Requirement::SubstitutionDiagnostic *SubstDiag);\n  concepts::NestedRequirement *BuildNestedRequirement(Expr *E);\n  concepts::NestedRequirement *\n  BuildNestedRequirement(\n      concepts::Requirement::SubstitutionDiagnostic *SubstDiag);\n  ExprResult ActOnRequiresExpr(SourceLocation RequiresKWLoc,\n                               RequiresExprBodyDecl *Body,\n                               ArrayRef<ParmVarDecl *> LocalParameters,\n                               ArrayRef<concepts::Requirement *> Requirements,\n                               SourceLocation ClosingBraceLoc);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Variadic Templates (C++0x [temp.variadic])\n  //===--------------------------------------------------------------------===//\n\n  /// Determine whether an unexpanded parameter pack might be permitted in this\n  /// location. Useful for error recovery.\n  bool isUnexpandedParameterPackPermitted();\n\n  /// The context in which an unexpanded parameter pack is\n  /// being diagnosed.\n  ///\n  /// Note that the values of this enumeration line up with the first\n  /// argument to the \\c err_unexpanded_parameter_pack diagnostic.\n  enum UnexpandedParameterPackContext {\n    /// An arbitrary expression.\n    UPPC_Expression = 0,\n\n    /// The base type of a class type.\n    UPPC_BaseType,\n\n    /// The type of an arbitrary declaration.\n    UPPC_DeclarationType,\n\n    /// The type of a data member.\n    UPPC_DataMemberType,\n\n    /// The size of a bit-field.\n    UPPC_BitFieldWidth,\n\n    /// The expression in a static assertion.\n    UPPC_StaticAssertExpression,\n\n    /// The fixed underlying type of an enumeration.\n    UPPC_FixedUnderlyingType,\n\n    /// The enumerator value.\n    UPPC_EnumeratorValue,\n\n    /// A using declaration.\n    UPPC_UsingDeclaration,\n\n    /// A friend declaration.\n    UPPC_FriendDeclaration,\n\n    /// A declaration qualifier.\n    UPPC_DeclarationQualifier,\n\n    /// An initializer.\n    UPPC_Initializer,\n\n    /// A default argument.\n    UPPC_DefaultArgument,\n\n    /// The type of a non-type template parameter.\n    UPPC_NonTypeTemplateParameterType,\n\n    /// The type of an exception.\n    UPPC_ExceptionType,\n\n    /// Partial specialization.\n    UPPC_PartialSpecialization,\n\n    /// Microsoft __if_exists.\n    UPPC_IfExists,\n\n    /// Microsoft __if_not_exists.\n    UPPC_IfNotExists,\n\n    /// Lambda expression.\n    UPPC_Lambda,\n\n    /// Block expression.\n    UPPC_Block,\n\n    /// A type constraint.\n    UPPC_TypeConstraint,\n\n    // A requirement in a requires-expression.\n    UPPC_Requirement,\n\n    // A requires-clause.\n    UPPC_RequiresClause,\n  };\n\n  /// Diagnose unexpanded parameter packs.\n  ///\n  /// \\param Loc The location at which we should emit the diagnostic.\n  ///\n  /// \\param UPPC The context in which we are diagnosing unexpanded\n  /// parameter packs.\n  ///\n  /// \\param Unexpanded the set of unexpanded parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPacks(SourceLocation Loc,\n                                        UnexpandedParameterPackContext UPPC,\n                                  ArrayRef<UnexpandedParameterPack> Unexpanded);\n\n  /// If the given type contains an unexpanded parameter pack,\n  /// diagnose the error.\n  ///\n  /// \\param Loc The source location where a diagnostc should be emitted.\n  ///\n  /// \\param T The type that is being checked for unexpanded parameter\n  /// packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(SourceLocation Loc, TypeSourceInfo *T,\n                                       UnexpandedParameterPackContext UPPC);\n\n  /// If the given expression contains an unexpanded parameter\n  /// pack, diagnose the error.\n  ///\n  /// \\param E The expression that is being checked for unexpanded\n  /// parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(Expr *E,\n                       UnexpandedParameterPackContext UPPC = UPPC_Expression);\n\n  /// If the given requirees-expression contains an unexpanded reference to one\n  /// of its own parameter packs, diagnose the error.\n  ///\n  /// \\param RE The requiress-expression that is being checked for unexpanded\n  /// parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPackInRequiresExpr(RequiresExpr *RE);\n\n  /// If the given nested-name-specifier contains an unexpanded\n  /// parameter pack, diagnose the error.\n  ///\n  /// \\param SS The nested-name-specifier that is being checked for\n  /// unexpanded parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(const CXXScopeSpec &SS,\n                                       UnexpandedParameterPackContext UPPC);\n\n  /// If the given name contains an unexpanded parameter pack,\n  /// diagnose the error.\n  ///\n  /// \\param NameInfo The name (with source location information) that\n  /// is being checked for unexpanded parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(const DeclarationNameInfo &NameInfo,\n                                       UnexpandedParameterPackContext UPPC);\n\n  /// If the given template name contains an unexpanded parameter pack,\n  /// diagnose the error.\n  ///\n  /// \\param Loc The location of the template name.\n  ///\n  /// \\param Template The template name that is being checked for unexpanded\n  /// parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(SourceLocation Loc,\n                                       TemplateName Template,\n                                       UnexpandedParameterPackContext UPPC);\n\n  /// If the given template argument contains an unexpanded parameter\n  /// pack, diagnose the error.\n  ///\n  /// \\param Arg The template argument that is being checked for unexpanded\n  /// parameter packs.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool DiagnoseUnexpandedParameterPack(TemplateArgumentLoc Arg,\n                                       UnexpandedParameterPackContext UPPC);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// template argument.\n  ///\n  /// \\param Arg The template argument that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(TemplateArgument Arg,\n                   SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// template argument.\n  ///\n  /// \\param Arg The template argument that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(TemplateArgumentLoc Arg,\n                    SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// type.\n  ///\n  /// \\param T The type that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(QualType T,\n                   SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// type.\n  ///\n  /// \\param TL The type that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(TypeLoc TL,\n                   SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// nested-name-specifier.\n  ///\n  /// \\param NNS The nested-name-specifier that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(NestedNameSpecifierLoc NNS,\n                         SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Collect the set of unexpanded parameter packs within the given\n  /// name.\n  ///\n  /// \\param NameInfo The name that will be traversed to find\n  /// unexpanded parameter packs.\n  void collectUnexpandedParameterPacks(const DeclarationNameInfo &NameInfo,\n                         SmallVectorImpl<UnexpandedParameterPack> &Unexpanded);\n\n  /// Invoked when parsing a template argument followed by an\n  /// ellipsis, which creates a pack expansion.\n  ///\n  /// \\param Arg The template argument preceding the ellipsis, which\n  /// may already be invalid.\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis.\n  ParsedTemplateArgument ActOnPackExpansion(const ParsedTemplateArgument &Arg,\n                                            SourceLocation EllipsisLoc);\n\n  /// Invoked when parsing a type followed by an ellipsis, which\n  /// creates a pack expansion.\n  ///\n  /// \\param Type The type preceding the ellipsis, which will become\n  /// the pattern of the pack expansion.\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis.\n  TypeResult ActOnPackExpansion(ParsedType Type, SourceLocation EllipsisLoc);\n\n  /// Construct a pack expansion type from the pattern of the pack\n  /// expansion.\n  TypeSourceInfo *CheckPackExpansion(TypeSourceInfo *Pattern,\n                                     SourceLocation EllipsisLoc,\n                                     Optional<unsigned> NumExpansions);\n\n  /// Construct a pack expansion type from the pattern of the pack\n  /// expansion.\n  QualType CheckPackExpansion(QualType Pattern,\n                              SourceRange PatternRange,\n                              SourceLocation EllipsisLoc,\n                              Optional<unsigned> NumExpansions);\n\n  /// Invoked when parsing an expression followed by an ellipsis, which\n  /// creates a pack expansion.\n  ///\n  /// \\param Pattern The expression preceding the ellipsis, which will become\n  /// the pattern of the pack expansion.\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis.\n  ExprResult ActOnPackExpansion(Expr *Pattern, SourceLocation EllipsisLoc);\n\n  /// Invoked when parsing an expression followed by an ellipsis, which\n  /// creates a pack expansion.\n  ///\n  /// \\param Pattern The expression preceding the ellipsis, which will become\n  /// the pattern of the pack expansion.\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis.\n  ExprResult CheckPackExpansion(Expr *Pattern, SourceLocation EllipsisLoc,\n                                Optional<unsigned> NumExpansions);\n\n  /// Determine whether we could expand a pack expansion with the\n  /// given set of parameter packs into separate arguments by repeatedly\n  /// transforming the pattern.\n  ///\n  /// \\param EllipsisLoc The location of the ellipsis that identifies the\n  /// pack expansion.\n  ///\n  /// \\param PatternRange The source range that covers the entire pattern of\n  /// the pack expansion.\n  ///\n  /// \\param Unexpanded The set of unexpanded parameter packs within the\n  /// pattern.\n  ///\n  /// \\param ShouldExpand Will be set to \\c true if the transformer should\n  /// expand the corresponding pack expansions into separate arguments. When\n  /// set, \\c NumExpansions must also be set.\n  ///\n  /// \\param RetainExpansion Whether the caller should add an unexpanded\n  /// pack expansion after all of the expanded arguments. This is used\n  /// when extending explicitly-specified template argument packs per\n  /// C++0x [temp.arg.explicit]p9.\n  ///\n  /// \\param NumExpansions The number of separate arguments that will be in\n  /// the expanded form of the corresponding pack expansion. This is both an\n  /// input and an output parameter, which can be set by the caller if the\n  /// number of expansions is known a priori (e.g., due to a prior substitution)\n  /// and will be set by the callee when the number of expansions is known.\n  /// The callee must set this value when \\c ShouldExpand is \\c true; it may\n  /// set this value in other cases.\n  ///\n  /// \\returns true if an error occurred (e.g., because the parameter packs\n  /// are to be instantiated with arguments of different lengths), false\n  /// otherwise. If false, \\c ShouldExpand (and possibly \\c NumExpansions)\n  /// must be set.\n  bool CheckParameterPacksForExpansion(SourceLocation EllipsisLoc,\n                                       SourceRange PatternRange,\n                             ArrayRef<UnexpandedParameterPack> Unexpanded,\n                             const MultiLevelTemplateArgumentList &TemplateArgs,\n                                       bool &ShouldExpand,\n                                       bool &RetainExpansion,\n                                       Optional<unsigned> &NumExpansions);\n\n  /// Determine the number of arguments in the given pack expansion\n  /// type.\n  ///\n  /// This routine assumes that the number of arguments in the expansion is\n  /// consistent across all of the unexpanded parameter packs in its pattern.\n  ///\n  /// Returns an empty Optional if the type can't be expanded.\n  Optional<unsigned> getNumArgumentsInExpansion(QualType T,\n      const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  /// Determine whether the given declarator contains any unexpanded\n  /// parameter packs.\n  ///\n  /// This routine is used by the parser to disambiguate function declarators\n  /// with an ellipsis prior to the ')', e.g.,\n  ///\n  /// \\code\n  ///   void f(T...);\n  /// \\endcode\n  ///\n  /// To determine whether we have an (unnamed) function parameter pack or\n  /// a variadic function.\n  ///\n  /// \\returns true if the declarator contains any unexpanded parameter packs,\n  /// false otherwise.\n  bool containsUnexpandedParameterPacks(Declarator &D);\n\n  /// Returns the pattern of the pack expansion for a template argument.\n  ///\n  /// \\param OrigLoc The template argument to expand.\n  ///\n  /// \\param Ellipsis Will be set to the location of the ellipsis.\n  ///\n  /// \\param NumExpansions Will be set to the number of expansions that will\n  /// be generated from this pack expansion, if known a priori.\n  TemplateArgumentLoc getTemplateArgumentPackExpansionPattern(\n      TemplateArgumentLoc OrigLoc,\n      SourceLocation &Ellipsis,\n      Optional<unsigned> &NumExpansions) const;\n\n  /// Given a template argument that contains an unexpanded parameter pack, but\n  /// which has already been substituted, attempt to determine the number of\n  /// elements that will be produced once this argument is fully-expanded.\n  ///\n  /// This is intended for use when transforming 'sizeof...(Arg)' in order to\n  /// avoid actually expanding the pack where possible.\n  Optional<unsigned> getFullyPackExpandedSize(TemplateArgument Arg);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Template Argument Deduction (C++ [temp.deduct])\n  //===--------------------------------------------------------------------===//\n\n  /// Adjust the type \\p ArgFunctionType to match the calling convention,\n  /// noreturn, and optionally the exception specification of \\p FunctionType.\n  /// Deduction often wants to ignore these properties when matching function\n  /// types.\n  QualType adjustCCAndNoReturn(QualType ArgFunctionType, QualType FunctionType,\n                               bool AdjustExceptionSpec = false);\n\n  /// Describes the result of template argument deduction.\n  ///\n  /// The TemplateDeductionResult enumeration describes the result of\n  /// template argument deduction, as returned from\n  /// DeduceTemplateArguments(). The separate TemplateDeductionInfo\n  /// structure provides additional information about the results of\n  /// template argument deduction, e.g., the deduced template argument\n  /// list (if successful) or the specific template parameters or\n  /// deduced arguments that were involved in the failure.\n  enum TemplateDeductionResult {\n    /// Template argument deduction was successful.\n    TDK_Success = 0,\n    /// The declaration was invalid; do nothing.\n    TDK_Invalid,\n    /// Template argument deduction exceeded the maximum template\n    /// instantiation depth (which has already been diagnosed).\n    TDK_InstantiationDepth,\n    /// Template argument deduction did not deduce a value\n    /// for every template parameter.\n    TDK_Incomplete,\n    /// Template argument deduction did not deduce a value for every\n    /// expansion of an expanded template parameter pack.\n    TDK_IncompletePack,\n    /// Template argument deduction produced inconsistent\n    /// deduced values for the given template parameter.\n    TDK_Inconsistent,\n    /// Template argument deduction failed due to inconsistent\n    /// cv-qualifiers on a template parameter type that would\n    /// otherwise be deduced, e.g., we tried to deduce T in \"const T\"\n    /// but were given a non-const \"X\".\n    TDK_Underqualified,\n    /// Substitution of the deduced template argument values\n    /// resulted in an error.\n    TDK_SubstitutionFailure,\n    /// After substituting deduced template arguments, a dependent\n    /// parameter type did not match the corresponding argument.\n    TDK_DeducedMismatch,\n    /// After substituting deduced template arguments, an element of\n    /// a dependent parameter type did not match the corresponding element\n    /// of the corresponding argument (when deducing from an initializer list).\n    TDK_DeducedMismatchNested,\n    /// A non-depnedent component of the parameter did not match the\n    /// corresponding component of the argument.\n    TDK_NonDeducedMismatch,\n    /// When performing template argument deduction for a function\n    /// template, there were too many call arguments.\n    TDK_TooManyArguments,\n    /// When performing template argument deduction for a function\n    /// template, there were too few call arguments.\n    TDK_TooFewArguments,\n    /// The explicitly-specified template arguments were not valid\n    /// template arguments for the given template.\n    TDK_InvalidExplicitArguments,\n    /// Checking non-dependent argument conversions failed.\n    TDK_NonDependentConversionFailure,\n    /// The deduced arguments did not satisfy the constraints associated\n    /// with the template.\n    TDK_ConstraintsNotSatisfied,\n    /// Deduction failed; that's all we know.\n    TDK_MiscellaneousDeductionFailure,\n    /// CUDA Target attributes do not match.\n    TDK_CUDATargetMismatch\n  };\n\n  TemplateDeductionResult\n  DeduceTemplateArguments(ClassTemplatePartialSpecializationDecl *Partial,\n                          const TemplateArgumentList &TemplateArgs,\n                          sema::TemplateDeductionInfo &Info);\n\n  TemplateDeductionResult\n  DeduceTemplateArguments(VarTemplatePartialSpecializationDecl *Partial,\n                          const TemplateArgumentList &TemplateArgs,\n                          sema::TemplateDeductionInfo &Info);\n\n  TemplateDeductionResult SubstituteExplicitTemplateArguments(\n      FunctionTemplateDecl *FunctionTemplate,\n      TemplateArgumentListInfo &ExplicitTemplateArgs,\n      SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n      SmallVectorImpl<QualType> &ParamTypes, QualType *FunctionType,\n      sema::TemplateDeductionInfo &Info);\n\n  /// brief A function argument from which we performed template argument\n  // deduction for a call.\n  struct OriginalCallArg {\n    OriginalCallArg(QualType OriginalParamType, bool DecomposedParam,\n                    unsigned ArgIdx, QualType OriginalArgType)\n        : OriginalParamType(OriginalParamType),\n          DecomposedParam(DecomposedParam), ArgIdx(ArgIdx),\n          OriginalArgType(OriginalArgType) {}\n\n    QualType OriginalParamType;\n    bool DecomposedParam;\n    unsigned ArgIdx;\n    QualType OriginalArgType;\n  };\n\n  TemplateDeductionResult FinishTemplateArgumentDeduction(\n      FunctionTemplateDecl *FunctionTemplate,\n      SmallVectorImpl<DeducedTemplateArgument> &Deduced,\n      unsigned NumExplicitlySpecified, FunctionDecl *&Specialization,\n      sema::TemplateDeductionInfo &Info,\n      SmallVectorImpl<OriginalCallArg> const *OriginalCallArgs = nullptr,\n      bool PartialOverloading = false,\n      llvm::function_ref<bool()> CheckNonDependent = []{ return false; });\n\n  TemplateDeductionResult DeduceTemplateArguments(\n      FunctionTemplateDecl *FunctionTemplate,\n      TemplateArgumentListInfo *ExplicitTemplateArgs, ArrayRef<Expr *> Args,\n      FunctionDecl *&Specialization, sema::TemplateDeductionInfo &Info,\n      bool PartialOverloading,\n      llvm::function_ref<bool(ArrayRef<QualType>)> CheckNonDependent);\n\n  TemplateDeductionResult\n  DeduceTemplateArguments(FunctionTemplateDecl *FunctionTemplate,\n                          TemplateArgumentListInfo *ExplicitTemplateArgs,\n                          QualType ArgFunctionType,\n                          FunctionDecl *&Specialization,\n                          sema::TemplateDeductionInfo &Info,\n                          bool IsAddressOfFunction = false);\n\n  TemplateDeductionResult\n  DeduceTemplateArguments(FunctionTemplateDecl *FunctionTemplate,\n                          QualType ToType,\n                          CXXConversionDecl *&Specialization,\n                          sema::TemplateDeductionInfo &Info);\n\n  TemplateDeductionResult\n  DeduceTemplateArguments(FunctionTemplateDecl *FunctionTemplate,\n                          TemplateArgumentListInfo *ExplicitTemplateArgs,\n                          FunctionDecl *&Specialization,\n                          sema::TemplateDeductionInfo &Info,\n                          bool IsAddressOfFunction = false);\n\n  /// Substitute Replacement for \\p auto in \\p TypeWithAuto\n  QualType SubstAutoType(QualType TypeWithAuto, QualType Replacement);\n  /// Substitute Replacement for auto in TypeWithAuto\n  TypeSourceInfo* SubstAutoTypeSourceInfo(TypeSourceInfo *TypeWithAuto,\n                                          QualType Replacement);\n  /// Completely replace the \\c auto in \\p TypeWithAuto by\n  /// \\p Replacement. This does not retain any \\c auto type sugar.\n  QualType ReplaceAutoType(QualType TypeWithAuto, QualType Replacement);\n  TypeSourceInfo *ReplaceAutoTypeSourceInfo(TypeSourceInfo *TypeWithAuto,\n                                            QualType Replacement);\n\n  /// Result type of DeduceAutoType.\n  enum DeduceAutoResult {\n    DAR_Succeeded,\n    DAR_Failed,\n    DAR_FailedAlreadyDiagnosed\n  };\n\n  DeduceAutoResult\n  DeduceAutoType(TypeSourceInfo *AutoType, Expr *&Initializer, QualType &Result,\n                 Optional<unsigned> DependentDeductionDepth = None,\n                 bool IgnoreConstraints = false);\n  DeduceAutoResult\n  DeduceAutoType(TypeLoc AutoTypeLoc, Expr *&Initializer, QualType &Result,\n                 Optional<unsigned> DependentDeductionDepth = None,\n                 bool IgnoreConstraints = false);\n  void DiagnoseAutoDeductionFailure(VarDecl *VDecl, Expr *Init);\n  bool DeduceReturnType(FunctionDecl *FD, SourceLocation Loc,\n                        bool Diagnose = true);\n\n  /// Declare implicit deduction guides for a class template if we've\n  /// not already done so.\n  void DeclareImplicitDeductionGuides(TemplateDecl *Template,\n                                      SourceLocation Loc);\n\n  QualType DeduceTemplateSpecializationFromInitializer(\n      TypeSourceInfo *TInfo, const InitializedEntity &Entity,\n      const InitializationKind &Kind, MultiExprArg Init);\n\n  QualType deduceVarTypeFromInitializer(VarDecl *VDecl, DeclarationName Name,\n                                        QualType Type, TypeSourceInfo *TSI,\n                                        SourceRange Range, bool DirectInit,\n                                        Expr *Init);\n\n  TypeLoc getReturnTypeLoc(FunctionDecl *FD) const;\n\n  bool DeduceFunctionTypeFromReturnExpr(FunctionDecl *FD,\n                                        SourceLocation ReturnLoc,\n                                        Expr *&RetExpr, AutoType *AT);\n\n  FunctionTemplateDecl *getMoreSpecializedTemplate(\n      FunctionTemplateDecl *FT1, FunctionTemplateDecl *FT2, SourceLocation Loc,\n      TemplatePartialOrderingContext TPOC, unsigned NumCallArguments1,\n      unsigned NumCallArguments2, bool Reversed = false);\n  UnresolvedSetIterator\n  getMostSpecialized(UnresolvedSetIterator SBegin, UnresolvedSetIterator SEnd,\n                     TemplateSpecCandidateSet &FailedCandidates,\n                     SourceLocation Loc,\n                     const PartialDiagnostic &NoneDiag,\n                     const PartialDiagnostic &AmbigDiag,\n                     const PartialDiagnostic &CandidateDiag,\n                     bool Complain = true, QualType TargetType = QualType());\n\n  ClassTemplatePartialSpecializationDecl *\n  getMoreSpecializedPartialSpecialization(\n                                  ClassTemplatePartialSpecializationDecl *PS1,\n                                  ClassTemplatePartialSpecializationDecl *PS2,\n                                  SourceLocation Loc);\n\n  bool isMoreSpecializedThanPrimary(ClassTemplatePartialSpecializationDecl *T,\n                                    sema::TemplateDeductionInfo &Info);\n\n  VarTemplatePartialSpecializationDecl *getMoreSpecializedPartialSpecialization(\n      VarTemplatePartialSpecializationDecl *PS1,\n      VarTemplatePartialSpecializationDecl *PS2, SourceLocation Loc);\n\n  bool isMoreSpecializedThanPrimary(VarTemplatePartialSpecializationDecl *T,\n                                    sema::TemplateDeductionInfo &Info);\n\n  bool isTemplateTemplateParameterAtLeastAsSpecializedAs(\n      TemplateParameterList *PParam, TemplateDecl *AArg, SourceLocation Loc);\n\n  void MarkUsedTemplateParameters(const Expr *E, bool OnlyDeduced,\n                                  unsigned Depth, llvm::SmallBitVector &Used);\n\n  void MarkUsedTemplateParameters(const TemplateArgumentList &TemplateArgs,\n                                  bool OnlyDeduced,\n                                  unsigned Depth,\n                                  llvm::SmallBitVector &Used);\n  void MarkDeducedTemplateParameters(\n                                  const FunctionTemplateDecl *FunctionTemplate,\n                                  llvm::SmallBitVector &Deduced) {\n    return MarkDeducedTemplateParameters(Context, FunctionTemplate, Deduced);\n  }\n  static void MarkDeducedTemplateParameters(ASTContext &Ctx,\n                                  const FunctionTemplateDecl *FunctionTemplate,\n                                  llvm::SmallBitVector &Deduced);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Template Instantiation\n  //\n\n  MultiLevelTemplateArgumentList\n  getTemplateInstantiationArgs(NamedDecl *D,\n                               const TemplateArgumentList *Innermost = nullptr,\n                               bool RelativeToPrimary = false,\n                               const FunctionDecl *Pattern = nullptr);\n\n  /// A context in which code is being synthesized (where a source location\n  /// alone is not sufficient to identify the context). This covers template\n  /// instantiation and various forms of implicitly-generated functions.\n  struct CodeSynthesisContext {\n    /// The kind of template instantiation we are performing\n    enum SynthesisKind {\n      /// We are instantiating a template declaration. The entity is\n      /// the declaration we're instantiating (e.g., a CXXRecordDecl).\n      TemplateInstantiation,\n\n      /// We are instantiating a default argument for a template\n      /// parameter. The Entity is the template parameter whose argument is\n      /// being instantiated, the Template is the template, and the\n      /// TemplateArgs/NumTemplateArguments provide the template arguments as\n      /// specified.\n      DefaultTemplateArgumentInstantiation,\n\n      /// We are instantiating a default argument for a function.\n      /// The Entity is the ParmVarDecl, and TemplateArgs/NumTemplateArgs\n      /// provides the template arguments as specified.\n      DefaultFunctionArgumentInstantiation,\n\n      /// We are substituting explicit template arguments provided for\n      /// a function template. The entity is a FunctionTemplateDecl.\n      ExplicitTemplateArgumentSubstitution,\n\n      /// We are substituting template argument determined as part of\n      /// template argument deduction for either a class template\n      /// partial specialization or a function template. The\n      /// Entity is either a {Class|Var}TemplatePartialSpecializationDecl or\n      /// a TemplateDecl.\n      DeducedTemplateArgumentSubstitution,\n\n      /// We are substituting prior template arguments into a new\n      /// template parameter. The template parameter itself is either a\n      /// NonTypeTemplateParmDecl or a TemplateTemplateParmDecl.\n      PriorTemplateArgumentSubstitution,\n\n      /// We are checking the validity of a default template argument that\n      /// has been used when naming a template-id.\n      DefaultTemplateArgumentChecking,\n\n      /// We are computing the exception specification for a defaulted special\n      /// member function.\n      ExceptionSpecEvaluation,\n\n      /// We are instantiating the exception specification for a function\n      /// template which was deferred until it was needed.\n      ExceptionSpecInstantiation,\n\n      /// We are instantiating a requirement of a requires expression.\n      RequirementInstantiation,\n\n      /// We are checking the satisfaction of a nested requirement of a requires\n      /// expression.\n      NestedRequirementConstraintsCheck,\n\n      /// We are declaring an implicit special member function.\n      DeclaringSpecialMember,\n\n      /// We are declaring an implicit 'operator==' for a defaulted\n      /// 'operator<=>'.\n      DeclaringImplicitEqualityComparison,\n\n      /// We are defining a synthesized function (such as a defaulted special\n      /// member).\n      DefiningSynthesizedFunction,\n\n      // We are checking the constraints associated with a constrained entity or\n      // the constraint expression of a concept. This includes the checks that\n      // atomic constraints have the type 'bool' and that they can be constant\n      // evaluated.\n      ConstraintsCheck,\n\n      // We are substituting template arguments into a constraint expression.\n      ConstraintSubstitution,\n\n      // We are normalizing a constraint expression.\n      ConstraintNormalization,\n\n      // We are substituting into the parameter mapping of an atomic constraint\n      // during normalization.\n      ParameterMappingSubstitution,\n\n      /// We are rewriting a comparison operator in terms of an operator<=>.\n      RewritingOperatorAsSpaceship,\n\n      /// We are initializing a structured binding.\n      InitializingStructuredBinding,\n\n      /// We are marking a class as __dllexport.\n      MarkingClassDllexported,\n\n      /// Added for Template instantiation observation.\n      /// Memoization means we are _not_ instantiating a template because\n      /// it is already instantiated (but we entered a context where we\n      /// would have had to if it was not already instantiated).\n      Memoization\n    } Kind;\n\n    /// Was the enclosing context a non-instantiation SFINAE context?\n    bool SavedInNonInstantiationSFINAEContext;\n\n    /// The point of instantiation or synthesis within the source code.\n    SourceLocation PointOfInstantiation;\n\n    /// The entity that is being synthesized.\n    Decl *Entity;\n\n    /// The template (or partial specialization) in which we are\n    /// performing the instantiation, for substitutions of prior template\n    /// arguments.\n    NamedDecl *Template;\n\n    /// The list of template arguments we are substituting, if they\n    /// are not part of the entity.\n    const TemplateArgument *TemplateArgs;\n\n    // FIXME: Wrap this union around more members, or perhaps store the\n    // kind-specific members in the RAII object owning the context.\n    union {\n      /// The number of template arguments in TemplateArgs.\n      unsigned NumTemplateArgs;\n\n      /// The special member being declared or defined.\n      CXXSpecialMember SpecialMember;\n    };\n\n    ArrayRef<TemplateArgument> template_arguments() const {\n      assert(Kind != DeclaringSpecialMember);\n      return {TemplateArgs, NumTemplateArgs};\n    }\n\n    /// The template deduction info object associated with the\n    /// substitution or checking of explicit or deduced template arguments.\n    sema::TemplateDeductionInfo *DeductionInfo;\n\n    /// The source range that covers the construct that cause\n    /// the instantiation, e.g., the template-id that causes a class\n    /// template instantiation.\n    SourceRange InstantiationRange;\n\n    CodeSynthesisContext()\n        : Kind(TemplateInstantiation),\n          SavedInNonInstantiationSFINAEContext(false), Entity(nullptr),\n          Template(nullptr), TemplateArgs(nullptr), NumTemplateArgs(0),\n          DeductionInfo(nullptr) {}\n\n    /// Determines whether this template is an actual instantiation\n    /// that should be counted toward the maximum instantiation depth.\n    bool isInstantiationRecord() const;\n  };\n\n  /// List of active code synthesis contexts.\n  ///\n  /// This vector is treated as a stack. As synthesis of one entity requires\n  /// synthesis of another, additional contexts are pushed onto the stack.\n  SmallVector<CodeSynthesisContext, 16> CodeSynthesisContexts;\n\n  /// Specializations whose definitions are currently being instantiated.\n  llvm::DenseSet<std::pair<Decl *, unsigned>> InstantiatingSpecializations;\n\n  /// Non-dependent types used in templates that have already been instantiated\n  /// by some template instantiation.\n  llvm::DenseSet<QualType> InstantiatedNonDependentTypes;\n\n  /// Extra modules inspected when performing a lookup during a template\n  /// instantiation. Computed lazily.\n  SmallVector<Module*, 16> CodeSynthesisContextLookupModules;\n\n  /// Cache of additional modules that should be used for name lookup\n  /// within the current template instantiation. Computed lazily; use\n  /// getLookupModules() to get a complete set.\n  llvm::DenseSet<Module*> LookupModulesCache;\n\n  /// Get the set of additional modules that should be checked during\n  /// name lookup. A module and its imports become visible when instanting a\n  /// template defined within it.\n  llvm::DenseSet<Module*> &getLookupModules();\n\n  /// Map from the most recent declaration of a namespace to the most\n  /// recent visible declaration of that namespace.\n  llvm::DenseMap<NamedDecl*, NamedDecl*> VisibleNamespaceCache;\n\n  /// Whether we are in a SFINAE context that is not associated with\n  /// template instantiation.\n  ///\n  /// This is used when setting up a SFINAE trap (\\c see SFINAETrap) outside\n  /// of a template instantiation or template argument deduction.\n  bool InNonInstantiationSFINAEContext;\n\n  /// The number of \\p CodeSynthesisContexts that are not template\n  /// instantiations and, therefore, should not be counted as part of the\n  /// instantiation depth.\n  ///\n  /// When the instantiation depth reaches the user-configurable limit\n  /// \\p LangOptions::InstantiationDepth we will abort instantiation.\n  // FIXME: Should we have a similar limit for other forms of synthesis?\n  unsigned NonInstantiationEntries;\n\n  /// The depth of the context stack at the point when the most recent\n  /// error or warning was produced.\n  ///\n  /// This value is used to suppress printing of redundant context stacks\n  /// when there are multiple errors or warnings in the same instantiation.\n  // FIXME: Does this belong in Sema? It's tough to implement it anywhere else.\n  unsigned LastEmittedCodeSynthesisContextDepth = 0;\n\n  /// The template instantiation callbacks to trace or track\n  /// instantiations (objects can be chained).\n  ///\n  /// This callbacks is used to print, trace or track template\n  /// instantiations as they are being constructed.\n  std::vector<std::unique_ptr<TemplateInstantiationCallback>>\n      TemplateInstCallbacks;\n\n  /// The current index into pack expansion arguments that will be\n  /// used for substitution of parameter packs.\n  ///\n  /// The pack expansion index will be -1 to indicate that parameter packs\n  /// should be instantiated as themselves. Otherwise, the index specifies\n  /// which argument within the parameter pack will be used for substitution.\n  int ArgumentPackSubstitutionIndex;\n\n  /// RAII object used to change the argument pack substitution index\n  /// within a \\c Sema object.\n  ///\n  /// See \\c ArgumentPackSubstitutionIndex for more information.\n  class ArgumentPackSubstitutionIndexRAII {\n    Sema &Self;\n    int OldSubstitutionIndex;\n\n  public:\n    ArgumentPackSubstitutionIndexRAII(Sema &Self, int NewSubstitutionIndex)\n      : Self(Self), OldSubstitutionIndex(Self.ArgumentPackSubstitutionIndex) {\n      Self.ArgumentPackSubstitutionIndex = NewSubstitutionIndex;\n    }\n\n    ~ArgumentPackSubstitutionIndexRAII() {\n      Self.ArgumentPackSubstitutionIndex = OldSubstitutionIndex;\n    }\n  };\n\n  friend class ArgumentPackSubstitutionRAII;\n\n  /// For each declaration that involved template argument deduction, the\n  /// set of diagnostics that were suppressed during that template argument\n  /// deduction.\n  ///\n  /// FIXME: Serialize this structure to the AST file.\n  typedef llvm::DenseMap<Decl *, SmallVector<PartialDiagnosticAt, 1> >\n    SuppressedDiagnosticsMap;\n  SuppressedDiagnosticsMap SuppressedDiagnostics;\n\n  /// A stack object to be created when performing template\n  /// instantiation.\n  ///\n  /// Construction of an object of type \\c InstantiatingTemplate\n  /// pushes the current instantiation onto the stack of active\n  /// instantiations. If the size of this stack exceeds the maximum\n  /// number of recursive template instantiations, construction\n  /// produces an error and evaluates true.\n  ///\n  /// Destruction of this object will pop the named instantiation off\n  /// the stack.\n  struct InstantiatingTemplate {\n    /// Note that we are instantiating a class template,\n    /// function template, variable template, alias template,\n    /// or a member thereof.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          Decl *Entity,\n                          SourceRange InstantiationRange = SourceRange());\n\n    struct ExceptionSpecification {};\n    /// Note that we are instantiating an exception specification\n    /// of a function template.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          FunctionDecl *Entity, ExceptionSpecification,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating a default argument in a\n    /// template-id.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          TemplateParameter Param, TemplateDecl *Template,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are substituting either explicitly-specified or\n    /// deduced template arguments during function template argument deduction.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          FunctionTemplateDecl *FunctionTemplate,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          CodeSynthesisContext::SynthesisKind Kind,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating as part of template\n    /// argument deduction for a class template declaration.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          TemplateDecl *Template,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating as part of template\n    /// argument deduction for a class template partial\n    /// specialization.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ClassTemplatePartialSpecializationDecl *PartialSpec,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating as part of template\n    /// argument deduction for a variable template partial\n    /// specialization.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          VarTemplatePartialSpecializationDecl *PartialSpec,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are instantiating a default argument for a function\n    /// parameter.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ParmVarDecl *Param,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we are substituting prior template arguments into a\n    /// non-type parameter.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          NamedDecl *Template,\n                          NonTypeTemplateParmDecl *Param,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange);\n\n    /// Note that we are substituting prior template arguments into a\n    /// template template parameter.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          NamedDecl *Template,\n                          TemplateTemplateParmDecl *Param,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange);\n\n    /// Note that we are checking the default template argument\n    /// against the template parameter for a given template-id.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          TemplateDecl *Template,\n                          NamedDecl *Param,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange);\n\n    struct ConstraintsCheck {};\n    /// \\brief Note that we are checking the constraints associated with some\n    /// constrained entity (a concept declaration or a template with associated\n    /// constraints).\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ConstraintsCheck, NamedDecl *Template,\n                          ArrayRef<TemplateArgument> TemplateArgs,\n                          SourceRange InstantiationRange);\n\n    struct ConstraintSubstitution {};\n    /// \\brief Note that we are checking a constraint expression associated\n    /// with a template declaration or as part of the satisfaction check of a\n    /// concept.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ConstraintSubstitution, NamedDecl *Template,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange);\n\n    struct ConstraintNormalization {};\n    /// \\brief Note that we are normalizing a constraint expression.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ConstraintNormalization, NamedDecl *Template,\n                          SourceRange InstantiationRange);\n\n    struct ParameterMappingSubstitution {};\n    /// \\brief Note that we are subtituting into the parameter mapping of an\n    /// atomic constraint during constraint normalization.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          ParameterMappingSubstitution, NamedDecl *Template,\n                          SourceRange InstantiationRange);\n\n    /// \\brief Note that we are substituting template arguments into a part of\n    /// a requirement of a requires expression.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          concepts::Requirement *Req,\n                          sema::TemplateDeductionInfo &DeductionInfo,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// \\brief Note that we are checking the satisfaction of the constraint\n    /// expression inside of a nested requirement.\n    InstantiatingTemplate(Sema &SemaRef, SourceLocation PointOfInstantiation,\n                          concepts::NestedRequirement *Req, ConstraintsCheck,\n                          SourceRange InstantiationRange = SourceRange());\n\n    /// Note that we have finished instantiating this template.\n    void Clear();\n\n    ~InstantiatingTemplate() { Clear(); }\n\n    /// Determines whether we have exceeded the maximum\n    /// recursive template instantiations.\n    bool isInvalid() const { return Invalid; }\n\n    /// Determine whether we are already instantiating this\n    /// specialization in some surrounding active instantiation.\n    bool isAlreadyInstantiating() const { return AlreadyInstantiating; }\n\n  private:\n    Sema &SemaRef;\n    bool Invalid;\n    bool AlreadyInstantiating;\n    bool CheckInstantiationDepth(SourceLocation PointOfInstantiation,\n                                 SourceRange InstantiationRange);\n\n    InstantiatingTemplate(\n        Sema &SemaRef, CodeSynthesisContext::SynthesisKind Kind,\n        SourceLocation PointOfInstantiation, SourceRange InstantiationRange,\n        Decl *Entity, NamedDecl *Template = nullptr,\n        ArrayRef<TemplateArgument> TemplateArgs = None,\n        sema::TemplateDeductionInfo *DeductionInfo = nullptr);\n\n    InstantiatingTemplate(const InstantiatingTemplate&) = delete;\n\n    InstantiatingTemplate&\n    operator=(const InstantiatingTemplate&) = delete;\n  };\n\n  void pushCodeSynthesisContext(CodeSynthesisContext Ctx);\n  void popCodeSynthesisContext();\n\n  /// Determine whether we are currently performing template instantiation.\n  bool inTemplateInstantiation() const {\n    return CodeSynthesisContexts.size() > NonInstantiationEntries;\n  }\n\n  void PrintContextStack() {\n    if (!CodeSynthesisContexts.empty() &&\n        CodeSynthesisContexts.size() != LastEmittedCodeSynthesisContextDepth) {\n      PrintInstantiationStack();\n      LastEmittedCodeSynthesisContextDepth = CodeSynthesisContexts.size();\n    }\n    if (PragmaAttributeCurrentTargetDecl)\n      PrintPragmaAttributeInstantiationPoint();\n  }\n  void PrintInstantiationStack();\n\n  void PrintPragmaAttributeInstantiationPoint();\n\n  /// Determines whether we are currently in a context where\n  /// template argument substitution failures are not considered\n  /// errors.\n  ///\n  /// \\returns An empty \\c Optional if we're not in a SFINAE context.\n  /// Otherwise, contains a pointer that, if non-NULL, contains the nearest\n  /// template-deduction context object, which can be used to capture\n  /// diagnostics that will be suppressed.\n  Optional<sema::TemplateDeductionInfo *> isSFINAEContext() const;\n\n  /// Determines whether we are currently in a context that\n  /// is not evaluated as per C++ [expr] p5.\n  bool isUnevaluatedContext() const {\n    assert(!ExprEvalContexts.empty() &&\n           \"Must be in an expression evaluation context\");\n    return ExprEvalContexts.back().isUnevaluated();\n  }\n\n  /// RAII class used to determine whether SFINAE has\n  /// trapped any errors that occur during template argument\n  /// deduction.\n  class SFINAETrap {\n    Sema &SemaRef;\n    unsigned PrevSFINAEErrors;\n    bool PrevInNonInstantiationSFINAEContext;\n    bool PrevAccessCheckingSFINAE;\n    bool PrevLastDiagnosticIgnored;\n\n  public:\n    explicit SFINAETrap(Sema &SemaRef, bool AccessCheckingSFINAE = false)\n      : SemaRef(SemaRef), PrevSFINAEErrors(SemaRef.NumSFINAEErrors),\n        PrevInNonInstantiationSFINAEContext(\n                                      SemaRef.InNonInstantiationSFINAEContext),\n        PrevAccessCheckingSFINAE(SemaRef.AccessCheckingSFINAE),\n        PrevLastDiagnosticIgnored(\n            SemaRef.getDiagnostics().isLastDiagnosticIgnored())\n    {\n      if (!SemaRef.isSFINAEContext())\n        SemaRef.InNonInstantiationSFINAEContext = true;\n      SemaRef.AccessCheckingSFINAE = AccessCheckingSFINAE;\n    }\n\n    ~SFINAETrap() {\n      SemaRef.NumSFINAEErrors = PrevSFINAEErrors;\n      SemaRef.InNonInstantiationSFINAEContext\n        = PrevInNonInstantiationSFINAEContext;\n      SemaRef.AccessCheckingSFINAE = PrevAccessCheckingSFINAE;\n      SemaRef.getDiagnostics().setLastDiagnosticIgnored(\n          PrevLastDiagnosticIgnored);\n    }\n\n    /// Determine whether any SFINAE errors have been trapped.\n    bool hasErrorOccurred() const {\n      return SemaRef.NumSFINAEErrors > PrevSFINAEErrors;\n    }\n  };\n\n  /// RAII class used to indicate that we are performing provisional\n  /// semantic analysis to determine the validity of a construct, so\n  /// typo-correction and diagnostics in the immediate context (not within\n  /// implicitly-instantiated templates) should be suppressed.\n  class TentativeAnalysisScope {\n    Sema &SemaRef;\n    // FIXME: Using a SFINAETrap for this is a hack.\n    SFINAETrap Trap;\n    bool PrevDisableTypoCorrection;\n  public:\n    explicit TentativeAnalysisScope(Sema &SemaRef)\n        : SemaRef(SemaRef), Trap(SemaRef, true),\n          PrevDisableTypoCorrection(SemaRef.DisableTypoCorrection) {\n      SemaRef.DisableTypoCorrection = true;\n    }\n    ~TentativeAnalysisScope() {\n      SemaRef.DisableTypoCorrection = PrevDisableTypoCorrection;\n    }\n  };\n\n  /// The current instantiation scope used to store local\n  /// variables.\n  LocalInstantiationScope *CurrentInstantiationScope;\n\n  /// Tracks whether we are in a context where typo correction is\n  /// disabled.\n  bool DisableTypoCorrection;\n\n  /// The number of typos corrected by CorrectTypo.\n  unsigned TyposCorrected;\n\n  typedef llvm::SmallSet<SourceLocation, 2> SrcLocSet;\n  typedef llvm::DenseMap<IdentifierInfo *, SrcLocSet> IdentifierSourceLocations;\n\n  /// A cache containing identifiers for which typo correction failed and\n  /// their locations, so that repeated attempts to correct an identifier in a\n  /// given location are ignored if typo correction already failed for it.\n  IdentifierSourceLocations TypoCorrectionFailures;\n\n  /// Worker object for performing CFG-based warnings.\n  sema::AnalysisBasedWarnings AnalysisWarnings;\n  threadSafety::BeforeSet *ThreadSafetyDeclCache;\n\n  /// An entity for which implicit template instantiation is required.\n  ///\n  /// The source location associated with the declaration is the first place in\n  /// the source code where the declaration was \"used\". It is not necessarily\n  /// the point of instantiation (which will be either before or after the\n  /// namespace-scope declaration that triggered this implicit instantiation),\n  /// However, it is the location that diagnostics should generally refer to,\n  /// because users will need to know what code triggered the instantiation.\n  typedef std::pair<ValueDecl *, SourceLocation> PendingImplicitInstantiation;\n\n  /// The queue of implicit template instantiations that are required\n  /// but have not yet been performed.\n  std::deque<PendingImplicitInstantiation> PendingInstantiations;\n\n  /// Queue of implicit template instantiations that cannot be performed\n  /// eagerly.\n  SmallVector<PendingImplicitInstantiation, 1> LateParsedInstantiations;\n\n  class GlobalEagerInstantiationScope {\n  public:\n    GlobalEagerInstantiationScope(Sema &S, bool Enabled)\n        : S(S), Enabled(Enabled) {\n      if (!Enabled) return;\n\n      SavedPendingInstantiations.swap(S.PendingInstantiations);\n      SavedVTableUses.swap(S.VTableUses);\n    }\n\n    void perform() {\n      if (Enabled) {\n        S.DefineUsedVTables();\n        S.PerformPendingInstantiations();\n      }\n    }\n\n    ~GlobalEagerInstantiationScope() {\n      if (!Enabled) return;\n\n      // Restore the set of pending vtables.\n      assert(S.VTableUses.empty() &&\n             \"VTableUses should be empty before it is discarded.\");\n      S.VTableUses.swap(SavedVTableUses);\n\n      // Restore the set of pending implicit instantiations.\n      if (S.TUKind != TU_Prefix || !S.LangOpts.PCHInstantiateTemplates) {\n        assert(S.PendingInstantiations.empty() &&\n               \"PendingInstantiations should be empty before it is discarded.\");\n        S.PendingInstantiations.swap(SavedPendingInstantiations);\n      } else {\n        // Template instantiations in the PCH may be delayed until the TU.\n        S.PendingInstantiations.swap(SavedPendingInstantiations);\n        S.PendingInstantiations.insert(S.PendingInstantiations.end(),\n                                       SavedPendingInstantiations.begin(),\n                                       SavedPendingInstantiations.end());\n      }\n    }\n\n  private:\n    Sema &S;\n    SmallVector<VTableUse, 16> SavedVTableUses;\n    std::deque<PendingImplicitInstantiation> SavedPendingInstantiations;\n    bool Enabled;\n  };\n\n  /// The queue of implicit template instantiations that are required\n  /// and must be performed within the current local scope.\n  ///\n  /// This queue is only used for member functions of local classes in\n  /// templates, which must be instantiated in the same scope as their\n  /// enclosing function, so that they can reference function-local\n  /// types, static variables, enumerators, etc.\n  std::deque<PendingImplicitInstantiation> PendingLocalImplicitInstantiations;\n\n  class LocalEagerInstantiationScope {\n  public:\n    LocalEagerInstantiationScope(Sema &S) : S(S) {\n      SavedPendingLocalImplicitInstantiations.swap(\n          S.PendingLocalImplicitInstantiations);\n    }\n\n    void perform() { S.PerformPendingInstantiations(/*LocalOnly=*/true); }\n\n    ~LocalEagerInstantiationScope() {\n      assert(S.PendingLocalImplicitInstantiations.empty() &&\n             \"there shouldn't be any pending local implicit instantiations\");\n      SavedPendingLocalImplicitInstantiations.swap(\n          S.PendingLocalImplicitInstantiations);\n    }\n\n  private:\n    Sema &S;\n    std::deque<PendingImplicitInstantiation>\n        SavedPendingLocalImplicitInstantiations;\n  };\n\n  /// A helper class for building up ExtParameterInfos.\n  class ExtParameterInfoBuilder {\n    SmallVector<FunctionProtoType::ExtParameterInfo, 16> Infos;\n    bool HasInteresting = false;\n\n  public:\n    /// Set the ExtParameterInfo for the parameter at the given index,\n    ///\n    void set(unsigned index, FunctionProtoType::ExtParameterInfo info) {\n      assert(Infos.size() <= index);\n      Infos.resize(index);\n      Infos.push_back(info);\n\n      if (!HasInteresting)\n        HasInteresting = (info != FunctionProtoType::ExtParameterInfo());\n    }\n\n    /// Return a pointer (suitable for setting in an ExtProtoInfo) to the\n    /// ExtParameterInfo array we've built up.\n    const FunctionProtoType::ExtParameterInfo *\n    getPointerOrNull(unsigned numParams) {\n      if (!HasInteresting) return nullptr;\n      Infos.resize(numParams);\n      return Infos.data();\n    }\n  };\n\n  void PerformPendingInstantiations(bool LocalOnly = false);\n\n  TypeSourceInfo *SubstType(TypeSourceInfo *T,\n                            const MultiLevelTemplateArgumentList &TemplateArgs,\n                            SourceLocation Loc, DeclarationName Entity,\n                            bool AllowDeducedTST = false);\n\n  QualType SubstType(QualType T,\n                     const MultiLevelTemplateArgumentList &TemplateArgs,\n                     SourceLocation Loc, DeclarationName Entity);\n\n  TypeSourceInfo *SubstType(TypeLoc TL,\n                            const MultiLevelTemplateArgumentList &TemplateArgs,\n                            SourceLocation Loc, DeclarationName Entity);\n\n  TypeSourceInfo *SubstFunctionDeclType(TypeSourceInfo *T,\n                            const MultiLevelTemplateArgumentList &TemplateArgs,\n                                        SourceLocation Loc,\n                                        DeclarationName Entity,\n                                        CXXRecordDecl *ThisContext,\n                                        Qualifiers ThisTypeQuals);\n  void SubstExceptionSpec(FunctionDecl *New, const FunctionProtoType *Proto,\n                          const MultiLevelTemplateArgumentList &Args);\n  bool SubstExceptionSpec(SourceLocation Loc,\n                          FunctionProtoType::ExceptionSpecInfo &ESI,\n                          SmallVectorImpl<QualType> &ExceptionStorage,\n                          const MultiLevelTemplateArgumentList &Args);\n  ParmVarDecl *SubstParmVarDecl(ParmVarDecl *D,\n                            const MultiLevelTemplateArgumentList &TemplateArgs,\n                                int indexAdjustment,\n                                Optional<unsigned> NumExpansions,\n                                bool ExpectParameterPack);\n  bool SubstParmTypes(SourceLocation Loc, ArrayRef<ParmVarDecl *> Params,\n                      const FunctionProtoType::ExtParameterInfo *ExtParamInfos,\n                      const MultiLevelTemplateArgumentList &TemplateArgs,\n                      SmallVectorImpl<QualType> &ParamTypes,\n                      SmallVectorImpl<ParmVarDecl *> *OutParams,\n                      ExtParameterInfoBuilder &ParamInfos);\n  ExprResult SubstExpr(Expr *E,\n                       const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  /// Substitute the given template arguments into a list of\n  /// expressions, expanding pack expansions if required.\n  ///\n  /// \\param Exprs The list of expressions to substitute into.\n  ///\n  /// \\param IsCall Whether this is some form of call, in which case\n  /// default arguments will be dropped.\n  ///\n  /// \\param TemplateArgs The set of template arguments to substitute.\n  ///\n  /// \\param Outputs Will receive all of the substituted arguments.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  bool SubstExprs(ArrayRef<Expr *> Exprs, bool IsCall,\n                  const MultiLevelTemplateArgumentList &TemplateArgs,\n                  SmallVectorImpl<Expr *> &Outputs);\n\n  StmtResult SubstStmt(Stmt *S,\n                       const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  TemplateParameterList *\n  SubstTemplateParams(TemplateParameterList *Params, DeclContext *Owner,\n                      const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  bool\n  SubstTemplateArguments(ArrayRef<TemplateArgumentLoc> Args,\n                         const MultiLevelTemplateArgumentList &TemplateArgs,\n                         TemplateArgumentListInfo &Outputs);\n\n\n  Decl *SubstDecl(Decl *D, DeclContext *Owner,\n                  const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  /// Substitute the name and return type of a defaulted 'operator<=>' to form\n  /// an implicit 'operator=='.\n  FunctionDecl *SubstSpaceshipAsEqualEqual(CXXRecordDecl *RD,\n                                           FunctionDecl *Spaceship);\n\n  ExprResult SubstInitializer(Expr *E,\n                       const MultiLevelTemplateArgumentList &TemplateArgs,\n                       bool CXXDirectInit);\n\n  bool\n  SubstBaseSpecifiers(CXXRecordDecl *Instantiation,\n                      CXXRecordDecl *Pattern,\n                      const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  bool\n  InstantiateClass(SourceLocation PointOfInstantiation,\n                   CXXRecordDecl *Instantiation, CXXRecordDecl *Pattern,\n                   const MultiLevelTemplateArgumentList &TemplateArgs,\n                   TemplateSpecializationKind TSK,\n                   bool Complain = true);\n\n  bool InstantiateEnum(SourceLocation PointOfInstantiation,\n                       EnumDecl *Instantiation, EnumDecl *Pattern,\n                       const MultiLevelTemplateArgumentList &TemplateArgs,\n                       TemplateSpecializationKind TSK);\n\n  bool InstantiateInClassInitializer(\n      SourceLocation PointOfInstantiation, FieldDecl *Instantiation,\n      FieldDecl *Pattern, const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  struct LateInstantiatedAttribute {\n    const Attr *TmplAttr;\n    LocalInstantiationScope *Scope;\n    Decl *NewDecl;\n\n    LateInstantiatedAttribute(const Attr *A, LocalInstantiationScope *S,\n                              Decl *D)\n      : TmplAttr(A), Scope(S), NewDecl(D)\n    { }\n  };\n  typedef SmallVector<LateInstantiatedAttribute, 16> LateInstantiatedAttrVec;\n\n  void InstantiateAttrs(const MultiLevelTemplateArgumentList &TemplateArgs,\n                        const Decl *Pattern, Decl *Inst,\n                        LateInstantiatedAttrVec *LateAttrs = nullptr,\n                        LocalInstantiationScope *OuterMostScope = nullptr);\n\n  void\n  InstantiateAttrsForDecl(const MultiLevelTemplateArgumentList &TemplateArgs,\n                          const Decl *Pattern, Decl *Inst,\n                          LateInstantiatedAttrVec *LateAttrs = nullptr,\n                          LocalInstantiationScope *OuterMostScope = nullptr);\n\n  void InstantiateDefaultCtorDefaultArgs(CXXConstructorDecl *Ctor);\n\n  bool usesPartialOrExplicitSpecialization(\n      SourceLocation Loc, ClassTemplateSpecializationDecl *ClassTemplateSpec);\n\n  bool\n  InstantiateClassTemplateSpecialization(SourceLocation PointOfInstantiation,\n                           ClassTemplateSpecializationDecl *ClassTemplateSpec,\n                           TemplateSpecializationKind TSK,\n                           bool Complain = true);\n\n  void InstantiateClassMembers(SourceLocation PointOfInstantiation,\n                               CXXRecordDecl *Instantiation,\n                            const MultiLevelTemplateArgumentList &TemplateArgs,\n                               TemplateSpecializationKind TSK);\n\n  void InstantiateClassTemplateSpecializationMembers(\n                                          SourceLocation PointOfInstantiation,\n                           ClassTemplateSpecializationDecl *ClassTemplateSpec,\n                                                TemplateSpecializationKind TSK);\n\n  NestedNameSpecifierLoc\n  SubstNestedNameSpecifierLoc(NestedNameSpecifierLoc NNS,\n                           const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  DeclarationNameInfo\n  SubstDeclarationNameInfo(const DeclarationNameInfo &NameInfo,\n                           const MultiLevelTemplateArgumentList &TemplateArgs);\n  TemplateName\n  SubstTemplateName(NestedNameSpecifierLoc QualifierLoc, TemplateName Name,\n                    SourceLocation Loc,\n                    const MultiLevelTemplateArgumentList &TemplateArgs);\n  bool Subst(const TemplateArgumentLoc *Args, unsigned NumArgs,\n             TemplateArgumentListInfo &Result,\n             const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  bool InstantiateDefaultArgument(SourceLocation CallLoc, FunctionDecl *FD,\n                                  ParmVarDecl *Param);\n  void InstantiateExceptionSpec(SourceLocation PointOfInstantiation,\n                                FunctionDecl *Function);\n  bool CheckInstantiatedFunctionTemplateConstraints(\n      SourceLocation PointOfInstantiation, FunctionDecl *Decl,\n      ArrayRef<TemplateArgument> TemplateArgs,\n      ConstraintSatisfaction &Satisfaction);\n  FunctionDecl *InstantiateFunctionDeclaration(FunctionTemplateDecl *FTD,\n                                               const TemplateArgumentList *Args,\n                                               SourceLocation Loc);\n  void InstantiateFunctionDefinition(SourceLocation PointOfInstantiation,\n                                     FunctionDecl *Function,\n                                     bool Recursive = false,\n                                     bool DefinitionRequired = false,\n                                     bool AtEndOfTU = false);\n  VarTemplateSpecializationDecl *BuildVarTemplateInstantiation(\n      VarTemplateDecl *VarTemplate, VarDecl *FromVar,\n      const TemplateArgumentList &TemplateArgList,\n      const TemplateArgumentListInfo &TemplateArgsInfo,\n      SmallVectorImpl<TemplateArgument> &Converted,\n      SourceLocation PointOfInstantiation,\n      LateInstantiatedAttrVec *LateAttrs = nullptr,\n      LocalInstantiationScope *StartingScope = nullptr);\n  VarTemplateSpecializationDecl *CompleteVarTemplateSpecializationDecl(\n      VarTemplateSpecializationDecl *VarSpec, VarDecl *PatternDecl,\n      const MultiLevelTemplateArgumentList &TemplateArgs);\n  void\n  BuildVariableInstantiation(VarDecl *NewVar, VarDecl *OldVar,\n                             const MultiLevelTemplateArgumentList &TemplateArgs,\n                             LateInstantiatedAttrVec *LateAttrs,\n                             DeclContext *Owner,\n                             LocalInstantiationScope *StartingScope,\n                             bool InstantiatingVarTemplate = false,\n                             VarTemplateSpecializationDecl *PrevVTSD = nullptr);\n\n  void InstantiateVariableInitializer(\n      VarDecl *Var, VarDecl *OldVar,\n      const MultiLevelTemplateArgumentList &TemplateArgs);\n  void InstantiateVariableDefinition(SourceLocation PointOfInstantiation,\n                                     VarDecl *Var, bool Recursive = false,\n                                     bool DefinitionRequired = false,\n                                     bool AtEndOfTU = false);\n\n  void InstantiateMemInitializers(CXXConstructorDecl *New,\n                                  const CXXConstructorDecl *Tmpl,\n                            const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  NamedDecl *FindInstantiatedDecl(SourceLocation Loc, NamedDecl *D,\n                          const MultiLevelTemplateArgumentList &TemplateArgs,\n                          bool FindingInstantiatedContext = false);\n  DeclContext *FindInstantiatedContext(SourceLocation Loc, DeclContext *DC,\n                          const MultiLevelTemplateArgumentList &TemplateArgs);\n\n  // Objective-C declarations.\n  enum ObjCContainerKind {\n    OCK_None = -1,\n    OCK_Interface = 0,\n    OCK_Protocol,\n    OCK_Category,\n    OCK_ClassExtension,\n    OCK_Implementation,\n    OCK_CategoryImplementation\n  };\n  ObjCContainerKind getObjCContainerKind() const;\n\n  DeclResult actOnObjCTypeParam(Scope *S,\n                                ObjCTypeParamVariance variance,\n                                SourceLocation varianceLoc,\n                                unsigned index,\n                                IdentifierInfo *paramName,\n                                SourceLocation paramLoc,\n                                SourceLocation colonLoc,\n                                ParsedType typeBound);\n\n  ObjCTypeParamList *actOnObjCTypeParamList(Scope *S, SourceLocation lAngleLoc,\n                                            ArrayRef<Decl *> typeParams,\n                                            SourceLocation rAngleLoc);\n  void popObjCTypeParamList(Scope *S, ObjCTypeParamList *typeParamList);\n\n  Decl *ActOnStartClassInterface(\n      Scope *S, SourceLocation AtInterfaceLoc, IdentifierInfo *ClassName,\n      SourceLocation ClassLoc, ObjCTypeParamList *typeParamList,\n      IdentifierInfo *SuperName, SourceLocation SuperLoc,\n      ArrayRef<ParsedType> SuperTypeArgs, SourceRange SuperTypeArgsRange,\n      Decl *const *ProtoRefs, unsigned NumProtoRefs,\n      const SourceLocation *ProtoLocs, SourceLocation EndProtoLoc,\n      const ParsedAttributesView &AttrList);\n\n  void ActOnSuperClassOfClassInterface(Scope *S,\n                                       SourceLocation AtInterfaceLoc,\n                                       ObjCInterfaceDecl *IDecl,\n                                       IdentifierInfo *ClassName,\n                                       SourceLocation ClassLoc,\n                                       IdentifierInfo *SuperName,\n                                       SourceLocation SuperLoc,\n                                       ArrayRef<ParsedType> SuperTypeArgs,\n                                       SourceRange SuperTypeArgsRange);\n\n  void ActOnTypedefedProtocols(SmallVectorImpl<Decl *> &ProtocolRefs,\n                               SmallVectorImpl<SourceLocation> &ProtocolLocs,\n                               IdentifierInfo *SuperName,\n                               SourceLocation SuperLoc);\n\n  Decl *ActOnCompatibilityAlias(\n                    SourceLocation AtCompatibilityAliasLoc,\n                    IdentifierInfo *AliasName,  SourceLocation AliasLocation,\n                    IdentifierInfo *ClassName, SourceLocation ClassLocation);\n\n  bool CheckForwardProtocolDeclarationForCircularDependency(\n    IdentifierInfo *PName,\n    SourceLocation &PLoc, SourceLocation PrevLoc,\n    const ObjCList<ObjCProtocolDecl> &PList);\n\n  Decl *ActOnStartProtocolInterface(\n      SourceLocation AtProtoInterfaceLoc, IdentifierInfo *ProtocolName,\n      SourceLocation ProtocolLoc, Decl *const *ProtoRefNames,\n      unsigned NumProtoRefs, const SourceLocation *ProtoLocs,\n      SourceLocation EndProtoLoc, const ParsedAttributesView &AttrList);\n\n  Decl *ActOnStartCategoryInterface(\n      SourceLocation AtInterfaceLoc, IdentifierInfo *ClassName,\n      SourceLocation ClassLoc, ObjCTypeParamList *typeParamList,\n      IdentifierInfo *CategoryName, SourceLocation CategoryLoc,\n      Decl *const *ProtoRefs, unsigned NumProtoRefs,\n      const SourceLocation *ProtoLocs, SourceLocation EndProtoLoc,\n      const ParsedAttributesView &AttrList);\n\n  Decl *ActOnStartClassImplementation(SourceLocation AtClassImplLoc,\n                                      IdentifierInfo *ClassName,\n                                      SourceLocation ClassLoc,\n                                      IdentifierInfo *SuperClassname,\n                                      SourceLocation SuperClassLoc,\n                                      const ParsedAttributesView &AttrList);\n\n  Decl *ActOnStartCategoryImplementation(SourceLocation AtCatImplLoc,\n                                         IdentifierInfo *ClassName,\n                                         SourceLocation ClassLoc,\n                                         IdentifierInfo *CatName,\n                                         SourceLocation CatLoc,\n                                         const ParsedAttributesView &AttrList);\n\n  DeclGroupPtrTy ActOnFinishObjCImplementation(Decl *ObjCImpDecl,\n                                               ArrayRef<Decl *> Decls);\n\n  DeclGroupPtrTy ActOnForwardClassDeclaration(SourceLocation Loc,\n                   IdentifierInfo **IdentList,\n                   SourceLocation *IdentLocs,\n                   ArrayRef<ObjCTypeParamList *> TypeParamLists,\n                   unsigned NumElts);\n\n  DeclGroupPtrTy\n  ActOnForwardProtocolDeclaration(SourceLocation AtProtoclLoc,\n                                  ArrayRef<IdentifierLocPair> IdentList,\n                                  const ParsedAttributesView &attrList);\n\n  void FindProtocolDeclaration(bool WarnOnDeclarations, bool ForObjCContainer,\n                               ArrayRef<IdentifierLocPair> ProtocolId,\n                               SmallVectorImpl<Decl *> &Protocols);\n\n  void DiagnoseTypeArgsAndProtocols(IdentifierInfo *ProtocolId,\n                                    SourceLocation ProtocolLoc,\n                                    IdentifierInfo *TypeArgId,\n                                    SourceLocation TypeArgLoc,\n                                    bool SelectProtocolFirst = false);\n\n  /// Given a list of identifiers (and their locations), resolve the\n  /// names to either Objective-C protocol qualifiers or type\n  /// arguments, as appropriate.\n  void actOnObjCTypeArgsOrProtocolQualifiers(\n         Scope *S,\n         ParsedType baseType,\n         SourceLocation lAngleLoc,\n         ArrayRef<IdentifierInfo *> identifiers,\n         ArrayRef<SourceLocation> identifierLocs,\n         SourceLocation rAngleLoc,\n         SourceLocation &typeArgsLAngleLoc,\n         SmallVectorImpl<ParsedType> &typeArgs,\n         SourceLocation &typeArgsRAngleLoc,\n         SourceLocation &protocolLAngleLoc,\n         SmallVectorImpl<Decl *> &protocols,\n         SourceLocation &protocolRAngleLoc,\n         bool warnOnIncompleteProtocols);\n\n  /// Build a an Objective-C protocol-qualified 'id' type where no\n  /// base type was specified.\n  TypeResult actOnObjCProtocolQualifierType(\n               SourceLocation lAngleLoc,\n               ArrayRef<Decl *> protocols,\n               ArrayRef<SourceLocation> protocolLocs,\n               SourceLocation rAngleLoc);\n\n  /// Build a specialized and/or protocol-qualified Objective-C type.\n  TypeResult actOnObjCTypeArgsAndProtocolQualifiers(\n               Scope *S,\n               SourceLocation Loc,\n               ParsedType BaseType,\n               SourceLocation TypeArgsLAngleLoc,\n               ArrayRef<ParsedType> TypeArgs,\n               SourceLocation TypeArgsRAngleLoc,\n               SourceLocation ProtocolLAngleLoc,\n               ArrayRef<Decl *> Protocols,\n               ArrayRef<SourceLocation> ProtocolLocs,\n               SourceLocation ProtocolRAngleLoc);\n\n  /// Build an Objective-C type parameter type.\n  QualType BuildObjCTypeParamType(const ObjCTypeParamDecl *Decl,\n                                  SourceLocation ProtocolLAngleLoc,\n                                  ArrayRef<ObjCProtocolDecl *> Protocols,\n                                  ArrayRef<SourceLocation> ProtocolLocs,\n                                  SourceLocation ProtocolRAngleLoc,\n                                  bool FailOnError = false);\n\n  /// Build an Objective-C object pointer type.\n  QualType BuildObjCObjectType(QualType BaseType,\n                               SourceLocation Loc,\n                               SourceLocation TypeArgsLAngleLoc,\n                               ArrayRef<TypeSourceInfo *> TypeArgs,\n                               SourceLocation TypeArgsRAngleLoc,\n                               SourceLocation ProtocolLAngleLoc,\n                               ArrayRef<ObjCProtocolDecl *> Protocols,\n                               ArrayRef<SourceLocation> ProtocolLocs,\n                               SourceLocation ProtocolRAngleLoc,\n                               bool FailOnError = false);\n\n  /// Ensure attributes are consistent with type.\n  /// \\param [in, out] Attributes The attributes to check; they will\n  /// be modified to be consistent with \\p PropertyTy.\n  void CheckObjCPropertyAttributes(Decl *PropertyPtrTy,\n                                   SourceLocation Loc,\n                                   unsigned &Attributes,\n                                   bool propertyInPrimaryClass);\n\n  /// Process the specified property declaration and create decls for the\n  /// setters and getters as needed.\n  /// \\param property The property declaration being processed\n  void ProcessPropertyDecl(ObjCPropertyDecl *property);\n\n\n  void DiagnosePropertyMismatch(ObjCPropertyDecl *Property,\n                                ObjCPropertyDecl *SuperProperty,\n                                const IdentifierInfo *Name,\n                                bool OverridingProtocolProperty);\n\n  void DiagnoseClassExtensionDupMethods(ObjCCategoryDecl *CAT,\n                                        ObjCInterfaceDecl *ID);\n\n  Decl *ActOnAtEnd(Scope *S, SourceRange AtEnd,\n                   ArrayRef<Decl *> allMethods = None,\n                   ArrayRef<DeclGroupPtrTy> allTUVars = None);\n\n  Decl *ActOnProperty(Scope *S, SourceLocation AtLoc,\n                      SourceLocation LParenLoc,\n                      FieldDeclarator &FD, ObjCDeclSpec &ODS,\n                      Selector GetterSel, Selector SetterSel,\n                      tok::ObjCKeywordKind MethodImplKind,\n                      DeclContext *lexicalDC = nullptr);\n\n  Decl *ActOnPropertyImplDecl(Scope *S,\n                              SourceLocation AtLoc,\n                              SourceLocation PropertyLoc,\n                              bool ImplKind,\n                              IdentifierInfo *PropertyId,\n                              IdentifierInfo *PropertyIvar,\n                              SourceLocation PropertyIvarLoc,\n                              ObjCPropertyQueryKind QueryKind);\n\n  enum ObjCSpecialMethodKind {\n    OSMK_None,\n    OSMK_Alloc,\n    OSMK_New,\n    OSMK_Copy,\n    OSMK_RetainingInit,\n    OSMK_NonRetainingInit\n  };\n\n  struct ObjCArgInfo {\n    IdentifierInfo *Name;\n    SourceLocation NameLoc;\n    // The Type is null if no type was specified, and the DeclSpec is invalid\n    // in this case.\n    ParsedType Type;\n    ObjCDeclSpec DeclSpec;\n\n    /// ArgAttrs - Attribute list for this argument.\n    ParsedAttributesView ArgAttrs;\n  };\n\n  Decl *ActOnMethodDeclaration(\n      Scope *S,\n      SourceLocation BeginLoc, // location of the + or -.\n      SourceLocation EndLoc,   // location of the ; or {.\n      tok::TokenKind MethodType, ObjCDeclSpec &ReturnQT, ParsedType ReturnType,\n      ArrayRef<SourceLocation> SelectorLocs, Selector Sel,\n      // optional arguments. The number of types/arguments is obtained\n      // from the Sel.getNumArgs().\n      ObjCArgInfo *ArgInfo, DeclaratorChunk::ParamInfo *CParamInfo,\n      unsigned CNumArgs, // c-style args\n      const ParsedAttributesView &AttrList, tok::ObjCKeywordKind MethodImplKind,\n      bool isVariadic, bool MethodDefinition);\n\n  ObjCMethodDecl *LookupMethodInQualifiedType(Selector Sel,\n                                              const ObjCObjectPointerType *OPT,\n                                              bool IsInstance);\n  ObjCMethodDecl *LookupMethodInObjectType(Selector Sel, QualType Ty,\n                                           bool IsInstance);\n\n  bool CheckARCMethodDecl(ObjCMethodDecl *method);\n  bool inferObjCARCLifetime(ValueDecl *decl);\n\n  void deduceOpenCLAddressSpace(ValueDecl *decl);\n\n  ExprResult\n  HandleExprPropertyRefExpr(const ObjCObjectPointerType *OPT,\n                            Expr *BaseExpr,\n                            SourceLocation OpLoc,\n                            DeclarationName MemberName,\n                            SourceLocation MemberLoc,\n                            SourceLocation SuperLoc, QualType SuperType,\n                            bool Super);\n\n  ExprResult\n  ActOnClassPropertyRefExpr(IdentifierInfo &receiverName,\n                            IdentifierInfo &propertyName,\n                            SourceLocation receiverNameLoc,\n                            SourceLocation propertyNameLoc);\n\n  ObjCMethodDecl *tryCaptureObjCSelf(SourceLocation Loc);\n\n  /// Describes the kind of message expression indicated by a message\n  /// send that starts with an identifier.\n  enum ObjCMessageKind {\n    /// The message is sent to 'super'.\n    ObjCSuperMessage,\n    /// The message is an instance message.\n    ObjCInstanceMessage,\n    /// The message is a class message, and the identifier is a type\n    /// name.\n    ObjCClassMessage\n  };\n\n  ObjCMessageKind getObjCMessageKind(Scope *S,\n                                     IdentifierInfo *Name,\n                                     SourceLocation NameLoc,\n                                     bool IsSuper,\n                                     bool HasTrailingDot,\n                                     ParsedType &ReceiverType);\n\n  ExprResult ActOnSuperMessage(Scope *S, SourceLocation SuperLoc,\n                               Selector Sel,\n                               SourceLocation LBracLoc,\n                               ArrayRef<SourceLocation> SelectorLocs,\n                               SourceLocation RBracLoc,\n                               MultiExprArg Args);\n\n  ExprResult BuildClassMessage(TypeSourceInfo *ReceiverTypeInfo,\n                               QualType ReceiverType,\n                               SourceLocation SuperLoc,\n                               Selector Sel,\n                               ObjCMethodDecl *Method,\n                               SourceLocation LBracLoc,\n                               ArrayRef<SourceLocation> SelectorLocs,\n                               SourceLocation RBracLoc,\n                               MultiExprArg Args,\n                               bool isImplicit = false);\n\n  ExprResult BuildClassMessageImplicit(QualType ReceiverType,\n                                       bool isSuperReceiver,\n                                       SourceLocation Loc,\n                                       Selector Sel,\n                                       ObjCMethodDecl *Method,\n                                       MultiExprArg Args);\n\n  ExprResult ActOnClassMessage(Scope *S,\n                               ParsedType Receiver,\n                               Selector Sel,\n                               SourceLocation LBracLoc,\n                               ArrayRef<SourceLocation> SelectorLocs,\n                               SourceLocation RBracLoc,\n                               MultiExprArg Args);\n\n  ExprResult BuildInstanceMessage(Expr *Receiver,\n                                  QualType ReceiverType,\n                                  SourceLocation SuperLoc,\n                                  Selector Sel,\n                                  ObjCMethodDecl *Method,\n                                  SourceLocation LBracLoc,\n                                  ArrayRef<SourceLocation> SelectorLocs,\n                                  SourceLocation RBracLoc,\n                                  MultiExprArg Args,\n                                  bool isImplicit = false);\n\n  ExprResult BuildInstanceMessageImplicit(Expr *Receiver,\n                                          QualType ReceiverType,\n                                          SourceLocation Loc,\n                                          Selector Sel,\n                                          ObjCMethodDecl *Method,\n                                          MultiExprArg Args);\n\n  ExprResult ActOnInstanceMessage(Scope *S,\n                                  Expr *Receiver,\n                                  Selector Sel,\n                                  SourceLocation LBracLoc,\n                                  ArrayRef<SourceLocation> SelectorLocs,\n                                  SourceLocation RBracLoc,\n                                  MultiExprArg Args);\n\n  ExprResult BuildObjCBridgedCast(SourceLocation LParenLoc,\n                                  ObjCBridgeCastKind Kind,\n                                  SourceLocation BridgeKeywordLoc,\n                                  TypeSourceInfo *TSInfo,\n                                  Expr *SubExpr);\n\n  ExprResult ActOnObjCBridgedCast(Scope *S,\n                                  SourceLocation LParenLoc,\n                                  ObjCBridgeCastKind Kind,\n                                  SourceLocation BridgeKeywordLoc,\n                                  ParsedType Type,\n                                  SourceLocation RParenLoc,\n                                  Expr *SubExpr);\n\n  void CheckTollFreeBridgeCast(QualType castType, Expr *castExpr);\n\n  void CheckObjCBridgeRelatedCast(QualType castType, Expr *castExpr);\n\n  bool CheckTollFreeBridgeStaticCast(QualType castType, Expr *castExpr,\n                                     CastKind &Kind);\n\n  bool checkObjCBridgeRelatedComponents(SourceLocation Loc,\n                                        QualType DestType, QualType SrcType,\n                                        ObjCInterfaceDecl *&RelatedClass,\n                                        ObjCMethodDecl *&ClassMethod,\n                                        ObjCMethodDecl *&InstanceMethod,\n                                        TypedefNameDecl *&TDNDecl,\n                                        bool CfToNs, bool Diagnose = true);\n\n  bool CheckObjCBridgeRelatedConversions(SourceLocation Loc,\n                                         QualType DestType, QualType SrcType,\n                                         Expr *&SrcExpr, bool Diagnose = true);\n\n  bool CheckConversionToObjCLiteral(QualType DstType, Expr *&SrcExpr,\n                                    bool Diagnose = true);\n\n  bool checkInitMethod(ObjCMethodDecl *method, QualType receiverTypeIfCall);\n\n  /// Check whether the given new method is a valid override of the\n  /// given overridden method, and set any properties that should be inherited.\n  void CheckObjCMethodOverride(ObjCMethodDecl *NewMethod,\n                               const ObjCMethodDecl *Overridden);\n\n  /// Describes the compatibility of a result type with its method.\n  enum ResultTypeCompatibilityKind {\n    RTC_Compatible,\n    RTC_Incompatible,\n    RTC_Unknown\n  };\n\n  void CheckObjCMethodDirectOverrides(ObjCMethodDecl *method,\n                                      ObjCMethodDecl *overridden);\n\n  void CheckObjCMethodOverrides(ObjCMethodDecl *ObjCMethod,\n                                ObjCInterfaceDecl *CurrentClass,\n                                ResultTypeCompatibilityKind RTC);\n\n  enum PragmaOptionsAlignKind {\n    POAK_Native,  // #pragma options align=native\n    POAK_Natural, // #pragma options align=natural\n    POAK_Packed,  // #pragma options align=packed\n    POAK_Power,   // #pragma options align=power\n    POAK_Mac68k,  // #pragma options align=mac68k\n    POAK_Reset    // #pragma options align=reset\n  };\n\n  /// ActOnPragmaClangSection - Called on well formed \\#pragma clang section\n  void ActOnPragmaClangSection(SourceLocation PragmaLoc,\n                               PragmaClangSectionAction Action,\n                               PragmaClangSectionKind SecKind, StringRef SecName);\n\n  /// ActOnPragmaOptionsAlign - Called on well formed \\#pragma options align.\n  void ActOnPragmaOptionsAlign(PragmaOptionsAlignKind Kind,\n                               SourceLocation PragmaLoc);\n\n  /// ActOnPragmaPack - Called on well formed \\#pragma pack(...).\n  void ActOnPragmaPack(SourceLocation PragmaLoc, PragmaMsStackAction Action,\n                       StringRef SlotLabel, Expr *Alignment);\n\n  enum class PragmaAlignPackDiagnoseKind {\n    NonDefaultStateAtInclude,\n    ChangedStateAtExit\n  };\n\n  void DiagnoseNonDefaultPragmaAlignPack(PragmaAlignPackDiagnoseKind Kind,\n                                         SourceLocation IncludeLoc);\n  void DiagnoseUnterminatedPragmaAlignPack();\n\n  /// ActOnPragmaMSStruct - Called on well formed \\#pragma ms_struct [on|off].\n  void ActOnPragmaMSStruct(PragmaMSStructKind Kind);\n\n  /// ActOnPragmaMSComment - Called on well formed\n  /// \\#pragma comment(kind, \"arg\").\n  void ActOnPragmaMSComment(SourceLocation CommentLoc, PragmaMSCommentKind Kind,\n                            StringRef Arg);\n\n  /// ActOnPragmaMSPointersToMembers - called on well formed \\#pragma\n  /// pointers_to_members(representation method[, general purpose\n  /// representation]).\n  void ActOnPragmaMSPointersToMembers(\n      LangOptions::PragmaMSPointersToMembersKind Kind,\n      SourceLocation PragmaLoc);\n\n  /// Called on well formed \\#pragma vtordisp().\n  void ActOnPragmaMSVtorDisp(PragmaMsStackAction Action,\n                             SourceLocation PragmaLoc,\n                             MSVtorDispMode Value);\n\n  enum PragmaSectionKind {\n    PSK_DataSeg,\n    PSK_BSSSeg,\n    PSK_ConstSeg,\n    PSK_CodeSeg,\n  };\n\n  bool UnifySection(StringRef SectionName, int SectionFlags,\n                    NamedDecl *TheDecl);\n  bool UnifySection(StringRef SectionName,\n                    int SectionFlags,\n                    SourceLocation PragmaSectionLocation);\n\n  /// Called on well formed \\#pragma bss_seg/data_seg/const_seg/code_seg.\n  void ActOnPragmaMSSeg(SourceLocation PragmaLocation,\n                        PragmaMsStackAction Action,\n                        llvm::StringRef StackSlotLabel,\n                        StringLiteral *SegmentName,\n                        llvm::StringRef PragmaName);\n\n  /// Called on well formed \\#pragma section().\n  void ActOnPragmaMSSection(SourceLocation PragmaLocation,\n                            int SectionFlags, StringLiteral *SegmentName);\n\n  /// Called on well-formed \\#pragma init_seg().\n  void ActOnPragmaMSInitSeg(SourceLocation PragmaLocation,\n                            StringLiteral *SegmentName);\n\n  /// Called on #pragma clang __debug dump II\n  void ActOnPragmaDump(Scope *S, SourceLocation Loc, IdentifierInfo *II);\n\n  /// ActOnPragmaDetectMismatch - Call on well-formed \\#pragma detect_mismatch\n  void ActOnPragmaDetectMismatch(SourceLocation Loc, StringRef Name,\n                                 StringRef Value);\n\n  /// Are precise floating point semantics currently enabled?\n  bool isPreciseFPEnabled() {\n    return !CurFPFeatures.getAllowFPReassociate() &&\n           !CurFPFeatures.getNoSignedZero() &&\n           !CurFPFeatures.getAllowReciprocal() &&\n           !CurFPFeatures.getAllowApproxFunc();\n  }\n\n  /// ActOnPragmaFloatControl - Call on well-formed \\#pragma float_control\n  void ActOnPragmaFloatControl(SourceLocation Loc, PragmaMsStackAction Action,\n                               PragmaFloatControlKind Value);\n\n  /// ActOnPragmaUnused - Called on well-formed '\\#pragma unused'.\n  void ActOnPragmaUnused(const Token &Identifier,\n                         Scope *curScope,\n                         SourceLocation PragmaLoc);\n\n  /// ActOnPragmaVisibility - Called on well formed \\#pragma GCC visibility... .\n  void ActOnPragmaVisibility(const IdentifierInfo* VisType,\n                             SourceLocation PragmaLoc);\n\n  NamedDecl *DeclClonePragmaWeak(NamedDecl *ND, IdentifierInfo *II,\n                                 SourceLocation Loc);\n  void DeclApplyPragmaWeak(Scope *S, NamedDecl *ND, WeakInfo &W);\n\n  /// ActOnPragmaWeakID - Called on well formed \\#pragma weak ident.\n  void ActOnPragmaWeakID(IdentifierInfo* WeakName,\n                         SourceLocation PragmaLoc,\n                         SourceLocation WeakNameLoc);\n\n  /// ActOnPragmaRedefineExtname - Called on well formed\n  /// \\#pragma redefine_extname oldname newname.\n  void ActOnPragmaRedefineExtname(IdentifierInfo* WeakName,\n                                  IdentifierInfo* AliasName,\n                                  SourceLocation PragmaLoc,\n                                  SourceLocation WeakNameLoc,\n                                  SourceLocation AliasNameLoc);\n\n  /// ActOnPragmaWeakAlias - Called on well formed \\#pragma weak ident = ident.\n  void ActOnPragmaWeakAlias(IdentifierInfo* WeakName,\n                            IdentifierInfo* AliasName,\n                            SourceLocation PragmaLoc,\n                            SourceLocation WeakNameLoc,\n                            SourceLocation AliasNameLoc);\n\n  /// ActOnPragmaFPContract - Called on well formed\n  /// \\#pragma {STDC,OPENCL} FP_CONTRACT and\n  /// \\#pragma clang fp contract\n  void ActOnPragmaFPContract(SourceLocation Loc, LangOptions::FPModeKind FPC);\n\n  /// Called on well formed\n  /// \\#pragma clang fp reassociate\n  void ActOnPragmaFPReassociate(SourceLocation Loc, bool IsEnabled);\n\n  /// ActOnPragmaFenvAccess - Called on well formed\n  /// \\#pragma STDC FENV_ACCESS\n  void ActOnPragmaFEnvAccess(SourceLocation Loc, bool IsEnabled);\n\n  /// Called on well formed '\\#pragma clang fp' that has option 'exceptions'.\n  void ActOnPragmaFPExceptions(SourceLocation Loc,\n                               LangOptions::FPExceptionModeKind);\n\n  /// Called to set constant rounding mode for floating point operations.\n  void setRoundingMode(SourceLocation Loc, llvm::RoundingMode);\n\n  /// Called to set exception behavior for floating point operations.\n  void setExceptionMode(SourceLocation Loc, LangOptions::FPExceptionModeKind);\n\n  /// AddAlignmentAttributesForRecord - Adds any needed alignment attributes to\n  /// a the record decl, to handle '\\#pragma pack' and '\\#pragma options align'.\n  void AddAlignmentAttributesForRecord(RecordDecl *RD);\n\n  /// AddMsStructLayoutForRecord - Adds ms_struct layout attribute to record.\n  void AddMsStructLayoutForRecord(RecordDecl *RD);\n\n  /// PushNamespaceVisibilityAttr - Note that we've entered a\n  /// namespace with a visibility attribute.\n  void PushNamespaceVisibilityAttr(const VisibilityAttr *Attr,\n                                   SourceLocation Loc);\n\n  /// AddPushedVisibilityAttribute - If '\\#pragma GCC visibility' was used,\n  /// add an appropriate visibility attribute.\n  void AddPushedVisibilityAttribute(Decl *RD);\n\n  /// PopPragmaVisibility - Pop the top element of the visibility stack; used\n  /// for '\\#pragma GCC visibility' and visibility attributes on namespaces.\n  void PopPragmaVisibility(bool IsNamespaceEnd, SourceLocation EndLoc);\n\n  /// FreeVisContext - Deallocate and null out VisContext.\n  void FreeVisContext();\n\n  /// AddCFAuditedAttribute - Check whether we're currently within\n  /// '\\#pragma clang arc_cf_code_audited' and, if so, consider adding\n  /// the appropriate attribute.\n  void AddCFAuditedAttribute(Decl *D);\n\n  void ActOnPragmaAttributeAttribute(ParsedAttr &Attribute,\n                                     SourceLocation PragmaLoc,\n                                     attr::ParsedSubjectMatchRuleSet Rules);\n  void ActOnPragmaAttributeEmptyPush(SourceLocation PragmaLoc,\n                                     const IdentifierInfo *Namespace);\n\n  /// Called on well-formed '\\#pragma clang attribute pop'.\n  void ActOnPragmaAttributePop(SourceLocation PragmaLoc,\n                               const IdentifierInfo *Namespace);\n\n  /// Adds the attributes that have been specified using the\n  /// '\\#pragma clang attribute push' directives to the given declaration.\n  void AddPragmaAttributes(Scope *S, Decl *D);\n\n  void DiagnoseUnterminatedPragmaAttribute();\n\n  /// Called on well formed \\#pragma clang optimize.\n  void ActOnPragmaOptimize(bool On, SourceLocation PragmaLoc);\n\n  /// Get the location for the currently active \"\\#pragma clang optimize\n  /// off\". If this location is invalid, then the state of the pragma is \"on\".\n  SourceLocation getOptimizeOffPragmaLocation() const {\n    return OptimizeOffPragmaLocation;\n  }\n\n  /// Only called on function definitions; if there is a pragma in scope\n  /// with the effect of a range-based optnone, consider marking the function\n  /// with attribute optnone.\n  void AddRangeBasedOptnone(FunctionDecl *FD);\n\n  /// Adds the 'optnone' attribute to the function declaration if there\n  /// are no conflicts; Loc represents the location causing the 'optnone'\n  /// attribute to be added (usually because of a pragma).\n  void AddOptnoneAttributeIfNoConflicts(FunctionDecl *FD, SourceLocation Loc);\n\n  /// AddAlignedAttr - Adds an aligned attribute to a particular declaration.\n  void AddAlignedAttr(Decl *D, const AttributeCommonInfo &CI, Expr *E,\n                      bool IsPackExpansion);\n  void AddAlignedAttr(Decl *D, const AttributeCommonInfo &CI, TypeSourceInfo *T,\n                      bool IsPackExpansion);\n\n  /// AddAssumeAlignedAttr - Adds an assume_aligned attribute to a particular\n  /// declaration.\n  void AddAssumeAlignedAttr(Decl *D, const AttributeCommonInfo &CI, Expr *E,\n                            Expr *OE);\n\n  /// AddAllocAlignAttr - Adds an alloc_align attribute to a particular\n  /// declaration.\n  void AddAllocAlignAttr(Decl *D, const AttributeCommonInfo &CI,\n                         Expr *ParamExpr);\n\n  /// AddAlignValueAttr - Adds an align_value attribute to a particular\n  /// declaration.\n  void AddAlignValueAttr(Decl *D, const AttributeCommonInfo &CI, Expr *E);\n\n  /// AddAnnotationAttr - Adds an annotation Annot with Args arguments to D.\n  void AddAnnotationAttr(Decl *D, const AttributeCommonInfo &CI,\n                         StringRef Annot, MutableArrayRef<Expr *> Args);\n\n  /// AddLaunchBoundsAttr - Adds a launch_bounds attribute to a particular\n  /// declaration.\n  void AddLaunchBoundsAttr(Decl *D, const AttributeCommonInfo &CI,\n                           Expr *MaxThreads, Expr *MinBlocks);\n\n  /// AddModeAttr - Adds a mode attribute to a particular declaration.\n  void AddModeAttr(Decl *D, const AttributeCommonInfo &CI, IdentifierInfo *Name,\n                   bool InInstantiation = false);\n\n  void AddParameterABIAttr(Decl *D, const AttributeCommonInfo &CI,\n                           ParameterABI ABI);\n\n  enum class RetainOwnershipKind {NS, CF, OS};\n  void AddXConsumedAttr(Decl *D, const AttributeCommonInfo &CI,\n                        RetainOwnershipKind K, bool IsTemplateInstantiation);\n\n  /// addAMDGPUFlatWorkGroupSizeAttr - Adds an amdgpu_flat_work_group_size\n  /// attribute to a particular declaration.\n  void addAMDGPUFlatWorkGroupSizeAttr(Decl *D, const AttributeCommonInfo &CI,\n                                      Expr *Min, Expr *Max);\n\n  /// addAMDGPUWavePersEUAttr - Adds an amdgpu_waves_per_eu attribute to a\n  /// particular declaration.\n  void addAMDGPUWavesPerEUAttr(Decl *D, const AttributeCommonInfo &CI,\n                               Expr *Min, Expr *Max);\n\n  bool checkNSReturnsRetainedReturnType(SourceLocation loc, QualType type);\n\n  //===--------------------------------------------------------------------===//\n  // C++ Coroutines TS\n  //\n  bool ActOnCoroutineBodyStart(Scope *S, SourceLocation KwLoc,\n                               StringRef Keyword);\n  ExprResult ActOnCoawaitExpr(Scope *S, SourceLocation KwLoc, Expr *E);\n  ExprResult ActOnCoyieldExpr(Scope *S, SourceLocation KwLoc, Expr *E);\n  StmtResult ActOnCoreturnStmt(Scope *S, SourceLocation KwLoc, Expr *E);\n\n  ExprResult BuildResolvedCoawaitExpr(SourceLocation KwLoc, Expr *E,\n                                      bool IsImplicit = false);\n  ExprResult BuildUnresolvedCoawaitExpr(SourceLocation KwLoc, Expr *E,\n                                        UnresolvedLookupExpr* Lookup);\n  ExprResult BuildCoyieldExpr(SourceLocation KwLoc, Expr *E);\n  StmtResult BuildCoreturnStmt(SourceLocation KwLoc, Expr *E,\n                               bool IsImplicit = false);\n  StmtResult BuildCoroutineBodyStmt(CoroutineBodyStmt::CtorArgs);\n  bool buildCoroutineParameterMoves(SourceLocation Loc);\n  VarDecl *buildCoroutinePromise(SourceLocation Loc);\n  void CheckCompletedCoroutineBody(FunctionDecl *FD, Stmt *&Body);\n  ClassTemplateDecl *lookupCoroutineTraits(SourceLocation KwLoc,\n                                           SourceLocation FuncLoc);\n  /// Check that the expression co_await promise.final_suspend() shall not be\n  /// potentially-throwing.\n  bool checkFinalSuspendNoThrow(const Stmt *FinalSuspend);\n\n  //===--------------------------------------------------------------------===//\n  // OpenCL extensions.\n  //\nprivate:\n  std::string CurrOpenCLExtension;\n  /// Extensions required by an OpenCL type.\n  llvm::DenseMap<const Type*, std::set<std::string>> OpenCLTypeExtMap;\n  /// Extensions required by an OpenCL declaration.\n  llvm::DenseMap<const Decl*, std::set<std::string>> OpenCLDeclExtMap;\npublic:\n  llvm::StringRef getCurrentOpenCLExtension() const {\n    return CurrOpenCLExtension;\n  }\n\n  /// Check if a function declaration \\p FD associates with any\n  /// extensions present in OpenCLDeclExtMap and if so return the\n  /// extension(s) name(s).\n  std::string getOpenCLExtensionsFromDeclExtMap(FunctionDecl *FD);\n\n  /// Check if a function type \\p FT associates with any\n  /// extensions present in OpenCLTypeExtMap and if so return the\n  /// extension(s) name(s).\n  std::string getOpenCLExtensionsFromTypeExtMap(FunctionType *FT);\n\n  /// Find an extension in an appropriate extension map and return its name\n  template<typename T, typename MapT>\n  std::string getOpenCLExtensionsFromExtMap(T* FT, MapT &Map);\n\n  void setCurrentOpenCLExtension(llvm::StringRef Ext) {\n    CurrOpenCLExtension = std::string(Ext);\n  }\n\n  /// Set OpenCL extensions for a type which can only be used when these\n  /// OpenCL extensions are enabled. If \\p Exts is empty, do nothing.\n  /// \\param Exts A space separated list of OpenCL extensions.\n  void setOpenCLExtensionForType(QualType T, llvm::StringRef Exts);\n\n  /// Set OpenCL extensions for a declaration which can only be\n  /// used when these OpenCL extensions are enabled. If \\p Exts is empty, do\n  /// nothing.\n  /// \\param Exts A space separated list of OpenCL extensions.\n  void setOpenCLExtensionForDecl(Decl *FD, llvm::StringRef Exts);\n\n  /// Set current OpenCL extensions for a type which can only be used\n  /// when these OpenCL extensions are enabled. If current OpenCL extension is\n  /// empty, do nothing.\n  void setCurrentOpenCLExtensionForType(QualType T);\n\n  /// Set current OpenCL extensions for a declaration which\n  /// can only be used when these OpenCL extensions are enabled. If current\n  /// OpenCL extension is empty, do nothing.\n  void setCurrentOpenCLExtensionForDecl(Decl *FD);\n\n  bool isOpenCLDisabledDecl(Decl *FD);\n\n  /// Check if type \\p T corresponding to declaration specifier \\p DS\n  /// is disabled due to required OpenCL extensions being disabled. If so,\n  /// emit diagnostics.\n  /// \\return true if type is disabled.\n  bool checkOpenCLDisabledTypeDeclSpec(const DeclSpec &DS, QualType T);\n\n  /// Check if declaration \\p D used by expression \\p E\n  /// is disabled due to required OpenCL extensions being disabled. If so,\n  /// emit diagnostics.\n  /// \\return true if type is disabled.\n  bool checkOpenCLDisabledDecl(const NamedDecl &D, const Expr &E);\n\n  //===--------------------------------------------------------------------===//\n  // OpenMP directives and clauses.\n  //\nprivate:\n  void *VarDataSharingAttributesStack;\n  /// Number of nested '#pragma omp declare target' directives.\n  SmallVector<SourceLocation, 4> DeclareTargetNesting;\n  /// Initialization of data-sharing attributes stack.\n  void InitDataSharingAttributesStack();\n  void DestroyDataSharingAttributesStack();\n  ExprResult\n  VerifyPositiveIntegerConstantInClause(Expr *Op, OpenMPClauseKind CKind,\n                                        bool StrictlyPositive = true);\n  /// Returns OpenMP nesting level for current directive.\n  unsigned getOpenMPNestingLevel() const;\n\n  /// Adjusts the function scopes index for the target-based regions.\n  void adjustOpenMPTargetScopeIndex(unsigned &FunctionScopesIndex,\n                                    unsigned Level) const;\n\n  /// Returns the number of scopes associated with the construct on the given\n  /// OpenMP level.\n  int getNumberOfConstructScopes(unsigned Level) const;\n\n  /// Push new OpenMP function region for non-capturing function.\n  void pushOpenMPFunctionRegion();\n\n  /// Pop OpenMP function region for non-capturing function.\n  void popOpenMPFunctionRegion(const sema::FunctionScopeInfo *OldFSI);\n\n  /// Checks if a type or a declaration is disabled due to the owning extension\n  /// being disabled, and emits diagnostic messages if it is disabled.\n  /// \\param D type or declaration to be checked.\n  /// \\param DiagLoc source location for the diagnostic message.\n  /// \\param DiagInfo information to be emitted for the diagnostic message.\n  /// \\param SrcRange source range of the declaration.\n  /// \\param Map maps type or declaration to the extensions.\n  /// \\param Selector selects diagnostic message: 0 for type and 1 for\n  ///        declaration.\n  /// \\return true if the type or declaration is disabled.\n  template <typename T, typename DiagLocT, typename DiagInfoT, typename MapT>\n  bool checkOpenCLDisabledTypeOrDecl(T D, DiagLocT DiagLoc, DiagInfoT DiagInfo,\n                                     MapT &Map, unsigned Selector = 0,\n                                     SourceRange SrcRange = SourceRange());\n\n  /// Helper to keep information about the current `omp begin/end declare\n  /// variant` nesting.\n  struct OMPDeclareVariantScope {\n    /// The associated OpenMP context selector.\n    OMPTraitInfo *TI;\n\n    /// The associated OpenMP context selector mangling.\n    std::string NameSuffix;\n\n    OMPDeclareVariantScope(OMPTraitInfo &TI);\n  };\n\n  /// Return the OMPTraitInfo for the surrounding scope, if any.\n  OMPTraitInfo *getOMPTraitInfoForSurroundingScope() {\n    return OMPDeclareVariantScopes.empty() ? nullptr\n                                           : OMPDeclareVariantScopes.back().TI;\n  }\n\n  /// The current `omp begin/end declare variant` scopes.\n  SmallVector<OMPDeclareVariantScope, 4> OMPDeclareVariantScopes;\n\n  /// The current `omp begin/end assumes` scopes.\n  SmallVector<AssumptionAttr *, 4> OMPAssumeScoped;\n\n  /// All `omp assumes` we encountered so far.\n  SmallVector<AssumptionAttr *, 4> OMPAssumeGlobal;\n\npublic:\n  /// The declarator \\p D defines a function in the scope \\p S which is nested\n  /// in an `omp begin/end declare variant` scope. In this method we create a\n  /// declaration for \\p D and rename \\p D according to the OpenMP context\n  /// selector of the surrounding scope. Return all base functions in \\p Bases.\n  void ActOnStartOfFunctionDefinitionInOpenMPDeclareVariantScope(\n      Scope *S, Declarator &D, MultiTemplateParamsArg TemplateParameterLists,\n      SmallVectorImpl<FunctionDecl *> &Bases);\n\n  /// Register \\p D as specialization of all base functions in \\p Bases in the\n  /// current `omp begin/end declare variant` scope.\n  void ActOnFinishedFunctionDefinitionInOpenMPDeclareVariantScope(\n      Decl *D, SmallVectorImpl<FunctionDecl *> &Bases);\n\n  /// Act on \\p D, a function definition inside of an `omp [begin/end] assumes`.\n  void ActOnFinishedFunctionDefinitionInOpenMPAssumeScope(Decl *D);\n\n  /// Can we exit an OpenMP declare variant scope at the moment.\n  bool isInOpenMPDeclareVariantScope() const {\n    return !OMPDeclareVariantScopes.empty();\n  }\n\n  /// Given the potential call expression \\p Call, determine if there is a\n  /// specialization via the OpenMP declare variant mechanism available. If\n  /// there is, return the specialized call expression, otherwise return the\n  /// original \\p Call.\n  ExprResult ActOnOpenMPCall(ExprResult Call, Scope *Scope,\n                             SourceLocation LParenLoc, MultiExprArg ArgExprs,\n                             SourceLocation RParenLoc, Expr *ExecConfig);\n\n  /// Handle a `omp begin declare variant`.\n  void ActOnOpenMPBeginDeclareVariant(SourceLocation Loc, OMPTraitInfo &TI);\n\n  /// Handle a `omp end declare variant`.\n  void ActOnOpenMPEndDeclareVariant();\n\n  /// Checks if the variant/multiversion functions are compatible.\n  bool areMultiversionVariantFunctionsCompatible(\n      const FunctionDecl *OldFD, const FunctionDecl *NewFD,\n      const PartialDiagnostic &NoProtoDiagID,\n      const PartialDiagnosticAt &NoteCausedDiagIDAt,\n      const PartialDiagnosticAt &NoSupportDiagIDAt,\n      const PartialDiagnosticAt &DiffDiagIDAt, bool TemplatesSupported,\n      bool ConstexprSupported, bool CLinkageMayDiffer);\n\n  /// Function tries to capture lambda's captured variables in the OpenMP region\n  /// before the original lambda is captured.\n  void tryCaptureOpenMPLambdas(ValueDecl *V);\n\n  /// Return true if the provided declaration \\a VD should be captured by\n  /// reference.\n  /// \\param Level Relative level of nested OpenMP construct for that the check\n  /// is performed.\n  /// \\param OpenMPCaptureLevel Capture level within an OpenMP construct.\n  bool isOpenMPCapturedByRef(const ValueDecl *D, unsigned Level,\n                             unsigned OpenMPCaptureLevel) const;\n\n  /// Check if the specified variable is used in one of the private\n  /// clauses (private, firstprivate, lastprivate, reduction etc.) in OpenMP\n  /// constructs.\n  VarDecl *isOpenMPCapturedDecl(ValueDecl *D, bool CheckScopeInfo = false,\n                                unsigned StopAt = 0);\n  ExprResult getOpenMPCapturedExpr(VarDecl *Capture, ExprValueKind VK,\n                                   ExprObjectKind OK, SourceLocation Loc);\n\n  /// If the current region is a loop-based region, mark the start of the loop\n  /// construct.\n  void startOpenMPLoop();\n\n  /// If the current region is a range loop-based region, mark the start of the\n  /// loop construct.\n  void startOpenMPCXXRangeFor();\n\n  /// Check if the specified variable is used in 'private' clause.\n  /// \\param Level Relative level of nested OpenMP construct for that the check\n  /// is performed.\n  OpenMPClauseKind isOpenMPPrivateDecl(ValueDecl *D, unsigned Level,\n                                       unsigned CapLevel) const;\n\n  /// Sets OpenMP capture kind (OMPC_private, OMPC_firstprivate, OMPC_map etc.)\n  /// for \\p FD based on DSA for the provided corresponding captured declaration\n  /// \\p D.\n  void setOpenMPCaptureKind(FieldDecl *FD, const ValueDecl *D, unsigned Level);\n\n  /// Check if the specified variable is captured  by 'target' directive.\n  /// \\param Level Relative level of nested OpenMP construct for that the check\n  /// is performed.\n  bool isOpenMPTargetCapturedDecl(const ValueDecl *D, unsigned Level,\n                                  unsigned CaptureLevel) const;\n\n  /// Check if the specified global variable must be captured  by outer capture\n  /// regions.\n  /// \\param Level Relative level of nested OpenMP construct for that\n  /// the check is performed.\n  bool isOpenMPGlobalCapturedDecl(ValueDecl *D, unsigned Level,\n                                  unsigned CaptureLevel) const;\n\n  ExprResult PerformOpenMPImplicitIntegerConversion(SourceLocation OpLoc,\n                                                    Expr *Op);\n  /// Called on start of new data sharing attribute block.\n  void StartOpenMPDSABlock(OpenMPDirectiveKind K,\n                           const DeclarationNameInfo &DirName, Scope *CurScope,\n                           SourceLocation Loc);\n  /// Start analysis of clauses.\n  void StartOpenMPClause(OpenMPClauseKind K);\n  /// End analysis of clauses.\n  void EndOpenMPClause();\n  /// Called on end of data sharing attribute block.\n  void EndOpenMPDSABlock(Stmt *CurDirective);\n\n  /// Check if the current region is an OpenMP loop region and if it is,\n  /// mark loop control variable, used in \\p Init for loop initialization, as\n  /// private by default.\n  /// \\param Init First part of the for loop.\n  void ActOnOpenMPLoopInitialization(SourceLocation ForLoc, Stmt *Init);\n\n  // OpenMP directives and clauses.\n  /// Called on correct id-expression from the '#pragma omp\n  /// threadprivate'.\n  ExprResult ActOnOpenMPIdExpression(Scope *CurScope, CXXScopeSpec &ScopeSpec,\n                                     const DeclarationNameInfo &Id,\n                                     OpenMPDirectiveKind Kind);\n  /// Called on well-formed '#pragma omp threadprivate'.\n  DeclGroupPtrTy ActOnOpenMPThreadprivateDirective(\n                                     SourceLocation Loc,\n                                     ArrayRef<Expr *> VarList);\n  /// Builds a new OpenMPThreadPrivateDecl and checks its correctness.\n  OMPThreadPrivateDecl *CheckOMPThreadPrivateDecl(SourceLocation Loc,\n                                                  ArrayRef<Expr *> VarList);\n  /// Called on well-formed '#pragma omp allocate'.\n  DeclGroupPtrTy ActOnOpenMPAllocateDirective(SourceLocation Loc,\n                                              ArrayRef<Expr *> VarList,\n                                              ArrayRef<OMPClause *> Clauses,\n                                              DeclContext *Owner = nullptr);\n\n  /// Called on well-formed '#pragma omp [begin] assume[s]'.\n  void ActOnOpenMPAssumesDirective(SourceLocation Loc,\n                                   OpenMPDirectiveKind DKind,\n                                   ArrayRef<StringRef> Assumptions,\n                                   bool SkippedClauses);\n\n  /// Check if there is an active global `omp begin assumes` directive.\n  bool isInOpenMPAssumeScope() const { return !OMPAssumeScoped.empty(); }\n\n  /// Check if there is an active global `omp assumes` directive.\n  bool hasGlobalOpenMPAssumes() const { return !OMPAssumeGlobal.empty(); }\n\n  /// Called on well-formed '#pragma omp end assumes'.\n  void ActOnOpenMPEndAssumesDirective();\n\n  /// Called on well-formed '#pragma omp requires'.\n  DeclGroupPtrTy ActOnOpenMPRequiresDirective(SourceLocation Loc,\n                                              ArrayRef<OMPClause *> ClauseList);\n  /// Check restrictions on Requires directive\n  OMPRequiresDecl *CheckOMPRequiresDecl(SourceLocation Loc,\n                                        ArrayRef<OMPClause *> Clauses);\n  /// Check if the specified type is allowed to be used in 'omp declare\n  /// reduction' construct.\n  QualType ActOnOpenMPDeclareReductionType(SourceLocation TyLoc,\n                                           TypeResult ParsedType);\n  /// Called on start of '#pragma omp declare reduction'.\n  DeclGroupPtrTy ActOnOpenMPDeclareReductionDirectiveStart(\n      Scope *S, DeclContext *DC, DeclarationName Name,\n      ArrayRef<std::pair<QualType, SourceLocation>> ReductionTypes,\n      AccessSpecifier AS, Decl *PrevDeclInScope = nullptr);\n  /// Initialize declare reduction construct initializer.\n  void ActOnOpenMPDeclareReductionCombinerStart(Scope *S, Decl *D);\n  /// Finish current declare reduction construct initializer.\n  void ActOnOpenMPDeclareReductionCombinerEnd(Decl *D, Expr *Combiner);\n  /// Initialize declare reduction construct initializer.\n  /// \\return omp_priv variable.\n  VarDecl *ActOnOpenMPDeclareReductionInitializerStart(Scope *S, Decl *D);\n  /// Finish current declare reduction construct initializer.\n  void ActOnOpenMPDeclareReductionInitializerEnd(Decl *D, Expr *Initializer,\n                                                 VarDecl *OmpPrivParm);\n  /// Called at the end of '#pragma omp declare reduction'.\n  DeclGroupPtrTy ActOnOpenMPDeclareReductionDirectiveEnd(\n      Scope *S, DeclGroupPtrTy DeclReductions, bool IsValid);\n\n  /// Check variable declaration in 'omp declare mapper' construct.\n  TypeResult ActOnOpenMPDeclareMapperVarDecl(Scope *S, Declarator &D);\n  /// Check if the specified type is allowed to be used in 'omp declare\n  /// mapper' construct.\n  QualType ActOnOpenMPDeclareMapperType(SourceLocation TyLoc,\n                                        TypeResult ParsedType);\n  /// Called on start of '#pragma omp declare mapper'.\n  DeclGroupPtrTy ActOnOpenMPDeclareMapperDirective(\n      Scope *S, DeclContext *DC, DeclarationName Name, QualType MapperType,\n      SourceLocation StartLoc, DeclarationName VN, AccessSpecifier AS,\n      Expr *MapperVarRef, ArrayRef<OMPClause *> Clauses,\n      Decl *PrevDeclInScope = nullptr);\n  /// Build the mapper variable of '#pragma omp declare mapper'.\n  ExprResult ActOnOpenMPDeclareMapperDirectiveVarDecl(Scope *S,\n                                                      QualType MapperType,\n                                                      SourceLocation StartLoc,\n                                                      DeclarationName VN);\n  bool isOpenMPDeclareMapperVarDeclAllowed(const VarDecl *VD) const;\n  const ValueDecl *getOpenMPDeclareMapperVarName() const;\n\n  /// Called on the start of target region i.e. '#pragma omp declare target'.\n  bool ActOnStartOpenMPDeclareTargetDirective(SourceLocation Loc);\n  /// Called at the end of target region i.e. '#pragme omp end declare target'.\n  void ActOnFinishOpenMPDeclareTargetDirective();\n  /// Searches for the provided declaration name for OpenMP declare target\n  /// directive.\n  NamedDecl *\n  lookupOpenMPDeclareTargetName(Scope *CurScope, CXXScopeSpec &ScopeSpec,\n                                const DeclarationNameInfo &Id,\n                                NamedDeclSetType &SameDirectiveDecls);\n  /// Called on correct id-expression from the '#pragma omp declare target'.\n  void ActOnOpenMPDeclareTargetName(NamedDecl *ND, SourceLocation Loc,\n                                    OMPDeclareTargetDeclAttr::MapTypeTy MT,\n                                    OMPDeclareTargetDeclAttr::DevTypeTy DT);\n  /// Check declaration inside target region.\n  void\n  checkDeclIsAllowedInOpenMPTarget(Expr *E, Decl *D,\n                                   SourceLocation IdLoc = SourceLocation());\n  /// Finishes analysis of the deferred functions calls that may be declared as\n  /// host/nohost during device/host compilation.\n  void finalizeOpenMPDelayedAnalysis(const FunctionDecl *Caller,\n                                     const FunctionDecl *Callee,\n                                     SourceLocation Loc);\n  /// Return true inside OpenMP declare target region.\n  bool isInOpenMPDeclareTargetContext() const {\n    return !DeclareTargetNesting.empty();\n  }\n  /// Return true inside OpenMP target region.\n  bool isInOpenMPTargetExecutionDirective() const;\n\n  /// Return the number of captured regions created for an OpenMP directive.\n  static int getOpenMPCaptureLevels(OpenMPDirectiveKind Kind);\n\n  /// Initialization of captured region for OpenMP region.\n  void ActOnOpenMPRegionStart(OpenMPDirectiveKind DKind, Scope *CurScope);\n\n  /// Called for syntactical loops (ForStmt or CXXForRangeStmt) associated to\n  /// an OpenMP loop directive.\n  StmtResult ActOnOpenMPCanonicalLoop(Stmt *AStmt);\n\n  /// End of OpenMP region.\n  ///\n  /// \\param S Statement associated with the current OpenMP region.\n  /// \\param Clauses List of clauses for the current OpenMP region.\n  ///\n  /// \\returns Statement for finished OpenMP region.\n  StmtResult ActOnOpenMPRegionEnd(StmtResult S, ArrayRef<OMPClause *> Clauses);\n  StmtResult ActOnOpenMPExecutableDirective(\n      OpenMPDirectiveKind Kind, const DeclarationNameInfo &DirName,\n      OpenMPDirectiveKind CancelRegion, ArrayRef<OMPClause *> Clauses,\n      Stmt *AStmt, SourceLocation StartLoc, SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp parallel' after parsing\n  /// of the  associated statement.\n  StmtResult ActOnOpenMPParallelDirective(ArrayRef<OMPClause *> Clauses,\n                                          Stmt *AStmt,\n                                          SourceLocation StartLoc,\n                                          SourceLocation EndLoc);\n  using VarsWithInheritedDSAType =\n      llvm::SmallDenseMap<const ValueDecl *, const Expr *, 4>;\n  /// Called on well-formed '\\#pragma omp simd' after parsing\n  /// of the associated statement.\n  StmtResult\n  ActOnOpenMPSimdDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                           SourceLocation StartLoc, SourceLocation EndLoc,\n                           VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '#pragma omp tile' after parsing of its clauses and\n  /// the associated statement.\n  StmtResult ActOnOpenMPTileDirective(ArrayRef<OMPClause *> Clauses,\n                                      Stmt *AStmt, SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp for' after parsing\n  /// of the associated statement.\n  StmtResult\n  ActOnOpenMPForDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                          SourceLocation StartLoc, SourceLocation EndLoc,\n                          VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp for simd' after parsing\n  /// of the associated statement.\n  StmtResult\n  ActOnOpenMPForSimdDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                              SourceLocation StartLoc, SourceLocation EndLoc,\n                              VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp sections' after parsing\n  /// of the associated statement.\n  StmtResult ActOnOpenMPSectionsDirective(ArrayRef<OMPClause *> Clauses,\n                                          Stmt *AStmt, SourceLocation StartLoc,\n                                          SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp section' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPSectionDirective(Stmt *AStmt, SourceLocation StartLoc,\n                                         SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp single' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPSingleDirective(ArrayRef<OMPClause *> Clauses,\n                                        Stmt *AStmt, SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp master' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPMasterDirective(Stmt *AStmt, SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp critical' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPCriticalDirective(const DeclarationNameInfo &DirName,\n                                          ArrayRef<OMPClause *> Clauses,\n                                          Stmt *AStmt, SourceLocation StartLoc,\n                                          SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp parallel for' after parsing\n  /// of the  associated statement.\n  StmtResult ActOnOpenMPParallelForDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp parallel for simd' after\n  /// parsing of the  associated statement.\n  StmtResult ActOnOpenMPParallelForSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp parallel master' after\n  /// parsing of the  associated statement.\n  StmtResult ActOnOpenMPParallelMasterDirective(ArrayRef<OMPClause *> Clauses,\n                                                Stmt *AStmt,\n                                                SourceLocation StartLoc,\n                                                SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp parallel sections' after\n  /// parsing of the  associated statement.\n  StmtResult ActOnOpenMPParallelSectionsDirective(ArrayRef<OMPClause *> Clauses,\n                                                  Stmt *AStmt,\n                                                  SourceLocation StartLoc,\n                                                  SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp task' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPTaskDirective(ArrayRef<OMPClause *> Clauses,\n                                      Stmt *AStmt, SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp taskyield'.\n  StmtResult ActOnOpenMPTaskyieldDirective(SourceLocation StartLoc,\n                                           SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp barrier'.\n  StmtResult ActOnOpenMPBarrierDirective(SourceLocation StartLoc,\n                                         SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp taskwait'.\n  StmtResult ActOnOpenMPTaskwaitDirective(SourceLocation StartLoc,\n                                          SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp taskgroup'.\n  StmtResult ActOnOpenMPTaskgroupDirective(ArrayRef<OMPClause *> Clauses,\n                                           Stmt *AStmt, SourceLocation StartLoc,\n                                           SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp flush'.\n  StmtResult ActOnOpenMPFlushDirective(ArrayRef<OMPClause *> Clauses,\n                                       SourceLocation StartLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp depobj'.\n  StmtResult ActOnOpenMPDepobjDirective(ArrayRef<OMPClause *> Clauses,\n                                        SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp scan'.\n  StmtResult ActOnOpenMPScanDirective(ArrayRef<OMPClause *> Clauses,\n                                      SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp ordered' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPOrderedDirective(ArrayRef<OMPClause *> Clauses,\n                                         Stmt *AStmt, SourceLocation StartLoc,\n                                         SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp atomic' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPAtomicDirective(ArrayRef<OMPClause *> Clauses,\n                                        Stmt *AStmt, SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp target' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPTargetDirective(ArrayRef<OMPClause *> Clauses,\n                                        Stmt *AStmt, SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp target data' after parsing of\n  /// the associated statement.\n  StmtResult ActOnOpenMPTargetDataDirective(ArrayRef<OMPClause *> Clauses,\n                                            Stmt *AStmt, SourceLocation StartLoc,\n                                            SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp target enter data' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetEnterDataDirective(ArrayRef<OMPClause *> Clauses,\n                                                 SourceLocation StartLoc,\n                                                 SourceLocation EndLoc,\n                                                 Stmt *AStmt);\n  /// Called on well-formed '\\#pragma omp target exit data' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetExitDataDirective(ArrayRef<OMPClause *> Clauses,\n                                                SourceLocation StartLoc,\n                                                SourceLocation EndLoc,\n                                                Stmt *AStmt);\n  /// Called on well-formed '\\#pragma omp target parallel' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetParallelDirective(ArrayRef<OMPClause *> Clauses,\n                                                Stmt *AStmt,\n                                                SourceLocation StartLoc,\n                                                SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp target parallel for' after\n  /// parsing of the  associated statement.\n  StmtResult ActOnOpenMPTargetParallelForDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp teams' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPTeamsDirective(ArrayRef<OMPClause *> Clauses,\n                                       Stmt *AStmt, SourceLocation StartLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp cancellation point'.\n  StmtResult\n  ActOnOpenMPCancellationPointDirective(SourceLocation StartLoc,\n                                        SourceLocation EndLoc,\n                                        OpenMPDirectiveKind CancelRegion);\n  /// Called on well-formed '\\#pragma omp cancel'.\n  StmtResult ActOnOpenMPCancelDirective(ArrayRef<OMPClause *> Clauses,\n                                        SourceLocation StartLoc,\n                                        SourceLocation EndLoc,\n                                        OpenMPDirectiveKind CancelRegion);\n  /// Called on well-formed '\\#pragma omp taskloop' after parsing of the\n  /// associated statement.\n  StmtResult\n  ActOnOpenMPTaskLoopDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                               SourceLocation StartLoc, SourceLocation EndLoc,\n                               VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp taskloop simd' after parsing of\n  /// the associated statement.\n  StmtResult ActOnOpenMPTaskLoopSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp master taskloop' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPMasterTaskLoopDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp master taskloop simd' after parsing of\n  /// the associated statement.\n  StmtResult ActOnOpenMPMasterTaskLoopSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp parallel master taskloop' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPParallelMasterTaskLoopDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp parallel master taskloop simd' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPParallelMasterTaskLoopSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp distribute' after parsing\n  /// of the associated statement.\n  StmtResult\n  ActOnOpenMPDistributeDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                                 SourceLocation StartLoc, SourceLocation EndLoc,\n                                 VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target update'.\n  StmtResult ActOnOpenMPTargetUpdateDirective(ArrayRef<OMPClause *> Clauses,\n                                              SourceLocation StartLoc,\n                                              SourceLocation EndLoc,\n                                              Stmt *AStmt);\n  /// Called on well-formed '\\#pragma omp distribute parallel for' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPDistributeParallelForDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp distribute parallel for simd'\n  /// after parsing of the associated statement.\n  StmtResult ActOnOpenMPDistributeParallelForSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp distribute simd' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPDistributeSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target parallel for simd' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetParallelForSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target simd' after parsing of\n  /// the associated statement.\n  StmtResult\n  ActOnOpenMPTargetSimdDirective(ArrayRef<OMPClause *> Clauses, Stmt *AStmt,\n                                 SourceLocation StartLoc, SourceLocation EndLoc,\n                                 VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp teams distribute' after parsing of\n  /// the associated statement.\n  StmtResult ActOnOpenMPTeamsDistributeDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp teams distribute simd' after parsing\n  /// of the associated statement.\n  StmtResult ActOnOpenMPTeamsDistributeSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp teams distribute parallel for simd'\n  /// after parsing of the associated statement.\n  StmtResult ActOnOpenMPTeamsDistributeParallelForSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp teams distribute parallel for'\n  /// after parsing of the associated statement.\n  StmtResult ActOnOpenMPTeamsDistributeParallelForDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target teams' after parsing of the\n  /// associated statement.\n  StmtResult ActOnOpenMPTargetTeamsDirective(ArrayRef<OMPClause *> Clauses,\n                                             Stmt *AStmt,\n                                             SourceLocation StartLoc,\n                                             SourceLocation EndLoc);\n  /// Called on well-formed '\\#pragma omp target teams distribute' after parsing\n  /// of the associated statement.\n  StmtResult ActOnOpenMPTargetTeamsDistributeDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target teams distribute parallel for'\n  /// after parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetTeamsDistributeParallelForDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target teams distribute parallel for\n  /// simd' after parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetTeamsDistributeParallelForSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n  /// Called on well-formed '\\#pragma omp target teams distribute simd' after\n  /// parsing of the associated statement.\n  StmtResult ActOnOpenMPTargetTeamsDistributeSimdDirective(\n      ArrayRef<OMPClause *> Clauses, Stmt *AStmt, SourceLocation StartLoc,\n      SourceLocation EndLoc, VarsWithInheritedDSAType &VarsWithImplicitDSA);\n\n  /// Checks correctness of linear modifiers.\n  bool CheckOpenMPLinearModifier(OpenMPLinearClauseKind LinKind,\n                                 SourceLocation LinLoc);\n  /// Checks that the specified declaration matches requirements for the linear\n  /// decls.\n  bool CheckOpenMPLinearDecl(const ValueDecl *D, SourceLocation ELoc,\n                             OpenMPLinearClauseKind LinKind, QualType Type,\n                             bool IsDeclareSimd = false);\n\n  /// Called on well-formed '\\#pragma omp declare simd' after parsing of\n  /// the associated method/function.\n  DeclGroupPtrTy ActOnOpenMPDeclareSimdDirective(\n      DeclGroupPtrTy DG, OMPDeclareSimdDeclAttr::BranchStateTy BS,\n      Expr *Simdlen, ArrayRef<Expr *> Uniforms, ArrayRef<Expr *> Aligneds,\n      ArrayRef<Expr *> Alignments, ArrayRef<Expr *> Linears,\n      ArrayRef<unsigned> LinModifiers, ArrayRef<Expr *> Steps, SourceRange SR);\n\n  /// Checks '\\#pragma omp declare variant' variant function and original\n  /// functions after parsing of the associated method/function.\n  /// \\param DG Function declaration to which declare variant directive is\n  /// applied to.\n  /// \\param VariantRef Expression that references the variant function, which\n  /// must be used instead of the original one, specified in \\p DG.\n  /// \\param TI The trait info object representing the match clause.\n  /// \\returns None, if the function/variant function are not compatible with\n  /// the pragma, pair of original function/variant ref expression otherwise.\n  Optional<std::pair<FunctionDecl *, Expr *>>\n  checkOpenMPDeclareVariantFunction(DeclGroupPtrTy DG, Expr *VariantRef,\n                                    OMPTraitInfo &TI, SourceRange SR);\n\n  /// Called on well-formed '\\#pragma omp declare variant' after parsing of\n  /// the associated method/function.\n  /// \\param FD Function declaration to which declare variant directive is\n  /// applied to.\n  /// \\param VariantRef Expression that references the variant function, which\n  /// must be used instead of the original one, specified in \\p DG.\n  /// \\param TI The context traits associated with the function variant.\n  void ActOnOpenMPDeclareVariantDirective(FunctionDecl *FD, Expr *VariantRef,\n                                          OMPTraitInfo &TI, SourceRange SR);\n\n  OMPClause *ActOnOpenMPSingleExprClause(OpenMPClauseKind Kind,\n                                         Expr *Expr,\n                                         SourceLocation StartLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation EndLoc);\n  /// Called on well-formed 'allocator' clause.\n  OMPClause *ActOnOpenMPAllocatorClause(Expr *Allocator,\n                                        SourceLocation StartLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed 'if' clause.\n  OMPClause *ActOnOpenMPIfClause(OpenMPDirectiveKind NameModifier,\n                                 Expr *Condition, SourceLocation StartLoc,\n                                 SourceLocation LParenLoc,\n                                 SourceLocation NameModifierLoc,\n                                 SourceLocation ColonLoc,\n                                 SourceLocation EndLoc);\n  /// Called on well-formed 'final' clause.\n  OMPClause *ActOnOpenMPFinalClause(Expr *Condition, SourceLocation StartLoc,\n                                    SourceLocation LParenLoc,\n                                    SourceLocation EndLoc);\n  /// Called on well-formed 'num_threads' clause.\n  OMPClause *ActOnOpenMPNumThreadsClause(Expr *NumThreads,\n                                         SourceLocation StartLoc,\n                                         SourceLocation LParenLoc,\n                                         SourceLocation EndLoc);\n  /// Called on well-formed 'safelen' clause.\n  OMPClause *ActOnOpenMPSafelenClause(Expr *Length,\n                                      SourceLocation StartLoc,\n                                      SourceLocation LParenLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'simdlen' clause.\n  OMPClause *ActOnOpenMPSimdlenClause(Expr *Length, SourceLocation StartLoc,\n                                      SourceLocation LParenLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-form 'sizes' clause.\n  OMPClause *ActOnOpenMPSizesClause(ArrayRef<Expr *> SizeExprs,\n                                    SourceLocation StartLoc,\n                                    SourceLocation LParenLoc,\n                                    SourceLocation EndLoc);\n  /// Called on well-formed 'collapse' clause.\n  OMPClause *ActOnOpenMPCollapseClause(Expr *NumForLoops,\n                                       SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed 'ordered' clause.\n  OMPClause *\n  ActOnOpenMPOrderedClause(SourceLocation StartLoc, SourceLocation EndLoc,\n                           SourceLocation LParenLoc = SourceLocation(),\n                           Expr *NumForLoops = nullptr);\n  /// Called on well-formed 'grainsize' clause.\n  OMPClause *ActOnOpenMPGrainsizeClause(Expr *Size, SourceLocation StartLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed 'num_tasks' clause.\n  OMPClause *ActOnOpenMPNumTasksClause(Expr *NumTasks, SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed 'hint' clause.\n  OMPClause *ActOnOpenMPHintClause(Expr *Hint, SourceLocation StartLoc,\n                                   SourceLocation LParenLoc,\n                                   SourceLocation EndLoc);\n  /// Called on well-formed 'detach' clause.\n  OMPClause *ActOnOpenMPDetachClause(Expr *Evt, SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n\n  OMPClause *ActOnOpenMPSimpleClause(OpenMPClauseKind Kind,\n                                     unsigned Argument,\n                                     SourceLocation ArgumentLoc,\n                                     SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'default' clause.\n  OMPClause *ActOnOpenMPDefaultClause(llvm::omp::DefaultKind Kind,\n                                      SourceLocation KindLoc,\n                                      SourceLocation StartLoc,\n                                      SourceLocation LParenLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'proc_bind' clause.\n  OMPClause *ActOnOpenMPProcBindClause(llvm::omp::ProcBindKind Kind,\n                                       SourceLocation KindLoc,\n                                       SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed 'order' clause.\n  OMPClause *ActOnOpenMPOrderClause(OpenMPOrderClauseKind Kind,\n                                    SourceLocation KindLoc,\n                                    SourceLocation StartLoc,\n                                    SourceLocation LParenLoc,\n                                    SourceLocation EndLoc);\n  /// Called on well-formed 'update' clause.\n  OMPClause *ActOnOpenMPUpdateClause(OpenMPDependClauseKind Kind,\n                                     SourceLocation KindLoc,\n                                     SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n\n  OMPClause *ActOnOpenMPSingleExprWithArgClause(\n      OpenMPClauseKind Kind, ArrayRef<unsigned> Arguments, Expr *Expr,\n      SourceLocation StartLoc, SourceLocation LParenLoc,\n      ArrayRef<SourceLocation> ArgumentsLoc, SourceLocation DelimLoc,\n      SourceLocation EndLoc);\n  /// Called on well-formed 'schedule' clause.\n  OMPClause *ActOnOpenMPScheduleClause(\n      OpenMPScheduleClauseModifier M1, OpenMPScheduleClauseModifier M2,\n      OpenMPScheduleClauseKind Kind, Expr *ChunkSize, SourceLocation StartLoc,\n      SourceLocation LParenLoc, SourceLocation M1Loc, SourceLocation M2Loc,\n      SourceLocation KindLoc, SourceLocation CommaLoc, SourceLocation EndLoc);\n\n  OMPClause *ActOnOpenMPClause(OpenMPClauseKind Kind, SourceLocation StartLoc,\n                               SourceLocation EndLoc);\n  /// Called on well-formed 'nowait' clause.\n  OMPClause *ActOnOpenMPNowaitClause(SourceLocation StartLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'untied' clause.\n  OMPClause *ActOnOpenMPUntiedClause(SourceLocation StartLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'mergeable' clause.\n  OMPClause *ActOnOpenMPMergeableClause(SourceLocation StartLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed 'read' clause.\n  OMPClause *ActOnOpenMPReadClause(SourceLocation StartLoc,\n                                   SourceLocation EndLoc);\n  /// Called on well-formed 'write' clause.\n  OMPClause *ActOnOpenMPWriteClause(SourceLocation StartLoc,\n                                    SourceLocation EndLoc);\n  /// Called on well-formed 'update' clause.\n  OMPClause *ActOnOpenMPUpdateClause(SourceLocation StartLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'capture' clause.\n  OMPClause *ActOnOpenMPCaptureClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'seq_cst' clause.\n  OMPClause *ActOnOpenMPSeqCstClause(SourceLocation StartLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'acq_rel' clause.\n  OMPClause *ActOnOpenMPAcqRelClause(SourceLocation StartLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'acquire' clause.\n  OMPClause *ActOnOpenMPAcquireClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'release' clause.\n  OMPClause *ActOnOpenMPReleaseClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'relaxed' clause.\n  OMPClause *ActOnOpenMPRelaxedClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'destroy' clause.\n  OMPClause *ActOnOpenMPDestroyClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'threads' clause.\n  OMPClause *ActOnOpenMPThreadsClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'simd' clause.\n  OMPClause *ActOnOpenMPSIMDClause(SourceLocation StartLoc,\n                                   SourceLocation EndLoc);\n  /// Called on well-formed 'nogroup' clause.\n  OMPClause *ActOnOpenMPNogroupClause(SourceLocation StartLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'unified_address' clause.\n  OMPClause *ActOnOpenMPUnifiedAddressClause(SourceLocation StartLoc,\n                                             SourceLocation EndLoc);\n\n  /// Called on well-formed 'unified_address' clause.\n  OMPClause *ActOnOpenMPUnifiedSharedMemoryClause(SourceLocation StartLoc,\n                                                  SourceLocation EndLoc);\n\n  /// Called on well-formed 'reverse_offload' clause.\n  OMPClause *ActOnOpenMPReverseOffloadClause(SourceLocation StartLoc,\n                                             SourceLocation EndLoc);\n\n  /// Called on well-formed 'dynamic_allocators' clause.\n  OMPClause *ActOnOpenMPDynamicAllocatorsClause(SourceLocation StartLoc,\n                                                SourceLocation EndLoc);\n\n  /// Called on well-formed 'atomic_default_mem_order' clause.\n  OMPClause *ActOnOpenMPAtomicDefaultMemOrderClause(\n      OpenMPAtomicDefaultMemOrderClauseKind Kind, SourceLocation KindLoc,\n      SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation EndLoc);\n\n  OMPClause *ActOnOpenMPVarListClause(\n      OpenMPClauseKind Kind, ArrayRef<Expr *> Vars, Expr *DepModOrTailExpr,\n      const OMPVarListLocTy &Locs, SourceLocation ColonLoc,\n      CXXScopeSpec &ReductionOrMapperIdScopeSpec,\n      DeclarationNameInfo &ReductionOrMapperId, int ExtraModifier,\n      ArrayRef<OpenMPMapModifierKind> MapTypeModifiers,\n      ArrayRef<SourceLocation> MapTypeModifiersLoc, bool IsMapTypeImplicit,\n      SourceLocation ExtraModifierLoc,\n      ArrayRef<OpenMPMotionModifierKind> MotionModifiers,\n      ArrayRef<SourceLocation> MotionModifiersLoc);\n  /// Called on well-formed 'inclusive' clause.\n  OMPClause *ActOnOpenMPInclusiveClause(ArrayRef<Expr *> VarList,\n                                        SourceLocation StartLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed 'exclusive' clause.\n  OMPClause *ActOnOpenMPExclusiveClause(ArrayRef<Expr *> VarList,\n                                        SourceLocation StartLoc,\n                                        SourceLocation LParenLoc,\n                                        SourceLocation EndLoc);\n  /// Called on well-formed 'allocate' clause.\n  OMPClause *\n  ActOnOpenMPAllocateClause(Expr *Allocator, ArrayRef<Expr *> VarList,\n                            SourceLocation StartLoc, SourceLocation ColonLoc,\n                            SourceLocation LParenLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'private' clause.\n  OMPClause *ActOnOpenMPPrivateClause(ArrayRef<Expr *> VarList,\n                                      SourceLocation StartLoc,\n                                      SourceLocation LParenLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'firstprivate' clause.\n  OMPClause *ActOnOpenMPFirstprivateClause(ArrayRef<Expr *> VarList,\n                                           SourceLocation StartLoc,\n                                           SourceLocation LParenLoc,\n                                           SourceLocation EndLoc);\n  /// Called on well-formed 'lastprivate' clause.\n  OMPClause *ActOnOpenMPLastprivateClause(\n      ArrayRef<Expr *> VarList, OpenMPLastprivateModifier LPKind,\n      SourceLocation LPKindLoc, SourceLocation ColonLoc,\n      SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'shared' clause.\n  OMPClause *ActOnOpenMPSharedClause(ArrayRef<Expr *> VarList,\n                                     SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'reduction' clause.\n  OMPClause *ActOnOpenMPReductionClause(\n      ArrayRef<Expr *> VarList, OpenMPReductionClauseModifier Modifier,\n      SourceLocation StartLoc, SourceLocation LParenLoc,\n      SourceLocation ModifierLoc, SourceLocation ColonLoc,\n      SourceLocation EndLoc, CXXScopeSpec &ReductionIdScopeSpec,\n      const DeclarationNameInfo &ReductionId,\n      ArrayRef<Expr *> UnresolvedReductions = llvm::None);\n  /// Called on well-formed 'task_reduction' clause.\n  OMPClause *ActOnOpenMPTaskReductionClause(\n      ArrayRef<Expr *> VarList, SourceLocation StartLoc,\n      SourceLocation LParenLoc, SourceLocation ColonLoc, SourceLocation EndLoc,\n      CXXScopeSpec &ReductionIdScopeSpec,\n      const DeclarationNameInfo &ReductionId,\n      ArrayRef<Expr *> UnresolvedReductions = llvm::None);\n  /// Called on well-formed 'in_reduction' clause.\n  OMPClause *ActOnOpenMPInReductionClause(\n      ArrayRef<Expr *> VarList, SourceLocation StartLoc,\n      SourceLocation LParenLoc, SourceLocation ColonLoc, SourceLocation EndLoc,\n      CXXScopeSpec &ReductionIdScopeSpec,\n      const DeclarationNameInfo &ReductionId,\n      ArrayRef<Expr *> UnresolvedReductions = llvm::None);\n  /// Called on well-formed 'linear' clause.\n  OMPClause *\n  ActOnOpenMPLinearClause(ArrayRef<Expr *> VarList, Expr *Step,\n                          SourceLocation StartLoc, SourceLocation LParenLoc,\n                          OpenMPLinearClauseKind LinKind, SourceLocation LinLoc,\n                          SourceLocation ColonLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'aligned' clause.\n  OMPClause *ActOnOpenMPAlignedClause(ArrayRef<Expr *> VarList,\n                                      Expr *Alignment,\n                                      SourceLocation StartLoc,\n                                      SourceLocation LParenLoc,\n                                      SourceLocation ColonLoc,\n                                      SourceLocation EndLoc);\n  /// Called on well-formed 'copyin' clause.\n  OMPClause *ActOnOpenMPCopyinClause(ArrayRef<Expr *> VarList,\n                                     SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'copyprivate' clause.\n  OMPClause *ActOnOpenMPCopyprivateClause(ArrayRef<Expr *> VarList,\n                                          SourceLocation StartLoc,\n                                          SourceLocation LParenLoc,\n                                          SourceLocation EndLoc);\n  /// Called on well-formed 'flush' pseudo clause.\n  OMPClause *ActOnOpenMPFlushClause(ArrayRef<Expr *> VarList,\n                                    SourceLocation StartLoc,\n                                    SourceLocation LParenLoc,\n                                    SourceLocation EndLoc);\n  /// Called on well-formed 'depobj' pseudo clause.\n  OMPClause *ActOnOpenMPDepobjClause(Expr *Depobj, SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'depend' clause.\n  OMPClause *\n  ActOnOpenMPDependClause(Expr *DepModifier, OpenMPDependClauseKind DepKind,\n                          SourceLocation DepLoc, SourceLocation ColonLoc,\n                          ArrayRef<Expr *> VarList, SourceLocation StartLoc,\n                          SourceLocation LParenLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'device' clause.\n  OMPClause *ActOnOpenMPDeviceClause(OpenMPDeviceClauseModifier Modifier,\n                                     Expr *Device, SourceLocation StartLoc,\n                                     SourceLocation LParenLoc,\n                                     SourceLocation ModifierLoc,\n                                     SourceLocation EndLoc);\n  /// Called on well-formed 'map' clause.\n  OMPClause *\n  ActOnOpenMPMapClause(ArrayRef<OpenMPMapModifierKind> MapTypeModifiers,\n                       ArrayRef<SourceLocation> MapTypeModifiersLoc,\n                       CXXScopeSpec &MapperIdScopeSpec,\n                       DeclarationNameInfo &MapperId,\n                       OpenMPMapClauseKind MapType, bool IsMapTypeImplicit,\n                       SourceLocation MapLoc, SourceLocation ColonLoc,\n                       ArrayRef<Expr *> VarList, const OMPVarListLocTy &Locs,\n                       ArrayRef<Expr *> UnresolvedMappers = llvm::None);\n  /// Called on well-formed 'num_teams' clause.\n  OMPClause *ActOnOpenMPNumTeamsClause(Expr *NumTeams, SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed 'thread_limit' clause.\n  OMPClause *ActOnOpenMPThreadLimitClause(Expr *ThreadLimit,\n                                          SourceLocation StartLoc,\n                                          SourceLocation LParenLoc,\n                                          SourceLocation EndLoc);\n  /// Called on well-formed 'priority' clause.\n  OMPClause *ActOnOpenMPPriorityClause(Expr *Priority, SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation EndLoc);\n  /// Called on well-formed 'dist_schedule' clause.\n  OMPClause *ActOnOpenMPDistScheduleClause(\n      OpenMPDistScheduleClauseKind Kind, Expr *ChunkSize,\n      SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation KindLoc,\n      SourceLocation CommaLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'defaultmap' clause.\n  OMPClause *ActOnOpenMPDefaultmapClause(\n      OpenMPDefaultmapClauseModifier M, OpenMPDefaultmapClauseKind Kind,\n      SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation MLoc,\n      SourceLocation KindLoc, SourceLocation EndLoc);\n  /// Called on well-formed 'to' clause.\n  OMPClause *\n  ActOnOpenMPToClause(ArrayRef<OpenMPMotionModifierKind> MotionModifiers,\n                      ArrayRef<SourceLocation> MotionModifiersLoc,\n                      CXXScopeSpec &MapperIdScopeSpec,\n                      DeclarationNameInfo &MapperId, SourceLocation ColonLoc,\n                      ArrayRef<Expr *> VarList, const OMPVarListLocTy &Locs,\n                      ArrayRef<Expr *> UnresolvedMappers = llvm::None);\n  /// Called on well-formed 'from' clause.\n  OMPClause *\n  ActOnOpenMPFromClause(ArrayRef<OpenMPMotionModifierKind> MotionModifiers,\n                        ArrayRef<SourceLocation> MotionModifiersLoc,\n                        CXXScopeSpec &MapperIdScopeSpec,\n                        DeclarationNameInfo &MapperId, SourceLocation ColonLoc,\n                        ArrayRef<Expr *> VarList, const OMPVarListLocTy &Locs,\n                        ArrayRef<Expr *> UnresolvedMappers = llvm::None);\n  /// Called on well-formed 'use_device_ptr' clause.\n  OMPClause *ActOnOpenMPUseDevicePtrClause(ArrayRef<Expr *> VarList,\n                                           const OMPVarListLocTy &Locs);\n  /// Called on well-formed 'use_device_addr' clause.\n  OMPClause *ActOnOpenMPUseDeviceAddrClause(ArrayRef<Expr *> VarList,\n                                            const OMPVarListLocTy &Locs);\n  /// Called on well-formed 'is_device_ptr' clause.\n  OMPClause *ActOnOpenMPIsDevicePtrClause(ArrayRef<Expr *> VarList,\n                                          const OMPVarListLocTy &Locs);\n  /// Called on well-formed 'nontemporal' clause.\n  OMPClause *ActOnOpenMPNontemporalClause(ArrayRef<Expr *> VarList,\n                                          SourceLocation StartLoc,\n                                          SourceLocation LParenLoc,\n                                          SourceLocation EndLoc);\n\n  /// Data for list of allocators.\n  struct UsesAllocatorsData {\n    /// Allocator.\n    Expr *Allocator = nullptr;\n    /// Allocator traits.\n    Expr *AllocatorTraits = nullptr;\n    /// Locations of '(' and ')' symbols.\n    SourceLocation LParenLoc, RParenLoc;\n  };\n  /// Called on well-formed 'uses_allocators' clause.\n  OMPClause *ActOnOpenMPUsesAllocatorClause(SourceLocation StartLoc,\n                                            SourceLocation LParenLoc,\n                                            SourceLocation EndLoc,\n                                            ArrayRef<UsesAllocatorsData> Data);\n  /// Called on well-formed 'affinity' clause.\n  OMPClause *ActOnOpenMPAffinityClause(SourceLocation StartLoc,\n                                       SourceLocation LParenLoc,\n                                       SourceLocation ColonLoc,\n                                       SourceLocation EndLoc, Expr *Modifier,\n                                       ArrayRef<Expr *> Locators);\n\n  /// The kind of conversion being performed.\n  enum CheckedConversionKind {\n    /// An implicit conversion.\n    CCK_ImplicitConversion,\n    /// A C-style cast.\n    CCK_CStyleCast,\n    /// A functional-style cast.\n    CCK_FunctionalCast,\n    /// A cast other than a C-style cast.\n    CCK_OtherCast,\n    /// A conversion for an operand of a builtin overloaded operator.\n    CCK_ForBuiltinOverloadedOp\n  };\n\n  static bool isCast(CheckedConversionKind CCK) {\n    return CCK == CCK_CStyleCast || CCK == CCK_FunctionalCast ||\n           CCK == CCK_OtherCast;\n  }\n\n  /// ImpCastExprToType - If Expr is not of type 'Type', insert an implicit\n  /// cast.  If there is already an implicit cast, merge into the existing one.\n  /// If isLvalue, the result of the cast is an lvalue.\n  ExprResult ImpCastExprToType(Expr *E, QualType Type, CastKind CK,\n                               ExprValueKind VK = VK_RValue,\n                               const CXXCastPath *BasePath = nullptr,\n                               CheckedConversionKind CCK\n                                  = CCK_ImplicitConversion);\n\n  /// ScalarTypeToBooleanCastKind - Returns the cast kind corresponding\n  /// to the conversion from scalar type ScalarTy to the Boolean type.\n  static CastKind ScalarTypeToBooleanCastKind(QualType ScalarTy);\n\n  /// IgnoredValueConversions - Given that an expression's result is\n  /// syntactically ignored, perform any conversions that are\n  /// required.\n  ExprResult IgnoredValueConversions(Expr *E);\n\n  // UsualUnaryConversions - promotes integers (C99 6.3.1.1p2) and converts\n  // functions and arrays to their respective pointers (C99 6.3.2.1).\n  ExprResult UsualUnaryConversions(Expr *E);\n\n  /// CallExprUnaryConversions - a special case of an unary conversion\n  /// performed on a function designator of a call expression.\n  ExprResult CallExprUnaryConversions(Expr *E);\n\n  // DefaultFunctionArrayConversion - converts functions and arrays\n  // to their respective pointers (C99 6.3.2.1).\n  ExprResult DefaultFunctionArrayConversion(Expr *E, bool Diagnose = true);\n\n  // DefaultFunctionArrayLvalueConversion - converts functions and\n  // arrays to their respective pointers and performs the\n  // lvalue-to-rvalue conversion.\n  ExprResult DefaultFunctionArrayLvalueConversion(Expr *E,\n                                                  bool Diagnose = true);\n\n  // DefaultLvalueConversion - performs lvalue-to-rvalue conversion on\n  // the operand. This function is a no-op if the operand has a function type\n  // or an array type.\n  ExprResult DefaultLvalueConversion(Expr *E);\n\n  // DefaultArgumentPromotion (C99 6.5.2.2p6). Used for function calls that\n  // do not have a prototype. Integer promotions are performed on each\n  // argument, and arguments that have type float are promoted to double.\n  ExprResult DefaultArgumentPromotion(Expr *E);\n\n  /// If \\p E is a prvalue denoting an unmaterialized temporary, materialize\n  /// it as an xvalue. In C++98, the result will still be a prvalue, because\n  /// we don't have xvalues there.\n  ExprResult TemporaryMaterializationConversion(Expr *E);\n\n  // Used for emitting the right warning by DefaultVariadicArgumentPromotion\n  enum VariadicCallType {\n    VariadicFunction,\n    VariadicBlock,\n    VariadicMethod,\n    VariadicConstructor,\n    VariadicDoesNotApply\n  };\n\n  VariadicCallType getVariadicCallType(FunctionDecl *FDecl,\n                                       const FunctionProtoType *Proto,\n                                       Expr *Fn);\n\n  // Used for determining in which context a type is allowed to be passed to a\n  // vararg function.\n  enum VarArgKind {\n    VAK_Valid,\n    VAK_ValidInCXX11,\n    VAK_Undefined,\n    VAK_MSVCUndefined,\n    VAK_Invalid\n  };\n\n  // Determines which VarArgKind fits an expression.\n  VarArgKind isValidVarArgType(const QualType &Ty);\n\n  /// Check to see if the given expression is a valid argument to a variadic\n  /// function, issuing a diagnostic if not.\n  void checkVariadicArgument(const Expr *E, VariadicCallType CT);\n\n  /// Check to see if a given expression could have '.c_str()' called on it.\n  bool hasCStrMethod(const Expr *E);\n\n  /// GatherArgumentsForCall - Collector argument expressions for various\n  /// form of call prototypes.\n  bool GatherArgumentsForCall(SourceLocation CallLoc, FunctionDecl *FDecl,\n                              const FunctionProtoType *Proto,\n                              unsigned FirstParam, ArrayRef<Expr *> Args,\n                              SmallVectorImpl<Expr *> &AllArgs,\n                              VariadicCallType CallType = VariadicDoesNotApply,\n                              bool AllowExplicit = false,\n                              bool IsListInitialization = false);\n\n  // DefaultVariadicArgumentPromotion - Like DefaultArgumentPromotion, but\n  // will create a runtime trap if the resulting type is not a POD type.\n  ExprResult DefaultVariadicArgumentPromotion(Expr *E, VariadicCallType CT,\n                                              FunctionDecl *FDecl);\n\n  /// Context in which we're performing a usual arithmetic conversion.\n  enum ArithConvKind {\n    /// An arithmetic operation.\n    ACK_Arithmetic,\n    /// A bitwise operation.\n    ACK_BitwiseOp,\n    /// A comparison.\n    ACK_Comparison,\n    /// A conditional (?:) operator.\n    ACK_Conditional,\n    /// A compound assignment expression.\n    ACK_CompAssign,\n  };\n\n  // UsualArithmeticConversions - performs the UsualUnaryConversions on it's\n  // operands and then handles various conversions that are common to binary\n  // operators (C99 6.3.1.8). If both operands aren't arithmetic, this\n  // routine returns the first non-arithmetic type found. The client is\n  // responsible for emitting appropriate error diagnostics.\n  QualType UsualArithmeticConversions(ExprResult &LHS, ExprResult &RHS,\n                                      SourceLocation Loc, ArithConvKind ACK);\n\n  /// AssignConvertType - All of the 'assignment' semantic checks return this\n  /// enum to indicate whether the assignment was allowed.  These checks are\n  /// done for simple assignments, as well as initialization, return from\n  /// function, argument passing, etc.  The query is phrased in terms of a\n  /// source and destination type.\n  enum AssignConvertType {\n    /// Compatible - the types are compatible according to the standard.\n    Compatible,\n\n    /// PointerToInt - The assignment converts a pointer to an int, which we\n    /// accept as an extension.\n    PointerToInt,\n\n    /// IntToPointer - The assignment converts an int to a pointer, which we\n    /// accept as an extension.\n    IntToPointer,\n\n    /// FunctionVoidPointer - The assignment is between a function pointer and\n    /// void*, which the standard doesn't allow, but we accept as an extension.\n    FunctionVoidPointer,\n\n    /// IncompatiblePointer - The assignment is between two pointers types that\n    /// are not compatible, but we accept them as an extension.\n    IncompatiblePointer,\n\n    /// IncompatibleFunctionPointer - The assignment is between two function\n    /// pointers types that are not compatible, but we accept them as an\n    /// extension.\n    IncompatibleFunctionPointer,\n\n    /// IncompatiblePointerSign - The assignment is between two pointers types\n    /// which point to integers which have a different sign, but are otherwise\n    /// identical. This is a subset of the above, but broken out because it's by\n    /// far the most common case of incompatible pointers.\n    IncompatiblePointerSign,\n\n    /// CompatiblePointerDiscardsQualifiers - The assignment discards\n    /// c/v/r qualifiers, which we accept as an extension.\n    CompatiblePointerDiscardsQualifiers,\n\n    /// IncompatiblePointerDiscardsQualifiers - The assignment\n    /// discards qualifiers that we don't permit to be discarded,\n    /// like address spaces.\n    IncompatiblePointerDiscardsQualifiers,\n\n    /// IncompatibleNestedPointerAddressSpaceMismatch - The assignment\n    /// changes address spaces in nested pointer types which is not allowed.\n    /// For instance, converting __private int ** to __generic int ** is\n    /// illegal even though __private could be converted to __generic.\n    IncompatibleNestedPointerAddressSpaceMismatch,\n\n    /// IncompatibleNestedPointerQualifiers - The assignment is between two\n    /// nested pointer types, and the qualifiers other than the first two\n    /// levels differ e.g. char ** -> const char **, but we accept them as an\n    /// extension.\n    IncompatibleNestedPointerQualifiers,\n\n    /// IncompatibleVectors - The assignment is between two vector types that\n    /// have the same size, which we accept as an extension.\n    IncompatibleVectors,\n\n    /// IntToBlockPointer - The assignment converts an int to a block\n    /// pointer. We disallow this.\n    IntToBlockPointer,\n\n    /// IncompatibleBlockPointer - The assignment is between two block\n    /// pointers types that are not compatible.\n    IncompatibleBlockPointer,\n\n    /// IncompatibleObjCQualifiedId - The assignment is between a qualified\n    /// id type and something else (that is incompatible with it). For example,\n    /// \"id <XXX>\" = \"Foo *\", where \"Foo *\" doesn't implement the XXX protocol.\n    IncompatibleObjCQualifiedId,\n\n    /// IncompatibleObjCWeakRef - Assigning a weak-unavailable object to an\n    /// object with __weak qualifier.\n    IncompatibleObjCWeakRef,\n\n    /// Incompatible - We reject this conversion outright, it is invalid to\n    /// represent it in the AST.\n    Incompatible\n  };\n\n  /// DiagnoseAssignmentResult - Emit a diagnostic, if required, for the\n  /// assignment conversion type specified by ConvTy.  This returns true if the\n  /// conversion was invalid or false if the conversion was accepted.\n  bool DiagnoseAssignmentResult(AssignConvertType ConvTy,\n                                SourceLocation Loc,\n                                QualType DstType, QualType SrcType,\n                                Expr *SrcExpr, AssignmentAction Action,\n                                bool *Complained = nullptr);\n\n  /// IsValueInFlagEnum - Determine if a value is allowed as part of a flag\n  /// enum. If AllowMask is true, then we also allow the complement of a valid\n  /// value, to be used as a mask.\n  bool IsValueInFlagEnum(const EnumDecl *ED, const llvm::APInt &Val,\n                         bool AllowMask) const;\n\n  /// DiagnoseAssignmentEnum - Warn if assignment to enum is a constant\n  /// integer not in the range of enum values.\n  void DiagnoseAssignmentEnum(QualType DstType, QualType SrcType,\n                              Expr *SrcExpr);\n\n  /// CheckAssignmentConstraints - Perform type checking for assignment,\n  /// argument passing, variable initialization, and function return values.\n  /// C99 6.5.16.\n  AssignConvertType CheckAssignmentConstraints(SourceLocation Loc,\n                                               QualType LHSType,\n                                               QualType RHSType);\n\n  /// Check assignment constraints and optionally prepare for a conversion of\n  /// the RHS to the LHS type. The conversion is prepared for if ConvertRHS\n  /// is true.\n  AssignConvertType CheckAssignmentConstraints(QualType LHSType,\n                                               ExprResult &RHS,\n                                               CastKind &Kind,\n                                               bool ConvertRHS = true);\n\n  /// Check assignment constraints for an assignment of RHS to LHSType.\n  ///\n  /// \\param LHSType The destination type for the assignment.\n  /// \\param RHS The source expression for the assignment.\n  /// \\param Diagnose If \\c true, diagnostics may be produced when checking\n  ///        for assignability. If a diagnostic is produced, \\p RHS will be\n  ///        set to ExprError(). Note that this function may still return\n  ///        without producing a diagnostic, even for an invalid assignment.\n  /// \\param DiagnoseCFAudited If \\c true, the target is a function parameter\n  ///        in an audited Core Foundation API and does not need to be checked\n  ///        for ARC retain issues.\n  /// \\param ConvertRHS If \\c true, \\p RHS will be updated to model the\n  ///        conversions necessary to perform the assignment. If \\c false,\n  ///        \\p Diagnose must also be \\c false.\n  AssignConvertType CheckSingleAssignmentConstraints(\n      QualType LHSType, ExprResult &RHS, bool Diagnose = true,\n      bool DiagnoseCFAudited = false, bool ConvertRHS = true);\n\n  // If the lhs type is a transparent union, check whether we\n  // can initialize the transparent union with the given expression.\n  AssignConvertType CheckTransparentUnionArgumentConstraints(QualType ArgType,\n                                                             ExprResult &RHS);\n\n  bool IsStringLiteralToNonConstPointerConversion(Expr *From, QualType ToType);\n\n  bool CheckExceptionSpecCompatibility(Expr *From, QualType ToType);\n\n  ExprResult PerformImplicitConversion(Expr *From, QualType ToType,\n                                       AssignmentAction Action,\n                                       bool AllowExplicit = false);\n  ExprResult PerformImplicitConversion(Expr *From, QualType ToType,\n                                       const ImplicitConversionSequence& ICS,\n                                       AssignmentAction Action,\n                                       CheckedConversionKind CCK\n                                          = CCK_ImplicitConversion);\n  ExprResult PerformImplicitConversion(Expr *From, QualType ToType,\n                                       const StandardConversionSequence& SCS,\n                                       AssignmentAction Action,\n                                       CheckedConversionKind CCK);\n\n  ExprResult PerformQualificationConversion(\n      Expr *E, QualType Ty, ExprValueKind VK = VK_RValue,\n      CheckedConversionKind CCK = CCK_ImplicitConversion);\n\n  /// the following \"Check\" methods will return a valid/converted QualType\n  /// or a null QualType (indicating an error diagnostic was issued).\n\n  /// type checking binary operators (subroutines of CreateBuiltinBinOp).\n  QualType InvalidOperands(SourceLocation Loc, ExprResult &LHS,\n                           ExprResult &RHS);\n  QualType InvalidLogicalVectorOperands(SourceLocation Loc, ExprResult &LHS,\n                                 ExprResult &RHS);\n  QualType CheckPointerToMemberOperands( // C++ 5.5\n    ExprResult &LHS, ExprResult &RHS, ExprValueKind &VK,\n    SourceLocation OpLoc, bool isIndirect);\n  QualType CheckMultiplyDivideOperands( // C99 6.5.5\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc, bool IsCompAssign,\n    bool IsDivide);\n  QualType CheckRemainderOperands( // C99 6.5.5\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n    bool IsCompAssign = false);\n  QualType CheckAdditionOperands( // C99 6.5.6\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n    BinaryOperatorKind Opc, QualType* CompLHSTy = nullptr);\n  QualType CheckSubtractionOperands( // C99 6.5.6\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n    QualType* CompLHSTy = nullptr);\n  QualType CheckShiftOperands( // C99 6.5.7\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n    BinaryOperatorKind Opc, bool IsCompAssign = false);\n  void CheckPtrComparisonWithNullChar(ExprResult &E, ExprResult &NullE);\n  QualType CheckCompareOperands( // C99 6.5.8/9\n      ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n      BinaryOperatorKind Opc);\n  QualType CheckBitwiseOperands( // C99 6.5.[10...12]\n      ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n      BinaryOperatorKind Opc);\n  QualType CheckLogicalOperands( // C99 6.5.[13,14]\n    ExprResult &LHS, ExprResult &RHS, SourceLocation Loc,\n    BinaryOperatorKind Opc);\n  // CheckAssignmentOperands is used for both simple and compound assignment.\n  // For simple assignment, pass both expressions and a null converted type.\n  // For compound assignment, pass both expressions and the converted type.\n  QualType CheckAssignmentOperands( // C99 6.5.16.[1,2]\n    Expr *LHSExpr, ExprResult &RHS, SourceLocation Loc, QualType CompoundType);\n\n  ExprResult checkPseudoObjectIncDec(Scope *S, SourceLocation OpLoc,\n                                     UnaryOperatorKind Opcode, Expr *Op);\n  ExprResult checkPseudoObjectAssignment(Scope *S, SourceLocation OpLoc,\n                                         BinaryOperatorKind Opcode,\n                                         Expr *LHS, Expr *RHS);\n  ExprResult checkPseudoObjectRValue(Expr *E);\n  Expr *recreateSyntacticForm(PseudoObjectExpr *E);\n\n  QualType CheckConditionalOperands( // C99 6.5.15\n    ExprResult &Cond, ExprResult &LHS, ExprResult &RHS,\n    ExprValueKind &VK, ExprObjectKind &OK, SourceLocation QuestionLoc);\n  QualType CXXCheckConditionalOperands( // C++ 5.16\n    ExprResult &cond, ExprResult &lhs, ExprResult &rhs,\n    ExprValueKind &VK, ExprObjectKind &OK, SourceLocation questionLoc);\n  QualType CheckVectorConditionalTypes(ExprResult &Cond, ExprResult &LHS,\n                                       ExprResult &RHS,\n                                       SourceLocation QuestionLoc);\n  QualType FindCompositePointerType(SourceLocation Loc, Expr *&E1, Expr *&E2,\n                                    bool ConvertArgs = true);\n  QualType FindCompositePointerType(SourceLocation Loc,\n                                    ExprResult &E1, ExprResult &E2,\n                                    bool ConvertArgs = true) {\n    Expr *E1Tmp = E1.get(), *E2Tmp = E2.get();\n    QualType Composite =\n        FindCompositePointerType(Loc, E1Tmp, E2Tmp, ConvertArgs);\n    E1 = E1Tmp;\n    E2 = E2Tmp;\n    return Composite;\n  }\n\n  QualType FindCompositeObjCPointerType(ExprResult &LHS, ExprResult &RHS,\n                                        SourceLocation QuestionLoc);\n\n  bool DiagnoseConditionalForNull(Expr *LHSExpr, Expr *RHSExpr,\n                                  SourceLocation QuestionLoc);\n\n  void DiagnoseAlwaysNonNullPointer(Expr *E,\n                                    Expr::NullPointerConstantKind NullType,\n                                    bool IsEqual, SourceRange Range);\n\n  /// type checking for vector binary operators.\n  QualType CheckVectorOperands(ExprResult &LHS, ExprResult &RHS,\n                               SourceLocation Loc, bool IsCompAssign,\n                               bool AllowBothBool, bool AllowBoolConversion);\n  QualType GetSignedVectorType(QualType V);\n  QualType CheckVectorCompareOperands(ExprResult &LHS, ExprResult &RHS,\n                                      SourceLocation Loc,\n                                      BinaryOperatorKind Opc);\n  QualType CheckVectorLogicalOperands(ExprResult &LHS, ExprResult &RHS,\n                                      SourceLocation Loc);\n\n  /// Type checking for matrix binary operators.\n  QualType CheckMatrixElementwiseOperands(ExprResult &LHS, ExprResult &RHS,\n                                          SourceLocation Loc,\n                                          bool IsCompAssign);\n  QualType CheckMatrixMultiplyOperands(ExprResult &LHS, ExprResult &RHS,\n                                       SourceLocation Loc, bool IsCompAssign);\n\n  bool isValidSveBitcast(QualType srcType, QualType destType);\n\n  bool areLaxCompatibleVectorTypes(QualType srcType, QualType destType);\n  bool isLaxVectorConversion(QualType srcType, QualType destType);\n\n  /// type checking declaration initializers (C99 6.7.8)\n  bool CheckForConstantInitializer(Expr *e, QualType t);\n\n  // type checking C++ declaration initializers (C++ [dcl.init]).\n\n  /// ReferenceCompareResult - Expresses the result of comparing two\n  /// types (cv1 T1 and cv2 T2) to determine their compatibility for the\n  /// purposes of initialization by reference (C++ [dcl.init.ref]p4).\n  enum ReferenceCompareResult {\n    /// Ref_Incompatible - The two types are incompatible, so direct\n    /// reference binding is not possible.\n    Ref_Incompatible = 0,\n    /// Ref_Related - The two types are reference-related, which means\n    /// that their unqualified forms (T1 and T2) are either the same\n    /// or T1 is a base class of T2.\n    Ref_Related,\n    /// Ref_Compatible - The two types are reference-compatible.\n    Ref_Compatible\n  };\n\n  // Fake up a scoped enumeration that still contextually converts to bool.\n  struct ReferenceConversionsScope {\n    /// The conversions that would be performed on an lvalue of type T2 when\n    /// binding a reference of type T1 to it, as determined when evaluating\n    /// whether T1 is reference-compatible with T2.\n    enum ReferenceConversions {\n      Qualification = 0x1,\n      NestedQualification = 0x2,\n      Function = 0x4,\n      DerivedToBase = 0x8,\n      ObjC = 0x10,\n      ObjCLifetime = 0x20,\n\n      LLVM_MARK_AS_BITMASK_ENUM(/*LargestValue=*/ObjCLifetime)\n    };\n  };\n  using ReferenceConversions = ReferenceConversionsScope::ReferenceConversions;\n\n  ReferenceCompareResult\n  CompareReferenceRelationship(SourceLocation Loc, QualType T1, QualType T2,\n                               ReferenceConversions *Conv = nullptr);\n\n  ExprResult checkUnknownAnyCast(SourceRange TypeRange, QualType CastType,\n                                 Expr *CastExpr, CastKind &CastKind,\n                                 ExprValueKind &VK, CXXCastPath &Path);\n\n  /// Force an expression with unknown-type to an expression of the\n  /// given type.\n  ExprResult forceUnknownAnyToType(Expr *E, QualType ToType);\n\n  /// Type-check an expression that's being passed to an\n  /// __unknown_anytype parameter.\n  ExprResult checkUnknownAnyArg(SourceLocation callLoc,\n                                Expr *result, QualType &paramType);\n\n  // CheckVectorCast - check type constraints for vectors.\n  // Since vectors are an extension, there are no C standard reference for this.\n  // We allow casting between vectors and integer datatypes of the same size.\n  // returns true if the cast is invalid\n  bool CheckVectorCast(SourceRange R, QualType VectorTy, QualType Ty,\n                       CastKind &Kind);\n\n  /// Prepare `SplattedExpr` for a vector splat operation, adding\n  /// implicit casts if necessary.\n  ExprResult prepareVectorSplat(QualType VectorTy, Expr *SplattedExpr);\n\n  // CheckExtVectorCast - check type constraints for extended vectors.\n  // Since vectors are an extension, there are no C standard reference for this.\n  // We allow casting between vectors and integer datatypes of the same size,\n  // or vectors and the element type of that vector.\n  // returns the cast expr\n  ExprResult CheckExtVectorCast(SourceRange R, QualType DestTy, Expr *CastExpr,\n                                CastKind &Kind);\n\n  ExprResult BuildCXXFunctionalCastExpr(TypeSourceInfo *TInfo, QualType Type,\n                                        SourceLocation LParenLoc,\n                                        Expr *CastExpr,\n                                        SourceLocation RParenLoc);\n\n  enum ARCConversionResult { ACR_okay, ACR_unbridged, ACR_error };\n\n  /// Checks for invalid conversions and casts between\n  /// retainable pointers and other pointer kinds for ARC and Weak.\n  ARCConversionResult CheckObjCConversion(SourceRange castRange,\n                                          QualType castType, Expr *&op,\n                                          CheckedConversionKind CCK,\n                                          bool Diagnose = true,\n                                          bool DiagnoseCFAudited = false,\n                                          BinaryOperatorKind Opc = BO_PtrMemD\n                                          );\n\n  Expr *stripARCUnbridgedCast(Expr *e);\n  void diagnoseARCUnbridgedCast(Expr *e);\n\n  bool CheckObjCARCUnavailableWeakConversion(QualType castType,\n                                             QualType ExprType);\n\n  /// checkRetainCycles - Check whether an Objective-C message send\n  /// might create an obvious retain cycle.\n  void checkRetainCycles(ObjCMessageExpr *msg);\n  void checkRetainCycles(Expr *receiver, Expr *argument);\n  void checkRetainCycles(VarDecl *Var, Expr *Init);\n\n  /// checkUnsafeAssigns - Check whether +1 expr is being assigned\n  /// to weak/__unsafe_unretained type.\n  bool checkUnsafeAssigns(SourceLocation Loc, QualType LHS, Expr *RHS);\n\n  /// checkUnsafeExprAssigns - Check whether +1 expr is being assigned\n  /// to weak/__unsafe_unretained expression.\n  void checkUnsafeExprAssigns(SourceLocation Loc, Expr *LHS, Expr *RHS);\n\n  /// CheckMessageArgumentTypes - Check types in an Obj-C message send.\n  /// \\param Method - May be null.\n  /// \\param [out] ReturnType - The return type of the send.\n  /// \\return true iff there were any incompatible types.\n  bool CheckMessageArgumentTypes(const Expr *Receiver, QualType ReceiverType,\n                                 MultiExprArg Args, Selector Sel,\n                                 ArrayRef<SourceLocation> SelectorLocs,\n                                 ObjCMethodDecl *Method, bool isClassMessage,\n                                 bool isSuperMessage, SourceLocation lbrac,\n                                 SourceLocation rbrac, SourceRange RecRange,\n                                 QualType &ReturnType, ExprValueKind &VK);\n\n  /// Determine the result of a message send expression based on\n  /// the type of the receiver, the method expected to receive the message,\n  /// and the form of the message send.\n  QualType getMessageSendResultType(const Expr *Receiver, QualType ReceiverType,\n                                    ObjCMethodDecl *Method, bool isClassMessage,\n                                    bool isSuperMessage);\n\n  /// If the given expression involves a message send to a method\n  /// with a related result type, emit a note describing what happened.\n  void EmitRelatedResultTypeNote(const Expr *E);\n\n  /// Given that we had incompatible pointer types in a return\n  /// statement, check whether we're in a method with a related result\n  /// type, and if so, emit a note describing what happened.\n  void EmitRelatedResultTypeNoteForReturn(QualType destType);\n\n  class ConditionResult {\n    Decl *ConditionVar;\n    FullExprArg Condition;\n    bool Invalid;\n    bool HasKnownValue;\n    bool KnownValue;\n\n    friend class Sema;\n    ConditionResult(Sema &S, Decl *ConditionVar, FullExprArg Condition,\n                    bool IsConstexpr)\n        : ConditionVar(ConditionVar), Condition(Condition), Invalid(false),\n          HasKnownValue(IsConstexpr && Condition.get() &&\n                        !Condition.get()->isValueDependent()),\n          KnownValue(HasKnownValue &&\n                     !!Condition.get()->EvaluateKnownConstInt(S.Context)) {}\n    explicit ConditionResult(bool Invalid)\n        : ConditionVar(nullptr), Condition(nullptr), Invalid(Invalid),\n          HasKnownValue(false), KnownValue(false) {}\n\n  public:\n    ConditionResult() : ConditionResult(false) {}\n    bool isInvalid() const { return Invalid; }\n    std::pair<VarDecl *, Expr *> get() const {\n      return std::make_pair(cast_or_null<VarDecl>(ConditionVar),\n                            Condition.get());\n    }\n    llvm::Optional<bool> getKnownValue() const {\n      if (!HasKnownValue)\n        return None;\n      return KnownValue;\n    }\n  };\n  static ConditionResult ConditionError() { return ConditionResult(true); }\n\n  enum class ConditionKind {\n    Boolean,     ///< A boolean condition, from 'if', 'while', 'for', or 'do'.\n    ConstexprIf, ///< A constant boolean condition from 'if constexpr'.\n    Switch       ///< An integral condition for a 'switch' statement.\n  };\n\n  ConditionResult ActOnCondition(Scope *S, SourceLocation Loc,\n                                 Expr *SubExpr, ConditionKind CK);\n\n  ConditionResult ActOnConditionVariable(Decl *ConditionVar,\n                                         SourceLocation StmtLoc,\n                                         ConditionKind CK);\n\n  DeclResult ActOnCXXConditionDeclaration(Scope *S, Declarator &D);\n\n  ExprResult CheckConditionVariable(VarDecl *ConditionVar,\n                                    SourceLocation StmtLoc,\n                                    ConditionKind CK);\n  ExprResult CheckSwitchCondition(SourceLocation SwitchLoc, Expr *Cond);\n\n  /// CheckBooleanCondition - Diagnose problems involving the use of\n  /// the given expression as a boolean condition (e.g. in an if\n  /// statement).  Also performs the standard function and array\n  /// decays, possibly changing the input variable.\n  ///\n  /// \\param Loc - A location associated with the condition, e.g. the\n  /// 'if' keyword.\n  /// \\return true iff there were any errors\n  ExprResult CheckBooleanCondition(SourceLocation Loc, Expr *E,\n                                   bool IsConstexpr = false);\n\n  /// ActOnExplicitBoolSpecifier - Build an ExplicitSpecifier from an expression\n  /// found in an explicit(bool) specifier.\n  ExplicitSpecifier ActOnExplicitBoolSpecifier(Expr *E);\n\n  /// tryResolveExplicitSpecifier - Attempt to resolve the explict specifier.\n  /// Returns true if the explicit specifier is now resolved.\n  bool tryResolveExplicitSpecifier(ExplicitSpecifier &ExplicitSpec);\n\n  /// DiagnoseAssignmentAsCondition - Given that an expression is\n  /// being used as a boolean condition, warn if it's an assignment.\n  void DiagnoseAssignmentAsCondition(Expr *E);\n\n  /// Redundant parentheses over an equality comparison can indicate\n  /// that the user intended an assignment used as condition.\n  void DiagnoseEqualityWithExtraParens(ParenExpr *ParenE);\n\n  /// CheckCXXBooleanCondition - Returns true if conversion to bool is invalid.\n  ExprResult CheckCXXBooleanCondition(Expr *CondExpr, bool IsConstexpr = false);\n\n  /// ConvertIntegerToTypeWarnOnOverflow - Convert the specified APInt to have\n  /// the specified width and sign.  If an overflow occurs, detect it and emit\n  /// the specified diagnostic.\n  void ConvertIntegerToTypeWarnOnOverflow(llvm::APSInt &OldVal,\n                                          unsigned NewWidth, bool NewSign,\n                                          SourceLocation Loc, unsigned DiagID);\n\n  /// Checks that the Objective-C declaration is declared in the global scope.\n  /// Emits an error and marks the declaration as invalid if it's not declared\n  /// in the global scope.\n  bool CheckObjCDeclScope(Decl *D);\n\n  /// Abstract base class used for diagnosing integer constant\n  /// expression violations.\n  class VerifyICEDiagnoser {\n  public:\n    bool Suppress;\n\n    VerifyICEDiagnoser(bool Suppress = false) : Suppress(Suppress) { }\n\n    virtual SemaDiagnosticBuilder\n    diagnoseNotICEType(Sema &S, SourceLocation Loc, QualType T);\n    virtual SemaDiagnosticBuilder diagnoseNotICE(Sema &S,\n                                                 SourceLocation Loc) = 0;\n    virtual SemaDiagnosticBuilder diagnoseFold(Sema &S, SourceLocation Loc);\n    virtual ~VerifyICEDiagnoser() {}\n  };\n\n  enum AllowFoldKind {\n    NoFold,\n    AllowFold,\n  };\n\n  /// VerifyIntegerConstantExpression - Verifies that an expression is an ICE,\n  /// and reports the appropriate diagnostics. Returns false on success.\n  /// Can optionally return the value of the expression.\n  ExprResult VerifyIntegerConstantExpression(Expr *E, llvm::APSInt *Result,\n                                             VerifyICEDiagnoser &Diagnoser,\n                                             AllowFoldKind CanFold = NoFold);\n  ExprResult VerifyIntegerConstantExpression(Expr *E, llvm::APSInt *Result,\n                                             unsigned DiagID,\n                                             AllowFoldKind CanFold = NoFold);\n  ExprResult VerifyIntegerConstantExpression(Expr *E,\n                                             llvm::APSInt *Result = nullptr,\n                                             AllowFoldKind CanFold = NoFold);\n  ExprResult VerifyIntegerConstantExpression(Expr *E,\n                                             AllowFoldKind CanFold = NoFold) {\n    return VerifyIntegerConstantExpression(E, nullptr, CanFold);\n  }\n\n  /// VerifyBitField - verifies that a bit field expression is an ICE and has\n  /// the correct width, and that the field type is valid.\n  /// Returns false on success.\n  /// Can optionally return whether the bit-field is of width 0\n  ExprResult VerifyBitField(SourceLocation FieldLoc, IdentifierInfo *FieldName,\n                            QualType FieldTy, bool IsMsStruct,\n                            Expr *BitWidth, bool *ZeroWidth = nullptr);\n\nprivate:\n  unsigned ForceCUDAHostDeviceDepth = 0;\n\npublic:\n  /// Increments our count of the number of times we've seen a pragma forcing\n  /// functions to be __host__ __device__.  So long as this count is greater\n  /// than zero, all functions encountered will be __host__ __device__.\n  void PushForceCUDAHostDevice();\n\n  /// Decrements our count of the number of times we've seen a pragma forcing\n  /// functions to be __host__ __device__.  Returns false if the count is 0\n  /// before incrementing, so you can emit an error.\n  bool PopForceCUDAHostDevice();\n\n  /// Diagnostics that are emitted only if we discover that the given function\n  /// must be codegen'ed.  Because handling these correctly adds overhead to\n  /// compilation, this is currently only enabled for CUDA compilations.\n  llvm::DenseMap<CanonicalDeclPtr<FunctionDecl>,\n                 std::vector<PartialDiagnosticAt>>\n      DeviceDeferredDiags;\n\n  /// A pair of a canonical FunctionDecl and a SourceLocation.  When used as the\n  /// key in a hashtable, both the FD and location are hashed.\n  struct FunctionDeclAndLoc {\n    CanonicalDeclPtr<FunctionDecl> FD;\n    SourceLocation Loc;\n  };\n\n  /// FunctionDecls and SourceLocations for which CheckCUDACall has emitted a\n  /// (maybe deferred) \"bad call\" diagnostic.  We use this to avoid emitting the\n  /// same deferred diag twice.\n  llvm::DenseSet<FunctionDeclAndLoc> LocsWithCUDACallDiags;\n\n  /// An inverse call graph, mapping known-emitted functions to one of their\n  /// known-emitted callers (plus the location of the call).\n  ///\n  /// Functions that we can tell a priori must be emitted aren't added to this\n  /// map.\n  llvm::DenseMap</* Callee = */ CanonicalDeclPtr<FunctionDecl>,\n                 /* Caller = */ FunctionDeclAndLoc>\n      DeviceKnownEmittedFns;\n\n  /// Creates a SemaDiagnosticBuilder that emits the diagnostic if the current\n  /// context is \"used as device code\".\n  ///\n  /// - If CurContext is a __host__ function, does not emit any diagnostics\n  ///   unless \\p EmitOnBothSides is true.\n  /// - If CurContext is a __device__ or __global__ function, emits the\n  ///   diagnostics immediately.\n  /// - If CurContext is a __host__ __device__ function and we are compiling for\n  ///   the device, creates a diagnostic which is emitted if and when we realize\n  ///   that the function will be codegen'ed.\n  ///\n  /// Example usage:\n  ///\n  ///  // Variable-length arrays are not allowed in CUDA device code.\n  ///  if (CUDADiagIfDeviceCode(Loc, diag::err_cuda_vla) << CurrentCUDATarget())\n  ///    return ExprError();\n  ///  // Otherwise, continue parsing as normal.\n  SemaDiagnosticBuilder CUDADiagIfDeviceCode(SourceLocation Loc,\n                                             unsigned DiagID);\n\n  /// Creates a SemaDiagnosticBuilder that emits the diagnostic if the current\n  /// context is \"used as host code\".\n  ///\n  /// Same as CUDADiagIfDeviceCode, with \"host\" and \"device\" switched.\n  SemaDiagnosticBuilder CUDADiagIfHostCode(SourceLocation Loc, unsigned DiagID);\n\n  /// Creates a SemaDiagnosticBuilder that emits the diagnostic if the current\n  /// context is \"used as device code\".\n  ///\n  /// - If CurContext is a `declare target` function or it is known that the\n  /// function is emitted for the device, emits the diagnostics immediately.\n  /// - If CurContext is a non-`declare target` function and we are compiling\n  ///   for the device, creates a diagnostic which is emitted if and when we\n  ///   realize that the function will be codegen'ed.\n  ///\n  /// Example usage:\n  ///\n  ///  // Variable-length arrays are not allowed in NVPTX device code.\n  ///  if (diagIfOpenMPDeviceCode(Loc, diag::err_vla_unsupported))\n  ///    return ExprError();\n  ///  // Otherwise, continue parsing as normal.\n  SemaDiagnosticBuilder\n  diagIfOpenMPDeviceCode(SourceLocation Loc, unsigned DiagID, FunctionDecl *FD);\n\n  /// Creates a SemaDiagnosticBuilder that emits the diagnostic if the current\n  /// context is \"used as host code\".\n  ///\n  /// - If CurContext is a `declare target` function or it is known that the\n  /// function is emitted for the host, emits the diagnostics immediately.\n  /// - If CurContext is a non-host function, just ignore it.\n  ///\n  /// Example usage:\n  ///\n  ///  // Variable-length arrays are not allowed in NVPTX device code.\n  ///  if (diagIfOpenMPHostode(Loc, diag::err_vla_unsupported))\n  ///    return ExprError();\n  ///  // Otherwise, continue parsing as normal.\n  SemaDiagnosticBuilder diagIfOpenMPHostCode(SourceLocation Loc,\n                                             unsigned DiagID, FunctionDecl *FD);\n\n  SemaDiagnosticBuilder targetDiag(SourceLocation Loc, unsigned DiagID,\n                                   FunctionDecl *FD = nullptr);\n  SemaDiagnosticBuilder targetDiag(SourceLocation Loc,\n                                   const PartialDiagnostic &PD,\n                                   FunctionDecl *FD = nullptr) {\n    return targetDiag(Loc, PD.getDiagID(), FD) << PD;\n  }\n\n  /// Check if the expression is allowed to be used in expressions for the\n  /// offloading devices.\n  void checkDeviceDecl(ValueDecl *D, SourceLocation Loc);\n\n  enum CUDAFunctionTarget {\n    CFT_Device,\n    CFT_Global,\n    CFT_Host,\n    CFT_HostDevice,\n    CFT_InvalidTarget\n  };\n\n  /// Determines whether the given function is a CUDA device/host/kernel/etc.\n  /// function.\n  ///\n  /// Use this rather than examining the function's attributes yourself -- you\n  /// will get it wrong.  Returns CFT_Host if D is null.\n  CUDAFunctionTarget IdentifyCUDATarget(const FunctionDecl *D,\n                                        bool IgnoreImplicitHDAttr = false);\n  CUDAFunctionTarget IdentifyCUDATarget(const ParsedAttributesView &Attrs);\n\n  /// Gets the CUDA target for the current context.\n  CUDAFunctionTarget CurrentCUDATarget() {\n    return IdentifyCUDATarget(dyn_cast<FunctionDecl>(CurContext));\n  }\n\n  static bool isCUDAImplicitHostDeviceFunction(const FunctionDecl *D);\n\n  // CUDA function call preference. Must be ordered numerically from\n  // worst to best.\n  enum CUDAFunctionPreference {\n    CFP_Never,      // Invalid caller/callee combination.\n    CFP_WrongSide,  // Calls from host-device to host or device\n                    // function that do not match current compilation\n                    // mode.\n    CFP_HostDevice, // Any calls to host/device functions.\n    CFP_SameSide,   // Calls from host-device to host or device\n                    // function matching current compilation mode.\n    CFP_Native,     // host-to-host or device-to-device calls.\n  };\n\n  /// Identifies relative preference of a given Caller/Callee\n  /// combination, based on their host/device attributes.\n  /// \\param Caller function which needs address of \\p Callee.\n  ///               nullptr in case of global context.\n  /// \\param Callee target function\n  ///\n  /// \\returns preference value for particular Caller/Callee combination.\n  CUDAFunctionPreference IdentifyCUDAPreference(const FunctionDecl *Caller,\n                                                const FunctionDecl *Callee);\n\n  /// Determines whether Caller may invoke Callee, based on their CUDA\n  /// host/device attributes.  Returns false if the call is not allowed.\n  ///\n  /// Note: Will return true for CFP_WrongSide calls.  These may appear in\n  /// semantically correct CUDA programs, but only if they're never codegen'ed.\n  bool IsAllowedCUDACall(const FunctionDecl *Caller,\n                         const FunctionDecl *Callee) {\n    return IdentifyCUDAPreference(Caller, Callee) != CFP_Never;\n  }\n\n  /// May add implicit CUDAHostAttr and CUDADeviceAttr attributes to FD,\n  /// depending on FD and the current compilation settings.\n  void maybeAddCUDAHostDeviceAttrs(FunctionDecl *FD,\n                                   const LookupResult &Previous);\n\n  /// May add implicit CUDAConstantAttr attribute to VD, depending on VD\n  /// and current compilation settings.\n  void MaybeAddCUDAConstantAttr(VarDecl *VD);\n\npublic:\n  /// Check whether we're allowed to call Callee from the current context.\n  ///\n  /// - If the call is never allowed in a semantically-correct program\n  ///   (CFP_Never), emits an error and returns false.\n  ///\n  /// - If the call is allowed in semantically-correct programs, but only if\n  ///   it's never codegen'ed (CFP_WrongSide), creates a deferred diagnostic to\n  ///   be emitted if and when the caller is codegen'ed, and returns true.\n  ///\n  ///   Will only create deferred diagnostics for a given SourceLocation once,\n  ///   so you can safely call this multiple times without generating duplicate\n  ///   deferred errors.\n  ///\n  /// - Otherwise, returns true without emitting any diagnostics.\n  bool CheckCUDACall(SourceLocation Loc, FunctionDecl *Callee);\n\n  void CUDACheckLambdaCapture(CXXMethodDecl *D, const sema::Capture &Capture);\n\n  /// Set __device__ or __host__ __device__ attributes on the given lambda\n  /// operator() method.\n  ///\n  /// CUDA lambdas by default is host device function unless it has explicit\n  /// host or device attribute.\n  void CUDASetLambdaAttrs(CXXMethodDecl *Method);\n\n  /// Finds a function in \\p Matches with highest calling priority\n  /// from \\p Caller context and erases all functions with lower\n  /// calling priority.\n  void EraseUnwantedCUDAMatches(\n      const FunctionDecl *Caller,\n      SmallVectorImpl<std::pair<DeclAccessPair, FunctionDecl *>> &Matches);\n\n  /// Given a implicit special member, infer its CUDA target from the\n  /// calls it needs to make to underlying base/field special members.\n  /// \\param ClassDecl the class for which the member is being created.\n  /// \\param CSM the kind of special member.\n  /// \\param MemberDecl the special member itself.\n  /// \\param ConstRHS true if this is a copy operation with a const object on\n  ///        its RHS.\n  /// \\param Diagnose true if this call should emit diagnostics.\n  /// \\return true if there was an error inferring.\n  /// The result of this call is implicit CUDA target attribute(s) attached to\n  /// the member declaration.\n  bool inferCUDATargetForImplicitSpecialMember(CXXRecordDecl *ClassDecl,\n                                               CXXSpecialMember CSM,\n                                               CXXMethodDecl *MemberDecl,\n                                               bool ConstRHS,\n                                               bool Diagnose);\n\n  /// \\return true if \\p CD can be considered empty according to CUDA\n  /// (E.2.3.1 in CUDA 7.5 Programming guide).\n  bool isEmptyCudaConstructor(SourceLocation Loc, CXXConstructorDecl *CD);\n  bool isEmptyCudaDestructor(SourceLocation Loc, CXXDestructorDecl *CD);\n\n  // \\brief Checks that initializers of \\p Var satisfy CUDA restrictions. In\n  // case of error emits appropriate diagnostic and invalidates \\p Var.\n  //\n  // \\details CUDA allows only empty constructors as initializers for global\n  // variables (see E.2.3.1, CUDA 7.5). The same restriction also applies to all\n  // __shared__ variables whether they are local or not (they all are implicitly\n  // static in CUDA). One exception is that CUDA allows constant initializers\n  // for __constant__ and __device__ variables.\n  void checkAllowedCUDAInitializer(VarDecl *VD);\n\n  /// Check whether NewFD is a valid overload for CUDA. Emits\n  /// diagnostics and invalidates NewFD if not.\n  void checkCUDATargetOverload(FunctionDecl *NewFD,\n                               const LookupResult &Previous);\n  /// Copies target attributes from the template TD to the function FD.\n  void inheritCUDATargetAttrs(FunctionDecl *FD, const FunctionTemplateDecl &TD);\n\n  /// Returns the name of the launch configuration function.  This is the name\n  /// of the function that will be called to configure kernel call, with the\n  /// parameters specified via <<<>>>.\n  std::string getCudaConfigureFuncName() const;\n\n  /// \\name Code completion\n  //@{\n  /// Describes the context in which code completion occurs.\n  enum ParserCompletionContext {\n    /// Code completion occurs at top-level or namespace context.\n    PCC_Namespace,\n    /// Code completion occurs within a class, struct, or union.\n    PCC_Class,\n    /// Code completion occurs within an Objective-C interface, protocol,\n    /// or category.\n    PCC_ObjCInterface,\n    /// Code completion occurs within an Objective-C implementation or\n    /// category implementation\n    PCC_ObjCImplementation,\n    /// Code completion occurs within the list of instance variables\n    /// in an Objective-C interface, protocol, category, or implementation.\n    PCC_ObjCInstanceVariableList,\n    /// Code completion occurs following one or more template\n    /// headers.\n    PCC_Template,\n    /// Code completion occurs following one or more template\n    /// headers within a class.\n    PCC_MemberTemplate,\n    /// Code completion occurs within an expression.\n    PCC_Expression,\n    /// Code completion occurs within a statement, which may\n    /// also be an expression or a declaration.\n    PCC_Statement,\n    /// Code completion occurs at the beginning of the\n    /// initialization statement (or expression) in a for loop.\n    PCC_ForInit,\n    /// Code completion occurs within the condition of an if,\n    /// while, switch, or for statement.\n    PCC_Condition,\n    /// Code completion occurs within the body of a function on a\n    /// recovery path, where we do not have a specific handle on our position\n    /// in the grammar.\n    PCC_RecoveryInFunction,\n    /// Code completion occurs where only a type is permitted.\n    PCC_Type,\n    /// Code completion occurs in a parenthesized expression, which\n    /// might also be a type cast.\n    PCC_ParenthesizedExpression,\n    /// Code completion occurs within a sequence of declaration\n    /// specifiers within a function, method, or block.\n    PCC_LocalDeclarationSpecifiers\n  };\n\n  void CodeCompleteModuleImport(SourceLocation ImportLoc, ModuleIdPath Path);\n  void CodeCompleteOrdinaryName(Scope *S,\n                                ParserCompletionContext CompletionContext);\n  void CodeCompleteDeclSpec(Scope *S, DeclSpec &DS,\n                            bool AllowNonIdentifiers,\n                            bool AllowNestedNameSpecifiers);\n\n  struct CodeCompleteExpressionData;\n  void CodeCompleteExpression(Scope *S,\n                              const CodeCompleteExpressionData &Data);\n  void CodeCompleteExpression(Scope *S, QualType PreferredType,\n                              bool IsParenthesized = false);\n  void CodeCompleteMemberReferenceExpr(Scope *S, Expr *Base, Expr *OtherOpBase,\n                                       SourceLocation OpLoc, bool IsArrow,\n                                       bool IsBaseExprStatement,\n                                       QualType PreferredType);\n  void CodeCompletePostfixExpression(Scope *S, ExprResult LHS,\n                                     QualType PreferredType);\n  void CodeCompleteTag(Scope *S, unsigned TagSpec);\n  void CodeCompleteTypeQualifiers(DeclSpec &DS);\n  void CodeCompleteFunctionQualifiers(DeclSpec &DS, Declarator &D,\n                                      const VirtSpecifiers *VS = nullptr);\n  void CodeCompleteBracketDeclarator(Scope *S);\n  void CodeCompleteCase(Scope *S);\n  /// Reports signatures for a call to CodeCompleteConsumer and returns the\n  /// preferred type for the current argument. Returned type can be null.\n  QualType ProduceCallSignatureHelp(Scope *S, Expr *Fn, ArrayRef<Expr *> Args,\n                                    SourceLocation OpenParLoc);\n  QualType ProduceConstructorSignatureHelp(Scope *S, QualType Type,\n                                           SourceLocation Loc,\n                                           ArrayRef<Expr *> Args,\n                                           SourceLocation OpenParLoc);\n  QualType ProduceCtorInitMemberSignatureHelp(Scope *S, Decl *ConstructorDecl,\n                                              CXXScopeSpec SS,\n                                              ParsedType TemplateTypeTy,\n                                              ArrayRef<Expr *> ArgExprs,\n                                              IdentifierInfo *II,\n                                              SourceLocation OpenParLoc);\n  void CodeCompleteInitializer(Scope *S, Decl *D);\n  /// Trigger code completion for a record of \\p BaseType. \\p InitExprs are\n  /// expressions in the initializer list seen so far and \\p D is the current\n  /// Designation being parsed.\n  void CodeCompleteDesignator(const QualType BaseType,\n                              llvm::ArrayRef<Expr *> InitExprs,\n                              const Designation &D);\n  void CodeCompleteAfterIf(Scope *S, bool IsBracedThen);\n\n  void CodeCompleteQualifiedId(Scope *S, CXXScopeSpec &SS, bool EnteringContext,\n                               bool IsUsingDeclaration, QualType BaseType,\n                               QualType PreferredType);\n  void CodeCompleteUsing(Scope *S);\n  void CodeCompleteUsingDirective(Scope *S);\n  void CodeCompleteNamespaceDecl(Scope *S);\n  void CodeCompleteNamespaceAliasDecl(Scope *S);\n  void CodeCompleteOperatorName(Scope *S);\n  void CodeCompleteConstructorInitializer(\n                                Decl *Constructor,\n                                ArrayRef<CXXCtorInitializer *> Initializers);\n\n  void CodeCompleteLambdaIntroducer(Scope *S, LambdaIntroducer &Intro,\n                                    bool AfterAmpersand);\n  void CodeCompleteAfterFunctionEquals(Declarator &D);\n\n  void CodeCompleteObjCAtDirective(Scope *S);\n  void CodeCompleteObjCAtVisibility(Scope *S);\n  void CodeCompleteObjCAtStatement(Scope *S);\n  void CodeCompleteObjCAtExpression(Scope *S);\n  void CodeCompleteObjCPropertyFlags(Scope *S, ObjCDeclSpec &ODS);\n  void CodeCompleteObjCPropertyGetter(Scope *S);\n  void CodeCompleteObjCPropertySetter(Scope *S);\n  void CodeCompleteObjCPassingType(Scope *S, ObjCDeclSpec &DS,\n                                   bool IsParameter);\n  void CodeCompleteObjCMessageReceiver(Scope *S);\n  void CodeCompleteObjCSuperMessage(Scope *S, SourceLocation SuperLoc,\n                                    ArrayRef<IdentifierInfo *> SelIdents,\n                                    bool AtArgumentExpression);\n  void CodeCompleteObjCClassMessage(Scope *S, ParsedType Receiver,\n                                    ArrayRef<IdentifierInfo *> SelIdents,\n                                    bool AtArgumentExpression,\n                                    bool IsSuper = false);\n  void CodeCompleteObjCInstanceMessage(Scope *S, Expr *Receiver,\n                                       ArrayRef<IdentifierInfo *> SelIdents,\n                                       bool AtArgumentExpression,\n                                       ObjCInterfaceDecl *Super = nullptr);\n  void CodeCompleteObjCForCollection(Scope *S,\n                                     DeclGroupPtrTy IterationVar);\n  void CodeCompleteObjCSelector(Scope *S,\n                                ArrayRef<IdentifierInfo *> SelIdents);\n  void CodeCompleteObjCProtocolReferences(\n                                         ArrayRef<IdentifierLocPair> Protocols);\n  void CodeCompleteObjCProtocolDecl(Scope *S);\n  void CodeCompleteObjCInterfaceDecl(Scope *S);\n  void CodeCompleteObjCSuperclass(Scope *S,\n                                  IdentifierInfo *ClassName,\n                                  SourceLocation ClassNameLoc);\n  void CodeCompleteObjCImplementationDecl(Scope *S);\n  void CodeCompleteObjCInterfaceCategory(Scope *S,\n                                         IdentifierInfo *ClassName,\n                                         SourceLocation ClassNameLoc);\n  void CodeCompleteObjCImplementationCategory(Scope *S,\n                                              IdentifierInfo *ClassName,\n                                              SourceLocation ClassNameLoc);\n  void CodeCompleteObjCPropertyDefinition(Scope *S);\n  void CodeCompleteObjCPropertySynthesizeIvar(Scope *S,\n                                              IdentifierInfo *PropertyName);\n  void CodeCompleteObjCMethodDecl(Scope *S, Optional<bool> IsInstanceMethod,\n                                  ParsedType ReturnType);\n  void CodeCompleteObjCMethodDeclSelector(Scope *S,\n                                          bool IsInstanceMethod,\n                                          bool AtParameterName,\n                                          ParsedType ReturnType,\n                                          ArrayRef<IdentifierInfo *> SelIdents);\n  void CodeCompleteObjCClassPropertyRefExpr(Scope *S, IdentifierInfo &ClassName,\n                                            SourceLocation ClassNameLoc,\n                                            bool IsBaseExprStatement);\n  void CodeCompletePreprocessorDirective(bool InConditional);\n  void CodeCompleteInPreprocessorConditionalExclusion(Scope *S);\n  void CodeCompletePreprocessorMacroName(bool IsDefinition);\n  void CodeCompletePreprocessorExpression();\n  void CodeCompletePreprocessorMacroArgument(Scope *S,\n                                             IdentifierInfo *Macro,\n                                             MacroInfo *MacroInfo,\n                                             unsigned Argument);\n  void CodeCompleteIncludedFile(llvm::StringRef Dir, bool IsAngled);\n  void CodeCompleteNaturalLanguage();\n  void CodeCompleteAvailabilityPlatformName();\n  void GatherGlobalCodeCompletions(CodeCompletionAllocator &Allocator,\n                                   CodeCompletionTUInfo &CCTUInfo,\n                  SmallVectorImpl<CodeCompletionResult> &Results);\n  //@}\n\n  //===--------------------------------------------------------------------===//\n  // Extra semantic analysis beyond the C type system\n\npublic:\n  SourceLocation getLocationOfStringLiteralByte(const StringLiteral *SL,\n                                                unsigned ByteNo) const;\n\nprivate:\n  void CheckArrayAccess(const Expr *BaseExpr, const Expr *IndexExpr,\n                        const ArraySubscriptExpr *ASE=nullptr,\n                        bool AllowOnePastEnd=true, bool IndexNegated=false);\n  void CheckArrayAccess(const Expr *E);\n  // Used to grab the relevant information from a FormatAttr and a\n  // FunctionDeclaration.\n  struct FormatStringInfo {\n    unsigned FormatIdx;\n    unsigned FirstDataArg;\n    bool HasVAListArg;\n  };\n\n  static bool getFormatStringInfo(const FormatAttr *Format, bool IsCXXMember,\n                                  FormatStringInfo *FSI);\n  bool CheckFunctionCall(FunctionDecl *FDecl, CallExpr *TheCall,\n                         const FunctionProtoType *Proto);\n  bool CheckObjCMethodCall(ObjCMethodDecl *Method, SourceLocation loc,\n                           ArrayRef<const Expr *> Args);\n  bool CheckPointerCall(NamedDecl *NDecl, CallExpr *TheCall,\n                        const FunctionProtoType *Proto);\n  bool CheckOtherCall(CallExpr *TheCall, const FunctionProtoType *Proto);\n  void CheckConstructorCall(FunctionDecl *FDecl, QualType ThisType,\n                            ArrayRef<const Expr *> Args,\n                            const FunctionProtoType *Proto, SourceLocation Loc);\n\n  void CheckArgAlignment(SourceLocation Loc, NamedDecl *FDecl,\n                         StringRef ParamName, QualType ArgTy, QualType ParamTy);\n\n  void checkCall(NamedDecl *FDecl, const FunctionProtoType *Proto,\n                 const Expr *ThisArg, ArrayRef<const Expr *> Args,\n                 bool IsMemberFunction, SourceLocation Loc, SourceRange Range,\n                 VariadicCallType CallType);\n\n  bool CheckObjCString(Expr *Arg);\n  ExprResult CheckOSLogFormatStringArg(Expr *Arg);\n\n  ExprResult CheckBuiltinFunctionCall(FunctionDecl *FDecl,\n                                      unsigned BuiltinID, CallExpr *TheCall);\n\n  bool CheckTSBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                  CallExpr *TheCall);\n\n  void checkFortifiedBuiltinMemoryFunction(FunctionDecl *FD, CallExpr *TheCall);\n\n  bool CheckARMBuiltinExclusiveCall(unsigned BuiltinID, CallExpr *TheCall,\n                                    unsigned MaxWidth);\n  bool CheckNeonBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                    CallExpr *TheCall);\n  bool CheckMVEBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckSVEBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckCDEBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                   CallExpr *TheCall);\n  bool CheckARMCoprocessorImmediate(const TargetInfo &TI, const Expr *CoprocArg,\n                                    bool WantCDE);\n  bool CheckARMBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                   CallExpr *TheCall);\n\n  bool CheckAArch64BuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                       CallExpr *TheCall);\n  bool CheckBPFBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckHexagonBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckHexagonBuiltinArgument(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckMipsBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                    CallExpr *TheCall);\n  bool CheckMipsBuiltinCpu(const TargetInfo &TI, unsigned BuiltinID,\n                           CallExpr *TheCall);\n  bool CheckMipsBuiltinArgument(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckSystemZBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckX86BuiltinRoundingOrSAE(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckX86BuiltinGatherScatterScale(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckX86BuiltinTileArguments(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckX86BuiltinTileArgumentsRange(CallExpr *TheCall,\n                                         ArrayRef<int> ArgNums);\n  bool CheckX86BuiltinTileDuplicate(CallExpr *TheCall, ArrayRef<int> ArgNums);\n  bool CheckX86BuiltinTileRangeAndDuplicate(CallExpr *TheCall,\n                                            ArrayRef<int> ArgNums);\n  bool CheckX86BuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                   CallExpr *TheCall);\n  bool CheckPPCBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                   CallExpr *TheCall);\n  bool CheckAMDGCNBuiltinFunctionCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool CheckRISCVBuiltinFunctionCall(const TargetInfo &TI, unsigned BuiltinID,\n                                     CallExpr *TheCall);\n\n  bool SemaBuiltinVAStart(unsigned BuiltinID, CallExpr *TheCall);\n  bool SemaBuiltinVAStartARMMicrosoft(CallExpr *Call);\n  bool SemaBuiltinUnorderedCompare(CallExpr *TheCall);\n  bool SemaBuiltinFPClassification(CallExpr *TheCall, unsigned NumArgs);\n  bool SemaBuiltinComplex(CallExpr *TheCall);\n  bool SemaBuiltinVSX(CallExpr *TheCall);\n  bool SemaBuiltinOSLogFormat(CallExpr *TheCall);\n\npublic:\n  // Used by C++ template instantiation.\n  ExprResult SemaBuiltinShuffleVector(CallExpr *TheCall);\n  ExprResult SemaConvertVectorExpr(Expr *E, TypeSourceInfo *TInfo,\n                                   SourceLocation BuiltinLoc,\n                                   SourceLocation RParenLoc);\n\nprivate:\n  bool SemaBuiltinPrefetch(CallExpr *TheCall);\n  bool SemaBuiltinAllocaWithAlign(CallExpr *TheCall);\n  bool SemaBuiltinAssume(CallExpr *TheCall);\n  bool SemaBuiltinAssumeAligned(CallExpr *TheCall);\n  bool SemaBuiltinLongjmp(CallExpr *TheCall);\n  bool SemaBuiltinSetjmp(CallExpr *TheCall);\n  ExprResult SemaBuiltinAtomicOverloaded(ExprResult TheCallResult);\n  ExprResult SemaBuiltinNontemporalOverloaded(ExprResult TheCallResult);\n  ExprResult SemaAtomicOpsOverloaded(ExprResult TheCallResult,\n                                     AtomicExpr::AtomicOp Op);\n  ExprResult SemaBuiltinOperatorNewDeleteOverloaded(ExprResult TheCallResult,\n                                                    bool IsDelete);\n  bool SemaBuiltinConstantArg(CallExpr *TheCall, int ArgNum,\n                              llvm::APSInt &Result);\n  bool SemaBuiltinConstantArgRange(CallExpr *TheCall, int ArgNum, int Low,\n                                   int High, bool RangeIsError = true);\n  bool SemaBuiltinConstantArgMultiple(CallExpr *TheCall, int ArgNum,\n                                      unsigned Multiple);\n  bool SemaBuiltinConstantArgPower2(CallExpr *TheCall, int ArgNum);\n  bool SemaBuiltinConstantArgShiftedByte(CallExpr *TheCall, int ArgNum,\n                                         unsigned ArgBits);\n  bool SemaBuiltinConstantArgShiftedByteOrXXFF(CallExpr *TheCall, int ArgNum,\n                                               unsigned ArgBits);\n  bool SemaBuiltinARMSpecialReg(unsigned BuiltinID, CallExpr *TheCall,\n                                int ArgNum, unsigned ExpectedFieldNum,\n                                bool AllowName);\n  bool SemaBuiltinARMMemoryTaggingCall(unsigned BuiltinID, CallExpr *TheCall);\n  bool SemaBuiltinPPCMMACall(CallExpr *TheCall, const char *TypeDesc);\n\n  bool CheckPPCMMAType(QualType Type, SourceLocation TypeLoc);\n\n  // Matrix builtin handling.\n  ExprResult SemaBuiltinMatrixTranspose(CallExpr *TheCall,\n                                        ExprResult CallResult);\n  ExprResult SemaBuiltinMatrixColumnMajorLoad(CallExpr *TheCall,\n                                              ExprResult CallResult);\n  ExprResult SemaBuiltinMatrixColumnMajorStore(CallExpr *TheCall,\n                                               ExprResult CallResult);\n\npublic:\n  enum FormatStringType {\n    FST_Scanf,\n    FST_Printf,\n    FST_NSString,\n    FST_Strftime,\n    FST_Strfmon,\n    FST_Kprintf,\n    FST_FreeBSDKPrintf,\n    FST_OSTrace,\n    FST_OSLog,\n    FST_Unknown\n  };\n  static FormatStringType GetFormatStringType(const FormatAttr *Format);\n\n  bool FormatStringHasSArg(const StringLiteral *FExpr);\n\n  static bool GetFormatNSStringIdx(const FormatAttr *Format, unsigned &Idx);\n\nprivate:\n  bool CheckFormatArguments(const FormatAttr *Format,\n                            ArrayRef<const Expr *> Args,\n                            bool IsCXXMember,\n                            VariadicCallType CallType,\n                            SourceLocation Loc, SourceRange Range,\n                            llvm::SmallBitVector &CheckedVarArgs);\n  bool CheckFormatArguments(ArrayRef<const Expr *> Args,\n                            bool HasVAListArg, unsigned format_idx,\n                            unsigned firstDataArg, FormatStringType Type,\n                            VariadicCallType CallType,\n                            SourceLocation Loc, SourceRange range,\n                            llvm::SmallBitVector &CheckedVarArgs);\n\n  void CheckAbsoluteValueFunction(const CallExpr *Call,\n                                  const FunctionDecl *FDecl);\n\n  void CheckMaxUnsignedZero(const CallExpr *Call, const FunctionDecl *FDecl);\n\n  void CheckMemaccessArguments(const CallExpr *Call,\n                               unsigned BId,\n                               IdentifierInfo *FnName);\n\n  void CheckStrlcpycatArguments(const CallExpr *Call,\n                                IdentifierInfo *FnName);\n\n  void CheckStrncatArguments(const CallExpr *Call,\n                             IdentifierInfo *FnName);\n\n  void CheckFreeArguments(const CallExpr *E);\n\n  void CheckReturnValExpr(Expr *RetValExp, QualType lhsType,\n                          SourceLocation ReturnLoc,\n                          bool isObjCMethod = false,\n                          const AttrVec *Attrs = nullptr,\n                          const FunctionDecl *FD = nullptr);\n\npublic:\n  void CheckFloatComparison(SourceLocation Loc, Expr *LHS, Expr *RHS);\n\nprivate:\n  void CheckImplicitConversions(Expr *E, SourceLocation CC = SourceLocation());\n  void CheckBoolLikeConversion(Expr *E, SourceLocation CC);\n  void CheckForIntOverflow(Expr *E);\n  void CheckUnsequencedOperations(const Expr *E);\n\n  /// Perform semantic checks on a completed expression. This will either\n  /// be a full-expression or a default argument expression.\n  void CheckCompletedExpr(Expr *E, SourceLocation CheckLoc = SourceLocation(),\n                          bool IsConstexpr = false);\n\n  void CheckBitFieldInitialization(SourceLocation InitLoc, FieldDecl *Field,\n                                   Expr *Init);\n\n  /// Check if there is a field shadowing.\n  void CheckShadowInheritedFields(const SourceLocation &Loc,\n                                  DeclarationName FieldName,\n                                  const CXXRecordDecl *RD,\n                                  bool DeclIsField = true);\n\n  /// Check if the given expression contains 'break' or 'continue'\n  /// statement that produces control flow different from GCC.\n  void CheckBreakContinueBinding(Expr *E);\n\n  /// Check whether receiver is mutable ObjC container which\n  /// attempts to add itself into the container\n  void CheckObjCCircularContainer(ObjCMessageExpr *Message);\n\n  void CheckTCBEnforcement(const CallExpr *TheCall, const FunctionDecl *Callee);\n\n  void AnalyzeDeleteExprMismatch(const CXXDeleteExpr *DE);\n  void AnalyzeDeleteExprMismatch(FieldDecl *Field, SourceLocation DeleteLoc,\n                                 bool DeleteWasArrayForm);\npublic:\n  /// Register a magic integral constant to be used as a type tag.\n  void RegisterTypeTagForDatatype(const IdentifierInfo *ArgumentKind,\n                                  uint64_t MagicValue, QualType Type,\n                                  bool LayoutCompatible, bool MustBeNull);\n\n  struct TypeTagData {\n    TypeTagData() {}\n\n    TypeTagData(QualType Type, bool LayoutCompatible, bool MustBeNull) :\n        Type(Type), LayoutCompatible(LayoutCompatible),\n        MustBeNull(MustBeNull)\n    {}\n\n    QualType Type;\n\n    /// If true, \\c Type should be compared with other expression's types for\n    /// layout-compatibility.\n    unsigned LayoutCompatible : 1;\n    unsigned MustBeNull : 1;\n  };\n\n  /// A pair of ArgumentKind identifier and magic value.  This uniquely\n  /// identifies the magic value.\n  typedef std::pair<const IdentifierInfo *, uint64_t> TypeTagMagicValue;\n\nprivate:\n  /// A map from magic value to type information.\n  std::unique_ptr<llvm::DenseMap<TypeTagMagicValue, TypeTagData>>\n      TypeTagForDatatypeMagicValues;\n\n  /// Peform checks on a call of a function with argument_with_type_tag\n  /// or pointer_with_type_tag attributes.\n  void CheckArgumentWithTypeTag(const ArgumentWithTypeTagAttr *Attr,\n                                const ArrayRef<const Expr *> ExprArgs,\n                                SourceLocation CallSiteLoc);\n\n  /// Check if we are taking the address of a packed field\n  /// as this may be a problem if the pointer value is dereferenced.\n  void CheckAddressOfPackedMember(Expr *rhs);\n\n  /// The parser's current scope.\n  ///\n  /// The parser maintains this state here.\n  Scope *CurScope;\n\n  mutable IdentifierInfo *Ident_super;\n  mutable IdentifierInfo *Ident___float128;\n\n  /// Nullability type specifiers.\n  IdentifierInfo *Ident__Nonnull = nullptr;\n  IdentifierInfo *Ident__Nullable = nullptr;\n  IdentifierInfo *Ident__Nullable_result = nullptr;\n  IdentifierInfo *Ident__Null_unspecified = nullptr;\n\n  IdentifierInfo *Ident_NSError = nullptr;\n\n  /// The handler for the FileChanged preprocessor events.\n  ///\n  /// Used for diagnostics that implement custom semantic analysis for #include\n  /// directives, like -Wpragma-pack.\n  sema::SemaPPCallbacks *SemaPPCallbackHandler;\n\nprotected:\n  friend class Parser;\n  friend class InitializationSequence;\n  friend class ASTReader;\n  friend class ASTDeclReader;\n  friend class ASTWriter;\n\npublic:\n  /// Retrieve the keyword associated\n  IdentifierInfo *getNullabilityKeyword(NullabilityKind nullability);\n\n  /// The struct behind the CFErrorRef pointer.\n  RecordDecl *CFError = nullptr;\n  bool isCFError(RecordDecl *D);\n\n  /// Retrieve the identifier \"NSError\".\n  IdentifierInfo *getNSErrorIdent();\n\n  /// Retrieve the parser's current scope.\n  ///\n  /// This routine must only be used when it is certain that semantic analysis\n  /// and the parser are in precisely the same context, which is not the case\n  /// when, e.g., we are performing any kind of template instantiation.\n  /// Therefore, the only safe places to use this scope are in the parser\n  /// itself and in routines directly invoked from the parser and *never* from\n  /// template substitution or instantiation.\n  Scope *getCurScope() const { return CurScope; }\n\n  void incrementMSManglingNumber() const {\n    return CurScope->incrementMSManglingNumber();\n  }\n\n  IdentifierInfo *getSuperIdentifier() const;\n  IdentifierInfo *getFloat128Identifier() const;\n\n  Decl *getObjCDeclContext() const;\n\n  DeclContext *getCurLexicalContext() const {\n    return OriginalLexicalContext ? OriginalLexicalContext : CurContext;\n  }\n\n  const DeclContext *getCurObjCLexicalContext() const {\n    const DeclContext *DC = getCurLexicalContext();\n    // A category implicitly has the attribute of the interface.\n    if (const ObjCCategoryDecl *CatD = dyn_cast<ObjCCategoryDecl>(DC))\n      DC = CatD->getClassInterface();\n    return DC;\n  }\n\n  /// Determine the number of levels of enclosing template parameters. This is\n  /// only usable while parsing. Note that this does not include dependent\n  /// contexts in which no template parameters have yet been declared, such as\n  /// in a terse function template or generic lambda before the first 'auto' is\n  /// encountered.\n  unsigned getTemplateDepth(Scope *S) const;\n\n  /// To be used for checking whether the arguments being passed to\n  /// function exceeds the number of parameters expected for it.\n  static bool TooManyArguments(size_t NumParams, size_t NumArgs,\n                               bool PartialOverloading = false) {\n    // We check whether we're just after a comma in code-completion.\n    if (NumArgs > 0 && PartialOverloading)\n      return NumArgs + 1 > NumParams; // If so, we view as an extra argument.\n    return NumArgs > NumParams;\n  }\n\n  // Emitting members of dllexported classes is delayed until the class\n  // (including field initializers) is fully parsed.\n  SmallVector<CXXRecordDecl*, 4> DelayedDllExportClasses;\n  SmallVector<CXXMethodDecl*, 4> DelayedDllExportMemberFunctions;\n\nprivate:\n  int ParsingClassDepth = 0;\n\n  class SavePendingParsedClassStateRAII {\n  public:\n    SavePendingParsedClassStateRAII(Sema &S) : S(S) { swapSavedState(); }\n\n    ~SavePendingParsedClassStateRAII() {\n      assert(S.DelayedOverridingExceptionSpecChecks.empty() &&\n             \"there shouldn't be any pending delayed exception spec checks\");\n      assert(S.DelayedEquivalentExceptionSpecChecks.empty() &&\n             \"there shouldn't be any pending delayed exception spec checks\");\n      swapSavedState();\n    }\n\n  private:\n    Sema &S;\n    decltype(DelayedOverridingExceptionSpecChecks)\n        SavedOverridingExceptionSpecChecks;\n    decltype(DelayedEquivalentExceptionSpecChecks)\n        SavedEquivalentExceptionSpecChecks;\n\n    void swapSavedState() {\n      SavedOverridingExceptionSpecChecks.swap(\n          S.DelayedOverridingExceptionSpecChecks);\n      SavedEquivalentExceptionSpecChecks.swap(\n          S.DelayedEquivalentExceptionSpecChecks);\n    }\n  };\n\n  /// Helper class that collects misaligned member designations and\n  /// their location info for delayed diagnostics.\n  struct MisalignedMember {\n    Expr *E;\n    RecordDecl *RD;\n    ValueDecl *MD;\n    CharUnits Alignment;\n\n    MisalignedMember() : E(), RD(), MD(), Alignment() {}\n    MisalignedMember(Expr *E, RecordDecl *RD, ValueDecl *MD,\n                     CharUnits Alignment)\n        : E(E), RD(RD), MD(MD), Alignment(Alignment) {}\n    explicit MisalignedMember(Expr *E)\n        : MisalignedMember(E, nullptr, nullptr, CharUnits()) {}\n\n    bool operator==(const MisalignedMember &m) { return this->E == m.E; }\n  };\n  /// Small set of gathered accesses to potentially misaligned members\n  /// due to the packed attribute.\n  SmallVector<MisalignedMember, 4> MisalignedMembers;\n\n  /// Adds an expression to the set of gathered misaligned members.\n  void AddPotentialMisalignedMembers(Expr *E, RecordDecl *RD, ValueDecl *MD,\n                                     CharUnits Alignment);\n\npublic:\n  /// Diagnoses the current set of gathered accesses. This typically\n  /// happens at full expression level. The set is cleared after emitting the\n  /// diagnostics.\n  void DiagnoseMisalignedMembers();\n\n  /// This function checks if the expression is in the sef of potentially\n  /// misaligned members and it is converted to some pointer type T with lower\n  /// or equal alignment requirements. If so it removes it. This is used when\n  /// we do not want to diagnose such misaligned access (e.g. in conversions to\n  /// void*).\n  void DiscardMisalignedMemberAddress(const Type *T, Expr *E);\n\n  /// This function calls Action when it determines that E designates a\n  /// misaligned member due to the packed attribute. This is used to emit\n  /// local diagnostics like in reference binding.\n  void RefersToMemberWithReducedAlignment(\n      Expr *E,\n      llvm::function_ref<void(Expr *, RecordDecl *, FieldDecl *, CharUnits)>\n          Action);\n\n  /// Describes the reason a calling convention specification was ignored, used\n  /// for diagnostics.\n  enum class CallingConventionIgnoredReason {\n    ForThisTarget = 0,\n    VariadicFunction,\n    ConstructorDestructor,\n    BuiltinFunction\n  };\n  /// Creates a SemaDiagnosticBuilder that emits the diagnostic if the current\n  /// context is \"used as device code\".\n  ///\n  /// - If CurLexicalContext is a kernel function or it is known that the\n  ///   function will be emitted for the device, emits the diagnostics\n  ///   immediately.\n  /// - If CurLexicalContext is a function and we are compiling\n  ///   for the device, but we don't know that this function will be codegen'ed\n  ///   for devive yet, creates a diagnostic which is emitted if and when we\n  ///   realize that the function will be codegen'ed.\n  ///\n  /// Example usage:\n  ///\n  /// Diagnose __float128 type usage only from SYCL device code if the current\n  /// target doesn't support it\n  /// if (!S.Context.getTargetInfo().hasFloat128Type() &&\n  ///     S.getLangOpts().SYCLIsDevice)\n  ///   SYCLDiagIfDeviceCode(Loc, diag::err_type_unsupported) << \"__float128\";\n  SemaDiagnosticBuilder SYCLDiagIfDeviceCode(SourceLocation Loc,\n                                             unsigned DiagID);\n\n  /// Check whether we're allowed to call Callee from the current context.\n  ///\n  /// - If the call is never allowed in a semantically-correct program\n  ///   emits an error and returns false.\n  ///\n  /// - If the call is allowed in semantically-correct programs, but only if\n  ///   it's never codegen'ed, creates a deferred diagnostic to be emitted if\n  ///   and when the caller is codegen'ed, and returns true.\n  ///\n  /// - Otherwise, returns true without emitting any diagnostics.\n  ///\n  /// Adds Callee to DeviceCallGraph if we don't know if its caller will be\n  /// codegen'ed yet.\n  bool checkSYCLDeviceFunction(SourceLocation Loc, FunctionDecl *Callee);\n};\n\n/// RAII object that enters a new expression evaluation context.\nclass EnterExpressionEvaluationContext {\n  Sema &Actions;\n  bool Entered = true;\n\npublic:\n  EnterExpressionEvaluationContext(\n      Sema &Actions, Sema::ExpressionEvaluationContext NewContext,\n      Decl *LambdaContextDecl = nullptr,\n      Sema::ExpressionEvaluationContextRecord::ExpressionKind ExprContext =\n          Sema::ExpressionEvaluationContextRecord::EK_Other,\n      bool ShouldEnter = true)\n      : Actions(Actions), Entered(ShouldEnter) {\n    if (Entered)\n      Actions.PushExpressionEvaluationContext(NewContext, LambdaContextDecl,\n                                              ExprContext);\n  }\n  EnterExpressionEvaluationContext(\n      Sema &Actions, Sema::ExpressionEvaluationContext NewContext,\n      Sema::ReuseLambdaContextDecl_t,\n      Sema::ExpressionEvaluationContextRecord::ExpressionKind ExprContext =\n          Sema::ExpressionEvaluationContextRecord::EK_Other)\n      : Actions(Actions) {\n    Actions.PushExpressionEvaluationContext(\n        NewContext, Sema::ReuseLambdaContextDecl, ExprContext);\n  }\n\n  enum InitListTag { InitList };\n  EnterExpressionEvaluationContext(Sema &Actions, InitListTag,\n                                   bool ShouldEnter = true)\n      : Actions(Actions), Entered(false) {\n    // In C++11 onwards, narrowing checks are performed on the contents of\n    // braced-init-lists, even when they occur within unevaluated operands.\n    // Therefore we still need to instantiate constexpr functions used in such\n    // a context.\n    if (ShouldEnter && Actions.isUnevaluatedContext() &&\n        Actions.getLangOpts().CPlusPlus11) {\n      Actions.PushExpressionEvaluationContext(\n          Sema::ExpressionEvaluationContext::UnevaluatedList);\n      Entered = true;\n    }\n  }\n\n  ~EnterExpressionEvaluationContext() {\n    if (Entered)\n      Actions.PopExpressionEvaluationContext();\n  }\n};\n\nDeductionFailureInfo\nMakeDeductionFailureInfo(ASTContext &Context, Sema::TemplateDeductionResult TDK,\n                         sema::TemplateDeductionInfo &Info);\n\n/// Contains a late templated function.\n/// Will be parsed at the end of the translation unit, used by Sema & Parser.\nstruct LateParsedTemplate {\n  CachedTokens Toks;\n  /// The template function declaration to be late parsed.\n  Decl *D;\n};\n\ntemplate <>\nvoid Sema::PragmaStack<Sema::AlignPackInfo>::Act(SourceLocation PragmaLocation,\n                                                 PragmaMsStackAction Action,\n                                                 llvm::StringRef StackSlotLabel,\n                                                 AlignPackInfo Value);\n\n} // end namespace clang\n\nnamespace llvm {\n// Hash a FunctionDeclAndLoc by looking at both its FunctionDecl and its\n// SourceLocation.\ntemplate <> struct DenseMapInfo<clang::Sema::FunctionDeclAndLoc> {\n  using FunctionDeclAndLoc = clang::Sema::FunctionDeclAndLoc;\n  using FDBaseInfo = DenseMapInfo<clang::CanonicalDeclPtr<clang::FunctionDecl>>;\n\n  static FunctionDeclAndLoc getEmptyKey() {\n    return {FDBaseInfo::getEmptyKey(), clang::SourceLocation()};\n  }\n\n  static FunctionDeclAndLoc getTombstoneKey() {\n    return {FDBaseInfo::getTombstoneKey(), clang::SourceLocation()};\n  }\n\n  static unsigned getHashValue(const FunctionDeclAndLoc &FDL) {\n    return hash_combine(FDBaseInfo::getHashValue(FDL.FD),\n                        FDL.Loc.getHashValue());\n  }\n\n  static bool isEqual(const FunctionDeclAndLoc &LHS,\n                      const FunctionDeclAndLoc &RHS) {\n    return LHS.FD == RHS.FD && LHS.Loc == RHS.Loc;\n  }\n};\n} // namespace llvm\n\n#endif\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Weak.h", "content": "//===-- UnresolvedSet.h - Unresolved sets of declarations  ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the WeakInfo class, which is used to store\n//  information about the target of a #pragma weak directive.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SEMA_WEAK_H\n#define LLVM_CLANG_SEMA_WEAK_H\n\n#include \"clang/Basic/SourceLocation.h\"\n\nnamespace clang {\n\nclass IdentifierInfo;\n\n/// Captures information about a \\#pragma weak directive.\nclass WeakInfo {\n  IdentifierInfo *alias;  // alias (optional)\n  SourceLocation loc;     // for diagnostics\n  bool used;              // identifier later declared?\npublic:\n  WeakInfo()\n    : alias(nullptr), loc(SourceLocation()), used(false) {}\n  WeakInfo(IdentifierInfo *Alias, SourceLocation Loc)\n    : alias(Alias), loc(Loc), used(false) {}\n  inline IdentifierInfo * getAlias() const { return alias; }\n  inline SourceLocation getLocation() const { return loc; }\n  void setUsed(bool Used=true) { used = Used; }\n  inline bool getUsed() { return used; }\n  bool operator==(WeakInfo RHS) const {\n    return alias == RHS.getAlias() && loc == RHS.getLocation();\n  }\n  bool operator!=(WeakInfo RHS) const { return !(*this == RHS); }\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_SEMA_WEAK_H\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTReader.h", "content": "//===- ASTReader.h - AST File Reader ----------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the ASTReader class, which reads AST files.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_SERIALIZATION_ASTREADER_H\n#define LLVM_CLANG_SERIALIZATION_ASTREADER_H\n\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/DiagnosticOptions.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/OpenCLOptions.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Version.h\"\n#include \"clang/Lex/ExternalPreprocessorSource.h\"\n#include \"clang/Lex/HeaderSearch.h\"\n#include \"clang/Lex/PreprocessingRecord.h\"\n#include \"clang/Lex/PreprocessorOptions.h\"\n#include \"clang/Sema/ExternalSemaSource.h\"\n#include \"clang/Sema/IdentifierResolver.h\"\n#include \"clang/Sema/Sema.h\"\n#include \"clang/Serialization/ASTBitCodes.h\"\n#include \"clang/Serialization/ContinuousRangeMap.h\"\n#include \"clang/Serialization/ModuleFile.h\"\n#include \"clang/Serialization/ModuleFileExtension.h\"\n#include \"clang/Serialization/ModuleManager.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Bitstream/BitstreamReader.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/Timer.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <ctime>\n#include <deque>\n#include <memory>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace clang {\n\nclass ASTConsumer;\nclass ASTContext;\nclass ASTDeserializationListener;\nclass ASTReader;\nclass ASTRecordReader;\nclass CXXTemporary;\nclass Decl;\nclass DeclarationName;\nclass DeclaratorDecl;\nclass DeclContext;\nclass EnumDecl;\nclass Expr;\nclass FieldDecl;\nclass FileEntry;\nclass FileManager;\nclass FileSystemOptions;\nclass FunctionDecl;\nclass GlobalModuleIndex;\nstruct HeaderFileInfo;\nclass HeaderSearchOptions;\nclass LangOptions;\nclass LazyASTUnresolvedSet;\nclass MacroInfo;\nclass InMemoryModuleCache;\nclass NamedDecl;\nclass NamespaceDecl;\nclass ObjCCategoryDecl;\nclass ObjCInterfaceDecl;\nclass PCHContainerReader;\nclass Preprocessor;\nclass PreprocessorOptions;\nstruct QualifierInfo;\nclass Sema;\nclass SourceManager;\nclass Stmt;\nclass SwitchCase;\nclass TargetOptions;\nclass Token;\nclass TypedefNameDecl;\nclass ValueDecl;\nclass VarDecl;\n\n/// Abstract interface for callback invocations by the ASTReader.\n///\n/// While reading an AST file, the ASTReader will call the methods of the\n/// listener to pass on specific information. Some of the listener methods can\n/// return true to indicate to the ASTReader that the information (and\n/// consequently the AST file) is invalid.\nclass ASTReaderListener {\npublic:\n  virtual ~ASTReaderListener();\n\n  /// Receives the full Clang version information.\n  ///\n  /// \\returns true to indicate that the version is invalid. Subclasses should\n  /// generally defer to this implementation.\n  virtual bool ReadFullVersionInformation(StringRef FullVersion) {\n    return FullVersion != getClangFullRepositoryVersion();\n  }\n\n  virtual void ReadModuleName(StringRef ModuleName) {}\n  virtual void ReadModuleMapFile(StringRef ModuleMapPath) {}\n\n  /// Receives the language options.\n  ///\n  /// \\returns true to indicate the options are invalid or false otherwise.\n  virtual bool ReadLanguageOptions(const LangOptions &LangOpts,\n                                   bool Complain,\n                                   bool AllowCompatibleDifferences) {\n    return false;\n  }\n\n  /// Receives the target options.\n  ///\n  /// \\returns true to indicate the target options are invalid, or false\n  /// otherwise.\n  virtual bool ReadTargetOptions(const TargetOptions &TargetOpts, bool Complain,\n                                 bool AllowCompatibleDifferences) {\n    return false;\n  }\n\n  /// Receives the diagnostic options.\n  ///\n  /// \\returns true to indicate the diagnostic options are invalid, or false\n  /// otherwise.\n  virtual bool\n  ReadDiagnosticOptions(IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts,\n                        bool Complain) {\n    return false;\n  }\n\n  /// Receives the file system options.\n  ///\n  /// \\returns true to indicate the file system options are invalid, or false\n  /// otherwise.\n  virtual bool ReadFileSystemOptions(const FileSystemOptions &FSOpts,\n                                     bool Complain) {\n    return false;\n  }\n\n  /// Receives the header search options.\n  ///\n  /// \\returns true to indicate the header search options are invalid, or false\n  /// otherwise.\n  virtual bool ReadHeaderSearchOptions(const HeaderSearchOptions &HSOpts,\n                                       StringRef SpecificModuleCachePath,\n                                       bool Complain) {\n    return false;\n  }\n\n  /// Receives the preprocessor options.\n  ///\n  /// \\param SuggestedPredefines Can be filled in with the set of predefines\n  /// that are suggested by the preprocessor options. Typically only used when\n  /// loading a precompiled header.\n  ///\n  /// \\returns true to indicate the preprocessor options are invalid, or false\n  /// otherwise.\n  virtual bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts,\n                                       bool Complain,\n                                       std::string &SuggestedPredefines) {\n    return false;\n  }\n\n  /// Receives __COUNTER__ value.\n  virtual void ReadCounter(const serialization::ModuleFile &M,\n                           unsigned Value) {}\n\n  /// This is called for each AST file loaded.\n  virtual void visitModuleFile(StringRef Filename,\n                               serialization::ModuleKind Kind) {}\n\n  /// Returns true if this \\c ASTReaderListener wants to receive the\n  /// input files of the AST file via \\c visitInputFile, false otherwise.\n  virtual bool needsInputFileVisitation() { return false; }\n\n  /// Returns true if this \\c ASTReaderListener wants to receive the\n  /// system input files of the AST file via \\c visitInputFile, false otherwise.\n  virtual bool needsSystemInputFileVisitation() { return false; }\n\n  /// if \\c needsInputFileVisitation returns true, this is called for\n  /// each non-system input file of the AST File. If\n  /// \\c needsSystemInputFileVisitation is true, then it is called for all\n  /// system input files as well.\n  ///\n  /// \\returns true to continue receiving the next input file, false to stop.\n  virtual bool visitInputFile(StringRef Filename, bool isSystem,\n                              bool isOverridden, bool isExplicitModule) {\n    return true;\n  }\n\n  /// Returns true if this \\c ASTReaderListener wants to receive the\n  /// imports of the AST file via \\c visitImport, false otherwise.\n  virtual bool needsImportVisitation() const { return false; }\n\n  /// If needsImportVisitation returns \\c true, this is called for each\n  /// AST file imported by this AST file.\n  virtual void visitImport(StringRef ModuleName, StringRef Filename) {}\n\n  /// Indicates that a particular module file extension has been read.\n  virtual void readModuleFileExtension(\n                 const ModuleFileExtensionMetadata &Metadata) {}\n};\n\n/// Simple wrapper class for chaining listeners.\nclass ChainedASTReaderListener : public ASTReaderListener {\n  std::unique_ptr<ASTReaderListener> First;\n  std::unique_ptr<ASTReaderListener> Second;\n\npublic:\n  /// Takes ownership of \\p First and \\p Second.\n  ChainedASTReaderListener(std::unique_ptr<ASTReaderListener> First,\n                           std::unique_ptr<ASTReaderListener> Second)\n      : First(std::move(First)), Second(std::move(Second)) {}\n\n  std::unique_ptr<ASTReaderListener> takeFirst() { return std::move(First); }\n  std::unique_ptr<ASTReaderListener> takeSecond() { return std::move(Second); }\n\n  bool ReadFullVersionInformation(StringRef FullVersion) override;\n  void ReadModuleName(StringRef ModuleName) override;\n  void ReadModuleMapFile(StringRef ModuleMapPath) override;\n  bool ReadLanguageOptions(const LangOptions &LangOpts, bool Complain,\n                           bool AllowCompatibleDifferences) override;\n  bool ReadTargetOptions(const TargetOptions &TargetOpts, bool Complain,\n                         bool AllowCompatibleDifferences) override;\n  bool ReadDiagnosticOptions(IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts,\n                             bool Complain) override;\n  bool ReadFileSystemOptions(const FileSystemOptions &FSOpts,\n                             bool Complain) override;\n\n  bool ReadHeaderSearchOptions(const HeaderSearchOptions &HSOpts,\n                               StringRef SpecificModuleCachePath,\n                               bool Complain) override;\n  bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts,\n                               bool Complain,\n                               std::string &SuggestedPredefines) override;\n\n  void ReadCounter(const serialization::ModuleFile &M, unsigned Value) override;\n  bool needsInputFileVisitation() override;\n  bool needsSystemInputFileVisitation() override;\n  void visitModuleFile(StringRef Filename,\n                       serialization::ModuleKind Kind) override;\n  bool visitInputFile(StringRef Filename, bool isSystem,\n                      bool isOverridden, bool isExplicitModule) override;\n  void readModuleFileExtension(\n         const ModuleFileExtensionMetadata &Metadata) override;\n};\n\n/// ASTReaderListener implementation to validate the information of\n/// the PCH file against an initialized Preprocessor.\nclass PCHValidator : public ASTReaderListener {\n  Preprocessor &PP;\n  ASTReader &Reader;\n\npublic:\n  PCHValidator(Preprocessor &PP, ASTReader &Reader)\n      : PP(PP), Reader(Reader) {}\n\n  bool ReadLanguageOptions(const LangOptions &LangOpts, bool Complain,\n                           bool AllowCompatibleDifferences) override;\n  bool ReadTargetOptions(const TargetOptions &TargetOpts, bool Complain,\n                         bool AllowCompatibleDifferences) override;\n  bool ReadDiagnosticOptions(IntrusiveRefCntPtr<DiagnosticOptions> DiagOpts,\n                             bool Complain) override;\n  bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts, bool Complain,\n                               std::string &SuggestedPredefines) override;\n  bool ReadHeaderSearchOptions(const HeaderSearchOptions &HSOpts,\n                               StringRef SpecificModuleCachePath,\n                               bool Complain) override;\n  void ReadCounter(const serialization::ModuleFile &M, unsigned Value) override;\n\nprivate:\n  void Error(const char *Msg);\n};\n\n/// ASTReaderListenter implementation to set SuggestedPredefines of\n/// ASTReader which is required to use a pch file. This is the replacement\n/// of PCHValidator or SimplePCHValidator when using a pch file without\n/// validating it.\nclass SimpleASTReaderListener : public ASTReaderListener {\n  Preprocessor &PP;\n\npublic:\n  SimpleASTReaderListener(Preprocessor &PP) : PP(PP) {}\n\n  bool ReadPreprocessorOptions(const PreprocessorOptions &PPOpts, bool Complain,\n                               std::string &SuggestedPredefines) override;\n};\n\nnamespace serialization {\n\nclass ReadMethodPoolVisitor;\n\nnamespace reader {\n\nclass ASTIdentifierLookupTrait;\n\n/// The on-disk hash table(s) used for DeclContext name lookup.\nstruct DeclContextLookupTable;\n\n} // namespace reader\n\n} // namespace serialization\n\n/// Reads an AST files chain containing the contents of a translation\n/// unit.\n///\n/// The ASTReader class reads bitstreams (produced by the ASTWriter\n/// class) containing the serialized representation of a given\n/// abstract syntax tree and its supporting data structures. An\n/// instance of the ASTReader can be attached to an ASTContext object,\n/// which will provide access to the contents of the AST files.\n///\n/// The AST reader provides lazy de-serialization of declarations, as\n/// required when traversing the AST. Only those AST nodes that are\n/// actually required will be de-serialized.\nclass ASTReader\n  : public ExternalPreprocessorSource,\n    public ExternalPreprocessingRecordSource,\n    public ExternalHeaderFileInfoSource,\n    public ExternalSemaSource,\n    public IdentifierInfoLookup,\n    public ExternalSLocEntrySource\n{\npublic:\n  /// Types of AST files.\n  friend class ASTDeclReader;\n  friend class ASTIdentifierIterator;\n  friend class ASTRecordReader;\n  friend class ASTUnit; // ASTUnit needs to remap source locations.\n  friend class ASTWriter;\n  friend class PCHValidator;\n  friend class serialization::reader::ASTIdentifierLookupTrait;\n  friend class serialization::ReadMethodPoolVisitor;\n  friend class TypeLocReader;\n\n  using RecordData = SmallVector<uint64_t, 64>;\n  using RecordDataImpl = SmallVectorImpl<uint64_t>;\n\n  /// The result of reading the control block of an AST file, which\n  /// can fail for various reasons.\n  enum ASTReadResult {\n    /// The control block was read successfully. Aside from failures,\n    /// the AST file is safe to read into the current context.\n    Success,\n\n    /// The AST file itself appears corrupted.\n    Failure,\n\n    /// The AST file was missing.\n    Missing,\n\n    /// The AST file is out-of-date relative to its input files,\n    /// and needs to be regenerated.\n    OutOfDate,\n\n    /// The AST file was written by a different version of Clang.\n    VersionMismatch,\n\n    /// The AST file was writtten with a different language/target\n    /// configuration.\n    ConfigurationMismatch,\n\n    /// The AST file has errors.\n    HadErrors\n  };\n\n  using ModuleFile = serialization::ModuleFile;\n  using ModuleKind = serialization::ModuleKind;\n  using ModuleManager = serialization::ModuleManager;\n  using ModuleIterator = ModuleManager::ModuleIterator;\n  using ModuleConstIterator = ModuleManager::ModuleConstIterator;\n  using ModuleReverseIterator = ModuleManager::ModuleReverseIterator;\n\nprivate:\n  /// The receiver of some callbacks invoked by ASTReader.\n  std::unique_ptr<ASTReaderListener> Listener;\n\n  /// The receiver of deserialization events.\n  ASTDeserializationListener *DeserializationListener = nullptr;\n\n  bool OwnsDeserializationListener = false;\n\n  SourceManager &SourceMgr;\n  FileManager &FileMgr;\n  const PCHContainerReader &PCHContainerRdr;\n  DiagnosticsEngine &Diags;\n\n  /// The semantic analysis object that will be processing the\n  /// AST files and the translation unit that uses it.\n  Sema *SemaObj = nullptr;\n\n  /// The preprocessor that will be loading the source file.\n  Preprocessor &PP;\n\n  /// The AST context into which we'll read the AST files.\n  ASTContext *ContextObj = nullptr;\n\n  /// The AST consumer.\n  ASTConsumer *Consumer = nullptr;\n\n  /// The module manager which manages modules and their dependencies\n  ModuleManager ModuleMgr;\n\n  /// A dummy identifier resolver used to merge TU-scope declarations in\n  /// C, for the cases where we don't have a Sema object to provide a real\n  /// identifier resolver.\n  IdentifierResolver DummyIdResolver;\n\n  /// A mapping from extension block names to module file extensions.\n  llvm::StringMap<std::shared_ptr<ModuleFileExtension>> ModuleFileExtensions;\n\n  /// A timer used to track the time spent deserializing.\n  std::unique_ptr<llvm::Timer> ReadTimer;\n\n  /// The location where the module file will be considered as\n  /// imported from. For non-module AST types it should be invalid.\n  SourceLocation CurrentImportLoc;\n\n  /// The module kind that is currently deserializing.\n  Optional<ModuleKind> CurrentDeserializingModuleKind;\n\n  /// The global module index, if loaded.\n  std::unique_ptr<GlobalModuleIndex> GlobalIndex;\n\n  /// A map of global bit offsets to the module that stores entities\n  /// at those bit offsets.\n  ContinuousRangeMap<uint64_t, ModuleFile*, 4> GlobalBitOffsetsMap;\n\n  /// A map of negated SLocEntryIDs to the modules containing them.\n  ContinuousRangeMap<unsigned, ModuleFile*, 64> GlobalSLocEntryMap;\n\n  using GlobalSLocOffsetMapType =\n      ContinuousRangeMap<unsigned, ModuleFile *, 64>;\n\n  /// A map of reversed (SourceManager::MaxLoadedOffset - SLocOffset)\n  /// SourceLocation offsets to the modules containing them.\n  GlobalSLocOffsetMapType GlobalSLocOffsetMap;\n\n  /// Types that have already been loaded from the chain.\n  ///\n  /// When the pointer at index I is non-NULL, the type with\n  /// ID = (I + 1) << FastQual::Width has already been loaded\n  std::vector<QualType> TypesLoaded;\n\n  using GlobalTypeMapType =\n      ContinuousRangeMap<serialization::TypeID, ModuleFile *, 4>;\n\n  /// Mapping from global type IDs to the module in which the\n  /// type resides along with the offset that should be added to the\n  /// global type ID to produce a local ID.\n  GlobalTypeMapType GlobalTypeMap;\n\n  /// Declarations that have already been loaded from the chain.\n  ///\n  /// When the pointer at index I is non-NULL, the declaration with ID\n  /// = I + 1 has already been loaded.\n  std::vector<Decl *> DeclsLoaded;\n\n  using GlobalDeclMapType =\n      ContinuousRangeMap<serialization::DeclID, ModuleFile *, 4>;\n\n  /// Mapping from global declaration IDs to the module in which the\n  /// declaration resides.\n  GlobalDeclMapType GlobalDeclMap;\n\n  using FileOffset = std::pair<ModuleFile *, uint64_t>;\n  using FileOffsetsTy = SmallVector<FileOffset, 2>;\n  using DeclUpdateOffsetsMap =\n      llvm::DenseMap<serialization::DeclID, FileOffsetsTy>;\n\n  /// Declarations that have modifications residing in a later file\n  /// in the chain.\n  DeclUpdateOffsetsMap DeclUpdateOffsets;\n\n  struct PendingUpdateRecord {\n    Decl *D;\n    serialization::GlobalDeclID ID;\n\n    // Whether the declaration was just deserialized.\n    bool JustLoaded;\n\n    PendingUpdateRecord(serialization::GlobalDeclID ID, Decl *D,\n                        bool JustLoaded)\n        : D(D), ID(ID), JustLoaded(JustLoaded) {}\n  };\n\n  /// Declaration updates for already-loaded declarations that we need\n  /// to apply once we finish processing an import.\n  llvm::SmallVector<PendingUpdateRecord, 16> PendingUpdateRecords;\n\n  enum class PendingFakeDefinitionKind { NotFake, Fake, FakeLoaded };\n\n  /// The DefinitionData pointers that we faked up for class definitions\n  /// that we needed but hadn't loaded yet.\n  llvm::DenseMap<void *, PendingFakeDefinitionKind> PendingFakeDefinitionData;\n\n  /// Exception specification updates that have been loaded but not yet\n  /// propagated across the relevant redeclaration chain. The map key is the\n  /// canonical declaration (used only for deduplication) and the value is a\n  /// declaration that has an exception specification.\n  llvm::SmallMapVector<Decl *, FunctionDecl *, 4> PendingExceptionSpecUpdates;\n\n  /// Deduced return type updates that have been loaded but not yet propagated\n  /// across the relevant redeclaration chain. The map key is the canonical\n  /// declaration and the value is the deduced return type.\n  llvm::SmallMapVector<FunctionDecl *, QualType, 4> PendingDeducedTypeUpdates;\n\n  /// Declarations that have been imported and have typedef names for\n  /// linkage purposes.\n  llvm::DenseMap<std::pair<DeclContext *, IdentifierInfo *>, NamedDecl *>\n      ImportedTypedefNamesForLinkage;\n\n  /// Mergeable declaration contexts that have anonymous declarations\n  /// within them, and those anonymous declarations.\n  llvm::DenseMap<Decl*, llvm::SmallVector<NamedDecl*, 2>>\n    AnonymousDeclarationsForMerging;\n\n  /// Key used to identify LifetimeExtendedTemporaryDecl for merging,\n  /// containing the lifetime-extending declaration and the mangling number.\n  using LETemporaryKey = std::pair<Decl *, unsigned>;\n\n  /// Map of already deserialiazed temporaries.\n  llvm::DenseMap<LETemporaryKey, LifetimeExtendedTemporaryDecl *>\n      LETemporaryForMerging;\n\n  struct FileDeclsInfo {\n    ModuleFile *Mod = nullptr;\n    ArrayRef<serialization::LocalDeclID> Decls;\n\n    FileDeclsInfo() = default;\n    FileDeclsInfo(ModuleFile *Mod, ArrayRef<serialization::LocalDeclID> Decls)\n        : Mod(Mod), Decls(Decls) {}\n  };\n\n  /// Map from a FileID to the file-level declarations that it contains.\n  llvm::DenseMap<FileID, FileDeclsInfo> FileDeclIDs;\n\n  /// An array of lexical contents of a declaration context, as a sequence of\n  /// Decl::Kind, DeclID pairs.\n  using LexicalContents = ArrayRef<llvm::support::unaligned_uint32_t>;\n\n  /// Map from a DeclContext to its lexical contents.\n  llvm::DenseMap<const DeclContext*, std::pair<ModuleFile*, LexicalContents>>\n      LexicalDecls;\n\n  /// Map from the TU to its lexical contents from each module file.\n  std::vector<std::pair<ModuleFile*, LexicalContents>> TULexicalDecls;\n\n  /// Map from a DeclContext to its lookup tables.\n  llvm::DenseMap<const DeclContext *,\n                 serialization::reader::DeclContextLookupTable> Lookups;\n\n  // Updates for visible decls can occur for other contexts than just the\n  // TU, and when we read those update records, the actual context may not\n  // be available yet, so have this pending map using the ID as a key. It\n  // will be realized when the context is actually loaded.\n  struct PendingVisibleUpdate {\n    ModuleFile *Mod;\n    const unsigned char *Data;\n  };\n  using DeclContextVisibleUpdates = SmallVector<PendingVisibleUpdate, 1>;\n\n  /// Updates to the visible declarations of declaration contexts that\n  /// haven't been loaded yet.\n  llvm::DenseMap<serialization::DeclID, DeclContextVisibleUpdates>\n      PendingVisibleUpdates;\n\n  /// The set of C++ or Objective-C classes that have forward\n  /// declarations that have not yet been linked to their definitions.\n  llvm::SmallPtrSet<Decl *, 4> PendingDefinitions;\n\n  using PendingBodiesMap =\n      llvm::MapVector<Decl *, uint64_t,\n                      llvm::SmallDenseMap<Decl *, unsigned, 4>,\n                      SmallVector<std::pair<Decl *, uint64_t>, 4>>;\n\n  /// Functions or methods that have bodies that will be attached.\n  PendingBodiesMap PendingBodies;\n\n  /// Definitions for which we have added merged definitions but not yet\n  /// performed deduplication.\n  llvm::SetVector<NamedDecl *> PendingMergedDefinitionsToDeduplicate;\n\n  /// Read the record that describes the lexical contents of a DC.\n  bool ReadLexicalDeclContextStorage(ModuleFile &M,\n                                     llvm::BitstreamCursor &Cursor,\n                                     uint64_t Offset, DeclContext *DC);\n\n  /// Read the record that describes the visible contents of a DC.\n  bool ReadVisibleDeclContextStorage(ModuleFile &M,\n                                     llvm::BitstreamCursor &Cursor,\n                                     uint64_t Offset, serialization::DeclID ID);\n\n  /// A vector containing identifiers that have already been\n  /// loaded.\n  ///\n  /// If the pointer at index I is non-NULL, then it refers to the\n  /// IdentifierInfo for the identifier with ID=I+1 that has already\n  /// been loaded.\n  std::vector<IdentifierInfo *> IdentifiersLoaded;\n\n  using GlobalIdentifierMapType =\n      ContinuousRangeMap<serialization::IdentID, ModuleFile *, 4>;\n\n  /// Mapping from global identifier IDs to the module in which the\n  /// identifier resides along with the offset that should be added to the\n  /// global identifier ID to produce a local ID.\n  GlobalIdentifierMapType GlobalIdentifierMap;\n\n  /// A vector containing macros that have already been\n  /// loaded.\n  ///\n  /// If the pointer at index I is non-NULL, then it refers to the\n  /// MacroInfo for the identifier with ID=I+1 that has already\n  /// been loaded.\n  std::vector<MacroInfo *> MacrosLoaded;\n\n  using LoadedMacroInfo =\n      std::pair<IdentifierInfo *, serialization::SubmoduleID>;\n\n  /// A set of #undef directives that we have loaded; used to\n  /// deduplicate the same #undef information coming from multiple module\n  /// files.\n  llvm::DenseSet<LoadedMacroInfo> LoadedUndefs;\n\n  using GlobalMacroMapType =\n      ContinuousRangeMap<serialization::MacroID, ModuleFile *, 4>;\n\n  /// Mapping from global macro IDs to the module in which the\n  /// macro resides along with the offset that should be added to the\n  /// global macro ID to produce a local ID.\n  GlobalMacroMapType GlobalMacroMap;\n\n  /// A vector containing submodules that have already been loaded.\n  ///\n  /// This vector is indexed by the Submodule ID (-1). NULL submodule entries\n  /// indicate that the particular submodule ID has not yet been loaded.\n  SmallVector<Module *, 2> SubmodulesLoaded;\n\n  using GlobalSubmoduleMapType =\n      ContinuousRangeMap<serialization::SubmoduleID, ModuleFile *, 4>;\n\n  /// Mapping from global submodule IDs to the module file in which the\n  /// submodule resides along with the offset that should be added to the\n  /// global submodule ID to produce a local ID.\n  GlobalSubmoduleMapType GlobalSubmoduleMap;\n\n  /// A set of hidden declarations.\n  using HiddenNames = SmallVector<Decl *, 2>;\n  using HiddenNamesMapType = llvm::DenseMap<Module *, HiddenNames>;\n\n  /// A mapping from each of the hidden submodules to the deserialized\n  /// declarations in that submodule that could be made visible.\n  HiddenNamesMapType HiddenNamesMap;\n\n  /// A module import, export, or conflict that hasn't yet been resolved.\n  struct UnresolvedModuleRef {\n    /// The file in which this module resides.\n    ModuleFile *File;\n\n    /// The module that is importing or exporting.\n    Module *Mod;\n\n    /// The kind of module reference.\n    enum { Import, Export, Conflict } Kind;\n\n    /// The local ID of the module that is being exported.\n    unsigned ID;\n\n    /// Whether this is a wildcard export.\n    unsigned IsWildcard : 1;\n\n    /// String data.\n    StringRef String;\n  };\n\n  /// The set of module imports and exports that still need to be\n  /// resolved.\n  SmallVector<UnresolvedModuleRef, 2> UnresolvedModuleRefs;\n\n  /// A vector containing selectors that have already been loaded.\n  ///\n  /// This vector is indexed by the Selector ID (-1). NULL selector\n  /// entries indicate that the particular selector ID has not yet\n  /// been loaded.\n  SmallVector<Selector, 16> SelectorsLoaded;\n\n  using GlobalSelectorMapType =\n      ContinuousRangeMap<serialization::SelectorID, ModuleFile *, 4>;\n\n  /// Mapping from global selector IDs to the module in which the\n  /// global selector ID to produce a local ID.\n  GlobalSelectorMapType GlobalSelectorMap;\n\n  /// The generation number of the last time we loaded data from the\n  /// global method pool for this selector.\n  llvm::DenseMap<Selector, unsigned> SelectorGeneration;\n\n  /// Whether a selector is out of date. We mark a selector as out of date\n  /// if we load another module after the method pool entry was pulled in.\n  llvm::DenseMap<Selector, bool> SelectorOutOfDate;\n\n  struct PendingMacroInfo {\n    ModuleFile *M;\n    /// Offset relative to ModuleFile::MacroOffsetsBase.\n    uint32_t MacroDirectivesOffset;\n\n    PendingMacroInfo(ModuleFile *M, uint32_t MacroDirectivesOffset)\n        : M(M), MacroDirectivesOffset(MacroDirectivesOffset) {}\n  };\n\n  using PendingMacroIDsMap =\n      llvm::MapVector<IdentifierInfo *, SmallVector<PendingMacroInfo, 2>>;\n\n  /// Mapping from identifiers that have a macro history to the global\n  /// IDs have not yet been deserialized to the global IDs of those macros.\n  PendingMacroIDsMap PendingMacroIDs;\n\n  using GlobalPreprocessedEntityMapType =\n      ContinuousRangeMap<unsigned, ModuleFile *, 4>;\n\n  /// Mapping from global preprocessing entity IDs to the module in\n  /// which the preprocessed entity resides along with the offset that should be\n  /// added to the global preprocessing entity ID to produce a local ID.\n  GlobalPreprocessedEntityMapType GlobalPreprocessedEntityMap;\n\n  using GlobalSkippedRangeMapType =\n      ContinuousRangeMap<unsigned, ModuleFile *, 4>;\n\n  /// Mapping from global skipped range base IDs to the module in which\n  /// the skipped ranges reside.\n  GlobalSkippedRangeMapType GlobalSkippedRangeMap;\n\n  /// \\name CodeGen-relevant special data\n  /// Fields containing data that is relevant to CodeGen.\n  //@{\n\n  /// The IDs of all declarations that fulfill the criteria of\n  /// \"interesting\" decls.\n  ///\n  /// This contains the data loaded from all EAGERLY_DESERIALIZED_DECLS blocks\n  /// in the chain. The referenced declarations are deserialized and passed to\n  /// the consumer eagerly.\n  SmallVector<uint64_t, 16> EagerlyDeserializedDecls;\n\n  /// The IDs of all tentative definitions stored in the chain.\n  ///\n  /// Sema keeps track of all tentative definitions in a TU because it has to\n  /// complete them and pass them on to CodeGen. Thus, tentative definitions in\n  /// the PCH chain must be eagerly deserialized.\n  SmallVector<uint64_t, 16> TentativeDefinitions;\n\n  /// The IDs of all CXXRecordDecls stored in the chain whose VTables are\n  /// used.\n  ///\n  /// CodeGen has to emit VTables for these records, so they have to be eagerly\n  /// deserialized.\n  SmallVector<uint64_t, 64> VTableUses;\n\n  /// A snapshot of the pending instantiations in the chain.\n  ///\n  /// This record tracks the instantiations that Sema has to perform at the\n  /// end of the TU. It consists of a pair of values for every pending\n  /// instantiation where the first value is the ID of the decl and the second\n  /// is the instantiation location.\n  SmallVector<uint64_t, 64> PendingInstantiations;\n\n  //@}\n\n  /// \\name DiagnosticsEngine-relevant special data\n  /// Fields containing data that is used for generating diagnostics\n  //@{\n\n  /// A snapshot of Sema's unused file-scoped variable tracking, for\n  /// generating warnings.\n  SmallVector<uint64_t, 16> UnusedFileScopedDecls;\n\n  /// A list of all the delegating constructors we've seen, to diagnose\n  /// cycles.\n  SmallVector<uint64_t, 4> DelegatingCtorDecls;\n\n  /// Method selectors used in a @selector expression. Used for\n  /// implementation of -Wselector.\n  SmallVector<uint64_t, 64> ReferencedSelectorsData;\n\n  /// A snapshot of Sema's weak undeclared identifier tracking, for\n  /// generating warnings.\n  SmallVector<uint64_t, 64> WeakUndeclaredIdentifiers;\n\n  /// The IDs of type aliases for ext_vectors that exist in the chain.\n  ///\n  /// Used by Sema for finding sugared names for ext_vectors in diagnostics.\n  SmallVector<uint64_t, 4> ExtVectorDecls;\n\n  //@}\n\n  /// \\name Sema-relevant special data\n  /// Fields containing data that is used for semantic analysis\n  //@{\n\n  /// The IDs of all potentially unused typedef names in the chain.\n  ///\n  /// Sema tracks these to emit warnings.\n  SmallVector<uint64_t, 16> UnusedLocalTypedefNameCandidates;\n\n  /// Our current depth in #pragma cuda force_host_device begin/end\n  /// macros.\n  unsigned ForceCUDAHostDeviceDepth = 0;\n\n  /// The IDs of the declarations Sema stores directly.\n  ///\n  /// Sema tracks a few important decls, such as namespace std, directly.\n  SmallVector<uint64_t, 4> SemaDeclRefs;\n\n  /// The IDs of the types ASTContext stores directly.\n  ///\n  /// The AST context tracks a few important types, such as va_list, directly.\n  SmallVector<uint64_t, 16> SpecialTypes;\n\n  /// The IDs of CUDA-specific declarations ASTContext stores directly.\n  ///\n  /// The AST context tracks a few important decls, currently cudaConfigureCall,\n  /// directly.\n  SmallVector<uint64_t, 2> CUDASpecialDeclRefs;\n\n  /// The floating point pragma option settings.\n  SmallVector<uint64_t, 1> FPPragmaOptions;\n\n  /// The pragma clang optimize location (if the pragma state is \"off\").\n  SourceLocation OptimizeOffPragmaLocation;\n\n  /// The PragmaMSStructKind pragma ms_struct state if set, or -1.\n  int PragmaMSStructState = -1;\n\n  /// The PragmaMSPointersToMembersKind pragma pointers_to_members state.\n  int PragmaMSPointersToMembersState = -1;\n  SourceLocation PointersToMembersPragmaLocation;\n\n  /// The pragma float_control state.\n  Optional<FPOptionsOverride> FpPragmaCurrentValue;\n  SourceLocation FpPragmaCurrentLocation;\n  struct FpPragmaStackEntry {\n    FPOptionsOverride Value;\n    SourceLocation Location;\n    SourceLocation PushLocation;\n    StringRef SlotLabel;\n  };\n  llvm::SmallVector<FpPragmaStackEntry, 2> FpPragmaStack;\n  llvm::SmallVector<std::string, 2> FpPragmaStrings;\n\n  /// The pragma align/pack state.\n  Optional<Sema::AlignPackInfo> PragmaAlignPackCurrentValue;\n  SourceLocation PragmaAlignPackCurrentLocation;\n  struct PragmaAlignPackStackEntry {\n    Sema::AlignPackInfo Value;\n    SourceLocation Location;\n    SourceLocation PushLocation;\n    StringRef SlotLabel;\n  };\n  llvm::SmallVector<PragmaAlignPackStackEntry, 2> PragmaAlignPackStack;\n  llvm::SmallVector<std::string, 2> PragmaAlignPackStrings;\n\n  /// The OpenCL extension settings.\n  OpenCLOptions OpenCLExtensions;\n\n  /// Extensions required by an OpenCL type.\n  llvm::DenseMap<const Type *, std::set<std::string>> OpenCLTypeExtMap;\n\n  /// Extensions required by an OpenCL declaration.\n  llvm::DenseMap<const Decl *, std::set<std::string>> OpenCLDeclExtMap;\n\n  /// A list of the namespaces we've seen.\n  SmallVector<uint64_t, 4> KnownNamespaces;\n\n  /// A list of undefined decls with internal linkage followed by the\n  /// SourceLocation of a matching ODR-use.\n  SmallVector<uint64_t, 8> UndefinedButUsed;\n\n  /// Delete expressions to analyze at the end of translation unit.\n  SmallVector<uint64_t, 8> DelayedDeleteExprs;\n\n  // A list of late parsed template function data with their module files.\n  SmallVector<std::pair<ModuleFile *, SmallVector<uint64_t, 1>>, 4>\n      LateParsedTemplates;\n\n  /// The IDs of all decls to be checked for deferred diags.\n  ///\n  /// Sema tracks these to emit deferred diags.\n  SmallVector<uint64_t, 4> DeclsToCheckForDeferredDiags;\n\n\npublic:\n  struct ImportedSubmodule {\n    serialization::SubmoduleID ID;\n    SourceLocation ImportLoc;\n\n    ImportedSubmodule(serialization::SubmoduleID ID, SourceLocation ImportLoc)\n        : ID(ID), ImportLoc(ImportLoc) {}\n  };\n\nprivate:\n  /// A list of modules that were imported by precompiled headers or\n  /// any other non-module AST file.\n  SmallVector<ImportedSubmodule, 2> ImportedModules;\n  //@}\n\n  /// The system include root to be used when loading the\n  /// precompiled header.\n  std::string isysroot;\n\n  /// Whether to disable the normal validation performed on precompiled\n  /// headers and module files when they are loaded.\n  DisableValidationForModuleKind DisableValidationKind;\n\n  /// Whether to accept an AST file with compiler errors.\n  bool AllowASTWithCompilerErrors;\n\n  /// Whether to accept an AST file that has a different configuration\n  /// from the current compiler instance.\n  bool AllowConfigurationMismatch;\n\n  /// Whether validate system input files.\n  bool ValidateSystemInputs;\n\n  /// Whether validate headers and module maps using hash based on contents.\n  bool ValidateASTInputFilesContent;\n\n  /// Whether we are allowed to use the global module index.\n  bool UseGlobalIndex;\n\n  /// Whether we have tried loading the global module index yet.\n  bool TriedLoadingGlobalIndex = false;\n\n  ///Whether we are currently processing update records.\n  bool ProcessingUpdateRecords = false;\n\n  using SwitchCaseMapTy = llvm::DenseMap<unsigned, SwitchCase *>;\n\n  /// Mapping from switch-case IDs in the chain to switch-case statements\n  ///\n  /// Statements usually don't have IDs, but switch cases need them, so that the\n  /// switch statement can refer to them.\n  SwitchCaseMapTy SwitchCaseStmts;\n\n  SwitchCaseMapTy *CurrSwitchCaseStmts;\n\n  /// The number of source location entries de-serialized from\n  /// the PCH file.\n  unsigned NumSLocEntriesRead = 0;\n\n  /// The number of source location entries in the chain.\n  unsigned TotalNumSLocEntries = 0;\n\n  /// The number of statements (and expressions) de-serialized\n  /// from the chain.\n  unsigned NumStatementsRead = 0;\n\n  /// The total number of statements (and expressions) stored\n  /// in the chain.\n  unsigned TotalNumStatements = 0;\n\n  /// The number of macros de-serialized from the chain.\n  unsigned NumMacrosRead = 0;\n\n  /// The total number of macros stored in the chain.\n  unsigned TotalNumMacros = 0;\n\n  /// The number of lookups into identifier tables.\n  unsigned NumIdentifierLookups = 0;\n\n  /// The number of lookups into identifier tables that succeed.\n  unsigned NumIdentifierLookupHits = 0;\n\n  /// The number of selectors that have been read.\n  unsigned NumSelectorsRead = 0;\n\n  /// The number of method pool entries that have been read.\n  unsigned NumMethodPoolEntriesRead = 0;\n\n  /// The number of times we have looked up a selector in the method\n  /// pool.\n  unsigned NumMethodPoolLookups = 0;\n\n  /// The number of times we have looked up a selector in the method\n  /// pool and found something.\n  unsigned NumMethodPoolHits = 0;\n\n  /// The number of times we have looked up a selector in the method\n  /// pool within a specific module.\n  unsigned NumMethodPoolTableLookups = 0;\n\n  /// The number of times we have looked up a selector in the method\n  /// pool within a specific module and found something.\n  unsigned NumMethodPoolTableHits = 0;\n\n  /// The total number of method pool entries in the selector table.\n  unsigned TotalNumMethodPoolEntries = 0;\n\n  /// Number of lexical decl contexts read/total.\n  unsigned NumLexicalDeclContextsRead = 0, TotalLexicalDeclContexts = 0;\n\n  /// Number of visible decl contexts read/total.\n  unsigned NumVisibleDeclContextsRead = 0, TotalVisibleDeclContexts = 0;\n\n  /// Total size of modules, in bits, currently loaded\n  uint64_t TotalModulesSizeInBits = 0;\n\n  /// Number of Decl/types that are currently deserializing.\n  unsigned NumCurrentElementsDeserializing = 0;\n\n  /// Set true while we are in the process of passing deserialized\n  /// \"interesting\" decls to consumer inside FinishedDeserializing().\n  /// This is used as a guard to avoid recursively repeating the process of\n  /// passing decls to consumer.\n  bool PassingDeclsToConsumer = false;\n\n  /// The set of identifiers that were read while the AST reader was\n  /// (recursively) loading declarations.\n  ///\n  /// The declarations on the identifier chain for these identifiers will be\n  /// loaded once the recursive loading has completed.\n  llvm::MapVector<IdentifierInfo *, SmallVector<uint32_t, 4>>\n    PendingIdentifierInfos;\n\n  /// The set of lookup results that we have faked in order to support\n  /// merging of partially deserialized decls but that we have not yet removed.\n  llvm::SmallMapVector<IdentifierInfo *, SmallVector<NamedDecl*, 2>, 16>\n    PendingFakeLookupResults;\n\n  /// The generation number of each identifier, which keeps track of\n  /// the last time we loaded information about this identifier.\n  llvm::DenseMap<IdentifierInfo *, unsigned> IdentifierGeneration;\n\n  class InterestingDecl {\n    Decl *D;\n    bool DeclHasPendingBody;\n\n  public:\n    InterestingDecl(Decl *D, bool HasBody)\n        : D(D), DeclHasPendingBody(HasBody) {}\n\n    Decl *getDecl() { return D; }\n\n    /// Whether the declaration has a pending body.\n    bool hasPendingBody() { return DeclHasPendingBody; }\n  };\n\n  /// Contains declarations and definitions that could be\n  /// \"interesting\" to the ASTConsumer, when we get that AST consumer.\n  ///\n  /// \"Interesting\" declarations are those that have data that may\n  /// need to be emitted, such as inline function definitions or\n  /// Objective-C protocols.\n  std::deque<InterestingDecl> PotentiallyInterestingDecls;\n\n  /// The list of deduced function types that we have not yet read, because\n  /// they might contain a deduced return type that refers to a local type\n  /// declared within the function.\n  SmallVector<std::pair<FunctionDecl *, serialization::TypeID>, 16>\n      PendingFunctionTypes;\n\n  /// The list of redeclaration chains that still need to be\n  /// reconstructed, and the local offset to the corresponding list\n  /// of redeclarations.\n  SmallVector<std::pair<Decl *, uint64_t>, 16> PendingDeclChains;\n\n  /// The list of canonical declarations whose redeclaration chains\n  /// need to be marked as incomplete once we're done deserializing things.\n  SmallVector<Decl *, 16> PendingIncompleteDeclChains;\n\n  /// The Decl IDs for the Sema/Lexical DeclContext of a Decl that has\n  /// been loaded but its DeclContext was not set yet.\n  struct PendingDeclContextInfo {\n    Decl *D;\n    serialization::GlobalDeclID SemaDC;\n    serialization::GlobalDeclID LexicalDC;\n  };\n\n  /// The set of Decls that have been loaded but their DeclContexts are\n  /// not set yet.\n  ///\n  /// The DeclContexts for these Decls will be set once recursive loading has\n  /// been completed.\n  std::deque<PendingDeclContextInfo> PendingDeclContextInfos;\n\n  /// The set of NamedDecls that have been loaded, but are members of a\n  /// context that has been merged into another context where the corresponding\n  /// declaration is either missing or has not yet been loaded.\n  ///\n  /// We will check whether the corresponding declaration is in fact missing\n  /// once recursing loading has been completed.\n  llvm::SmallVector<NamedDecl *, 16> PendingOdrMergeChecks;\n\n  using DataPointers =\n      std::pair<CXXRecordDecl *, struct CXXRecordDecl::DefinitionData *>;\n\n  /// Record definitions in which we found an ODR violation.\n  llvm::SmallDenseMap<CXXRecordDecl *, llvm::SmallVector<DataPointers, 2>, 2>\n      PendingOdrMergeFailures;\n\n  /// Function definitions in which we found an ODR violation.\n  llvm::SmallDenseMap<FunctionDecl *, llvm::SmallVector<FunctionDecl *, 2>, 2>\n      PendingFunctionOdrMergeFailures;\n\n  /// Enum definitions in which we found an ODR violation.\n  llvm::SmallDenseMap<EnumDecl *, llvm::SmallVector<EnumDecl *, 2>, 2>\n      PendingEnumOdrMergeFailures;\n\n  /// DeclContexts in which we have diagnosed an ODR violation.\n  llvm::SmallPtrSet<DeclContext*, 2> DiagnosedOdrMergeFailures;\n\n  /// The set of Objective-C categories that have been deserialized\n  /// since the last time the declaration chains were linked.\n  llvm::SmallPtrSet<ObjCCategoryDecl *, 16> CategoriesDeserialized;\n\n  /// The set of Objective-C class definitions that have already been\n  /// loaded, for which we will need to check for categories whenever a new\n  /// module is loaded.\n  SmallVector<ObjCInterfaceDecl *, 16> ObjCClassesLoaded;\n\n  using KeyDeclsMap =\n      llvm::DenseMap<Decl *, SmallVector<serialization::DeclID, 2>>;\n\n  /// A mapping from canonical declarations to the set of global\n  /// declaration IDs for key declaration that have been merged with that\n  /// canonical declaration. A key declaration is a formerly-canonical\n  /// declaration whose module did not import any other key declaration for that\n  /// entity. These are the IDs that we use as keys when finding redecl chains.\n  KeyDeclsMap KeyDecls;\n\n  /// A mapping from DeclContexts to the semantic DeclContext that we\n  /// are treating as the definition of the entity. This is used, for instance,\n  /// when merging implicit instantiations of class templates across modules.\n  llvm::DenseMap<DeclContext *, DeclContext *> MergedDeclContexts;\n\n  /// A mapping from canonical declarations of enums to their canonical\n  /// definitions. Only populated when using modules in C++.\n  llvm::DenseMap<EnumDecl *, EnumDecl *> EnumDefinitions;\n\n  /// When reading a Stmt tree, Stmt operands are placed in this stack.\n  SmallVector<Stmt *, 16> StmtStack;\n\n  /// What kind of records we are reading.\n  enum ReadingKind {\n    Read_None, Read_Decl, Read_Type, Read_Stmt\n  };\n\n  /// What kind of records we are reading.\n  ReadingKind ReadingKind = Read_None;\n\n  /// RAII object to change the reading kind.\n  class ReadingKindTracker {\n    ASTReader &Reader;\n    enum ReadingKind PrevKind;\n\n  public:\n    ReadingKindTracker(enum ReadingKind newKind, ASTReader &reader)\n        : Reader(reader), PrevKind(Reader.ReadingKind) {\n      Reader.ReadingKind = newKind;\n    }\n\n    ReadingKindTracker(const ReadingKindTracker &) = delete;\n    ReadingKindTracker &operator=(const ReadingKindTracker &) = delete;\n    ~ReadingKindTracker() { Reader.ReadingKind = PrevKind; }\n  };\n\n  /// RAII object to mark the start of processing updates.\n  class ProcessingUpdatesRAIIObj {\n    ASTReader &Reader;\n    bool PrevState;\n\n  public:\n    ProcessingUpdatesRAIIObj(ASTReader &reader)\n        : Reader(reader), PrevState(Reader.ProcessingUpdateRecords) {\n      Reader.ProcessingUpdateRecords = true;\n    }\n\n    ProcessingUpdatesRAIIObj(const ProcessingUpdatesRAIIObj &) = delete;\n    ProcessingUpdatesRAIIObj &\n    operator=(const ProcessingUpdatesRAIIObj &) = delete;\n    ~ProcessingUpdatesRAIIObj() { Reader.ProcessingUpdateRecords = PrevState; }\n  };\n\n  /// Suggested contents of the predefines buffer, after this\n  /// PCH file has been processed.\n  ///\n  /// In most cases, this string will be empty, because the predefines\n  /// buffer computed to build the PCH file will be identical to the\n  /// predefines buffer computed from the command line. However, when\n  /// there are differences that the PCH reader can work around, this\n  /// predefines buffer may contain additional definitions.\n  std::string SuggestedPredefines;\n\n  llvm::DenseMap<const Decl *, bool> DefinitionSource;\n\n  bool shouldDisableValidationForFile(const serialization::ModuleFile &M) const;\n\n  /// Reads a statement from the specified cursor.\n  Stmt *ReadStmtFromStream(ModuleFile &F);\n\n  struct InputFileInfo {\n    std::string Filename;\n    uint64_t ContentHash;\n    off_t StoredSize;\n    time_t StoredTime;\n    bool Overridden;\n    bool Transient;\n    bool TopLevelModuleMap;\n  };\n\n  /// Reads the stored information about an input file.\n  InputFileInfo readInputFileInfo(ModuleFile &F, unsigned ID);\n\n  /// Retrieve the file entry and 'overridden' bit for an input\n  /// file in the given module file.\n  serialization::InputFile getInputFile(ModuleFile &F, unsigned ID,\n                                        bool Complain = true);\n\npublic:\n  void ResolveImportedPath(ModuleFile &M, std::string &Filename);\n  static void ResolveImportedPath(std::string &Filename, StringRef Prefix);\n\n  /// Returns the first key declaration for the given declaration. This\n  /// is one that is formerly-canonical (or still canonical) and whose module\n  /// did not import any other key declaration of the entity.\n  Decl *getKeyDeclaration(Decl *D) {\n    D = D->getCanonicalDecl();\n    if (D->isFromASTFile())\n      return D;\n\n    auto I = KeyDecls.find(D);\n    if (I == KeyDecls.end() || I->second.empty())\n      return D;\n    return GetExistingDecl(I->second[0]);\n  }\n  const Decl *getKeyDeclaration(const Decl *D) {\n    return getKeyDeclaration(const_cast<Decl*>(D));\n  }\n\n  /// Run a callback on each imported key declaration of \\p D.\n  template <typename Fn>\n  void forEachImportedKeyDecl(const Decl *D, Fn Visit) {\n    D = D->getCanonicalDecl();\n    if (D->isFromASTFile())\n      Visit(D);\n\n    auto It = KeyDecls.find(const_cast<Decl*>(D));\n    if (It != KeyDecls.end())\n      for (auto ID : It->second)\n        Visit(GetExistingDecl(ID));\n  }\n\n  /// Get the loaded lookup tables for \\p Primary, if any.\n  const serialization::reader::DeclContextLookupTable *\n  getLoadedLookupTables(DeclContext *Primary) const;\n\nprivate:\n  struct ImportedModule {\n    ModuleFile *Mod;\n    ModuleFile *ImportedBy;\n    SourceLocation ImportLoc;\n\n    ImportedModule(ModuleFile *Mod,\n                   ModuleFile *ImportedBy,\n                   SourceLocation ImportLoc)\n        : Mod(Mod), ImportedBy(ImportedBy), ImportLoc(ImportLoc) {}\n  };\n\n  ASTReadResult ReadASTCore(StringRef FileName, ModuleKind Type,\n                            SourceLocation ImportLoc, ModuleFile *ImportedBy,\n                            SmallVectorImpl<ImportedModule> &Loaded,\n                            off_t ExpectedSize, time_t ExpectedModTime,\n                            ASTFileSignature ExpectedSignature,\n                            unsigned ClientLoadCapabilities);\n  ASTReadResult ReadControlBlock(ModuleFile &F,\n                                 SmallVectorImpl<ImportedModule> &Loaded,\n                                 const ModuleFile *ImportedBy,\n                                 unsigned ClientLoadCapabilities);\n  static ASTReadResult ReadOptionsBlock(\n      llvm::BitstreamCursor &Stream, unsigned ClientLoadCapabilities,\n      bool AllowCompatibleConfigurationMismatch, ASTReaderListener &Listener,\n      std::string &SuggestedPredefines);\n\n  /// Read the unhashed control block.\n  ///\n  /// This has no effect on \\c F.Stream, instead creating a fresh cursor from\n  /// \\c F.Data and reading ahead.\n  ASTReadResult readUnhashedControlBlock(ModuleFile &F, bool WasImportedBy,\n                                         unsigned ClientLoadCapabilities);\n\n  static ASTReadResult\n  readUnhashedControlBlockImpl(ModuleFile *F, llvm::StringRef StreamData,\n                               unsigned ClientLoadCapabilities,\n                               bool AllowCompatibleConfigurationMismatch,\n                               ASTReaderListener *Listener,\n                               bool ValidateDiagnosticOptions);\n\n  ASTReadResult ReadASTBlock(ModuleFile &F, unsigned ClientLoadCapabilities);\n  ASTReadResult ReadExtensionBlock(ModuleFile &F);\n  void ReadModuleOffsetMap(ModuleFile &F) const;\n  bool ParseLineTable(ModuleFile &F, const RecordData &Record);\n  bool ReadSourceManagerBlock(ModuleFile &F);\n  llvm::BitstreamCursor &SLocCursorForID(int ID);\n  SourceLocation getImportLocation(ModuleFile *F);\n  ASTReadResult ReadModuleMapFileBlock(RecordData &Record, ModuleFile &F,\n                                       const ModuleFile *ImportedBy,\n                                       unsigned ClientLoadCapabilities);\n  ASTReadResult ReadSubmoduleBlock(ModuleFile &F,\n                                   unsigned ClientLoadCapabilities);\n  static bool ParseLanguageOptions(const RecordData &Record, bool Complain,\n                                   ASTReaderListener &Listener,\n                                   bool AllowCompatibleDifferences);\n  static bool ParseTargetOptions(const RecordData &Record, bool Complain,\n                                 ASTReaderListener &Listener,\n                                 bool AllowCompatibleDifferences);\n  static bool ParseDiagnosticOptions(const RecordData &Record, bool Complain,\n                                     ASTReaderListener &Listener);\n  static bool ParseFileSystemOptions(const RecordData &Record, bool Complain,\n                                     ASTReaderListener &Listener);\n  static bool ParseHeaderSearchOptions(const RecordData &Record, bool Complain,\n                                       ASTReaderListener &Listener);\n  static bool ParsePreprocessorOptions(const RecordData &Record, bool Complain,\n                                       ASTReaderListener &Listener,\n                                       std::string &SuggestedPredefines);\n\n  struct RecordLocation {\n    ModuleFile *F;\n    uint64_t Offset;\n\n    RecordLocation(ModuleFile *M, uint64_t O) : F(M), Offset(O) {}\n  };\n\n  QualType readTypeRecord(unsigned Index);\n  RecordLocation TypeCursorForIndex(unsigned Index);\n  void LoadedDecl(unsigned Index, Decl *D);\n  Decl *ReadDeclRecord(serialization::DeclID ID);\n  void markIncompleteDeclChain(Decl *Canon);\n\n  /// Returns the most recent declaration of a declaration (which must be\n  /// of a redeclarable kind) that is either local or has already been loaded\n  /// merged into its redecl chain.\n  Decl *getMostRecentExistingDecl(Decl *D);\n\n  RecordLocation DeclCursorForID(serialization::DeclID ID,\n                                 SourceLocation &Location);\n  void loadDeclUpdateRecords(PendingUpdateRecord &Record);\n  void loadPendingDeclChain(Decl *D, uint64_t LocalOffset);\n  void loadObjCCategories(serialization::GlobalDeclID ID, ObjCInterfaceDecl *D,\n                          unsigned PreviousGeneration = 0);\n\n  RecordLocation getLocalBitOffset(uint64_t GlobalOffset);\n  uint64_t getGlobalBitOffset(ModuleFile &M, uint64_t LocalOffset);\n\n  /// Returns the first preprocessed entity ID that begins or ends after\n  /// \\arg Loc.\n  serialization::PreprocessedEntityID\n  findPreprocessedEntity(SourceLocation Loc, bool EndsAfter) const;\n\n  /// Find the next module that contains entities and return the ID\n  /// of the first entry.\n  ///\n  /// \\param SLocMapI points at a chunk of a module that contains no\n  /// preprocessed entities or the entities it contains are not the\n  /// ones we are looking for.\n  serialization::PreprocessedEntityID\n    findNextPreprocessedEntity(\n                        GlobalSLocOffsetMapType::const_iterator SLocMapI) const;\n\n  /// Returns (ModuleFile, Local index) pair for \\p GlobalIndex of a\n  /// preprocessed entity.\n  std::pair<ModuleFile *, unsigned>\n    getModulePreprocessedEntity(unsigned GlobalIndex);\n\n  /// Returns (begin, end) pair for the preprocessed entities of a\n  /// particular module.\n  llvm::iterator_range<PreprocessingRecord::iterator>\n  getModulePreprocessedEntities(ModuleFile &Mod) const;\n\npublic:\n  class ModuleDeclIterator\n      : public llvm::iterator_adaptor_base<\n            ModuleDeclIterator, const serialization::LocalDeclID *,\n            std::random_access_iterator_tag, const Decl *, ptrdiff_t,\n            const Decl *, const Decl *> {\n    ASTReader *Reader = nullptr;\n    ModuleFile *Mod = nullptr;\n\n  public:\n    ModuleDeclIterator() : iterator_adaptor_base(nullptr) {}\n\n    ModuleDeclIterator(ASTReader *Reader, ModuleFile *Mod,\n                       const serialization::LocalDeclID *Pos)\n        : iterator_adaptor_base(Pos), Reader(Reader), Mod(Mod) {}\n\n    value_type operator*() const {\n      return Reader->GetDecl(Reader->getGlobalDeclID(*Mod, *I));\n    }\n\n    value_type operator->() const { return **this; }\n\n    bool operator==(const ModuleDeclIterator &RHS) const {\n      assert(Reader == RHS.Reader && Mod == RHS.Mod);\n      return I == RHS.I;\n    }\n  };\n\n  llvm::iterator_range<ModuleDeclIterator>\n  getModuleFileLevelDecls(ModuleFile &Mod);\n\nprivate:\n  void PassInterestingDeclsToConsumer();\n  void PassInterestingDeclToConsumer(Decl *D);\n\n  void finishPendingActions();\n  void diagnoseOdrViolations();\n\n  void pushExternalDeclIntoScope(NamedDecl *D, DeclarationName Name);\n\n  void addPendingDeclContextInfo(Decl *D,\n                                 serialization::GlobalDeclID SemaDC,\n                                 serialization::GlobalDeclID LexicalDC) {\n    assert(D);\n    PendingDeclContextInfo Info = { D, SemaDC, LexicalDC };\n    PendingDeclContextInfos.push_back(Info);\n  }\n\n  /// Produce an error diagnostic and return true.\n  ///\n  /// This routine should only be used for fatal errors that have to\n  /// do with non-routine failures (e.g., corrupted AST file).\n  void Error(StringRef Msg) const;\n  void Error(unsigned DiagID, StringRef Arg1 = StringRef(),\n             StringRef Arg2 = StringRef(), StringRef Arg3 = StringRef()) const;\n  void Error(llvm::Error &&Err) const;\n\npublic:\n  /// Load the AST file and validate its contents against the given\n  /// Preprocessor.\n  ///\n  /// \\param PP the preprocessor associated with the context in which this\n  /// precompiled header will be loaded.\n  ///\n  /// \\param Context the AST context that this precompiled header will be\n  /// loaded into, if any.\n  ///\n  /// \\param PCHContainerRdr the PCHContainerOperations to use for loading and\n  /// creating modules.\n  ///\n  /// \\param Extensions the list of module file extensions that can be loaded\n  /// from the AST files.\n  ///\n  /// \\param isysroot If non-NULL, the system include path specified by the\n  /// user. This is only used with relocatable PCH files. If non-NULL,\n  /// a relocatable PCH file will use the default path \"/\".\n  ///\n  /// \\param DisableValidationKind If set, the AST reader will suppress most\n  /// of its regular consistency checking, allowing the use of precompiled\n  /// headers and module files that cannot be determined to be compatible.\n  ///\n  /// \\param AllowASTWithCompilerErrors If true, the AST reader will accept an\n  /// AST file the was created out of an AST with compiler errors,\n  /// otherwise it will reject it.\n  ///\n  /// \\param AllowConfigurationMismatch If true, the AST reader will not check\n  /// for configuration differences between the AST file and the invocation.\n  ///\n  /// \\param ValidateSystemInputs If true, the AST reader will validate\n  /// system input files in addition to user input files. This is only\n  /// meaningful if \\p DisableValidation is false.\n  ///\n  /// \\param UseGlobalIndex If true, the AST reader will try to load and use\n  /// the global module index.\n  ///\n  /// \\param ReadTimer If non-null, a timer used to track the time spent\n  /// deserializing.\n  ASTReader(Preprocessor &PP, InMemoryModuleCache &ModuleCache,\n            ASTContext *Context, const PCHContainerReader &PCHContainerRdr,\n            ArrayRef<std::shared_ptr<ModuleFileExtension>> Extensions,\n            StringRef isysroot = \"\",\n            DisableValidationForModuleKind DisableValidationKind =\n                DisableValidationForModuleKind::None,\n            bool AllowASTWithCompilerErrors = false,\n            bool AllowConfigurationMismatch = false,\n            bool ValidateSystemInputs = false,\n            bool ValidateASTInputFilesContent = false,\n            bool UseGlobalIndex = true,\n            std::unique_ptr<llvm::Timer> ReadTimer = {});\n  ASTReader(const ASTReader &) = delete;\n  ASTReader &operator=(const ASTReader &) = delete;\n  ~ASTReader() override;\n\n  SourceManager &getSourceManager() const { return SourceMgr; }\n  FileManager &getFileManager() const { return FileMgr; }\n  DiagnosticsEngine &getDiags() const { return Diags; }\n\n  /// Flags that indicate what kind of AST loading failures the client\n  /// of the AST reader can directly handle.\n  ///\n  /// When a client states that it can handle a particular kind of failure,\n  /// the AST reader will not emit errors when producing that kind of failure.\n  enum LoadFailureCapabilities {\n    /// The client can't handle any AST loading failures.\n    ARR_None = 0,\n\n    /// The client can handle an AST file that cannot load because it\n    /// is missing.\n    ARR_Missing = 0x1,\n\n    /// The client can handle an AST file that cannot load because it\n    /// is out-of-date relative to its input files.\n    ARR_OutOfDate = 0x2,\n\n    /// The client can handle an AST file that cannot load because it\n    /// was built with a different version of Clang.\n    ARR_VersionMismatch = 0x4,\n\n    /// The client can handle an AST file that cannot load because it's\n    /// compiled configuration doesn't match that of the context it was\n    /// loaded into.\n    ARR_ConfigurationMismatch = 0x8,\n\n    /// If a module file is marked with errors treat it as out-of-date so the\n    /// caller can rebuild it.\n    ARR_TreatModuleWithErrorsAsOutOfDate = 0x10\n  };\n\n  /// Load the AST file designated by the given file name.\n  ///\n  /// \\param FileName The name of the AST file to load.\n  ///\n  /// \\param Type The kind of AST being loaded, e.g., PCH, module, main file,\n  /// or preamble.\n  ///\n  /// \\param ImportLoc the location where the module file will be considered as\n  /// imported from. For non-module AST types it should be invalid.\n  ///\n  /// \\param ClientLoadCapabilities The set of client load-failure\n  /// capabilities, represented as a bitset of the enumerators of\n  /// LoadFailureCapabilities.\n  ///\n  /// \\param Imported optional out-parameter to append the list of modules\n  /// that were imported by precompiled headers or any other non-module AST file\n  ASTReadResult ReadAST(StringRef FileName, ModuleKind Type,\n                        SourceLocation ImportLoc,\n                        unsigned ClientLoadCapabilities,\n                        SmallVectorImpl<ImportedSubmodule> *Imported = nullptr);\n\n  /// Make the entities in the given module and any of its (non-explicit)\n  /// submodules visible to name lookup.\n  ///\n  /// \\param Mod The module whose names should be made visible.\n  ///\n  /// \\param NameVisibility The level of visibility to give the names in the\n  /// module.  Visibility can only be increased over time.\n  ///\n  /// \\param ImportLoc The location at which the import occurs.\n  void makeModuleVisible(Module *Mod,\n                         Module::NameVisibilityKind NameVisibility,\n                         SourceLocation ImportLoc);\n\n  /// Make the names within this set of hidden names visible.\n  void makeNamesVisible(const HiddenNames &Names, Module *Owner);\n\n  /// Note that MergedDef is a redefinition of the canonical definition\n  /// Def, so Def should be visible whenever MergedDef is.\n  void mergeDefinitionVisibility(NamedDecl *Def, NamedDecl *MergedDef);\n\n  /// Take the AST callbacks listener.\n  std::unique_ptr<ASTReaderListener> takeListener() {\n    return std::move(Listener);\n  }\n\n  /// Set the AST callbacks listener.\n  void setListener(std::unique_ptr<ASTReaderListener> Listener) {\n    this->Listener = std::move(Listener);\n  }\n\n  /// Add an AST callback listener.\n  ///\n  /// Takes ownership of \\p L.\n  void addListener(std::unique_ptr<ASTReaderListener> L) {\n    if (Listener)\n      L = std::make_unique<ChainedASTReaderListener>(std::move(L),\n                                                      std::move(Listener));\n    Listener = std::move(L);\n  }\n\n  /// RAII object to temporarily add an AST callback listener.\n  class ListenerScope {\n    ASTReader &Reader;\n    bool Chained = false;\n\n  public:\n    ListenerScope(ASTReader &Reader, std::unique_ptr<ASTReaderListener> L)\n        : Reader(Reader) {\n      auto Old = Reader.takeListener();\n      if (Old) {\n        Chained = true;\n        L = std::make_unique<ChainedASTReaderListener>(std::move(L),\n                                                        std::move(Old));\n      }\n      Reader.setListener(std::move(L));\n    }\n\n    ~ListenerScope() {\n      auto New = Reader.takeListener();\n      if (Chained)\n        Reader.setListener(static_cast<ChainedASTReaderListener *>(New.get())\n                               ->takeSecond());\n    }\n  };\n\n  /// Set the AST deserialization listener.\n  void setDeserializationListener(ASTDeserializationListener *Listener,\n                                  bool TakeOwnership = false);\n\n  /// Get the AST deserialization listener.\n  ASTDeserializationListener *getDeserializationListener() {\n    return DeserializationListener;\n  }\n\n  /// Determine whether this AST reader has a global index.\n  bool hasGlobalIndex() const { return (bool)GlobalIndex; }\n\n  /// Return global module index.\n  GlobalModuleIndex *getGlobalIndex() { return GlobalIndex.get(); }\n\n  /// Reset reader for a reload try.\n  void resetForReload() { TriedLoadingGlobalIndex = false; }\n\n  /// Attempts to load the global index.\n  ///\n  /// \\returns true if loading the global index has failed for any reason.\n  bool loadGlobalIndex();\n\n  /// Determine whether we tried to load the global index, but failed,\n  /// e.g., because it is out-of-date or does not exist.\n  bool isGlobalIndexUnavailable() const;\n\n  /// Initializes the ASTContext\n  void InitializeContext();\n\n  /// Update the state of Sema after loading some additional modules.\n  void UpdateSema();\n\n  /// Add in-memory (virtual file) buffer.\n  void addInMemoryBuffer(StringRef &FileName,\n                         std::unique_ptr<llvm::MemoryBuffer> Buffer) {\n    ModuleMgr.addInMemoryBuffer(FileName, std::move(Buffer));\n  }\n\n  /// Finalizes the AST reader's state before writing an AST file to\n  /// disk.\n  ///\n  /// This operation may undo temporary state in the AST that should not be\n  /// emitted.\n  void finalizeForWriting();\n\n  /// Retrieve the module manager.\n  ModuleManager &getModuleManager() { return ModuleMgr; }\n\n  /// Retrieve the preprocessor.\n  Preprocessor &getPreprocessor() const { return PP; }\n\n  /// Retrieve the name of the original source file name for the primary\n  /// module file.\n  StringRef getOriginalSourceFile() {\n    return ModuleMgr.getPrimaryModule().OriginalSourceFileName;\n  }\n\n  /// Retrieve the name of the original source file name directly from\n  /// the AST file, without actually loading the AST file.\n  static std::string\n  getOriginalSourceFile(const std::string &ASTFileName, FileManager &FileMgr,\n                        const PCHContainerReader &PCHContainerRdr,\n                        DiagnosticsEngine &Diags);\n\n  /// Read the control block for the named AST file.\n  ///\n  /// \\returns true if an error occurred, false otherwise.\n  static bool\n  readASTFileControlBlock(StringRef Filename, FileManager &FileMgr,\n                          const PCHContainerReader &PCHContainerRdr,\n                          bool FindModuleFileExtensions,\n                          ASTReaderListener &Listener,\n                          bool ValidateDiagnosticOptions);\n\n  /// Determine whether the given AST file is acceptable to load into a\n  /// translation unit with the given language and target options.\n  static bool isAcceptableASTFile(StringRef Filename, FileManager &FileMgr,\n                                  const PCHContainerReader &PCHContainerRdr,\n                                  const LangOptions &LangOpts,\n                                  const TargetOptions &TargetOpts,\n                                  const PreprocessorOptions &PPOpts,\n                                  StringRef ExistingModuleCachePath);\n\n  /// Returns the suggested contents of the predefines buffer,\n  /// which contains a (typically-empty) subset of the predefines\n  /// build prior to including the precompiled header.\n  const std::string &getSuggestedPredefines() { return SuggestedPredefines; }\n\n  /// Read a preallocated preprocessed entity from the external source.\n  ///\n  /// \\returns null if an error occurred that prevented the preprocessed\n  /// entity from being loaded.\n  PreprocessedEntity *ReadPreprocessedEntity(unsigned Index) override;\n\n  /// Returns a pair of [Begin, End) indices of preallocated\n  /// preprocessed entities that \\p Range encompasses.\n  std::pair<unsigned, unsigned>\n      findPreprocessedEntitiesInRange(SourceRange Range) override;\n\n  /// Optionally returns true or false if the preallocated preprocessed\n  /// entity with index \\p Index came from file \\p FID.\n  Optional<bool> isPreprocessedEntityInFileID(unsigned Index,\n                                              FileID FID) override;\n\n  /// Read a preallocated skipped range from the external source.\n  SourceRange ReadSkippedRange(unsigned Index) override;\n\n  /// Read the header file information for the given file entry.\n  HeaderFileInfo GetHeaderFileInfo(const FileEntry *FE) override;\n\n  void ReadPragmaDiagnosticMappings(DiagnosticsEngine &Diag);\n\n  /// Returns the number of source locations found in the chain.\n  unsigned getTotalNumSLocs() const {\n    return TotalNumSLocEntries;\n  }\n\n  /// Returns the number of identifiers found in the chain.\n  unsigned getTotalNumIdentifiers() const {\n    return static_cast<unsigned>(IdentifiersLoaded.size());\n  }\n\n  /// Returns the number of macros found in the chain.\n  unsigned getTotalNumMacros() const {\n    return static_cast<unsigned>(MacrosLoaded.size());\n  }\n\n  /// Returns the number of types found in the chain.\n  unsigned getTotalNumTypes() const {\n    return static_cast<unsigned>(TypesLoaded.size());\n  }\n\n  /// Returns the number of declarations found in the chain.\n  unsigned getTotalNumDecls() const {\n    return static_cast<unsigned>(DeclsLoaded.size());\n  }\n\n  /// Returns the number of submodules known.\n  unsigned getTotalNumSubmodules() const {\n    return static_cast<unsigned>(SubmodulesLoaded.size());\n  }\n\n  /// Returns the number of selectors found in the chain.\n  unsigned getTotalNumSelectors() const {\n    return static_cast<unsigned>(SelectorsLoaded.size());\n  }\n\n  /// Returns the number of preprocessed entities known to the AST\n  /// reader.\n  unsigned getTotalNumPreprocessedEntities() const {\n    unsigned Result = 0;\n    for (const auto &M : ModuleMgr)\n      Result += M.NumPreprocessedEntities;\n    return Result;\n  }\n\n  /// Resolve a type ID into a type, potentially building a new\n  /// type.\n  QualType GetType(serialization::TypeID ID);\n\n  /// Resolve a local type ID within a given AST file into a type.\n  QualType getLocalType(ModuleFile &F, unsigned LocalID);\n\n  /// Map a local type ID within a given AST file into a global type ID.\n  serialization::TypeID getGlobalTypeID(ModuleFile &F, unsigned LocalID) const;\n\n  /// Read a type from the current position in the given record, which\n  /// was read from the given AST file.\n  QualType readType(ModuleFile &F, const RecordData &Record, unsigned &Idx) {\n    if (Idx >= Record.size())\n      return {};\n\n    return getLocalType(F, Record[Idx++]);\n  }\n\n  /// Map from a local declaration ID within a given module to a\n  /// global declaration ID.\n  serialization::DeclID getGlobalDeclID(ModuleFile &F,\n                                      serialization::LocalDeclID LocalID) const;\n\n  /// Returns true if global DeclID \\p ID originated from module \\p M.\n  bool isDeclIDFromModule(serialization::GlobalDeclID ID, ModuleFile &M) const;\n\n  /// Retrieve the module file that owns the given declaration, or NULL\n  /// if the declaration is not from a module file.\n  ModuleFile *getOwningModuleFile(const Decl *D);\n\n  /// Get the best name we know for the module that owns the given\n  /// declaration, or an empty string if the declaration is not from a module.\n  std::string getOwningModuleNameForDiagnostic(const Decl *D);\n\n  /// Returns the source location for the decl \\p ID.\n  SourceLocation getSourceLocationForDeclID(serialization::GlobalDeclID ID);\n\n  /// Resolve a declaration ID into a declaration, potentially\n  /// building a new declaration.\n  Decl *GetDecl(serialization::DeclID ID);\n  Decl *GetExternalDecl(uint32_t ID) override;\n\n  /// Resolve a declaration ID into a declaration. Return 0 if it's not\n  /// been loaded yet.\n  Decl *GetExistingDecl(serialization::DeclID ID);\n\n  /// Reads a declaration with the given local ID in the given module.\n  Decl *GetLocalDecl(ModuleFile &F, uint32_t LocalID) {\n    return GetDecl(getGlobalDeclID(F, LocalID));\n  }\n\n  /// Reads a declaration with the given local ID in the given module.\n  ///\n  /// \\returns The requested declaration, casted to the given return type.\n  template<typename T>\n  T *GetLocalDeclAs(ModuleFile &F, uint32_t LocalID) {\n    return cast_or_null<T>(GetLocalDecl(F, LocalID));\n  }\n\n  /// Map a global declaration ID into the declaration ID used to\n  /// refer to this declaration within the given module fule.\n  ///\n  /// \\returns the global ID of the given declaration as known in the given\n  /// module file.\n  serialization::DeclID\n  mapGlobalIDToModuleFileGlobalID(ModuleFile &M,\n                                  serialization::DeclID GlobalID);\n\n  /// Reads a declaration ID from the given position in a record in the\n  /// given module.\n  ///\n  /// \\returns The declaration ID read from the record, adjusted to a global ID.\n  serialization::DeclID ReadDeclID(ModuleFile &F, const RecordData &Record,\n                                   unsigned &Idx);\n\n  /// Reads a declaration from the given position in a record in the\n  /// given module.\n  Decl *ReadDecl(ModuleFile &F, const RecordData &R, unsigned &I) {\n    return GetDecl(ReadDeclID(F, R, I));\n  }\n\n  /// Reads a declaration from the given position in a record in the\n  /// given module.\n  ///\n  /// \\returns The declaration read from this location, casted to the given\n  /// result type.\n  template<typename T>\n  T *ReadDeclAs(ModuleFile &F, const RecordData &R, unsigned &I) {\n    return cast_or_null<T>(GetDecl(ReadDeclID(F, R, I)));\n  }\n\n  /// If any redeclarations of \\p D have been imported since it was\n  /// last checked, this digs out those redeclarations and adds them to the\n  /// redeclaration chain for \\p D.\n  void CompleteRedeclChain(const Decl *D) override;\n\n  CXXBaseSpecifier *GetExternalCXXBaseSpecifiers(uint64_t Offset) override;\n\n  /// Resolve the offset of a statement into a statement.\n  ///\n  /// This operation will read a new statement from the external\n  /// source each time it is called, and is meant to be used via a\n  /// LazyOffsetPtr (which is used by Decls for the body of functions, etc).\n  Stmt *GetExternalDeclStmt(uint64_t Offset) override;\n\n  /// ReadBlockAbbrevs - Enter a subblock of the specified BlockID with the\n  /// specified cursor.  Read the abbreviations that are at the top of the block\n  /// and then leave the cursor pointing into the block.\n  static bool ReadBlockAbbrevs(llvm::BitstreamCursor &Cursor, unsigned BlockID,\n                               uint64_t *StartOfBlockOffset = nullptr);\n\n  /// Finds all the visible declarations with a given name.\n  /// The current implementation of this method just loads the entire\n  /// lookup table as unmaterialized references.\n  bool FindExternalVisibleDeclsByName(const DeclContext *DC,\n                                      DeclarationName Name) override;\n\n  /// Read all of the declarations lexically stored in a\n  /// declaration context.\n  ///\n  /// \\param DC The declaration context whose declarations will be\n  /// read.\n  ///\n  /// \\param IsKindWeWant A predicate indicating which declaration kinds\n  /// we are interested in.\n  ///\n  /// \\param Decls Vector that will contain the declarations loaded\n  /// from the external source. The caller is responsible for merging\n  /// these declarations with any declarations already stored in the\n  /// declaration context.\n  void\n  FindExternalLexicalDecls(const DeclContext *DC,\n                           llvm::function_ref<bool(Decl::Kind)> IsKindWeWant,\n                           SmallVectorImpl<Decl *> &Decls) override;\n\n  /// Get the decls that are contained in a file in the Offset/Length\n  /// range. \\p Length can be 0 to indicate a point at \\p Offset instead of\n  /// a range.\n  void FindFileRegionDecls(FileID File, unsigned Offset, unsigned Length,\n                           SmallVectorImpl<Decl *> &Decls) override;\n\n  /// Notify ASTReader that we started deserialization of\n  /// a decl or type so until FinishedDeserializing is called there may be\n  /// decls that are initializing. Must be paired with FinishedDeserializing.\n  void StartedDeserializing() override;\n\n  /// Notify ASTReader that we finished the deserialization of\n  /// a decl or type. Must be paired with StartedDeserializing.\n  void FinishedDeserializing() override;\n\n  /// Function that will be invoked when we begin parsing a new\n  /// translation unit involving this external AST source.\n  ///\n  /// This function will provide all of the external definitions to\n  /// the ASTConsumer.\n  void StartTranslationUnit(ASTConsumer *Consumer) override;\n\n  /// Print some statistics about AST usage.\n  void PrintStats() override;\n\n  /// Dump information about the AST reader to standard error.\n  void dump();\n\n  /// Return the amount of memory used by memory buffers, breaking down\n  /// by heap-backed versus mmap'ed memory.\n  void getMemoryBufferSizes(MemoryBufferSizes &sizes) const override;\n\n  /// Initialize the semantic source with the Sema instance\n  /// being used to perform semantic analysis on the abstract syntax\n  /// tree.\n  void InitializeSema(Sema &S) override;\n\n  /// Inform the semantic consumer that Sema is no longer available.\n  void ForgetSema() override { SemaObj = nullptr; }\n\n  /// Retrieve the IdentifierInfo for the named identifier.\n  ///\n  /// This routine builds a new IdentifierInfo for the given identifier. If any\n  /// declarations with this name are visible from translation unit scope, their\n  /// declarations will be deserialized and introduced into the declaration\n  /// chain of the identifier.\n  IdentifierInfo *get(StringRef Name) override;\n\n  /// Retrieve an iterator into the set of all identifiers\n  /// in all loaded AST files.\n  IdentifierIterator *getIdentifiers() override;\n\n  /// Load the contents of the global method pool for a given\n  /// selector.\n  void ReadMethodPool(Selector Sel) override;\n\n  /// Load the contents of the global method pool for a given\n  /// selector if necessary.\n  void updateOutOfDateSelector(Selector Sel) override;\n\n  /// Load the set of namespaces that are known to the external source,\n  /// which will be used during typo correction.\n  void ReadKnownNamespaces(\n                         SmallVectorImpl<NamespaceDecl *> &Namespaces) override;\n\n  void ReadUndefinedButUsed(\n      llvm::MapVector<NamedDecl *, SourceLocation> &Undefined) override;\n\n  void ReadMismatchingDeleteExpressions(llvm::MapVector<\n      FieldDecl *, llvm::SmallVector<std::pair<SourceLocation, bool>, 4>> &\n                                            Exprs) override;\n\n  void ReadTentativeDefinitions(\n                            SmallVectorImpl<VarDecl *> &TentativeDefs) override;\n\n  void ReadUnusedFileScopedDecls(\n                       SmallVectorImpl<const DeclaratorDecl *> &Decls) override;\n\n  void ReadDelegatingConstructors(\n                         SmallVectorImpl<CXXConstructorDecl *> &Decls) override;\n\n  void ReadExtVectorDecls(SmallVectorImpl<TypedefNameDecl *> &Decls) override;\n\n  void ReadUnusedLocalTypedefNameCandidates(\n      llvm::SmallSetVector<const TypedefNameDecl *, 4> &Decls) override;\n\n  void ReadDeclsToCheckForDeferredDiags(\n      llvm::SmallVector<Decl *, 4> &Decls) override;\n\n  void ReadReferencedSelectors(\n           SmallVectorImpl<std::pair<Selector, SourceLocation>> &Sels) override;\n\n  void ReadWeakUndeclaredIdentifiers(\n           SmallVectorImpl<std::pair<IdentifierInfo *, WeakInfo>> &WI) override;\n\n  void ReadUsedVTables(SmallVectorImpl<ExternalVTableUse> &VTables) override;\n\n  void ReadPendingInstantiations(\n                  SmallVectorImpl<std::pair<ValueDecl *,\n                                            SourceLocation>> &Pending) override;\n\n  void ReadLateParsedTemplates(\n      llvm::MapVector<const FunctionDecl *, std::unique_ptr<LateParsedTemplate>>\n          &LPTMap) override;\n\n  /// Load a selector from disk, registering its ID if it exists.\n  void LoadSelector(Selector Sel);\n\n  void SetIdentifierInfo(unsigned ID, IdentifierInfo *II);\n  void SetGloballyVisibleDecls(IdentifierInfo *II,\n                               const SmallVectorImpl<uint32_t> &DeclIDs,\n                               SmallVectorImpl<Decl *> *Decls = nullptr);\n\n  /// Report a diagnostic.\n  DiagnosticBuilder Diag(unsigned DiagID) const;\n\n  /// Report a diagnostic.\n  DiagnosticBuilder Diag(SourceLocation Loc, unsigned DiagID) const;\n\n  IdentifierInfo *DecodeIdentifierInfo(serialization::IdentifierID ID);\n\n  IdentifierInfo *readIdentifier(ModuleFile &M, const RecordData &Record,\n                                 unsigned &Idx) {\n    return DecodeIdentifierInfo(getGlobalIdentifierID(M, Record[Idx++]));\n  }\n\n  IdentifierInfo *GetIdentifier(serialization::IdentifierID ID) override {\n    // Note that we are loading an identifier.\n    Deserializing AnIdentifier(this);\n\n    return DecodeIdentifierInfo(ID);\n  }\n\n  IdentifierInfo *getLocalIdentifier(ModuleFile &M, unsigned LocalID);\n\n  serialization::IdentifierID getGlobalIdentifierID(ModuleFile &M,\n                                                    unsigned LocalID);\n\n  void resolvePendingMacro(IdentifierInfo *II, const PendingMacroInfo &PMInfo);\n\n  /// Retrieve the macro with the given ID.\n  MacroInfo *getMacro(serialization::MacroID ID);\n\n  /// Retrieve the global macro ID corresponding to the given local\n  /// ID within the given module file.\n  serialization::MacroID getGlobalMacroID(ModuleFile &M, unsigned LocalID);\n\n  /// Read the source location entry with index ID.\n  bool ReadSLocEntry(int ID) override;\n\n  /// Retrieve the module import location and module name for the\n  /// given source manager entry ID.\n  std::pair<SourceLocation, StringRef> getModuleImportLoc(int ID) override;\n\n  /// Retrieve the global submodule ID given a module and its local ID\n  /// number.\n  serialization::SubmoduleID\n  getGlobalSubmoduleID(ModuleFile &M, unsigned LocalID);\n\n  /// Retrieve the submodule that corresponds to a global submodule ID.\n  ///\n  Module *getSubmodule(serialization::SubmoduleID GlobalID);\n\n  /// Retrieve the module that corresponds to the given module ID.\n  ///\n  /// Note: overrides method in ExternalASTSource\n  Module *getModule(unsigned ID) override;\n\n  /// Retrieve the module file with a given local ID within the specified\n  /// ModuleFile.\n  ModuleFile *getLocalModuleFile(ModuleFile &M, unsigned ID);\n\n  /// Get an ID for the given module file.\n  unsigned getModuleFileID(ModuleFile *M);\n\n  /// Return a descriptor for the corresponding module.\n  llvm::Optional<ASTSourceDescriptor> getSourceDescriptor(unsigned ID) override;\n\n  ExtKind hasExternalDefinitions(const Decl *D) override;\n\n  /// Retrieve a selector from the given module with its local ID\n  /// number.\n  Selector getLocalSelector(ModuleFile &M, unsigned LocalID);\n\n  Selector DecodeSelector(serialization::SelectorID Idx);\n\n  Selector GetExternalSelector(serialization::SelectorID ID) override;\n  uint32_t GetNumExternalSelectors() override;\n\n  Selector ReadSelector(ModuleFile &M, const RecordData &Record, unsigned &Idx) {\n    return getLocalSelector(M, Record[Idx++]);\n  }\n\n  /// Retrieve the global selector ID that corresponds to this\n  /// the local selector ID in a given module.\n  serialization::SelectorID getGlobalSelectorID(ModuleFile &F,\n                                                unsigned LocalID) const;\n\n  /// Read the contents of a CXXCtorInitializer array.\n  CXXCtorInitializer **GetExternalCXXCtorInitializers(uint64_t Offset) override;\n\n  /// Read a AlignPackInfo from raw form.\n  Sema::AlignPackInfo ReadAlignPackInfo(uint32_t Raw) const {\n    return Sema::AlignPackInfo::getFromRawEncoding(Raw);\n  }\n\n  /// Read a source location from raw form and return it in its\n  /// originating module file's source location space.\n  SourceLocation ReadUntranslatedSourceLocation(uint32_t Raw) const {\n    return SourceLocation::getFromRawEncoding((Raw >> 1) | (Raw << 31));\n  }\n\n  /// Read a source location from raw form.\n  SourceLocation ReadSourceLocation(ModuleFile &ModuleFile, uint32_t Raw) const {\n    SourceLocation Loc = ReadUntranslatedSourceLocation(Raw);\n    return TranslateSourceLocation(ModuleFile, Loc);\n  }\n\n  /// Translate a source location from another module file's source\n  /// location space into ours.\n  SourceLocation TranslateSourceLocation(ModuleFile &ModuleFile,\n                                         SourceLocation Loc) const {\n    if (!ModuleFile.ModuleOffsetMap.empty())\n      ReadModuleOffsetMap(ModuleFile);\n    assert(ModuleFile.SLocRemap.find(Loc.getOffset()) !=\n               ModuleFile.SLocRemap.end() &&\n           \"Cannot find offset to remap.\");\n    int Remap = ModuleFile.SLocRemap.find(Loc.getOffset())->second;\n    return Loc.getLocWithOffset(Remap);\n  }\n\n  /// Read a source location.\n  SourceLocation ReadSourceLocation(ModuleFile &ModuleFile,\n                                    const RecordDataImpl &Record,\n                                    unsigned &Idx) {\n    return ReadSourceLocation(ModuleFile, Record[Idx++]);\n  }\n\n  /// Read a source range.\n  SourceRange ReadSourceRange(ModuleFile &F,\n                              const RecordData &Record, unsigned &Idx);\n\n  // Read a string\n  static std::string ReadString(const RecordData &Record, unsigned &Idx);\n\n  // Skip a string\n  static void SkipString(const RecordData &Record, unsigned &Idx) {\n    Idx += Record[Idx] + 1;\n  }\n\n  // Read a path\n  std::string ReadPath(ModuleFile &F, const RecordData &Record, unsigned &Idx);\n\n  // Read a path\n  std::string ReadPath(StringRef BaseDirectory, const RecordData &Record,\n                       unsigned &Idx);\n\n  // Skip a path\n  static void SkipPath(const RecordData &Record, unsigned &Idx) {\n    SkipString(Record, Idx);\n  }\n\n  /// Read a version tuple.\n  static VersionTuple ReadVersionTuple(const RecordData &Record, unsigned &Idx);\n\n  CXXTemporary *ReadCXXTemporary(ModuleFile &F, const RecordData &Record,\n                                 unsigned &Idx);\n\n  /// Reads a statement.\n  Stmt *ReadStmt(ModuleFile &F);\n\n  /// Reads an expression.\n  Expr *ReadExpr(ModuleFile &F);\n\n  /// Reads a sub-statement operand during statement reading.\n  Stmt *ReadSubStmt() {\n    assert(ReadingKind == Read_Stmt &&\n           \"Should be called only during statement reading!\");\n    // Subexpressions are stored from last to first, so the next Stmt we need\n    // is at the back of the stack.\n    assert(!StmtStack.empty() && \"Read too many sub-statements!\");\n    return StmtStack.pop_back_val();\n  }\n\n  /// Reads a sub-expression operand during statement reading.\n  Expr *ReadSubExpr();\n\n  /// Reads a token out of a record.\n  Token ReadToken(ModuleFile &M, const RecordDataImpl &Record, unsigned &Idx);\n\n  /// Reads the macro record located at the given offset.\n  MacroInfo *ReadMacroRecord(ModuleFile &F, uint64_t Offset);\n\n  /// Determine the global preprocessed entity ID that corresponds to\n  /// the given local ID within the given module.\n  serialization::PreprocessedEntityID\n  getGlobalPreprocessedEntityID(ModuleFile &M, unsigned LocalID) const;\n\n  /// Add a macro to deserialize its macro directive history.\n  ///\n  /// \\param II The name of the macro.\n  /// \\param M The module file.\n  /// \\param MacroDirectivesOffset Offset of the serialized macro directive\n  /// history.\n  void addPendingMacro(IdentifierInfo *II, ModuleFile *M,\n                       uint32_t MacroDirectivesOffset);\n\n  /// Read the set of macros defined by this external macro source.\n  void ReadDefinedMacros() override;\n\n  /// Update an out-of-date identifier.\n  void updateOutOfDateIdentifier(IdentifierInfo &II) override;\n\n  /// Note that this identifier is up-to-date.\n  void markIdentifierUpToDate(IdentifierInfo *II);\n\n  /// Load all external visible decls in the given DeclContext.\n  void completeVisibleDeclsMap(const DeclContext *DC) override;\n\n  /// Retrieve the AST context that this AST reader supplements.\n  ASTContext &getContext() {\n    assert(ContextObj && \"requested AST context when not loading AST\");\n    return *ContextObj;\n  }\n\n  // Contains the IDs for declarations that were requested before we have\n  // access to a Sema object.\n  SmallVector<uint64_t, 16> PreloadedDeclIDs;\n\n  /// Retrieve the semantic analysis object used to analyze the\n  /// translation unit in which the precompiled header is being\n  /// imported.\n  Sema *getSema() { return SemaObj; }\n\n  /// Get the identifier resolver used for name lookup / updates\n  /// in the translation unit scope. We have one of these even if we don't\n  /// have a Sema object.\n  IdentifierResolver &getIdResolver();\n\n  /// Retrieve the identifier table associated with the\n  /// preprocessor.\n  IdentifierTable &getIdentifierTable();\n\n  /// Record that the given ID maps to the given switch-case\n  /// statement.\n  void RecordSwitchCaseID(SwitchCase *SC, unsigned ID);\n\n  /// Retrieve the switch-case statement with the given ID.\n  SwitchCase *getSwitchCaseWithID(unsigned ID);\n\n  void ClearSwitchCaseIDs();\n\n  /// Cursors for comments blocks.\n  SmallVector<std::pair<llvm::BitstreamCursor,\n                        serialization::ModuleFile *>, 8> CommentsCursors;\n\n  /// Loads comments ranges.\n  void ReadComments() override;\n\n  /// Visit all the input files of the given module file.\n  void visitInputFiles(serialization::ModuleFile &MF,\n                       bool IncludeSystem, bool Complain,\n          llvm::function_ref<void(const serialization::InputFile &IF,\n                                  bool isSystem)> Visitor);\n\n  /// Visit all the top-level module maps loaded when building the given module\n  /// file.\n  void visitTopLevelModuleMaps(serialization::ModuleFile &MF,\n                               llvm::function_ref<\n                                   void(const FileEntry *)> Visitor);\n\n  bool isProcessingUpdateRecords() { return ProcessingUpdateRecords; }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_SERIALIZATION_ASTREADER_H\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp", "content": "//===- ASTReaderDecl.cpp - Decl Deserialization ---------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the ASTReader::readDeclRecord method, which is the\n// entrypoint for loading a decl.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"ASTCommon.h\"\n#include \"ASTReaderInternals.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/AttrIterator.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclCXX.h\"\n#include \"clang/AST/DeclFriend.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclOpenMP.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/DeclVisitor.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/LambdaCapture.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/OpenMPClause.h\"\n#include \"clang/AST/Redeclarable.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/UnresolvedSet.h\"\n#include \"clang/Basic/AttrKinds.h\"\n#include \"clang/Basic/ExceptionSpecificationType.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Lambda.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/Linkage.h\"\n#include \"clang/Basic/Module.h\"\n#include \"clang/Basic/PragmaKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Sema/IdentifierResolver.h\"\n#include \"clang/Serialization/ASTBitCodes.h\"\n#include \"clang/Serialization/ASTRecordReader.h\"\n#include \"clang/Serialization/ContinuousRangeMap.h\"\n#include \"clang/Serialization/ModuleFile.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Bitstream/BitstreamReader.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/SaveAndRestore.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <cstring>\n#include <string>\n#include <utility>\n\nusing namespace clang;\nusing namespace serialization;\n\n//===----------------------------------------------------------------------===//\n// Declaration deserialization\n//===----------------------------------------------------------------------===//\n\nnamespace clang {\n\n  class ASTDeclReader : public DeclVisitor<ASTDeclReader, void> {\n    ASTReader &Reader;\n    ASTRecordReader &Record;\n    ASTReader::RecordLocation Loc;\n    const DeclID ThisDeclID;\n    const SourceLocation ThisDeclLoc;\n\n    using RecordData = ASTReader::RecordData;\n\n    TypeID DeferredTypeID = 0;\n    unsigned AnonymousDeclNumber;\n    GlobalDeclID NamedDeclForTagDecl = 0;\n    IdentifierInfo *TypedefNameForLinkage = nullptr;\n\n    bool HasPendingBody = false;\n\n    ///A flag to carry the information for a decl from the entity is\n    /// used. We use it to delay the marking of the canonical decl as used until\n    /// the entire declaration is deserialized and merged.\n    bool IsDeclMarkedUsed = false;\n\n    uint64_t GetCurrentCursorOffset();\n\n    uint64_t ReadLocalOffset() {\n      uint64_t LocalOffset = Record.readInt();\n      assert(LocalOffset < Loc.Offset && \"offset point after current record\");\n      return LocalOffset ? Loc.Offset - LocalOffset : 0;\n    }\n\n    uint64_t ReadGlobalOffset() {\n      uint64_t Local = ReadLocalOffset();\n      return Local ? Record.getGlobalBitOffset(Local) : 0;\n    }\n\n    SourceLocation readSourceLocation() {\n      return Record.readSourceLocation();\n    }\n\n    SourceRange readSourceRange() {\n      return Record.readSourceRange();\n    }\n\n    TypeSourceInfo *readTypeSourceInfo() {\n      return Record.readTypeSourceInfo();\n    }\n\n    serialization::DeclID readDeclID() {\n      return Record.readDeclID();\n    }\n\n    std::string readString() {\n      return Record.readString();\n    }\n\n    void readDeclIDList(SmallVectorImpl<DeclID> &IDs) {\n      for (unsigned I = 0, Size = Record.readInt(); I != Size; ++I)\n        IDs.push_back(readDeclID());\n    }\n\n    Decl *readDecl() {\n      return Record.readDecl();\n    }\n\n    template<typename T>\n    T *readDeclAs() {\n      return Record.readDeclAs<T>();\n    }\n\n    serialization::SubmoduleID readSubmoduleID() {\n      if (Record.getIdx() == Record.size())\n        return 0;\n\n      return Record.getGlobalSubmoduleID(Record.readInt());\n    }\n\n    Module *readModule() {\n      return Record.getSubmodule(readSubmoduleID());\n    }\n\n    void ReadCXXRecordDefinition(CXXRecordDecl *D, bool Update);\n    void ReadCXXDefinitionData(struct CXXRecordDecl::DefinitionData &Data,\n                               const CXXRecordDecl *D);\n    void MergeDefinitionData(CXXRecordDecl *D,\n                             struct CXXRecordDecl::DefinitionData &&NewDD);\n    void ReadObjCDefinitionData(struct ObjCInterfaceDecl::DefinitionData &Data);\n    void MergeDefinitionData(ObjCInterfaceDecl *D,\n                             struct ObjCInterfaceDecl::DefinitionData &&NewDD);\n    void ReadObjCDefinitionData(struct ObjCProtocolDecl::DefinitionData &Data);\n    void MergeDefinitionData(ObjCProtocolDecl *D,\n                             struct ObjCProtocolDecl::DefinitionData &&NewDD);\n\n    static DeclContext *getPrimaryDCForAnonymousDecl(DeclContext *LexicalDC);\n\n    static NamedDecl *getAnonymousDeclForMerging(ASTReader &Reader,\n                                                 DeclContext *DC,\n                                                 unsigned Index);\n    static void setAnonymousDeclForMerging(ASTReader &Reader, DeclContext *DC,\n                                           unsigned Index, NamedDecl *D);\n\n    /// Results from loading a RedeclarableDecl.\n    class RedeclarableResult {\n      Decl *MergeWith;\n      GlobalDeclID FirstID;\n      bool IsKeyDecl;\n\n    public:\n      RedeclarableResult(Decl *MergeWith, GlobalDeclID FirstID, bool IsKeyDecl)\n          : MergeWith(MergeWith), FirstID(FirstID), IsKeyDecl(IsKeyDecl) {}\n\n      /// Retrieve the first ID.\n      GlobalDeclID getFirstID() const { return FirstID; }\n\n      /// Is this declaration a key declaration?\n      bool isKeyDecl() const { return IsKeyDecl; }\n\n      /// Get a known declaration that this should be merged with, if\n      /// any.\n      Decl *getKnownMergeTarget() const { return MergeWith; }\n    };\n\n    /// Class used to capture the result of searching for an existing\n    /// declaration of a specific kind and name, along with the ability\n    /// to update the place where this result was found (the declaration\n    /// chain hanging off an identifier or the DeclContext we searched in)\n    /// if requested.\n    class FindExistingResult {\n      ASTReader &Reader;\n      NamedDecl *New = nullptr;\n      NamedDecl *Existing = nullptr;\n      bool AddResult = false;\n      unsigned AnonymousDeclNumber = 0;\n      IdentifierInfo *TypedefNameForLinkage = nullptr;\n\n    public:\n      FindExistingResult(ASTReader &Reader) : Reader(Reader) {}\n\n      FindExistingResult(ASTReader &Reader, NamedDecl *New, NamedDecl *Existing,\n                         unsigned AnonymousDeclNumber,\n                         IdentifierInfo *TypedefNameForLinkage)\n          : Reader(Reader), New(New), Existing(Existing), AddResult(true),\n            AnonymousDeclNumber(AnonymousDeclNumber),\n            TypedefNameForLinkage(TypedefNameForLinkage) {}\n\n      FindExistingResult(FindExistingResult &&Other)\n          : Reader(Other.Reader), New(Other.New), Existing(Other.Existing),\n            AddResult(Other.AddResult),\n            AnonymousDeclNumber(Other.AnonymousDeclNumber),\n            TypedefNameForLinkage(Other.TypedefNameForLinkage) {\n        Other.AddResult = false;\n      }\n\n      FindExistingResult &operator=(FindExistingResult &&) = delete;\n      ~FindExistingResult();\n\n      /// Suppress the addition of this result into the known set of\n      /// names.\n      void suppress() { AddResult = false; }\n\n      operator NamedDecl*() const { return Existing; }\n\n      template<typename T>\n      operator T*() const { return dyn_cast_or_null<T>(Existing); }\n    };\n\n    static DeclContext *getPrimaryContextForMerging(ASTReader &Reader,\n                                                    DeclContext *DC);\n    FindExistingResult findExisting(NamedDecl *D);\n\n  public:\n    ASTDeclReader(ASTReader &Reader, ASTRecordReader &Record,\n                  ASTReader::RecordLocation Loc,\n                  DeclID thisDeclID, SourceLocation ThisDeclLoc)\n        : Reader(Reader), Record(Record), Loc(Loc), ThisDeclID(thisDeclID),\n          ThisDeclLoc(ThisDeclLoc) {}\n\n    template <typename T> static\n    void AddLazySpecializations(T *D,\n                                SmallVectorImpl<serialization::DeclID>& IDs) {\n      if (IDs.empty())\n        return;\n\n      // FIXME: We should avoid this pattern of getting the ASTContext.\n      ASTContext &C = D->getASTContext();\n\n      auto *&LazySpecializations = D->getCommonPtr()->LazySpecializations;\n\n      if (auto &Old = LazySpecializations) {\n        IDs.insert(IDs.end(), Old + 1, Old + 1 + Old[0]);\n        llvm::sort(IDs);\n        IDs.erase(std::unique(IDs.begin(), IDs.end()), IDs.end());\n      }\n\n      auto *Result = new (C) serialization::DeclID[1 + IDs.size()];\n      *Result = IDs.size();\n      std::copy(IDs.begin(), IDs.end(), Result + 1);\n\n      LazySpecializations = Result;\n    }\n\n    template <typename DeclT>\n    static Decl *getMostRecentDeclImpl(Redeclarable<DeclT> *D);\n    static Decl *getMostRecentDeclImpl(...);\n    static Decl *getMostRecentDecl(Decl *D);\n\n    static void mergeInheritableAttributes(ASTReader &Reader, Decl *D,\n                                           Decl *Previous);\n\n    template <typename DeclT>\n    static void attachPreviousDeclImpl(ASTReader &Reader,\n                                       Redeclarable<DeclT> *D, Decl *Previous,\n                                       Decl *Canon);\n    static void attachPreviousDeclImpl(ASTReader &Reader, ...);\n    static void attachPreviousDecl(ASTReader &Reader, Decl *D, Decl *Previous,\n                                   Decl *Canon);\n\n    template <typename DeclT>\n    static void attachLatestDeclImpl(Redeclarable<DeclT> *D, Decl *Latest);\n    static void attachLatestDeclImpl(...);\n    static void attachLatestDecl(Decl *D, Decl *latest);\n\n    template <typename DeclT>\n    static void markIncompleteDeclChainImpl(Redeclarable<DeclT> *D);\n    static void markIncompleteDeclChainImpl(...);\n\n    /// Determine whether this declaration has a pending body.\n    bool hasPendingBody() const { return HasPendingBody; }\n\n    void ReadFunctionDefinition(FunctionDecl *FD);\n    void Visit(Decl *D);\n\n    void UpdateDecl(Decl *D, SmallVectorImpl<serialization::DeclID> &);\n\n    static void setNextObjCCategory(ObjCCategoryDecl *Cat,\n                                    ObjCCategoryDecl *Next) {\n      Cat->NextClassCategory = Next;\n    }\n\n    void VisitDecl(Decl *D);\n    void VisitPragmaCommentDecl(PragmaCommentDecl *D);\n    void VisitPragmaDetectMismatchDecl(PragmaDetectMismatchDecl *D);\n    void VisitTranslationUnitDecl(TranslationUnitDecl *TU);\n    void VisitNamedDecl(NamedDecl *ND);\n    void VisitLabelDecl(LabelDecl *LD);\n    void VisitNamespaceDecl(NamespaceDecl *D);\n    void VisitUsingDirectiveDecl(UsingDirectiveDecl *D);\n    void VisitNamespaceAliasDecl(NamespaceAliasDecl *D);\n    void VisitTypeDecl(TypeDecl *TD);\n    RedeclarableResult VisitTypedefNameDecl(TypedefNameDecl *TD);\n    void VisitTypedefDecl(TypedefDecl *TD);\n    void VisitTypeAliasDecl(TypeAliasDecl *TD);\n    void VisitUnresolvedUsingTypenameDecl(UnresolvedUsingTypenameDecl *D);\n    RedeclarableResult VisitTagDecl(TagDecl *TD);\n    void VisitEnumDecl(EnumDecl *ED);\n    RedeclarableResult VisitRecordDeclImpl(RecordDecl *RD);\n    void VisitRecordDecl(RecordDecl *RD) { VisitRecordDeclImpl(RD); }\n    RedeclarableResult VisitCXXRecordDeclImpl(CXXRecordDecl *D);\n    void VisitCXXRecordDecl(CXXRecordDecl *D) { VisitCXXRecordDeclImpl(D); }\n    RedeclarableResult VisitClassTemplateSpecializationDeclImpl(\n                                            ClassTemplateSpecializationDecl *D);\n\n    void VisitClassTemplateSpecializationDecl(\n        ClassTemplateSpecializationDecl *D) {\n      VisitClassTemplateSpecializationDeclImpl(D);\n    }\n\n    void VisitClassTemplatePartialSpecializationDecl(\n                                     ClassTemplatePartialSpecializationDecl *D);\n    void VisitClassScopeFunctionSpecializationDecl(\n                                       ClassScopeFunctionSpecializationDecl *D);\n    RedeclarableResult\n    VisitVarTemplateSpecializationDeclImpl(VarTemplateSpecializationDecl *D);\n\n    void VisitVarTemplateSpecializationDecl(VarTemplateSpecializationDecl *D) {\n      VisitVarTemplateSpecializationDeclImpl(D);\n    }\n\n    void VisitVarTemplatePartialSpecializationDecl(\n        VarTemplatePartialSpecializationDecl *D);\n    void VisitTemplateTypeParmDecl(TemplateTypeParmDecl *D);\n    void VisitValueDecl(ValueDecl *VD);\n    void VisitEnumConstantDecl(EnumConstantDecl *ECD);\n    void VisitUnresolvedUsingValueDecl(UnresolvedUsingValueDecl *D);\n    void VisitDeclaratorDecl(DeclaratorDecl *DD);\n    void VisitFunctionDecl(FunctionDecl *FD);\n    void VisitCXXDeductionGuideDecl(CXXDeductionGuideDecl *GD);\n    void VisitCXXMethodDecl(CXXMethodDecl *D);\n    void VisitCXXConstructorDecl(CXXConstructorDecl *D);\n    void VisitCXXDestructorDecl(CXXDestructorDecl *D);\n    void VisitCXXConversionDecl(CXXConversionDecl *D);\n    void VisitFieldDecl(FieldDecl *FD);\n    void VisitMSPropertyDecl(MSPropertyDecl *FD);\n    void VisitMSGuidDecl(MSGuidDecl *D);\n    void VisitTemplateParamObjectDecl(TemplateParamObjectDecl *D);\n    void VisitIndirectFieldDecl(IndirectFieldDecl *FD);\n    RedeclarableResult VisitVarDeclImpl(VarDecl *D);\n    void VisitVarDecl(VarDecl *VD) { VisitVarDeclImpl(VD); }\n    void VisitImplicitParamDecl(ImplicitParamDecl *PD);\n    void VisitParmVarDecl(ParmVarDecl *PD);\n    void VisitDecompositionDecl(DecompositionDecl *DD);\n    void VisitBindingDecl(BindingDecl *BD);\n    void VisitNonTypeTemplateParmDecl(NonTypeTemplateParmDecl *D);\n    DeclID VisitTemplateDecl(TemplateDecl *D);\n    void VisitConceptDecl(ConceptDecl *D);\n    void VisitRequiresExprBodyDecl(RequiresExprBodyDecl *D);\n    RedeclarableResult VisitRedeclarableTemplateDecl(RedeclarableTemplateDecl *D);\n    void VisitClassTemplateDecl(ClassTemplateDecl *D);\n    void VisitBuiltinTemplateDecl(BuiltinTemplateDecl *D);\n    void VisitVarTemplateDecl(VarTemplateDecl *D);\n    void VisitFunctionTemplateDecl(FunctionTemplateDecl *D);\n    void VisitTemplateTemplateParmDecl(TemplateTemplateParmDecl *D);\n    void VisitTypeAliasTemplateDecl(TypeAliasTemplateDecl *D);\n    void VisitUsingDecl(UsingDecl *D);\n    void VisitUsingPackDecl(UsingPackDecl *D);\n    void VisitUsingShadowDecl(UsingShadowDecl *D);\n    void VisitConstructorUsingShadowDecl(ConstructorUsingShadowDecl *D);\n    void VisitLinkageSpecDecl(LinkageSpecDecl *D);\n    void VisitExportDecl(ExportDecl *D);\n    void VisitFileScopeAsmDecl(FileScopeAsmDecl *AD);\n    void VisitImportDecl(ImportDecl *D);\n    void VisitAccessSpecDecl(AccessSpecDecl *D);\n    void VisitFriendDecl(FriendDecl *D);\n    void VisitFriendTemplateDecl(FriendTemplateDecl *D);\n    void VisitStaticAssertDecl(StaticAssertDecl *D);\n    void VisitBlockDecl(BlockDecl *BD);\n    void VisitCapturedDecl(CapturedDecl *CD);\n    void VisitEmptyDecl(EmptyDecl *D);\n    void VisitLifetimeExtendedTemporaryDecl(LifetimeExtendedTemporaryDecl *D);\n\n    std::pair<uint64_t, uint64_t> VisitDeclContext(DeclContext *DC);\n\n    template<typename T>\n    RedeclarableResult VisitRedeclarable(Redeclarable<T> *D);\n\n    template<typename T>\n    void mergeRedeclarable(Redeclarable<T> *D, RedeclarableResult &Redecl,\n                           DeclID TemplatePatternID = 0);\n\n    template<typename T>\n    void mergeRedeclarable(Redeclarable<T> *D, T *Existing,\n                           RedeclarableResult &Redecl,\n                           DeclID TemplatePatternID = 0);\n\n    template<typename T>\n    void mergeMergeable(Mergeable<T> *D);\n\n    void mergeMergeable(LifetimeExtendedTemporaryDecl *D);\n\n    void mergeTemplatePattern(RedeclarableTemplateDecl *D,\n                              RedeclarableTemplateDecl *Existing,\n                              DeclID DsID, bool IsKeyDecl);\n\n    ObjCTypeParamList *ReadObjCTypeParamList();\n\n    // FIXME: Reorder according to DeclNodes.td?\n    void VisitObjCMethodDecl(ObjCMethodDecl *D);\n    void VisitObjCTypeParamDecl(ObjCTypeParamDecl *D);\n    void VisitObjCContainerDecl(ObjCContainerDecl *D);\n    void VisitObjCInterfaceDecl(ObjCInterfaceDecl *D);\n    void VisitObjCIvarDecl(ObjCIvarDecl *D);\n    void VisitObjCProtocolDecl(ObjCProtocolDecl *D);\n    void VisitObjCAtDefsFieldDecl(ObjCAtDefsFieldDecl *D);\n    void VisitObjCCategoryDecl(ObjCCategoryDecl *D);\n    void VisitObjCImplDecl(ObjCImplDecl *D);\n    void VisitObjCCategoryImplDecl(ObjCCategoryImplDecl *D);\n    void VisitObjCImplementationDecl(ObjCImplementationDecl *D);\n    void VisitObjCCompatibleAliasDecl(ObjCCompatibleAliasDecl *D);\n    void VisitObjCPropertyDecl(ObjCPropertyDecl *D);\n    void VisitObjCPropertyImplDecl(ObjCPropertyImplDecl *D);\n    void VisitOMPThreadPrivateDecl(OMPThreadPrivateDecl *D);\n    void VisitOMPAllocateDecl(OMPAllocateDecl *D);\n    void VisitOMPDeclareReductionDecl(OMPDeclareReductionDecl *D);\n    void VisitOMPDeclareMapperDecl(OMPDeclareMapperDecl *D);\n    void VisitOMPRequiresDecl(OMPRequiresDecl *D);\n    void VisitOMPCapturedExprDecl(OMPCapturedExprDecl *D);\n  };\n\n} // namespace clang\n\nnamespace {\n\n/// Iterator over the redeclarations of a declaration that have already\n/// been merged into the same redeclaration chain.\ntemplate<typename DeclT>\nclass MergedRedeclIterator {\n  DeclT *Start;\n  DeclT *Canonical = nullptr;\n  DeclT *Current = nullptr;\n\npublic:\n  MergedRedeclIterator() = default;\n  MergedRedeclIterator(DeclT *Start) : Start(Start), Current(Start) {}\n\n  DeclT *operator*() { return Current; }\n\n  MergedRedeclIterator &operator++() {\n    if (Current->isFirstDecl()) {\n      Canonical = Current;\n      Current = Current->getMostRecentDecl();\n    } else\n      Current = Current->getPreviousDecl();\n\n    // If we started in the merged portion, we'll reach our start position\n    // eventually. Otherwise, we'll never reach it, but the second declaration\n    // we reached was the canonical declaration, so stop when we see that one\n    // again.\n    if (Current == Start || Current == Canonical)\n      Current = nullptr;\n    return *this;\n  }\n\n  friend bool operator!=(const MergedRedeclIterator &A,\n                         const MergedRedeclIterator &B) {\n    return A.Current != B.Current;\n  }\n};\n\n} // namespace\n\ntemplate <typename DeclT>\nstatic llvm::iterator_range<MergedRedeclIterator<DeclT>>\nmerged_redecls(DeclT *D) {\n  return llvm::make_range(MergedRedeclIterator<DeclT>(D),\n                          MergedRedeclIterator<DeclT>());\n}\n\nuint64_t ASTDeclReader::GetCurrentCursorOffset() {\n  return Loc.F->DeclsCursor.GetCurrentBitNo() + Loc.F->GlobalBitOffset;\n}\n\nvoid ASTDeclReader::ReadFunctionDefinition(FunctionDecl *FD) {\n  if (Record.readInt()) {\n    Reader.DefinitionSource[FD] =\n        Loc.F->Kind == ModuleKind::MK_MainFile ||\n        Reader.getContext().getLangOpts().BuildingPCHWithObjectFile;\n  }\n  if (auto *CD = dyn_cast<CXXConstructorDecl>(FD)) {\n    CD->setNumCtorInitializers(Record.readInt());\n    if (CD->getNumCtorInitializers())\n      CD->CtorInitializers = ReadGlobalOffset();\n  }\n  // Store the offset of the body so we can lazily load it later.\n  Reader.PendingBodies[FD] = GetCurrentCursorOffset();\n  HasPendingBody = true;\n}\n\nvoid ASTDeclReader::Visit(Decl *D) {\n  DeclVisitor<ASTDeclReader, void>::Visit(D);\n\n  // At this point we have deserialized and merged the decl and it is safe to\n  // update its canonical decl to signal that the entire entity is used.\n  D->getCanonicalDecl()->Used |= IsDeclMarkedUsed;\n  IsDeclMarkedUsed = false;\n\n  if (auto *DD = dyn_cast<DeclaratorDecl>(D)) {\n    if (auto *TInfo = DD->getTypeSourceInfo())\n      Record.readTypeLoc(TInfo->getTypeLoc());\n  }\n\n  if (auto *TD = dyn_cast<TypeDecl>(D)) {\n    // We have a fully initialized TypeDecl. Read its type now.\n    TD->setTypeForDecl(Reader.GetType(DeferredTypeID).getTypePtrOrNull());\n\n    // If this is a tag declaration with a typedef name for linkage, it's safe\n    // to load that typedef now.\n    if (NamedDeclForTagDecl)\n      cast<TagDecl>(D)->TypedefNameDeclOrQualifier =\n          cast<TypedefNameDecl>(Reader.GetDecl(NamedDeclForTagDecl));\n  } else if (auto *ID = dyn_cast<ObjCInterfaceDecl>(D)) {\n    // if we have a fully initialized TypeDecl, we can safely read its type now.\n    ID->TypeForDecl = Reader.GetType(DeferredTypeID).getTypePtrOrNull();\n  } else if (auto *FD = dyn_cast<FunctionDecl>(D)) {\n    // FunctionDecl's body was written last after all other Stmts/Exprs.\n    // We only read it if FD doesn't already have a body (e.g., from another\n    // module).\n    // FIXME: Can we diagnose ODR violations somehow?\n    if (Record.readInt())\n      ReadFunctionDefinition(FD);\n  }\n}\n\nvoid ASTDeclReader::VisitDecl(Decl *D) {\n  if (D->isTemplateParameter() || D->isTemplateParameterPack() ||\n      isa<ParmVarDecl>(D) || isa<ObjCTypeParamDecl>(D)) {\n    // We don't want to deserialize the DeclContext of a template\n    // parameter or of a parameter of a function template immediately.   These\n    // entities might be used in the formulation of its DeclContext (for\n    // example, a function parameter can be used in decltype() in trailing\n    // return type of the function).  Use the translation unit DeclContext as a\n    // placeholder.\n    GlobalDeclID SemaDCIDForTemplateParmDecl = readDeclID();\n    GlobalDeclID LexicalDCIDForTemplateParmDecl = readDeclID();\n    if (!LexicalDCIDForTemplateParmDecl)\n      LexicalDCIDForTemplateParmDecl = SemaDCIDForTemplateParmDecl;\n    Reader.addPendingDeclContextInfo(D,\n                                     SemaDCIDForTemplateParmDecl,\n                                     LexicalDCIDForTemplateParmDecl);\n    D->setDeclContext(Reader.getContext().getTranslationUnitDecl());\n  } else {\n    auto *SemaDC = readDeclAs<DeclContext>();\n    auto *LexicalDC = readDeclAs<DeclContext>();\n    if (!LexicalDC)\n      LexicalDC = SemaDC;\n    DeclContext *MergedSemaDC = Reader.MergedDeclContexts.lookup(SemaDC);\n    // Avoid calling setLexicalDeclContext() directly because it uses\n    // Decl::getASTContext() internally which is unsafe during derialization.\n    D->setDeclContextsImpl(MergedSemaDC ? MergedSemaDC : SemaDC, LexicalDC,\n                           Reader.getContext());\n  }\n  D->setLocation(ThisDeclLoc);\n  D->InvalidDecl = Record.readInt();\n  if (Record.readInt()) { // hasAttrs\n    AttrVec Attrs;\n    Record.readAttributes(Attrs);\n    // Avoid calling setAttrs() directly because it uses Decl::getASTContext()\n    // internally which is unsafe during derialization.\n    D->setAttrsImpl(Attrs, Reader.getContext());\n  }\n  D->setImplicit(Record.readInt());\n  D->Used = Record.readInt();\n  IsDeclMarkedUsed |= D->Used;\n  D->setReferenced(Record.readInt());\n  D->setTopLevelDeclInObjCContainer(Record.readInt());\n  D->setAccess((AccessSpecifier)Record.readInt());\n  D->FromASTFile = true;\n  bool ModulePrivate = Record.readInt();\n\n  // Determine whether this declaration is part of a (sub)module. If so, it\n  // may not yet be visible.\n  if (unsigned SubmoduleID = readSubmoduleID()) {\n    // Store the owning submodule ID in the declaration.\n    D->setModuleOwnershipKind(\n        ModulePrivate ? Decl::ModuleOwnershipKind::ModulePrivate\n                      : Decl::ModuleOwnershipKind::VisibleWhenImported);\n    D->setOwningModuleID(SubmoduleID);\n\n    if (ModulePrivate) {\n      // Module-private declarations are never visible, so there is no work to\n      // do.\n    } else if (Reader.getContext().getLangOpts().ModulesLocalVisibility) {\n      // If local visibility is being tracked, this declaration will become\n      // hidden and visible as the owning module does.\n    } else if (Module *Owner = Reader.getSubmodule(SubmoduleID)) {\n      // Mark the declaration as visible when its owning module becomes visible.\n      if (Owner->NameVisibility == Module::AllVisible)\n        D->setVisibleDespiteOwningModule();\n      else\n        Reader.HiddenNamesMap[Owner].push_back(D);\n    }\n  } else if (ModulePrivate) {\n    D->setModuleOwnershipKind(Decl::ModuleOwnershipKind::ModulePrivate);\n  }\n}\n\nvoid ASTDeclReader::VisitPragmaCommentDecl(PragmaCommentDecl *D) {\n  VisitDecl(D);\n  D->setLocation(readSourceLocation());\n  D->CommentKind = (PragmaMSCommentKind)Record.readInt();\n  std::string Arg = readString();\n  memcpy(D->getTrailingObjects<char>(), Arg.data(), Arg.size());\n  D->getTrailingObjects<char>()[Arg.size()] = '\\0';\n}\n\nvoid ASTDeclReader::VisitPragmaDetectMismatchDecl(PragmaDetectMismatchDecl *D) {\n  VisitDecl(D);\n  D->setLocation(readSourceLocation());\n  std::string Name = readString();\n  memcpy(D->getTrailingObjects<char>(), Name.data(), Name.size());\n  D->getTrailingObjects<char>()[Name.size()] = '\\0';\n\n  D->ValueStart = Name.size() + 1;\n  std::string Value = readString();\n  memcpy(D->getTrailingObjects<char>() + D->ValueStart, Value.data(),\n         Value.size());\n  D->getTrailingObjects<char>()[D->ValueStart + Value.size()] = '\\0';\n}\n\nvoid ASTDeclReader::VisitTranslationUnitDecl(TranslationUnitDecl *TU) {\n  llvm_unreachable(\"Translation units are not serialized\");\n}\n\nvoid ASTDeclReader::VisitNamedDecl(NamedDecl *ND) {\n  VisitDecl(ND);\n  ND->setDeclName(Record.readDeclarationName());\n  AnonymousDeclNumber = Record.readInt();\n}\n\nvoid ASTDeclReader::VisitTypeDecl(TypeDecl *TD) {\n  VisitNamedDecl(TD);\n  TD->setLocStart(readSourceLocation());\n  // Delay type reading until after we have fully initialized the decl.\n  DeferredTypeID = Record.getGlobalTypeID(Record.readInt());\n}\n\nASTDeclReader::RedeclarableResult\nASTDeclReader::VisitTypedefNameDecl(TypedefNameDecl *TD) {\n  RedeclarableResult Redecl = VisitRedeclarable(TD);\n  VisitTypeDecl(TD);\n  TypeSourceInfo *TInfo = readTypeSourceInfo();\n  if (Record.readInt()) { // isModed\n    QualType modedT = Record.readType();\n    TD->setModedTypeSourceInfo(TInfo, modedT);\n  } else\n    TD->setTypeSourceInfo(TInfo);\n  // Read and discard the declaration for which this is a typedef name for\n  // linkage, if it exists. We cannot rely on our type to pull in this decl,\n  // because it might have been merged with a type from another module and\n  // thus might not refer to our version of the declaration.\n  readDecl();\n  return Redecl;\n}\n\nvoid ASTDeclReader::VisitTypedefDecl(TypedefDecl *TD) {\n  RedeclarableResult Redecl = VisitTypedefNameDecl(TD);\n  mergeRedeclarable(TD, Redecl);\n}\n\nvoid ASTDeclReader::VisitTypeAliasDecl(TypeAliasDecl *TD) {\n  RedeclarableResult Redecl = VisitTypedefNameDecl(TD);\n  if (auto *Template = readDeclAs<TypeAliasTemplateDecl>())\n    // Merged when we merge the template.\n    TD->setDescribedAliasTemplate(Template);\n  else\n    mergeRedeclarable(TD, Redecl);\n}\n\nASTDeclReader::RedeclarableResult ASTDeclReader::VisitTagDecl(TagDecl *TD) {\n  RedeclarableResult Redecl = VisitRedeclarable(TD);\n  VisitTypeDecl(TD);\n\n  TD->IdentifierNamespace = Record.readInt();\n  TD->setTagKind((TagDecl::TagKind)Record.readInt());\n  if (!isa<CXXRecordDecl>(TD))\n    TD->setCompleteDefinition(Record.readInt());\n  TD->setEmbeddedInDeclarator(Record.readInt());\n  TD->setFreeStanding(Record.readInt());\n  TD->setCompleteDefinitionRequired(Record.readInt());\n  TD->setBraceRange(readSourceRange());\n\n  switch (Record.readInt()) {\n  case 0:\n    break;\n  case 1: { // ExtInfo\n    auto *Info = new (Reader.getContext()) TagDecl::ExtInfo();\n    Record.readQualifierInfo(*Info);\n    TD->TypedefNameDeclOrQualifier = Info;\n    break;\n  }\n  case 2: // TypedefNameForAnonDecl\n    NamedDeclForTagDecl = readDeclID();\n    TypedefNameForLinkage = Record.readIdentifier();\n    break;\n  default:\n    llvm_unreachable(\"unexpected tag info kind\");\n  }\n\n  if (!isa<CXXRecordDecl>(TD))\n    mergeRedeclarable(TD, Redecl);\n  return Redecl;\n}\n\nvoid ASTDeclReader::VisitEnumDecl(EnumDecl *ED) {\n  VisitTagDecl(ED);\n  if (TypeSourceInfo *TI = readTypeSourceInfo())\n    ED->setIntegerTypeSourceInfo(TI);\n  else\n    ED->setIntegerType(Record.readType());\n  ED->setPromotionType(Record.readType());\n  ED->setNumPositiveBits(Record.readInt());\n  ED->setNumNegativeBits(Record.readInt());\n  ED->setScoped(Record.readInt());\n  ED->setScopedUsingClassTag(Record.readInt());\n  ED->setFixed(Record.readInt());\n\n  ED->setHasODRHash(true);\n  ED->ODRHash = Record.readInt();\n\n  // If this is a definition subject to the ODR, and we already have a\n  // definition, merge this one into it.\n  if (ED->isCompleteDefinition() &&\n      Reader.getContext().getLangOpts().Modules &&\n      Reader.getContext().getLangOpts().CPlusPlus) {\n    EnumDecl *&OldDef = Reader.EnumDefinitions[ED->getCanonicalDecl()];\n    if (!OldDef) {\n      // This is the first time we've seen an imported definition. Look for a\n      // local definition before deciding that we are the first definition.\n      for (auto *D : merged_redecls(ED->getCanonicalDecl())) {\n        if (!D->isFromASTFile() && D->isCompleteDefinition()) {\n          OldDef = D;\n          break;\n        }\n      }\n    }\n    if (OldDef) {\n      Reader.MergedDeclContexts.insert(std::make_pair(ED, OldDef));\n      ED->setCompleteDefinition(false);\n      Reader.mergeDefinitionVisibility(OldDef, ED);\n      if (OldDef->getODRHash() != ED->getODRHash())\n        Reader.PendingEnumOdrMergeFailures[OldDef].push_back(ED);\n    } else {\n      OldDef = ED;\n    }\n  }\n\n  if (auto *InstED = readDeclAs<EnumDecl>()) {\n    auto TSK = (TemplateSpecializationKind)Record.readInt();\n    SourceLocation POI = readSourceLocation();\n    ED->setInstantiationOfMemberEnum(Reader.getContext(), InstED, TSK);\n    ED->getMemberSpecializationInfo()->setPointOfInstantiation(POI);\n  }\n}\n\nASTDeclReader::RedeclarableResult\nASTDeclReader::VisitRecordDeclImpl(RecordDecl *RD) {\n  RedeclarableResult Redecl = VisitTagDecl(RD);\n  RD->setHasFlexibleArrayMember(Record.readInt());\n  RD->setAnonymousStructOrUnion(Record.readInt());\n  RD->setHasObjectMember(Record.readInt());\n  RD->setHasVolatileMember(Record.readInt());\n  RD->setNonTrivialToPrimitiveDefaultInitialize(Record.readInt());\n  RD->setNonTrivialToPrimitiveCopy(Record.readInt());\n  RD->setNonTrivialToPrimitiveDestroy(Record.readInt());\n  RD->setHasNonTrivialToPrimitiveDefaultInitializeCUnion(Record.readInt());\n  RD->setHasNonTrivialToPrimitiveDestructCUnion(Record.readInt());\n  RD->setHasNonTrivialToPrimitiveCopyCUnion(Record.readInt());\n  RD->setParamDestroyedInCallee(Record.readInt());\n  RD->setArgPassingRestrictions((RecordDecl::ArgPassingKind)Record.readInt());\n  return Redecl;\n}\n\nvoid ASTDeclReader::VisitValueDecl(ValueDecl *VD) {\n  VisitNamedDecl(VD);\n  // For function declarations, defer reading the type in case the function has\n  // a deduced return type that references an entity declared within the\n  // function.\n  if (isa<FunctionDecl>(VD))\n    DeferredTypeID = Record.getGlobalTypeID(Record.readInt());\n  else\n    VD->setType(Record.readType());\n}\n\nvoid ASTDeclReader::VisitEnumConstantDecl(EnumConstantDecl *ECD) {\n  VisitValueDecl(ECD);\n  if (Record.readInt())\n    ECD->setInitExpr(Record.readExpr());\n  ECD->setInitVal(Record.readAPSInt());\n  mergeMergeable(ECD);\n}\n\nvoid ASTDeclReader::VisitDeclaratorDecl(DeclaratorDecl *DD) {\n  VisitValueDecl(DD);\n  DD->setInnerLocStart(readSourceLocation());\n  if (Record.readInt()) { // hasExtInfo\n    auto *Info = new (Reader.getContext()) DeclaratorDecl::ExtInfo();\n    Record.readQualifierInfo(*Info);\n    Info->TrailingRequiresClause = Record.readExpr();\n    DD->DeclInfo = Info;\n  }\n  QualType TSIType = Record.readType();\n  DD->setTypeSourceInfo(\n      TSIType.isNull() ? nullptr\n                       : Reader.getContext().CreateTypeSourceInfo(TSIType));\n}\n\nvoid ASTDeclReader::VisitFunctionDecl(FunctionDecl *FD) {\n  RedeclarableResult Redecl = VisitRedeclarable(FD);\n  VisitDeclaratorDecl(FD);\n\n  // Attach a type to this function. Use the real type if possible, but fall\n  // back to the type as written if it involves a deduced return type.\n  if (FD->getTypeSourceInfo() &&\n      FD->getTypeSourceInfo()->getType()->castAs<FunctionType>()\n                             ->getReturnType()->getContainedAutoType()) {\n    // We'll set up the real type in Visit, once we've finished loading the\n    // function.\n    FD->setType(FD->getTypeSourceInfo()->getType());\n    Reader.PendingFunctionTypes.push_back({FD, DeferredTypeID});\n  } else {\n    FD->setType(Reader.GetType(DeferredTypeID));\n  }\n  DeferredTypeID = 0;\n\n  FD->DNLoc = Record.readDeclarationNameLoc(FD->getDeclName());\n  FD->IdentifierNamespace = Record.readInt();\n\n  // FunctionDecl's body is handled last at ASTDeclReader::Visit,\n  // after everything else is read.\n\n  FD->setStorageClass(static_cast<StorageClass>(Record.readInt()));\n  FD->setInlineSpecified(Record.readInt());\n  FD->setImplicitlyInline(Record.readInt());\n  FD->setVirtualAsWritten(Record.readInt());\n  // We defer calling `FunctionDecl::setPure()` here as for methods of\n  // `CXXTemplateSpecializationDecl`s, we may not have connected up the\n  // definition (which is required for `setPure`).\n  const bool Pure = Record.readInt();\n  FD->setHasInheritedPrototype(Record.readInt());\n  FD->setHasWrittenPrototype(Record.readInt());\n  FD->setDeletedAsWritten(Record.readInt());\n  FD->setTrivial(Record.readInt());\n  FD->setTrivialForCall(Record.readInt());\n  FD->setDefaulted(Record.readInt());\n  FD->setExplicitlyDefaulted(Record.readInt());\n  FD->setHasImplicitReturnZero(Record.readInt());\n  FD->setConstexprKind(static_cast<ConstexprSpecKind>(Record.readInt()));\n  FD->setUsesSEHTry(Record.readInt());\n  FD->setHasSkippedBody(Record.readInt());\n  FD->setIsMultiVersion(Record.readInt());\n  FD->setLateTemplateParsed(Record.readInt());\n\n  FD->setCachedLinkage(static_cast<Linkage>(Record.readInt()));\n  FD->EndRangeLoc = readSourceLocation();\n\n  FD->ODRHash = Record.readInt();\n  FD->setHasODRHash(true);\n\n  if (FD->isDefaulted()) {\n    if (unsigned NumLookups = Record.readInt()) {\n      SmallVector<DeclAccessPair, 8> Lookups;\n      for (unsigned I = 0; I != NumLookups; ++I) {\n        NamedDecl *ND = Record.readDeclAs<NamedDecl>();\n        AccessSpecifier AS = (AccessSpecifier)Record.readInt();\n        Lookups.push_back(DeclAccessPair::make(ND, AS));\n      }\n      FD->setDefaultedFunctionInfo(FunctionDecl::DefaultedFunctionInfo::Create(\n          Reader.getContext(), Lookups));\n    }\n  }\n\n  switch ((FunctionDecl::TemplatedKind)Record.readInt()) {\n  case FunctionDecl::TK_NonTemplate:\n    mergeRedeclarable(FD, Redecl);\n    break;\n  case FunctionDecl::TK_FunctionTemplate:\n    // Merged when we merge the template.\n    FD->setDescribedFunctionTemplate(readDeclAs<FunctionTemplateDecl>());\n    break;\n  case FunctionDecl::TK_MemberSpecialization: {\n    auto *InstFD = readDeclAs<FunctionDecl>();\n    auto TSK = (TemplateSpecializationKind)Record.readInt();\n    SourceLocation POI = readSourceLocation();\n    FD->setInstantiationOfMemberFunction(Reader.getContext(), InstFD, TSK);\n    FD->getMemberSpecializationInfo()->setPointOfInstantiation(POI);\n    mergeRedeclarable(FD, Redecl);\n    break;\n  }\n  case FunctionDecl::TK_FunctionTemplateSpecialization: {\n    auto *Template = readDeclAs<FunctionTemplateDecl>();\n    auto TSK = (TemplateSpecializationKind)Record.readInt();\n\n    // Template arguments.\n    SmallVector<TemplateArgument, 8> TemplArgs;\n    Record.readTemplateArgumentList(TemplArgs, /*Canonicalize*/ true);\n\n    // Template args as written.\n    SmallVector<TemplateArgumentLoc, 8> TemplArgLocs;\n    SourceLocation LAngleLoc, RAngleLoc;\n    bool HasTemplateArgumentsAsWritten = Record.readInt();\n    if (HasTemplateArgumentsAsWritten) {\n      unsigned NumTemplateArgLocs = Record.readInt();\n      TemplArgLocs.reserve(NumTemplateArgLocs);\n      for (unsigned i = 0; i != NumTemplateArgLocs; ++i)\n        TemplArgLocs.push_back(Record.readTemplateArgumentLoc());\n\n      LAngleLoc = readSourceLocation();\n      RAngleLoc = readSourceLocation();\n    }\n\n    SourceLocation POI = readSourceLocation();\n\n    ASTContext &C = Reader.getContext();\n    TemplateArgumentList *TemplArgList\n      = TemplateArgumentList::CreateCopy(C, TemplArgs);\n    TemplateArgumentListInfo TemplArgsInfo(LAngleLoc, RAngleLoc);\n    for (unsigned i = 0, e = TemplArgLocs.size(); i != e; ++i)\n      TemplArgsInfo.addArgument(TemplArgLocs[i]);\n\n    MemberSpecializationInfo *MSInfo = nullptr;\n    if (Record.readInt()) {\n      auto *FD = readDeclAs<FunctionDecl>();\n      auto TSK = (TemplateSpecializationKind)Record.readInt();\n      SourceLocation POI = readSourceLocation();\n\n      MSInfo = new (C) MemberSpecializationInfo(FD, TSK);\n      MSInfo->setPointOfInstantiation(POI);\n    }\n\n    FunctionTemplateSpecializationInfo *FTInfo =\n        FunctionTemplateSpecializationInfo::Create(\n            C, FD, Template, TSK, TemplArgList,\n            HasTemplateArgumentsAsWritten ? &TemplArgsInfo : nullptr, POI,\n            MSInfo);\n    FD->TemplateOrSpecialization = FTInfo;\n\n    if (FD->isCanonicalDecl()) { // if canonical add to template's set.\n      // The template that contains the specializations set. It's not safe to\n      // use getCanonicalDecl on Template since it may still be initializing.\n      auto *CanonTemplate = readDeclAs<FunctionTemplateDecl>();\n      // Get the InsertPos by FindNodeOrInsertPos() instead of calling\n      // InsertNode(FTInfo) directly to avoid the getASTContext() call in\n      // FunctionTemplateSpecializationInfo's Profile().\n      // We avoid getASTContext because a decl in the parent hierarchy may\n      // be initializing.\n      llvm::FoldingSetNodeID ID;\n      FunctionTemplateSpecializationInfo::Profile(ID, TemplArgs, C);\n      void *InsertPos = nullptr;\n      FunctionTemplateDecl::Common *CommonPtr = CanonTemplate->getCommonPtr();\n      FunctionTemplateSpecializationInfo *ExistingInfo =\n          CommonPtr->Specializations.FindNodeOrInsertPos(ID, InsertPos);\n      if (InsertPos)\n        CommonPtr->Specializations.InsertNode(FTInfo, InsertPos);\n      else {\n        assert(Reader.getContext().getLangOpts().Modules &&\n               \"already deserialized this template specialization\");\n        mergeRedeclarable(FD, ExistingInfo->getFunction(), Redecl);\n      }\n    }\n    break;\n  }\n  case FunctionDecl::TK_DependentFunctionTemplateSpecialization: {\n    // Templates.\n    UnresolvedSet<8> TemplDecls;\n    unsigned NumTemplates = Record.readInt();\n    while (NumTemplates--)\n      TemplDecls.addDecl(readDeclAs<NamedDecl>());\n\n    // Templates args.\n    TemplateArgumentListInfo TemplArgs;\n    unsigned NumArgs = Record.readInt();\n    while (NumArgs--)\n      TemplArgs.addArgument(Record.readTemplateArgumentLoc());\n    TemplArgs.setLAngleLoc(readSourceLocation());\n    TemplArgs.setRAngleLoc(readSourceLocation());\n\n    FD->setDependentTemplateSpecialization(Reader.getContext(),\n                                           TemplDecls, TemplArgs);\n    // These are not merged; we don't need to merge redeclarations of dependent\n    // template friends.\n    break;\n  }\n  }\n\n  // Defer calling `setPure` until merging above has guaranteed we've set\n  // `DefinitionData` (as this will need to access it).\n  FD->setPure(Pure);\n\n  // Read in the parameters.\n  unsigned NumParams = Record.readInt();\n  SmallVector<ParmVarDecl *, 16> Params;\n  Params.reserve(NumParams);\n  for (unsigned I = 0; I != NumParams; ++I)\n    Params.push_back(readDeclAs<ParmVarDecl>());\n  FD->setParams(Reader.getContext(), Params);\n}\n\nvoid ASTDeclReader::VisitObjCMethodDecl(ObjCMethodDecl *MD) {\n  VisitNamedDecl(MD);\n  if (Record.readInt()) {\n    // Load the body on-demand. Most clients won't care, because method\n    // definitions rarely show up in headers.\n    Reader.PendingBodies[MD] = GetCurrentCursorOffset();\n    HasPendingBody = true;\n  }\n  MD->setSelfDecl(readDeclAs<ImplicitParamDecl>());\n  MD->setCmdDecl(readDeclAs<ImplicitParamDecl>());\n  MD->setInstanceMethod(Record.readInt());\n  MD->setVariadic(Record.readInt());\n  MD->setPropertyAccessor(Record.readInt());\n  MD->setSynthesizedAccessorStub(Record.readInt());\n  MD->setDefined(Record.readInt());\n  MD->setOverriding(Record.readInt());\n  MD->setHasSkippedBody(Record.readInt());\n\n  MD->setIsRedeclaration(Record.readInt());\n  MD->setHasRedeclaration(Record.readInt());\n  if (MD->hasRedeclaration())\n    Reader.getContext().setObjCMethodRedeclaration(MD,\n                                       readDeclAs<ObjCMethodDecl>());\n\n  MD->setDeclImplementation((ObjCMethodDecl::ImplementationControl)Record.readInt());\n  MD->setObjCDeclQualifier((Decl::ObjCDeclQualifier)Record.readInt());\n  MD->setRelatedResultType(Record.readInt());\n  MD->setReturnType(Record.readType());\n  MD->setReturnTypeSourceInfo(readTypeSourceInfo());\n  MD->DeclEndLoc = readSourceLocation();\n  unsigned NumParams = Record.readInt();\n  SmallVector<ParmVarDecl *, 16> Params;\n  Params.reserve(NumParams);\n  for (unsigned I = 0; I != NumParams; ++I)\n    Params.push_back(readDeclAs<ParmVarDecl>());\n\n  MD->setSelLocsKind((SelectorLocationsKind)Record.readInt());\n  unsigned NumStoredSelLocs = Record.readInt();\n  SmallVector<SourceLocation, 16> SelLocs;\n  SelLocs.reserve(NumStoredSelLocs);\n  for (unsigned i = 0; i != NumStoredSelLocs; ++i)\n    SelLocs.push_back(readSourceLocation());\n\n  MD->setParamsAndSelLocs(Reader.getContext(), Params, SelLocs);\n}\n\nvoid ASTDeclReader::VisitObjCTypeParamDecl(ObjCTypeParamDecl *D) {\n  VisitTypedefNameDecl(D);\n\n  D->Variance = Record.readInt();\n  D->Index = Record.readInt();\n  D->VarianceLoc = readSourceLocation();\n  D->ColonLoc = readSourceLocation();\n}\n\nvoid ASTDeclReader::VisitObjCContainerDecl(ObjCContainerDecl *CD) {\n  VisitNamedDecl(CD);\n  CD->setAtStartLoc(readSourceLocation());\n  CD->setAtEndRange(readSourceRange());\n}\n\nObjCTypeParamList *ASTDeclReader::ReadObjCTypeParamList() {\n  unsigned numParams = Record.readInt();\n  if (numParams == 0)\n    return nullptr;\n\n  SmallVector<ObjCTypeParamDecl *, 4> typeParams;\n  typeParams.reserve(numParams);\n  for (unsigned i = 0; i != numParams; ++i) {\n    auto *typeParam = readDeclAs<ObjCTypeParamDecl>();\n    if (!typeParam)\n      return nullptr;\n\n    typeParams.push_back(typeParam);\n  }\n\n  SourceLocation lAngleLoc = readSourceLocation();\n  SourceLocation rAngleLoc = readSourceLocation();\n\n  return ObjCTypeParamList::create(Reader.getContext(), lAngleLoc,\n                                   typeParams, rAngleLoc);\n}\n\nvoid ASTDeclReader::ReadObjCDefinitionData(\n         struct ObjCInterfaceDecl::DefinitionData &Data) {\n  // Read the superclass.\n  Data.SuperClassTInfo = readTypeSourceInfo();\n\n  Data.EndLoc = readSourceLocation();\n  Data.HasDesignatedInitializers = Record.readInt();\n\n  // Read the directly referenced protocols and their SourceLocations.\n  unsigned NumProtocols = Record.readInt();\n  SmallVector<ObjCProtocolDecl *, 16> Protocols;\n  Protocols.reserve(NumProtocols);\n  for (unsigned I = 0; I != NumProtocols; ++I)\n    Protocols.push_back(readDeclAs<ObjCProtocolDecl>());\n  SmallVector<SourceLocation, 16> ProtoLocs;\n  ProtoLocs.reserve(NumProtocols);\n  for (unsigned I = 0; I != NumProtocols; ++I)\n    ProtoLocs.push_back(readSourceLocation());\n  Data.ReferencedProtocols.set(Protocols.data(), NumProtocols, ProtoLocs.data(),\n                               Reader.getContext());\n\n  // Read the transitive closure of protocols referenced by this class.\n  NumProtocols = Record.readInt();\n  Protocols.clear();\n  Protocols.reserve(NumProtocols);\n  for (unsigned I = 0; I != NumProtocols; ++I)\n    Protocols.push_back(readDeclAs<ObjCProtocolDecl>());\n  Data.AllReferencedProtocols.set(Protocols.data(), NumProtocols,\n                                  Reader.getContext());\n}\n\nvoid ASTDeclReader::MergeDefinitionData(ObjCInterfaceDecl *D,\n         struct ObjCInterfaceDecl::DefinitionData &&NewDD) {\n  // FIXME: odr checking?\n}\n\nvoid ASTDeclReader::VisitObjCInterfaceDecl(ObjCInterfaceDecl *ID) {\n  RedeclarableResult Redecl = VisitRedeclarable(ID);\n  VisitObjCContainerDecl(ID);\n  DeferredTypeID = Record.getGlobalTypeID(Record.readInt());\n  mergeRedeclarable(ID, Redecl);\n\n  ID->TypeParamList = ReadObjCTypeParamList();\n  if (Record.readInt()) {\n    // Read the definition.\n    ID->allocateDefinitionData();\n\n    ReadObjCDefinitionData(ID->data());\n    ObjCInterfaceDecl *Canon = ID->getCanonicalDecl();\n    if (Canon->Data.getPointer()) {\n      // If we already have a definition, keep the definition invariant and\n      // merge the data.\n      MergeDefinitionData(Canon, std::move(ID->data()));\n      ID->Data = Canon->Data;\n    } else {\n      // Set the definition data of the canonical declaration, so other\n      // redeclarations will see it.\n      ID->getCanonicalDecl()->Data = ID->Data;\n\n      // We will rebuild this list lazily.\n      ID->setIvarList(nullptr);\n    }\n\n    // Note that we have deserialized a definition.\n    Reader.PendingDefinitions.insert(ID);\n\n    // Note that we've loaded this Objective-C class.\n    Reader.ObjCClassesLoaded.push_back(ID);\n  } else {\n    ID->Data = ID->getCanonicalDecl()->Data;\n  }\n}\n\nvoid ASTDeclReader::VisitObjCIvarDecl(ObjCIvarDecl *IVD) {\n  VisitFieldDecl(IVD);\n  IVD->setAccessControl((ObjCIvarDecl::AccessControl)Record.readInt());\n  // This field will be built lazily.\n  IVD->setNextIvar(nullptr);\n  bool synth = Record.readInt();\n  IVD->setSynthesize(synth);\n}\n\nvoid ASTDeclReader::ReadObjCDefinitionData(\n         struct ObjCProtocolDecl::DefinitionData &Data) {\n    unsigned NumProtoRefs = Record.readInt();\n    SmallVector<ObjCProtocolDecl *, 16> ProtoRefs;\n    ProtoRefs.reserve(NumProtoRefs);\n    for (unsigned I = 0; I != NumProtoRefs; ++I)\n      ProtoRefs.push_back(readDeclAs<ObjCProtocolDecl>());\n    SmallVector<SourceLocation, 16> ProtoLocs;\n    ProtoLocs.reserve(NumProtoRefs);\n    for (unsigned I = 0; I != NumProtoRefs; ++I)\n      ProtoLocs.push_back(readSourceLocation());\n    Data.ReferencedProtocols.set(ProtoRefs.data(), NumProtoRefs,\n                                 ProtoLocs.data(), Reader.getContext());\n}\n\nvoid ASTDeclReader::MergeDefinitionData(ObjCProtocolDecl *D,\n         struct ObjCProtocolDecl::DefinitionData &&NewDD) {\n  // FIXME: odr checking?\n}\n\nvoid ASTDeclReader::VisitObjCProtocolDecl(ObjCProtocolDecl *PD) {\n  RedeclarableResult Redecl = VisitRedeclarable(PD);\n  VisitObjCContainerDecl(PD);\n  mergeRedeclarable(PD, Redecl);\n\n  if (Record.readInt()) {\n    // Read the definition.\n    PD->allocateDefinitionData();\n\n    ReadObjCDefinitionData(PD->data());\n\n    ObjCProtocolDecl *Canon = PD->getCanonicalDecl();\n    if (Canon->Data.getPointer()) {\n      // If we already have a definition, keep the definition invariant and\n      // merge the data.\n      MergeDefinitionData(Canon, std::move(PD->data()));\n      PD->Data = Canon->Data;\n    } else {\n      // Set the definition data of the canonical declaration, so other\n      // redeclarations will see it.\n      PD->getCanonicalDecl()->Data = PD->Data;\n    }\n    // Note that we have deserialized a definition.\n    Reader.PendingDefinitions.insert(PD);\n  } else {\n    PD->Data = PD->getCanonicalDecl()->Data;\n  }\n}\n\nvoid ASTDeclReader::VisitObjCAtDefsFieldDecl(ObjCAtDefsFieldDecl *FD) {\n  VisitFieldDecl(FD);\n}\n\nvoid ASTDeclReader::VisitObjCCategoryDecl(ObjCCategoryDecl *CD) {\n  VisitObjCContainerDecl(CD);\n  CD->setCategoryNameLoc(readSourceLocation());\n  CD->setIvarLBraceLoc(readSourceLocation());\n  CD->setIvarRBraceLoc(readSourceLocation());\n\n  // Note that this category has been deserialized. We do this before\n  // deserializing the interface declaration, so that it will consider this\n  /// category.\n  Reader.CategoriesDeserialized.insert(CD);\n\n  CD->ClassInterface = readDeclAs<ObjCInterfaceDecl>();\n  CD->TypeParamList = ReadObjCTypeParamList();\n  unsigned NumProtoRefs = Record.readInt();\n  SmallVector<ObjCProtocolDecl *, 16> ProtoRefs;\n  ProtoRefs.reserve(NumProtoRefs);\n  for (unsigned I = 0; I != NumProtoRefs; ++I)\n    ProtoRefs.push_back(readDeclAs<ObjCProtocolDecl>());\n  SmallVector<SourceLocation, 16> ProtoLocs;\n  ProtoLocs.reserve(NumProtoRefs);\n  for (unsigned I = 0; I != NumProtoRefs; ++I)\n    ProtoLocs.push_back(readSourceLocation());\n  CD->setProtocolList(ProtoRefs.data(), NumProtoRefs, ProtoLocs.data(),\n                      Reader.getContext());\n\n  // Protocols in the class extension belong to the class.\n  if (NumProtoRefs > 0 && CD->ClassInterface && CD->IsClassExtension())\n    CD->ClassInterface->mergeClassExtensionProtocolList(\n        (ObjCProtocolDecl *const *)ProtoRefs.data(), NumProtoRefs,\n        Reader.getContext());\n}\n\nvoid ASTDeclReader::VisitObjCCompatibleAliasDecl(ObjCCompatibleAliasDecl *CAD) {\n  VisitNamedDecl(CAD);\n  CAD->setClassInterface(readDeclAs<ObjCInterfaceDecl>());\n}\n\nvoid ASTDeclReader::VisitObjCPropertyDecl(ObjCPropertyDecl *D) {\n  VisitNamedDecl(D);\n  D->setAtLoc(readSourceLocation());\n  D->setLParenLoc(readSourceLocation());\n  QualType T = Record.readType();\n  TypeSourceInfo *TSI = readTypeSourceInfo();\n  D->setType(T, TSI);\n  D->setPropertyAttributes((ObjCPropertyAttribute::Kind)Record.readInt());\n  D->setPropertyAttributesAsWritten(\n      (ObjCPropertyAttribute::Kind)Record.readInt());\n  D->setPropertyImplementation(\n      (ObjCPropertyDecl::PropertyControl)Record.readInt());\n  DeclarationName GetterName = Record.readDeclarationName();\n  SourceLocation GetterLoc = readSourceLocation();\n  D->setGetterName(GetterName.getObjCSelector(), GetterLoc);\n  DeclarationName SetterName = Record.readDeclarationName();\n  SourceLocation SetterLoc = readSourceLocation();\n  D->setSetterName(SetterName.getObjCSelector(), SetterLoc);\n  D->setGetterMethodDecl(readDeclAs<ObjCMethodDecl>());\n  D->setSetterMethodDecl(readDeclAs<ObjCMethodDecl>());\n  D->setPropertyIvarDecl(readDeclAs<ObjCIvarDecl>());\n}\n\nvoid ASTDeclReader::VisitObjCImplDecl(ObjCImplDecl *D) {\n  VisitObjCContainerDecl(D);\n  D->setClassInterface(readDeclAs<ObjCInterfaceDecl>());\n}\n\nvoid ASTDeclReader::VisitObjCCategoryImplDecl(ObjCCategoryImplDecl *D) {\n  VisitObjCImplDecl(D);\n  D->CategoryNameLoc = readSourceLocation();\n}\n\nvoid ASTDeclReader::VisitObjCImplementationDecl(ObjCImplementationDecl *D) {\n  VisitObjCImplDecl(D);\n  D->setSuperClass(readDeclAs<ObjCInterfaceDecl>());\n  D->SuperLoc = readSourceLocation();\n  D->setIvarLBraceLoc(readSourceLocation());\n  D->setIvarRBraceLoc(readSourceLocation());\n  D->setHasNonZeroConstructors(Record.readInt());\n  D->setHasDestructors(Record.readInt());\n  D->NumIvarInitializers = Record.readInt();\n  if (D->NumIvarInitializers)\n    D->IvarInitializers = ReadGlobalOffset();\n}\n\nvoid ASTDeclReader::VisitObjCPropertyImplDecl(ObjCPropertyImplDecl *D) {\n  VisitDecl(D);\n  D->setAtLoc(readSourceLocation());\n  D->setPropertyDecl(readDeclAs<ObjCPropertyDecl>());\n  D->PropertyIvarDecl = readDeclAs<ObjCIvarDecl>();\n  D->IvarLoc = readSourceLocation();\n  D->setGetterMethodDecl(readDeclAs<ObjCMethodDecl>());\n  D->setSetterMethodDecl(readDeclAs<ObjCMethodDecl>());\n  D->setGetterCXXConstructor(Record.readExpr());\n  D->setSetterCXXAssignment(Record.readExpr());\n}\n\nvoid ASTDeclReader::VisitFieldDecl(FieldDecl *FD) {\n  VisitDeclaratorDecl(FD);\n  FD->Mutable = Record.readInt();\n\n  if (auto ISK = static_cast<FieldDecl::InitStorageKind>(Record.readInt())) {\n    FD->InitStorage.setInt(ISK);\n    FD->InitStorage.setPointer(ISK == FieldDecl::ISK_CapturedVLAType\n                                   ? Record.readType().getAsOpaquePtr()\n                                   : Record.readExpr());\n  }\n\n  if (auto *BW = Record.readExpr())\n    FD->setBitWidth(BW);\n\n  if (!FD->getDeclName()) {\n    if (auto *Tmpl = readDeclAs<FieldDecl>())\n      Reader.getContext().setInstantiatedFromUnnamedFieldDecl(FD, Tmpl);\n  }\n  mergeMergeable(FD);\n}\n\nvoid ASTDeclReader::VisitMSPropertyDecl(MSPropertyDecl *PD) {\n  VisitDeclaratorDecl(PD);\n  PD->GetterId = Record.readIdentifier();\n  PD->SetterId = Record.readIdentifier();\n}\n\nvoid ASTDeclReader::VisitMSGuidDecl(MSGuidDecl *D) {\n  VisitValueDecl(D);\n  D->PartVal.Part1 = Record.readInt();\n  D->PartVal.Part2 = Record.readInt();\n  D->PartVal.Part3 = Record.readInt();\n  for (auto &C : D->PartVal.Part4And5)\n    C = Record.readInt();\n\n  // Add this GUID to the AST context's lookup structure, and merge if needed.\n  if (MSGuidDecl *Existing = Reader.getContext().MSGuidDecls.GetOrInsertNode(D))\n    Reader.getContext().setPrimaryMergedDecl(D, Existing->getCanonicalDecl());\n}\n\nvoid ASTDeclReader::VisitTemplateParamObjectDecl(TemplateParamObjectDecl *D) {\n  VisitValueDecl(D);\n  D->Value = Record.readAPValue();\n\n  // Add this template parameter object to the AST context's lookup structure,\n  // and merge if needed.\n  if (TemplateParamObjectDecl *Existing =\n          Reader.getContext().TemplateParamObjectDecls.GetOrInsertNode(D))\n    Reader.getContext().setPrimaryMergedDecl(D, Existing->getCanonicalDecl());\n}\n\nvoid ASTDeclReader::VisitIndirectFieldDecl(IndirectFieldDecl *FD) {\n  VisitValueDecl(FD);\n\n  FD->ChainingSize = Record.readInt();\n  assert(FD->ChainingSize >= 2 && \"Anonymous chaining must be >= 2\");\n  FD->Chaining = new (Reader.getContext())NamedDecl*[FD->ChainingSize];\n\n  for (unsigned I = 0; I != FD->ChainingSize; ++I)\n    FD->Chaining[I] = readDeclAs<NamedDecl>();\n\n  mergeMergeable(FD);\n}\n\nASTDeclReader::RedeclarableResult ASTDeclReader::VisitVarDeclImpl(VarDecl *VD) {\n  RedeclarableResult Redecl = VisitRedeclarable(VD);\n  VisitDeclaratorDecl(VD);\n\n  VD->VarDeclBits.SClass = (StorageClass)Record.readInt();\n  VD->VarDeclBits.TSCSpec = Record.readInt();\n  VD->VarDeclBits.InitStyle = Record.readInt();\n  VD->VarDeclBits.ARCPseudoStrong = Record.readInt();\n  if (!isa<ParmVarDecl>(VD)) {\n    VD->NonParmVarDeclBits.IsThisDeclarationADemotedDefinition =\n        Record.readInt();\n    VD->NonParmVarDeclBits.ExceptionVar = Record.readInt();\n    VD->NonParmVarDeclBits.NRVOVariable = Record.readInt();\n    VD->NonParmVarDeclBits.CXXForRangeDecl = Record.readInt();\n    VD->NonParmVarDeclBits.ObjCForDecl = Record.readInt();\n    VD->NonParmVarDeclBits.IsInline = Record.readInt();\n    VD->NonParmVarDeclBits.IsInlineSpecified = Record.readInt();\n    VD->NonParmVarDeclBits.IsConstexpr = Record.readInt();\n    VD->NonParmVarDeclBits.IsInitCapture = Record.readInt();\n    VD->NonParmVarDeclBits.PreviousDeclInSameBlockScope = Record.readInt();\n    VD->NonParmVarDeclBits.ImplicitParamKind = Record.readInt();\n    VD->NonParmVarDeclBits.EscapingByref = Record.readInt();\n  }\n  auto VarLinkage = Linkage(Record.readInt());\n  VD->setCachedLinkage(VarLinkage);\n\n  // Reconstruct the one piece of the IdentifierNamespace that we need.\n  if (VD->getStorageClass() == SC_Extern && VarLinkage != NoLinkage &&\n      VD->getLexicalDeclContext()->isFunctionOrMethod())\n    VD->setLocalExternDecl();\n\n  if (uint64_t Val = Record.readInt()) {\n    VD->setInit(Record.readExpr());\n    if (Val != 1) {\n      EvaluatedStmt *Eval = VD->ensureEvaluatedStmt();\n      Eval->HasConstantInitialization = (Val & 2) != 0;\n      Eval->HasConstantDestruction = (Val & 4) != 0;\n    }\n  }\n\n  if (VD->hasAttr<BlocksAttr>() && VD->getType()->getAsCXXRecordDecl()) {\n    Expr *CopyExpr = Record.readExpr();\n    if (CopyExpr)\n      Reader.getContext().setBlockVarCopyInit(VD, CopyExpr, Record.readInt());\n  }\n\n  if (VD->getStorageDuration() == SD_Static && Record.readInt()) {\n    Reader.DefinitionSource[VD] =\n        Loc.F->Kind == ModuleKind::MK_MainFile ||\n        Reader.getContext().getLangOpts().BuildingPCHWithObjectFile;\n  }\n\n  enum VarKind {\n    VarNotTemplate = 0, VarTemplate, StaticDataMemberSpecialization\n  };\n  switch ((VarKind)Record.readInt()) {\n  case VarNotTemplate:\n    // Only true variables (not parameters or implicit parameters) can be\n    // merged; the other kinds are not really redeclarable at all.\n    if (!isa<ParmVarDecl>(VD) && !isa<ImplicitParamDecl>(VD) &&\n        !isa<VarTemplateSpecializationDecl>(VD))\n      mergeRedeclarable(VD, Redecl);\n    break;\n  case VarTemplate:\n    // Merged when we merge the template.\n    VD->setDescribedVarTemplate(readDeclAs<VarTemplateDecl>());\n    break;\n  case StaticDataMemberSpecialization: { // HasMemberSpecializationInfo.\n    auto *Tmpl = readDeclAs<VarDecl>();\n    auto TSK = (TemplateSpecializationKind)Record.readInt();\n    SourceLocation POI = readSourceLocation();\n    Reader.getContext().setInstantiatedFromStaticDataMember(VD, Tmpl, TSK,POI);\n    mergeRedeclarable(VD, Redecl);\n    break;\n  }\n  }\n\n  return Redecl;\n}\n\nvoid ASTDeclReader::VisitImplicitParamDecl(ImplicitParamDecl *PD) {\n  VisitVarDecl(PD);\n}\n\nvoid ASTDeclReader::VisitParmVarDecl(ParmVarDecl *PD) {\n  VisitVarDecl(PD);\n  unsigned isObjCMethodParam = Record.readInt();\n  unsigned scopeDepth = Record.readInt();\n  unsigned scopeIndex = Record.readInt();\n  unsigned declQualifier = Record.readInt();\n  if (isObjCMethodParam) {\n    assert(scopeDepth == 0);\n    PD->setObjCMethodScopeInfo(scopeIndex);\n    PD->ParmVarDeclBits.ScopeDepthOrObjCQuals = declQualifier;\n  } else {\n    PD->setScopeInfo(scopeDepth, scopeIndex);\n  }\n  PD->ParmVarDeclBits.IsKNRPromoted = Record.readInt();\n  PD->ParmVarDeclBits.HasInheritedDefaultArg = Record.readInt();\n  if (Record.readInt()) // hasUninstantiatedDefaultArg.\n    PD->setUninstantiatedDefaultArg(Record.readExpr());\n\n  // FIXME: If this is a redeclaration of a function from another module, handle\n  // inheritance of default arguments.\n}\n\nvoid ASTDeclReader::VisitDecompositionDecl(DecompositionDecl *DD) {\n  VisitVarDecl(DD);\n  auto **BDs = DD->getTrailingObjects<BindingDecl *>();\n  for (unsigned I = 0; I != DD->NumBindings; ++I) {\n    BDs[I] = readDeclAs<BindingDecl>();\n    BDs[I]->setDecomposedDecl(DD);\n  }\n}\n\nvoid ASTDeclReader::VisitBindingDecl(BindingDecl *BD) {\n  VisitValueDecl(BD);\n  BD->Binding = Record.readExpr();\n}\n\nvoid ASTDeclReader::VisitFileScopeAsmDecl(FileScopeAsmDecl *AD) {\n  VisitDecl(AD);\n  AD->setAsmString(cast<StringLiteral>(Record.readExpr()));\n  AD->setRParenLoc(readSourceLocation());\n}\n\nvoid ASTDeclReader::VisitBlockDecl(BlockDecl *BD) {\n  VisitDecl(BD);\n  BD->setBody(cast_or_null<CompoundStmt>(Record.readStmt()));\n  BD->setSignatureAsWritten(readTypeSourceInfo());\n  unsigned NumParams = Record.readInt();\n  SmallVector<ParmVarDecl *, 16> Params;\n  Params.reserve(NumParams);\n  for (unsigned I = 0; I != NumParams; ++I)\n    Params.push_back(readDeclAs<ParmVarDecl>());\n  BD->setParams(Params);\n\n  BD->setIsVariadic(Record.readInt());\n  BD->setBlockMissingReturnType(Record.readInt());\n  BD->setIsConversionFromLambda(Record.readInt());\n  BD->setDoesNotEscape(Record.readInt());\n  BD->setCanAvoidCopyToHeap(Record.readInt());\n\n  bool capturesCXXThis = Record.readInt();\n  unsigned numCaptures = Record.readInt();\n  SmallVector<BlockDecl::Capture, 16> captures;\n  captures.reserve(numCaptures);\n  for (unsigned i = 0; i != numCaptures; ++i) {\n    auto *decl = readDeclAs<VarDecl>();\n    unsigned flags = Record.readInt();\n    bool byRef = (flags & 1);\n    bool nested = (flags & 2);\n    Expr *copyExpr = ((flags & 4) ? Record.readExpr() : nullptr);\n\n    captures.push_back(BlockDecl::Capture(decl, byRef, nested, copyExpr));\n  }\n  BD->setCaptures(Reader.getContext(), captures, capturesCXXThis);\n}\n\nvoid ASTDeclReader::VisitCapturedDecl(CapturedDecl *CD) {\n  VisitDecl(CD);\n  unsigned ContextParamPos = Record.readInt();\n  CD->setNothrow(Record.readInt() != 0);\n  // Body is set by VisitCapturedStmt.\n  for (unsigned I = 0; I < CD->NumParams; ++I) {\n    if (I != ContextParamPos)\n      CD->setParam(I, readDeclAs<ImplicitParamDecl>());\n    else\n      CD->setContextParam(I, readDeclAs<ImplicitParamDecl>());\n  }\n}\n\nvoid ASTDeclReader::VisitLinkageSpecDecl(LinkageSpecDecl *D) {\n  VisitDecl(D);\n  D->setLanguage((LinkageSpecDecl::LanguageIDs)Record.readInt());\n  D->setExternLoc(readSourceLocation());\n  D->setRBraceLoc(readSourceLocation());\n}\n\nvoid ASTDeclReader::VisitExportDecl(ExportDecl *D) {\n  VisitDecl(D);\n  D->RBraceLoc = readSourceLocation();\n}\n\nvoid ASTDeclReader::VisitLabelDecl(LabelDecl *D) {\n  VisitNamedDecl(D);\n  D->setLocStart(readSourceLocation());\n}\n\nvoid ASTDeclReader::VisitNamespaceDecl(NamespaceDecl *D) {\n  RedeclarableResult Redecl = VisitRedeclarable(D);\n  VisitNamedDecl(D);\n  D->setInline(Record.readInt());\n  D->LocStart = readSourceLocation();\n  D->RBraceLoc = readSourceLocation();\n\n  // Defer loading the anonymous namespace until we've finished merging\n  // this namespace; loading it might load a later declaration of the\n  // same namespace, and we have an invariant that older declarations\n  // get merged before newer ones try to merge.\n  GlobalDeclID AnonNamespace = 0;\n  if (Redecl.getFirstID() == ThisDeclID) {\n    AnonNamespace = readDeclID();\n  } else {\n    // Link this namespace back to the first declaration, which has already\n    // been deserialized.\n    D->AnonOrFirstNamespaceAndInline.setPointer(D->getFirstDecl());\n  }\n\n  mergeRedeclarable(D, Redecl);\n\n  if (AnonNamespace) {\n    // Each module has its own anonymous namespace, which is disjoint from\n    // any other module's anonymous namespaces, so don't attach the anonymous\n    // namespace at all.\n    auto *Anon = cast<NamespaceDecl>(Reader.GetDecl(AnonNamespace));\n    if (!Record.isModule())\n      D->setAnonymousNamespace(Anon);\n  }\n}\n\nvoid ASTDeclReader::VisitNamespaceAliasDecl(NamespaceAliasDecl *D) {\n  RedeclarableResult Redecl = VisitRedeclarable(D);\n  VisitNamedDecl(D);\n  D->NamespaceLoc = readSourceLocation();\n  D->IdentLoc = readSourceLocation();\n  D->QualifierLoc = Record.readNestedNameSpecifierLoc();\n  D->Namespace = readDeclAs<NamedDecl>();\n  mergeRedeclarable(D, Redecl);\n}\n\nvoid ASTDeclReader::VisitUsingDecl(UsingDecl *D) {\n  VisitNamedDecl(D);\n  D->setUsingLoc(readSourceLocation());\n  D->QualifierLoc = Record.readNestedNameSpecifierLoc();\n  D->DNLoc = Record.readDeclarationNameLoc(D->getDeclName());\n  D->FirstUsingShadow.setPointer(readDeclAs<UsingShadowDecl>());\n  D->setTypename(Record.readInt());\n  if (auto *Pattern = readDeclAs<NamedDecl>())\n    Reader.getContext().setInstantiatedFromUsingDecl(D, Pattern);\n  mergeMergeable(D);\n}\n\nvoid ASTDeclReader::VisitUsingPackDecl(UsingPackDecl *D) {\n  VisitNamedDecl(D);\n  D->InstantiatedFrom = readDeclAs<NamedDecl>();\n  auto **Expansions = D->getTrailingObjects<NamedDecl *>();\n  for (unsigned I = 0; I != D->NumExpansions; ++I)\n    Expansions[I] = readDeclAs<NamedDecl>();\n  mergeMergeable(D);\n}\n\nvoid ASTDeclReader::VisitUsingShadowDecl(UsingShadowDecl *D) {\n  RedeclarableResult Redecl = VisitRedeclarable(D);\n  VisitNamedDecl(D);\n  D->Underlying = readDeclAs<NamedDecl>();\n  D->IdentifierNamespace = Record.readInt();\n  D->UsingOrNextShadow = readDeclAs<NamedDecl>();\n  auto *Pattern = readDeclAs<UsingShadowDecl>();\n  if (Pattern)\n    Reader.getContext().setInstantiatedFromUsingShadowDecl(D, Pattern);\n  mergeRedeclarable(D, Redecl);\n}\n\nvoid ASTDeclReader::VisitConstructorUsingShadowDecl(\n    ConstructorUsingShadowDecl *D) {\n  VisitUsingShadowDecl(D);\n  D->NominatedBaseClassShadowDecl = readDeclAs<ConstructorUsingShadowDecl>();\n  D->ConstructedBaseClassShadowDecl = readDeclAs<ConstructorUsingShadowDecl>();\n  D->IsVirtual = Record.readInt();\n}\n\nvoid ASTDeclReader::VisitUsingDirectiveDecl(UsingDirectiveDecl *D) {\n  VisitNamedDecl(D);\n  D->UsingLoc = readSourceLocation();\n  D->NamespaceLoc = readSourceLocation();\n  D->QualifierLoc = Record.readNestedNameSpecifierLoc();\n  D->NominatedNamespace = readDeclAs<NamedDecl>();\n  D->CommonAncestor = readDeclAs<DeclContext>();\n}\n\nvoid ASTDeclReader::VisitUnresolvedUsingValueDecl(UnresolvedUsingValueDecl *D) {\n  VisitValueDecl(D);\n  D->setUsingLoc(readSourceLocation());\n  D->QualifierLoc = Record.readNestedNameSpecifierLoc();\n  D->DNLoc = Record.readDeclarationNameLoc(D->getDeclName());\n  D->EllipsisLoc = readSourceLocation();\n  mergeMergeable(D);\n}\n\nvoid ASTDeclReader::VisitUnresolvedUsingTypenameDecl(\n                                               UnresolvedUsingTypenameDecl *D) {\n  VisitTypeDecl(D);\n  D->TypenameLocation = readSourceLocation();\n  D->QualifierLoc = Record.readNestedNameSpecifierLoc();\n  D->EllipsisLoc = readSourceLocation();\n  mergeMergeable(D);\n}\n\nvoid ASTDeclReader::ReadCXXDefinitionData(\n    struct CXXRecordDecl::DefinitionData &Data, const CXXRecordDecl *D) {\n  #define FIELD(Name, Width, Merge) \\\n  Data.Name = Record.readInt();\n  #include \"clang/AST/CXXRecordDeclDefinitionBits.def\"\n\n  // Note: the caller has deserialized the IsLambda bit already.\n  Data.ODRHash = Record.readInt();\n  Data.HasODRHash = true;\n\n  if (Record.readInt()) {\n    Reader.DefinitionSource[D] = \n        Loc.F->Kind == ModuleKind::MK_MainFile ||\n        Reader.getContext().getLangOpts().BuildingPCHWithObjectFile;\n  }\n\n  Data.NumBases = Record.readInt();\n  if (Data.NumBases)\n    Data.Bases = ReadGlobalOffset();\n  Data.NumVBases = Record.readInt();\n  if (Data.NumVBases)\n    Data.VBases = ReadGlobalOffset();\n\n  Record.readUnresolvedSet(Data.Conversions);\n  Data.ComputedVisibleConversions = Record.readInt();\n  if (Data.ComputedVisibleConversions)\n    Record.readUnresolvedSet(Data.VisibleConversions);\n  assert(Data.Definition && \"Data.Definition should be already set!\");\n  Data.FirstFriend = readDeclID();\n\n  if (Data.IsLambda) {\n    using Capture = LambdaCapture;\n\n    auto &Lambda = static_cast<CXXRecordDecl::LambdaDefinitionData &>(Data);\n    Lambda.Dependent = Record.readInt();\n    Lambda.IsGenericLambda = Record.readInt();\n    Lambda.CaptureDefault = Record.readInt();\n    Lambda.NumCaptures = Record.readInt();\n    Lambda.NumExplicitCaptures = Record.readInt();\n    Lambda.HasKnownInternalLinkage = Record.readInt();\n    Lambda.ManglingNumber = Record.readInt();\n    D->setDeviceLambdaManglingNumber(Record.readInt());\n    Lambda.ContextDecl = readDeclID();\n    Lambda.Captures = (Capture *)Reader.getContext().Allocate(\n        sizeof(Capture) * Lambda.NumCaptures);\n    Capture *ToCapture = Lambda.Captures;\n    Lambda.MethodTyInfo = readTypeSourceInfo();\n    for (unsigned I = 0, N = Lambda.NumCaptures; I != N; ++I) {\n      SourceLocation Loc = readSourceLocation();\n      bool IsImplicit = Record.readInt();\n      auto Kind = static_cast<LambdaCaptureKind>(Record.readInt());\n      switch (Kind) {\n      case LCK_StarThis:\n      case LCK_This:\n      case LCK_VLAType:\n        *ToCapture++ = Capture(Loc, IsImplicit, Kind, nullptr,SourceLocation());\n        break;\n      case LCK_ByCopy:\n      case LCK_ByRef:\n        auto *Var = readDeclAs<VarDecl>();\n        SourceLocation EllipsisLoc = readSourceLocation();\n        *ToCapture++ = Capture(Loc, IsImplicit, Kind, Var, EllipsisLoc);\n        break;\n      }\n    }\n  }\n}\n\nvoid ASTDeclReader::MergeDefinitionData(\n    CXXRecordDecl *D, struct CXXRecordDecl::DefinitionData &&MergeDD) {\n  assert(D->DefinitionData &&\n         \"merging class definition into non-definition\");\n  auto &DD = *D->DefinitionData;\n\n  if (DD.Definition != MergeDD.Definition) {\n    // Track that we merged the definitions.\n    Reader.MergedDeclContexts.insert(std::make_pair(MergeDD.Definition,\n                                                    DD.Definition));\n    Reader.PendingDefinitions.erase(MergeDD.Definition);\n    MergeDD.Definition->setCompleteDefinition(false);\n    Reader.mergeDefinitionVisibility(DD.Definition, MergeDD.Definition);\n    assert(Reader.Lookups.find(MergeDD.Definition) == Reader.Lookups.end() &&\n           \"already loaded pending lookups for merged definition\");\n  }\n\n  auto PFDI = Reader.PendingFakeDefinitionData.find(&DD);\n  if (PFDI != Reader.PendingFakeDefinitionData.end() &&\n      PFDI->second == ASTReader::PendingFakeDefinitionKind::Fake) {\n    // We faked up this definition data because we found a class for which we'd\n    // not yet loaded the definition. Replace it with the real thing now.\n    assert(!DD.IsLambda && !MergeDD.IsLambda && \"faked up lambda definition?\");\n    PFDI->second = ASTReader::PendingFakeDefinitionKind::FakeLoaded;\n\n    // Don't change which declaration is the definition; that is required\n    // to be invariant once we select it.\n    auto *Def = DD.Definition;\n    DD = std::move(MergeDD);\n    DD.Definition = Def;\n    return;\n  }\n\n  bool DetectedOdrViolation = false;\n\n  #define FIELD(Name, Width, Merge) Merge(Name)\n  #define MERGE_OR(Field) DD.Field |= MergeDD.Field;\n  #define NO_MERGE(Field) \\\n    DetectedOdrViolation |= DD.Field != MergeDD.Field; \\\n    MERGE_OR(Field)\n  #include \"clang/AST/CXXRecordDeclDefinitionBits.def\"\n  NO_MERGE(IsLambda)\n  #undef NO_MERGE\n  #undef MERGE_OR\n\n  if (DD.NumBases != MergeDD.NumBases || DD.NumVBases != MergeDD.NumVBases)\n    DetectedOdrViolation = true;\n  // FIXME: Issue a diagnostic if the base classes don't match when we come\n  // to lazily load them.\n\n  // FIXME: Issue a diagnostic if the list of conversion functions doesn't\n  // match when we come to lazily load them.\n  if (MergeDD.ComputedVisibleConversions && !DD.ComputedVisibleConversions) {\n    DD.VisibleConversions = std::move(MergeDD.VisibleConversions);\n    DD.ComputedVisibleConversions = true;\n  }\n\n  // FIXME: Issue a diagnostic if FirstFriend doesn't match when we come to\n  // lazily load it.\n\n  if (DD.IsLambda) {\n    // FIXME: ODR-checking for merging lambdas (this happens, for instance,\n    // when they occur within the body of a function template specialization).\n  }\n\n  if (D->getODRHash() != MergeDD.ODRHash) {\n    DetectedOdrViolation = true;\n  }\n\n  if (DetectedOdrViolation)\n    Reader.PendingOdrMergeFailures[DD.Definition].push_back(\n        {MergeDD.Definition, &MergeDD});\n}\n\nvoid ASTDeclReader::ReadCXXRecordDefinition(CXXRecordDecl *D, bool Update) {\n  struct CXXRecordDecl::DefinitionData *DD;\n  ASTContext &C = Reader.getContext();\n\n  // Determine whether this is a lambda closure type, so that we can\n  // allocate the appropriate DefinitionData structure.\n  bool IsLambda = Record.readInt();\n  if (IsLambda)\n    DD = new (C) CXXRecordDecl::LambdaDefinitionData(D, nullptr, false, false,\n                                                     LCD_None);\n  else\n    DD = new (C) struct CXXRecordDecl::DefinitionData(D);\n\n  CXXRecordDecl *Canon = D->getCanonicalDecl();\n  // Set decl definition data before reading it, so that during deserialization\n  // when we read CXXRecordDecl, it already has definition data and we don't\n  // set fake one.\n  if (!Canon->DefinitionData)\n    Canon->DefinitionData = DD;\n  D->DefinitionData = Canon->DefinitionData;\n  ReadCXXDefinitionData(*DD, D);\n\n  // We might already have a different definition for this record. This can\n  // happen either because we're reading an update record, or because we've\n  // already done some merging. Either way, just merge into it.\n  if (Canon->DefinitionData != DD) {\n    MergeDefinitionData(Canon, std::move(*DD));\n    return;\n  }\n\n  // Mark this declaration as being a definition.\n  D->setCompleteDefinition(true);\n\n  // If this is not the first declaration or is an update record, we can have\n  // other redeclarations already. Make a note that we need to propagate the\n  // DefinitionData pointer onto them.\n  if (Update || Canon != D)\n    Reader.PendingDefinitions.insert(D);\n}\n\nASTDeclReader::RedeclarableResult\nASTDeclReader::VisitCXXRecordDeclImpl(CXXRecordDecl *D) {\n  RedeclarableResult Redecl = VisitRecordDeclImpl(D);\n\n  ASTContext &C = Reader.getContext();\n\n  enum CXXRecKind {\n    CXXRecNotTemplate = 0, CXXRecTemplate, CXXRecMemberSpecialization\n  };\n  switch ((CXXRecKind)Record.readInt()) {\n  case CXXRecNotTemplate:\n    // Merged when we merge the folding set entry in the primary template.\n    if (!isa<ClassTemplateSpecializationDecl>(D))\n      mergeRedeclarable(D, Redecl);\n    break;\n  case CXXRecTemplate: {\n    // Merged when we merge the template.\n    auto *Template = readDeclAs<ClassTemplateDecl>();\n    D->TemplateOrInstantiation = Template;\n    if (!Template->getTemplatedDecl()) {\n      // We've not actually loaded the ClassTemplateDecl yet, because we're\n      // currently being loaded as its pattern. Rely on it to set up our\n      // TypeForDecl (see VisitClassTemplateDecl).\n      //\n      // Beware: we do not yet know our canonical declaration, and may still\n      // get merged once the surrounding class template has got off the ground.\n      DeferredTypeID = 0;\n    }\n    break;\n  }\n  case CXXRecMemberSpecialization: {\n    auto *RD = readDeclAs<CXXRecordDecl>();\n    auto TSK = (TemplateSpecializationKind)Record.readInt();\n    SourceLocation POI = readSourceLocation();\n    MemberSpecializationInfo *MSI = new (C) MemberSpecializationInfo(RD, TSK);\n    MSI->setPointOfInstantiation(POI);\n    D->TemplateOrInstantiation = MSI;\n    mergeRedeclarable(D, Redecl);\n    break;\n  }\n  }\n\n  bool WasDefinition = Record.readInt();\n  if (WasDefinition)\n    ReadCXXRecordDefinition(D, /*Update*/false);\n  else\n    // Propagate DefinitionData pointer from the canonical declaration.\n    D->DefinitionData = D->getCanonicalDecl()->DefinitionData;\n\n  // Lazily load the key function to avoid deserializing every method so we can\n  // compute it.\n  if (WasDefinition) {\n    DeclID KeyFn = readDeclID();\n    if (KeyFn && D->isCompleteDefinition())\n      // FIXME: This is wrong for the ARM ABI, where some other module may have\n      // made this function no longer be a key function. We need an update\n      // record or similar for that case.\n      C.KeyFunctions[D] = KeyFn;\n  }\n\n  return Redecl;\n}\n\nvoid ASTDeclReader::VisitCXXDeductionGuideDecl(CXXDeductionGuideDecl *D) {\n  D->setExplicitSpecifier(Record.readExplicitSpec());\n  VisitFunctionDecl(D);\n  D->setIsCopyDeductionCandidate(Record.readInt());\n}\n\nvoid ASTDeclReader::VisitCXXMethodDecl(CXXMethodDecl *D) {\n  VisitFunctionDecl(D);\n\n  unsigned NumOverridenMethods = Record.readInt();\n  if (D->isCanonicalDecl()) {\n    while (NumOverridenMethods--) {\n      // Avoid invariant checking of CXXMethodDecl::addOverriddenMethod,\n      // MD may be initializing.\n      if (auto *MD = readDeclAs<CXXMethodDecl>())\n        Reader.getContext().addOverriddenMethod(D, MD->getCanonicalDecl());\n    }\n  } else {\n    // We don't care about which declarations this used to override; we get\n    // the relevant information from the canonical declaration.\n    Record.skipInts(NumOverridenMethods);\n  }\n}\n\nvoid ASTDeclReader::VisitCXXConstructorDecl(CXXConstructorDecl *D) {\n  // We need the inherited constructor information to merge the declaration,\n  // so we have to read it before we call VisitCXXMethodDecl.\n  D->setExplicitSpecifier(Record.readExplicitSpec());\n  if (D->isInheritingConstructor()) {\n    auto *Shadow = readDeclAs<ConstructorUsingShadowDecl>();\n    auto *Ctor = readDeclAs<CXXConstructorDecl>();\n    *D->getTrailingObjects<InheritedConstructor>() =\n        InheritedConstructor(Shadow, Ctor);\n  }\n\n  VisitCXXMethodDecl(D);\n}\n\nvoid ASTDeclReader::VisitCXXDestructorDecl(CXXDestructorDecl *D) {\n  VisitCXXMethodDecl(D);\n\n  if (auto *OperatorDelete = readDeclAs<FunctionDecl>()) {\n    CXXDestructorDecl *Canon = D->getCanonicalDecl();\n    auto *ThisArg = Record.readExpr();\n    // FIXME: Check consistency if we have an old and new operator delete.\n    if (!Canon->OperatorDelete) {\n      Canon->OperatorDelete = OperatorDelete;\n      Canon->OperatorDeleteThisArg = ThisArg;\n    }\n  }\n}\n\nvoid ASTDeclReader::VisitCXXConversionDecl(CXXConversionDecl *D) {\n  D->setExplicitSpecifier(Record.readExplicitSpec());\n  VisitCXXMethodDecl(D);\n}\n\nvoid ASTDeclReader::VisitImportDecl(ImportDecl *D) {\n  VisitDecl(D);\n  D->ImportedModule = readModule();\n  D->setImportComplete(Record.readInt());\n  auto *StoredLocs = D->getTrailingObjects<SourceLocation>();\n  for (unsigned I = 0, N = Record.back(); I != N; ++I)\n    StoredLocs[I] = readSourceLocation();\n  Record.skipInts(1); // The number of stored source locations.\n}\n\nvoid ASTDeclReader::VisitAccessSpecDecl(AccessSpecDecl *D) {\n  VisitDecl(D);\n  D->setColonLoc(readSourceLocation());\n}\n\nvoid ASTDeclReader::VisitFriendDecl(FriendDecl *D) {\n  VisitDecl(D);\n  if (Record.readInt()) // hasFriendDecl\n    D->Friend = readDeclAs<NamedDecl>();\n  else\n    D->Friend = readTypeSourceInfo();\n  for (unsigned i = 0; i != D->NumTPLists; ++i)\n    D->getTrailingObjects<TemplateParameterList *>()[i] =\n        Record.readTemplateParameterList();\n  D->NextFriend = readDeclID();\n  D->UnsupportedFriend = (Record.readInt() != 0);\n  D->FriendLoc = readSourceLocation();\n}\n\nvoid ASTDeclReader::VisitFriendTemplateDecl(FriendTemplateDecl *D) {\n  VisitDecl(D);\n  unsigned NumParams = Record.readInt();\n  D->NumParams = NumParams;\n  D->Params = new TemplateParameterList*[NumParams];\n  for (unsigned i = 0; i != NumParams; ++i)\n    D->Params[i] = Record.readTemplateParameterList();\n  if (Record.readInt()) // HasFriendDecl\n    D->Friend = readDeclAs<NamedDecl>();\n  else\n    D->Friend = readTypeSourceInfo();\n  D->FriendLoc = readSourceLocation();\n}\n\nDeclID ASTDeclReader::VisitTemplateDecl(TemplateDecl *D) {\n  VisitNamedDecl(D);\n\n  DeclID PatternID = readDeclID();\n  auto *TemplatedDecl = cast_or_null<NamedDecl>(Reader.GetDecl(PatternID));\n  TemplateParameterList *TemplateParams = Record.readTemplateParameterList();\n  D->init(TemplatedDecl, TemplateParams);\n\n  return PatternID;\n}\n\nvoid ASTDeclReader::VisitConceptDecl(ConceptDecl *D) {\n  VisitTemplateDecl(D);\n  D->ConstraintExpr = Record.readExpr();\n  mergeMergeable(D);\n}\n\nvoid ASTDeclReader::VisitRequiresExprBodyDecl(RequiresExprBodyDecl *D) {\n}\n\nASTDeclReader::RedeclarableResult\nASTDeclReader::VisitRedeclarableTemplateDecl(RedeclarableTemplateDecl *D) {\n  RedeclarableResult Redecl = VisitRedeclarable(D);\n\n  // Make sure we've allocated the Common pointer first. We do this before\n  // VisitTemplateDecl so that getCommonPtr() can be used during initialization.\n  RedeclarableTemplateDecl *CanonD = D->getCanonicalDecl();\n  if (!CanonD->Common) {\n    CanonD->Common = CanonD->newCommon(Reader.getContext());\n    Reader.PendingDefinitions.insert(CanonD);\n  }\n  D->Common = CanonD->Common;\n\n  // If this is the first declaration of the template, fill in the information\n  // for the 'common' pointer.\n  if (ThisDeclID == Redecl.getFirstID()) {\n    if (auto *RTD = readDeclAs<RedeclarableTemplateDecl>()) {\n      assert(RTD->getKind() == D->getKind() &&\n             \"InstantiatedFromMemberTemplate kind mismatch\");\n      D->setInstantiatedFromMemberTemplate(RTD);\n      if (Record.readInt())\n        D->setMemberSpecialization();\n    }\n  }\n\n  DeclID PatternID = VisitTemplateDecl(D);\n  D->IdentifierNamespace = Record.readInt();\n\n  mergeRedeclarable(D, Redecl, PatternID);\n\n  // If we merged the template with a prior declaration chain, merge the common\n  // pointer.\n  // FIXME: Actually merge here, don't just overwrite.\n  D->Common = D->getCanonicalDecl()->Common;\n\n  return Redecl;\n}\n\nvoid ASTDeclReader::VisitClassTemplateDecl(ClassTemplateDecl *D) {\n  RedeclarableResult Redecl = VisitRedeclarableTemplateDecl(D);\n\n  if (ThisDeclID == Redecl.getFirstID()) {\n    // This ClassTemplateDecl owns a CommonPtr; read it to keep track of all of\n    // the specializations.\n    SmallVector<serialization::DeclID, 32> SpecIDs;\n    readDeclIDList(SpecIDs);\n    ASTDeclReader::AddLazySpecializations(D, SpecIDs);\n  }\n\n  if (D->getTemplatedDecl()->TemplateOrInstantiation) {\n    // We were loaded before our templated declaration was. We've not set up\n    // its corresponding type yet (see VisitCXXRecordDeclImpl), so reconstruct\n    // it now.\n    Reader.getContext().getInjectedClassNameType(\n        D->getTemplatedDecl(), D->getInjectedClassNameSpecialization());\n  }\n}\n\nvoid ASTDeclReader::VisitBuiltinTemplateDecl(BuiltinTemplateDecl *D) {\n  llvm_unreachable(\"BuiltinTemplates are not serialized\");\n}\n\n/// TODO: Unify with ClassTemplateDecl version?\n///       May require unifying ClassTemplateDecl and\n///        VarTemplateDecl beyond TemplateDecl...\nvoid ASTDeclReader::VisitVarTemplateDecl(VarTemplateDecl *D) {\n  RedeclarableResult Redecl = VisitRedeclarableTemplateDecl(D);\n\n  if (ThisDeclID == Redecl.getFirstID()) {\n    // This VarTemplateDecl owns a CommonPtr; read it to keep track of all of\n    // the specializations.\n    SmallVector<serialization::DeclID, 32> SpecIDs;\n    readDeclIDList(SpecIDs);\n    ASTDeclReader::AddLazySpecializations(D, SpecIDs);\n  }\n}\n\nASTDeclReader::RedeclarableResult\nASTDeclReader::VisitClassTemplateSpecializationDeclImpl(\n    ClassTemplateSpecializationDecl *D) {\n  RedeclarableResult Redecl = VisitCXXRecordDeclImpl(D);\n\n  ASTContext &C = Reader.getContext();\n  if (Decl *InstD = readDecl()) {\n    if (auto *CTD = dyn_cast<ClassTemplateDecl>(InstD)) {\n      D->SpecializedTemplate = CTD;\n    } else {\n      SmallVector<TemplateArgument, 8> TemplArgs;\n      Record.readTemplateArgumentList(TemplArgs);\n      TemplateArgumentList *ArgList\n        = TemplateArgumentList::CreateCopy(C, TemplArgs);\n      auto *PS =\n          new (C) ClassTemplateSpecializationDecl::\n                                             SpecializedPartialSpecialization();\n      PS->PartialSpecialization\n          = cast<ClassTemplatePartialSpecializationDecl>(InstD);\n      PS->TemplateArgs = ArgList;\n      D->SpecializedTemplate = PS;\n    }\n  }\n\n  SmallVector<TemplateArgument, 8> TemplArgs;\n  Record.readTemplateArgumentList(TemplArgs, /*Canonicalize*/ true);\n  D->TemplateArgs = TemplateArgumentList::CreateCopy(C, TemplArgs);\n  D->PointOfInstantiation = readSourceLocation();\n  D->SpecializationKind = (TemplateSpecializationKind)Record.readInt();\n\n  bool writtenAsCanonicalDecl = Record.readInt();\n  if (writtenAsCanonicalDecl) {\n    auto *CanonPattern = readDeclAs<ClassTemplateDecl>();\n    if (D->isCanonicalDecl()) { // It's kept in the folding set.\n      // Set this as, or find, the canonical declaration for this specialization\n      ClassTemplateSpecializationDecl *CanonSpec;\n      if (auto *Partial = dyn_cast<ClassTemplatePartialSpecializationDecl>(D)) {\n        CanonSpec = CanonPattern->getCommonPtr()->PartialSpecializations\n            .GetOrInsertNode(Partial);\n      } else {\n        CanonSpec =\n            CanonPattern->getCommonPtr()->Specializations.GetOrInsertNode(D);\n      }\n      // If there was already a canonical specialization, merge into it.\n      if (CanonSpec != D) {\n        mergeRedeclarable<TagDecl>(D, CanonSpec, Redecl);\n\n        // This declaration might be a definition. Merge with any existing\n        // definition.\n        if (auto *DDD = D->DefinitionData) {\n          if (CanonSpec->DefinitionData)\n            MergeDefinitionData(CanonSpec, std::move(*DDD));\n          else\n            CanonSpec->DefinitionData = D->DefinitionData;\n        }\n        D->DefinitionData = CanonSpec->DefinitionData;\n      }\n    }\n  }\n\n  // Explicit info.\n  if (TypeSourceInfo *TyInfo = readTypeSourceInfo()) {\n    auto *ExplicitInfo =\n        new (C) ClassTemplateSpecializationDecl::ExplicitSpecializationInfo;\n    ExplicitInfo->TypeAsWritten = TyInfo;\n    ExplicitInfo->ExternLoc = readSourceLocation();\n    ExplicitInfo->TemplateKeywordLoc = readSourceLocation();\n    D->ExplicitInfo = ExplicitInfo;\n  }\n\n  return Redecl;\n}\n\nvoid ASTDeclReader::VisitClassTemplatePartialSpecializationDecl(\n                                    ClassTemplatePartialSpecializationDecl *D) {\n  // We need to read the template params first because redeclarable is going to\n  // need them for profiling\n  TemplateParameterList *Params = Record.readTemplateParameterList();\n  D->TemplateParams = Params;\n  D->ArgsAsWritten = Record.readASTTemplateArgumentListInfo();\n\n  RedeclarableResult Redecl = VisitClassTemplateSpecializationDeclImpl(D);\n\n  // These are read/set from/to the first declaration.\n  if (ThisDeclID == Redecl.getFirstID()) {\n    D->InstantiatedFromMember.setPointer(\n      readDeclAs<ClassTemplatePartialSpecializationDecl>());\n    D->InstantiatedFromMember.setInt(Record.readInt());\n  }\n}\n\nvoid ASTDeclReader::VisitClassScopeFunctionSpecializationDecl(\n                                    ClassScopeFunctionSpecializationDecl *D) {\n  VisitDecl(D);\n  D->Specialization = readDeclAs<CXXMethodDecl>();\n  if (Record.readInt())\n    D->TemplateArgs = Record.readASTTemplateArgumentListInfo();\n}\n\nvoid ASTDeclReader::VisitFunctionTemplateDecl(FunctionTemplateDecl *D) {\n  RedeclarableResult Redecl = VisitRedeclarableTemplateDecl(D);\n\n  if (ThisDeclID == Redecl.getFirstID()) {\n    // This FunctionTemplateDecl owns a CommonPtr; read it.\n    SmallVector<serialization::DeclID, 32> SpecIDs;\n    readDeclIDList(SpecIDs);\n    ASTDeclReader::AddLazySpecializations(D, SpecIDs);\n  }\n}\n\n/// TODO: Unify with ClassTemplateSpecializationDecl version?\n///       May require unifying ClassTemplate(Partial)SpecializationDecl and\n///        VarTemplate(Partial)SpecializationDecl with a new data\n///        structure Template(Partial)SpecializationDecl, and\n///        using Template(Partial)SpecializationDecl as input type.\nASTDeclReader::RedeclarableResult\nASTDeclReader::VisitVarTemplateSpecializationDeclImpl(\n    VarTemplateSpecializationDecl *D) {\n  RedeclarableResult Redecl = VisitVarDeclImpl(D);\n\n  ASTContext &C = Reader.getContext();\n  if (Decl *InstD = readDecl()) {\n    if (auto *VTD = dyn_cast<VarTemplateDecl>(InstD)) {\n      D->SpecializedTemplate = VTD;\n    } else {\n      SmallVector<TemplateArgument, 8> TemplArgs;\n      Record.readTemplateArgumentList(TemplArgs);\n      TemplateArgumentList *ArgList = TemplateArgumentList::CreateCopy(\n          C, TemplArgs);\n      auto *PS =\n          new (C)\n          VarTemplateSpecializationDecl::SpecializedPartialSpecialization();\n      PS->PartialSpecialization =\n          cast<VarTemplatePartialSpecializationDecl>(InstD);\n      PS->TemplateArgs = ArgList;\n      D->SpecializedTemplate = PS;\n    }\n  }\n\n  // Explicit info.\n  if (TypeSourceInfo *TyInfo = readTypeSourceInfo()) {\n    auto *ExplicitInfo =\n        new (C) VarTemplateSpecializationDecl::ExplicitSpecializationInfo;\n    ExplicitInfo->TypeAsWritten = TyInfo;\n    ExplicitInfo->ExternLoc = readSourceLocation();\n    ExplicitInfo->TemplateKeywordLoc = readSourceLocation();\n    D->ExplicitInfo = ExplicitInfo;\n  }\n\n  SmallVector<TemplateArgument, 8> TemplArgs;\n  Record.readTemplateArgumentList(TemplArgs, /*Canonicalize*/ true);\n  D->TemplateArgs = TemplateArgumentList::CreateCopy(C, TemplArgs);\n  D->PointOfInstantiation = readSourceLocation();\n  D->SpecializationKind = (TemplateSpecializationKind)Record.readInt();\n  D->IsCompleteDefinition = Record.readInt();\n\n  bool writtenAsCanonicalDecl = Record.readInt();\n  if (writtenAsCanonicalDecl) {\n    auto *CanonPattern = readDeclAs<VarTemplateDecl>();\n    if (D->isCanonicalDecl()) { // It's kept in the folding set.\n      // FIXME: If it's already present, merge it.\n      if (auto *Partial = dyn_cast<VarTemplatePartialSpecializationDecl>(D)) {\n        CanonPattern->getCommonPtr()->PartialSpecializations\n            .GetOrInsertNode(Partial);\n      } else {\n        CanonPattern->getCommonPtr()->Specializations.GetOrInsertNode(D);\n      }\n    }\n  }\n\n  return Redecl;\n}\n\n/// TODO: Unify with ClassTemplatePartialSpecializationDecl version?\n///       May require unifying ClassTemplate(Partial)SpecializationDecl and\n///        VarTemplate(Partial)SpecializationDecl with a new data\n///        structure Template(Partial)SpecializationDecl, and\n///        using Template(Partial)SpecializationDecl as input type.\nvoid ASTDeclReader::VisitVarTemplatePartialSpecializationDecl(\n    VarTemplatePartialSpecializationDecl *D) {\n  TemplateParameterList *Params = Record.readTemplateParameterList();\n  D->TemplateParams = Params;\n  D->ArgsAsWritten = Record.readASTTemplateArgumentListInfo();\n\n  RedeclarableResult Redecl = VisitVarTemplateSpecializationDeclImpl(D);\n\n  // These are read/set from/to the first declaration.\n  if (ThisDeclID == Redecl.getFirstID()) {\n    D->InstantiatedFromMember.setPointer(\n        readDeclAs<VarTemplatePartialSpecializationDecl>());\n    D->InstantiatedFromMember.setInt(Record.readInt());\n  }\n}\n\nvoid ASTDeclReader::VisitTemplateTypeParmDecl(TemplateTypeParmDecl *D) {\n  VisitTypeDecl(D);\n\n  D->setDeclaredWithTypename(Record.readInt());\n\n  if (Record.readBool()) {\n    NestedNameSpecifierLoc NNS = Record.readNestedNameSpecifierLoc();\n    DeclarationNameInfo DN = Record.readDeclarationNameInfo();\n    ConceptDecl *NamedConcept = Record.readDeclAs<ConceptDecl>();\n    const ASTTemplateArgumentListInfo *ArgsAsWritten = nullptr;\n    if (Record.readBool())\n        ArgsAsWritten = Record.readASTTemplateArgumentListInfo();\n    Expr *ImmediatelyDeclaredConstraint = Record.readExpr();\n    D->setTypeConstraint(NNS, DN, /*FoundDecl=*/nullptr, NamedConcept,\n                         ArgsAsWritten, ImmediatelyDeclaredConstraint);\n    if ((D->ExpandedParameterPack = Record.readInt()))\n      D->NumExpanded = Record.readInt();\n  }\n\n  if (Record.readInt())\n    D->setDefaultArgument(readTypeSourceInfo());\n}\n\nvoid ASTDeclReader::VisitNonTypeTemplateParmDecl(NonTypeTemplateParmDecl *D) {\n  VisitDeclaratorDecl(D);\n  // TemplateParmPosition.\n  D->setDepth(Record.readInt());\n  D->setPosition(Record.readInt());\n  if (D->hasPlaceholderTypeConstraint())\n    D->setPlaceholderTypeConstraint(Record.readExpr());\n  if (D->isExpandedParameterPack()) {\n    auto TypesAndInfos =\n        D->getTrailingObjects<std::pair<QualType, TypeSourceInfo *>>();\n    for (unsigned I = 0, N = D->getNumExpansionTypes(); I != N; ++I) {\n      new (&TypesAndInfos[I].first) QualType(Record.readType());\n      TypesAndInfos[I].second = readTypeSourceInfo();\n    }\n  } else {\n    // Rest of NonTypeTemplateParmDecl.\n    D->ParameterPack = Record.readInt();\n    if (Record.readInt())\n      D->setDefaultArgument(Record.readExpr());\n  }\n}\n\nvoid ASTDeclReader::VisitTemplateTemplateParmDecl(TemplateTemplateParmDecl *D) {\n  VisitTemplateDecl(D);\n  // TemplateParmPosition.\n  D->setDepth(Record.readInt());\n  D->setPosition(Record.readInt());\n  if (D->isExpandedParameterPack()) {\n    auto **Data = D->getTrailingObjects<TemplateParameterList *>();\n    for (unsigned I = 0, N = D->getNumExpansionTemplateParameters();\n         I != N; ++I)\n      Data[I] = Record.readTemplateParameterList();\n  } else {\n    // Rest of TemplateTemplateParmDecl.\n    D->ParameterPack = Record.readInt();\n    if (Record.readInt())\n      D->setDefaultArgument(Reader.getContext(),\n                            Record.readTemplateArgumentLoc());\n  }\n}\n\nvoid ASTDeclReader::VisitTypeAliasTemplateDecl(TypeAliasTemplateDecl *D) {\n  VisitRedeclarableTemplateDecl(D);\n}\n\nvoid ASTDeclReader::VisitStaticAssertDecl(StaticAssertDecl *D) {\n  VisitDecl(D);\n  D->AssertExprAndFailed.setPointer(Record.readExpr());\n  D->AssertExprAndFailed.setInt(Record.readInt());\n  D->Message = cast_or_null<StringLiteral>(Record.readExpr());\n  D->RParenLoc = readSourceLocation();\n}\n\nvoid ASTDeclReader::VisitEmptyDecl(EmptyDecl *D) {\n  VisitDecl(D);\n}\n\nvoid ASTDeclReader::VisitLifetimeExtendedTemporaryDecl(\n    LifetimeExtendedTemporaryDecl *D) {\n  VisitDecl(D);\n  D->ExtendingDecl = readDeclAs<ValueDecl>();\n  D->ExprWithTemporary = Record.readStmt();\n  if (Record.readInt()) {\n    D->Value = new (D->getASTContext()) APValue(Record.readAPValue());\n    D->getASTContext().addDestruction(D->Value);\n  }\n  D->ManglingNumber = Record.readInt();\n  mergeMergeable(D);\n}\n\nstd::pair<uint64_t, uint64_t>\nASTDeclReader::VisitDeclContext(DeclContext *DC) {\n  uint64_t LexicalOffset = ReadLocalOffset();\n  uint64_t VisibleOffset = ReadLocalOffset();\n  return std::make_pair(LexicalOffset, VisibleOffset);\n}\n\ntemplate <typename T>\nASTDeclReader::RedeclarableResult\nASTDeclReader::VisitRedeclarable(Redeclarable<T> *D) {\n  DeclID FirstDeclID = readDeclID();\n  Decl *MergeWith = nullptr;\n\n  bool IsKeyDecl = ThisDeclID == FirstDeclID;\n  bool IsFirstLocalDecl = false;\n\n  uint64_t RedeclOffset = 0;\n\n  // 0 indicates that this declaration was the only declaration of its entity,\n  // and is used for space optimization.\n  if (FirstDeclID == 0) {\n    FirstDeclID = ThisDeclID;\n    IsKeyDecl = true;\n    IsFirstLocalDecl = true;\n  } else if (unsigned N = Record.readInt()) {\n    // This declaration was the first local declaration, but may have imported\n    // other declarations.\n    IsKeyDecl = N == 1;\n    IsFirstLocalDecl = true;\n\n    // We have some declarations that must be before us in our redeclaration\n    // chain. Read them now, and remember that we ought to merge with one of\n    // them.\n    // FIXME: Provide a known merge target to the second and subsequent such\n    // declaration.\n    for (unsigned I = 0; I != N - 1; ++I)\n      MergeWith = readDecl();\n\n    RedeclOffset = ReadLocalOffset();\n  } else {\n    // This declaration was not the first local declaration. Read the first\n    // local declaration now, to trigger the import of other redeclarations.\n    (void)readDecl();\n  }\n\n  auto *FirstDecl = cast_or_null<T>(Reader.GetDecl(FirstDeclID));\n  if (FirstDecl != D) {\n    // We delay loading of the redeclaration chain to avoid deeply nested calls.\n    // We temporarily set the first (canonical) declaration as the previous one\n    // which is the one that matters and mark the real previous DeclID to be\n    // loaded & attached later on.\n    D->RedeclLink = Redeclarable<T>::PreviousDeclLink(FirstDecl);\n    D->First = FirstDecl->getCanonicalDecl();\n  }\n\n  auto *DAsT = static_cast<T *>(D);\n\n  // Note that we need to load local redeclarations of this decl and build a\n  // decl chain for them. This must happen *after* we perform the preloading\n  // above; this ensures that the redeclaration chain is built in the correct\n  // order.\n  if (IsFirstLocalDecl)\n    Reader.PendingDeclChains.push_back(std::make_pair(DAsT, RedeclOffset));\n\n  return RedeclarableResult(MergeWith, FirstDeclID, IsKeyDecl);\n}\n\n/// Attempts to merge the given declaration (D) with another declaration\n/// of the same entity.\ntemplate<typename T>\nvoid ASTDeclReader::mergeRedeclarable(Redeclarable<T> *DBase,\n                                      RedeclarableResult &Redecl,\n                                      DeclID TemplatePatternID) {\n  // If modules are not available, there is no reason to perform this merge.\n  if (!Reader.getContext().getLangOpts().Modules)\n    return;\n\n  // If we're not the canonical declaration, we don't need to merge.\n  if (!DBase->isFirstDecl())\n    return;\n\n  auto *D = static_cast<T *>(DBase);\n\n  if (auto *Existing = Redecl.getKnownMergeTarget())\n    // We already know of an existing declaration we should merge with.\n    mergeRedeclarable(D, cast<T>(Existing), Redecl, TemplatePatternID);\n  else if (FindExistingResult ExistingRes = findExisting(D))\n    if (T *Existing = ExistingRes)\n      mergeRedeclarable(D, Existing, Redecl, TemplatePatternID);\n}\n\n/// \"Cast\" to type T, asserting if we don't have an implicit conversion.\n/// We use this to put code in a template that will only be valid for certain\n/// instantiations.\ntemplate<typename T> static T assert_cast(T t) { return t; }\ntemplate<typename T> static T assert_cast(...) {\n  llvm_unreachable(\"bad assert_cast\");\n}\n\n/// Merge together the pattern declarations from two template\n/// declarations.\nvoid ASTDeclReader::mergeTemplatePattern(RedeclarableTemplateDecl *D,\n                                         RedeclarableTemplateDecl *Existing,\n                                         DeclID DsID, bool IsKeyDecl) {\n  auto *DPattern = D->getTemplatedDecl();\n  auto *ExistingPattern = Existing->getTemplatedDecl();\n  RedeclarableResult Result(/*MergeWith*/ ExistingPattern,\n                            DPattern->getCanonicalDecl()->getGlobalID(),\n                            IsKeyDecl);\n\n  if (auto *DClass = dyn_cast<CXXRecordDecl>(DPattern)) {\n    // Merge with any existing definition.\n    // FIXME: This is duplicated in several places. Refactor.\n    auto *ExistingClass =\n        cast<CXXRecordDecl>(ExistingPattern)->getCanonicalDecl();\n    if (auto *DDD = DClass->DefinitionData) {\n      if (ExistingClass->DefinitionData) {\n        MergeDefinitionData(ExistingClass, std::move(*DDD));\n      } else {\n        ExistingClass->DefinitionData = DClass->DefinitionData;\n        // We may have skipped this before because we thought that DClass\n        // was the canonical declaration.\n        Reader.PendingDefinitions.insert(DClass);\n      }\n    }\n    DClass->DefinitionData = ExistingClass->DefinitionData;\n\n    return mergeRedeclarable(DClass, cast<TagDecl>(ExistingPattern),\n                             Result);\n  }\n  if (auto *DFunction = dyn_cast<FunctionDecl>(DPattern))\n    return mergeRedeclarable(DFunction, cast<FunctionDecl>(ExistingPattern),\n                             Result);\n  if (auto *DVar = dyn_cast<VarDecl>(DPattern))\n    return mergeRedeclarable(DVar, cast<VarDecl>(ExistingPattern), Result);\n  if (auto *DAlias = dyn_cast<TypeAliasDecl>(DPattern))\n    return mergeRedeclarable(DAlias, cast<TypedefNameDecl>(ExistingPattern),\n                             Result);\n  llvm_unreachable(\"merged an unknown kind of redeclarable template\");\n}\n\n/// Attempts to merge the given declaration (D) with another declaration\n/// of the same entity.\ntemplate<typename T>\nvoid ASTDeclReader::mergeRedeclarable(Redeclarable<T> *DBase, T *Existing,\n                                      RedeclarableResult &Redecl,\n                                      DeclID TemplatePatternID) {\n  auto *D = static_cast<T *>(DBase);\n  T *ExistingCanon = Existing->getCanonicalDecl();\n  T *DCanon = D->getCanonicalDecl();\n  if (ExistingCanon != DCanon) {\n    assert(DCanon->getGlobalID() == Redecl.getFirstID() &&\n           \"already merged this declaration\");\n\n    // Have our redeclaration link point back at the canonical declaration\n    // of the existing declaration, so that this declaration has the\n    // appropriate canonical declaration.\n    D->RedeclLink = Redeclarable<T>::PreviousDeclLink(ExistingCanon);\n    D->First = ExistingCanon;\n    ExistingCanon->Used |= D->Used;\n    D->Used = false;\n\n    // When we merge a namespace, update its pointer to the first namespace.\n    // We cannot have loaded any redeclarations of this declaration yet, so\n    // there's nothing else that needs to be updated.\n    if (auto *Namespace = dyn_cast<NamespaceDecl>(D))\n      Namespace->AnonOrFirstNamespaceAndInline.setPointer(\n          assert_cast<NamespaceDecl*>(ExistingCanon));\n\n    // When we merge a template, merge its pattern.\n    if (auto *DTemplate = dyn_cast<RedeclarableTemplateDecl>(D))\n      mergeTemplatePattern(\n          DTemplate, assert_cast<RedeclarableTemplateDecl*>(ExistingCanon),\n          TemplatePatternID, Redecl.isKeyDecl());\n\n    // If this declaration is a key declaration, make a note of that.\n    if (Redecl.isKeyDecl())\n      Reader.KeyDecls[ExistingCanon].push_back(Redecl.getFirstID());\n  }\n}\n\n/// ODR-like semantics for C/ObjC allow us to merge tag types and a structural\n/// check in Sema guarantees the types can be merged (see C11 6.2.7/1 or C89\n/// 6.1.2.6/1). Although most merging is done in Sema, we need to guarantee\n/// that some types are mergeable during deserialization, otherwise name\n/// lookup fails. This is the case for EnumConstantDecl.\nstatic bool allowODRLikeMergeInC(NamedDecl *ND) {\n  if (!ND)\n    return false;\n  // TODO: implement merge for other necessary decls.\n  if (isa<EnumConstantDecl>(ND))\n    return true;\n  return false;\n}\n\n/// Attempts to merge LifetimeExtendedTemporaryDecl with\n/// identical class definitions from two different modules.\nvoid ASTDeclReader::mergeMergeable(LifetimeExtendedTemporaryDecl *D) {\n  // If modules are not available, there is no reason to perform this merge.\n  if (!Reader.getContext().getLangOpts().Modules)\n    return;\n\n  LifetimeExtendedTemporaryDecl *LETDecl = D;\n\n  LifetimeExtendedTemporaryDecl *&LookupResult =\n      Reader.LETemporaryForMerging[std::make_pair(\n          LETDecl->getExtendingDecl(), LETDecl->getManglingNumber())];\n  if (LookupResult)\n    Reader.getContext().setPrimaryMergedDecl(LETDecl,\n                                             LookupResult->getCanonicalDecl());\n  else\n    LookupResult = LETDecl;\n}\n\n/// Attempts to merge the given declaration (D) with another declaration\n/// of the same entity, for the case where the entity is not actually\n/// redeclarable. This happens, for instance, when merging the fields of\n/// identical class definitions from two different modules.\ntemplate<typename T>\nvoid ASTDeclReader::mergeMergeable(Mergeable<T> *D) {\n  // If modules are not available, there is no reason to perform this merge.\n  if (!Reader.getContext().getLangOpts().Modules)\n    return;\n\n  // ODR-based merging is performed in C++ and in some cases (tag types) in C.\n  // Note that C identically-named things in different translation units are\n  // not redeclarations, but may still have compatible types, where ODR-like\n  // semantics may apply.\n  if (!Reader.getContext().getLangOpts().CPlusPlus &&\n      !allowODRLikeMergeInC(dyn_cast<NamedDecl>(static_cast<T*>(D))))\n    return;\n\n  if (FindExistingResult ExistingRes = findExisting(static_cast<T*>(D)))\n    if (T *Existing = ExistingRes)\n      Reader.getContext().setPrimaryMergedDecl(static_cast<T *>(D),\n                                               Existing->getCanonicalDecl());\n}\n\nvoid ASTDeclReader::VisitOMPThreadPrivateDecl(OMPThreadPrivateDecl *D) {\n  Record.readOMPChildren(D->Data);\n  VisitDecl(D);\n}\n\nvoid ASTDeclReader::VisitOMPAllocateDecl(OMPAllocateDecl *D) {\n  Record.readOMPChildren(D->Data);\n  VisitDecl(D);\n}\n\nvoid ASTDeclReader::VisitOMPRequiresDecl(OMPRequiresDecl * D) {\n  Record.readOMPChildren(D->Data);\n  VisitDecl(D);\n}\n\nvoid ASTDeclReader::VisitOMPDeclareReductionDecl(OMPDeclareReductionDecl *D) {\n  VisitValueDecl(D);\n  D->setLocation(readSourceLocation());\n  Expr *In = Record.readExpr();\n  Expr *Out = Record.readExpr();\n  D->setCombinerData(In, Out);\n  Expr *Combiner = Record.readExpr();\n  D->setCombiner(Combiner);\n  Expr *Orig = Record.readExpr();\n  Expr *Priv = Record.readExpr();\n  D->setInitializerData(Orig, Priv);\n  Expr *Init = Record.readExpr();\n  auto IK = static_cast<OMPDeclareReductionDecl::InitKind>(Record.readInt());\n  D->setInitializer(Init, IK);\n  D->PrevDeclInScope = readDeclID();\n}\n\nvoid ASTDeclReader::VisitOMPDeclareMapperDecl(OMPDeclareMapperDecl *D) {\n  Record.readOMPChildren(D->Data);\n  VisitValueDecl(D);\n  D->VarName = Record.readDeclarationName();\n  D->PrevDeclInScope = readDeclID();\n}\n\nvoid ASTDeclReader::VisitOMPCapturedExprDecl(OMPCapturedExprDecl *D) {\n  VisitVarDecl(D);\n}\n\n//===----------------------------------------------------------------------===//\n// Attribute Reading\n//===----------------------------------------------------------------------===//\n\nnamespace {\nclass AttrReader {\n  ASTRecordReader &Reader;\n\npublic:\n  AttrReader(ASTRecordReader &Reader) : Reader(Reader) {}\n\n  uint64_t readInt() {\n    return Reader.readInt();\n  }\n\n  SourceRange readSourceRange() {\n    return Reader.readSourceRange();\n  }\n\n  SourceLocation readSourceLocation() {\n    return Reader.readSourceLocation();\n  }\n\n  Expr *readExpr() { return Reader.readExpr(); }\n\n  std::string readString() {\n    return Reader.readString();\n  }\n\n  TypeSourceInfo *readTypeSourceInfo() {\n    return Reader.readTypeSourceInfo();\n  }\n\n  IdentifierInfo *readIdentifier() {\n    return Reader.readIdentifier();\n  }\n\n  VersionTuple readVersionTuple() {\n    return Reader.readVersionTuple();\n  }\n\n  OMPTraitInfo *readOMPTraitInfo() { return Reader.readOMPTraitInfo(); }\n\n  template <typename T> T *GetLocalDeclAs(uint32_t LocalID) {\n    return Reader.GetLocalDeclAs<T>(LocalID);\n  }\n};\n}\n\nAttr *ASTRecordReader::readAttr() {\n  AttrReader Record(*this);\n  auto V = Record.readInt();\n  if (!V)\n    return nullptr;\n\n  Attr *New = nullptr;\n  // Kind is stored as a 1-based integer because 0 is used to indicate a null\n  // Attr pointer.\n  auto Kind = static_cast<attr::Kind>(V - 1);\n  ASTContext &Context = getContext();\n\n  IdentifierInfo *AttrName = Record.readIdentifier();\n  IdentifierInfo *ScopeName = Record.readIdentifier();\n  SourceRange AttrRange = Record.readSourceRange();\n  SourceLocation ScopeLoc = Record.readSourceLocation();\n  unsigned ParsedKind = Record.readInt();\n  unsigned Syntax = Record.readInt();\n  unsigned SpellingIndex = Record.readInt();\n\n  AttributeCommonInfo Info(AttrName, ScopeName, AttrRange, ScopeLoc,\n                           AttributeCommonInfo::Kind(ParsedKind),\n                           AttributeCommonInfo::Syntax(Syntax), SpellingIndex);\n\n#include \"clang/Serialization/AttrPCHRead.inc\"\n\n  assert(New && \"Unable to decode attribute?\");\n  return New;\n}\n\n/// Reads attributes from the current stream position.\nvoid ASTRecordReader::readAttributes(AttrVec &Attrs) {\n  for (unsigned I = 0, E = readInt(); I != E; ++I)\n    Attrs.push_back(readAttr());\n}\n\n//===----------------------------------------------------------------------===//\n// ASTReader Implementation\n//===----------------------------------------------------------------------===//\n\n/// Note that we have loaded the declaration with the given\n/// Index.\n///\n/// This routine notes that this declaration has already been loaded,\n/// so that future GetDecl calls will return this declaration rather\n/// than trying to load a new declaration.\ninline void ASTReader::LoadedDecl(unsigned Index, Decl *D) {\n  assert(!DeclsLoaded[Index] && \"Decl loaded twice?\");\n  DeclsLoaded[Index] = D;\n}\n\n/// Determine whether the consumer will be interested in seeing\n/// this declaration (via HandleTopLevelDecl).\n///\n/// This routine should return true for anything that might affect\n/// code generation, e.g., inline function definitions, Objective-C\n/// declarations with metadata, etc.\nstatic bool isConsumerInterestedIn(ASTContext &Ctx, Decl *D, bool HasBody) {\n  // An ObjCMethodDecl is never considered as \"interesting\" because its\n  // implementation container always is.\n\n  // An ImportDecl or VarDecl imported from a module map module will get\n  // emitted when we import the relevant module.\n  if (isPartOfPerModuleInitializer(D)) {\n    auto *M = D->getImportedOwningModule();\n    if (M && M->Kind == Module::ModuleMapModule &&\n        Ctx.DeclMustBeEmitted(D))\n      return false;\n  }\n\n  if (isa<FileScopeAsmDecl>(D) ||\n      isa<ObjCProtocolDecl>(D) ||\n      isa<ObjCImplDecl>(D) ||\n      isa<ImportDecl>(D) ||\n      isa<PragmaCommentDecl>(D) ||\n      isa<PragmaDetectMismatchDecl>(D))\n    return true;\n  if (isa<OMPThreadPrivateDecl>(D) || isa<OMPDeclareReductionDecl>(D) ||\n      isa<OMPDeclareMapperDecl>(D) || isa<OMPAllocateDecl>(D) ||\n      isa<OMPRequiresDecl>(D))\n    return !D->getDeclContext()->isFunctionOrMethod();\n  if (const auto *Var = dyn_cast<VarDecl>(D))\n    return Var->isFileVarDecl() &&\n           (Var->isThisDeclarationADefinition() == VarDecl::Definition ||\n            OMPDeclareTargetDeclAttr::isDeclareTargetDeclaration(Var));\n  if (const auto *Func = dyn_cast<FunctionDecl>(D))\n    return Func->doesThisDeclarationHaveABody() || HasBody;\n\n  if (auto *ES = D->getASTContext().getExternalSource())\n    if (ES->hasExternalDefinitions(D) == ExternalASTSource::EK_Never)\n      return true;\n\n  return false;\n}\n\n/// Get the correct cursor and offset for loading a declaration.\nASTReader::RecordLocation\nASTReader::DeclCursorForID(DeclID ID, SourceLocation &Loc) {\n  GlobalDeclMapType::iterator I = GlobalDeclMap.find(ID);\n  assert(I != GlobalDeclMap.end() && \"Corrupted global declaration map\");\n  ModuleFile *M = I->second;\n  const DeclOffset &DOffs =\n      M->DeclOffsets[ID - M->BaseDeclID - NUM_PREDEF_DECL_IDS];\n  Loc = TranslateSourceLocation(*M, DOffs.getLocation());\n  return RecordLocation(M, DOffs.getBitOffset(M->DeclsBlockStartOffset));\n}\n\nASTReader::RecordLocation ASTReader::getLocalBitOffset(uint64_t GlobalOffset) {\n  auto I = GlobalBitOffsetsMap.find(GlobalOffset);\n\n  assert(I != GlobalBitOffsetsMap.end() && \"Corrupted global bit offsets map\");\n  return RecordLocation(I->second, GlobalOffset - I->second->GlobalBitOffset);\n}\n\nuint64_t ASTReader::getGlobalBitOffset(ModuleFile &M, uint64_t LocalOffset) {\n  return LocalOffset + M.GlobalBitOffset;\n}\n\nstatic bool isSameTemplateParameterList(const ASTContext &C,\n                                        const TemplateParameterList *X,\n                                        const TemplateParameterList *Y);\n\n/// Determine whether two template parameters are similar enough\n/// that they may be used in declarations of the same template.\nstatic bool isSameTemplateParameter(const NamedDecl *X,\n                                    const NamedDecl *Y) {\n  if (X->getKind() != Y->getKind())\n    return false;\n\n  if (const auto *TX = dyn_cast<TemplateTypeParmDecl>(X)) {\n    const auto *TY = cast<TemplateTypeParmDecl>(Y);\n    if (TX->isParameterPack() != TY->isParameterPack())\n      return false;\n    if (TX->hasTypeConstraint() != TY->hasTypeConstraint())\n      return false;\n    const TypeConstraint *TXTC = TX->getTypeConstraint();\n    const TypeConstraint *TYTC = TY->getTypeConstraint();\n    if (!TXTC != !TYTC)\n      return false;\n    if (TXTC && TYTC) {\n      if (TXTC->getNamedConcept() != TYTC->getNamedConcept())\n        return false;\n      if (TXTC->hasExplicitTemplateArgs() != TYTC->hasExplicitTemplateArgs())\n        return false;\n      if (TXTC->hasExplicitTemplateArgs()) {\n        const auto *TXTCArgs = TXTC->getTemplateArgsAsWritten();\n        const auto *TYTCArgs = TYTC->getTemplateArgsAsWritten();\n        if (TXTCArgs->NumTemplateArgs != TYTCArgs->NumTemplateArgs)\n          return false;\n        llvm::FoldingSetNodeID XID, YID;\n        for (const auto &ArgLoc : TXTCArgs->arguments())\n          ArgLoc.getArgument().Profile(XID, X->getASTContext());\n        for (const auto &ArgLoc : TYTCArgs->arguments())\n          ArgLoc.getArgument().Profile(YID, Y->getASTContext());\n        if (XID != YID)\n          return false;\n      }\n    }\n    return true;\n  }\n\n  if (const auto *TX = dyn_cast<NonTypeTemplateParmDecl>(X)) {\n    const auto *TY = cast<NonTypeTemplateParmDecl>(Y);\n    return TX->isParameterPack() == TY->isParameterPack() &&\n           TX->getASTContext().hasSameType(TX->getType(), TY->getType());\n  }\n\n  const auto *TX = cast<TemplateTemplateParmDecl>(X);\n  const auto *TY = cast<TemplateTemplateParmDecl>(Y);\n  return TX->isParameterPack() == TY->isParameterPack() &&\n         isSameTemplateParameterList(TX->getASTContext(),\n                                     TX->getTemplateParameters(),\n                                     TY->getTemplateParameters());\n}\n\nstatic NamespaceDecl *getNamespace(const NestedNameSpecifier *X) {\n  if (auto *NS = X->getAsNamespace())\n    return NS;\n  if (auto *NAS = X->getAsNamespaceAlias())\n    return NAS->getNamespace();\n  return nullptr;\n}\n\nstatic bool isSameQualifier(const NestedNameSpecifier *X,\n                            const NestedNameSpecifier *Y) {\n  if (auto *NSX = getNamespace(X)) {\n    auto *NSY = getNamespace(Y);\n    if (!NSY || NSX->getCanonicalDecl() != NSY->getCanonicalDecl())\n      return false;\n  } else if (X->getKind() != Y->getKind())\n    return false;\n\n  // FIXME: For namespaces and types, we're permitted to check that the entity\n  // is named via the same tokens. We should probably do so.\n  switch (X->getKind()) {\n  case NestedNameSpecifier::Identifier:\n    if (X->getAsIdentifier() != Y->getAsIdentifier())\n      return false;\n    break;\n  case NestedNameSpecifier::Namespace:\n  case NestedNameSpecifier::NamespaceAlias:\n    // We've already checked that we named the same namespace.\n    break;\n  case NestedNameSpecifier::TypeSpec:\n  case NestedNameSpecifier::TypeSpecWithTemplate:\n    if (X->getAsType()->getCanonicalTypeInternal() !=\n        Y->getAsType()->getCanonicalTypeInternal())\n      return false;\n    break;\n  case NestedNameSpecifier::Global:\n  case NestedNameSpecifier::Super:\n    return true;\n  }\n\n  // Recurse into earlier portion of NNS, if any.\n  auto *PX = X->getPrefix();\n  auto *PY = Y->getPrefix();\n  if (PX && PY)\n    return isSameQualifier(PX, PY);\n  return !PX && !PY;\n}\n\n/// Determine whether two template parameter lists are similar enough\n/// that they may be used in declarations of the same template.\nstatic bool isSameTemplateParameterList(const ASTContext &C,\n                                        const TemplateParameterList *X,\n                                        const TemplateParameterList *Y) {\n  if (X->size() != Y->size())\n    return false;\n\n  for (unsigned I = 0, N = X->size(); I != N; ++I)\n    if (!isSameTemplateParameter(X->getParam(I), Y->getParam(I)))\n      return false;\n\n  const Expr *XRC = X->getRequiresClause();\n  const Expr *YRC = Y->getRequiresClause();\n  if (!XRC != !YRC)\n    return false;\n  if (XRC) {\n    llvm::FoldingSetNodeID XRCID, YRCID;\n    XRC->Profile(XRCID, C, /*Canonical=*/true);\n    YRC->Profile(YRCID, C, /*Canonical=*/true);\n    if (XRCID != YRCID)\n      return false;\n  }\n\n  return true;\n}\n\n/// Determine whether the attributes we can overload on are identical for A and\n/// B. Will ignore any overloadable attrs represented in the type of A and B.\nstatic bool hasSameOverloadableAttrs(const FunctionDecl *A,\n                                     const FunctionDecl *B) {\n  // Note that pass_object_size attributes are represented in the function's\n  // ExtParameterInfo, so we don't need to check them here.\n\n  llvm::FoldingSetNodeID Cand1ID, Cand2ID;\n  auto AEnableIfAttrs = A->specific_attrs<EnableIfAttr>();\n  auto BEnableIfAttrs = B->specific_attrs<EnableIfAttr>();\n\n  for (auto Pair : zip_longest(AEnableIfAttrs, BEnableIfAttrs)) {\n    Optional<EnableIfAttr *> Cand1A = std::get<0>(Pair);\n    Optional<EnableIfAttr *> Cand2A = std::get<1>(Pair);\n\n    // Return false if the number of enable_if attributes is different.\n    if (!Cand1A || !Cand2A)\n      return false;\n\n    Cand1ID.clear();\n    Cand2ID.clear();\n\n    (*Cand1A)->getCond()->Profile(Cand1ID, A->getASTContext(), true);\n    (*Cand2A)->getCond()->Profile(Cand2ID, B->getASTContext(), true);\n\n    // Return false if any of the enable_if expressions of A and B are\n    // different.\n    if (Cand1ID != Cand2ID)\n      return false;\n  }\n  return true;\n}\n\n/// Determine whether the two declarations refer to the same entity.pr\nstatic bool isSameEntity(NamedDecl *X, NamedDecl *Y) {\n  assert(X->getDeclName() == Y->getDeclName() && \"Declaration name mismatch!\");\n\n  if (X == Y)\n    return true;\n\n  // Must be in the same context.\n  //\n  // Note that we can't use DeclContext::Equals here, because the DeclContexts\n  // could be two different declarations of the same function. (We will fix the\n  // semantic DC to refer to the primary definition after merging.)\n  if (!declaresSameEntity(cast<Decl>(X->getDeclContext()->getRedeclContext()),\n                          cast<Decl>(Y->getDeclContext()->getRedeclContext())))\n    return false;\n\n  // Two typedefs refer to the same entity if they have the same underlying\n  // type.\n  if (const auto *TypedefX = dyn_cast<TypedefNameDecl>(X))\n    if (const auto *TypedefY = dyn_cast<TypedefNameDecl>(Y))\n      return X->getASTContext().hasSameType(TypedefX->getUnderlyingType(),\n                                            TypedefY->getUnderlyingType());\n\n  // Must have the same kind.\n  if (X->getKind() != Y->getKind())\n    return false;\n\n  // Objective-C classes and protocols with the same name always match.\n  if (isa<ObjCInterfaceDecl>(X) || isa<ObjCProtocolDecl>(X))\n    return true;\n\n  if (isa<ClassTemplateSpecializationDecl>(X)) {\n    // No need to handle these here: we merge them when adding them to the\n    // template.\n    return false;\n  }\n\n  // Compatible tags match.\n  if (const auto *TagX = dyn_cast<TagDecl>(X)) {\n    const auto *TagY = cast<TagDecl>(Y);\n    return (TagX->getTagKind() == TagY->getTagKind()) ||\n      ((TagX->getTagKind() == TTK_Struct || TagX->getTagKind() == TTK_Class ||\n        TagX->getTagKind() == TTK_Interface) &&\n       (TagY->getTagKind() == TTK_Struct || TagY->getTagKind() == TTK_Class ||\n        TagY->getTagKind() == TTK_Interface));\n  }\n\n  // Functions with the same type and linkage match.\n  // FIXME: This needs to cope with merging of prototyped/non-prototyped\n  // functions, etc.\n  if (const auto *FuncX = dyn_cast<FunctionDecl>(X)) {\n    const auto *FuncY = cast<FunctionDecl>(Y);\n    if (const auto *CtorX = dyn_cast<CXXConstructorDecl>(X)) {\n      const auto *CtorY = cast<CXXConstructorDecl>(Y);\n      if (CtorX->getInheritedConstructor() &&\n          !isSameEntity(CtorX->getInheritedConstructor().getConstructor(),\n                        CtorY->getInheritedConstructor().getConstructor()))\n        return false;\n    }\n\n    if (FuncX->isMultiVersion() != FuncY->isMultiVersion())\n      return false;\n\n    // Multiversioned functions with different feature strings are represented\n    // as separate declarations.\n    if (FuncX->isMultiVersion()) {\n      const auto *TAX = FuncX->getAttr<TargetAttr>();\n      const auto *TAY = FuncY->getAttr<TargetAttr>();\n      assert(TAX && TAY && \"Multiversion Function without target attribute\");\n\n      if (TAX->getFeaturesStr() != TAY->getFeaturesStr())\n        return false;\n    }\n\n    ASTContext &C = FuncX->getASTContext();\n\n    const Expr *XRC = FuncX->getTrailingRequiresClause();\n    const Expr *YRC = FuncY->getTrailingRequiresClause();\n    if (!XRC != !YRC)\n      return false;\n    if (XRC) {\n      llvm::FoldingSetNodeID XRCID, YRCID;\n      XRC->Profile(XRCID, C, /*Canonical=*/true);\n      YRC->Profile(YRCID, C, /*Canonical=*/true);\n      if (XRCID != YRCID)\n        return false;\n    }\n\n    auto GetTypeAsWritten = [](const FunctionDecl *FD) {\n      // Map to the first declaration that we've already merged into this one.\n      // The TSI of redeclarations might not match (due to calling conventions\n      // being inherited onto the type but not the TSI), but the TSI type of\n      // the first declaration of the function should match across modules.\n      FD = FD->getCanonicalDecl();\n      return FD->getTypeSourceInfo() ? FD->getTypeSourceInfo()->getType()\n                                     : FD->getType();\n    };\n    QualType XT = GetTypeAsWritten(FuncX), YT = GetTypeAsWritten(FuncY);\n    if (!C.hasSameType(XT, YT)) {\n      // We can get functions with different types on the redecl chain in C++17\n      // if they have differing exception specifications and at least one of\n      // the excpetion specs is unresolved.\n      auto *XFPT = XT->getAs<FunctionProtoType>();\n      auto *YFPT = YT->getAs<FunctionProtoType>();\n      if (C.getLangOpts().CPlusPlus17 && XFPT && YFPT &&\n          (isUnresolvedExceptionSpec(XFPT->getExceptionSpecType()) ||\n           isUnresolvedExceptionSpec(YFPT->getExceptionSpecType())) &&\n          C.hasSameFunctionTypeIgnoringExceptionSpec(XT, YT))\n        return true;\n      return false;\n    }\n\n    return FuncX->getLinkageInternal() == FuncY->getLinkageInternal() &&\n           hasSameOverloadableAttrs(FuncX, FuncY);\n  }\n\n  // Variables with the same type and linkage match.\n  if (const auto *VarX = dyn_cast<VarDecl>(X)) {\n    const auto *VarY = cast<VarDecl>(Y);\n    if (VarX->getLinkageInternal() == VarY->getLinkageInternal()) {\n      ASTContext &C = VarX->getASTContext();\n      if (C.hasSameType(VarX->getType(), VarY->getType()))\n        return true;\n\n      // We can get decls with different types on the redecl chain. Eg.\n      // template <typename T> struct S { static T Var[]; }; // #1\n      // template <typename T> T S<T>::Var[sizeof(T)]; // #2\n      // Only? happens when completing an incomplete array type. In this case\n      // when comparing #1 and #2 we should go through their element type.\n      const ArrayType *VarXTy = C.getAsArrayType(VarX->getType());\n      const ArrayType *VarYTy = C.getAsArrayType(VarY->getType());\n      if (!VarXTy || !VarYTy)\n        return false;\n      if (VarXTy->isIncompleteArrayType() || VarYTy->isIncompleteArrayType())\n        return C.hasSameType(VarXTy->getElementType(), VarYTy->getElementType());\n    }\n    return false;\n  }\n\n  // Namespaces with the same name and inlinedness match.\n  if (const auto *NamespaceX = dyn_cast<NamespaceDecl>(X)) {\n    const auto *NamespaceY = cast<NamespaceDecl>(Y);\n    return NamespaceX->isInline() == NamespaceY->isInline();\n  }\n\n  // Identical template names and kinds match if their template parameter lists\n  // and patterns match.\n  if (const auto *TemplateX = dyn_cast<TemplateDecl>(X)) {\n    const auto *TemplateY = cast<TemplateDecl>(Y);\n    return isSameEntity(TemplateX->getTemplatedDecl(),\n                        TemplateY->getTemplatedDecl()) &&\n           isSameTemplateParameterList(TemplateX->getASTContext(),\n                                       TemplateX->getTemplateParameters(),\n                                       TemplateY->getTemplateParameters());\n  }\n\n  // Fields with the same name and the same type match.\n  if (const auto *FDX = dyn_cast<FieldDecl>(X)) {\n    const auto *FDY = cast<FieldDecl>(Y);\n    // FIXME: Also check the bitwidth is odr-equivalent, if any.\n    return X->getASTContext().hasSameType(FDX->getType(), FDY->getType());\n  }\n\n  // Indirect fields with the same target field match.\n  if (const auto *IFDX = dyn_cast<IndirectFieldDecl>(X)) {\n    const auto *IFDY = cast<IndirectFieldDecl>(Y);\n    return IFDX->getAnonField()->getCanonicalDecl() ==\n           IFDY->getAnonField()->getCanonicalDecl();\n  }\n\n  // Enumerators with the same name match.\n  if (isa<EnumConstantDecl>(X))\n    // FIXME: Also check the value is odr-equivalent.\n    return true;\n\n  // Using shadow declarations with the same target match.\n  if (const auto *USX = dyn_cast<UsingShadowDecl>(X)) {\n    const auto *USY = cast<UsingShadowDecl>(Y);\n    return USX->getTargetDecl() == USY->getTargetDecl();\n  }\n\n  // Using declarations with the same qualifier match. (We already know that\n  // the name matches.)\n  if (const auto *UX = dyn_cast<UsingDecl>(X)) {\n    const auto *UY = cast<UsingDecl>(Y);\n    return isSameQualifier(UX->getQualifier(), UY->getQualifier()) &&\n           UX->hasTypename() == UY->hasTypename() &&\n           UX->isAccessDeclaration() == UY->isAccessDeclaration();\n  }\n  if (const auto *UX = dyn_cast<UnresolvedUsingValueDecl>(X)) {\n    const auto *UY = cast<UnresolvedUsingValueDecl>(Y);\n    return isSameQualifier(UX->getQualifier(), UY->getQualifier()) &&\n           UX->isAccessDeclaration() == UY->isAccessDeclaration();\n  }\n  if (const auto *UX = dyn_cast<UnresolvedUsingTypenameDecl>(X))\n    return isSameQualifier(\n        UX->getQualifier(),\n        cast<UnresolvedUsingTypenameDecl>(Y)->getQualifier());\n\n  // Namespace alias definitions with the same target match.\n  if (const auto *NAX = dyn_cast<NamespaceAliasDecl>(X)) {\n    const auto *NAY = cast<NamespaceAliasDecl>(Y);\n    return NAX->getNamespace()->Equals(NAY->getNamespace());\n  }\n\n  return false;\n}\n\n/// Find the context in which we should search for previous declarations when\n/// looking for declarations to merge.\nDeclContext *ASTDeclReader::getPrimaryContextForMerging(ASTReader &Reader,\n                                                        DeclContext *DC) {\n  if (auto *ND = dyn_cast<NamespaceDecl>(DC))\n    return ND->getOriginalNamespace();\n\n  if (auto *RD = dyn_cast<CXXRecordDecl>(DC)) {\n    // Try to dig out the definition.\n    auto *DD = RD->DefinitionData;\n    if (!DD)\n      DD = RD->getCanonicalDecl()->DefinitionData;\n\n    // If there's no definition yet, then DC's definition is added by an update\n    // record, but we've not yet loaded that update record. In this case, we\n    // commit to DC being the canonical definition now, and will fix this when\n    // we load the update record.\n    if (!DD) {\n      DD = new (Reader.getContext()) struct CXXRecordDecl::DefinitionData(RD);\n      RD->setCompleteDefinition(true);\n      RD->DefinitionData = DD;\n      RD->getCanonicalDecl()->DefinitionData = DD;\n\n      // Track that we did this horrible thing so that we can fix it later.\n      Reader.PendingFakeDefinitionData.insert(\n          std::make_pair(DD, ASTReader::PendingFakeDefinitionKind::Fake));\n    }\n\n    return DD->Definition;\n  }\n\n  if (auto *ED = dyn_cast<EnumDecl>(DC))\n    return ED->getASTContext().getLangOpts().CPlusPlus? ED->getDefinition()\n                                                      : nullptr;\n\n  // We can see the TU here only if we have no Sema object. In that case,\n  // there's no TU scope to look in, so using the DC alone is sufficient.\n  if (auto *TU = dyn_cast<TranslationUnitDecl>(DC))\n    return TU;\n\n  return nullptr;\n}\n\nASTDeclReader::FindExistingResult::~FindExistingResult() {\n  // Record that we had a typedef name for linkage whether or not we merge\n  // with that declaration.\n  if (TypedefNameForLinkage) {\n    DeclContext *DC = New->getDeclContext()->getRedeclContext();\n    Reader.ImportedTypedefNamesForLinkage.insert(\n        std::make_pair(std::make_pair(DC, TypedefNameForLinkage), New));\n    return;\n  }\n\n  if (!AddResult || Existing)\n    return;\n\n  DeclarationName Name = New->getDeclName();\n  DeclContext *DC = New->getDeclContext()->getRedeclContext();\n  if (needsAnonymousDeclarationNumber(New)) {\n    setAnonymousDeclForMerging(Reader, New->getLexicalDeclContext(),\n                               AnonymousDeclNumber, New);\n  } else if (DC->isTranslationUnit() &&\n             !Reader.getContext().getLangOpts().CPlusPlus) {\n    if (Reader.getIdResolver().tryAddTopLevelDecl(New, Name))\n      Reader.PendingFakeLookupResults[Name.getAsIdentifierInfo()]\n            .push_back(New);\n  } else if (DeclContext *MergeDC = getPrimaryContextForMerging(Reader, DC)) {\n    // Add the declaration to its redeclaration context so later merging\n    // lookups will find it.\n    MergeDC->makeDeclVisibleInContextImpl(New, /*Internal*/true);\n  }\n}\n\n/// Find the declaration that should be merged into, given the declaration found\n/// by name lookup. If we're merging an anonymous declaration within a typedef,\n/// we need a matching typedef, and we merge with the type inside it.\nstatic NamedDecl *getDeclForMerging(NamedDecl *Found,\n                                    bool IsTypedefNameForLinkage) {\n  if (!IsTypedefNameForLinkage)\n    return Found;\n\n  // If we found a typedef declaration that gives a name to some other\n  // declaration, then we want that inner declaration. Declarations from\n  // AST files are handled via ImportedTypedefNamesForLinkage.\n  if (Found->isFromASTFile())\n    return nullptr;\n\n  if (auto *TND = dyn_cast<TypedefNameDecl>(Found))\n    return TND->getAnonDeclWithTypedefName(/*AnyRedecl*/true);\n\n  return nullptr;\n}\n\n/// Find the declaration to use to populate the anonymous declaration table\n/// for the given lexical DeclContext. We only care about finding local\n/// definitions of the context; we'll merge imported ones as we go.\nDeclContext *\nASTDeclReader::getPrimaryDCForAnonymousDecl(DeclContext *LexicalDC) {\n  // For classes, we track the definition as we merge.\n  if (auto *RD = dyn_cast<CXXRecordDecl>(LexicalDC)) {\n    auto *DD = RD->getCanonicalDecl()->DefinitionData;\n    return DD ? DD->Definition : nullptr;\n  }\n\n  // For anything else, walk its merged redeclarations looking for a definition.\n  // Note that we can't just call getDefinition here because the redeclaration\n  // chain isn't wired up.\n  for (auto *D : merged_redecls(cast<Decl>(LexicalDC))) {\n    if (auto *FD = dyn_cast<FunctionDecl>(D))\n      if (FD->isThisDeclarationADefinition())\n        return FD;\n    if (auto *MD = dyn_cast<ObjCMethodDecl>(D))\n      if (MD->isThisDeclarationADefinition())\n        return MD;\n  }\n\n  // No merged definition yet.\n  return nullptr;\n}\n\nNamedDecl *ASTDeclReader::getAnonymousDeclForMerging(ASTReader &Reader,\n                                                     DeclContext *DC,\n                                                     unsigned Index) {\n  // If the lexical context has been merged, look into the now-canonical\n  // definition.\n  auto *CanonDC = cast<Decl>(DC)->getCanonicalDecl();\n\n  // If we've seen this before, return the canonical declaration.\n  auto &Previous = Reader.AnonymousDeclarationsForMerging[CanonDC];\n  if (Index < Previous.size() && Previous[Index])\n    return Previous[Index];\n\n  // If this is the first time, but we have parsed a declaration of the context,\n  // build the anonymous declaration list from the parsed declaration.\n  auto *PrimaryDC = getPrimaryDCForAnonymousDecl(DC);\n  if (PrimaryDC && !cast<Decl>(PrimaryDC)->isFromASTFile()) {\n    numberAnonymousDeclsWithin(PrimaryDC, [&](NamedDecl *ND, unsigned Number) {\n      if (Previous.size() == Number)\n        Previous.push_back(cast<NamedDecl>(ND->getCanonicalDecl()));\n      else\n        Previous[Number] = cast<NamedDecl>(ND->getCanonicalDecl());\n    });\n  }\n\n  return Index < Previous.size() ? Previous[Index] : nullptr;\n}\n\nvoid ASTDeclReader::setAnonymousDeclForMerging(ASTReader &Reader,\n                                               DeclContext *DC, unsigned Index,\n                                               NamedDecl *D) {\n  auto *CanonDC = cast<Decl>(DC)->getCanonicalDecl();\n\n  auto &Previous = Reader.AnonymousDeclarationsForMerging[CanonDC];\n  if (Index >= Previous.size())\n    Previous.resize(Index + 1);\n  if (!Previous[Index])\n    Previous[Index] = D;\n}\n\nASTDeclReader::FindExistingResult ASTDeclReader::findExisting(NamedDecl *D) {\n  DeclarationName Name = TypedefNameForLinkage ? TypedefNameForLinkage\n                                               : D->getDeclName();\n\n  if (!Name && !needsAnonymousDeclarationNumber(D)) {\n    // Don't bother trying to find unnamed declarations that are in\n    // unmergeable contexts.\n    FindExistingResult Result(Reader, D, /*Existing=*/nullptr,\n                              AnonymousDeclNumber, TypedefNameForLinkage);\n    Result.suppress();\n    return Result;\n  }\n\n  DeclContext *DC = D->getDeclContext()->getRedeclContext();\n  if (TypedefNameForLinkage) {\n    auto It = Reader.ImportedTypedefNamesForLinkage.find(\n        std::make_pair(DC, TypedefNameForLinkage));\n    if (It != Reader.ImportedTypedefNamesForLinkage.end())\n      if (isSameEntity(It->second, D))\n        return FindExistingResult(Reader, D, It->second, AnonymousDeclNumber,\n                                  TypedefNameForLinkage);\n    // Go on to check in other places in case an existing typedef name\n    // was not imported.\n  }\n\n  if (needsAnonymousDeclarationNumber(D)) {\n    // This is an anonymous declaration that we may need to merge. Look it up\n    // in its context by number.\n    if (auto *Existing = getAnonymousDeclForMerging(\n            Reader, D->getLexicalDeclContext(), AnonymousDeclNumber))\n      if (isSameEntity(Existing, D))\n        return FindExistingResult(Reader, D, Existing, AnonymousDeclNumber,\n                                  TypedefNameForLinkage);\n  } else if (DC->isTranslationUnit() &&\n             !Reader.getContext().getLangOpts().CPlusPlus) {\n    IdentifierResolver &IdResolver = Reader.getIdResolver();\n\n    // Temporarily consider the identifier to be up-to-date. We don't want to\n    // cause additional lookups here.\n    class UpToDateIdentifierRAII {\n      IdentifierInfo *II;\n      bool WasOutToDate = false;\n\n    public:\n      explicit UpToDateIdentifierRAII(IdentifierInfo *II) : II(II) {\n        if (II) {\n          WasOutToDate = II->isOutOfDate();\n          if (WasOutToDate)\n            II->setOutOfDate(false);\n        }\n      }\n\n      ~UpToDateIdentifierRAII() {\n        if (WasOutToDate)\n          II->setOutOfDate(true);\n      }\n    } UpToDate(Name.getAsIdentifierInfo());\n\n    for (IdentifierResolver::iterator I = IdResolver.begin(Name),\n                                   IEnd = IdResolver.end();\n         I != IEnd; ++I) {\n      if (NamedDecl *Existing = getDeclForMerging(*I, TypedefNameForLinkage))\n        if (isSameEntity(Existing, D))\n          return FindExistingResult(Reader, D, Existing, AnonymousDeclNumber,\n                                    TypedefNameForLinkage);\n    }\n  } else if (DeclContext *MergeDC = getPrimaryContextForMerging(Reader, DC)) {\n    DeclContext::lookup_result R = MergeDC->noload_lookup(Name);\n    for (DeclContext::lookup_iterator I = R.begin(), E = R.end(); I != E; ++I) {\n      if (NamedDecl *Existing = getDeclForMerging(*I, TypedefNameForLinkage))\n        if (isSameEntity(Existing, D))\n          return FindExistingResult(Reader, D, Existing, AnonymousDeclNumber,\n                                    TypedefNameForLinkage);\n    }\n  } else {\n    // Not in a mergeable context.\n    return FindExistingResult(Reader);\n  }\n\n  // If this declaration is from a merged context, make a note that we need to\n  // check that the canonical definition of that context contains the decl.\n  //\n  // FIXME: We should do something similar if we merge two definitions of the\n  // same template specialization into the same CXXRecordDecl.\n  auto MergedDCIt = Reader.MergedDeclContexts.find(D->getLexicalDeclContext());\n  if (MergedDCIt != Reader.MergedDeclContexts.end() &&\n      MergedDCIt->second == D->getDeclContext())\n    Reader.PendingOdrMergeChecks.push_back(D);\n\n  return FindExistingResult(Reader, D, /*Existing=*/nullptr,\n                            AnonymousDeclNumber, TypedefNameForLinkage);\n}\n\ntemplate<typename DeclT>\nDecl *ASTDeclReader::getMostRecentDeclImpl(Redeclarable<DeclT> *D) {\n  return D->RedeclLink.getLatestNotUpdated();\n}\n\nDecl *ASTDeclReader::getMostRecentDeclImpl(...) {\n  llvm_unreachable(\"getMostRecentDecl on non-redeclarable declaration\");\n}\n\nDecl *ASTDeclReader::getMostRecentDecl(Decl *D) {\n  assert(D);\n\n  switch (D->getKind()) {\n#define ABSTRACT_DECL(TYPE)\n#define DECL(TYPE, BASE)                               \\\n  case Decl::TYPE:                                     \\\n    return getMostRecentDeclImpl(cast<TYPE##Decl>(D));\n#include \"clang/AST/DeclNodes.inc\"\n  }\n  llvm_unreachable(\"unknown decl kind\");\n}\n\nDecl *ASTReader::getMostRecentExistingDecl(Decl *D) {\n  return ASTDeclReader::getMostRecentDecl(D->getCanonicalDecl());\n}\n\nvoid ASTDeclReader::mergeInheritableAttributes(ASTReader &Reader, Decl *D,\n                                               Decl *Previous) {\n  InheritableAttr *NewAttr = nullptr;\n  ASTContext &Context = Reader.getContext();\n  const auto *IA = Previous->getAttr<MSInheritanceAttr>();\n\n  if (IA && !D->hasAttr<MSInheritanceAttr>()) {\n    NewAttr = cast<InheritableAttr>(IA->clone(Context));\n    NewAttr->setInherited(true);\n    D->addAttr(NewAttr);\n  }\n}\n\ntemplate<typename DeclT>\nvoid ASTDeclReader::attachPreviousDeclImpl(ASTReader &Reader,\n                                           Redeclarable<DeclT> *D,\n                                           Decl *Previous, Decl *Canon) {\n  D->RedeclLink.setPrevious(cast<DeclT>(Previous));\n  D->First = cast<DeclT>(Previous)->First;\n}\n\nnamespace clang {\n\ntemplate<>\nvoid ASTDeclReader::attachPreviousDeclImpl(ASTReader &Reader,\n                                           Redeclarable<VarDecl> *D,\n                                           Decl *Previous, Decl *Canon) {\n  auto *VD = static_cast<VarDecl *>(D);\n  auto *PrevVD = cast<VarDecl>(Previous);\n  D->RedeclLink.setPrevious(PrevVD);\n  D->First = PrevVD->First;\n\n  // We should keep at most one definition on the chain.\n  // FIXME: Cache the definition once we've found it. Building a chain with\n  // N definitions currently takes O(N^2) time here.\n  if (VD->isThisDeclarationADefinition() == VarDecl::Definition) {\n    for (VarDecl *CurD = PrevVD; CurD; CurD = CurD->getPreviousDecl()) {\n      if (CurD->isThisDeclarationADefinition() == VarDecl::Definition) {\n        Reader.mergeDefinitionVisibility(CurD, VD);\n        VD->demoteThisDefinitionToDeclaration();\n        break;\n      }\n    }\n  }\n}\n\nstatic bool isUndeducedReturnType(QualType T) {\n  auto *DT = T->getContainedDeducedType();\n  return DT && !DT->isDeduced();\n}\n\ntemplate<>\nvoid ASTDeclReader::attachPreviousDeclImpl(ASTReader &Reader,\n                                           Redeclarable<FunctionDecl> *D,\n                                           Decl *Previous, Decl *Canon) {\n  auto *FD = static_cast<FunctionDecl *>(D);\n  auto *PrevFD = cast<FunctionDecl>(Previous);\n\n  FD->RedeclLink.setPrevious(PrevFD);\n  FD->First = PrevFD->First;\n\n  // If the previous declaration is an inline function declaration, then this\n  // declaration is too.\n  if (PrevFD->isInlined() != FD->isInlined()) {\n    // FIXME: [dcl.fct.spec]p4:\n    //   If a function with external linkage is declared inline in one\n    //   translation unit, it shall be declared inline in all translation\n    //   units in which it appears.\n    //\n    // Be careful of this case:\n    //\n    // module A:\n    //   template<typename T> struct X { void f(); };\n    //   template<typename T> inline void X<T>::f() {}\n    //\n    // module B instantiates the declaration of X<int>::f\n    // module C instantiates the definition of X<int>::f\n    //\n    // If module B and C are merged, we do not have a violation of this rule.\n    FD->setImplicitlyInline(true);\n  }\n\n  auto *FPT = FD->getType()->getAs<FunctionProtoType>();\n  auto *PrevFPT = PrevFD->getType()->getAs<FunctionProtoType>();\n  if (FPT && PrevFPT) {\n    // If we need to propagate an exception specification along the redecl\n    // chain, make a note of that so that we can do so later.\n    bool IsUnresolved = isUnresolvedExceptionSpec(FPT->getExceptionSpecType());\n    bool WasUnresolved =\n        isUnresolvedExceptionSpec(PrevFPT->getExceptionSpecType());\n    if (IsUnresolved != WasUnresolved)\n      Reader.PendingExceptionSpecUpdates.insert(\n          {Canon, IsUnresolved ? PrevFD : FD});\n\n    // If we need to propagate a deduced return type along the redecl chain,\n    // make a note of that so that we can do it later.\n    bool IsUndeduced = isUndeducedReturnType(FPT->getReturnType());\n    bool WasUndeduced = isUndeducedReturnType(PrevFPT->getReturnType());\n    if (IsUndeduced != WasUndeduced)\n      Reader.PendingDeducedTypeUpdates.insert(\n          {cast<FunctionDecl>(Canon),\n           (IsUndeduced ? PrevFPT : FPT)->getReturnType()});\n  }\n}\n\n} // namespace clang\n\nvoid ASTDeclReader::attachPreviousDeclImpl(ASTReader &Reader, ...) {\n  llvm_unreachable(\"attachPreviousDecl on non-redeclarable declaration\");\n}\n\n/// Inherit the default template argument from \\p From to \\p To. Returns\n/// \\c false if there is no default template for \\p From.\ntemplate <typename ParmDecl>\nstatic bool inheritDefaultTemplateArgument(ASTContext &Context, ParmDecl *From,\n                                           Decl *ToD) {\n  auto *To = cast<ParmDecl>(ToD);\n  if (!From->hasDefaultArgument())\n    return false;\n  To->setInheritedDefaultArgument(Context, From);\n  return true;\n}\n\nstatic void inheritDefaultTemplateArguments(ASTContext &Context,\n                                            TemplateDecl *From,\n                                            TemplateDecl *To) {\n  auto *FromTP = From->getTemplateParameters();\n  auto *ToTP = To->getTemplateParameters();\n  assert(FromTP->size() == ToTP->size() && \"merged mismatched templates?\");\n\n  for (unsigned I = 0, N = FromTP->size(); I != N; ++I) {\n    NamedDecl *FromParam = FromTP->getParam(I);\n    NamedDecl *ToParam = ToTP->getParam(I);\n\n    if (auto *FTTP = dyn_cast<TemplateTypeParmDecl>(FromParam))\n      inheritDefaultTemplateArgument(Context, FTTP, ToParam);\n    else if (auto *FNTTP = dyn_cast<NonTypeTemplateParmDecl>(FromParam))\n      inheritDefaultTemplateArgument(Context, FNTTP, ToParam);\n    else\n      inheritDefaultTemplateArgument(\n              Context, cast<TemplateTemplateParmDecl>(FromParam), ToParam);\n  }\n}\n\nvoid ASTDeclReader::attachPreviousDecl(ASTReader &Reader, Decl *D,\n                                       Decl *Previous, Decl *Canon) {\n  assert(D && Previous);\n\n  switch (D->getKind()) {\n#define ABSTRACT_DECL(TYPE)\n#define DECL(TYPE, BASE)                                                  \\\n  case Decl::TYPE:                                                        \\\n    attachPreviousDeclImpl(Reader, cast<TYPE##Decl>(D), Previous, Canon); \\\n    break;\n#include \"clang/AST/DeclNodes.inc\"\n  }\n\n  // If the declaration was visible in one module, a redeclaration of it in\n  // another module remains visible even if it wouldn't be visible by itself.\n  //\n  // FIXME: In this case, the declaration should only be visible if a module\n  //        that makes it visible has been imported.\n  D->IdentifierNamespace |=\n      Previous->IdentifierNamespace &\n      (Decl::IDNS_Ordinary | Decl::IDNS_Tag | Decl::IDNS_Type);\n\n  // If the declaration declares a template, it may inherit default arguments\n  // from the previous declaration.\n  if (auto *TD = dyn_cast<TemplateDecl>(D))\n    inheritDefaultTemplateArguments(Reader.getContext(),\n                                    cast<TemplateDecl>(Previous), TD);\n\n  // If any of the declaration in the chain contains an Inheritable attribute,\n  // it needs to be added to all the declarations in the redeclarable chain.\n  // FIXME: Only the logic of merging MSInheritableAttr is present, it should\n  // be extended for all inheritable attributes.\n  mergeInheritableAttributes(Reader, D, Previous);\n}\n\ntemplate<typename DeclT>\nvoid ASTDeclReader::attachLatestDeclImpl(Redeclarable<DeclT> *D, Decl *Latest) {\n  D->RedeclLink.setLatest(cast<DeclT>(Latest));\n}\n\nvoid ASTDeclReader::attachLatestDeclImpl(...) {\n  llvm_unreachable(\"attachLatestDecl on non-redeclarable declaration\");\n}\n\nvoid ASTDeclReader::attachLatestDecl(Decl *D, Decl *Latest) {\n  assert(D && Latest);\n\n  switch (D->getKind()) {\n#define ABSTRACT_DECL(TYPE)\n#define DECL(TYPE, BASE)                                  \\\n  case Decl::TYPE:                                        \\\n    attachLatestDeclImpl(cast<TYPE##Decl>(D), Latest); \\\n    break;\n#include \"clang/AST/DeclNodes.inc\"\n  }\n}\n\ntemplate<typename DeclT>\nvoid ASTDeclReader::markIncompleteDeclChainImpl(Redeclarable<DeclT> *D) {\n  D->RedeclLink.markIncomplete();\n}\n\nvoid ASTDeclReader::markIncompleteDeclChainImpl(...) {\n  llvm_unreachable(\"markIncompleteDeclChain on non-redeclarable declaration\");\n}\n\nvoid ASTReader::markIncompleteDeclChain(Decl *D) {\n  switch (D->getKind()) {\n#define ABSTRACT_DECL(TYPE)\n#define DECL(TYPE, BASE)                                             \\\n  case Decl::TYPE:                                                   \\\n    ASTDeclReader::markIncompleteDeclChainImpl(cast<TYPE##Decl>(D)); \\\n    break;\n#include \"clang/AST/DeclNodes.inc\"\n  }\n}\n\n/// Read the declaration at the given offset from the AST file.\nDecl *ASTReader::ReadDeclRecord(DeclID ID) {\n  unsigned Index = ID - NUM_PREDEF_DECL_IDS;\n  SourceLocation DeclLoc;\n  RecordLocation Loc = DeclCursorForID(ID, DeclLoc);\n  llvm::BitstreamCursor &DeclsCursor = Loc.F->DeclsCursor;\n  // Keep track of where we are in the stream, then jump back there\n  // after reading this declaration.\n  SavedStreamPosition SavedPosition(DeclsCursor);\n\n  ReadingKindTracker ReadingKind(Read_Decl, *this);\n\n  // Note that we are loading a declaration record.\n  Deserializing ADecl(this);\n\n  auto Fail = [](const char *what, llvm::Error &&Err) {\n    llvm::report_fatal_error(Twine(\"ASTReader::readDeclRecord failed \") + what +\n                             \": \" + toString(std::move(Err)));\n  };\n\n  if (llvm::Error JumpFailed = DeclsCursor.JumpToBit(Loc.Offset))\n    Fail(\"jumping\", std::move(JumpFailed));\n  ASTRecordReader Record(*this, *Loc.F);\n  ASTDeclReader Reader(*this, Record, Loc, ID, DeclLoc);\n  Expected<unsigned> MaybeCode = DeclsCursor.ReadCode();\n  if (!MaybeCode)\n    Fail(\"reading code\", MaybeCode.takeError());\n  unsigned Code = MaybeCode.get();\n\n  ASTContext &Context = getContext();\n  Decl *D = nullptr;\n  Expected<unsigned> MaybeDeclCode = Record.readRecord(DeclsCursor, Code);\n  if (!MaybeDeclCode)\n    llvm::report_fatal_error(\n        \"ASTReader::readDeclRecord failed reading decl code: \" +\n        toString(MaybeDeclCode.takeError()));\n  switch ((DeclCode)MaybeDeclCode.get()) {\n  case DECL_CONTEXT_LEXICAL:\n  case DECL_CONTEXT_VISIBLE:\n    llvm_unreachable(\"Record cannot be de-serialized with readDeclRecord\");\n  case DECL_TYPEDEF:\n    D = TypedefDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_TYPEALIAS:\n    D = TypeAliasDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_ENUM:\n    D = EnumDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_RECORD:\n    D = RecordDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_ENUM_CONSTANT:\n    D = EnumConstantDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_FUNCTION:\n    D = FunctionDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_LINKAGE_SPEC:\n    D = LinkageSpecDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_EXPORT:\n    D = ExportDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_LABEL:\n    D = LabelDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_NAMESPACE:\n    D = NamespaceDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_NAMESPACE_ALIAS:\n    D = NamespaceAliasDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_USING:\n    D = UsingDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_USING_PACK:\n    D = UsingPackDecl::CreateDeserialized(Context, ID, Record.readInt());\n    break;\n  case DECL_USING_SHADOW:\n    D = UsingShadowDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CONSTRUCTOR_USING_SHADOW:\n    D = ConstructorUsingShadowDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_USING_DIRECTIVE:\n    D = UsingDirectiveDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_UNRESOLVED_USING_VALUE:\n    D = UnresolvedUsingValueDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_UNRESOLVED_USING_TYPENAME:\n    D = UnresolvedUsingTypenameDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CXX_RECORD:\n    D = CXXRecordDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CXX_DEDUCTION_GUIDE:\n    D = CXXDeductionGuideDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CXX_METHOD:\n    D = CXXMethodDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CXX_CONSTRUCTOR:\n    D = CXXConstructorDecl::CreateDeserialized(Context, ID, Record.readInt());\n    break;\n  case DECL_CXX_DESTRUCTOR:\n    D = CXXDestructorDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CXX_CONVERSION:\n    D = CXXConversionDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_ACCESS_SPEC:\n    D = AccessSpecDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_FRIEND:\n    D = FriendDecl::CreateDeserialized(Context, ID, Record.readInt());\n    break;\n  case DECL_FRIEND_TEMPLATE:\n    D = FriendTemplateDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CLASS_TEMPLATE:\n    D = ClassTemplateDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CLASS_TEMPLATE_SPECIALIZATION:\n    D = ClassTemplateSpecializationDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CLASS_TEMPLATE_PARTIAL_SPECIALIZATION:\n    D = ClassTemplatePartialSpecializationDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_VAR_TEMPLATE:\n    D = VarTemplateDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_VAR_TEMPLATE_SPECIALIZATION:\n    D = VarTemplateSpecializationDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_VAR_TEMPLATE_PARTIAL_SPECIALIZATION:\n    D = VarTemplatePartialSpecializationDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CLASS_SCOPE_FUNCTION_SPECIALIZATION:\n    D = ClassScopeFunctionSpecializationDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_FUNCTION_TEMPLATE:\n    D = FunctionTemplateDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_TEMPLATE_TYPE_PARM: {\n    bool HasTypeConstraint = Record.readInt();\n    D = TemplateTypeParmDecl::CreateDeserialized(Context, ID,\n                                                 HasTypeConstraint);\n    break;\n  }\n  case DECL_NON_TYPE_TEMPLATE_PARM: {\n    bool HasTypeConstraint = Record.readInt();\n    D = NonTypeTemplateParmDecl::CreateDeserialized(Context, ID,\n                                                    HasTypeConstraint);\n    break;\n  }\n  case DECL_EXPANDED_NON_TYPE_TEMPLATE_PARM_PACK: {\n    bool HasTypeConstraint = Record.readInt();\n    D = NonTypeTemplateParmDecl::CreateDeserialized(Context, ID,\n                                                    Record.readInt(),\n                                                    HasTypeConstraint);\n    break;\n  }\n  case DECL_TEMPLATE_TEMPLATE_PARM:\n    D = TemplateTemplateParmDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_EXPANDED_TEMPLATE_TEMPLATE_PARM_PACK:\n    D = TemplateTemplateParmDecl::CreateDeserialized(Context, ID,\n                                                     Record.readInt());\n    break;\n  case DECL_TYPE_ALIAS_TEMPLATE:\n    D = TypeAliasTemplateDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CONCEPT:\n    D = ConceptDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_REQUIRES_EXPR_BODY:\n    D = RequiresExprBodyDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_STATIC_ASSERT:\n    D = StaticAssertDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_METHOD:\n    D = ObjCMethodDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_INTERFACE:\n    D = ObjCInterfaceDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_IVAR:\n    D = ObjCIvarDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_PROTOCOL:\n    D = ObjCProtocolDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_AT_DEFS_FIELD:\n    D = ObjCAtDefsFieldDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_CATEGORY:\n    D = ObjCCategoryDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_CATEGORY_IMPL:\n    D = ObjCCategoryImplDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_IMPLEMENTATION:\n    D = ObjCImplementationDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_COMPATIBLE_ALIAS:\n    D = ObjCCompatibleAliasDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_PROPERTY:\n    D = ObjCPropertyDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_PROPERTY_IMPL:\n    D = ObjCPropertyImplDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_FIELD:\n    D = FieldDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_INDIRECTFIELD:\n    D = IndirectFieldDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_VAR:\n    D = VarDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_IMPLICIT_PARAM:\n    D = ImplicitParamDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_PARM_VAR:\n    D = ParmVarDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_DECOMPOSITION:\n    D = DecompositionDecl::CreateDeserialized(Context, ID, Record.readInt());\n    break;\n  case DECL_BINDING:\n    D = BindingDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_FILE_SCOPE_ASM:\n    D = FileScopeAsmDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_BLOCK:\n    D = BlockDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_MS_PROPERTY:\n    D = MSPropertyDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_MS_GUID:\n    D = MSGuidDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_TEMPLATE_PARAM_OBJECT:\n    D = TemplateParamObjectDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_CAPTURED:\n    D = CapturedDecl::CreateDeserialized(Context, ID, Record.readInt());\n    break;\n  case DECL_CXX_BASE_SPECIFIERS:\n    Error(\"attempt to read a C++ base-specifier record as a declaration\");\n    return nullptr;\n  case DECL_CXX_CTOR_INITIALIZERS:\n    Error(\"attempt to read a C++ ctor initializer record as a declaration\");\n    return nullptr;\n  case DECL_IMPORT:\n    // Note: last entry of the ImportDecl record is the number of stored source\n    // locations.\n    D = ImportDecl::CreateDeserialized(Context, ID, Record.back());\n    break;\n  case DECL_OMP_THREADPRIVATE: {\n    Record.skipInts(1);\n    unsigned NumChildren = Record.readInt();\n    Record.skipInts(1);\n    D = OMPThreadPrivateDecl::CreateDeserialized(Context, ID, NumChildren);\n    break;\n  }\n  case DECL_OMP_ALLOCATE: {\n    unsigned NumClauses = Record.readInt();\n    unsigned NumVars = Record.readInt();\n    Record.skipInts(1);\n    D = OMPAllocateDecl::CreateDeserialized(Context, ID, NumVars, NumClauses);\n    break;\n  }\n  case DECL_OMP_REQUIRES: {\n    unsigned NumClauses = Record.readInt();\n    Record.skipInts(2);\n    D = OMPRequiresDecl::CreateDeserialized(Context, ID, NumClauses);\n    break;\n  }\n  case DECL_OMP_DECLARE_REDUCTION:\n    D = OMPDeclareReductionDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OMP_DECLARE_MAPPER: {\n    unsigned NumClauses = Record.readInt();\n    Record.skipInts(2);\n    D = OMPDeclareMapperDecl::CreateDeserialized(Context, ID, NumClauses);\n    break;\n  }\n  case DECL_OMP_CAPTUREDEXPR:\n    D = OMPCapturedExprDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_PRAGMA_COMMENT:\n    D = PragmaCommentDecl::CreateDeserialized(Context, ID, Record.readInt());\n    break;\n  case DECL_PRAGMA_DETECT_MISMATCH:\n    D = PragmaDetectMismatchDecl::CreateDeserialized(Context, ID,\n                                                     Record.readInt());\n    break;\n  case DECL_EMPTY:\n    D = EmptyDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_LIFETIME_EXTENDED_TEMPORARY:\n    D = LifetimeExtendedTemporaryDecl::CreateDeserialized(Context, ID);\n    break;\n  case DECL_OBJC_TYPE_PARAM:\n    D = ObjCTypeParamDecl::CreateDeserialized(Context, ID);\n    break;\n  }\n\n  assert(D && \"Unknown declaration reading AST file\");\n  LoadedDecl(Index, D);\n  // Set the DeclContext before doing any deserialization, to make sure internal\n  // calls to Decl::getASTContext() by Decl's methods will find the\n  // TranslationUnitDecl without crashing.\n  D->setDeclContext(Context.getTranslationUnitDecl());\n  Reader.Visit(D);\n\n  // If this declaration is also a declaration context, get the\n  // offsets for its tables of lexical and visible declarations.\n  if (auto *DC = dyn_cast<DeclContext>(D)) {\n    std::pair<uint64_t, uint64_t> Offsets = Reader.VisitDeclContext(DC);\n    if (Offsets.first &&\n        ReadLexicalDeclContextStorage(*Loc.F, DeclsCursor, Offsets.first, DC))\n      return nullptr;\n    if (Offsets.second &&\n        ReadVisibleDeclContextStorage(*Loc.F, DeclsCursor, Offsets.second, ID))\n      return nullptr;\n  }\n  assert(Record.getIdx() == Record.size());\n\n  // Load any relevant update records.\n  PendingUpdateRecords.push_back(\n      PendingUpdateRecord(ID, D, /*JustLoaded=*/true));\n\n  // Load the categories after recursive loading is finished.\n  if (auto *Class = dyn_cast<ObjCInterfaceDecl>(D))\n    // If we already have a definition when deserializing the ObjCInterfaceDecl,\n    // we put the Decl in PendingDefinitions so we can pull the categories here.\n    if (Class->isThisDeclarationADefinition() ||\n        PendingDefinitions.count(Class))\n      loadObjCCategories(ID, Class);\n\n  // If we have deserialized a declaration that has a definition the\n  // AST consumer might need to know about, queue it.\n  // We don't pass it to the consumer immediately because we may be in recursive\n  // loading, and some declarations may still be initializing.\n  PotentiallyInterestingDecls.push_back(\n      InterestingDecl(D, Reader.hasPendingBody()));\n\n  return D;\n}\n\nvoid ASTReader::PassInterestingDeclsToConsumer() {\n  assert(Consumer);\n\n  if (PassingDeclsToConsumer)\n    return;\n\n  // Guard variable to avoid recursively redoing the process of passing\n  // decls to consumer.\n  SaveAndRestore<bool> GuardPassingDeclsToConsumer(PassingDeclsToConsumer,\n                                                   true);\n\n  // Ensure that we've loaded all potentially-interesting declarations\n  // that need to be eagerly loaded.\n  for (auto ID : EagerlyDeserializedDecls)\n    GetDecl(ID);\n  EagerlyDeserializedDecls.clear();\n\n  while (!PotentiallyInterestingDecls.empty()) {\n    InterestingDecl D = PotentiallyInterestingDecls.front();\n    PotentiallyInterestingDecls.pop_front();\n    if (isConsumerInterestedIn(getContext(), D.getDecl(), D.hasPendingBody()))\n      PassInterestingDeclToConsumer(D.getDecl());\n  }\n}\n\nvoid ASTReader::loadDeclUpdateRecords(PendingUpdateRecord &Record) {\n  // The declaration may have been modified by files later in the chain.\n  // If this is the case, read the record containing the updates from each file\n  // and pass it to ASTDeclReader to make the modifications.\n  serialization::GlobalDeclID ID = Record.ID;\n  Decl *D = Record.D;\n  ProcessingUpdatesRAIIObj ProcessingUpdates(*this);\n  DeclUpdateOffsetsMap::iterator UpdI = DeclUpdateOffsets.find(ID);\n\n  SmallVector<serialization::DeclID, 8> PendingLazySpecializationIDs;\n\n  if (UpdI != DeclUpdateOffsets.end()) {\n    auto UpdateOffsets = std::move(UpdI->second);\n    DeclUpdateOffsets.erase(UpdI);\n\n    // Check if this decl was interesting to the consumer. If we just loaded\n    // the declaration, then we know it was interesting and we skip the call\n    // to isConsumerInterestedIn because it is unsafe to call in the\n    // current ASTReader state.\n    bool WasInteresting =\n        Record.JustLoaded || isConsumerInterestedIn(getContext(), D, false);\n    for (auto &FileAndOffset : UpdateOffsets) {\n      ModuleFile *F = FileAndOffset.first;\n      uint64_t Offset = FileAndOffset.second;\n      llvm::BitstreamCursor &Cursor = F->DeclsCursor;\n      SavedStreamPosition SavedPosition(Cursor);\n      if (llvm::Error JumpFailed = Cursor.JumpToBit(Offset))\n        // FIXME don't do a fatal error.\n        llvm::report_fatal_error(\n            \"ASTReader::loadDeclUpdateRecords failed jumping: \" +\n            toString(std::move(JumpFailed)));\n      Expected<unsigned> MaybeCode = Cursor.ReadCode();\n      if (!MaybeCode)\n        llvm::report_fatal_error(\n            \"ASTReader::loadDeclUpdateRecords failed reading code: \" +\n            toString(MaybeCode.takeError()));\n      unsigned Code = MaybeCode.get();\n      ASTRecordReader Record(*this, *F);\n      if (Expected<unsigned> MaybeRecCode = Record.readRecord(Cursor, Code))\n        assert(MaybeRecCode.get() == DECL_UPDATES &&\n               \"Expected DECL_UPDATES record!\");\n      else\n        llvm::report_fatal_error(\n            \"ASTReader::loadDeclUpdateRecords failed reading rec code: \" +\n            toString(MaybeCode.takeError()));\n\n      ASTDeclReader Reader(*this, Record, RecordLocation(F, Offset), ID,\n                           SourceLocation());\n      Reader.UpdateDecl(D, PendingLazySpecializationIDs);\n\n      // We might have made this declaration interesting. If so, remember that\n      // we need to hand it off to the consumer.\n      if (!WasInteresting &&\n          isConsumerInterestedIn(getContext(), D, Reader.hasPendingBody())) {\n        PotentiallyInterestingDecls.push_back(\n            InterestingDecl(D, Reader.hasPendingBody()));\n        WasInteresting = true;\n      }\n    }\n  }\n  // Add the lazy specializations to the template.\n  assert((PendingLazySpecializationIDs.empty() || isa<ClassTemplateDecl>(D) ||\n          isa<FunctionTemplateDecl>(D) || isa<VarTemplateDecl>(D)) &&\n         \"Must not have pending specializations\");\n  if (auto *CTD = dyn_cast<ClassTemplateDecl>(D))\n    ASTDeclReader::AddLazySpecializations(CTD, PendingLazySpecializationIDs);\n  else if (auto *FTD = dyn_cast<FunctionTemplateDecl>(D))\n    ASTDeclReader::AddLazySpecializations(FTD, PendingLazySpecializationIDs);\n  else if (auto *VTD = dyn_cast<VarTemplateDecl>(D))\n    ASTDeclReader::AddLazySpecializations(VTD, PendingLazySpecializationIDs);\n  PendingLazySpecializationIDs.clear();\n\n  // Load the pending visible updates for this decl context, if it has any.\n  auto I = PendingVisibleUpdates.find(ID);\n  if (I != PendingVisibleUpdates.end()) {\n    auto VisibleUpdates = std::move(I->second);\n    PendingVisibleUpdates.erase(I);\n\n    auto *DC = cast<DeclContext>(D)->getPrimaryContext();\n    for (const auto &Update : VisibleUpdates)\n      Lookups[DC].Table.add(\n          Update.Mod, Update.Data,\n          reader::ASTDeclContextNameLookupTrait(*this, *Update.Mod));\n    DC->setHasExternalVisibleStorage(true);\n  }\n}\n\nvoid ASTReader::loadPendingDeclChain(Decl *FirstLocal, uint64_t LocalOffset) {\n  // Attach FirstLocal to the end of the decl chain.\n  Decl *CanonDecl = FirstLocal->getCanonicalDecl();\n  if (FirstLocal != CanonDecl) {\n    Decl *PrevMostRecent = ASTDeclReader::getMostRecentDecl(CanonDecl);\n    ASTDeclReader::attachPreviousDecl(\n        *this, FirstLocal, PrevMostRecent ? PrevMostRecent : CanonDecl,\n        CanonDecl);\n  }\n\n  if (!LocalOffset) {\n    ASTDeclReader::attachLatestDecl(CanonDecl, FirstLocal);\n    return;\n  }\n\n  // Load the list of other redeclarations from this module file.\n  ModuleFile *M = getOwningModuleFile(FirstLocal);\n  assert(M && \"imported decl from no module file\");\n\n  llvm::BitstreamCursor &Cursor = M->DeclsCursor;\n  SavedStreamPosition SavedPosition(Cursor);\n  if (llvm::Error JumpFailed = Cursor.JumpToBit(LocalOffset))\n    llvm::report_fatal_error(\n        \"ASTReader::loadPendingDeclChain failed jumping: \" +\n        toString(std::move(JumpFailed)));\n\n  RecordData Record;\n  Expected<unsigned> MaybeCode = Cursor.ReadCode();\n  if (!MaybeCode)\n    llvm::report_fatal_error(\n        \"ASTReader::loadPendingDeclChain failed reading code: \" +\n        toString(MaybeCode.takeError()));\n  unsigned Code = MaybeCode.get();\n  if (Expected<unsigned> MaybeRecCode = Cursor.readRecord(Code, Record))\n    assert(MaybeRecCode.get() == LOCAL_REDECLARATIONS &&\n           \"expected LOCAL_REDECLARATIONS record!\");\n  else\n    llvm::report_fatal_error(\n        \"ASTReader::loadPendingDeclChain failed reading rec code: \" +\n        toString(MaybeCode.takeError()));\n\n  // FIXME: We have several different dispatches on decl kind here; maybe\n  // we should instead generate one loop per kind and dispatch up-front?\n  Decl *MostRecent = FirstLocal;\n  for (unsigned I = 0, N = Record.size(); I != N; ++I) {\n    auto *D = GetLocalDecl(*M, Record[N - I - 1]);\n    ASTDeclReader::attachPreviousDecl(*this, D, MostRecent, CanonDecl);\n    MostRecent = D;\n  }\n  ASTDeclReader::attachLatestDecl(CanonDecl, MostRecent);\n}\n\nnamespace {\n\n  /// Given an ObjC interface, goes through the modules and links to the\n  /// interface all the categories for it.\n  class ObjCCategoriesVisitor {\n    ASTReader &Reader;\n    ObjCInterfaceDecl *Interface;\n    llvm::SmallPtrSetImpl<ObjCCategoryDecl *> &Deserialized;\n    ObjCCategoryDecl *Tail = nullptr;\n    llvm::DenseMap<DeclarationName, ObjCCategoryDecl *> NameCategoryMap;\n    serialization::GlobalDeclID InterfaceID;\n    unsigned PreviousGeneration;\n\n    void add(ObjCCategoryDecl *Cat) {\n      // Only process each category once.\n      if (!Deserialized.erase(Cat))\n        return;\n\n      // Check for duplicate categories.\n      if (Cat->getDeclName()) {\n        ObjCCategoryDecl *&Existing = NameCategoryMap[Cat->getDeclName()];\n        if (Existing &&\n            Reader.getOwningModuleFile(Existing)\n                                          != Reader.getOwningModuleFile(Cat)) {\n          // FIXME: We should not warn for duplicates in diamond:\n          //\n          //   MT     //\n          //  /  \\    //\n          // ML  MR   //\n          //  \\  /    //\n          //   MB     //\n          //\n          // If there are duplicates in ML/MR, there will be warning when\n          // creating MB *and* when importing MB. We should not warn when\n          // importing.\n          Reader.Diag(Cat->getLocation(), diag::warn_dup_category_def)\n            << Interface->getDeclName() << Cat->getDeclName();\n          Reader.Diag(Existing->getLocation(), diag::note_previous_definition);\n        } else if (!Existing) {\n          // Record this category.\n          Existing = Cat;\n        }\n      }\n\n      // Add this category to the end of the chain.\n      if (Tail)\n        ASTDeclReader::setNextObjCCategory(Tail, Cat);\n      else\n        Interface->setCategoryListRaw(Cat);\n      Tail = Cat;\n    }\n\n  public:\n    ObjCCategoriesVisitor(ASTReader &Reader,\n                          ObjCInterfaceDecl *Interface,\n                          llvm::SmallPtrSetImpl<ObjCCategoryDecl *> &Deserialized,\n                          serialization::GlobalDeclID InterfaceID,\n                          unsigned PreviousGeneration)\n        : Reader(Reader), Interface(Interface), Deserialized(Deserialized),\n          InterfaceID(InterfaceID), PreviousGeneration(PreviousGeneration) {\n      // Populate the name -> category map with the set of known categories.\n      for (auto *Cat : Interface->known_categories()) {\n        if (Cat->getDeclName())\n          NameCategoryMap[Cat->getDeclName()] = Cat;\n\n        // Keep track of the tail of the category list.\n        Tail = Cat;\n      }\n    }\n\n    bool operator()(ModuleFile &M) {\n      // If we've loaded all of the category information we care about from\n      // this module file, we're done.\n      if (M.Generation <= PreviousGeneration)\n        return true;\n\n      // Map global ID of the definition down to the local ID used in this\n      // module file. If there is no such mapping, we'll find nothing here\n      // (or in any module it imports).\n      DeclID LocalID = Reader.mapGlobalIDToModuleFileGlobalID(M, InterfaceID);\n      if (!LocalID)\n        return true;\n\n      // Perform a binary search to find the local redeclarations for this\n      // declaration (if any).\n      const ObjCCategoriesInfo Compare = { LocalID, 0 };\n      const ObjCCategoriesInfo *Result\n        = std::lower_bound(M.ObjCCategoriesMap,\n                           M.ObjCCategoriesMap + M.LocalNumObjCCategoriesInMap,\n                           Compare);\n      if (Result == M.ObjCCategoriesMap + M.LocalNumObjCCategoriesInMap ||\n          Result->DefinitionID != LocalID) {\n        // We didn't find anything. If the class definition is in this module\n        // file, then the module files it depends on cannot have any categories,\n        // so suppress further lookup.\n        return Reader.isDeclIDFromModule(InterfaceID, M);\n      }\n\n      // We found something. Dig out all of the categories.\n      unsigned Offset = Result->Offset;\n      unsigned N = M.ObjCCategories[Offset];\n      M.ObjCCategories[Offset++] = 0; // Don't try to deserialize again\n      for (unsigned I = 0; I != N; ++I)\n        add(cast_or_null<ObjCCategoryDecl>(\n              Reader.GetLocalDecl(M, M.ObjCCategories[Offset++])));\n      return true;\n    }\n  };\n\n} // namespace\n\nvoid ASTReader::loadObjCCategories(serialization::GlobalDeclID ID,\n                                   ObjCInterfaceDecl *D,\n                                   unsigned PreviousGeneration) {\n  ObjCCategoriesVisitor Visitor(*this, D, CategoriesDeserialized, ID,\n                                PreviousGeneration);\n  ModuleMgr.visit(Visitor);\n}\n\ntemplate<typename DeclT, typename Fn>\nstatic void forAllLaterRedecls(DeclT *D, Fn F) {\n  F(D);\n\n  // Check whether we've already merged D into its redeclaration chain.\n  // MostRecent may or may not be nullptr if D has not been merged. If\n  // not, walk the merged redecl chain and see if it's there.\n  auto *MostRecent = D->getMostRecentDecl();\n  bool Found = false;\n  for (auto *Redecl = MostRecent; Redecl && !Found;\n       Redecl = Redecl->getPreviousDecl())\n    Found = (Redecl == D);\n\n  // If this declaration is merged, apply the functor to all later decls.\n  if (Found) {\n    for (auto *Redecl = MostRecent; Redecl != D;\n         Redecl = Redecl->getPreviousDecl())\n      F(Redecl);\n  }\n}\n\nvoid ASTDeclReader::UpdateDecl(Decl *D,\n   llvm::SmallVectorImpl<serialization::DeclID> &PendingLazySpecializationIDs) {\n  while (Record.getIdx() < Record.size()) {\n    switch ((DeclUpdateKind)Record.readInt()) {\n    case UPD_CXX_ADDED_IMPLICIT_MEMBER: {\n      auto *RD = cast<CXXRecordDecl>(D);\n      // FIXME: If we also have an update record for instantiating the\n      // definition of D, we need that to happen before we get here.\n      Decl *MD = Record.readDecl();\n      assert(MD && \"couldn't read decl from update record\");\n      // FIXME: We should call addHiddenDecl instead, to add the member\n      // to its DeclContext.\n      RD->addedMember(MD);\n      break;\n    }\n\n    case UPD_CXX_ADDED_TEMPLATE_SPECIALIZATION:\n      // It will be added to the template's lazy specialization set.\n      PendingLazySpecializationIDs.push_back(readDeclID());\n      break;\n\n    case UPD_CXX_ADDED_ANONYMOUS_NAMESPACE: {\n      auto *Anon = readDeclAs<NamespaceDecl>();\n\n      // Each module has its own anonymous namespace, which is disjoint from\n      // any other module's anonymous namespaces, so don't attach the anonymous\n      // namespace at all.\n      if (!Record.isModule()) {\n        if (auto *TU = dyn_cast<TranslationUnitDecl>(D))\n          TU->setAnonymousNamespace(Anon);\n        else\n          cast<NamespaceDecl>(D)->setAnonymousNamespace(Anon);\n      }\n      break;\n    }\n\n    case UPD_CXX_ADDED_VAR_DEFINITION: {\n      auto *VD = cast<VarDecl>(D);\n      VD->NonParmVarDeclBits.IsInline = Record.readInt();\n      VD->NonParmVarDeclBits.IsInlineSpecified = Record.readInt();\n      uint64_t Val = Record.readInt();\n      if (Val && !VD->getInit()) {\n        VD->setInit(Record.readExpr());\n        if (Val != 1) {\n          EvaluatedStmt *Eval = VD->ensureEvaluatedStmt();\n          Eval->HasConstantInitialization = (Val & 2) != 0;\n          Eval->HasConstantDestruction = (Val & 4) != 0;\n        }\n      }\n      break;\n    }\n\n    case UPD_CXX_POINT_OF_INSTANTIATION: {\n      SourceLocation POI = Record.readSourceLocation();\n      if (auto *VTSD = dyn_cast<VarTemplateSpecializationDecl>(D)) {\n        VTSD->setPointOfInstantiation(POI);\n      } else if (auto *VD = dyn_cast<VarDecl>(D)) {\n        VD->getMemberSpecializationInfo()->setPointOfInstantiation(POI);\n      } else {\n        auto *FD = cast<FunctionDecl>(D);\n        if (auto *FTSInfo = FD->TemplateOrSpecialization\n                    .dyn_cast<FunctionTemplateSpecializationInfo *>())\n          FTSInfo->setPointOfInstantiation(POI);\n        else\n          FD->TemplateOrSpecialization.get<MemberSpecializationInfo *>()\n              ->setPointOfInstantiation(POI);\n      }\n      break;\n    }\n\n    case UPD_CXX_INSTANTIATED_DEFAULT_ARGUMENT: {\n      auto *Param = cast<ParmVarDecl>(D);\n\n      // We have to read the default argument regardless of whether we use it\n      // so that hypothetical further update records aren't messed up.\n      // TODO: Add a function to skip over the next expr record.\n      auto *DefaultArg = Record.readExpr();\n\n      // Only apply the update if the parameter still has an uninstantiated\n      // default argument.\n      if (Param->hasUninstantiatedDefaultArg())\n        Param->setDefaultArg(DefaultArg);\n      break;\n    }\n\n    case UPD_CXX_INSTANTIATED_DEFAULT_MEMBER_INITIALIZER: {\n      auto *FD = cast<FieldDecl>(D);\n      auto *DefaultInit = Record.readExpr();\n\n      // Only apply the update if the field still has an uninstantiated\n      // default member initializer.\n      if (FD->hasInClassInitializer() && !FD->getInClassInitializer()) {\n        if (DefaultInit)\n          FD->setInClassInitializer(DefaultInit);\n        else\n          // Instantiation failed. We can get here if we serialized an AST for\n          // an invalid program.\n          FD->removeInClassInitializer();\n      }\n      break;\n    }\n\n    case UPD_CXX_ADDED_FUNCTION_DEFINITION: {\n      auto *FD = cast<FunctionDecl>(D);\n      if (Reader.PendingBodies[FD]) {\n        // FIXME: Maybe check for ODR violations.\n        // It's safe to stop now because this update record is always last.\n        return;\n      }\n\n      if (Record.readInt()) {\n        // Maintain AST consistency: any later redeclarations of this function\n        // are inline if this one is. (We might have merged another declaration\n        // into this one.)\n        forAllLaterRedecls(FD, [](FunctionDecl *FD) {\n          FD->setImplicitlyInline();\n        });\n      }\n      FD->setInnerLocStart(readSourceLocation());\n      ReadFunctionDefinition(FD);\n      assert(Record.getIdx() == Record.size() && \"lazy body must be last\");\n      break;\n    }\n\n    case UPD_CXX_INSTANTIATED_CLASS_DEFINITION: {\n      auto *RD = cast<CXXRecordDecl>(D);\n      auto *OldDD = RD->getCanonicalDecl()->DefinitionData;\n      bool HadRealDefinition =\n          OldDD && (OldDD->Definition != RD ||\n                    !Reader.PendingFakeDefinitionData.count(OldDD));\n      RD->setParamDestroyedInCallee(Record.readInt());\n      RD->setArgPassingRestrictions(\n          (RecordDecl::ArgPassingKind)Record.readInt());\n      ReadCXXRecordDefinition(RD, /*Update*/true);\n\n      // Visible update is handled separately.\n      uint64_t LexicalOffset = ReadLocalOffset();\n      if (!HadRealDefinition && LexicalOffset) {\n        Record.readLexicalDeclContextStorage(LexicalOffset, RD);\n        Reader.PendingFakeDefinitionData.erase(OldDD);\n      }\n\n      auto TSK = (TemplateSpecializationKind)Record.readInt();\n      SourceLocation POI = readSourceLocation();\n      if (MemberSpecializationInfo *MSInfo =\n              RD->getMemberSpecializationInfo()) {\n        MSInfo->setTemplateSpecializationKind(TSK);\n        MSInfo->setPointOfInstantiation(POI);\n      } else {\n        auto *Spec = cast<ClassTemplateSpecializationDecl>(RD);\n        Spec->setTemplateSpecializationKind(TSK);\n        Spec->setPointOfInstantiation(POI);\n\n        if (Record.readInt()) {\n          auto *PartialSpec =\n              readDeclAs<ClassTemplatePartialSpecializationDecl>();\n          SmallVector<TemplateArgument, 8> TemplArgs;\n          Record.readTemplateArgumentList(TemplArgs);\n          auto *TemplArgList = TemplateArgumentList::CreateCopy(\n              Reader.getContext(), TemplArgs);\n\n          // FIXME: If we already have a partial specialization set,\n          // check that it matches.\n          if (!Spec->getSpecializedTemplateOrPartial()\n                   .is<ClassTemplatePartialSpecializationDecl *>())\n            Spec->setInstantiationOf(PartialSpec, TemplArgList);\n        }\n      }\n\n      RD->setTagKind((TagTypeKind)Record.readInt());\n      RD->setLocation(readSourceLocation());\n      RD->setLocStart(readSourceLocation());\n      RD->setBraceRange(readSourceRange());\n\n      if (Record.readInt()) {\n        AttrVec Attrs;\n        Record.readAttributes(Attrs);\n        // If the declaration already has attributes, we assume that some other\n        // AST file already loaded them.\n        if (!D->hasAttrs())\n          D->setAttrsImpl(Attrs, Reader.getContext());\n      }\n      break;\n    }\n\n    case UPD_CXX_RESOLVED_DTOR_DELETE: {\n      // Set the 'operator delete' directly to avoid emitting another update\n      // record.\n      auto *Del = readDeclAs<FunctionDecl>();\n      auto *First = cast<CXXDestructorDecl>(D->getCanonicalDecl());\n      auto *ThisArg = Record.readExpr();\n      // FIXME: Check consistency if we have an old and new operator delete.\n      if (!First->OperatorDelete) {\n        First->OperatorDelete = Del;\n        First->OperatorDeleteThisArg = ThisArg;\n      }\n      break;\n    }\n\n    case UPD_CXX_RESOLVED_EXCEPTION_SPEC: {\n      SmallVector<QualType, 8> ExceptionStorage;\n      auto ESI = Record.readExceptionSpecInfo(ExceptionStorage);\n\n      // Update this declaration's exception specification, if needed.\n      auto *FD = cast<FunctionDecl>(D);\n      auto *FPT = FD->getType()->castAs<FunctionProtoType>();\n      // FIXME: If the exception specification is already present, check that it\n      // matches.\n      if (isUnresolvedExceptionSpec(FPT->getExceptionSpecType())) {\n        FD->setType(Reader.getContext().getFunctionType(\n            FPT->getReturnType(), FPT->getParamTypes(),\n            FPT->getExtProtoInfo().withExceptionSpec(ESI)));\n\n        // When we get to the end of deserializing, see if there are other decls\n        // that we need to propagate this exception specification onto.\n        Reader.PendingExceptionSpecUpdates.insert(\n            std::make_pair(FD->getCanonicalDecl(), FD));\n      }\n      break;\n    }\n\n    case UPD_CXX_DEDUCED_RETURN_TYPE: {\n      auto *FD = cast<FunctionDecl>(D);\n      QualType DeducedResultType = Record.readType();\n      Reader.PendingDeducedTypeUpdates.insert(\n          {FD->getCanonicalDecl(), DeducedResultType});\n      break;\n    }\n\n    case UPD_DECL_MARKED_USED:\n      // Maintain AST consistency: any later redeclarations are used too.\n      D->markUsed(Reader.getContext());\n      break;\n\n    case UPD_MANGLING_NUMBER:\n      Reader.getContext().setManglingNumber(cast<NamedDecl>(D),\n                                            Record.readInt());\n      break;\n\n    case UPD_STATIC_LOCAL_NUMBER:\n      Reader.getContext().setStaticLocalNumber(cast<VarDecl>(D),\n                                               Record.readInt());\n      break;\n\n    case UPD_DECL_MARKED_OPENMP_THREADPRIVATE:\n      D->addAttr(OMPThreadPrivateDeclAttr::CreateImplicit(\n          Reader.getContext(), readSourceRange(),\n          AttributeCommonInfo::AS_Pragma));\n      break;\n\n    case UPD_DECL_MARKED_OPENMP_ALLOCATE: {\n      auto AllocatorKind =\n          static_cast<OMPAllocateDeclAttr::AllocatorTypeTy>(Record.readInt());\n      Expr *Allocator = Record.readExpr();\n      SourceRange SR = readSourceRange();\n      D->addAttr(OMPAllocateDeclAttr::CreateImplicit(\n          Reader.getContext(), AllocatorKind, Allocator, SR,\n          AttributeCommonInfo::AS_Pragma));\n      break;\n    }\n\n    case UPD_DECL_EXPORTED: {\n      unsigned SubmoduleID = readSubmoduleID();\n      auto *Exported = cast<NamedDecl>(D);\n      Module *Owner = SubmoduleID ? Reader.getSubmodule(SubmoduleID) : nullptr;\n      Reader.getContext().mergeDefinitionIntoModule(Exported, Owner);\n      Reader.PendingMergedDefinitionsToDeduplicate.insert(Exported);\n      break;\n    }\n\n    case UPD_DECL_MARKED_OPENMP_DECLARETARGET: {\n      auto MapType = Record.readEnum<OMPDeclareTargetDeclAttr::MapTypeTy>();\n      auto DevType = Record.readEnum<OMPDeclareTargetDeclAttr::DevTypeTy>();\n      unsigned Level = Record.readInt();\n      D->addAttr(OMPDeclareTargetDeclAttr::CreateImplicit(\n          Reader.getContext(), MapType, DevType, Level, readSourceRange(),\n          AttributeCommonInfo::AS_Pragma));\n      break;\n    }\n\n    case UPD_ADDED_ATTR_TO_RECORD:\n      AttrVec Attrs;\n      Record.readAttributes(Attrs);\n      assert(Attrs.size() == 1);\n      D->addAttr(Attrs[0]);\n      break;\n    }\n  }\n}\n"}}, "reports": [{"events": [{"location": {"col": 10, "file": 16, "line": 547}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 16, "line": 547}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Sema.h", "reportHash": "e4ea9e448dcf02abdc9f5b5d3e3dd49c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 16, "line": 547}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Sema.h", "reportHash": "6d3e3a9902b95b676df63c0eb20eabf6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 16, "line": 553}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 16, "line": 553}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Sema.h", "reportHash": "e1c1fc5b0499a31b1f5802d7d2e7d85f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 16, "line": 553}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Sema.h", "reportHash": "d21b038a024ef2e5834a8cb9da9e4505", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 16, "line": 12744}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 16, "line": 12744}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Sema.h", "reportHash": "9783c490c2f3328c1676b1840c59f08e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 16, "line": 12744}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Sema.h", "reportHash": "416fb8d22a80af333bb4ecfa8d61ef04", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 37}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 17, "line": 37}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Weak.h", "reportHash": "7a9423145963822800906aa38ff8744b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 37}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Weak.h", "reportHash": "860d2a140d16f1adf7df755e9ddd88c2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 40}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 17, "line": 40}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Weak.h", "reportHash": "752d08e055ead327a7b560403c08e95d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 40}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Sema/Weak.h", "reportHash": "98a8954632da2ae8f612c3d144ae4325", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 18, "line": 1427}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 18, "line": 1427}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTReader.h", "reportHash": "792638886d454b2a35cf2855b6a7c29b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 18, "line": 1427}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Serialization/ASTReader.h", "reportHash": "51284d4b2e7c4172c457145f1e2681bb", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 19, "line": 490}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 19, "line": 490}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp", "reportHash": "f13dc18278f06ff7287a4f5b4e2138ca", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
