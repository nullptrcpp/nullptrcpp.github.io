<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h", "content": "//===- llvm/ADT/SparseMultiSet.h - Sparse multiset --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the SparseMultiSet class, which adds multiset behavior to\n// the SparseSet.\n//\n// A sparse multiset holds a small number of objects identified by integer keys\n// from a moderately sized universe. The sparse multiset uses more memory than\n// other containers in order to provide faster operations. Any key can map to\n// multiple values. A SparseMultiSetNode class is provided, which serves as a\n// convenient base class for the contents of a SparseMultiSet.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SPARSEMULTISET_H\n#define LLVM_ADT_SPARSEMULTISET_H\n\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/SparseSet.h\"\n#include <cassert>\n#include <cstdint>\n#include <cstdlib>\n#include <iterator>\n#include <limits>\n#include <utility>\n\nnamespace llvm {\n\n/// Fast multiset implementation for objects that can be identified by small\n/// unsigned keys.\n///\n/// SparseMultiSet allocates memory proportional to the size of the key\n/// universe, so it is not recommended for building composite data structures.\n/// It is useful for algorithms that require a single set with fast operations.\n///\n/// Compared to DenseSet and DenseMap, SparseMultiSet provides constant-time\n/// fast clear() as fast as a vector.  The find(), insert(), and erase()\n/// operations are all constant time, and typically faster than a hash table.\n/// The iteration order doesn't depend on numerical key values, it only depends\n/// on the order of insert() and erase() operations.  Iteration order is the\n/// insertion order. Iteration is only provided over elements of equivalent\n/// keys, but iterators are bidirectional.\n///\n/// Compared to BitVector, SparseMultiSet<unsigned> uses 8x-40x more memory, but\n/// offers constant-time clear() and size() operations as well as fast iteration\n/// independent on the size of the universe.\n///\n/// SparseMultiSet contains a dense vector holding all the objects and a sparse\n/// array holding indexes into the dense vector.  Most of the memory is used by\n/// the sparse array which is the size of the key universe. The SparseT template\n/// parameter provides a space/speed tradeoff for sets holding many elements.\n///\n/// When SparseT is uint32_t, find() only touches up to 3 cache lines, but the\n/// sparse array uses 4 x Universe bytes.\n///\n/// When SparseT is uint8_t (the default), find() touches up to 3+[N/256] cache\n/// lines, but the sparse array is 4x smaller.  N is the number of elements in\n/// the set.\n///\n/// For sets that may grow to thousands of elements, SparseT should be set to\n/// uint16_t or uint32_t.\n///\n/// Multiset behavior is provided by providing doubly linked lists for values\n/// that are inlined in the dense vector. SparseMultiSet is a good choice when\n/// one desires a growable number of entries per key, as it will retain the\n/// SparseSet algorithmic properties despite being growable. Thus, it is often a\n/// better choice than a SparseSet of growable containers or a vector of\n/// vectors. SparseMultiSet also keeps iterators valid after erasure (provided\n/// the iterators don't point to the element erased), allowing for more\n/// intuitive and fast removal.\n///\n/// @tparam ValueT      The type of objects in the set.\n/// @tparam KeyFunctorT A functor that computes an unsigned index from KeyT.\n/// @tparam SparseT     An unsigned integer type. See above.\n///\ntemplate<typename ValueT,\n         typename KeyFunctorT = identity<unsigned>,\n         typename SparseT = uint8_t>\nclass SparseMultiSet {\n  static_assert(std::numeric_limits<SparseT>::is_integer &&\n                !std::numeric_limits<SparseT>::is_signed,\n                \"SparseT must be an unsigned integer type\");\n\n  /// The actual data that's stored, as a doubly-linked list implemented via\n  /// indices into the DenseVector.  The doubly linked list is implemented\n  /// circular in Prev indices, and INVALID-terminated in Next indices. This\n  /// provides efficient access to list tails. These nodes can also be\n  /// tombstones, in which case they are actually nodes in a single-linked\n  /// freelist of recyclable slots.\n  struct SMSNode {\n    static constexpr unsigned INVALID = ~0U;\n\n    ValueT Data;\n    unsigned Prev;\n    unsigned Next;\n\n    SMSNode(ValueT D, unsigned P, unsigned N) : Data(D), Prev(P), Next(N) {}\n\n    /// List tails have invalid Nexts.\n    bool isTail() const {\n      return Next == INVALID;\n    }\n\n    /// Whether this node is a tombstone node, and thus is in our freelist.\n    bool isTombstone() const {\n      return Prev == INVALID;\n    }\n\n    /// Since the list is circular in Prev, all non-tombstone nodes have a valid\n    /// Prev.\n    bool isValid() const { return Prev != INVALID; }\n  };\n\n  using KeyT = typename KeyFunctorT::argument_type;\n  using DenseT = SmallVector<SMSNode, 8>;\n  DenseT Dense;\n  SparseT *Sparse = nullptr;\n  unsigned Universe = 0;\n  KeyFunctorT KeyIndexOf;\n  SparseSetValFunctor<KeyT, ValueT, KeyFunctorT> ValIndexOf;\n\n  /// We have a built-in recycler for reusing tombstone slots. This recycler\n  /// puts a singly-linked free list into tombstone slots, allowing us quick\n  /// erasure, iterator preservation, and dense size.\n  unsigned FreelistIdx = SMSNode::INVALID;\n  unsigned NumFree = 0;\n\n  unsigned sparseIndex(const ValueT &Val) const {\n    assert(ValIndexOf(Val) < Universe &&\n           \"Invalid key in set. Did object mutate?\");\n    return ValIndexOf(Val);\n  }\n  unsigned sparseIndex(const SMSNode &N) const { return sparseIndex(N.Data); }\n\n  /// Whether the given entry is the head of the list. List heads's previous\n  /// pointers are to the tail of the list, allowing for efficient access to the\n  /// list tail. D must be a valid entry node.\n  bool isHead(const SMSNode &D) const {\n    assert(D.isValid() && \"Invalid node for head\");\n    return Dense[D.Prev].isTail();\n  }\n\n  /// Whether the given entry is a singleton entry, i.e. the only entry with\n  /// that key.\n  bool isSingleton(const SMSNode &N) const {\n    assert(N.isValid() && \"Invalid node for singleton\");\n    // Is N its own predecessor?\n    return &Dense[N.Prev] == &N;\n  }\n\n  /// Add in the given SMSNode. Uses a free entry in our freelist if\n  /// available. Returns the index of the added node.\n  unsigned addValue(const ValueT& V, unsigned Prev, unsigned Next) {\n    if (NumFree == 0) {\n      Dense.push_back(SMSNode(V, Prev, Next));\n      return Dense.size() - 1;\n    }\n\n    // Peel off a free slot\n    unsigned Idx = FreelistIdx;\n    unsigned NextFree = Dense[Idx].Next;\n    assert(Dense[Idx].isTombstone() && \"Non-tombstone free?\");\n\n    Dense[Idx] = SMSNode(V, Prev, Next);\n    FreelistIdx = NextFree;\n    --NumFree;\n    return Idx;\n  }\n\n  /// Make the current index a new tombstone. Pushes it onto the freelist.\n  void makeTombstone(unsigned Idx) {\n    Dense[Idx].Prev = SMSNode::INVALID;\n    Dense[Idx].Next = FreelistIdx;\n    FreelistIdx = Idx;\n    ++NumFree;\n  }\n\npublic:\n  using value_type = ValueT;\n  using reference = ValueT &;\n  using const_reference = const ValueT &;\n  using pointer = ValueT *;\n  using const_pointer = const ValueT *;\n  using size_type = unsigned;\n\n  SparseMultiSet() = default;\n  SparseMultiSet(const SparseMultiSet &) = delete;\n  SparseMultiSet &operator=(const SparseMultiSet &) = delete;\n  ~SparseMultiSet() { free(Sparse); }\n\n  /// Set the universe size which determines the largest key the set can hold.\n  /// The universe must be sized before any elements can be added.\n  ///\n  /// @param U Universe size. All object keys must be less than U.\n  ///\n  void setUniverse(unsigned U) {\n    // It's not hard to resize the universe on a non-empty set, but it doesn't\n    // seem like a likely use case, so we can add that code when we need it.\n    assert(empty() && \"Can only resize universe on an empty map\");\n    // Hysteresis prevents needless reallocations.\n    if (U >= Universe/4 && U <= Universe)\n      return;\n    free(Sparse);\n    // The Sparse array doesn't actually need to be initialized, so malloc\n    // would be enough here, but that will cause tools like valgrind to\n    // complain about branching on uninitialized data.\n    Sparse = static_cast<SparseT*>(safe_calloc(U, sizeof(SparseT)));\n    Universe = U;\n  }\n\n  /// Our iterators are iterators over the collection of objects that share a\n  /// key.\n  template<typename SMSPtrTy>\n  class iterator_base : public std::iterator<std::bidirectional_iterator_tag,\n                                             ValueT> {\n    friend class SparseMultiSet;\n\n    SMSPtrTy SMS;\n    unsigned Idx;\n    unsigned SparseIdx;\n\n    iterator_base(SMSPtrTy P, unsigned I, unsigned SI)\n      : SMS(P), Idx(I), SparseIdx(SI) {}\n\n    /// Whether our iterator has fallen outside our dense vector.\n    bool isEnd() const {\n      if (Idx == SMSNode::INVALID)\n        return true;\n\n      assert(Idx < SMS->Dense.size() && \"Out of range, non-INVALID Idx?\");\n      return false;\n    }\n\n    /// Whether our iterator is properly keyed, i.e. the SparseIdx is valid\n    bool isKeyed() const { return SparseIdx < SMS->Universe; }\n\n    unsigned Prev() const { return SMS->Dense[Idx].Prev; }\n    unsigned Next() const { return SMS->Dense[Idx].Next; }\n\n    void setPrev(unsigned P) { SMS->Dense[Idx].Prev = P; }\n    void setNext(unsigned N) { SMS->Dense[Idx].Next = N; }\n\n  public:\n    using super = std::iterator<std::bidirectional_iterator_tag, ValueT>;\n    using value_type = typename super::value_type;\n    using difference_type = typename super::difference_type;\n    using pointer = typename super::pointer;\n    using reference = typename super::reference;\n\n    reference operator*() const {\n      assert(isKeyed() && SMS->sparseIndex(SMS->Dense[Idx].Data) == SparseIdx &&\n             \"Dereferencing iterator of invalid key or index\");\n\n      return SMS->Dense[Idx].Data;\n    }\n    pointer operator->() const { return &operator*(); }\n\n    /// Comparison operators\n    bool operator==(const iterator_base &RHS) const {\n      // end compares equal\n      if (SMS == RHS.SMS && Idx == RHS.Idx) {\n        assert((isEnd() || SparseIdx == RHS.SparseIdx) &&\n               \"Same dense entry, but different keys?\");\n        return true;\n      }\n\n      return false;\n    }\n\n    bool operator!=(const iterator_base &RHS) const {\n      return !operator==(RHS);\n    }\n\n    /// Increment and decrement operators\n    iterator_base &operator--() { // predecrement - Back up\n      assert(isKeyed() && \"Decrementing an invalid iterator\");\n      assert((isEnd() || !SMS->isHead(SMS->Dense[Idx])) &&\n             \"Decrementing head of list\");\n\n      // If we're at the end, then issue a new find()\n      if (isEnd())\n        Idx = SMS->findIndex(SparseIdx).Prev();\n      else\n        Idx = Prev();\n\n      return *this;\n    }\n    iterator_base &operator++() { // preincrement - Advance\n      assert(!isEnd() && isKeyed() && \"Incrementing an invalid/end iterator\");\n      Idx = Next();\n      return *this;\n    }\n    iterator_base operator--(int) { // postdecrement\n      iterator_base I(*this);\n      --*this;\n      return I;\n    }\n    iterator_base operator++(int) { // postincrement\n      iterator_base I(*this);\n      ++*this;\n      return I;\n    }\n  };\n\n  using iterator = iterator_base<SparseMultiSet *>;\n  using const_iterator = iterator_base<const SparseMultiSet *>;\n\n  // Convenience types\n  using RangePair = std::pair<iterator, iterator>;\n\n  /// Returns an iterator past this container. Note that such an iterator cannot\n  /// be decremented, but will compare equal to other end iterators.\n  iterator end() { return iterator(this, SMSNode::INVALID, SMSNode::INVALID); }\n  const_iterator end() const {\n    return const_iterator(this, SMSNode::INVALID, SMSNode::INVALID);\n  }\n\n  /// Returns true if the set is empty.\n  ///\n  /// This is not the same as BitVector::empty().\n  ///\n  bool empty() const { return size() == 0; }\n\n  /// Returns the number of elements in the set.\n  ///\n  /// This is not the same as BitVector::size() which returns the size of the\n  /// universe.\n  ///\n  size_type size() const {\n    assert(NumFree <= Dense.size() && \"Out-of-bounds free entries\");\n    return Dense.size() - NumFree;\n  }\n\n  /// Clears the set.  This is a very fast constant time operation.\n  ///\n  void clear() {\n    // Sparse does not need to be cleared, see find().\n    Dense.clear();\n    NumFree = 0;\n    FreelistIdx = SMSNode::INVALID;\n  }\n\n  /// Find an element by its index.\n  ///\n  /// @param   Idx A valid index to find.\n  /// @returns An iterator to the element identified by key, or end().\n  ///\n  iterator findIndex(unsigned Idx) {\n    assert(Idx < Universe && \"Key out of range\");\n    const unsigned Stride = std::numeric_limits<SparseT>::max() + 1u;\n    for (unsigned i = Sparse[Idx], e = Dense.size(); i < e; i += Stride) {\n      const unsigned FoundIdx = sparseIndex(Dense[i]);\n      // Check that we're pointing at the correct entry and that it is the head\n      // of a valid list.\n      if (Idx == FoundIdx && Dense[i].isValid() && isHead(Dense[i]))\n        return iterator(this, i, Idx);\n      // Stride is 0 when SparseT >= unsigned.  We don't need to loop.\n      if (!Stride)\n        break;\n    }\n    return end();\n  }\n\n  /// Find an element by its key.\n  ///\n  /// @param   Key A valid key to find.\n  /// @returns An iterator to the element identified by key, or end().\n  ///\n  iterator find(const KeyT &Key) {\n    return findIndex(KeyIndexOf(Key));\n  }\n\n  const_iterator find(const KeyT &Key) const {\n    iterator I = const_cast<SparseMultiSet*>(this)->findIndex(KeyIndexOf(Key));\n    return const_iterator(I.SMS, I.Idx, KeyIndexOf(Key));\n  }\n\n  /// Returns the number of elements identified by Key. This will be linear in\n  /// the number of elements of that key.\n  size_type count(const KeyT &Key) const {\n    unsigned Ret = 0;\n    for (const_iterator It = find(Key); It != end(); ++It)\n      ++Ret;\n\n    return Ret;\n  }\n\n  /// Returns true if this set contains an element identified by Key.\n  bool contains(const KeyT &Key) const {\n    return find(Key) != end();\n  }\n\n  /// Return the head and tail of the subset's list, otherwise returns end().\n  iterator getHead(const KeyT &Key) { return find(Key); }\n  iterator getTail(const KeyT &Key) {\n    iterator I = find(Key);\n    if (I != end())\n      I = iterator(this, I.Prev(), KeyIndexOf(Key));\n    return I;\n  }\n\n  /// The bounds of the range of items sharing Key K. First member is the head\n  /// of the list, and the second member is a decrementable end iterator for\n  /// that key.\n  RangePair equal_range(const KeyT &K) {\n    iterator B = find(K);\n    iterator E = iterator(this, SMSNode::INVALID, B.SparseIdx);\n    return make_pair(B, E);\n  }\n\n  /// Insert a new element at the tail of the subset list. Returns an iterator\n  /// to the newly added entry.\n  iterator insert(const ValueT &Val) {\n    unsigned Idx = sparseIndex(Val);\n    iterator I = findIndex(Idx);\n\n    unsigned NodeIdx = addValue(Val, SMSNode::INVALID, SMSNode::INVALID);\n\n    if (I == end()) {\n      // Make a singleton list\n      Sparse[Idx] = NodeIdx;\n      Dense[NodeIdx].Prev = NodeIdx;\n      return iterator(this, NodeIdx, Idx);\n    }\n\n    // Stick it at the end.\n    unsigned HeadIdx = I.Idx;\n    unsigned TailIdx = I.Prev();\n    Dense[TailIdx].Next = NodeIdx;\n    Dense[HeadIdx].Prev = NodeIdx;\n    Dense[NodeIdx].Prev = TailIdx;\n\n    return iterator(this, NodeIdx, Idx);\n  }\n\n  /// Erases an existing element identified by a valid iterator.\n  ///\n  /// This invalidates iterators pointing at the same entry, but erase() returns\n  /// an iterator pointing to the next element in the subset's list. This makes\n  /// it possible to erase selected elements while iterating over the subset:\n  ///\n  ///   tie(I, E) = Set.equal_range(Key);\n  ///   while (I != E)\n  ///     if (test(*I))\n  ///       I = Set.erase(I);\n  ///     else\n  ///       ++I;\n  ///\n  /// Note that if the last element in the subset list is erased, this will\n  /// return an end iterator which can be decremented to get the new tail (if it\n  /// exists):\n  ///\n  ///  tie(B, I) = Set.equal_range(Key);\n  ///  for (bool isBegin = B == I; !isBegin; /* empty */) {\n  ///    isBegin = (--I) == B;\n  ///    if (test(I))\n  ///      break;\n  ///    I = erase(I);\n  ///  }\n  iterator erase(iterator I) {\n    assert(I.isKeyed() && !I.isEnd() && !Dense[I.Idx].isTombstone() &&\n           \"erasing invalid/end/tombstone iterator\");\n\n    // First, unlink the node from its list. Then swap the node out with the\n    // dense vector's last entry\n    iterator NextI = unlink(Dense[I.Idx]);\n\n    // Put in a tombstone.\n    makeTombstone(I.Idx);\n\n    return NextI;\n  }\n\n  /// Erase all elements with the given key. This invalidates all\n  /// iterators of that key.\n  void eraseAll(const KeyT &K) {\n    for (iterator I = find(K); I != end(); /* empty */)\n      I = erase(I);\n  }\n\nprivate:\n  /// Unlink the node from its list. Returns the next node in the list.\n  iterator unlink(const SMSNode &N) {\n    if (isSingleton(N)) {\n      // Singleton is already unlinked\n      assert(N.Next == SMSNode::INVALID && \"Singleton has next?\");\n      return iterator(this, SMSNode::INVALID, ValIndexOf(N.Data));\n    }\n\n    if (isHead(N)) {\n      // If we're the head, then update the sparse array and our next.\n      Sparse[sparseIndex(N)] = N.Next;\n      Dense[N.Next].Prev = N.Prev;\n      return iterator(this, N.Next, ValIndexOf(N.Data));\n    }\n\n    if (N.isTail()) {\n      // If we're the tail, then update our head and our previous.\n      findIndex(sparseIndex(N)).setPrev(N.Prev);\n      Dense[N.Prev].Next = N.Next;\n\n      // Give back an end iterator that can be decremented\n      iterator I(this, N.Prev, ValIndexOf(N.Data));\n      return ++I;\n    }\n\n    // Otherwise, just drop us\n    Dense[N.Next].Prev = N.Prev;\n    Dense[N.Prev].Next = N.Next;\n    return iterator(this, N.Next, ValIndexOf(N.Data));\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_SPARSEMULTISET_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "content": "//===- llvm/CodeGen/LiveInterval.h - Interval representation ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the LiveRange and LiveInterval classes.  Given some\n// numbering of each the machine instructions an interval [i, j) is said to be a\n// live range for register v if there is no instruction with number j' >= j\n// such that v is live at j' and there is no instruction with number i' < i such\n// that v is live at i'. In this implementation ranges can have holes,\n// i.e. a range might look like [1,20), [50,65), [1000,1001).  Each\n// individual segment is represented as an instance of LiveRange::Segment,\n// and the whole range is represented as an instance of LiveRange.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_LIVEINTERVAL_H\n#define LLVM_CODEGEN_LIVEINTERVAL_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/IntEqClasses.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/CodeGen/Register.h\"\n#include \"llvm/CodeGen/SlotIndexes.h\"\n#include \"llvm/MC/LaneBitmask.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <functional>\n#include <memory>\n#include <set>\n#include <tuple>\n#include <utility>\n\nnamespace llvm {\n\n  class CoalescerPair;\n  class LiveIntervals;\n  class MachineRegisterInfo;\n  class raw_ostream;\n\n  /// VNInfo - Value Number Information.\n  /// This class holds information about a machine level values, including\n  /// definition and use points.\n  ///\n  class VNInfo {\n  public:\n    using Allocator = BumpPtrAllocator;\n\n    /// The ID number of this value.\n    unsigned id;\n\n    /// The index of the defining instruction.\n    SlotIndex def;\n\n    /// VNInfo constructor.\n    VNInfo(unsigned i, SlotIndex d) : id(i), def(d) {}\n\n    /// VNInfo constructor, copies values from orig, except for the value number.\n    VNInfo(unsigned i, const VNInfo &orig) : id(i), def(orig.def) {}\n\n    /// Copy from the parameter into this VNInfo.\n    void copyFrom(VNInfo &src) {\n      def = src.def;\n    }\n\n    /// Returns true if this value is defined by a PHI instruction (or was,\n    /// PHI instructions may have been eliminated).\n    /// PHI-defs begin at a block boundary, all other defs begin at register or\n    /// EC slots.\n    bool isPHIDef() const { return def.isBlock(); }\n\n    /// Returns true if this value is unused.\n    bool isUnused() const { return !def.isValid(); }\n\n    /// Mark this value as unused.\n    void markUnused() { def = SlotIndex(); }\n  };\n\n  /// Result of a LiveRange query. This class hides the implementation details\n  /// of live ranges, and it should be used as the primary interface for\n  /// examining live ranges around instructions.\n  class LiveQueryResult {\n    VNInfo *const EarlyVal;\n    VNInfo *const LateVal;\n    const SlotIndex EndPoint;\n    const bool Kill;\n\n  public:\n    LiveQueryResult(VNInfo *EarlyVal, VNInfo *LateVal, SlotIndex EndPoint,\n                    bool Kill)\n      : EarlyVal(EarlyVal), LateVal(LateVal), EndPoint(EndPoint), Kill(Kill)\n    {}\n\n    /// Return the value that is live-in to the instruction. This is the value\n    /// that will be read by the instruction's use operands. Return NULL if no\n    /// value is live-in.\n    VNInfo *valueIn() const {\n      return EarlyVal;\n    }\n\n    /// Return true if the live-in value is killed by this instruction. This\n    /// means that either the live range ends at the instruction, or it changes\n    /// value.\n    bool isKill() const {\n      return Kill;\n    }\n\n    /// Return true if this instruction has a dead def.\n    bool isDeadDef() const {\n      return EndPoint.isDead();\n    }\n\n    /// Return the value leaving the instruction, if any. This can be a\n    /// live-through value, or a live def. A dead def returns NULL.\n    VNInfo *valueOut() const {\n      return isDeadDef() ? nullptr : LateVal;\n    }\n\n    /// Returns the value alive at the end of the instruction, if any. This can\n    /// be a live-through value, a live def or a dead def.\n    VNInfo *valueOutOrDead() const {\n      return LateVal;\n    }\n\n    /// Return the value defined by this instruction, if any. This includes\n    /// dead defs, it is the value created by the instruction's def operands.\n    VNInfo *valueDefined() const {\n      return EarlyVal == LateVal ? nullptr : LateVal;\n    }\n\n    /// Return the end point of the last live range segment to interact with\n    /// the instruction, if any.\n    ///\n    /// The end point is an invalid SlotIndex only if the live range doesn't\n    /// intersect the instruction at all.\n    ///\n    /// The end point may be at or past the end of the instruction's basic\n    /// block. That means the value was live out of the block.\n    SlotIndex endPoint() const {\n      return EndPoint;\n    }\n  };\n\n  /// This class represents the liveness of a register, stack slot, etc.\n  /// It manages an ordered list of Segment objects.\n  /// The Segments are organized in a static single assignment form: At places\n  /// where a new value is defined or different values reach a CFG join a new\n  /// segment with a new value number is used.\n  class LiveRange {\n  public:\n    /// This represents a simple continuous liveness interval for a value.\n    /// The start point is inclusive, the end point exclusive. These intervals\n    /// are rendered as [start,end).\n    struct Segment {\n      SlotIndex start;  // Start point of the interval (inclusive)\n      SlotIndex end;    // End point of the interval (exclusive)\n      VNInfo *valno = nullptr; // identifier for the value contained in this\n                               // segment.\n\n      Segment() = default;\n\n      Segment(SlotIndex S, SlotIndex E, VNInfo *V)\n        : start(S), end(E), valno(V) {\n        assert(S < E && \"Cannot create empty or backwards segment\");\n      }\n\n      /// Return true if the index is covered by this segment.\n      bool contains(SlotIndex I) const {\n        return start <= I && I < end;\n      }\n\n      /// Return true if the given interval, [S, E), is covered by this segment.\n      bool containsInterval(SlotIndex S, SlotIndex E) const {\n        assert((S < E) && \"Backwards interval?\");\n        return (start <= S && S < end) && (start < E && E <= end);\n      }\n\n      bool operator<(const Segment &Other) const {\n        return std::tie(start, end) < std::tie(Other.start, Other.end);\n      }\n      bool operator==(const Segment &Other) const {\n        return start == Other.start && end == Other.end;\n      }\n\n      bool operator!=(const Segment &Other) const {\n        return !(*this == Other);\n      }\n\n      void dump() const;\n    };\n\n    using Segments = SmallVector<Segment, 2>;\n    using VNInfoList = SmallVector<VNInfo *, 2>;\n\n    Segments segments;   // the liveness segments\n    VNInfoList valnos;   // value#'s\n\n    // The segment set is used temporarily to accelerate initial computation\n    // of live ranges of physical registers in computeRegUnitRange.\n    // After that the set is flushed to the segment vector and deleted.\n    using SegmentSet = std::set<Segment>;\n    std::unique_ptr<SegmentSet> segmentSet;\n\n    using iterator = Segments::iterator;\n    using const_iterator = Segments::const_iterator;\n\n    iterator begin() { return segments.begin(); }\n    iterator end()   { return segments.end(); }\n\n    const_iterator begin() const { return segments.begin(); }\n    const_iterator end() const  { return segments.end(); }\n\n    using vni_iterator = VNInfoList::iterator;\n    using const_vni_iterator = VNInfoList::const_iterator;\n\n    vni_iterator vni_begin() { return valnos.begin(); }\n    vni_iterator vni_end()   { return valnos.end(); }\n\n    const_vni_iterator vni_begin() const { return valnos.begin(); }\n    const_vni_iterator vni_end() const   { return valnos.end(); }\n\n    /// Constructs a new LiveRange object.\n    LiveRange(bool UseSegmentSet = false)\n        : segmentSet(UseSegmentSet ? std::make_unique<SegmentSet>()\n                                   : nullptr) {}\n\n    /// Constructs a new LiveRange object by copying segments and valnos from\n    /// another LiveRange.\n    LiveRange(const LiveRange &Other, BumpPtrAllocator &Allocator) {\n      assert(Other.segmentSet == nullptr &&\n             \"Copying of LiveRanges with active SegmentSets is not supported\");\n      assign(Other, Allocator);\n    }\n\n    /// Copies values numbers and live segments from \\p Other into this range.\n    void assign(const LiveRange &Other, BumpPtrAllocator &Allocator) {\n      if (this == &Other)\n        return;\n\n      assert(Other.segmentSet == nullptr &&\n             \"Copying of LiveRanges with active SegmentSets is not supported\");\n      // Duplicate valnos.\n      for (const VNInfo *VNI : Other.valnos)\n        createValueCopy(VNI, Allocator);\n      // Now we can copy segments and remap their valnos.\n      for (const Segment &S : Other.segments)\n        segments.push_back(Segment(S.start, S.end, valnos[S.valno->id]));\n    }\n\n    /// advanceTo - Advance the specified iterator to point to the Segment\n    /// containing the specified position, or end() if the position is past the\n    /// end of the range.  If no Segment contains this position, but the\n    /// position is in a hole, this method returns an iterator pointing to the\n    /// Segment immediately after the hole.\n    iterator advanceTo(iterator I, SlotIndex Pos) {\n      assert(I != end());\n      if (Pos >= endIndex())\n        return end();\n      while (I->end <= Pos) ++I;\n      return I;\n    }\n\n    const_iterator advanceTo(const_iterator I, SlotIndex Pos) const {\n      assert(I != end());\n      if (Pos >= endIndex())\n        return end();\n      while (I->end <= Pos) ++I;\n      return I;\n    }\n\n    /// find - Return an iterator pointing to the first segment that ends after\n    /// Pos, or end(). This is the same as advanceTo(begin(), Pos), but faster\n    /// when searching large ranges.\n    ///\n    /// If Pos is contained in a Segment, that segment is returned.\n    /// If Pos is in a hole, the following Segment is returned.\n    /// If Pos is beyond endIndex, end() is returned.\n    iterator find(SlotIndex Pos);\n\n    const_iterator find(SlotIndex Pos) const {\n      return const_cast<LiveRange*>(this)->find(Pos);\n    }\n\n    void clear() {\n      valnos.clear();\n      segments.clear();\n    }\n\n    size_t size() const {\n      return segments.size();\n    }\n\n    bool hasAtLeastOneValue() const { return !valnos.empty(); }\n\n    bool containsOneValue() const { return valnos.size() == 1; }\n\n    unsigned getNumValNums() const { return (unsigned)valnos.size(); }\n\n    /// getValNumInfo - Returns pointer to the specified val#.\n    ///\n    inline VNInfo *getValNumInfo(unsigned ValNo) {\n      return valnos[ValNo];\n    }\n    inline const VNInfo *getValNumInfo(unsigned ValNo) const {\n      return valnos[ValNo];\n    }\n\n    /// containsValue - Returns true if VNI belongs to this range.\n    bool containsValue(const VNInfo *VNI) const {\n      return VNI && VNI->id < getNumValNums() && VNI == getValNumInfo(VNI->id);\n    }\n\n    /// getNextValue - Create a new value number and return it.  MIIdx specifies\n    /// the instruction that defines the value number.\n    VNInfo *getNextValue(SlotIndex def, VNInfo::Allocator &VNInfoAllocator) {\n      VNInfo *VNI =\n        new (VNInfoAllocator) VNInfo((unsigned)valnos.size(), def);\n      valnos.push_back(VNI);\n      return VNI;\n    }\n\n    /// createDeadDef - Make sure the range has a value defined at Def.\n    /// If one already exists, return it. Otherwise allocate a new value and\n    /// add liveness for a dead def.\n    VNInfo *createDeadDef(SlotIndex Def, VNInfo::Allocator &VNIAlloc);\n\n    /// Create a def of value @p VNI. Return @p VNI. If there already exists\n    /// a definition at VNI->def, the value defined there must be @p VNI.\n    VNInfo *createDeadDef(VNInfo *VNI);\n\n    /// Create a copy of the given value. The new value will be identical except\n    /// for the Value number.\n    VNInfo *createValueCopy(const VNInfo *orig,\n                            VNInfo::Allocator &VNInfoAllocator) {\n      VNInfo *VNI =\n        new (VNInfoAllocator) VNInfo((unsigned)valnos.size(), *orig);\n      valnos.push_back(VNI);\n      return VNI;\n    }\n\n    /// RenumberValues - Renumber all values in order of appearance and remove\n    /// unused values.\n    void RenumberValues();\n\n    /// MergeValueNumberInto - This method is called when two value numbers\n    /// are found to be equivalent.  This eliminates V1, replacing all\n    /// segments with the V1 value number with the V2 value number.  This can\n    /// cause merging of V1/V2 values numbers and compaction of the value space.\n    VNInfo* MergeValueNumberInto(VNInfo *V1, VNInfo *V2);\n\n    /// Merge all of the live segments of a specific val# in RHS into this live\n    /// range as the specified value number. The segments in RHS are allowed\n    /// to overlap with segments in the current range, it will replace the\n    /// value numbers of the overlaped live segments with the specified value\n    /// number.\n    void MergeSegmentsInAsValue(const LiveRange &RHS, VNInfo *LHSValNo);\n\n    /// MergeValueInAsValue - Merge all of the segments of a specific val#\n    /// in RHS into this live range as the specified value number.\n    /// The segments in RHS are allowed to overlap with segments in the\n    /// current range, but only if the overlapping segments have the\n    /// specified value number.\n    void MergeValueInAsValue(const LiveRange &RHS,\n                             const VNInfo *RHSValNo, VNInfo *LHSValNo);\n\n    bool empty() const { return segments.empty(); }\n\n    /// beginIndex - Return the lowest numbered slot covered.\n    SlotIndex beginIndex() const {\n      assert(!empty() && \"Call to beginIndex() on empty range.\");\n      return segments.front().start;\n    }\n\n    /// endNumber - return the maximum point of the range of the whole,\n    /// exclusive.\n    SlotIndex endIndex() const {\n      assert(!empty() && \"Call to endIndex() on empty range.\");\n      return segments.back().end;\n    }\n\n    bool expiredAt(SlotIndex index) const {\n      return index >= endIndex();\n    }\n\n    bool liveAt(SlotIndex index) const {\n      const_iterator r = find(index);\n      return r != end() && r->start <= index;\n    }\n\n    /// Return the segment that contains the specified index, or null if there\n    /// is none.\n    const Segment *getSegmentContaining(SlotIndex Idx) const {\n      const_iterator I = FindSegmentContaining(Idx);\n      return I == end() ? nullptr : &*I;\n    }\n\n    /// Return the live segment that contains the specified index, or null if\n    /// there is none.\n    Segment *getSegmentContaining(SlotIndex Idx) {\n      iterator I = FindSegmentContaining(Idx);\n      return I == end() ? nullptr : &*I;\n    }\n\n    /// getVNInfoAt - Return the VNInfo that is live at Idx, or NULL.\n    VNInfo *getVNInfoAt(SlotIndex Idx) const {\n      const_iterator I = FindSegmentContaining(Idx);\n      return I == end() ? nullptr : I->valno;\n    }\n\n    /// getVNInfoBefore - Return the VNInfo that is live up to but not\n    /// necessarilly including Idx, or NULL. Use this to find the reaching def\n    /// used by an instruction at this SlotIndex position.\n    VNInfo *getVNInfoBefore(SlotIndex Idx) const {\n      const_iterator I = FindSegmentContaining(Idx.getPrevSlot());\n      return I == end() ? nullptr : I->valno;\n    }\n\n    /// Return an iterator to the segment that contains the specified index, or\n    /// end() if there is none.\n    iterator FindSegmentContaining(SlotIndex Idx) {\n      iterator I = find(Idx);\n      return I != end() && I->start <= Idx ? I : end();\n    }\n\n    const_iterator FindSegmentContaining(SlotIndex Idx) const {\n      const_iterator I = find(Idx);\n      return I != end() && I->start <= Idx ? I : end();\n    }\n\n    /// overlaps - Return true if the intersection of the two live ranges is\n    /// not empty.\n    bool overlaps(const LiveRange &other) const {\n      if (other.empty())\n        return false;\n      return overlapsFrom(other, other.begin());\n    }\n\n    /// overlaps - Return true if the two ranges have overlapping segments\n    /// that are not coalescable according to CP.\n    ///\n    /// Overlapping segments where one range is defined by a coalescable\n    /// copy are allowed.\n    bool overlaps(const LiveRange &Other, const CoalescerPair &CP,\n                  const SlotIndexes&) const;\n\n    /// overlaps - Return true if the live range overlaps an interval specified\n    /// by [Start, End).\n    bool overlaps(SlotIndex Start, SlotIndex End) const;\n\n    /// overlapsFrom - Return true if the intersection of the two live ranges\n    /// is not empty.  The specified iterator is a hint that we can begin\n    /// scanning the Other range starting at I.\n    bool overlapsFrom(const LiveRange &Other, const_iterator StartPos) const;\n\n    /// Returns true if all segments of the @p Other live range are completely\n    /// covered by this live range.\n    /// Adjacent live ranges do not affect the covering:the liverange\n    /// [1,5](5,10] covers (3,7].\n    bool covers(const LiveRange &Other) const;\n\n    /// Add the specified Segment to this range, merging segments as\n    /// appropriate.  This returns an iterator to the inserted segment (which\n    /// may have grown since it was inserted).\n    iterator addSegment(Segment S);\n\n    /// Attempt to extend a value defined after @p StartIdx to include @p Use.\n    /// Both @p StartIdx and @p Use should be in the same basic block. In case\n    /// of subranges, an extension could be prevented by an explicit \"undef\"\n    /// caused by a <def,read-undef> on a non-overlapping lane. The list of\n    /// location of such \"undefs\" should be provided in @p Undefs.\n    /// The return value is a pair: the first element is VNInfo of the value\n    /// that was extended (possibly nullptr), the second is a boolean value\n    /// indicating whether an \"undef\" was encountered.\n    /// If this range is live before @p Use in the basic block that starts at\n    /// @p StartIdx, and there is no intervening \"undef\", extend it to be live\n    /// up to @p Use, and return the pair {value, false}. If there is no\n    /// segment before @p Use and there is no \"undef\" between @p StartIdx and\n    /// @p Use, return {nullptr, false}. If there is an \"undef\" before @p Use,\n    /// return {nullptr, true}.\n    std::pair<VNInfo*,bool> extendInBlock(ArrayRef<SlotIndex> Undefs,\n        SlotIndex StartIdx, SlotIndex Kill);\n\n    /// Simplified version of the above \"extendInBlock\", which assumes that\n    /// no register lanes are undefined by <def,read-undef> operands.\n    /// If this range is live before @p Use in the basic block that starts\n    /// at @p StartIdx, extend it to be live up to @p Use, and return the\n    /// value. If there is no segment before @p Use, return nullptr.\n    VNInfo *extendInBlock(SlotIndex StartIdx, SlotIndex Kill);\n\n    /// join - Join two live ranges (this, and other) together.  This applies\n    /// mappings to the value numbers in the LHS/RHS ranges as specified.  If\n    /// the ranges are not joinable, this aborts.\n    void join(LiveRange &Other,\n              const int *ValNoAssignments,\n              const int *RHSValNoAssignments,\n              SmallVectorImpl<VNInfo *> &NewVNInfo);\n\n    /// True iff this segment is a single segment that lies between the\n    /// specified boundaries, exclusively. Vregs live across a backedge are not\n    /// considered local. The boundaries are expected to lie within an extended\n    /// basic block, so vregs that are not live out should contain no holes.\n    bool isLocal(SlotIndex Start, SlotIndex End) const {\n      return beginIndex() > Start.getBaseIndex() &&\n        endIndex() < End.getBoundaryIndex();\n    }\n\n    /// Remove the specified segment from this range.  Note that the segment\n    /// must be a single Segment in its entirety.\n    void removeSegment(SlotIndex Start, SlotIndex End,\n                       bool RemoveDeadValNo = false);\n\n    void removeSegment(Segment S, bool RemoveDeadValNo = false) {\n      removeSegment(S.start, S.end, RemoveDeadValNo);\n    }\n\n    /// Remove segment pointed to by iterator @p I from this range.  This does\n    /// not remove dead value numbers.\n    iterator removeSegment(iterator I) {\n      return segments.erase(I);\n    }\n\n    /// Query Liveness at Idx.\n    /// The sub-instruction slot of Idx doesn't matter, only the instruction\n    /// it refers to is considered.\n    LiveQueryResult Query(SlotIndex Idx) const {\n      // Find the segment that enters the instruction.\n      const_iterator I = find(Idx.getBaseIndex());\n      const_iterator E = end();\n      if (I == E)\n        return LiveQueryResult(nullptr, nullptr, SlotIndex(), false);\n\n      // Is this an instruction live-in segment?\n      // If Idx is the start index of a basic block, include live-in segments\n      // that start at Idx.getBaseIndex().\n      VNInfo *EarlyVal = nullptr;\n      VNInfo *LateVal  = nullptr;\n      SlotIndex EndPoint;\n      bool Kill = false;\n      if (I->start <= Idx.getBaseIndex()) {\n        EarlyVal = I->valno;\n        EndPoint = I->end;\n        // Move to the potentially live-out segment.\n        if (SlotIndex::isSameInstr(Idx, I->end)) {\n          Kill = true;\n          if (++I == E)\n            return LiveQueryResult(EarlyVal, LateVal, EndPoint, Kill);\n        }\n        // Special case: A PHIDef value can have its def in the middle of a\n        // segment if the value happens to be live out of the layout\n        // predecessor.\n        // Such a value is not live-in.\n        if (EarlyVal->def == Idx.getBaseIndex())\n          EarlyVal = nullptr;\n      }\n      // I now points to the segment that may be live-through, or defined by\n      // this instr. Ignore segments starting after the current instr.\n      if (!SlotIndex::isEarlierInstr(Idx, I->start)) {\n        LateVal = I->valno;\n        EndPoint = I->end;\n      }\n      return LiveQueryResult(EarlyVal, LateVal, EndPoint, Kill);\n    }\n\n    /// removeValNo - Remove all the segments defined by the specified value#.\n    /// Also remove the value# from value# list.\n    void removeValNo(VNInfo *ValNo);\n\n    /// Returns true if the live range is zero length, i.e. no live segments\n    /// span instructions. It doesn't pay to spill such a range.\n    bool isZeroLength(SlotIndexes *Indexes) const {\n      for (const Segment &S : segments)\n        if (Indexes->getNextNonNullIndex(S.start).getBaseIndex() <\n            S.end.getBaseIndex())\n          return false;\n      return true;\n    }\n\n    // Returns true if any segment in the live range contains any of the\n    // provided slot indexes.  Slots which occur in holes between\n    // segments will not cause the function to return true.\n    bool isLiveAtIndexes(ArrayRef<SlotIndex> Slots) const;\n\n    bool operator<(const LiveRange& other) const {\n      const SlotIndex &thisIndex = beginIndex();\n      const SlotIndex &otherIndex = other.beginIndex();\n      return thisIndex < otherIndex;\n    }\n\n    /// Returns true if there is an explicit \"undef\" between @p Begin\n    /// @p End.\n    bool isUndefIn(ArrayRef<SlotIndex> Undefs, SlotIndex Begin,\n                   SlotIndex End) const {\n      return llvm::any_of(Undefs, [Begin, End](SlotIndex Idx) -> bool {\n        return Begin <= Idx && Idx < End;\n      });\n    }\n\n    /// Flush segment set into the regular segment vector.\n    /// The method is to be called after the live range\n    /// has been created, if use of the segment set was\n    /// activated in the constructor of the live range.\n    void flushSegmentSet();\n\n    /// Stores indexes from the input index sequence R at which this LiveRange\n    /// is live to the output O iterator.\n    /// R is a range of _ascending sorted_ _random_ access iterators\n    /// to the input indexes. Indexes stored at O are ascending sorted so it\n    /// can be used directly in the subsequent search (for example for\n    /// subranges). Returns true if found at least one index.\n    template <typename Range, typename OutputIt>\n    bool findIndexesLiveAt(Range &&R, OutputIt O) const {\n      assert(llvm::is_sorted(R));\n      auto Idx = R.begin(), EndIdx = R.end();\n      auto Seg = segments.begin(), EndSeg = segments.end();\n      bool Found = false;\n      while (Idx != EndIdx && Seg != EndSeg) {\n        // if the Seg is lower find first segment that is above Idx using binary\n        // search\n        if (Seg->end <= *Idx) {\n          Seg = std::upper_bound(\n              ++Seg, EndSeg, *Idx,\n              [=](std::remove_reference_t<decltype(*Idx)> V,\n                  const std::remove_reference_t<decltype(*Seg)> &S) {\n                return V < S.end;\n              });\n          if (Seg == EndSeg)\n            break;\n        }\n        auto NotLessStart = std::lower_bound(Idx, EndIdx, Seg->start);\n        if (NotLessStart == EndIdx)\n          break;\n        auto NotLessEnd = std::lower_bound(NotLessStart, EndIdx, Seg->end);\n        if (NotLessEnd != NotLessStart) {\n          Found = true;\n          O = std::copy(NotLessStart, NotLessEnd, O);\n        }\n        Idx = NotLessEnd;\n        ++Seg;\n      }\n      return Found;\n    }\n\n    void print(raw_ostream &OS) const;\n    void dump() const;\n\n    /// Walk the range and assert if any invariants fail to hold.\n    ///\n    /// Note that this is a no-op when asserts are disabled.\n#ifdef NDEBUG\n    void verify() const {}\n#else\n    void verify() const;\n#endif\n\n  protected:\n    /// Append a segment to the list of segments.\n    void append(const LiveRange::Segment S);\n\n  private:\n    friend class LiveRangeUpdater;\n    void addSegmentToSet(Segment S);\n    void markValNoForDeletion(VNInfo *V);\n  };\n\n  inline raw_ostream &operator<<(raw_ostream &OS, const LiveRange &LR) {\n    LR.print(OS);\n    return OS;\n  }\n\n  /// LiveInterval - This class represents the liveness of a register,\n  /// or stack slot.\n  class LiveInterval : public LiveRange {\n  public:\n    using super = LiveRange;\n\n    /// A live range for subregisters. The LaneMask specifies which parts of the\n    /// super register are covered by the interval.\n    /// (@sa TargetRegisterInfo::getSubRegIndexLaneMask()).\n    class SubRange : public LiveRange {\n    public:\n      SubRange *Next = nullptr;\n      LaneBitmask LaneMask;\n\n      /// Constructs a new SubRange object.\n      SubRange(LaneBitmask LaneMask) : LaneMask(LaneMask) {}\n\n      /// Constructs a new SubRange object by copying liveness from @p Other.\n      SubRange(LaneBitmask LaneMask, const LiveRange &Other,\n               BumpPtrAllocator &Allocator)\n        : LiveRange(Other, Allocator), LaneMask(LaneMask) {}\n\n      void print(raw_ostream &OS) const;\n      void dump() const;\n    };\n\n  private:\n    SubRange *SubRanges = nullptr; ///< Single linked list of subregister live\n                                   /// ranges.\n    const Register Reg; // the register or stack slot of this interval.\n    float Weight = 0.0; // weight of this interval\n\n  public:\n    Register reg() const { return Reg; }\n    float weight() const { return Weight; }\n    void incrementWeight(float Inc) { Weight += Inc; }\n    void setWeight(float Value) { Weight = Value; }\n\n    LiveInterval(unsigned Reg, float Weight) : Reg(Reg), Weight(Weight) {}\n\n    ~LiveInterval() {\n      clearSubRanges();\n    }\n\n    template<typename T>\n    class SingleLinkedListIterator {\n      T *P;\n\n    public:\n      SingleLinkedListIterator<T>(T *P) : P(P) {}\n\n      SingleLinkedListIterator<T> &operator++() {\n        P = P->Next;\n        return *this;\n      }\n      SingleLinkedListIterator<T> operator++(int) {\n        SingleLinkedListIterator res = *this;\n        ++*this;\n        return res;\n      }\n      bool operator!=(const SingleLinkedListIterator<T> &Other) const {\n        return P != Other.operator->();\n      }\n      bool operator==(const SingleLinkedListIterator<T> &Other) const {\n        return P == Other.operator->();\n      }\n      T &operator*() const {\n        return *P;\n      }\n      T *operator->() const {\n        return P;\n      }\n    };\n\n    using subrange_iterator = SingleLinkedListIterator<SubRange>;\n    using const_subrange_iterator = SingleLinkedListIterator<const SubRange>;\n\n    subrange_iterator subrange_begin() {\n      return subrange_iterator(SubRanges);\n    }\n    subrange_iterator subrange_end() {\n      return subrange_iterator(nullptr);\n    }\n\n    const_subrange_iterator subrange_begin() const {\n      return const_subrange_iterator(SubRanges);\n    }\n    const_subrange_iterator subrange_end() const {\n      return const_subrange_iterator(nullptr);\n    }\n\n    iterator_range<subrange_iterator> subranges() {\n      return make_range(subrange_begin(), subrange_end());\n    }\n\n    iterator_range<const_subrange_iterator> subranges() const {\n      return make_range(subrange_begin(), subrange_end());\n    }\n\n    /// Creates a new empty subregister live range. The range is added at the\n    /// beginning of the subrange list; subrange iterators stay valid.\n    SubRange *createSubRange(BumpPtrAllocator &Allocator,\n                             LaneBitmask LaneMask) {\n      SubRange *Range = new (Allocator) SubRange(LaneMask);\n      appendSubRange(Range);\n      return Range;\n    }\n\n    /// Like createSubRange() but the new range is filled with a copy of the\n    /// liveness information in @p CopyFrom.\n    SubRange *createSubRangeFrom(BumpPtrAllocator &Allocator,\n                                 LaneBitmask LaneMask,\n                                 const LiveRange &CopyFrom) {\n      SubRange *Range = new (Allocator) SubRange(LaneMask, CopyFrom, Allocator);\n      appendSubRange(Range);\n      return Range;\n    }\n\n    /// Returns true if subregister liveness information is available.\n    bool hasSubRanges() const {\n      return SubRanges != nullptr;\n    }\n\n    /// Removes all subregister liveness information.\n    void clearSubRanges();\n\n    /// Removes all subranges without any segments (subranges without segments\n    /// are not considered valid and should only exist temporarily).\n    void removeEmptySubRanges();\n\n    /// getSize - Returns the sum of sizes of all the LiveRange's.\n    ///\n    unsigned getSize() const;\n\n    /// isSpillable - Can this interval be spilled?\n    bool isSpillable() const { return Weight != huge_valf; }\n\n    /// markNotSpillable - Mark interval as not spillable\n    void markNotSpillable() { Weight = huge_valf; }\n\n    /// For a given lane mask @p LaneMask, compute indexes at which the\n    /// lane is marked undefined by subregister <def,read-undef> definitions.\n    void computeSubRangeUndefs(SmallVectorImpl<SlotIndex> &Undefs,\n                               LaneBitmask LaneMask,\n                               const MachineRegisterInfo &MRI,\n                               const SlotIndexes &Indexes) const;\n\n    /// Refines the subranges to support \\p LaneMask. This may only be called\n    /// for LI.hasSubrange()==true. Subregister ranges are split or created\n    /// until \\p LaneMask can be matched exactly. \\p Mod is executed on the\n    /// matching subranges.\n    ///\n    /// Example:\n    ///    Given an interval with subranges with lanemasks L0F00, L00F0 and\n    ///    L000F, refining for mask L0018. Will split the L00F0 lane into\n    ///    L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod\n    ///    function will be applied to the L0010 and L0008 subranges.\n    ///\n    /// \\p Indexes and \\p TRI are required to clean up the VNIs that\n    /// don't define the related lane masks after they get shrunk. E.g.,\n    /// when L000F gets split into L0007 and L0008 maybe only a subset\n    /// of the VNIs that defined L000F defines L0007.\n    ///\n    /// The clean up of the VNIs need to look at the actual instructions\n    /// to decide what is or is not live at a definition point. If the\n    /// update of the subranges occurs while the IR does not reflect these\n    /// changes, \\p ComposeSubRegIdx can be used to specify how the\n    /// definition are going to be rewritten.\n    /// E.g., let say we want to merge:\n    ///     V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>\n    /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>\n    /// overlap, i.e., by choosing a class where we can find \"offset + 1 == 3\".\n    /// Put differently we align V2's sub3 with V1's sub1:\n    /// V2: sub0 sub1 sub2 sub3\n    /// V1: <offset>  sub0 sub1\n    ///\n    /// This offset will look like a composed subregidx in the the class:\n    ///     V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>\n    /// =>  V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>\n    ///\n    /// Now if we didn't rewrite the uses and def of V1, all the checks for V1\n    /// need to account for this offset.\n    /// This happens during coalescing where we update the live-ranges while\n    /// still having the old IR around because updating the IR on-the-fly\n    /// would actually clobber some information on how the live-ranges that\n    /// are being updated look like.\n    void refineSubRanges(BumpPtrAllocator &Allocator, LaneBitmask LaneMask,\n                         std::function<void(LiveInterval::SubRange &)> Apply,\n                         const SlotIndexes &Indexes,\n                         const TargetRegisterInfo &TRI,\n                         unsigned ComposeSubRegIdx = 0);\n\n    bool operator<(const LiveInterval& other) const {\n      const SlotIndex &thisIndex = beginIndex();\n      const SlotIndex &otherIndex = other.beginIndex();\n      return std::tie(thisIndex, Reg) < std::tie(otherIndex, other.Reg);\n    }\n\n    void print(raw_ostream &OS) const;\n    void dump() const;\n\n    /// Walks the interval and assert if any invariants fail to hold.\n    ///\n    /// Note that this is a no-op when asserts are disabled.\n#ifdef NDEBUG\n    void verify(const MachineRegisterInfo *MRI = nullptr) const {}\n#else\n    void verify(const MachineRegisterInfo *MRI = nullptr) const;\n#endif\n\n  private:\n    /// Appends @p Range to SubRanges list.\n    void appendSubRange(SubRange *Range) {\n      Range->Next = SubRanges;\n      SubRanges = Range;\n    }\n\n    /// Free memory held by SubRange.\n    void freeSubRange(SubRange *S);\n  };\n\n  inline raw_ostream &operator<<(raw_ostream &OS,\n                                 const LiveInterval::SubRange &SR) {\n    SR.print(OS);\n    return OS;\n  }\n\n  inline raw_ostream &operator<<(raw_ostream &OS, const LiveInterval &LI) {\n    LI.print(OS);\n    return OS;\n  }\n\n  raw_ostream &operator<<(raw_ostream &OS, const LiveRange::Segment &S);\n\n  inline bool operator<(SlotIndex V, const LiveRange::Segment &S) {\n    return V < S.start;\n  }\n\n  inline bool operator<(const LiveRange::Segment &S, SlotIndex V) {\n    return S.start < V;\n  }\n\n  /// Helper class for performant LiveRange bulk updates.\n  ///\n  /// Calling LiveRange::addSegment() repeatedly can be expensive on large\n  /// live ranges because segments after the insertion point may need to be\n  /// shifted. The LiveRangeUpdater class can defer the shifting when adding\n  /// many segments in order.\n  ///\n  /// The LiveRange will be in an invalid state until flush() is called.\n  class LiveRangeUpdater {\n    LiveRange *LR;\n    SlotIndex LastStart;\n    LiveRange::iterator WriteI;\n    LiveRange::iterator ReadI;\n    SmallVector<LiveRange::Segment, 16> Spills;\n    void mergeSpills();\n\n  public:\n    /// Create a LiveRangeUpdater for adding segments to LR.\n    /// LR will temporarily be in an invalid state until flush() is called.\n    LiveRangeUpdater(LiveRange *lr = nullptr) : LR(lr) {}\n\n    ~LiveRangeUpdater() { flush(); }\n\n    /// Add a segment to LR and coalesce when possible, just like\n    /// LR.addSegment(). Segments should be added in increasing start order for\n    /// best performance.\n    void add(LiveRange::Segment);\n\n    void add(SlotIndex Start, SlotIndex End, VNInfo *VNI) {\n      add(LiveRange::Segment(Start, End, VNI));\n    }\n\n    /// Return true if the LR is currently in an invalid state, and flush()\n    /// needs to be called.\n    bool isDirty() const { return LastStart.isValid(); }\n\n    /// Flush the updater state to LR so it is valid and contains all added\n    /// segments.\n    void flush();\n\n    /// Select a different destination live range.\n    void setDest(LiveRange *lr) {\n      if (LR != lr && isDirty())\n        flush();\n      LR = lr;\n    }\n\n    /// Get the current destination live range.\n    LiveRange *getDest() const { return LR; }\n\n    void dump() const;\n    void print(raw_ostream&) const;\n  };\n\n  inline raw_ostream &operator<<(raw_ostream &OS, const LiveRangeUpdater &X) {\n    X.print(OS);\n    return OS;\n  }\n\n  /// ConnectedVNInfoEqClasses - Helper class that can divide VNInfos in a\n  /// LiveInterval into equivalence clases of connected components. A\n  /// LiveInterval that has multiple connected components can be broken into\n  /// multiple LiveIntervals.\n  ///\n  /// Given a LiveInterval that may have multiple connected components, run:\n  ///\n  ///   unsigned numComps = ConEQ.Classify(LI);\n  ///   if (numComps > 1) {\n  ///     // allocate numComps-1 new LiveIntervals into LIS[1..]\n  ///     ConEQ.Distribute(LIS);\n  /// }\n\n  class ConnectedVNInfoEqClasses {\n    LiveIntervals &LIS;\n    IntEqClasses EqClass;\n\n  public:\n    explicit ConnectedVNInfoEqClasses(LiveIntervals &lis) : LIS(lis) {}\n\n    /// Classify the values in \\p LR into connected components.\n    /// Returns the number of connected components.\n    unsigned Classify(const LiveRange &LR);\n\n    /// getEqClass - Classify creates equivalence classes numbered 0..N. Return\n    /// the equivalence class assigned the VNI.\n    unsigned getEqClass(const VNInfo *VNI) const { return EqClass[VNI->id]; }\n\n    /// Distribute values in \\p LI into a separate LiveIntervals\n    /// for each connected component. LIV must have an empty LiveInterval for\n    /// each additional connected component. The first connected component is\n    /// left in \\p LI.\n    void Distribute(LiveInterval &LI, LiveInterval *LIV[],\n                    MachineRegisterInfo &MRI);\n  };\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_LIVEINTERVAL_H\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h", "content": "//===- RegisterPressure.h - Dynamic Register Pressure -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the RegisterPressure class which can be used to track\n// MachineInstr level register pressure.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_REGISTERPRESSURE_H\n#define LLVM_CODEGEN_REGISTERPRESSURE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/SparseSet.h\"\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/CodeGen/SlotIndexes.h\"\n#include \"llvm/CodeGen/TargetRegisterInfo.h\"\n#include \"llvm/MC/LaneBitmask.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <limits>\n#include <vector>\n\nnamespace llvm {\n\nclass LiveIntervals;\nclass MachineFunction;\nclass MachineInstr;\nclass MachineRegisterInfo;\nclass RegisterClassInfo;\n\nstruct RegisterMaskPair {\n  Register RegUnit; ///< Virtual register or register unit.\n  LaneBitmask LaneMask;\n\n  RegisterMaskPair(Register RegUnit, LaneBitmask LaneMask)\n      : RegUnit(RegUnit), LaneMask(LaneMask) {}\n};\n\n/// Base class for register pressure results.\nstruct RegisterPressure {\n  /// Map of max reg pressure indexed by pressure set ID, not class ID.\n  std::vector<unsigned> MaxSetPressure;\n\n  /// List of live in virtual registers or physical register units.\n  SmallVector<RegisterMaskPair,8> LiveInRegs;\n  SmallVector<RegisterMaskPair,8> LiveOutRegs;\n\n  void dump(const TargetRegisterInfo *TRI) const;\n};\n\n/// RegisterPressure computed within a region of instructions delimited by\n/// TopIdx and BottomIdx.  During pressure computation, the maximum pressure per\n/// register pressure set is increased. Once pressure within a region is fully\n/// computed, the live-in and live-out sets are recorded.\n///\n/// This is preferable to RegionPressure when LiveIntervals are available,\n/// because delimiting regions by SlotIndex is more robust and convenient than\n/// holding block iterators. The block contents can change without invalidating\n/// the pressure result.\nstruct IntervalPressure : RegisterPressure {\n  /// Record the boundary of the region being tracked.\n  SlotIndex TopIdx;\n  SlotIndex BottomIdx;\n\n  void reset();\n\n  void openTop(SlotIndex NextTop);\n\n  void openBottom(SlotIndex PrevBottom);\n};\n\n/// RegisterPressure computed within a region of instructions delimited by\n/// TopPos and BottomPos. This is a less precise version of IntervalPressure for\n/// use when LiveIntervals are unavailable.\nstruct RegionPressure : RegisterPressure {\n  /// Record the boundary of the region being tracked.\n  MachineBasicBlock::const_iterator TopPos;\n  MachineBasicBlock::const_iterator BottomPos;\n\n  void reset();\n\n  void openTop(MachineBasicBlock::const_iterator PrevTop);\n\n  void openBottom(MachineBasicBlock::const_iterator PrevBottom);\n};\n\n/// Capture a change in pressure for a single pressure set. UnitInc may be\n/// expressed in terms of upward or downward pressure depending on the client\n/// and will be dynamically adjusted for current liveness.\n///\n/// Pressure increments are tiny, typically 1-2 units, and this is only for\n/// heuristics, so we don't check UnitInc overflow. Instead, we may have a\n/// higher level assert that pressure is consistent within a region. We also\n/// effectively ignore dead defs which don't affect heuristics much.\nclass PressureChange {\n  uint16_t PSetID = 0; // ID+1. 0=Invalid.\n  int16_t UnitInc = 0;\n\npublic:\n  PressureChange() = default;\n  PressureChange(unsigned id): PSetID(id + 1) {\n    assert(id < std::numeric_limits<uint16_t>::max() && \"PSetID overflow.\");\n  }\n\n  bool isValid() const { return PSetID > 0; }\n\n  unsigned getPSet() const {\n    assert(isValid() && \"invalid PressureChange\");\n    return PSetID - 1;\n  }\n\n  // If PSetID is invalid, return UINT16_MAX to give it lowest priority.\n  unsigned getPSetOrMax() const {\n    return (PSetID - 1) & std::numeric_limits<uint16_t>::max();\n  }\n\n  int getUnitInc() const { return UnitInc; }\n\n  void setUnitInc(int Inc) { UnitInc = Inc; }\n\n  bool operator==(const PressureChange &RHS) const {\n    return PSetID == RHS.PSetID && UnitInc == RHS.UnitInc;\n  }\n\n  void dump() const;\n};\n\n/// List of PressureChanges in order of increasing, unique PSetID.\n///\n/// Use a small fixed number, because we can fit more PressureChanges in an\n/// empty SmallVector than ever need to be tracked per register class. If more\n/// PSets are affected, then we only track the most constrained.\nclass PressureDiff {\n  // The initial design was for MaxPSets=4, but that requires PSet partitions,\n  // which are not yet implemented. (PSet partitions are equivalent PSets given\n  // the register classes actually in use within the scheduling region.)\n  enum { MaxPSets = 16 };\n\n  PressureChange PressureChanges[MaxPSets];\n\n  using iterator = PressureChange *;\n\n  iterator nonconst_begin() { return &PressureChanges[0]; }\n  iterator nonconst_end() { return &PressureChanges[MaxPSets]; }\n\npublic:\n  using const_iterator = const PressureChange *;\n\n  const_iterator begin() const { return &PressureChanges[0]; }\n  const_iterator end() const { return &PressureChanges[MaxPSets]; }\n\n  void addPressureChange(Register RegUnit, bool IsDec,\n                         const MachineRegisterInfo *MRI);\n\n  void dump(const TargetRegisterInfo &TRI) const;\n};\n\n/// List of registers defined and used by a machine instruction.\nclass RegisterOperands {\npublic:\n  /// List of virtual registers and register units read by the instruction.\n  SmallVector<RegisterMaskPair, 8> Uses;\n  /// List of virtual registers and register units defined by the\n  /// instruction which are not dead.\n  SmallVector<RegisterMaskPair, 8> Defs;\n  /// List of virtual registers and register units defined by the\n  /// instruction but dead.\n  SmallVector<RegisterMaskPair, 8> DeadDefs;\n\n  /// Analyze the given instruction \\p MI and fill in the Uses, Defs and\n  /// DeadDefs list based on the MachineOperand flags.\n  void collect(const MachineInstr &MI, const TargetRegisterInfo &TRI,\n               const MachineRegisterInfo &MRI, bool TrackLaneMasks,\n               bool IgnoreDead);\n\n  /// Use liveness information to find dead defs not marked with a dead flag\n  /// and move them to the DeadDefs vector.\n  void detectDeadDefs(const MachineInstr &MI, const LiveIntervals &LIS);\n\n  /// Use liveness information to find out which uses/defs are partially\n  /// undefined/dead and adjust the RegisterMaskPairs accordingly.\n  /// If \\p AddFlagsMI is given then missing read-undef and dead flags will be\n  /// added to the instruction.\n  void adjustLaneLiveness(const LiveIntervals &LIS,\n                          const MachineRegisterInfo &MRI, SlotIndex Pos,\n                          MachineInstr *AddFlagsMI = nullptr);\n};\n\n/// Array of PressureDiffs.\nclass PressureDiffs {\n  PressureDiff *PDiffArray = nullptr;\n  unsigned Size = 0;\n  unsigned Max = 0;\n\npublic:\n  PressureDiffs() = default;\n  ~PressureDiffs() { free(PDiffArray); }\n\n  void clear() { Size = 0; }\n\n  void init(unsigned N);\n\n  PressureDiff &operator[](unsigned Idx) {\n    assert(Idx < Size && \"PressureDiff index out of bounds\");\n    return PDiffArray[Idx];\n  }\n  const PressureDiff &operator[](unsigned Idx) const {\n    return const_cast<PressureDiffs*>(this)->operator[](Idx);\n  }\n\n  /// Record pressure difference induced by the given operand list to\n  /// node with index \\p Idx.\n  void addInstruction(unsigned Idx, const RegisterOperands &RegOpers,\n                      const MachineRegisterInfo &MRI);\n};\n\n/// Store the effects of a change in pressure on things that MI scheduler cares\n/// about.\n///\n/// Excess records the value of the largest difference in register units beyond\n/// the target's pressure limits across the affected pressure sets, where\n/// largest is defined as the absolute value of the difference. Negative\n/// ExcessUnits indicates a reduction in pressure that had already exceeded the\n/// target's limits.\n///\n/// CriticalMax records the largest increase in the tracker's max pressure that\n/// exceeds the critical limit for some pressure set determined by the client.\n///\n/// CurrentMax records the largest increase in the tracker's max pressure that\n/// exceeds the current limit for some pressure set determined by the client.\nstruct RegPressureDelta {\n  PressureChange Excess;\n  PressureChange CriticalMax;\n  PressureChange CurrentMax;\n\n  RegPressureDelta() = default;\n\n  bool operator==(const RegPressureDelta &RHS) const {\n    return Excess == RHS.Excess && CriticalMax == RHS.CriticalMax\n      && CurrentMax == RHS.CurrentMax;\n  }\n  bool operator!=(const RegPressureDelta &RHS) const {\n    return !operator==(RHS);\n  }\n  void dump() const;\n};\n\n/// A set of live virtual registers and physical register units.\n///\n/// This is a wrapper around a SparseSet which deals with mapping register unit\n/// and virtual register indexes to an index usable by the sparse set.\nclass LiveRegSet {\nprivate:\n  struct IndexMaskPair {\n    unsigned Index;\n    LaneBitmask LaneMask;\n\n    IndexMaskPair(unsigned Index, LaneBitmask LaneMask)\n        : Index(Index), LaneMask(LaneMask) {}\n\n    unsigned getSparseSetIndex() const {\n      return Index;\n    }\n  };\n\n  using RegSet = SparseSet<IndexMaskPair>;\n  RegSet Regs;\n  unsigned NumRegUnits;\n\n  unsigned getSparseIndexFromReg(Register Reg) const {\n    if (Reg.isVirtual())\n      return Register::virtReg2Index(Reg) + NumRegUnits;\n    assert(Reg < NumRegUnits);\n    return Reg;\n  }\n\n  Register getRegFromSparseIndex(unsigned SparseIndex) const {\n    if (SparseIndex >= NumRegUnits)\n      return Register::index2VirtReg(SparseIndex - NumRegUnits);\n    return Register(SparseIndex);\n  }\n\npublic:\n  void clear();\n  void init(const MachineRegisterInfo &MRI);\n\n  LaneBitmask contains(Register Reg) const {\n    unsigned SparseIndex = getSparseIndexFromReg(Reg);\n    RegSet::const_iterator I = Regs.find(SparseIndex);\n    if (I == Regs.end())\n      return LaneBitmask::getNone();\n    return I->LaneMask;\n  }\n\n  /// Mark the \\p Pair.LaneMask lanes of \\p Pair.Reg as live.\n  /// Returns the previously live lanes of \\p Pair.Reg.\n  LaneBitmask insert(RegisterMaskPair Pair) {\n    unsigned SparseIndex = getSparseIndexFromReg(Pair.RegUnit);\n    auto InsertRes = Regs.insert(IndexMaskPair(SparseIndex, Pair.LaneMask));\n    if (!InsertRes.second) {\n      LaneBitmask PrevMask = InsertRes.first->LaneMask;\n      InsertRes.first->LaneMask |= Pair.LaneMask;\n      return PrevMask;\n    }\n    return LaneBitmask::getNone();\n  }\n\n  /// Clears the \\p Pair.LaneMask lanes of \\p Pair.Reg (mark them as dead).\n  /// Returns the previously live lanes of \\p Pair.Reg.\n  LaneBitmask erase(RegisterMaskPair Pair) {\n    unsigned SparseIndex = getSparseIndexFromReg(Pair.RegUnit);\n    RegSet::iterator I = Regs.find(SparseIndex);\n    if (I == Regs.end())\n      return LaneBitmask::getNone();\n    LaneBitmask PrevMask = I->LaneMask;\n    I->LaneMask &= ~Pair.LaneMask;\n    return PrevMask;\n  }\n\n  size_t size() const {\n    return Regs.size();\n  }\n\n  template<typename ContainerT>\n  void appendTo(ContainerT &To) const {\n    for (const IndexMaskPair &P : Regs) {\n      Register Reg = getRegFromSparseIndex(P.Index);\n      if (P.LaneMask.any())\n        To.push_back(RegisterMaskPair(Reg, P.LaneMask));\n    }\n  }\n};\n\n/// Track the current register pressure at some position in the instruction\n/// stream, and remember the high water mark within the region traversed. This\n/// does not automatically consider live-through ranges. The client may\n/// independently adjust for global liveness.\n///\n/// Each RegPressureTracker only works within a MachineBasicBlock. Pressure can\n/// be tracked across a larger region by storing a RegisterPressure result at\n/// each block boundary and explicitly adjusting pressure to account for block\n/// live-in and live-out register sets.\n///\n/// RegPressureTracker holds a reference to a RegisterPressure result that it\n/// computes incrementally. During downward tracking, P.BottomIdx or P.BottomPos\n/// is invalid until it reaches the end of the block or closeRegion() is\n/// explicitly called. Similarly, P.TopIdx is invalid during upward\n/// tracking. Changing direction has the side effect of closing region, and\n/// traversing past TopIdx or BottomIdx reopens it.\nclass RegPressureTracker {\n  const MachineFunction *MF = nullptr;\n  const TargetRegisterInfo *TRI = nullptr;\n  const RegisterClassInfo *RCI = nullptr;\n  const MachineRegisterInfo *MRI;\n  const LiveIntervals *LIS = nullptr;\n\n  /// We currently only allow pressure tracking within a block.\n  const MachineBasicBlock *MBB = nullptr;\n\n  /// Track the max pressure within the region traversed so far.\n  RegisterPressure &P;\n\n  /// Run in two modes dependending on whether constructed with IntervalPressure\n  /// or RegisterPressure. If requireIntervals is false, LIS are ignored.\n  bool RequireIntervals;\n\n  /// True if UntiedDefs will be populated.\n  bool TrackUntiedDefs = false;\n\n  /// True if lanemasks should be tracked.\n  bool TrackLaneMasks = false;\n\n  /// Register pressure corresponds to liveness before this instruction\n  /// iterator. It may point to the end of the block or a DebugValue rather than\n  /// an instruction.\n  MachineBasicBlock::const_iterator CurrPos;\n\n  /// Pressure map indexed by pressure set ID, not class ID.\n  std::vector<unsigned> CurrSetPressure;\n\n  /// Set of live registers.\n  LiveRegSet LiveRegs;\n\n  /// Set of vreg defs that start a live range.\n  SparseSet<Register, VirtReg2IndexFunctor> UntiedDefs;\n  /// Live-through pressure.\n  std::vector<unsigned> LiveThruPressure;\n\npublic:\n  RegPressureTracker(IntervalPressure &rp) : P(rp), RequireIntervals(true) {}\n  RegPressureTracker(RegionPressure &rp) : P(rp), RequireIntervals(false) {}\n\n  void reset();\n\n  void init(const MachineFunction *mf, const RegisterClassInfo *rci,\n            const LiveIntervals *lis, const MachineBasicBlock *mbb,\n            MachineBasicBlock::const_iterator pos,\n            bool TrackLaneMasks, bool TrackUntiedDefs);\n\n  /// Force liveness of virtual registers or physical register\n  /// units. Particularly useful to initialize the livein/out state of the\n  /// tracker before the first call to advance/recede.\n  void addLiveRegs(ArrayRef<RegisterMaskPair> Regs);\n\n  /// Get the MI position corresponding to this register pressure.\n  MachineBasicBlock::const_iterator getPos() const { return CurrPos; }\n\n  // Reset the MI position corresponding to the register pressure. This allows\n  // schedulers to move instructions above the RegPressureTracker's\n  // CurrPos. Since the pressure is computed before CurrPos, the iterator\n  // position changes while pressure does not.\n  void setPos(MachineBasicBlock::const_iterator Pos) { CurrPos = Pos; }\n\n  /// Recede across the previous instruction.\n  void recede(SmallVectorImpl<RegisterMaskPair> *LiveUses = nullptr);\n\n  /// Recede across the previous instruction.\n  /// This \"low-level\" variant assumes that recedeSkipDebugValues() was\n  /// called previously and takes precomputed RegisterOperands for the\n  /// instruction.\n  void recede(const RegisterOperands &RegOpers,\n              SmallVectorImpl<RegisterMaskPair> *LiveUses = nullptr);\n\n  /// Recede until we find an instruction which is not a DebugValue.\n  void recedeSkipDebugValues();\n\n  /// Advance across the current instruction.\n  void advance();\n\n  /// Advance across the current instruction.\n  /// This is a \"low-level\" variant of advance() which takes precomputed\n  /// RegisterOperands of the instruction.\n  void advance(const RegisterOperands &RegOpers);\n\n  /// Finalize the region boundaries and recored live ins and live outs.\n  void closeRegion();\n\n  /// Initialize the LiveThru pressure set based on the untied defs found in\n  /// RPTracker.\n  void initLiveThru(const RegPressureTracker &RPTracker);\n\n  /// Copy an existing live thru pressure result.\n  void initLiveThru(ArrayRef<unsigned> PressureSet) {\n    LiveThruPressure.assign(PressureSet.begin(), PressureSet.end());\n  }\n\n  ArrayRef<unsigned> getLiveThru() const { return LiveThruPressure; }\n\n  /// Get the resulting register pressure over the traversed region.\n  /// This result is complete if closeRegion() was explicitly invoked.\n  RegisterPressure &getPressure() { return P; }\n  const RegisterPressure &getPressure() const { return P; }\n\n  /// Get the register set pressure at the current position, which may be less\n  /// than the pressure across the traversed region.\n  const std::vector<unsigned> &getRegSetPressureAtPos() const {\n    return CurrSetPressure;\n  }\n\n  bool isTopClosed() const;\n  bool isBottomClosed() const;\n\n  void closeTop();\n  void closeBottom();\n\n  /// Consider the pressure increase caused by traversing this instruction\n  /// bottom-up. Find the pressure set with the most change beyond its pressure\n  /// limit based on the tracker's current pressure, and record the number of\n  /// excess register units of that pressure set introduced by this instruction.\n  void getMaxUpwardPressureDelta(const MachineInstr *MI,\n                                 PressureDiff *PDiff,\n                                 RegPressureDelta &Delta,\n                                 ArrayRef<PressureChange> CriticalPSets,\n                                 ArrayRef<unsigned> MaxPressureLimit);\n\n  void getUpwardPressureDelta(const MachineInstr *MI,\n                              /*const*/ PressureDiff &PDiff,\n                              RegPressureDelta &Delta,\n                              ArrayRef<PressureChange> CriticalPSets,\n                              ArrayRef<unsigned> MaxPressureLimit) const;\n\n  /// Consider the pressure increase caused by traversing this instruction\n  /// top-down. Find the pressure set with the most change beyond its pressure\n  /// limit based on the tracker's current pressure, and record the number of\n  /// excess register units of that pressure set introduced by this instruction.\n  void getMaxDownwardPressureDelta(const MachineInstr *MI,\n                                   RegPressureDelta &Delta,\n                                   ArrayRef<PressureChange> CriticalPSets,\n                                   ArrayRef<unsigned> MaxPressureLimit);\n\n  /// Find the pressure set with the most change beyond its pressure limit after\n  /// traversing this instruction either upward or downward depending on the\n  /// closed end of the current region.\n  void getMaxPressureDelta(const MachineInstr *MI,\n                           RegPressureDelta &Delta,\n                           ArrayRef<PressureChange> CriticalPSets,\n                           ArrayRef<unsigned> MaxPressureLimit) {\n    if (isTopClosed())\n      return getMaxDownwardPressureDelta(MI, Delta, CriticalPSets,\n                                         MaxPressureLimit);\n\n    assert(isBottomClosed() && \"Uninitialized pressure tracker\");\n    return getMaxUpwardPressureDelta(MI, nullptr, Delta, CriticalPSets,\n                                     MaxPressureLimit);\n  }\n\n  /// Get the pressure of each PSet after traversing this instruction bottom-up.\n  void getUpwardPressure(const MachineInstr *MI,\n                         std::vector<unsigned> &PressureResult,\n                         std::vector<unsigned> &MaxPressureResult);\n\n  /// Get the pressure of each PSet after traversing this instruction top-down.\n  void getDownwardPressure(const MachineInstr *MI,\n                           std::vector<unsigned> &PressureResult,\n                           std::vector<unsigned> &MaxPressureResult);\n\n  void getPressureAfterInst(const MachineInstr *MI,\n                            std::vector<unsigned> &PressureResult,\n                            std::vector<unsigned> &MaxPressureResult) {\n    if (isTopClosed())\n      return getUpwardPressure(MI, PressureResult, MaxPressureResult);\n\n    assert(isBottomClosed() && \"Uninitialized pressure tracker\");\n    return getDownwardPressure(MI, PressureResult, MaxPressureResult);\n  }\n\n  bool hasUntiedDef(Register VirtReg) const {\n    return UntiedDefs.count(VirtReg);\n  }\n\n  void dump() const;\n\nprotected:\n  /// Add Reg to the live out set and increase max pressure.\n  void discoverLiveOut(RegisterMaskPair Pair);\n  /// Add Reg to the live in set and increase max pressure.\n  void discoverLiveIn(RegisterMaskPair Pair);\n\n  /// Get the SlotIndex for the first nondebug instruction including or\n  /// after the current position.\n  SlotIndex getCurrSlot() const;\n\n  void increaseRegPressure(Register RegUnit, LaneBitmask PreviousMask,\n                           LaneBitmask NewMask);\n  void decreaseRegPressure(Register RegUnit, LaneBitmask PreviousMask,\n                           LaneBitmask NewMask);\n\n  void bumpDeadDefs(ArrayRef<RegisterMaskPair> DeadDefs);\n\n  void bumpUpwardPressure(const MachineInstr *MI);\n  void bumpDownwardPressure(const MachineInstr *MI);\n\n  void discoverLiveInOrOut(RegisterMaskPair Pair,\n                           SmallVectorImpl<RegisterMaskPair> &LiveInOrOut);\n\n  LaneBitmask getLastUsedLanes(Register RegUnit, SlotIndex Pos) const;\n  LaneBitmask getLiveLanesAt(Register RegUnit, SlotIndex Pos) const;\n  LaneBitmask getLiveThroughAt(Register RegUnit, SlotIndex Pos) const;\n};\n\nvoid dumpRegSetPressure(ArrayRef<unsigned> SetPressure,\n                        const TargetRegisterInfo *TRI);\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_REGISTERPRESSURE_H\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h", "content": "//===- llvm/CodeGen/ScheduleDAG.h - Common Base Class -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file Implements the ScheduleDAG class, which is used as the common base\n/// class for instruction schedulers. This encapsulates the scheduling DAG,\n/// which is shared between SelectionDAG and MachineInstr scheduling.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_SCHEDULEDAG_H\n#define LLVM_CODEGEN_SCHEDULEDAG_H\n\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/CodeGen/TargetLowering.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <string>\n#include <vector>\n\nnamespace llvm {\n\ntemplate<class Graph> class GraphWriter;\nclass LLVMTargetMachine;\nclass MachineFunction;\nclass MachineRegisterInfo;\nclass MCInstrDesc;\nstruct MCSchedClassDesc;\nclass SDNode;\nclass SUnit;\nclass ScheduleDAG;\nclass TargetInstrInfo;\nclass TargetRegisterClass;\nclass TargetRegisterInfo;\n\n  /// Scheduling dependency. This represents one direction of an edge in the\n  /// scheduling DAG.\n  class SDep {\n  public:\n    /// These are the different kinds of scheduling dependencies.\n    enum Kind {\n      Data,        ///< Regular data dependence (aka true-dependence).\n      Anti,        ///< A register anti-dependence (aka WAR).\n      Output,      ///< A register output-dependence (aka WAW).\n      Order        ///< Any other ordering dependency.\n    };\n\n    // Strong dependencies must be respected by the scheduler. Artificial\n    // dependencies may be removed only if they are redundant with another\n    // strong dependence.\n    //\n    // Weak dependencies may be violated by the scheduling strategy, but only if\n    // the strategy can prove it is correct to do so.\n    //\n    // Strong OrderKinds must occur before \"Weak\".\n    // Weak OrderKinds must occur after \"Weak\".\n    enum OrderKind {\n      Barrier,      ///< An unknown scheduling barrier.\n      MayAliasMem,  ///< Nonvolatile load/Store instructions that may alias.\n      MustAliasMem, ///< Nonvolatile load/Store instructions that must alias.\n      Artificial,   ///< Arbitrary strong DAG edge (no real dependence).\n      Weak,         ///< Arbitrary weak DAG edge.\n      Cluster       ///< Weak DAG edge linking a chain of clustered instrs.\n    };\n\n  private:\n    /// A pointer to the depending/depended-on SUnit, and an enum\n    /// indicating the kind of the dependency.\n    PointerIntPair<SUnit *, 2, Kind> Dep;\n\n    /// A union discriminated by the dependence kind.\n    union {\n      /// For Data, Anti, and Output dependencies, the associated register. For\n      /// Data dependencies that don't currently have a register/ assigned, this\n      /// is set to zero.\n      unsigned Reg;\n\n      /// Additional information about Order dependencies.\n      unsigned OrdKind; // enum OrderKind\n    } Contents;\n\n    /// The time associated with this edge. Often this is just the value of the\n    /// Latency field of the predecessor, however advanced models may provide\n    /// additional information about specific edges.\n    unsigned Latency;\n\n  public:\n    /// Constructs a null SDep. This is only for use by container classes which\n    /// require default constructors. SUnits may not/ have null SDep edges.\n    SDep() : Dep(nullptr, Data) {}\n\n    /// Constructs an SDep with the specified values.\n    SDep(SUnit *S, Kind kind, unsigned Reg)\n      : Dep(S, kind), Contents() {\n      switch (kind) {\n      default:\n        llvm_unreachable(\"Reg given for non-register dependence!\");\n      case Anti:\n      case Output:\n        assert(Reg != 0 &&\n               \"SDep::Anti and SDep::Output must use a non-zero Reg!\");\n        Contents.Reg = Reg;\n        Latency = 0;\n        break;\n      case Data:\n        Contents.Reg = Reg;\n        Latency = 1;\n        break;\n      }\n    }\n\n    SDep(SUnit *S, OrderKind kind)\n      : Dep(S, Order), Contents(), Latency(0) {\n      Contents.OrdKind = kind;\n    }\n\n    /// Returns true if the specified SDep is equivalent except for latency.\n    bool overlaps(const SDep &Other) const;\n\n    bool operator==(const SDep &Other) const {\n      return overlaps(Other) && Latency == Other.Latency;\n    }\n\n    bool operator!=(const SDep &Other) const {\n      return !operator==(Other);\n    }\n\n    /// Returns the latency value for this edge, which roughly means the\n    /// minimum number of cycles that must elapse between the predecessor and\n    /// the successor, given that they have this edge between them.\n    unsigned getLatency() const {\n      return Latency;\n    }\n\n    /// Sets the latency for this edge.\n    void setLatency(unsigned Lat) {\n      Latency = Lat;\n    }\n\n    //// Returns the SUnit to which this edge points.\n    SUnit *getSUnit() const;\n\n    //// Assigns the SUnit to which this edge points.\n    void setSUnit(SUnit *SU);\n\n    /// Returns an enum value representing the kind of the dependence.\n    Kind getKind() const;\n\n    /// Shorthand for getKind() != SDep::Data.\n    bool isCtrl() const {\n      return getKind() != Data;\n    }\n\n    /// Tests if this is an Order dependence between two memory accesses\n    /// where both sides of the dependence access memory in non-volatile and\n    /// fully modeled ways.\n    bool isNormalMemory() const {\n      return getKind() == Order && (Contents.OrdKind == MayAliasMem\n                                    || Contents.OrdKind == MustAliasMem);\n    }\n\n    /// Tests if this is an Order dependence that is marked as a barrier.\n    bool isBarrier() const {\n      return getKind() == Order && Contents.OrdKind == Barrier;\n    }\n\n    /// Tests if this is could be any kind of memory dependence.\n    bool isNormalMemoryOrBarrier() const {\n      return (isNormalMemory() || isBarrier());\n    }\n\n    /// Tests if this is an Order dependence that is marked as\n    /// \"must alias\", meaning that the SUnits at either end of the edge have a\n    /// memory dependence on a known memory location.\n    bool isMustAlias() const {\n      return getKind() == Order && Contents.OrdKind == MustAliasMem;\n    }\n\n    /// Tests if this a weak dependence. Weak dependencies are considered DAG\n    /// edges for height computation and other heuristics, but do not force\n    /// ordering. Breaking a weak edge may require the scheduler to compensate,\n    /// for example by inserting a copy.\n    bool isWeak() const {\n      return getKind() == Order && Contents.OrdKind >= Weak;\n    }\n\n    /// Tests if this is an Order dependence that is marked as\n    /// \"artificial\", meaning it isn't necessary for correctness.\n    bool isArtificial() const {\n      return getKind() == Order && Contents.OrdKind == Artificial;\n    }\n\n    /// Tests if this is an Order dependence that is marked as \"cluster\",\n    /// meaning it is artificial and wants to be adjacent.\n    bool isCluster() const {\n      return getKind() == Order && Contents.OrdKind == Cluster;\n    }\n\n    /// Tests if this is a Data dependence that is associated with a register.\n    bool isAssignedRegDep() const {\n      return getKind() == Data && Contents.Reg != 0;\n    }\n\n    /// Returns the register associated with this edge. This is only valid on\n    /// Data, Anti, and Output edges. On Data edges, this value may be zero,\n    /// meaning there is no associated register.\n    unsigned getReg() const {\n      assert((getKind() == Data || getKind() == Anti || getKind() == Output) &&\n             \"getReg called on non-register dependence edge!\");\n      return Contents.Reg;\n    }\n\n    /// Assigns the associated register for this edge. This is only valid on\n    /// Data, Anti, and Output edges. On Anti and Output edges, this value must\n    /// not be zero. On Data edges, the value may be zero, which would mean that\n    /// no specific register is associated with this edge.\n    void setReg(unsigned Reg) {\n      assert((getKind() == Data || getKind() == Anti || getKind() == Output) &&\n             \"setReg called on non-register dependence edge!\");\n      assert((getKind() != Anti || Reg != 0) &&\n             \"SDep::Anti edge cannot use the zero register!\");\n      assert((getKind() != Output || Reg != 0) &&\n             \"SDep::Output edge cannot use the zero register!\");\n      Contents.Reg = Reg;\n    }\n\n    void dump(const TargetRegisterInfo *TRI = nullptr) const;\n  };\n\n  /// Scheduling unit. This is a node in the scheduling DAG.\n  class SUnit {\n  private:\n    enum : unsigned { BoundaryID = ~0u };\n\n    SDNode *Node = nullptr;        ///< Representative node.\n    MachineInstr *Instr = nullptr; ///< Alternatively, a MachineInstr.\n\n  public:\n    SUnit *OrigNode = nullptr; ///< If not this, the node from which this node\n                               /// was cloned. (SD scheduling only)\n\n    const MCSchedClassDesc *SchedClass =\n        nullptr; ///< nullptr or resolved SchedClass.\n\n    SmallVector<SDep, 4> Preds;  ///< All sunit predecessors.\n    SmallVector<SDep, 4> Succs;  ///< All sunit successors.\n\n    typedef SmallVectorImpl<SDep>::iterator pred_iterator;\n    typedef SmallVectorImpl<SDep>::iterator succ_iterator;\n    typedef SmallVectorImpl<SDep>::const_iterator const_pred_iterator;\n    typedef SmallVectorImpl<SDep>::const_iterator const_succ_iterator;\n\n    unsigned NodeNum = BoundaryID;     ///< Entry # of node in the node vector.\n    unsigned NodeQueueId = 0;          ///< Queue id of node.\n    unsigned NumPreds = 0;             ///< # of SDep::Data preds.\n    unsigned NumSuccs = 0;             ///< # of SDep::Data sucss.\n    unsigned NumPredsLeft = 0;         ///< # of preds not scheduled.\n    unsigned NumSuccsLeft = 0;         ///< # of succs not scheduled.\n    unsigned WeakPredsLeft = 0;        ///< # of weak preds not scheduled.\n    unsigned WeakSuccsLeft = 0;        ///< # of weak succs not scheduled.\n    unsigned short NumRegDefsLeft = 0; ///< # of reg defs with no scheduled use.\n    unsigned short Latency = 0;        ///< Node latency.\n    bool isVRegCycle      : 1;         ///< May use and def the same vreg.\n    bool isCall           : 1;         ///< Is a function call.\n    bool isCallOp         : 1;         ///< Is a function call operand.\n    bool isTwoAddress     : 1;         ///< Is a two-address instruction.\n    bool isCommutable     : 1;         ///< Is a commutable instruction.\n    bool hasPhysRegUses   : 1;         ///< Has physreg uses.\n    bool hasPhysRegDefs   : 1;         ///< Has physreg defs that are being used.\n    bool hasPhysRegClobbers : 1;       ///< Has any physreg defs, used or not.\n    bool isPending        : 1;         ///< True once pending.\n    bool isAvailable      : 1;         ///< True once available.\n    bool isScheduled      : 1;         ///< True once scheduled.\n    bool isScheduleHigh   : 1;         ///< True if preferable to schedule high.\n    bool isScheduleLow    : 1;         ///< True if preferable to schedule low.\n    bool isCloned         : 1;         ///< True if this node has been cloned.\n    bool isUnbuffered     : 1;         ///< Uses an unbuffered resource.\n    bool hasReservedResource : 1;      ///< Uses a reserved resource.\n    Sched::Preference SchedulingPref = Sched::None; ///< Scheduling preference.\n\n  private:\n    bool isDepthCurrent   : 1;         ///< True if Depth is current.\n    bool isHeightCurrent  : 1;         ///< True if Height is current.\n    unsigned Depth = 0;                ///< Node depth.\n    unsigned Height = 0;               ///< Node height.\n\n  public:\n    unsigned TopReadyCycle = 0; ///< Cycle relative to start when node is ready.\n    unsigned BotReadyCycle = 0; ///< Cycle relative to end when node is ready.\n\n    const TargetRegisterClass *CopyDstRC =\n        nullptr; ///< Is a special copy node if != nullptr.\n    const TargetRegisterClass *CopySrcRC = nullptr;\n\n    /// Constructs an SUnit for pre-regalloc scheduling to represent an\n    /// SDNode and any nodes flagged to it.\n    SUnit(SDNode *node, unsigned nodenum)\n      : Node(node), NodeNum(nodenum), isVRegCycle(false), isCall(false),\n        isCallOp(false), isTwoAddress(false), isCommutable(false),\n        hasPhysRegUses(false), hasPhysRegDefs(false), hasPhysRegClobbers(false),\n        isPending(false), isAvailable(false), isScheduled(false),\n        isScheduleHigh(false), isScheduleLow(false), isCloned(false),\n        isUnbuffered(false), hasReservedResource(false), isDepthCurrent(false),\n        isHeightCurrent(false) {}\n\n    /// Constructs an SUnit for post-regalloc scheduling to represent a\n    /// MachineInstr.\n    SUnit(MachineInstr *instr, unsigned nodenum)\n      : Instr(instr), NodeNum(nodenum), isVRegCycle(false), isCall(false),\n        isCallOp(false), isTwoAddress(false), isCommutable(false),\n        hasPhysRegUses(false), hasPhysRegDefs(false), hasPhysRegClobbers(false),\n        isPending(false), isAvailable(false), isScheduled(false),\n        isScheduleHigh(false), isScheduleLow(false), isCloned(false),\n        isUnbuffered(false), hasReservedResource(false), isDepthCurrent(false),\n        isHeightCurrent(false) {}\n\n    /// Constructs a placeholder SUnit.\n    SUnit()\n      : isVRegCycle(false), isCall(false), isCallOp(false), isTwoAddress(false),\n        isCommutable(false), hasPhysRegUses(false), hasPhysRegDefs(false),\n        hasPhysRegClobbers(false), isPending(false), isAvailable(false),\n        isScheduled(false), isScheduleHigh(false), isScheduleLow(false),\n        isCloned(false), isUnbuffered(false), hasReservedResource(false),\n        isDepthCurrent(false), isHeightCurrent(false) {}\n\n    /// Boundary nodes are placeholders for the boundary of the\n    /// scheduling region.\n    ///\n    /// BoundaryNodes can have DAG edges, including Data edges, but they do not\n    /// correspond to schedulable entities (e.g. instructions) and do not have a\n    /// valid ID. Consequently, always check for boundary nodes before accessing\n    /// an associative data structure keyed on node ID.\n    bool isBoundaryNode() const { return NodeNum == BoundaryID; }\n\n    /// Assigns the representative SDNode for this SUnit. This may be used\n    /// during pre-regalloc scheduling.\n    void setNode(SDNode *N) {\n      assert(!Instr && \"Setting SDNode of SUnit with MachineInstr!\");\n      Node = N;\n    }\n\n    /// Returns the representative SDNode for this SUnit. This may be used\n    /// during pre-regalloc scheduling.\n    SDNode *getNode() const {\n      assert(!Instr && \"Reading SDNode of SUnit with MachineInstr!\");\n      return Node;\n    }\n\n    /// Returns true if this SUnit refers to a machine instruction as\n    /// opposed to an SDNode.\n    bool isInstr() const { return Instr; }\n\n    /// Assigns the instruction for the SUnit. This may be used during\n    /// post-regalloc scheduling.\n    void setInstr(MachineInstr *MI) {\n      assert(!Node && \"Setting MachineInstr of SUnit with SDNode!\");\n      Instr = MI;\n    }\n\n    /// Returns the representative MachineInstr for this SUnit. This may be used\n    /// during post-regalloc scheduling.\n    MachineInstr *getInstr() const {\n      assert(!Node && \"Reading MachineInstr of SUnit with SDNode!\");\n      return Instr;\n    }\n\n    /// Adds the specified edge as a pred of the current node if not already.\n    /// It also adds the current node as a successor of the specified node.\n    bool addPred(const SDep &D, bool Required = true);\n\n    /// Adds a barrier edge to SU by calling addPred(), with latency 0\n    /// generally or latency 1 for a store followed by a load.\n    bool addPredBarrier(SUnit *SU) {\n      SDep Dep(SU, SDep::Barrier);\n      unsigned TrueMemOrderLatency =\n        ((SU->getInstr()->mayStore() && this->getInstr()->mayLoad()) ? 1 : 0);\n      Dep.setLatency(TrueMemOrderLatency);\n      return addPred(Dep);\n    }\n\n    /// Removes the specified edge as a pred of the current node if it exists.\n    /// It also removes the current node as a successor of the specified node.\n    void removePred(const SDep &D);\n\n    /// Returns the depth of this node, which is the length of the maximum path\n    /// up to any node which has no predecessors.\n    unsigned getDepth() const {\n      if (!isDepthCurrent)\n        const_cast<SUnit *>(this)->ComputeDepth();\n      return Depth;\n    }\n\n    /// Returns the height of this node, which is the length of the\n    /// maximum path down to any node which has no successors.\n    unsigned getHeight() const {\n      if (!isHeightCurrent)\n        const_cast<SUnit *>(this)->ComputeHeight();\n      return Height;\n    }\n\n    /// If NewDepth is greater than this node's depth value, sets it to\n    /// be the new depth value. This also recursively marks successor nodes\n    /// dirty.\n    void setDepthToAtLeast(unsigned NewDepth);\n\n    /// If NewHeight is greater than this node's height value, set it to be\n    /// the new height value. This also recursively marks predecessor nodes\n    /// dirty.\n    void setHeightToAtLeast(unsigned NewHeight);\n\n    /// Sets a flag in this node to indicate that its stored Depth value\n    /// will require recomputation the next time getDepth() is called.\n    void setDepthDirty();\n\n    /// Sets a flag in this node to indicate that its stored Height value\n    /// will require recomputation the next time getHeight() is called.\n    void setHeightDirty();\n\n    /// Tests if node N is a predecessor of this node.\n    bool isPred(const SUnit *N) const {\n      for (const SDep &Pred : Preds)\n        if (Pred.getSUnit() == N)\n          return true;\n      return false;\n    }\n\n    /// Tests if node N is a successor of this node.\n    bool isSucc(const SUnit *N) const {\n      for (const SDep &Succ : Succs)\n        if (Succ.getSUnit() == N)\n          return true;\n      return false;\n    }\n\n    bool isTopReady() const {\n      return NumPredsLeft == 0;\n    }\n    bool isBottomReady() const {\n      return NumSuccsLeft == 0;\n    }\n\n    /// Orders this node's predecessor edges such that the critical path\n    /// edge occurs first.\n    void biasCriticalPath();\n\n    void dumpAttributes() const;\n\n  private:\n    void ComputeDepth();\n    void ComputeHeight();\n  };\n\n  /// Returns true if the specified SDep is equivalent except for latency.\n  inline bool SDep::overlaps(const SDep &Other) const {\n    if (Dep != Other.Dep)\n      return false;\n    switch (Dep.getInt()) {\n    case Data:\n    case Anti:\n    case Output:\n      return Contents.Reg == Other.Contents.Reg;\n    case Order:\n      return Contents.OrdKind == Other.Contents.OrdKind;\n    }\n    llvm_unreachable(\"Invalid dependency kind!\");\n  }\n\n  //// Returns the SUnit to which this edge points.\n  inline SUnit *SDep::getSUnit() const { return Dep.getPointer(); }\n\n  //// Assigns the SUnit to which this edge points.\n  inline void SDep::setSUnit(SUnit *SU) { Dep.setPointer(SU); }\n\n  /// Returns an enum value representing the kind of the dependence.\n  inline SDep::Kind SDep::getKind() const { return Dep.getInt(); }\n\n  //===--------------------------------------------------------------------===//\n\n  /// This interface is used to plug different priorities computation\n  /// algorithms into the list scheduler. It implements the interface of a\n  /// standard priority queue, where nodes are inserted in arbitrary order and\n  /// returned in priority order.  The computation of the priority and the\n  /// representation of the queue are totally up to the implementation to\n  /// decide.\n  class SchedulingPriorityQueue {\n    virtual void anchor();\n\n    unsigned CurCycle = 0;\n    bool HasReadyFilter;\n\n  public:\n    SchedulingPriorityQueue(bool rf = false) :  HasReadyFilter(rf) {}\n\n    virtual ~SchedulingPriorityQueue() = default;\n\n    virtual bool isBottomUp() const = 0;\n\n    virtual void initNodes(std::vector<SUnit> &SUnits) = 0;\n    virtual void addNode(const SUnit *SU) = 0;\n    virtual void updateNode(const SUnit *SU) = 0;\n    virtual void releaseState() = 0;\n\n    virtual bool empty() const = 0;\n\n    bool hasReadyFilter() const { return HasReadyFilter; }\n\n    virtual bool tracksRegPressure() const { return false; }\n\n    virtual bool isReady(SUnit *) const {\n      assert(!HasReadyFilter && \"The ready filter must override isReady()\");\n      return true;\n    }\n\n    virtual void push(SUnit *U) = 0;\n\n    void push_all(const std::vector<SUnit *> &Nodes) {\n      for (std::vector<SUnit *>::const_iterator I = Nodes.begin(),\n           E = Nodes.end(); I != E; ++I)\n        push(*I);\n    }\n\n    virtual SUnit *pop() = 0;\n\n    virtual void remove(SUnit *SU) = 0;\n\n    virtual void dump(ScheduleDAG *) const {}\n\n    /// As each node is scheduled, this method is invoked.  This allows the\n    /// priority function to adjust the priority of related unscheduled nodes,\n    /// for example.\n    virtual void scheduledNode(SUnit *) {}\n\n    virtual void unscheduledNode(SUnit *) {}\n\n    void setCurCycle(unsigned Cycle) {\n      CurCycle = Cycle;\n    }\n\n    unsigned getCurCycle() const {\n      return CurCycle;\n    }\n  };\n\n  class ScheduleDAG {\n  public:\n    const LLVMTargetMachine &TM;        ///< Target processor\n    const TargetInstrInfo *TII;         ///< Target instruction information\n    const TargetRegisterInfo *TRI;      ///< Target processor register info\n    MachineFunction &MF;                ///< Machine function\n    MachineRegisterInfo &MRI;           ///< Virtual/real register map\n    std::vector<SUnit> SUnits;          ///< The scheduling units.\n    SUnit EntrySU;                      ///< Special node for the region entry.\n    SUnit ExitSU;                       ///< Special node for the region exit.\n\n#ifdef NDEBUG\n    static const bool StressSched = false;\n#else\n    bool StressSched;\n#endif\n\n    explicit ScheduleDAG(MachineFunction &mf);\n\n    virtual ~ScheduleDAG();\n\n    /// Clears the DAG state (between regions).\n    void clearDAG();\n\n    /// Returns the MCInstrDesc of this SUnit.\n    /// Returns NULL for SDNodes without a machine opcode.\n    const MCInstrDesc *getInstrDesc(const SUnit *SU) const {\n      if (SU->isInstr()) return &SU->getInstr()->getDesc();\n      return getNodeDesc(SU->getNode());\n    }\n\n    /// Pops up a GraphViz/gv window with the ScheduleDAG rendered using 'dot'.\n    virtual void viewGraph(const Twine &Name, const Twine &Title);\n    virtual void viewGraph();\n\n    virtual void dumpNode(const SUnit &SU) const = 0;\n    virtual void dump() const = 0;\n    void dumpNodeName(const SUnit &SU) const;\n\n    /// Returns a label for an SUnit node in a visualization of the ScheduleDAG.\n    virtual std::string getGraphNodeLabel(const SUnit *SU) const = 0;\n\n    /// Returns a label for the region of code covered by the DAG.\n    virtual std::string getDAGName() const = 0;\n\n    /// Adds custom features for a visualization of the ScheduleDAG.\n    virtual void addCustomGraphFeatures(GraphWriter<ScheduleDAG*> &) const {}\n\n#ifndef NDEBUG\n    /// Verifies that all SUnits were scheduled and that their state is\n    /// consistent. Returns the number of scheduled SUnits.\n    unsigned VerifyScheduledDAG(bool isBottomUp);\n#endif\n\n  protected:\n    void dumpNodeAll(const SUnit &SU) const;\n\n  private:\n    /// Returns the MCInstrDesc of this SDNode or NULL.\n    const MCInstrDesc *getNodeDesc(const SDNode *Node) const;\n  };\n\n  class SUnitIterator : public std::iterator<std::forward_iterator_tag,\n                                             SUnit, ptrdiff_t> {\n    SUnit *Node;\n    unsigned Operand;\n\n    SUnitIterator(SUnit *N, unsigned Op) : Node(N), Operand(Op) {}\n\n  public:\n    bool operator==(const SUnitIterator& x) const {\n      return Operand == x.Operand;\n    }\n    bool operator!=(const SUnitIterator& x) const { return !operator==(x); }\n\n    pointer operator*() const {\n      return Node->Preds[Operand].getSUnit();\n    }\n    pointer operator->() const { return operator*(); }\n\n    SUnitIterator& operator++() {                // Preincrement\n      ++Operand;\n      return *this;\n    }\n    SUnitIterator operator++(int) { // Postincrement\n      SUnitIterator tmp = *this; ++*this; return tmp;\n    }\n\n    static SUnitIterator begin(SUnit *N) { return SUnitIterator(N, 0); }\n    static SUnitIterator end  (SUnit *N) {\n      return SUnitIterator(N, (unsigned)N->Preds.size());\n    }\n\n    unsigned getOperand() const { return Operand; }\n    const SUnit *getNode() const { return Node; }\n\n    /// Tests if this is not an SDep::Data dependence.\n    bool isCtrlDep() const {\n      return getSDep().isCtrl();\n    }\n    bool isArtificialDep() const {\n      return getSDep().isArtificial();\n    }\n    const SDep &getSDep() const {\n      return Node->Preds[Operand];\n    }\n  };\n\n  template <> struct GraphTraits<SUnit*> {\n    typedef SUnit *NodeRef;\n    typedef SUnitIterator ChildIteratorType;\n    static NodeRef getEntryNode(SUnit *N) { return N; }\n    static ChildIteratorType child_begin(NodeRef N) {\n      return SUnitIterator::begin(N);\n    }\n    static ChildIteratorType child_end(NodeRef N) {\n      return SUnitIterator::end(N);\n    }\n  };\n\n  template <> struct GraphTraits<ScheduleDAG*> : public GraphTraits<SUnit*> {\n    typedef pointer_iterator<std::vector<SUnit>::iterator> nodes_iterator;\n    static nodes_iterator nodes_begin(ScheduleDAG *G) {\n      return nodes_iterator(G->SUnits.begin());\n    }\n    static nodes_iterator nodes_end(ScheduleDAG *G) {\n      return nodes_iterator(G->SUnits.end());\n    }\n  };\n\n  /// This class can compute a topological ordering for SUnits and provides\n  /// methods for dynamically updating the ordering as new edges are added.\n  ///\n  /// This allows a very fast implementation of IsReachable, for example.\n  class ScheduleDAGTopologicalSort {\n    /// A reference to the ScheduleDAG's SUnits.\n    std::vector<SUnit> &SUnits;\n    SUnit *ExitSU;\n\n    // Have any new nodes been added?\n    bool Dirty = false;\n\n    // Outstanding added edges, that have not been applied to the ordering.\n    SmallVector<std::pair<SUnit *, SUnit *>, 16> Updates;\n\n    /// Maps topological index to the node number.\n    std::vector<int> Index2Node;\n    /// Maps the node number to its topological index.\n    std::vector<int> Node2Index;\n    /// a set of nodes visited during a DFS traversal.\n    BitVector Visited;\n\n    /// Makes a DFS traversal and mark all nodes affected by the edge insertion.\n    /// These nodes will later get new topological indexes by means of the Shift\n    /// method.\n    void DFS(const SUnit *SU, int UpperBound, bool& HasLoop);\n\n    /// Reassigns topological indexes for the nodes in the DAG to\n    /// preserve the topological ordering.\n    void Shift(BitVector& Visited, int LowerBound, int UpperBound);\n\n    /// Assigns the topological index to the node n.\n    void Allocate(int n, int index);\n\n    /// Fix the ordering, by either recomputing from scratch or by applying\n    /// any outstanding updates. Uses a heuristic to estimate what will be\n    /// cheaper.\n    void FixOrder();\n\n  public:\n    ScheduleDAGTopologicalSort(std::vector<SUnit> &SUnits, SUnit *ExitSU);\n\n    /// Add a SUnit without predecessors to the end of the topological order. It\n    /// also must be the first new node added to the DAG.\n    void AddSUnitWithoutPredecessors(const SUnit *SU);\n\n    /// Creates the initial topological ordering from the DAG to be scheduled.\n    void InitDAGTopologicalSorting();\n\n    /// Returns an array of SUs that are both in the successor\n    /// subtree of StartSU and in the predecessor subtree of TargetSU.\n    /// StartSU and TargetSU are not in the array.\n    /// Success is false if TargetSU is not in the successor subtree of\n    /// StartSU, else it is true.\n    std::vector<int> GetSubGraph(const SUnit &StartSU, const SUnit &TargetSU,\n                                 bool &Success);\n\n    /// Checks if \\p SU is reachable from \\p TargetSU.\n    bool IsReachable(const SUnit *SU, const SUnit *TargetSU);\n\n    /// Returns true if addPred(TargetSU, SU) creates a cycle.\n    bool WillCreateCycle(SUnit *TargetSU, SUnit *SU);\n\n    /// Updates the topological ordering to accommodate an edge to be\n    /// added from SUnit \\p X to SUnit \\p Y.\n    void AddPred(SUnit *Y, SUnit *X);\n\n    /// Queues an update to the topological ordering to accommodate an edge to\n    /// be added from SUnit \\p X to SUnit \\p Y.\n    void AddPredQueued(SUnit *Y, SUnit *X);\n\n    /// Updates the topological ordering to accommodate an an edge to be\n    /// removed from the specified node \\p N from the predecessors of the\n    /// current node \\p M.\n    void RemovePred(SUnit *M, SUnit *N);\n\n    /// Mark the ordering as temporarily broken, after a new node has been\n    /// added.\n    void MarkDirty() { Dirty = true; }\n\n    typedef std::vector<int>::iterator iterator;\n    typedef std::vector<int>::const_iterator const_iterator;\n    iterator begin() { return Index2Node.begin(); }\n    const_iterator begin() const { return Index2Node.begin(); }\n    iterator end() { return Index2Node.end(); }\n    const_iterator end() const { return Index2Node.end(); }\n\n    typedef std::vector<int>::reverse_iterator reverse_iterator;\n    typedef std::vector<int>::const_reverse_iterator const_reverse_iterator;\n    reverse_iterator rbegin() { return Index2Node.rbegin(); }\n    const_reverse_iterator rbegin() const { return Index2Node.rbegin(); }\n    reverse_iterator rend() { return Index2Node.rend(); }\n    const_reverse_iterator rend() const { return Index2Node.rend(); }\n  };\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_SCHEDULEDAG_H\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h", "content": "//===- ScheduleDFS.h - ILP metric for ScheduleDAGInstrs ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Definition of an ILP metric for machine level instruction scheduling.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_SCHEDULEDFS_H\n#define LLVM_CODEGEN_SCHEDULEDFS_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/CodeGen/ScheduleDAG.h\"\n#include <cassert>\n#include <cstdint>\n#include <vector>\n\nnamespace llvm {\n\ntemplate <typename T> class ArrayRef;\nclass raw_ostream;\n\n/// Represent the ILP of the subDAG rooted at a DAG node.\n///\n/// ILPValues summarize the DAG subtree rooted at each node. ILPValues are\n/// valid for all nodes regardless of their subtree membership.\n///\n/// When computed using bottom-up DFS, this metric assumes that the DAG is a\n/// forest of trees with roots at the bottom of the schedule branching upward.\nstruct ILPValue {\n  unsigned InstrCount;\n  /// Length may either correspond to depth or height, depending on direction,\n  /// and cycles or nodes depending on context.\n  unsigned Length;\n\n  ILPValue(unsigned count, unsigned length):\n    InstrCount(count), Length(length) {}\n\n  // Order by the ILP metric's value.\n  bool operator<(ILPValue RHS) const {\n    return (uint64_t)InstrCount * RHS.Length\n      < (uint64_t)Length * RHS.InstrCount;\n  }\n  bool operator>(ILPValue RHS) const {\n    return RHS < *this;\n  }\n  bool operator<=(ILPValue RHS) const {\n    return (uint64_t)InstrCount * RHS.Length\n      <= (uint64_t)Length * RHS.InstrCount;\n  }\n  bool operator>=(ILPValue RHS) const {\n    return RHS <= *this;\n  }\n\n  void print(raw_ostream &OS) const;\n\n  void dump() const;\n};\n\n/// Compute the values of each DAG node for various metrics during DFS.\nclass SchedDFSResult {\n  friend class SchedDFSImpl;\n\n  static const unsigned InvalidSubtreeID = ~0u;\n\n  /// Per-SUnit data computed during DFS for various metrics.\n  ///\n  /// A node's SubtreeID is set to itself when it is visited to indicate that it\n  /// is the root of a subtree. Later it is set to its parent to indicate an\n  /// interior node. Finally, it is set to a representative subtree ID during\n  /// finalization.\n  struct NodeData {\n    unsigned InstrCount = 0;\n    unsigned SubtreeID = InvalidSubtreeID;\n\n    NodeData() = default;\n  };\n\n  /// Per-Subtree data computed during DFS.\n  struct TreeData {\n    unsigned ParentTreeID = InvalidSubtreeID;\n    unsigned SubInstrCount = 0;\n\n    TreeData() = default;\n  };\n\n  /// Record a connection between subtrees and the connection level.\n  struct Connection {\n    unsigned TreeID;\n    unsigned Level;\n\n    Connection(unsigned tree, unsigned level): TreeID(tree), Level(level) {}\n  };\n\n  bool IsBottomUp;\n  unsigned SubtreeLimit;\n  /// DFS results for each SUnit in this DAG.\n  std::vector<NodeData> DFSNodeData;\n\n  // Store per-tree data indexed on tree ID,\n  SmallVector<TreeData, 16> DFSTreeData;\n\n  // For each subtree discovered during DFS, record its connections to other\n  // subtrees.\n  std::vector<SmallVector<Connection, 4>> SubtreeConnections;\n\n  /// Cache the current connection level of each subtree.\n  /// This mutable array is updated during scheduling.\n  std::vector<unsigned> SubtreeConnectLevels;\n\npublic:\n  SchedDFSResult(bool IsBU, unsigned lim)\n    : IsBottomUp(IsBU), SubtreeLimit(lim) {}\n\n  /// Get the node cutoff before subtrees are considered significant.\n  unsigned getSubtreeLimit() const { return SubtreeLimit; }\n\n  /// Return true if this DFSResult is uninitialized.\n  ///\n  /// resize() initializes DFSResult, while compute() populates it.\n  bool empty() const { return DFSNodeData.empty(); }\n\n  /// Clear the results.\n  void clear() {\n    DFSNodeData.clear();\n    DFSTreeData.clear();\n    SubtreeConnections.clear();\n    SubtreeConnectLevels.clear();\n  }\n\n  /// Initialize the result data with the size of the DAG.\n  void resize(unsigned NumSUnits) {\n    DFSNodeData.resize(NumSUnits);\n  }\n\n  /// Compute various metrics for the DAG with given roots.\n  void compute(ArrayRef<SUnit> SUnits);\n\n  /// Get the number of instructions in the given subtree and its\n  /// children.\n  unsigned getNumInstrs(const SUnit *SU) const {\n    return DFSNodeData[SU->NodeNum].InstrCount;\n  }\n\n  /// Get the number of instructions in the given subtree not including\n  /// children.\n  unsigned getNumSubInstrs(unsigned SubtreeID) const {\n    return DFSTreeData[SubtreeID].SubInstrCount;\n  }\n\n  /// Get the ILP value for a DAG node.\n  ///\n  /// A leaf node has an ILP of 1/1.\n  ILPValue getILP(const SUnit *SU) const {\n    return ILPValue(DFSNodeData[SU->NodeNum].InstrCount, 1 + SU->getDepth());\n  }\n\n  /// The number of subtrees detected in this DAG.\n  unsigned getNumSubtrees() const { return SubtreeConnectLevels.size(); }\n\n  /// Get the ID of the subtree the given DAG node belongs to.\n  ///\n  /// For convenience, if DFSResults have not been computed yet, give everything\n  /// tree ID 0.\n  unsigned getSubtreeID(const SUnit *SU) const {\n    if (empty())\n      return 0;\n    assert(SU->NodeNum < DFSNodeData.size() &&  \"New Node\");\n    return DFSNodeData[SU->NodeNum].SubtreeID;\n  }\n\n  /// Get the connection level of a subtree.\n  ///\n  /// For bottom-up trees, the connection level is the latency depth (in cycles)\n  /// of the deepest connection to another subtree.\n  unsigned getSubtreeLevel(unsigned SubtreeID) const {\n    return SubtreeConnectLevels[SubtreeID];\n  }\n\n  /// Scheduler callback to update SubtreeConnectLevels when a tree is\n  /// initially scheduled.\n  void scheduleTree(unsigned SubtreeID);\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const ILPValue &Val);\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_SCHEDULEDFS_H\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h", "content": "//===- llvm/CodeGen/SlotIndexes.h - Slot indexes representation -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements SlotIndex and related classes. The purpose of SlotIndex\n// is to describe a position at which a register can become live, or cease to\n// be live.\n//\n// SlotIndex is mostly a proxy for entries of the SlotIndexList, a class which\n// is held is LiveIntervals and provides the real numbering. This allows\n// LiveIntervals to perform largely transparent renumbering.\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_SLOTINDEXES_H\n#define LLVM_CODEGEN_SLOTINDEXES_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/IntervalMap.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/ilist.h\"\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/MachineFunctionPass.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/CodeGen/MachineInstrBundle.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <algorithm>\n#include <cassert>\n#include <iterator>\n#include <utility>\n\nnamespace llvm {\n\nclass raw_ostream;\n\n  /// This class represents an entry in the slot index list held in the\n  /// SlotIndexes pass. It should not be used directly. See the\n  /// SlotIndex & SlotIndexes classes for the public interface to this\n  /// information.\n  class IndexListEntry : public ilist_node<IndexListEntry> {\n    MachineInstr *mi;\n    unsigned index;\n\n  public:\n    IndexListEntry(MachineInstr *mi, unsigned index) : mi(mi), index(index) {}\n\n    MachineInstr* getInstr() const { return mi; }\n    void setInstr(MachineInstr *mi) {\n      this->mi = mi;\n    }\n\n    unsigned getIndex() const { return index; }\n    void setIndex(unsigned index) {\n      this->index = index;\n    }\n\n#ifdef EXPENSIVE_CHECKS\n    // When EXPENSIVE_CHECKS is defined, \"erased\" index list entries will\n    // actually be moved to a \"graveyard\" list, and have their pointers\n    // poisoned, so that dangling SlotIndex access can be reliably detected.\n    void setPoison() {\n      intptr_t tmp = reinterpret_cast<intptr_t>(mi);\n      assert(((tmp & 0x1) == 0x0) && \"Pointer already poisoned?\");\n      tmp |= 0x1;\n      mi = reinterpret_cast<MachineInstr*>(tmp);\n    }\n\n    bool isPoisoned() const { return (reinterpret_cast<intptr_t>(mi) & 0x1) == 0x1; }\n#endif // EXPENSIVE_CHECKS\n  };\n\n  template <>\n  struct ilist_alloc_traits<IndexListEntry>\n      : public ilist_noalloc_traits<IndexListEntry> {};\n\n  /// SlotIndex - An opaque wrapper around machine indexes.\n  class SlotIndex {\n    friend class SlotIndexes;\n\n    enum Slot {\n      /// Basic block boundary.  Used for live ranges entering and leaving a\n      /// block without being live in the layout neighbor.  Also used as the\n      /// def slot of PHI-defs.\n      Slot_Block,\n\n      /// Early-clobber register use/def slot.  A live range defined at\n      /// Slot_EarlyClobber interferes with normal live ranges killed at\n      /// Slot_Register.  Also used as the kill slot for live ranges tied to an\n      /// early-clobber def.\n      Slot_EarlyClobber,\n\n      /// Normal register use/def slot.  Normal instructions kill and define\n      /// register live ranges at this slot.\n      Slot_Register,\n\n      /// Dead def kill point.  Kill slot for a live range that is defined by\n      /// the same instruction (Slot_Register or Slot_EarlyClobber), but isn't\n      /// used anywhere.\n      Slot_Dead,\n\n      Slot_Count\n    };\n\n    PointerIntPair<IndexListEntry*, 2, unsigned> lie;\n\n    SlotIndex(IndexListEntry *entry, unsigned slot)\n      : lie(entry, slot) {}\n\n    IndexListEntry* listEntry() const {\n      assert(isValid() && \"Attempt to compare reserved index.\");\n#ifdef EXPENSIVE_CHECKS\n      assert(!lie.getPointer()->isPoisoned() &&\n             \"Attempt to access deleted list-entry.\");\n#endif // EXPENSIVE_CHECKS\n      return lie.getPointer();\n    }\n\n    unsigned getIndex() const {\n      return listEntry()->getIndex() | getSlot();\n    }\n\n    /// Returns the slot for this SlotIndex.\n    Slot getSlot() const {\n      return static_cast<Slot>(lie.getInt());\n    }\n\n  public:\n    enum {\n      /// The default distance between instructions as returned by distance().\n      /// This may vary as instructions are inserted and removed.\n      InstrDist = 4 * Slot_Count\n    };\n\n    /// Construct an invalid index.\n    SlotIndex() = default;\n\n    // Construct a new slot index from the given one, and set the slot.\n    SlotIndex(const SlotIndex &li, Slot s) : lie(li.listEntry(), unsigned(s)) {\n      assert(lie.getPointer() != nullptr &&\n             \"Attempt to construct index with 0 pointer.\");\n    }\n\n    /// Returns true if this is a valid index. Invalid indices do\n    /// not point into an index table, and cannot be compared.\n    bool isValid() const {\n      return lie.getPointer();\n    }\n\n    /// Return true for a valid index.\n    explicit operator bool() const { return isValid(); }\n\n    /// Print this index to the given raw_ostream.\n    void print(raw_ostream &os) const;\n\n    /// Dump this index to stderr.\n    void dump() const;\n\n    /// Compare two SlotIndex objects for equality.\n    bool operator==(SlotIndex other) const {\n      return lie == other.lie;\n    }\n    /// Compare two SlotIndex objects for inequality.\n    bool operator!=(SlotIndex other) const {\n      return lie != other.lie;\n    }\n\n    /// Compare two SlotIndex objects. Return true if the first index\n    /// is strictly lower than the second.\n    bool operator<(SlotIndex other) const {\n      return getIndex() < other.getIndex();\n    }\n    /// Compare two SlotIndex objects. Return true if the first index\n    /// is lower than, or equal to, the second.\n    bool operator<=(SlotIndex other) const {\n      return getIndex() <= other.getIndex();\n    }\n\n    /// Compare two SlotIndex objects. Return true if the first index\n    /// is greater than the second.\n    bool operator>(SlotIndex other) const {\n      return getIndex() > other.getIndex();\n    }\n\n    /// Compare two SlotIndex objects. Return true if the first index\n    /// is greater than, or equal to, the second.\n    bool operator>=(SlotIndex other) const {\n      return getIndex() >= other.getIndex();\n    }\n\n    /// isSameInstr - Return true if A and B refer to the same instruction.\n    static bool isSameInstr(SlotIndex A, SlotIndex B) {\n      return A.lie.getPointer() == B.lie.getPointer();\n    }\n\n    /// isEarlierInstr - Return true if A refers to an instruction earlier than\n    /// B. This is equivalent to A < B && !isSameInstr(A, B).\n    static bool isEarlierInstr(SlotIndex A, SlotIndex B) {\n      return A.listEntry()->getIndex() < B.listEntry()->getIndex();\n    }\n\n    /// Return true if A refers to the same instruction as B or an earlier one.\n    /// This is equivalent to !isEarlierInstr(B, A).\n    static bool isEarlierEqualInstr(SlotIndex A, SlotIndex B) {\n      return !isEarlierInstr(B, A);\n    }\n\n    /// Return the distance from this index to the given one.\n    int distance(SlotIndex other) const {\n      return other.getIndex() - getIndex();\n    }\n\n    /// Return the scaled distance from this index to the given one, where all\n    /// slots on the same instruction have zero distance.\n    int getInstrDistance(SlotIndex other) const {\n      return (other.listEntry()->getIndex() - listEntry()->getIndex())\n        / Slot_Count;\n    }\n\n    /// isBlock - Returns true if this is a block boundary slot.\n    bool isBlock() const { return getSlot() == Slot_Block; }\n\n    /// isEarlyClobber - Returns true if this is an early-clobber slot.\n    bool isEarlyClobber() const { return getSlot() == Slot_EarlyClobber; }\n\n    /// isRegister - Returns true if this is a normal register use/def slot.\n    /// Note that early-clobber slots may also be used for uses and defs.\n    bool isRegister() const { return getSlot() == Slot_Register; }\n\n    /// isDead - Returns true if this is a dead def kill slot.\n    bool isDead() const { return getSlot() == Slot_Dead; }\n\n    /// Returns the base index for associated with this index. The base index\n    /// is the one associated with the Slot_Block slot for the instruction\n    /// pointed to by this index.\n    SlotIndex getBaseIndex() const {\n      return SlotIndex(listEntry(), Slot_Block);\n    }\n\n    /// Returns the boundary index for associated with this index. The boundary\n    /// index is the one associated with the Slot_Block slot for the instruction\n    /// pointed to by this index.\n    SlotIndex getBoundaryIndex() const {\n      return SlotIndex(listEntry(), Slot_Dead);\n    }\n\n    /// Returns the register use/def slot in the current instruction for a\n    /// normal or early-clobber def.\n    SlotIndex getRegSlot(bool EC = false) const {\n      return SlotIndex(listEntry(), EC ? Slot_EarlyClobber : Slot_Register);\n    }\n\n    /// Returns the dead def kill slot for the current instruction.\n    SlotIndex getDeadSlot() const {\n      return SlotIndex(listEntry(), Slot_Dead);\n    }\n\n    /// Returns the next slot in the index list. This could be either the\n    /// next slot for the instruction pointed to by this index or, if this\n    /// index is a STORE, the first slot for the next instruction.\n    /// WARNING: This method is considerably more expensive than the methods\n    /// that return specific slots (getUseIndex(), etc). If you can - please\n    /// use one of those methods.\n    SlotIndex getNextSlot() const {\n      Slot s = getSlot();\n      if (s == Slot_Dead) {\n        return SlotIndex(&*++listEntry()->getIterator(), Slot_Block);\n      }\n      return SlotIndex(listEntry(), s + 1);\n    }\n\n    /// Returns the next index. This is the index corresponding to the this\n    /// index's slot, but for the next instruction.\n    SlotIndex getNextIndex() const {\n      return SlotIndex(&*++listEntry()->getIterator(), getSlot());\n    }\n\n    /// Returns the previous slot in the index list. This could be either the\n    /// previous slot for the instruction pointed to by this index or, if this\n    /// index is a Slot_Block, the last slot for the previous instruction.\n    /// WARNING: This method is considerably more expensive than the methods\n    /// that return specific slots (getUseIndex(), etc). If you can - please\n    /// use one of those methods.\n    SlotIndex getPrevSlot() const {\n      Slot s = getSlot();\n      if (s == Slot_Block) {\n        return SlotIndex(&*--listEntry()->getIterator(), Slot_Dead);\n      }\n      return SlotIndex(listEntry(), s - 1);\n    }\n\n    /// Returns the previous index. This is the index corresponding to this\n    /// index's slot, but for the previous instruction.\n    SlotIndex getPrevIndex() const {\n      return SlotIndex(&*--listEntry()->getIterator(), getSlot());\n    }\n  };\n\n  inline raw_ostream& operator<<(raw_ostream &os, SlotIndex li) {\n    li.print(os);\n    return os;\n  }\n\n  using IdxMBBPair = std::pair<SlotIndex, MachineBasicBlock *>;\n\n  /// SlotIndexes pass.\n  ///\n  /// This pass assigns indexes to each instruction.\n  class SlotIndexes : public MachineFunctionPass {\n  private:\n    // IndexListEntry allocator.\n    BumpPtrAllocator ileAllocator;\n\n    using IndexList = ilist<IndexListEntry>;\n    IndexList indexList;\n\n    MachineFunction *mf;\n\n    using Mi2IndexMap = DenseMap<const MachineInstr *, SlotIndex>;\n    Mi2IndexMap mi2iMap;\n\n    /// MBBRanges - Map MBB number to (start, stop) indexes.\n    SmallVector<std::pair<SlotIndex, SlotIndex>, 8> MBBRanges;\n\n    /// Idx2MBBMap - Sorted list of pairs of index of first instruction\n    /// and MBB id.\n    SmallVector<IdxMBBPair, 8> idx2MBBMap;\n\n    IndexListEntry* createEntry(MachineInstr *mi, unsigned index) {\n      IndexListEntry *entry =\n          static_cast<IndexListEntry *>(ileAllocator.Allocate(\n              sizeof(IndexListEntry), alignof(IndexListEntry)));\n\n      new (entry) IndexListEntry(mi, index);\n\n      return entry;\n    }\n\n    /// Renumber locally after inserting curItr.\n    void renumberIndexes(IndexList::iterator curItr);\n\n  public:\n    static char ID;\n\n    SlotIndexes();\n\n    ~SlotIndexes() override;\n\n    void getAnalysisUsage(AnalysisUsage &au) const override;\n    void releaseMemory() override;\n\n    bool runOnMachineFunction(MachineFunction &fn) override;\n\n    /// Dump the indexes.\n    void dump() const;\n\n    /// Repair indexes after adding and removing instructions.\n    void repairIndexesInRange(MachineBasicBlock *MBB,\n                              MachineBasicBlock::iterator Begin,\n                              MachineBasicBlock::iterator End);\n\n    /// Returns the zero index for this analysis.\n    SlotIndex getZeroIndex() {\n      assert(indexList.front().getIndex() == 0 && \"First index is not 0?\");\n      return SlotIndex(&indexList.front(), 0);\n    }\n\n    /// Returns the base index of the last slot in this analysis.\n    SlotIndex getLastIndex() {\n      return SlotIndex(&indexList.back(), 0);\n    }\n\n    /// Returns true if the given machine instr is mapped to an index,\n    /// otherwise returns false.\n    bool hasIndex(const MachineInstr &instr) const {\n      return mi2iMap.count(&instr);\n    }\n\n    /// Returns the base index for the given instruction.\n    SlotIndex getInstructionIndex(const MachineInstr &MI,\n                                  bool IgnoreBundle = false) const {\n      // Instructions inside a bundle have the same number as the bundle itself.\n      auto BundleStart = getBundleStart(MI.getIterator());\n      auto BundleEnd = getBundleEnd(MI.getIterator());\n      // Use the first non-debug instruction in the bundle to get SlotIndex.\n      const MachineInstr &BundleNonDebug =\n          IgnoreBundle ? MI\n                       : *skipDebugInstructionsForward(BundleStart, BundleEnd);\n      assert(!BundleNonDebug.isDebugInstr() &&\n             \"Could not use a debug instruction to query mi2iMap.\");\n      Mi2IndexMap::const_iterator itr = mi2iMap.find(&BundleNonDebug);\n      assert(itr != mi2iMap.end() && \"Instruction not found in maps.\");\n      return itr->second;\n    }\n\n    /// Returns the instruction for the given index, or null if the given\n    /// index has no instruction associated with it.\n    MachineInstr* getInstructionFromIndex(SlotIndex index) const {\n      return index.isValid() ? index.listEntry()->getInstr() : nullptr;\n    }\n\n    /// Returns the next non-null index, if one exists.\n    /// Otherwise returns getLastIndex().\n    SlotIndex getNextNonNullIndex(SlotIndex Index) {\n      IndexList::iterator I = Index.listEntry()->getIterator();\n      IndexList::iterator E = indexList.end();\n      while (++I != E)\n        if (I->getInstr())\n          return SlotIndex(&*I, Index.getSlot());\n      // We reached the end of the function.\n      return getLastIndex();\n    }\n\n    /// getIndexBefore - Returns the index of the last indexed instruction\n    /// before MI, or the start index of its basic block.\n    /// MI is not required to have an index.\n    SlotIndex getIndexBefore(const MachineInstr &MI) const {\n      const MachineBasicBlock *MBB = MI.getParent();\n      assert(MBB && \"MI must be inserted in a basic block\");\n      MachineBasicBlock::const_iterator I = MI, B = MBB->begin();\n      while (true) {\n        if (I == B)\n          return getMBBStartIdx(MBB);\n        --I;\n        Mi2IndexMap::const_iterator MapItr = mi2iMap.find(&*I);\n        if (MapItr != mi2iMap.end())\n          return MapItr->second;\n      }\n    }\n\n    /// getIndexAfter - Returns the index of the first indexed instruction\n    /// after MI, or the end index of its basic block.\n    /// MI is not required to have an index.\n    SlotIndex getIndexAfter(const MachineInstr &MI) const {\n      const MachineBasicBlock *MBB = MI.getParent();\n      assert(MBB && \"MI must be inserted in a basic block\");\n      MachineBasicBlock::const_iterator I = MI, E = MBB->end();\n      while (true) {\n        ++I;\n        if (I == E)\n          return getMBBEndIdx(MBB);\n        Mi2IndexMap::const_iterator MapItr = mi2iMap.find(&*I);\n        if (MapItr != mi2iMap.end())\n          return MapItr->second;\n      }\n    }\n\n    /// Return the (start,end) range of the given basic block number.\n    const std::pair<SlotIndex, SlotIndex> &\n    getMBBRange(unsigned Num) const {\n      return MBBRanges[Num];\n    }\n\n    /// Return the (start,end) range of the given basic block.\n    const std::pair<SlotIndex, SlotIndex> &\n    getMBBRange(const MachineBasicBlock *MBB) const {\n      return getMBBRange(MBB->getNumber());\n    }\n\n    /// Returns the first index in the given basic block number.\n    SlotIndex getMBBStartIdx(unsigned Num) const {\n      return getMBBRange(Num).first;\n    }\n\n    /// Returns the first index in the given basic block.\n    SlotIndex getMBBStartIdx(const MachineBasicBlock *mbb) const {\n      return getMBBRange(mbb).first;\n    }\n\n    /// Returns the last index in the given basic block number.\n    SlotIndex getMBBEndIdx(unsigned Num) const {\n      return getMBBRange(Num).second;\n    }\n\n    /// Returns the last index in the given basic block.\n    SlotIndex getMBBEndIdx(const MachineBasicBlock *mbb) const {\n      return getMBBRange(mbb).second;\n    }\n\n    /// Iterator over the idx2MBBMap (sorted pairs of slot index of basic block\n    /// begin and basic block)\n    using MBBIndexIterator = SmallVectorImpl<IdxMBBPair>::const_iterator;\n\n    /// Move iterator to the next IdxMBBPair where the SlotIndex is greater or\n    /// equal to \\p To.\n    MBBIndexIterator advanceMBBIndex(MBBIndexIterator I, SlotIndex To) const {\n      return std::partition_point(\n          I, idx2MBBMap.end(),\n          [=](const IdxMBBPair &IM) { return IM.first < To; });\n    }\n\n    /// Get an iterator pointing to the IdxMBBPair with the biggest SlotIndex\n    /// that is greater or equal to \\p Idx.\n    MBBIndexIterator findMBBIndex(SlotIndex Idx) const {\n      return advanceMBBIndex(idx2MBBMap.begin(), Idx);\n    }\n\n    /// Returns an iterator for the begin of the idx2MBBMap.\n    MBBIndexIterator MBBIndexBegin() const {\n      return idx2MBBMap.begin();\n    }\n\n    /// Return an iterator for the end of the idx2MBBMap.\n    MBBIndexIterator MBBIndexEnd() const {\n      return idx2MBBMap.end();\n    }\n\n    /// Returns the basic block which the given index falls in.\n    MachineBasicBlock* getMBBFromIndex(SlotIndex index) const {\n      if (MachineInstr *MI = getInstructionFromIndex(index))\n        return MI->getParent();\n\n      MBBIndexIterator I = findMBBIndex(index);\n      // Take the pair containing the index\n      MBBIndexIterator J =\n        ((I != MBBIndexEnd() && I->first > index) ||\n         (I == MBBIndexEnd() && !idx2MBBMap.empty())) ? std::prev(I) : I;\n\n      assert(J != MBBIndexEnd() && J->first <= index &&\n             index < getMBBEndIdx(J->second) &&\n             \"index does not correspond to an MBB\");\n      return J->second;\n    }\n\n    /// Insert the given machine instruction into the mapping. Returns the\n    /// assigned index.\n    /// If Late is set and there are null indexes between mi's neighboring\n    /// instructions, create the new index after the null indexes instead of\n    /// before them.\n    SlotIndex insertMachineInstrInMaps(MachineInstr &MI, bool Late = false) {\n      assert(!MI.isInsideBundle() &&\n             \"Instructions inside bundles should use bundle start's slot.\");\n      assert(mi2iMap.find(&MI) == mi2iMap.end() && \"Instr already indexed.\");\n      // Numbering debug instructions could cause code generation to be\n      // affected by debug information.\n      assert(!MI.isDebugInstr() && \"Cannot number debug instructions.\");\n\n      assert(MI.getParent() != nullptr && \"Instr must be added to function.\");\n\n      // Get the entries where MI should be inserted.\n      IndexList::iterator prevItr, nextItr;\n      if (Late) {\n        // Insert MI's index immediately before the following instruction.\n        nextItr = getIndexAfter(MI).listEntry()->getIterator();\n        prevItr = std::prev(nextItr);\n      } else {\n        // Insert MI's index immediately after the preceding instruction.\n        prevItr = getIndexBefore(MI).listEntry()->getIterator();\n        nextItr = std::next(prevItr);\n      }\n\n      // Get a number for the new instr, or 0 if there's no room currently.\n      // In the latter case we'll force a renumber later.\n      unsigned dist = ((nextItr->getIndex() - prevItr->getIndex())/2) & ~3u;\n      unsigned newNumber = prevItr->getIndex() + dist;\n\n      // Insert a new list entry for MI.\n      IndexList::iterator newItr =\n          indexList.insert(nextItr, createEntry(&MI, newNumber));\n\n      // Renumber locally if we need to.\n      if (dist == 0)\n        renumberIndexes(newItr);\n\n      SlotIndex newIndex(&*newItr, SlotIndex::Slot_Block);\n      mi2iMap.insert(std::make_pair(&MI, newIndex));\n      return newIndex;\n    }\n\n    /// Removes machine instruction (bundle) \\p MI from the mapping.\n    /// This should be called before MachineInstr::eraseFromParent() is used to\n    /// remove a whole bundle or an unbundled instruction.\n    /// If \\p AllowBundled is set then this can be used on a bundled\n    /// instruction; however, this exists to support handleMoveIntoBundle,\n    /// and in general removeSingleMachineInstrFromMaps should be used instead.\n    void removeMachineInstrFromMaps(MachineInstr &MI,\n                                    bool AllowBundled = false);\n\n    /// Removes a single machine instruction \\p MI from the mapping.\n    /// This should be called before MachineInstr::eraseFromBundle() is used to\n    /// remove a single instruction (out of a bundle).\n    void removeSingleMachineInstrFromMaps(MachineInstr &MI);\n\n    /// ReplaceMachineInstrInMaps - Replacing a machine instr with a new one in\n    /// maps used by register allocator. \\returns the index where the new\n    /// instruction was inserted.\n    SlotIndex replaceMachineInstrInMaps(MachineInstr &MI, MachineInstr &NewMI) {\n      Mi2IndexMap::iterator mi2iItr = mi2iMap.find(&MI);\n      if (mi2iItr == mi2iMap.end())\n        return SlotIndex();\n      SlotIndex replaceBaseIndex = mi2iItr->second;\n      IndexListEntry *miEntry(replaceBaseIndex.listEntry());\n      assert(miEntry->getInstr() == &MI &&\n             \"Mismatched instruction in index tables.\");\n      miEntry->setInstr(&NewMI);\n      mi2iMap.erase(mi2iItr);\n      mi2iMap.insert(std::make_pair(&NewMI, replaceBaseIndex));\n      return replaceBaseIndex;\n    }\n\n    /// Add the given MachineBasicBlock into the maps.\n    /// If it contains any instructions then they must already be in the maps.\n    /// This is used after a block has been split by moving some suffix of its\n    /// instructions into a newly created block.\n    void insertMBBInMaps(MachineBasicBlock *mbb) {\n      assert(mbb != &mbb->getParent()->front() &&\n             \"Can't insert a new block at the beginning of a function.\");\n      auto prevMBB = std::prev(MachineFunction::iterator(mbb));\n\n      // Create a new entry to be used for the start of mbb and the end of\n      // prevMBB.\n      IndexListEntry *startEntry = createEntry(nullptr, 0);\n      IndexListEntry *endEntry = getMBBEndIdx(&*prevMBB).listEntry();\n      IndexListEntry *insEntry =\n          mbb->empty() ? endEntry\n                       : getInstructionIndex(mbb->front()).listEntry();\n      IndexList::iterator newItr =\n          indexList.insert(insEntry->getIterator(), startEntry);\n\n      SlotIndex startIdx(startEntry, SlotIndex::Slot_Block);\n      SlotIndex endIdx(endEntry, SlotIndex::Slot_Block);\n\n      MBBRanges[prevMBB->getNumber()].second = startIdx;\n\n      assert(unsigned(mbb->getNumber()) == MBBRanges.size() &&\n             \"Blocks must be added in order\");\n      MBBRanges.push_back(std::make_pair(startIdx, endIdx));\n      idx2MBBMap.push_back(IdxMBBPair(startIdx, mbb));\n\n      renumberIndexes(newItr);\n      llvm::sort(idx2MBBMap, less_first());\n    }\n  };\n\n  // Specialize IntervalMapInfo for half-open slot index intervals.\n  template <>\n  struct IntervalMapInfo<SlotIndex> : IntervalMapHalfOpenInfo<SlotIndex> {\n  };\n\n} // end namespace llvm\n\n#endif // LLVM_CODEGEN_SLOTINDEXES_H\n"}}, "reports": [{"events": [{"location": {"col": 10, "file": 22, "line": 265}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 22, "line": 265}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h", "reportHash": "1190c38df929521cda8cc55a1c7fe777", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 22, "line": 265}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h", "reportHash": "e56e3b3971e1bbba326cdfc28e9c50df", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 22, "line": 276}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 22, "line": 276}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h", "reportHash": "a81d334166fc297bfc318016e997c1c8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 22, "line": 276}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SparseMultiSet.h", "reportHash": "2d9c44dde8eeb0c01d994128f4b1521a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 30, "line": 186}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 30, "line": 186}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "6adb86c3f8b0bfb9dd31562d897d669c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 30, "line": 186}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "1998026c573c55f065aa4c058121c4fd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 30, "line": 189}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 30, "line": 189}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "5f9a1eadc4142231e556b0acc457ccb6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 30, "line": 189}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "9f16cba9f38277971427041c763b08f5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 30, "line": 193}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 30, "line": 193}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "7765d36a0ce6ae2c1955d12c2922b886", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 30, "line": 193}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "3895bd12db9b89224dd497c63f2b4e90", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 591}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 30, "line": 591}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "d38c7b36221e0da831edf468185ad9f7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 591}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "6edd270aefbd0c22bc7d728b0baf0dec", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 30, "line": 738}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 30, "line": 738}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "ef99dc9599480b28e187234707484761", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 30, "line": 738}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "aeb8fb184aeaccbc79dbf69bd440f643", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 30, "line": 741}, "message": "mark 'noexcept'"}, {"location": {"col": 12, "file": 30, "line": 741}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "c92d3e4925f69220c2687b5225ab4a6b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 30, "line": 741}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "411410bc07f036fa4576ca5b3a4afab4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 870}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 30, "line": 870}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "52108823590d88c2bc054b9cb99cd48b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 30, "line": 870}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "aeca99f90973b6e7d6971a501777bd6d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 30, "line": 912}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 30, "line": 912}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "8e9390bf6f479ccc61d84e05152840f1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 30, "line": 912}, "message": "'operator<' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "d57749bb9b54832925f0d7bfd2de45b6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 30, "line": 916}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 30, "line": 916}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "20e3553c859154eed35446f36e2155e7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 30, "line": 916}, "message": "'operator<' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h", "reportHash": "cfe60b59dadbd778000ccd3dae42815c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 37, "line": 129}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 37, "line": 129}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h", "reportHash": "ba5596ebf6bdd444b99e16b4d0e674a2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 37, "line": 129}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h", "reportHash": "7ada37e05cdd49da4f201c30ccf59022", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 37, "line": 246}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 37, "line": 246}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h", "reportHash": "7e5bb845dc464301af9c653d0ec24b71", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 37, "line": 246}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h", "reportHash": "1fb709c074adfea3266e5cbb72568403", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 37, "line": 250}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 37, "line": 250}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h", "reportHash": "f4609af9ac3084a0b4ca4c6507d8f38b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 37, "line": 250}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h", "reportHash": "0d9779e590e6d7c3d2978a735f0fa7c9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 131}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 38, "line": 131}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h", "reportHash": "18cdee4460b3d17d4b37ae5fb3194b21", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 131}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h", "reportHash": "670f629930720f5fc35802e9b89a88e8", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 135}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 38, "line": 135}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h", "reportHash": "7ac1ca1a089db6fbb0774b5fcf8c00a6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 135}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h", "reportHash": "a43f78569fb8bd35564c27759d928d3c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 625}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 38, "line": 625}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h", "reportHash": "ec9641fd30d731c18a54fb550a6286f5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 625}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h", "reportHash": "2a6e43c6562f05e2b9b8ce8ed3482448", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 628}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 38, "line": 628}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h", "reportHash": "cff538f97831690bd9b91ab3dfcb9f85", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 628}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h", "reportHash": "e391c7d55a5feb4351087a8478226f66", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 39, "line": 44}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 39, "line": 44}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h", "reportHash": "b66b25b19a5cabc8e9cb872ae62e5c09", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 39, "line": 44}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h", "reportHash": "039c3621d101a4df34201b194c165347", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 39, "line": 48}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 39, "line": 48}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h", "reportHash": "e4c272b4856d54c90fa96282f779654e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 39, "line": 48}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h", "reportHash": "565216d9d7f98f7ba6f141f80000ac3b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 39, "line": 51}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 39, "line": 51}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h", "reportHash": "325cd0f482994cc45670fa9acb1dd124", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 39, "line": 51}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h", "reportHash": "a975a4fd2b2ba52a338fc7ad371f77bb", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 39, "line": 55}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 39, "line": 55}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h", "reportHash": "c1b040a1ea776a20098a6d0b7991cf11", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 39, "line": 55}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h", "reportHash": "652ca1e8fe5ffe987c3cef25bdc5506b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 165}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 41, "line": 165}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h", "reportHash": "c9f7e46f8516b89d41490dd83a726807", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 165}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h", "reportHash": "05e82ddd5524e4eaa8ccf542b72d2eda", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 169}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 41, "line": 169}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h", "reportHash": "f14af94042e910e2c0d3e0b6ba2a7cb0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 169}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h", "reportHash": "670a85cb1f1c8a0575c5f9987d8a64b2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 175}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 41, "line": 175}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h", "reportHash": "54d8845bf21e6016df2ff45a561ef912", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 175}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h", "reportHash": "9ea968d149de83f8470e71c91843342b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 180}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 41, "line": 180}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h", "reportHash": "41518e43ad572e9ade5b211ac28eee02", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 180}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h", "reportHash": "b1ca9cd123639574612e1b84516fac16", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 186}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 41, "line": 186}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h", "reportHash": "06b0dab399f189aac6aca14cbc19cc97", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 186}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h", "reportHash": "7269cbb23e3ba9793dd45d68102f9bf7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 192}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 41, "line": 192}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h", "reportHash": "75a8e48a24f98d8b1a91e49133dd4415", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 41, "line": 192}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h", "reportHash": "16a2f3577465f137bd8f8689b9e789d6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
