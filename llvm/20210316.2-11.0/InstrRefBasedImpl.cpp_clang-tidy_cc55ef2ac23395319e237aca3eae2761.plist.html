<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"75": {"id": 75, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "content": "//===- InstrRefBasedImpl.cpp - Tracking Debug Value MIs -------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n/// \\file InstrRefBasedImpl.cpp\n///\n/// This is a separate implementation of LiveDebugValues, see\n/// LiveDebugValues.cpp and VarLocBasedImpl.cpp for more information.\n///\n/// This pass propagates variable locations between basic blocks, resolving\n/// control flow conflicts between them. The problem is much like SSA\n/// construction, where each DBG_VALUE instruction assigns the *value* that\n/// a variable has, and every instruction where the variable is in scope uses\n/// that variable. The resulting map of instruction-to-value is then translated\n/// into a register (or spill) location for each variable over each instruction.\n///\n/// This pass determines which DBG_VALUE dominates which instructions, or if\n/// none do, where values must be merged (like PHI nodes). The added\n/// complication is that because codegen has already finished, a PHI node may\n/// be needed for a variable location to be correct, but no register or spill\n/// slot merges the necessary values. In these circumstances, the variable\n/// location is dropped.\n///\n/// What makes this analysis non-trivial is loops: we cannot tell in advance\n/// whether a variable location is live throughout a loop, or whether its\n/// location is clobbered (or redefined by another DBG_VALUE), without\n/// exploring all the way through.\n///\n/// To make this simpler we perform two kinds of analysis. First, we identify\n/// every value defined by every instruction (ignoring those that only move\n/// another value), then compute a map of which values are available for each\n/// instruction. This is stronger than a reaching-def analysis, as we create\n/// PHI values where other values merge.\n///\n/// Secondly, for each variable, we effectively re-construct SSA using each\n/// DBG_VALUE as a def. The DBG_VALUEs read a value-number computed by the\n/// first analysis from the location they refer to. We can then compute the\n/// dominance frontiers of where a variable has a value, and create PHI nodes\n/// where they merge.\n/// This isn't precisely SSA-construction though, because the function shape\n/// is pre-defined. If a variable location requires a PHI node, but no\n/// PHI for the relevant values is present in the function (as computed by the\n/// first analysis), the location must be dropped.\n///\n/// Once both are complete, we can pass back over all instructions knowing:\n///  * What _value_ each variable should contain, either defined by an\n///    instruction or where control flow merges\n///  * What the location of that value is (if any).\n/// Allowing us to create appropriate live-in DBG_VALUEs, and DBG_VALUEs when\n/// a value moves location. After this pass runs, all variable locations within\n/// a block should be specified by DBG_VALUEs within that block, allowing\n/// DbgEntityHistoryCalculator to focus on individual blocks.\n///\n/// This pass is able to go fast because the size of the first\n/// reaching-definition analysis is proportional to the working-set size of\n/// the function, which the compiler tries to keep small. (It's also\n/// proportional to the number of blocks). Additionally, we repeatedly perform\n/// the second reaching-definition analysis with only the variables and blocks\n/// in a single lexical scope, exploiting their locality.\n///\n/// Determining where PHIs happen is trickier with this approach, and it comes\n/// to a head in the major problem for LiveDebugValues: is a value live-through\n/// a loop, or not? Your garden-variety dataflow analysis aims to build a set of\n/// facts about a function, however this analysis needs to generate new value\n/// numbers at joins.\n///\n/// To do this, consider a lattice of all definition values, from instructions\n/// and from PHIs. Each PHI is characterised by the RPO number of the block it\n/// occurs in. Each value pair A, B can be ordered by RPO(A) < RPO(B):\n/// with non-PHI values at the top, and any PHI value in the last block (by RPO\n/// order) at the bottom.\n///\n/// (Awkwardly: lower-down-the _lattice_ means a greater RPO _number_. Below,\n/// \"rank\" always refers to the former).\n///\n/// At any join, for each register, we consider:\n///  * All incoming values, and\n///  * The PREVIOUS live-in value at this join.\n/// If all incoming values agree: that's the live-in value. If they do not, the\n/// incoming values are ranked according to the partial order, and the NEXT\n/// LOWEST rank after the PREVIOUS live-in value is picked (multiple values of\n/// the same rank are ignored as conflicting). If there are no candidate values,\n/// or if the rank of the live-in would be lower than the rank of the current\n/// blocks PHIs, create a new PHI value.\n///\n/// Intuitively: if it's not immediately obvious what value a join should result\n/// in, we iteratively descend from instruction-definitions down through PHI\n/// values, getting closer to the current block each time. If the current block\n/// is a loop head, this ordering is effectively searching outer levels of\n/// loops, to find a value that's live-through the current loop.\n///\n/// If there is no value that's live-through this loop, a PHI is created for\n/// this location instead. We can't use a lower-ranked PHI because by definition\n/// it doesn't dominate the current block. We can't create a PHI value any\n/// earlier, because we risk creating a PHI value at a location where values do\n/// not in fact merge, thus misrepresenting the truth, and not making the true\n/// live-through value for variable locations.\n///\n/// This algorithm applies to both calculating the availability of values in\n/// the first analysis, and the location of variables in the second. However\n/// for the second we add an extra dimension of pain: creating a variable\n/// location PHI is only valid if, for each incoming edge,\n///  * There is a value for the variable on the incoming edge, and\n///  * All the edges have that value in the same register.\n/// Or put another way: we can only create a variable-location PHI if there is\n/// a matching machine-location PHI, each input to which is the variables value\n/// in the predecessor block.\n///\n/// To accommodate this difference, each point on the lattice is split in\n/// two: a \"proposed\" PHI and \"definite\" PHI. Any PHI that can immediately\n/// have a location determined are \"definite\" PHIs, and no further work is\n/// needed. Otherwise, a location that all non-backedge predecessors agree\n/// on is picked and propagated as a \"proposed\" PHI value. If that PHI value\n/// is truly live-through, it'll appear on the loop backedges on the next\n/// dataflow iteration, after which the block live-in moves to be a \"definite\"\n/// PHI. If it's not truly live-through, the variable value will be downgraded\n/// further as we explore the lattice, or remains \"proposed\" and is considered\n/// invalid once dataflow completes.\n///\n/// ### Terminology\n///\n/// A machine location is a register or spill slot, a value is something that's\n/// defined by an instruction or PHI node, while a variable value is the value\n/// assigned to a variable. A variable location is a machine location, that must\n/// contain the appropriate variable value. A value that is a PHI node is\n/// occasionally called an mphi.\n///\n/// The first dataflow problem is the \"machine value location\" problem,\n/// because we're determining which machine locations contain which values.\n/// The \"locations\" are constant: what's unknown is what value they contain.\n///\n/// The second dataflow problem (the one for variables) is the \"variable value\n/// problem\", because it's determining what values a variable has, rather than\n/// what location those values are placed in. Unfortunately, it's not that\n/// simple, because producing a PHI value always involves picking a location.\n/// This is an imperfection that we just have to accept, at least for now.\n///\n/// TODO:\n///   Overlapping fragments\n///   Entry values\n///   Add back DEBUG statements for debugging this\n///   Collect statistics\n///\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/PostOrderIterator.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/ADT/UniqueVector.h\"\n#include \"llvm/CodeGen/LexicalScopes.h\"\n#include \"llvm/CodeGen/MachineBasicBlock.h\"\n#include \"llvm/CodeGen/MachineFrameInfo.h\"\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/MachineFunctionPass.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/CodeGen/MachineInstrBuilder.h\"\n#include \"llvm/CodeGen/MachineMemOperand.h\"\n#include \"llvm/CodeGen/MachineOperand.h\"\n#include \"llvm/CodeGen/PseudoSourceValue.h\"\n#include \"llvm/CodeGen/RegisterScavenging.h\"\n#include \"llvm/CodeGen/TargetFrameLowering.h\"\n#include \"llvm/CodeGen/TargetInstrInfo.h\"\n#include \"llvm/CodeGen/TargetLowering.h\"\n#include \"llvm/CodeGen/TargetPassConfig.h\"\n#include \"llvm/CodeGen/TargetRegisterInfo.h\"\n#include \"llvm/CodeGen/TargetSubtargetInfo.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/IR/DIBuilder.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/InitializePasses.h\"\n#include \"llvm/MC/MCRegisterInfo.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <queue>\n#include <tuple>\n#include <utility>\n#include <vector>\n#include <limits.h>\n#include <limits>\n\n#include \"LiveDebugValues.h\"\n\nusing namespace llvm;\n\n#define DEBUG_TYPE \"livedebugvalues\"\n\nSTATISTIC(NumInserted, \"Number of DBG_VALUE instructions inserted\");\nSTATISTIC(NumRemoved, \"Number of DBG_VALUE instructions removed\");\n\n// Act more like the VarLoc implementation, by propagating some locations too\n// far and ignoring some transfers.\nstatic cl::opt<bool> EmulateOldLDV(\"emulate-old-livedebugvalues\", cl::Hidden,\n                                   cl::desc(\"Act like old LiveDebugValues did\"),\n                                   cl::init(false));\n\n// Rely on isStoreToStackSlotPostFE and similar to observe all stack spills.\nstatic cl::opt<bool>\n    ObserveAllStackops(\"observe-all-stack-ops\", cl::Hidden,\n                       cl::desc(\"Allow non-kill spill and restores\"),\n                       cl::init(false));\n\nnamespace {\n\n// The location at which a spilled value resides. It consists of a register and\n// an offset.\nstruct SpillLoc {\n  unsigned SpillBase;\n  StackOffset SpillOffset;\n  bool operator==(const SpillLoc &Other) const {\n    return std::make_pair(SpillBase, SpillOffset) ==\n           std::make_pair(Other.SpillBase, Other.SpillOffset);\n  }\n  bool operator<(const SpillLoc &Other) const {\n    return std::make_tuple(SpillBase, SpillOffset.getFixed(),\n                    SpillOffset.getScalable()) <\n           std::make_tuple(Other.SpillBase, Other.SpillOffset.getFixed(),\n                    Other.SpillOffset.getScalable());\n  }\n};\n\nclass LocIdx {\n  unsigned Location;\n\n  // Default constructor is private, initializing to an illegal location number.\n  // Use only for \"not an entry\" elements in IndexedMaps.\n  LocIdx() : Location(UINT_MAX) { }\n\npublic:\n  #define NUM_LOC_BITS 24\n  LocIdx(unsigned L) : Location(L) {\n    assert(L < (1 << NUM_LOC_BITS) && \"Machine locations must fit in 24 bits\");\n  }\n\n  static LocIdx MakeIllegalLoc() {\n    return LocIdx();\n  }\n\n  bool isIllegal() const {\n    return Location == UINT_MAX;\n  }\n\n  uint64_t asU64() const {\n    return Location;\n  }\n\n  bool operator==(unsigned L) const {\n    return Location == L;\n  }\n\n  bool operator==(const LocIdx &L) const {\n    return Location == L.Location;\n  }\n\n  bool operator!=(unsigned L) const {\n    return !(*this == L);\n  }\n\n  bool operator!=(const LocIdx &L) const {\n    return !(*this == L);\n  }\n\n  bool operator<(const LocIdx &Other) const {\n    return Location < Other.Location;\n  }\n};\n\nclass LocIdxToIndexFunctor {\npublic:\n  using argument_type = LocIdx;\n  unsigned operator()(const LocIdx &L) const {\n    return L.asU64();\n  }\n};\n\n/// Unique identifier for a value defined by an instruction, as a value type.\n/// Casts back and forth to a uint64_t. Probably replacable with something less\n/// bit-constrained. Each value identifies the instruction and machine location\n/// where the value is defined, although there may be no corresponding machine\n/// operand for it (ex: regmasks clobbering values). The instructions are\n/// one-based, and definitions that are PHIs have instruction number zero.\n///\n/// The obvious limits of a 1M block function or 1M instruction blocks are\n/// problematic; but by that point we should probably have bailed out of\n/// trying to analyse the function.\nclass ValueIDNum {\n  uint64_t BlockNo : 20;         /// The block where the def happens.\n  uint64_t InstNo : 20;          /// The Instruction where the def happens.\n                                 /// One based, is distance from start of block.\n  uint64_t LocNo : NUM_LOC_BITS; /// The machine location where the def happens.\n\npublic:\n  // XXX -- temporarily enabled while the live-in / live-out tables are moved\n  // to something more type-y\n  ValueIDNum() : BlockNo(0xFFFFF),\n                 InstNo(0xFFFFF),\n                 LocNo(0xFFFFFF) { }\n\n  ValueIDNum(uint64_t Block, uint64_t Inst, uint64_t Loc)\n    : BlockNo(Block), InstNo(Inst), LocNo(Loc) { }\n\n  ValueIDNum(uint64_t Block, uint64_t Inst, LocIdx Loc)\n    : BlockNo(Block), InstNo(Inst), LocNo(Loc.asU64()) { }\n\n  uint64_t getBlock() const { return BlockNo; }\n  uint64_t getInst() const { return InstNo; }\n  uint64_t getLoc() const { return LocNo; }\n  bool isPHI() const { return InstNo == 0; }\n\n  uint64_t asU64() const {\n    uint64_t TmpBlock = BlockNo;\n    uint64_t TmpInst = InstNo;\n    return TmpBlock << 44ull | TmpInst << NUM_LOC_BITS | LocNo;\n  }\n\n  static ValueIDNum fromU64(uint64_t v) {\n    uint64_t L = (v & 0x3FFF);\n    return {v >> 44ull, ((v >> NUM_LOC_BITS) & 0xFFFFF), L};\n  }\n\n  bool operator<(const ValueIDNum &Other) const {\n    return asU64() < Other.asU64();\n  }\n\n  bool operator==(const ValueIDNum &Other) const {\n    return std::tie(BlockNo, InstNo, LocNo) ==\n           std::tie(Other.BlockNo, Other.InstNo, Other.LocNo);\n  }\n\n  bool operator!=(const ValueIDNum &Other) const { return !(*this == Other); }\n\n  std::string asString(const std::string &mlocname) const {\n    return Twine(\"Value{bb: \")\n        .concat(Twine(BlockNo).concat(\n            Twine(\", inst: \")\n                .concat((InstNo ? Twine(InstNo) : Twine(\"live-in\"))\n                            .concat(Twine(\", loc: \").concat(Twine(mlocname)))\n                            .concat(Twine(\"}\")))))\n        .str();\n  }\n\n  static ValueIDNum EmptyValue;\n};\n\n} // end anonymous namespace\n\nnamespace {\n\n/// Meta qualifiers for a value. Pair of whatever expression is used to qualify\n/// the the value, and Boolean of whether or not it's indirect.\nclass DbgValueProperties {\npublic:\n  DbgValueProperties(const DIExpression *DIExpr, bool Indirect)\n      : DIExpr(DIExpr), Indirect(Indirect) {}\n\n  /// Extract properties from an existing DBG_VALUE instruction.\n  DbgValueProperties(const MachineInstr &MI) {\n    assert(MI.isDebugValue());\n    DIExpr = MI.getDebugExpression();\n    Indirect = MI.getOperand(1).isImm();\n  }\n\n  bool operator==(const DbgValueProperties &Other) const {\n    return std::tie(DIExpr, Indirect) == std::tie(Other.DIExpr, Other.Indirect);\n  }\n\n  bool operator!=(const DbgValueProperties &Other) const {\n    return !(*this == Other);\n  }\n\n  const DIExpression *DIExpr;\n  bool Indirect;\n};\n\n/// Tracker for what values are in machine locations. Listens to the Things\n/// being Done by various instructions, and maintains a table of what machine\n/// locations have what values (as defined by a ValueIDNum).\n///\n/// There are potentially a much larger number of machine locations on the\n/// target machine than the actual working-set size of the function. On x86 for\n/// example, we're extremely unlikely to want to track values through control\n/// or debug registers. To avoid doing so, MLocTracker has several layers of\n/// indirection going on, with two kinds of ``location'':\n///  * A LocID uniquely identifies a register or spill location, with a\n///    predictable value.\n///  * A LocIdx is a key (in the database sense) for a LocID and a ValueIDNum.\n/// Whenever a location is def'd or used by a MachineInstr, we automagically\n/// create a new LocIdx for a location, but not otherwise. This ensures we only\n/// account for locations that are actually used or defined. The cost is another\n/// vector lookup (of LocID -> LocIdx) over any other implementation. This is\n/// fairly cheap, and the compiler tries to reduce the working-set at any one\n/// time in the function anyway.\n///\n/// Register mask operands completely blow this out of the water; I've just\n/// piled hacks on top of hacks to get around that.\nclass MLocTracker {\npublic:\n  MachineFunction &MF;\n  const TargetInstrInfo &TII;\n  const TargetRegisterInfo &TRI;\n  const TargetLowering &TLI;\n\n  /// IndexedMap type, mapping from LocIdx to ValueIDNum.\n  using LocToValueType = IndexedMap<ValueIDNum, LocIdxToIndexFunctor>;\n\n  /// Map of LocIdxes to the ValueIDNums that they store. This is tightly\n  /// packed, entries only exist for locations that are being tracked.\n  LocToValueType LocIdxToIDNum;\n\n  /// \"Map\" of machine location IDs (i.e., raw register or spill number) to the\n  /// LocIdx key / number for that location. There are always at least as many\n  /// as the number of registers on the target -- if the value in the register\n  /// is not being tracked, then the LocIdx value will be zero. New entries are\n  /// appended if a new spill slot begins being tracked.\n  /// This, and the corresponding reverse map persist for the analysis of the\n  /// whole function, and is necessarying for decoding various vectors of\n  /// values.\n  std::vector<LocIdx> LocIDToLocIdx;\n\n  /// Inverse map of LocIDToLocIdx.\n  IndexedMap<unsigned, LocIdxToIndexFunctor> LocIdxToLocID;\n\n  /// Unique-ification of spill slots. Used to number them -- their LocID\n  /// number is the index in SpillLocs minus one plus NumRegs.\n  UniqueVector<SpillLoc> SpillLocs;\n\n  // If we discover a new machine location, assign it an mphi with this\n  // block number.\n  unsigned CurBB;\n\n  /// Cached local copy of the number of registers the target has.\n  unsigned NumRegs;\n\n  /// Collection of register mask operands that have been observed. Second part\n  /// of pair indicates the instruction that they happened in. Used to\n  /// reconstruct where defs happened if we start tracking a location later\n  /// on.\n  SmallVector<std::pair<const MachineOperand *, unsigned>, 32> Masks;\n\n  /// Iterator for locations and the values they contain. Dereferencing\n  /// produces a struct/pair containing the LocIdx key for this location,\n  /// and a reference to the value currently stored. Simplifies the process\n  /// of seeking a particular location.\n  class MLocIterator {\n    LocToValueType &ValueMap;\n    LocIdx Idx;\n\n  public:\n    class value_type {\n      public:\n      value_type(LocIdx Idx, ValueIDNum &Value) : Idx(Idx), Value(Value) { }\n      const LocIdx Idx;  /// Read-only index of this location.\n      ValueIDNum &Value; /// Reference to the stored value at this location.\n    };\n\n    MLocIterator(LocToValueType &ValueMap, LocIdx Idx)\n      : ValueMap(ValueMap), Idx(Idx) { }\n\n    bool operator==(const MLocIterator &Other) const {\n      assert(&ValueMap == &Other.ValueMap);\n      return Idx == Other.Idx;\n    }\n\n    bool operator!=(const MLocIterator &Other) const {\n      return !(*this == Other);\n    }\n\n    void operator++() {\n      Idx = LocIdx(Idx.asU64() + 1);\n    }\n\n    value_type operator*() {\n      return value_type(Idx, ValueMap[LocIdx(Idx)]);\n    }\n  };\n\n  MLocTracker(MachineFunction &MF, const TargetInstrInfo &TII,\n              const TargetRegisterInfo &TRI, const TargetLowering &TLI)\n      : MF(MF), TII(TII), TRI(TRI), TLI(TLI),\n        LocIdxToIDNum(ValueIDNum::EmptyValue),\n        LocIdxToLocID(0) {\n    NumRegs = TRI.getNumRegs();\n    reset();\n    LocIDToLocIdx.resize(NumRegs, LocIdx::MakeIllegalLoc());\n    assert(NumRegs < (1u << NUM_LOC_BITS)); // Detect bit packing failure\n\n    // Always track SP. This avoids the implicit clobbering caused by regmasks\n    // from affectings its values. (LiveDebugValues disbelieves calls and\n    // regmasks that claim to clobber SP).\n    Register SP = TLI.getStackPointerRegisterToSaveRestore();\n    if (SP) {\n      unsigned ID = getLocID(SP, false);\n      (void)lookupOrTrackRegister(ID);\n    }\n  }\n\n  /// Produce location ID number for indexing LocIDToLocIdx. Takes the register\n  /// or spill number, and flag for whether it's a spill or not.\n  unsigned getLocID(Register RegOrSpill, bool isSpill) {\n    return (isSpill) ? RegOrSpill.id() + NumRegs - 1 : RegOrSpill.id();\n  }\n\n  /// Accessor for reading the value at Idx.\n  ValueIDNum getNumAtPos(LocIdx Idx) const {\n    assert(Idx.asU64() < LocIdxToIDNum.size());\n    return LocIdxToIDNum[Idx];\n  }\n\n  unsigned getNumLocs(void) const { return LocIdxToIDNum.size(); }\n\n  /// Reset all locations to contain a PHI value at the designated block. Used\n  /// sometimes for actual PHI values, othertimes to indicate the block entry\n  /// value (before any more information is known).\n  void setMPhis(unsigned NewCurBB) {\n    CurBB = NewCurBB;\n    for (auto Location : locations())\n      Location.Value = {CurBB, 0, Location.Idx};\n  }\n\n  /// Load values for each location from array of ValueIDNums. Take current\n  /// bbnum just in case we read a value from a hitherto untouched register.\n  void loadFromArray(ValueIDNum *Locs, unsigned NewCurBB) {\n    CurBB = NewCurBB;\n    // Iterate over all tracked locations, and load each locations live-in\n    // value into our local index.\n    for (auto Location : locations())\n      Location.Value = Locs[Location.Idx.asU64()];\n  }\n\n  /// Wipe any un-necessary location records after traversing a block.\n  void reset(void) {\n    // We could reset all the location values too; however either loadFromArray\n    // or setMPhis should be called before this object is re-used. Just\n    // clear Masks, they're definitely not needed.\n    Masks.clear();\n  }\n\n  /// Clear all data. Destroys the LocID <=> LocIdx map, which makes most of\n  /// the information in this pass uninterpretable.\n  void clear(void) {\n    reset();\n    LocIDToLocIdx.clear();\n    LocIdxToLocID.clear();\n    LocIdxToIDNum.clear();\n    //SpillLocs.reset(); XXX UniqueVector::reset assumes a SpillLoc casts from 0\n    SpillLocs = decltype(SpillLocs)();\n\n    LocIDToLocIdx.resize(NumRegs, LocIdx::MakeIllegalLoc());\n  }\n\n  /// Set a locaiton to a certain value.\n  void setMLoc(LocIdx L, ValueIDNum Num) {\n    assert(L.asU64() < LocIdxToIDNum.size());\n    LocIdxToIDNum[L] = Num;\n  }\n\n  /// Create a LocIdx for an untracked register ID. Initialize it to either an\n  /// mphi value representing a live-in, or a recent register mask clobber.\n  LocIdx trackRegister(unsigned ID) {\n    assert(ID != 0);\n    LocIdx NewIdx = LocIdx(LocIdxToIDNum.size());\n    LocIdxToIDNum.grow(NewIdx);\n    LocIdxToLocID.grow(NewIdx);\n\n    // Default: it's an mphi.\n    ValueIDNum ValNum = {CurBB, 0, NewIdx};\n    // Was this reg ever touched by a regmask?\n    for (const auto &MaskPair : reverse(Masks)) {\n      if (MaskPair.first->clobbersPhysReg(ID)) {\n        // There was an earlier def we skipped.\n        ValNum = {CurBB, MaskPair.second, NewIdx};\n        break;\n      }\n    }\n\n    LocIdxToIDNum[NewIdx] = ValNum;\n    LocIdxToLocID[NewIdx] = ID;\n    return NewIdx;\n  }\n\n  LocIdx lookupOrTrackRegister(unsigned ID) {\n    LocIdx &Index = LocIDToLocIdx[ID];\n    if (Index.isIllegal())\n      Index = trackRegister(ID);\n    return Index;\n  }\n\n  /// Record a definition of the specified register at the given block / inst.\n  /// This doesn't take a ValueIDNum, because the definition and its location\n  /// are synonymous.\n  void defReg(Register R, unsigned BB, unsigned Inst) {\n    unsigned ID = getLocID(R, false);\n    LocIdx Idx = lookupOrTrackRegister(ID);\n    ValueIDNum ValueID = {BB, Inst, Idx};\n    LocIdxToIDNum[Idx] = ValueID;\n  }\n\n  /// Set a register to a value number. To be used if the value number is\n  /// known in advance.\n  void setReg(Register R, ValueIDNum ValueID) {\n    unsigned ID = getLocID(R, false);\n    LocIdx Idx = lookupOrTrackRegister(ID);\n    LocIdxToIDNum[Idx] = ValueID;\n  }\n\n  ValueIDNum readReg(Register R) {\n    unsigned ID = getLocID(R, false);\n    LocIdx Idx = lookupOrTrackRegister(ID);\n    return LocIdxToIDNum[Idx];\n  }\n\n  /// Reset a register value to zero / empty. Needed to replicate the\n  /// VarLoc implementation where a copy to/from a register effectively\n  /// clears the contents of the source register. (Values can only have one\n  ///  machine location in VarLocBasedImpl).\n  void wipeRegister(Register R) {\n    unsigned ID = getLocID(R, false);\n    LocIdx Idx = LocIDToLocIdx[ID];\n    LocIdxToIDNum[Idx] = ValueIDNum::EmptyValue;\n  }\n\n  /// Determine the LocIdx of an existing register.\n  LocIdx getRegMLoc(Register R) {\n    unsigned ID = getLocID(R, false);\n    return LocIDToLocIdx[ID];\n  }\n\n  /// Record a RegMask operand being executed. Defs any register we currently\n  /// track, stores a pointer to the mask in case we have to account for it\n  /// later.\n  void writeRegMask(const MachineOperand *MO, unsigned CurBB, unsigned InstID) {\n    // Ensure SP exists, so that we don't override it later.\n    Register SP = TLI.getStackPointerRegisterToSaveRestore();\n\n    // Def any register we track have that isn't preserved. The regmask\n    // terminates the liveness of a register, meaning its value can't be\n    // relied upon -- we represent this by giving it a new value.\n    for (auto Location : locations()) {\n      unsigned ID = LocIdxToLocID[Location.Idx];\n      // Don't clobber SP, even if the mask says it's clobbered.\n      if (ID < NumRegs && ID != SP && MO->clobbersPhysReg(ID))\n        defReg(ID, CurBB, InstID);\n    }\n    Masks.push_back(std::make_pair(MO, InstID));\n  }\n\n  /// Find LocIdx for SpillLoc \\p L, creating a new one if it's not tracked.\n  LocIdx getOrTrackSpillLoc(SpillLoc L) {\n    unsigned SpillID = SpillLocs.idFor(L);\n    if (SpillID == 0) {\n      SpillID = SpillLocs.insert(L);\n      unsigned L = getLocID(SpillID, true);\n      LocIdx Idx = LocIdx(LocIdxToIDNum.size()); // New idx\n      LocIdxToIDNum.grow(Idx);\n      LocIdxToLocID.grow(Idx);\n      LocIDToLocIdx.push_back(Idx);\n      LocIdxToLocID[Idx] = L;\n      return Idx;\n    } else {\n      unsigned L = getLocID(SpillID, true);\n      LocIdx Idx = LocIDToLocIdx[L];\n      return Idx;\n    }\n  }\n\n  /// Set the value stored in a spill slot.\n  void setSpill(SpillLoc L, ValueIDNum ValueID) {\n    LocIdx Idx = getOrTrackSpillLoc(L);\n    LocIdxToIDNum[Idx] = ValueID;\n  }\n\n  /// Read whatever value is in a spill slot, or None if it isn't tracked.\n  Optional<ValueIDNum> readSpill(SpillLoc L) {\n    unsigned SpillID = SpillLocs.idFor(L);\n    if (SpillID == 0)\n      return None;\n\n    unsigned LocID = getLocID(SpillID, true);\n    LocIdx Idx = LocIDToLocIdx[LocID];\n    return LocIdxToIDNum[Idx];\n  }\n\n  /// Determine the LocIdx of a spill slot. Return None if it previously\n  /// hasn't had a value assigned.\n  Optional<LocIdx> getSpillMLoc(SpillLoc L) {\n    unsigned SpillID = SpillLocs.idFor(L);\n    if (SpillID == 0)\n      return None;\n    unsigned LocNo = getLocID(SpillID, true);\n    return LocIDToLocIdx[LocNo];\n  }\n\n  /// Return true if Idx is a spill machine location.\n  bool isSpill(LocIdx Idx) const {\n    return LocIdxToLocID[Idx] >= NumRegs;\n  }\n\n  MLocIterator begin() {\n    return MLocIterator(LocIdxToIDNum, 0);\n  }\n\n  MLocIterator end() {\n    return MLocIterator(LocIdxToIDNum, LocIdxToIDNum.size());\n  }\n\n  /// Return a range over all locations currently tracked.\n  iterator_range<MLocIterator> locations() {\n    return llvm::make_range(begin(), end());\n  }\n\n  std::string LocIdxToName(LocIdx Idx) const {\n    unsigned ID = LocIdxToLocID[Idx];\n    if (ID >= NumRegs)\n      return Twine(\"slot \").concat(Twine(ID - NumRegs)).str();\n    else\n      return TRI.getRegAsmName(ID).str();\n  }\n\n  std::string IDAsString(const ValueIDNum &Num) const {\n    std::string DefName = LocIdxToName(Num.getLoc());\n    return Num.asString(DefName);\n  }\n\n  LLVM_DUMP_METHOD\n  void dump() {\n    for (auto Location : locations()) {\n      std::string MLocName = LocIdxToName(Location.Value.getLoc());\n      std::string DefName = Location.Value.asString(MLocName);\n      dbgs() << LocIdxToName(Location.Idx) << \" --> \" << DefName << \"\\n\";\n    }\n  }\n\n  LLVM_DUMP_METHOD\n  void dump_mloc_map() {\n    for (auto Location : locations()) {\n      std::string foo = LocIdxToName(Location.Idx);\n      dbgs() << \"Idx \" << Location.Idx.asU64() << \" \" << foo << \"\\n\";\n    }\n  }\n\n  /// Create a DBG_VALUE based on  machine location \\p MLoc. Qualify it with the\n  /// information in \\pProperties, for variable Var. Don't insert it anywhere,\n  /// just return the builder for it.\n  MachineInstrBuilder emitLoc(Optional<LocIdx> MLoc, const DebugVariable &Var,\n                              const DbgValueProperties &Properties) {\n    DebugLoc DL = DILocation::get(Var.getVariable()->getContext(), 0, 0,\n                                  Var.getVariable()->getScope(),\n                                  const_cast<DILocation *>(Var.getInlinedAt()));\n    auto MIB = BuildMI(MF, DL, TII.get(TargetOpcode::DBG_VALUE));\n\n    const DIExpression *Expr = Properties.DIExpr;\n    if (!MLoc) {\n      // No location -> DBG_VALUE $noreg\n      MIB.addReg(0, RegState::Debug);\n      MIB.addReg(0, RegState::Debug);\n    } else if (LocIdxToLocID[*MLoc] >= NumRegs) {\n      unsigned LocID = LocIdxToLocID[*MLoc];\n      const SpillLoc &Spill = SpillLocs[LocID - NumRegs + 1];\n\n      auto *TRI = MF.getSubtarget().getRegisterInfo();\n      Expr = TRI->prependOffsetExpression(Expr, DIExpression::ApplyOffset,\n                                          Spill.SpillOffset);\n      unsigned Base = Spill.SpillBase;\n      MIB.addReg(Base, RegState::Debug);\n      MIB.addImm(0);\n    } else {\n      unsigned LocID = LocIdxToLocID[*MLoc];\n      MIB.addReg(LocID, RegState::Debug);\n      if (Properties.Indirect)\n        MIB.addImm(0);\n      else\n        MIB.addReg(0, RegState::Debug);\n    }\n\n    MIB.addMetadata(Var.getVariable());\n    MIB.addMetadata(Expr);\n    return MIB;\n  }\n};\n\n/// Class recording the (high level) _value_ of a variable. Identifies either\n/// the value of the variable as a ValueIDNum, or a constant MachineOperand.\n/// This class also stores meta-information about how the value is qualified.\n/// Used to reason about variable values when performing the second\n/// (DebugVariable specific) dataflow analysis.\nclass DbgValue {\npublic:\n  union {\n    /// If Kind is Def, the value number that this value is based on.\n    ValueIDNum ID;\n    /// If Kind is Const, the MachineOperand defining this value.\n    MachineOperand MO;\n    /// For a NoVal DbgValue, which block it was generated in.\n    unsigned BlockNo;\n  };\n  /// Qualifiers for the ValueIDNum above.\n  DbgValueProperties Properties;\n\n  typedef enum {\n    Undef,     // Represents a DBG_VALUE $noreg in the transfer function only.\n    Def,       // This value is defined by an inst, or is a PHI value.\n    Const,     // A constant value contained in the MachineOperand field.\n    Proposed,  // This is a tentative PHI value, which may be confirmed or\n               // invalidated later.\n    NoVal      // Empty DbgValue, generated during dataflow. BlockNo stores\n               // which block this was generated in.\n   } KindT;\n  /// Discriminator for whether this is a constant or an in-program value.\n  KindT Kind;\n\n  DbgValue(const ValueIDNum &Val, const DbgValueProperties &Prop, KindT Kind)\n    : ID(Val), Properties(Prop), Kind(Kind) {\n    assert(Kind == Def || Kind == Proposed);\n  }\n\n  DbgValue(unsigned BlockNo, const DbgValueProperties &Prop, KindT Kind)\n    : BlockNo(BlockNo), Properties(Prop), Kind(Kind) {\n    assert(Kind == NoVal);\n  }\n\n  DbgValue(const MachineOperand &MO, const DbgValueProperties &Prop, KindT Kind)\n    : MO(MO), Properties(Prop), Kind(Kind) {\n    assert(Kind == Const);\n  }\n\n  DbgValue(const DbgValueProperties &Prop, KindT Kind)\n    : Properties(Prop), Kind(Kind) {\n    assert(Kind == Undef &&\n           \"Empty DbgValue constructor must pass in Undef kind\");\n  }\n\n  void dump(const MLocTracker *MTrack) const {\n    if (Kind == Const) {\n      MO.dump();\n    } else if (Kind == NoVal) {\n      dbgs() << \"NoVal(\" << BlockNo << \")\";\n    } else if (Kind == Proposed) {\n      dbgs() << \"VPHI(\" << MTrack->IDAsString(ID) << \")\";\n    } else {\n      assert(Kind == Def);\n      dbgs() << MTrack->IDAsString(ID);\n    }\n    if (Properties.Indirect)\n      dbgs() << \" indir\";\n    if (Properties.DIExpr)\n      dbgs() << \" \" << *Properties.DIExpr;\n  }\n\n  bool operator==(const DbgValue &Other) const {\n    if (std::tie(Kind, Properties) != std::tie(Other.Kind, Other.Properties))\n      return false;\n    else if (Kind == Proposed && ID != Other.ID)\n      return false;\n    else if (Kind == Def && ID != Other.ID)\n      return false;\n    else if (Kind == NoVal && BlockNo != Other.BlockNo)\n      return false;\n    else if (Kind == Const)\n      return MO.isIdenticalTo(Other.MO);\n\n    return true;\n  }\n\n  bool operator!=(const DbgValue &Other) const { return !(*this == Other); }\n};\n\n/// Types for recording sets of variable fragments that overlap. For a given\n/// local variable, we record all other fragments of that variable that could\n/// overlap it, to reduce search time.\nusing FragmentOfVar =\n    std::pair<const DILocalVariable *, DIExpression::FragmentInfo>;\nusing OverlapMap =\n    DenseMap<FragmentOfVar, SmallVector<DIExpression::FragmentInfo, 1>>;\n\n/// Collection of DBG_VALUEs observed when traversing a block. Records each\n/// variable and the value the DBG_VALUE refers to. Requires the machine value\n/// location dataflow algorithm to have run already, so that values can be\n/// identified.\nclass VLocTracker {\npublic:\n  /// Map DebugVariable to the latest Value it's defined to have.\n  /// Needs to be a MapVector because we determine order-in-the-input-MIR from\n  /// the order in this container.\n  /// We only retain the last DbgValue in each block for each variable, to\n  /// determine the blocks live-out variable value. The Vars container forms the\n  /// transfer function for this block, as part of the dataflow analysis. The\n  /// movement of values between locations inside of a block is handled at a\n  /// much later stage, in the TransferTracker class.\n  MapVector<DebugVariable, DbgValue> Vars;\n  DenseMap<DebugVariable, const DILocation *> Scopes;\n  MachineBasicBlock *MBB;\n\npublic:\n  VLocTracker() {}\n\n  void defVar(const MachineInstr &MI, const DbgValueProperties &Properties,\n              Optional<ValueIDNum> ID) {\n    assert(MI.isDebugValue() || MI.isDebugRef());\n    DebugVariable Var(MI.getDebugVariable(), MI.getDebugExpression(),\n                      MI.getDebugLoc()->getInlinedAt());\n    DbgValue Rec = (ID) ? DbgValue(*ID, Properties, DbgValue::Def)\n                        : DbgValue(Properties, DbgValue::Undef);\n\n    // Attempt insertion; overwrite if it's already mapped.\n    auto Result = Vars.insert(std::make_pair(Var, Rec));\n    if (!Result.second)\n      Result.first->second = Rec;\n    Scopes[Var] = MI.getDebugLoc().get();\n  }\n\n  void defVar(const MachineInstr &MI, const MachineOperand &MO) {\n    // Only DBG_VALUEs can define constant-valued variables.\n    assert(MI.isDebugValue());\n    DebugVariable Var(MI.getDebugVariable(), MI.getDebugExpression(),\n                      MI.getDebugLoc()->getInlinedAt());\n    DbgValueProperties Properties(MI);\n    DbgValue Rec = DbgValue(MO, Properties, DbgValue::Const);\n\n    // Attempt insertion; overwrite if it's already mapped.\n    auto Result = Vars.insert(std::make_pair(Var, Rec));\n    if (!Result.second)\n      Result.first->second = Rec;\n    Scopes[Var] = MI.getDebugLoc().get();\n  }\n};\n\n/// Tracker for converting machine value locations and variable values into\n/// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs\n/// specifying block live-in locations and transfers within blocks.\n///\n/// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker\n/// and must be initialized with the set of variable values that are live-in to\n/// the block. The caller then repeatedly calls process(). TransferTracker picks\n/// out variable locations for the live-in variable values (if there _is_ a\n/// location) and creates the corresponding DBG_VALUEs. Then, as the block is\n/// stepped through, transfers of values between machine locations are\n/// identified and if profitable, a DBG_VALUE created.\n///\n/// This is where debug use-before-defs would be resolved: a variable with an\n/// unavailable value could materialize in the middle of a block, when the\n/// value becomes available. Or, we could detect clobbers and re-specify the\n/// variable in a backup location. (XXX these are unimplemented).\nclass TransferTracker {\npublic:\n  const TargetInstrInfo *TII;\n  /// This machine location tracker is assumed to always contain the up-to-date\n  /// value mapping for all machine locations. TransferTracker only reads\n  /// information from it. (XXX make it const?)\n  MLocTracker *MTracker;\n  MachineFunction &MF;\n\n  /// Record of all changes in variable locations at a block position. Awkwardly\n  /// we allow inserting either before or after the point: MBB != nullptr\n  /// indicates it's before, otherwise after.\n  struct Transfer {\n    MachineBasicBlock::iterator Pos; /// Position to insert DBG_VALUes\n    MachineBasicBlock *MBB;          /// non-null if we should insert after.\n    SmallVector<MachineInstr *, 4> Insts; /// Vector of DBG_VALUEs to insert.\n  };\n\n  typedef struct {\n    LocIdx Loc;\n    DbgValueProperties Properties;\n  } LocAndProperties;\n\n  /// Collection of transfers (DBG_VALUEs) to be inserted.\n  SmallVector<Transfer, 32> Transfers;\n\n  /// Local cache of what-value-is-in-what-LocIdx. Used to identify differences\n  /// between TransferTrackers view of variable locations and MLocTrackers. For\n  /// example, MLocTracker observes all clobbers, but TransferTracker lazily\n  /// does not.\n  std::vector<ValueIDNum> VarLocs;\n\n  /// Map from LocIdxes to which DebugVariables are based that location.\n  /// Mantained while stepping through the block. Not accurate if\n  /// VarLocs[Idx] != MTracker->LocIdxToIDNum[Idx].\n  std::map<LocIdx, SmallSet<DebugVariable, 4>> ActiveMLocs;\n\n  /// Map from DebugVariable to it's current location and qualifying meta\n  /// information. To be used in conjunction with ActiveMLocs to construct\n  /// enough information for the DBG_VALUEs for a particular LocIdx.\n  DenseMap<DebugVariable, LocAndProperties> ActiveVLocs;\n\n  /// Temporary cache of DBG_VALUEs to be entered into the Transfers collection.\n  SmallVector<MachineInstr *, 4> PendingDbgValues;\n\n  /// Record of a use-before-def: created when a value that's live-in to the\n  /// current block isn't available in any machine location, but it will be\n  /// defined in this block.\n  struct UseBeforeDef {\n    /// Value of this variable, def'd in block.\n    ValueIDNum ID;\n    /// Identity of this variable.\n    DebugVariable Var;\n    /// Additional variable properties.\n    DbgValueProperties Properties;\n  };\n\n  /// Map from instruction index (within the block) to the set of UseBeforeDefs\n  /// that become defined at that instruction.\n  DenseMap<unsigned, SmallVector<UseBeforeDef, 1>> UseBeforeDefs;\n\n  /// The set of variables that are in UseBeforeDefs and can become a location\n  /// once the relevant value is defined. An element being erased from this\n  /// collection prevents the use-before-def materializing.\n  DenseSet<DebugVariable> UseBeforeDefVariables;\n\n  const TargetRegisterInfo &TRI;\n  const BitVector &CalleeSavedRegs;\n\n  TransferTracker(const TargetInstrInfo *TII, MLocTracker *MTracker,\n                  MachineFunction &MF, const TargetRegisterInfo &TRI,\n                  const BitVector &CalleeSavedRegs)\n      : TII(TII), MTracker(MTracker), MF(MF), TRI(TRI),\n        CalleeSavedRegs(CalleeSavedRegs) {}\n\n  /// Load object with live-in variable values. \\p mlocs contains the live-in\n  /// values in each machine location, while \\p vlocs the live-in variable\n  /// values. This method picks variable locations for the live-in variables,\n  /// creates DBG_VALUEs and puts them in #Transfers, then prepares the other\n  /// object fields to track variable locations as we step through the block.\n  /// FIXME: could just examine mloctracker instead of passing in \\p mlocs?\n  void loadInlocs(MachineBasicBlock &MBB, ValueIDNum *MLocs,\n                  SmallVectorImpl<std::pair<DebugVariable, DbgValue>> &VLocs,\n                  unsigned NumLocs) {\n    ActiveMLocs.clear();\n    ActiveVLocs.clear();\n    VarLocs.clear();\n    VarLocs.reserve(NumLocs);\n    UseBeforeDefs.clear();\n    UseBeforeDefVariables.clear();\n\n    auto isCalleeSaved = [&](LocIdx L) {\n      unsigned Reg = MTracker->LocIdxToLocID[L];\n      if (Reg >= MTracker->NumRegs)\n        return false;\n      for (MCRegAliasIterator RAI(Reg, &TRI, true); RAI.isValid(); ++RAI)\n        if (CalleeSavedRegs.test(*RAI))\n          return true;\n      return false;\n    };\n\n    // Map of the preferred location for each value.\n    std::map<ValueIDNum, LocIdx> ValueToLoc;\n\n    // Produce a map of value numbers to the current machine locs they live\n    // in. When emulating VarLocBasedImpl, there should only be one\n    // location; when not, we get to pick.\n    for (auto Location : MTracker->locations()) {\n      LocIdx Idx = Location.Idx;\n      ValueIDNum &VNum = MLocs[Idx.asU64()];\n      VarLocs.push_back(VNum);\n      auto it = ValueToLoc.find(VNum);\n      // In order of preference, pick:\n      //  * Callee saved registers,\n      //  * Other registers,\n      //  * Spill slots.\n      if (it == ValueToLoc.end() || MTracker->isSpill(it->second) ||\n          (!isCalleeSaved(it->second) && isCalleeSaved(Idx.asU64()))) {\n        // Insert, or overwrite if insertion failed.\n        auto PrefLocRes = ValueToLoc.insert(std::make_pair(VNum, Idx));\n        if (!PrefLocRes.second)\n          PrefLocRes.first->second = Idx;\n      }\n    }\n\n    // Now map variables to their picked LocIdxes.\n    for (auto Var : VLocs) {\n      if (Var.second.Kind == DbgValue::Const) {\n        PendingDbgValues.push_back(\n            emitMOLoc(Var.second.MO, Var.first, Var.second.Properties));\n        continue;\n      }\n\n      // If the value has no location, we can't make a variable location.\n      const ValueIDNum &Num = Var.second.ID;\n      auto ValuesPreferredLoc = ValueToLoc.find(Num);\n      if (ValuesPreferredLoc == ValueToLoc.end()) {\n        // If it's a def that occurs in this block, register it as a\n        // use-before-def to be resolved as we step through the block.\n        if (Num.getBlock() == (unsigned)MBB.getNumber() && !Num.isPHI())\n          addUseBeforeDef(Var.first, Var.second.Properties, Num);\n        continue;\n      }\n\n      LocIdx M = ValuesPreferredLoc->second;\n      auto NewValue = LocAndProperties{M, Var.second.Properties};\n      auto Result = ActiveVLocs.insert(std::make_pair(Var.first, NewValue));\n      if (!Result.second)\n        Result.first->second = NewValue;\n      ActiveMLocs[M].insert(Var.first);\n      PendingDbgValues.push_back(\n          MTracker->emitLoc(M, Var.first, Var.second.Properties));\n    }\n    flushDbgValues(MBB.begin(), &MBB);\n  }\n\n  /// Record that \\p Var has value \\p ID, a value that becomes available\n  /// later in the function.\n  void addUseBeforeDef(const DebugVariable &Var,\n                       const DbgValueProperties &Properties, ValueIDNum ID) {\n    UseBeforeDef UBD = {ID, Var, Properties};\n    UseBeforeDefs[ID.getInst()].push_back(UBD);\n    UseBeforeDefVariables.insert(Var);\n  }\n\n  /// After the instruction at index \\p Inst and position \\p pos has been\n  /// processed, check whether it defines a variable value in a use-before-def.\n  /// If so, and the variable value hasn't changed since the start of the\n  /// block, create a DBG_VALUE.\n  void checkInstForNewValues(unsigned Inst, MachineBasicBlock::iterator pos) {\n    auto MIt = UseBeforeDefs.find(Inst);\n    if (MIt == UseBeforeDefs.end())\n      return;\n\n    for (auto &Use : MIt->second) {\n      LocIdx L = Use.ID.getLoc();\n\n      // If something goes very wrong, we might end up labelling a COPY\n      // instruction or similar with an instruction number, where it doesn't\n      // actually define a new value, instead it moves a value. In case this\n      // happens, discard.\n      if (MTracker->LocIdxToIDNum[L] != Use.ID)\n        continue;\n\n      // If a different debug instruction defined the variable value / location\n      // since the start of the block, don't materialize this use-before-def.\n      if (!UseBeforeDefVariables.count(Use.Var))\n        continue;\n\n      PendingDbgValues.push_back(MTracker->emitLoc(L, Use.Var, Use.Properties));\n    }\n    flushDbgValues(pos, nullptr);\n  }\n\n  /// Helper to move created DBG_VALUEs into Transfers collection.\n  void flushDbgValues(MachineBasicBlock::iterator Pos, MachineBasicBlock *MBB) {\n    if (PendingDbgValues.size() > 0) {\n      Transfers.push_back({Pos, MBB, PendingDbgValues});\n      PendingDbgValues.clear();\n    }\n  }\n\n  /// Change a variable value after encountering a DBG_VALUE inside a block.\n  void redefVar(const MachineInstr &MI) {\n    DebugVariable Var(MI.getDebugVariable(), MI.getDebugExpression(),\n                      MI.getDebugLoc()->getInlinedAt());\n    DbgValueProperties Properties(MI);\n\n    const MachineOperand &MO = MI.getOperand(0);\n\n    // Ignore non-register locations, we don't transfer those.\n    if (!MO.isReg() || MO.getReg() == 0) {\n      auto It = ActiveVLocs.find(Var);\n      if (It != ActiveVLocs.end()) {\n        ActiveMLocs[It->second.Loc].erase(Var);\n        ActiveVLocs.erase(It);\n     }\n      // Any use-before-defs no longer apply.\n      UseBeforeDefVariables.erase(Var);\n      return;\n    }\n\n    Register Reg = MO.getReg();\n    LocIdx NewLoc = MTracker->getRegMLoc(Reg);\n    redefVar(MI, Properties, NewLoc);\n  }\n\n  /// Handle a change in variable location within a block. Terminate the\n  /// variables current location, and record the value it now refers to, so\n  /// that we can detect location transfers later on.\n  void redefVar(const MachineInstr &MI, const DbgValueProperties &Properties,\n                Optional<LocIdx> OptNewLoc) {\n    DebugVariable Var(MI.getDebugVariable(), MI.getDebugExpression(),\n                      MI.getDebugLoc()->getInlinedAt());\n    // Any use-before-defs no longer apply.\n    UseBeforeDefVariables.erase(Var);\n\n    // Erase any previous location,\n    auto It = ActiveVLocs.find(Var);\n    if (It != ActiveVLocs.end())\n      ActiveMLocs[It->second.Loc].erase(Var);\n\n    // If there _is_ no new location, all we had to do was erase.\n    if (!OptNewLoc)\n      return;\n    LocIdx NewLoc = *OptNewLoc;\n\n    // Check whether our local copy of values-by-location in #VarLocs is out of\n    // date. Wipe old tracking data for the location if it's been clobbered in\n    // the meantime.\n    if (MTracker->getNumAtPos(NewLoc) != VarLocs[NewLoc.asU64()]) {\n      for (auto &P : ActiveMLocs[NewLoc]) {\n        ActiveVLocs.erase(P);\n      }\n      ActiveMLocs[NewLoc.asU64()].clear();\n      VarLocs[NewLoc.asU64()] = MTracker->getNumAtPos(NewLoc);\n    }\n\n    ActiveMLocs[NewLoc].insert(Var);\n    if (It == ActiveVLocs.end()) {\n      ActiveVLocs.insert(\n          std::make_pair(Var, LocAndProperties{NewLoc, Properties}));\n    } else {\n      It->second.Loc = NewLoc;\n      It->second.Properties = Properties;\n    }\n  }\n\n  /// Explicitly terminate variable locations based on \\p mloc. Creates undef\n  /// DBG_VALUEs for any variables that were located there, and clears\n  /// #ActiveMLoc / #ActiveVLoc tracking information for that location.\n  void clobberMloc(LocIdx MLoc, MachineBasicBlock::iterator Pos) {\n    assert(MTracker->isSpill(MLoc));\n    auto ActiveMLocIt = ActiveMLocs.find(MLoc);\n    if (ActiveMLocIt == ActiveMLocs.end())\n      return;\n\n    VarLocs[MLoc.asU64()] = ValueIDNum::EmptyValue;\n\n    for (auto &Var : ActiveMLocIt->second) {\n      auto ActiveVLocIt = ActiveVLocs.find(Var);\n      // Create an undef. We can't feed in a nullptr DIExpression alas,\n      // so use the variables last expression. Pass None as the location.\n      const DIExpression *Expr = ActiveVLocIt->second.Properties.DIExpr;\n      DbgValueProperties Properties(Expr, false);\n      PendingDbgValues.push_back(MTracker->emitLoc(None, Var, Properties));\n      ActiveVLocs.erase(ActiveVLocIt);\n    }\n    flushDbgValues(Pos, nullptr);\n\n    ActiveMLocIt->second.clear();\n  }\n\n  /// Transfer variables based on \\p Src to be based on \\p Dst. This handles\n  /// both register copies as well as spills and restores. Creates DBG_VALUEs\n  /// describing the movement.\n  void transferMlocs(LocIdx Src, LocIdx Dst, MachineBasicBlock::iterator Pos) {\n    // Does Src still contain the value num we expect? If not, it's been\n    // clobbered in the meantime, and our variable locations are stale.\n    if (VarLocs[Src.asU64()] != MTracker->getNumAtPos(Src))\n      return;\n\n    // assert(ActiveMLocs[Dst].size() == 0);\n    //^^^ Legitimate scenario on account of un-clobbered slot being assigned to?\n    ActiveMLocs[Dst] = ActiveMLocs[Src];\n    VarLocs[Dst.asU64()] = VarLocs[Src.asU64()];\n\n    // For each variable based on Src; create a location at Dst.\n    for (auto &Var : ActiveMLocs[Src]) {\n      auto ActiveVLocIt = ActiveVLocs.find(Var);\n      assert(ActiveVLocIt != ActiveVLocs.end());\n      ActiveVLocIt->second.Loc = Dst;\n\n      assert(Dst != 0);\n      MachineInstr *MI =\n          MTracker->emitLoc(Dst, Var, ActiveVLocIt->second.Properties);\n      PendingDbgValues.push_back(MI);\n    }\n    ActiveMLocs[Src].clear();\n    flushDbgValues(Pos, nullptr);\n\n    // XXX XXX XXX \"pretend to be old LDV\" means dropping all tracking data\n    // about the old location.\n    if (EmulateOldLDV)\n      VarLocs[Src.asU64()] = ValueIDNum::EmptyValue;\n  }\n\n  MachineInstrBuilder emitMOLoc(const MachineOperand &MO,\n                                const DebugVariable &Var,\n                                const DbgValueProperties &Properties) {\n    DebugLoc DL = DILocation::get(Var.getVariable()->getContext(), 0, 0,\n                                  Var.getVariable()->getScope(),\n                                  const_cast<DILocation *>(Var.getInlinedAt()));\n    auto MIB = BuildMI(MF, DL, TII->get(TargetOpcode::DBG_VALUE));\n    MIB.add(MO);\n    if (Properties.Indirect)\n      MIB.addImm(0);\n    else\n      MIB.addReg(0);\n    MIB.addMetadata(Var.getVariable());\n    MIB.addMetadata(Properties.DIExpr);\n    return MIB;\n  }\n};\n\nclass InstrRefBasedLDV : public LDVImpl {\nprivate:\n  using FragmentInfo = DIExpression::FragmentInfo;\n  using OptFragmentInfo = Optional<DIExpression::FragmentInfo>;\n\n  // Helper while building OverlapMap, a map of all fragments seen for a given\n  // DILocalVariable.\n  using VarToFragments =\n      DenseMap<const DILocalVariable *, SmallSet<FragmentInfo, 4>>;\n\n  /// Machine location/value transfer function, a mapping of which locations\n  /// are assigned which new values.\n  using MLocTransferMap = std::map<LocIdx, ValueIDNum>;\n\n  /// Live in/out structure for the variable values: a per-block map of\n  /// variables to their values. XXX, better name?\n  using LiveIdxT =\n      DenseMap<const MachineBasicBlock *, DenseMap<DebugVariable, DbgValue> *>;\n\n  using VarAndLoc = std::pair<DebugVariable, DbgValue>;\n\n  /// Type for a live-in value: the predecessor block, and its value.\n  using InValueT = std::pair<MachineBasicBlock *, DbgValue *>;\n\n  /// Vector (per block) of a collection (inner smallvector) of live-ins.\n  /// Used as the result type for the variable value dataflow problem.\n  using LiveInsT = SmallVector<SmallVector<VarAndLoc, 8>, 8>;\n\n  const TargetRegisterInfo *TRI;\n  const TargetInstrInfo *TII;\n  const TargetFrameLowering *TFI;\n  BitVector CalleeSavedRegs;\n  LexicalScopes LS;\n  TargetPassConfig *TPC;\n\n  /// Object to track machine locations as we step through a block. Could\n  /// probably be a field rather than a pointer, as it's always used.\n  MLocTracker *MTracker;\n\n  /// Number of the current block LiveDebugValues is stepping through.\n  unsigned CurBB;\n\n  /// Number of the current instruction LiveDebugValues is evaluating.\n  unsigned CurInst;\n\n  /// Variable tracker -- listens to DBG_VALUEs occurring as InstrRefBasedImpl\n  /// steps through a block. Reads the values at each location from the\n  /// MLocTracker object.\n  VLocTracker *VTracker;\n\n  /// Tracker for transfers, listens to DBG_VALUEs and transfers of values\n  /// between locations during stepping, creates new DBG_VALUEs when values move\n  /// location.\n  TransferTracker *TTracker;\n\n  /// Blocks which are artificial, i.e. blocks which exclusively contain\n  /// instructions without DebugLocs, or with line 0 locations.\n  SmallPtrSet<const MachineBasicBlock *, 16> ArtificialBlocks;\n\n  // Mapping of blocks to and from their RPOT order.\n  DenseMap<unsigned int, MachineBasicBlock *> OrderToBB;\n  DenseMap<MachineBasicBlock *, unsigned int> BBToOrder;\n  DenseMap<unsigned, unsigned> BBNumToRPO;\n\n  /// Pair of MachineInstr, and its 1-based offset into the containing block.\n  using InstAndNum = std::pair<const MachineInstr *, unsigned>;\n  /// Map from debug instruction number to the MachineInstr labelled with that\n  /// number, and its location within the function. Used to transform\n  /// instruction numbers in DBG_INSTR_REFs into machine value numbers.\n  std::map<uint64_t, InstAndNum> DebugInstrNumToInstr;\n\n  // Map of overlapping variable fragments.\n  OverlapMap OverlapFragments;\n  VarToFragments SeenFragments;\n\n  /// Tests whether this instruction is a spill to a stack slot.\n  bool isSpillInstruction(const MachineInstr &MI, MachineFunction *MF);\n\n  /// Decide if @MI is a spill instruction and return true if it is. We use 2\n  /// criteria to make this decision:\n  /// - Is this instruction a store to a spill slot?\n  /// - Is there a register operand that is both used and killed?\n  /// TODO: Store optimization can fold spills into other stores (including\n  /// other spills). We do not handle this yet (more than one memory operand).\n  bool isLocationSpill(const MachineInstr &MI, MachineFunction *MF,\n                       unsigned &Reg);\n\n  /// If a given instruction is identified as a spill, return the spill slot\n  /// and set \\p Reg to the spilled register.\n  Optional<SpillLoc> isRestoreInstruction(const MachineInstr &MI,\n                                          MachineFunction *MF, unsigned &Reg);\n\n  /// Given a spill instruction, extract the register and offset used to\n  /// address the spill slot in a target independent way.\n  SpillLoc extractSpillBaseRegAndOffset(const MachineInstr &MI);\n\n  /// Observe a single instruction while stepping through a block.\n  void process(MachineInstr &MI);\n\n  /// Examines whether \\p MI is a DBG_VALUE and notifies trackers.\n  /// \\returns true if MI was recognized and processed.\n  bool transferDebugValue(const MachineInstr &MI);\n\n  /// Examines whether \\p MI is a DBG_INSTR_REF and notifies trackers.\n  /// \\returns true if MI was recognized and processed.\n  bool transferDebugInstrRef(MachineInstr &MI);\n\n  /// Examines whether \\p MI is copy instruction, and notifies trackers.\n  /// \\returns true if MI was recognized and processed.\n  bool transferRegisterCopy(MachineInstr &MI);\n\n  /// Examines whether \\p MI is stack spill or restore  instruction, and\n  /// notifies trackers. \\returns true if MI was recognized and processed.\n  bool transferSpillOrRestoreInst(MachineInstr &MI);\n\n  /// Examines \\p MI for any registers that it defines, and notifies trackers.\n  void transferRegisterDef(MachineInstr &MI);\n\n  /// Copy one location to the other, accounting for movement of subregisters\n  /// too.\n  void performCopy(Register Src, Register Dst);\n\n  void accumulateFragmentMap(MachineInstr &MI);\n\n  /// Step through the function, recording register definitions and movements\n  /// in an MLocTracker. Convert the observations into a per-block transfer\n  /// function in \\p MLocTransfer, suitable for using with the machine value\n  /// location dataflow problem.\n  void\n  produceMLocTransferFunction(MachineFunction &MF,\n                              SmallVectorImpl<MLocTransferMap> &MLocTransfer,\n                              unsigned MaxNumBlocks);\n\n  /// Solve the machine value location dataflow problem. Takes as input the\n  /// transfer functions in \\p MLocTransfer. Writes the output live-in and\n  /// live-out arrays to the (initialized to zero) multidimensional arrays in\n  /// \\p MInLocs and \\p MOutLocs. The outer dimension is indexed by block\n  /// number, the inner by LocIdx.\n  void mlocDataflow(ValueIDNum **MInLocs, ValueIDNum **MOutLocs,\n                    SmallVectorImpl<MLocTransferMap> &MLocTransfer);\n\n  /// Perform a control flow join (lattice value meet) of the values in machine\n  /// locations at \\p MBB. Follows the algorithm described in the file-comment,\n  /// reading live-outs of predecessors from \\p OutLocs, the current live ins\n  /// from \\p InLocs, and assigning the newly computed live ins back into\n  /// \\p InLocs. \\returns two bools -- the first indicates whether a change\n  /// was made, the second whether a lattice downgrade occurred. If the latter\n  /// is true, revisiting this block is necessary.\n  std::tuple<bool, bool>\n  mlocJoin(MachineBasicBlock &MBB,\n           SmallPtrSet<const MachineBasicBlock *, 16> &Visited,\n           ValueIDNum **OutLocs, ValueIDNum *InLocs);\n\n  /// Solve the variable value dataflow problem, for a single lexical scope.\n  /// Uses the algorithm from the file comment to resolve control flow joins,\n  /// although there are extra hacks, see vlocJoin. Reads the\n  /// locations of values from the \\p MInLocs and \\p MOutLocs arrays (see\n  /// mlocDataflow) and reads the variable values transfer function from\n  /// \\p AllTheVlocs. Live-in and Live-out variable values are stored locally,\n  /// with the live-ins permanently stored to \\p Output once the fixedpoint is\n  /// reached.\n  /// \\p VarsWeCareAbout contains a collection of the variables in \\p Scope\n  /// that we should be tracking.\n  /// \\p AssignBlocks contains the set of blocks that aren't in \\p Scope, but\n  /// which do contain DBG_VALUEs, which VarLocBasedImpl tracks locations\n  /// through.\n  void vlocDataflow(const LexicalScope *Scope, const DILocation *DILoc,\n                    const SmallSet<DebugVariable, 4> &VarsWeCareAbout,\n                    SmallPtrSetImpl<MachineBasicBlock *> &AssignBlocks,\n                    LiveInsT &Output, ValueIDNum **MOutLocs,\n                    ValueIDNum **MInLocs,\n                    SmallVectorImpl<VLocTracker> &AllTheVLocs);\n\n  /// Compute the live-ins to a block, considering control flow merges according\n  /// to the method in the file comment. Live out and live in variable values\n  /// are stored in \\p VLOCOutLocs and \\p VLOCInLocs. The live-ins for \\p MBB\n  /// are computed and stored into \\p VLOCInLocs. \\returns true if the live-ins\n  /// are modified.\n  /// \\p InLocsT Output argument, storage for calculated live-ins.\n  /// \\returns two bools -- the first indicates whether a change\n  /// was made, the second whether a lattice downgrade occurred. If the latter\n  /// is true, revisiting this block is necessary.\n  std::tuple<bool, bool>\n  vlocJoin(MachineBasicBlock &MBB, LiveIdxT &VLOCOutLocs, LiveIdxT &VLOCInLocs,\n           SmallPtrSet<const MachineBasicBlock *, 16> *VLOCVisited,\n           unsigned BBNum, const SmallSet<DebugVariable, 4> &AllVars,\n           ValueIDNum **MOutLocs, ValueIDNum **MInLocs,\n           SmallPtrSet<const MachineBasicBlock *, 8> &InScopeBlocks,\n           SmallPtrSet<const MachineBasicBlock *, 8> &BlocksToExplore,\n           DenseMap<DebugVariable, DbgValue> &InLocsT);\n\n  /// Continue exploration of the variable-value lattice, as explained in the\n  /// file-level comment. \\p OldLiveInLocation contains the current\n  /// exploration position, from which we need to descend further. \\p Values\n  /// contains the set of live-in values, \\p CurBlockRPONum the RPO number of\n  /// the current block, and \\p CandidateLocations a set of locations that\n  /// should be considered as PHI locations, if we reach the bottom of the\n  /// lattice. \\returns true if we should downgrade; the value is the agreeing\n  /// value number in a non-backedge predecessor.\n  bool vlocDowngradeLattice(const MachineBasicBlock &MBB,\n                            const DbgValue &OldLiveInLocation,\n                            const SmallVectorImpl<InValueT> &Values,\n                            unsigned CurBlockRPONum);\n\n  /// For the given block and live-outs feeding into it, try to find a\n  /// machine location where they all join. If a solution for all predecessors\n  /// can't be found, a location where all non-backedge-predecessors join\n  /// will be returned instead. While this method finds a join location, this\n  /// says nothing as to whether it should be used.\n  /// \\returns Pair of value ID if found, and true when the correct value\n  /// is available on all predecessor edges, or false if it's only available\n  /// for non-backedge predecessors.\n  std::tuple<Optional<ValueIDNum>, bool>\n  pickVPHILoc(MachineBasicBlock &MBB, const DebugVariable &Var,\n              const LiveIdxT &LiveOuts, ValueIDNum **MOutLocs,\n              ValueIDNum **MInLocs,\n              const SmallVectorImpl<MachineBasicBlock *> &BlockOrders);\n\n  /// Given the solutions to the two dataflow problems, machine value locations\n  /// in \\p MInLocs and live-in variable values in \\p SavedLiveIns, runs the\n  /// TransferTracker class over the function to produce live-in and transfer\n  /// DBG_VALUEs, then inserts them. Groups of DBG_VALUEs are inserted in the\n  /// order given by AllVarsNumbering -- this could be any stable order, but\n  /// right now \"order of appearence in function, when explored in RPO\", so\n  /// that we can compare explictly against VarLocBasedImpl.\n  void emitLocations(MachineFunction &MF, LiveInsT SavedLiveIns,\n                     ValueIDNum **MInLocs,\n                     DenseMap<DebugVariable, unsigned> &AllVarsNumbering);\n\n  /// Boilerplate computation of some initial sets, artifical blocks and\n  /// RPOT block ordering.\n  void initialSetup(MachineFunction &MF);\n\n  bool ExtendRanges(MachineFunction &MF, TargetPassConfig *TPC) override;\n\npublic:\n  /// Default construct and initialize the pass.\n  InstrRefBasedLDV();\n\n  LLVM_DUMP_METHOD\n  void dump_mloc_transfer(const MLocTransferMap &mloc_transfer) const;\n\n  bool isCalleeSaved(LocIdx L) {\n    unsigned Reg = MTracker->LocIdxToLocID[L];\n    for (MCRegAliasIterator RAI(Reg, TRI, true); RAI.isValid(); ++RAI)\n      if (CalleeSavedRegs.test(*RAI))\n        return true;\n    return false;\n  }\n};\n\n} // end anonymous namespace\n\n//===----------------------------------------------------------------------===//\n//            Implementation\n//===----------------------------------------------------------------------===//\n\nValueIDNum ValueIDNum::EmptyValue = {UINT_MAX, UINT_MAX, UINT_MAX};\n\n/// Default construct and initialize the pass.\nInstrRefBasedLDV::InstrRefBasedLDV() {}\n\n//===----------------------------------------------------------------------===//\n//            Debug Range Extension Implementation\n//===----------------------------------------------------------------------===//\n\n#ifndef NDEBUG\n// Something to restore in the future.\n// void InstrRefBasedLDV::printVarLocInMBB(..)\n#endif\n\nSpillLoc\nInstrRefBasedLDV::extractSpillBaseRegAndOffset(const MachineInstr &MI) {\n  assert(MI.hasOneMemOperand() &&\n         \"Spill instruction does not have exactly one memory operand?\");\n  auto MMOI = MI.memoperands_begin();\n  const PseudoSourceValue *PVal = (*MMOI)->getPseudoValue();\n  assert(PVal->kind() == PseudoSourceValue::FixedStack &&\n         \"Inconsistent memory operand in spill instruction\");\n  int FI = cast<FixedStackPseudoSourceValue>(PVal)->getFrameIndex();\n  const MachineBasicBlock *MBB = MI.getParent();\n  Register Reg;\n  StackOffset Offset = TFI->getFrameIndexReference(*MBB->getParent(), FI, Reg);\n  return {Reg, Offset};\n}\n\n/// End all previous ranges related to @MI and start a new range from @MI\n/// if it is a DBG_VALUE instr.\nbool InstrRefBasedLDV::transferDebugValue(const MachineInstr &MI) {\n  if (!MI.isDebugValue())\n    return false;\n\n  const DILocalVariable *Var = MI.getDebugVariable();\n  const DIExpression *Expr = MI.getDebugExpression();\n  const DILocation *DebugLoc = MI.getDebugLoc();\n  const DILocation *InlinedAt = DebugLoc->getInlinedAt();\n  assert(Var->isValidLocationForIntrinsic(DebugLoc) &&\n         \"Expected inlined-at fields to agree\");\n\n  DebugVariable V(Var, Expr, InlinedAt);\n  DbgValueProperties Properties(MI);\n\n  // If there are no instructions in this lexical scope, do no location tracking\n  // at all, this variable shouldn't get a legitimate location range.\n  auto *Scope = LS.findLexicalScope(MI.getDebugLoc().get());\n  if (Scope == nullptr)\n    return true; // handled it; by doing nothing\n\n  const MachineOperand &MO = MI.getOperand(0);\n\n  // MLocTracker needs to know that this register is read, even if it's only\n  // read by a debug inst.\n  if (MO.isReg() && MO.getReg() != 0)\n    (void)MTracker->readReg(MO.getReg());\n\n  // If we're preparing for the second analysis (variables), the machine value\n  // locations are already solved, and we report this DBG_VALUE and the value\n  // it refers to to VLocTracker.\n  if (VTracker) {\n    if (MO.isReg()) {\n      // Feed defVar the new variable location, or if this is a\n      // DBG_VALUE $noreg, feed defVar None.\n      if (MO.getReg())\n        VTracker->defVar(MI, Properties, MTracker->readReg(MO.getReg()));\n      else\n        VTracker->defVar(MI, Properties, None);\n    } else if (MI.getOperand(0).isImm() || MI.getOperand(0).isFPImm() ||\n               MI.getOperand(0).isCImm()) {\n      VTracker->defVar(MI, MI.getOperand(0));\n    }\n  }\n\n  // If performing final tracking of transfers, report this variable definition\n  // to the TransferTracker too.\n  if (TTracker)\n    TTracker->redefVar(MI);\n  return true;\n}\n\nbool InstrRefBasedLDV::transferDebugInstrRef(MachineInstr &MI) {\n  if (!MI.isDebugRef())\n    return false;\n\n  // Only handle this instruction when we are building the variable value\n  // transfer function.\n  if (!VTracker)\n    return false;\n\n  unsigned InstNo = MI.getOperand(0).getImm();\n  unsigned OpNo = MI.getOperand(1).getImm();\n\n  const DILocalVariable *Var = MI.getDebugVariable();\n  const DIExpression *Expr = MI.getDebugExpression();\n  const DILocation *DebugLoc = MI.getDebugLoc();\n  const DILocation *InlinedAt = DebugLoc->getInlinedAt();\n  assert(Var->isValidLocationForIntrinsic(DebugLoc) &&\n         \"Expected inlined-at fields to agree\");\n\n  DebugVariable V(Var, Expr, InlinedAt);\n\n  auto *Scope = LS.findLexicalScope(MI.getDebugLoc().get());\n  if (Scope == nullptr)\n    return true; // Handled by doing nothing. This variable is never in scope.\n\n  const MachineFunction &MF = *MI.getParent()->getParent();\n\n  // Various optimizations may have happened to the value during codegen,\n  // recorded in the value substitution table. Apply any substitutions to\n  // the instruction / operand number in this DBG_INSTR_REF.\n  auto Sub = MF.DebugValueSubstitutions.find(std::make_pair(InstNo, OpNo));\n  while (Sub != MF.DebugValueSubstitutions.end()) {\n    InstNo = Sub->second.first;\n    OpNo = Sub->second.second;\n    Sub = MF.DebugValueSubstitutions.find(std::make_pair(InstNo, OpNo));\n  }\n\n  // Default machine value number is <None> -- if no instruction defines\n  // the corresponding value, it must have been optimized out.\n  Optional<ValueIDNum> NewID = None;\n\n  // Try to lookup the instruction number, and find the machine value number\n  // that it defines.\n  auto InstrIt = DebugInstrNumToInstr.find(InstNo);\n  if (InstrIt != DebugInstrNumToInstr.end()) {\n    const MachineInstr &TargetInstr = *InstrIt->second.first;\n    uint64_t BlockNo = TargetInstr.getParent()->getNumber();\n\n    // Pick out the designated operand.\n    assert(OpNo < TargetInstr.getNumOperands());\n    const MachineOperand &MO = TargetInstr.getOperand(OpNo);\n\n    // Today, this can only be a register.\n    assert(MO.isReg() && MO.isDef());\n\n    unsigned LocID = MTracker->getLocID(MO.getReg(), false);\n    LocIdx L = MTracker->LocIDToLocIdx[LocID];\n    NewID = ValueIDNum(BlockNo, InstrIt->second.second, L);\n  }\n\n  // We, we have a value number or None. Tell the variable value tracker about\n  // it. The rest of this LiveDebugValues implementation acts exactly the same\n  // for DBG_INSTR_REFs as DBG_VALUEs (just, the former can refer to values that\n  // aren't immediately available).\n  DbgValueProperties Properties(Expr, false);\n  VTracker->defVar(MI, Properties, NewID);\n\n  // If we're on the final pass through the function, decompose this INSTR_REF\n  // into a plain DBG_VALUE.\n  if (!TTracker)\n    return true;\n\n  // Pick a location for the machine value number, if such a location exists.\n  // (This information could be stored in TransferTracker to make it faster).\n  Optional<LocIdx> FoundLoc = None;\n  for (auto Location : MTracker->locations()) {\n    LocIdx CurL = Location.Idx;\n    ValueIDNum ID = MTracker->LocIdxToIDNum[CurL];\n    if (NewID && ID == NewID) {\n      // If this is the first location with that value, pick it. Otherwise,\n      // consider whether it's a \"longer term\" location.\n      if (!FoundLoc) {\n        FoundLoc = CurL;\n        continue;\n      }\n\n      if (MTracker->isSpill(CurL))\n        FoundLoc = CurL; // Spills are a longer term location.\n      else if (!MTracker->isSpill(*FoundLoc) &&\n               !MTracker->isSpill(CurL) &&\n               !isCalleeSaved(*FoundLoc) &&\n               isCalleeSaved(CurL))\n        FoundLoc = CurL; // Callee saved regs are longer term than normal.\n    }\n  }\n\n  // Tell transfer tracker that the variable value has changed.\n  TTracker->redefVar(MI, Properties, FoundLoc);\n\n  // If there was a value with no location; but the value is defined in a\n  // later instruction in this block, this is a block-local use-before-def.\n  if (!FoundLoc && NewID && NewID->getBlock() == CurBB &&\n      NewID->getInst() > CurInst)\n    TTracker->addUseBeforeDef(V, {MI.getDebugExpression(), false}, *NewID);\n\n  // Produce a DBG_VALUE representing what this DBG_INSTR_REF meant.\n  // This DBG_VALUE is potentially a $noreg / undefined location, if\n  // FoundLoc is None.\n  // (XXX -- could morph the DBG_INSTR_REF in the future).\n  MachineInstr *DbgMI = MTracker->emitLoc(FoundLoc, V, Properties);\n  TTracker->PendingDbgValues.push_back(DbgMI);\n  TTracker->flushDbgValues(MI.getIterator(), nullptr);\n\n  return true;\n}\n\nvoid InstrRefBasedLDV::transferRegisterDef(MachineInstr &MI) {\n  // Meta Instructions do not affect the debug liveness of any register they\n  // define.\n  if (MI.isImplicitDef()) {\n    // Except when there's an implicit def, and the location it's defining has\n    // no value number. The whole point of an implicit def is to announce that\n    // the register is live, without be specific about it's value. So define\n    // a value if there isn't one already.\n    ValueIDNum Num = MTracker->readReg(MI.getOperand(0).getReg());\n    // Has a legitimate value -> ignore the implicit def.\n    if (Num.getLoc() != 0)\n      return;\n    // Otherwise, def it here.\n  } else if (MI.isMetaInstruction())\n    return;\n\n  MachineFunction *MF = MI.getMF();\n  const TargetLowering *TLI = MF->getSubtarget().getTargetLowering();\n  Register SP = TLI->getStackPointerRegisterToSaveRestore();\n\n  // Find the regs killed by MI, and find regmasks of preserved regs.\n  // Max out the number of statically allocated elements in `DeadRegs`, as this\n  // prevents fallback to std::set::count() operations.\n  SmallSet<uint32_t, 32> DeadRegs;\n  SmallVector<const uint32_t *, 4> RegMasks;\n  SmallVector<const MachineOperand *, 4> RegMaskPtrs;\n  for (const MachineOperand &MO : MI.operands()) {\n    // Determine whether the operand is a register def.\n    if (MO.isReg() && MO.isDef() && MO.getReg() &&\n        Register::isPhysicalRegister(MO.getReg()) &&\n        !(MI.isCall() && MO.getReg() == SP)) {\n      // Remove ranges of all aliased registers.\n      for (MCRegAliasIterator RAI(MO.getReg(), TRI, true); RAI.isValid(); ++RAI)\n        // FIXME: Can we break out of this loop early if no insertion occurs?\n        DeadRegs.insert(*RAI);\n    } else if (MO.isRegMask()) {\n      RegMasks.push_back(MO.getRegMask());\n      RegMaskPtrs.push_back(&MO);\n    }\n  }\n\n  // Tell MLocTracker about all definitions, of regmasks and otherwise.\n  for (uint32_t DeadReg : DeadRegs)\n    MTracker->defReg(DeadReg, CurBB, CurInst);\n\n  for (auto *MO : RegMaskPtrs)\n    MTracker->writeRegMask(MO, CurBB, CurInst);\n}\n\nvoid InstrRefBasedLDV::performCopy(Register SrcRegNum, Register DstRegNum) {\n  ValueIDNum SrcValue = MTracker->readReg(SrcRegNum);\n\n  MTracker->setReg(DstRegNum, SrcValue);\n\n  // In all circumstances, re-def the super registers. It's definitely a new\n  // value now. This doesn't uniquely identify the composition of subregs, for\n  // example, two identical values in subregisters composed in different\n  // places would not get equal value numbers.\n  for (MCSuperRegIterator SRI(DstRegNum, TRI); SRI.isValid(); ++SRI)\n    MTracker->defReg(*SRI, CurBB, CurInst);\n\n  // If we're emulating VarLocBasedImpl, just define all the subregisters.\n  // DBG_VALUEs of them will expect to be tracked from the DBG_VALUE, not\n  // through prior copies.\n  if (EmulateOldLDV) {\n    for (MCSubRegIndexIterator DRI(DstRegNum, TRI); DRI.isValid(); ++DRI)\n      MTracker->defReg(DRI.getSubReg(), CurBB, CurInst);\n    return;\n  }\n\n  // Otherwise, actually copy subregisters from one location to another.\n  // XXX: in addition, any subregisters of DstRegNum that don't line up with\n  // the source register should be def'd.\n  for (MCSubRegIndexIterator SRI(SrcRegNum, TRI); SRI.isValid(); ++SRI) {\n    unsigned SrcSubReg = SRI.getSubReg();\n    unsigned SubRegIdx = SRI.getSubRegIndex();\n    unsigned DstSubReg = TRI->getSubReg(DstRegNum, SubRegIdx);\n    if (!DstSubReg)\n      continue;\n\n    // Do copy. There are two matching subregisters, the source value should\n    // have been def'd when the super-reg was, the latter might not be tracked\n    // yet.\n    // This will force SrcSubReg to be tracked, if it isn't yet.\n    (void)MTracker->readReg(SrcSubReg);\n    LocIdx SrcL = MTracker->getRegMLoc(SrcSubReg);\n    assert(SrcL.asU64());\n    (void)MTracker->readReg(DstSubReg);\n    LocIdx DstL = MTracker->getRegMLoc(DstSubReg);\n    assert(DstL.asU64());\n    (void)DstL;\n    ValueIDNum CpyValue = {SrcValue.getBlock(), SrcValue.getInst(), SrcL};\n\n    MTracker->setReg(DstSubReg, CpyValue);\n  }\n}\n\nbool InstrRefBasedLDV::isSpillInstruction(const MachineInstr &MI,\n                                          MachineFunction *MF) {\n  // TODO: Handle multiple stores folded into one.\n  if (!MI.hasOneMemOperand())\n    return false;\n\n  if (!MI.getSpillSize(TII) && !MI.getFoldedSpillSize(TII))\n    return false; // This is not a spill instruction, since no valid size was\n                  // returned from either function.\n\n  return true;\n}\n\nbool InstrRefBasedLDV::isLocationSpill(const MachineInstr &MI,\n                                       MachineFunction *MF, unsigned &Reg) {\n  if (!isSpillInstruction(MI, MF))\n    return false;\n\n  // XXX FIXME: On x86, isStoreToStackSlotPostFE returns '1' instead of an\n  // actual register number.\n  if (ObserveAllStackops) {\n    int FI;\n    Reg = TII->isStoreToStackSlotPostFE(MI, FI);\n    return Reg != 0;\n  }\n\n  auto isKilledReg = [&](const MachineOperand MO, unsigned &Reg) {\n    if (!MO.isReg() || !MO.isUse()) {\n      Reg = 0;\n      return false;\n    }\n    Reg = MO.getReg();\n    return MO.isKill();\n  };\n\n  for (const MachineOperand &MO : MI.operands()) {\n    // In a spill instruction generated by the InlineSpiller the spilled\n    // register has its kill flag set.\n    if (isKilledReg(MO, Reg))\n      return true;\n    if (Reg != 0) {\n      // Check whether next instruction kills the spilled register.\n      // FIXME: Current solution does not cover search for killed register in\n      // bundles and instructions further down the chain.\n      auto NextI = std::next(MI.getIterator());\n      // Skip next instruction that points to basic block end iterator.\n      if (MI.getParent()->end() == NextI)\n        continue;\n      unsigned RegNext;\n      for (const MachineOperand &MONext : NextI->operands()) {\n        // Return true if we came across the register from the\n        // previous spill instruction that is killed in NextI.\n        if (isKilledReg(MONext, RegNext) && RegNext == Reg)\n          return true;\n      }\n    }\n  }\n  // Return false if we didn't find spilled register.\n  return false;\n}\n\nOptional<SpillLoc>\nInstrRefBasedLDV::isRestoreInstruction(const MachineInstr &MI,\n                                       MachineFunction *MF, unsigned &Reg) {\n  if (!MI.hasOneMemOperand())\n    return None;\n\n  // FIXME: Handle folded restore instructions with more than one memory\n  // operand.\n  if (MI.getRestoreSize(TII)) {\n    Reg = MI.getOperand(0).getReg();\n    return extractSpillBaseRegAndOffset(MI);\n  }\n  return None;\n}\n\nbool InstrRefBasedLDV::transferSpillOrRestoreInst(MachineInstr &MI) {\n  // XXX -- it's too difficult to implement VarLocBasedImpl's  stack location\n  // limitations under the new model. Therefore, when comparing them, compare\n  // versions that don't attempt spills or restores at all.\n  if (EmulateOldLDV)\n    return false;\n\n  MachineFunction *MF = MI.getMF();\n  unsigned Reg;\n  Optional<SpillLoc> Loc;\n\n  LLVM_DEBUG(dbgs() << \"Examining instruction: \"; MI.dump(););\n\n  // First, if there are any DBG_VALUEs pointing at a spill slot that is\n  // written to, terminate that variable location. The value in memory\n  // will have changed. DbgEntityHistoryCalculator doesn't try to detect this.\n  if (isSpillInstruction(MI, MF)) {\n    Loc = extractSpillBaseRegAndOffset(MI);\n\n    if (TTracker) {\n      Optional<LocIdx> MLoc = MTracker->getSpillMLoc(*Loc);\n      if (MLoc)\n        TTracker->clobberMloc(*MLoc, MI.getIterator());\n    }\n  }\n\n  // Try to recognise spill and restore instructions that may transfer a value.\n  if (isLocationSpill(MI, MF, Reg)) {\n    Loc = extractSpillBaseRegAndOffset(MI);\n    auto ValueID = MTracker->readReg(Reg);\n\n    // If the location is empty, produce a phi, signify it's the live-in value.\n    if (ValueID.getLoc() == 0)\n      ValueID = {CurBB, 0, MTracker->getRegMLoc(Reg)};\n\n    MTracker->setSpill(*Loc, ValueID);\n    auto OptSpillLocIdx = MTracker->getSpillMLoc(*Loc);\n    assert(OptSpillLocIdx && \"Spill slot set but has no LocIdx?\");\n    LocIdx SpillLocIdx = *OptSpillLocIdx;\n\n    // Tell TransferTracker about this spill, produce DBG_VALUEs for it.\n    if (TTracker)\n      TTracker->transferMlocs(MTracker->getRegMLoc(Reg), SpillLocIdx,\n                              MI.getIterator());\n  } else {\n    if (!(Loc = isRestoreInstruction(MI, MF, Reg)))\n      return false;\n\n    // Is there a value to be restored?\n    auto OptValueID = MTracker->readSpill(*Loc);\n    if (OptValueID) {\n      ValueIDNum ValueID = *OptValueID;\n      LocIdx SpillLocIdx = *MTracker->getSpillMLoc(*Loc);\n      // XXX -- can we recover sub-registers of this value? Until we can, first\n      // overwrite all defs of the register being restored to.\n      for (MCRegAliasIterator RAI(Reg, TRI, true); RAI.isValid(); ++RAI)\n        MTracker->defReg(*RAI, CurBB, CurInst);\n\n      // Now override the reg we're restoring to.\n      MTracker->setReg(Reg, ValueID);\n\n      // Report this restore to the transfer tracker too.\n      if (TTracker)\n        TTracker->transferMlocs(SpillLocIdx, MTracker->getRegMLoc(Reg),\n                                MI.getIterator());\n    } else {\n      // There isn't anything in the location; not clear if this is a code path\n      // that still runs. Def this register anyway just in case.\n      for (MCRegAliasIterator RAI(Reg, TRI, true); RAI.isValid(); ++RAI)\n        MTracker->defReg(*RAI, CurBB, CurInst);\n\n      // Force the spill slot to be tracked.\n      LocIdx L = MTracker->getOrTrackSpillLoc(*Loc);\n\n      // Set the restored value to be a machine phi number, signifying that it's\n      // whatever the spills live-in value is in this block. Definitely has\n      // a LocIdx due to the setSpill above.\n      ValueIDNum ValueID = {CurBB, 0, L};\n      MTracker->setReg(Reg, ValueID);\n      MTracker->setSpill(*Loc, ValueID);\n    }\n  }\n  return true;\n}\n\nbool InstrRefBasedLDV::transferRegisterCopy(MachineInstr &MI) {\n  auto DestSrc = TII->isCopyInstr(MI);\n  if (!DestSrc)\n    return false;\n\n  const MachineOperand *DestRegOp = DestSrc->Destination;\n  const MachineOperand *SrcRegOp = DestSrc->Source;\n\n  auto isCalleeSavedReg = [&](unsigned Reg) {\n    for (MCRegAliasIterator RAI(Reg, TRI, true); RAI.isValid(); ++RAI)\n      if (CalleeSavedRegs.test(*RAI))\n        return true;\n    return false;\n  };\n\n  Register SrcReg = SrcRegOp->getReg();\n  Register DestReg = DestRegOp->getReg();\n\n  // Ignore identity copies. Yep, these make it as far as LiveDebugValues.\n  if (SrcReg == DestReg)\n    return true;\n\n  // For emulating VarLocBasedImpl:\n  // We want to recognize instructions where destination register is callee\n  // saved register. If register that could be clobbered by the call is\n  // included, there would be a great chance that it is going to be clobbered\n  // soon. It is more likely that previous register, which is callee saved, is\n  // going to stay unclobbered longer, even if it is killed.\n  //\n  // For InstrRefBasedImpl, we can track multiple locations per value, so\n  // ignore this condition.\n  if (EmulateOldLDV && !isCalleeSavedReg(DestReg))\n    return false;\n\n  // InstrRefBasedImpl only followed killing copies.\n  if (EmulateOldLDV && !SrcRegOp->isKill())\n    return false;\n\n  // Copy MTracker info, including subregs if available.\n  InstrRefBasedLDV::performCopy(SrcReg, DestReg);\n\n  // Only produce a transfer of DBG_VALUE within a block where old LDV\n  // would have. We might make use of the additional value tracking in some\n  // other way, later.\n  if (TTracker && isCalleeSavedReg(DestReg) && SrcRegOp->isKill())\n    TTracker->transferMlocs(MTracker->getRegMLoc(SrcReg),\n                            MTracker->getRegMLoc(DestReg), MI.getIterator());\n\n  // VarLocBasedImpl would quit tracking the old location after copying.\n  if (EmulateOldLDV && SrcReg != DestReg)\n    MTracker->defReg(SrcReg, CurBB, CurInst);\n\n  return true;\n}\n\n/// Accumulate a mapping between each DILocalVariable fragment and other\n/// fragments of that DILocalVariable which overlap. This reduces work during\n/// the data-flow stage from \"Find any overlapping fragments\" to \"Check if the\n/// known-to-overlap fragments are present\".\n/// \\param MI A previously unprocessed DEBUG_VALUE instruction to analyze for\n///           fragment usage.\nvoid InstrRefBasedLDV::accumulateFragmentMap(MachineInstr &MI) {\n  DebugVariable MIVar(MI.getDebugVariable(), MI.getDebugExpression(),\n                      MI.getDebugLoc()->getInlinedAt());\n  FragmentInfo ThisFragment = MIVar.getFragmentOrDefault();\n\n  // If this is the first sighting of this variable, then we are guaranteed\n  // there are currently no overlapping fragments either. Initialize the set\n  // of seen fragments, record no overlaps for the current one, and return.\n  auto SeenIt = SeenFragments.find(MIVar.getVariable());\n  if (SeenIt == SeenFragments.end()) {\n    SmallSet<FragmentInfo, 4> OneFragment;\n    OneFragment.insert(ThisFragment);\n    SeenFragments.insert({MIVar.getVariable(), OneFragment});\n\n    OverlapFragments.insert({{MIVar.getVariable(), ThisFragment}, {}});\n    return;\n  }\n\n  // If this particular Variable/Fragment pair already exists in the overlap\n  // map, it has already been accounted for.\n  auto IsInOLapMap =\n      OverlapFragments.insert({{MIVar.getVariable(), ThisFragment}, {}});\n  if (!IsInOLapMap.second)\n    return;\n\n  auto &ThisFragmentsOverlaps = IsInOLapMap.first->second;\n  auto &AllSeenFragments = SeenIt->second;\n\n  // Otherwise, examine all other seen fragments for this variable, with \"this\"\n  // fragment being a previously unseen fragment. Record any pair of\n  // overlapping fragments.\n  for (auto &ASeenFragment : AllSeenFragments) {\n    // Does this previously seen fragment overlap?\n    if (DIExpression::fragmentsOverlap(ThisFragment, ASeenFragment)) {\n      // Yes: Mark the current fragment as being overlapped.\n      ThisFragmentsOverlaps.push_back(ASeenFragment);\n      // Mark the previously seen fragment as being overlapped by the current\n      // one.\n      auto ASeenFragmentsOverlaps =\n          OverlapFragments.find({MIVar.getVariable(), ASeenFragment});\n      assert(ASeenFragmentsOverlaps != OverlapFragments.end() &&\n             \"Previously seen var fragment has no vector of overlaps\");\n      ASeenFragmentsOverlaps->second.push_back(ThisFragment);\n    }\n  }\n\n  AllSeenFragments.insert(ThisFragment);\n}\n\nvoid InstrRefBasedLDV::process(MachineInstr &MI) {\n  // Try to interpret an MI as a debug or transfer instruction. Only if it's\n  // none of these should we interpret it's register defs as new value\n  // definitions.\n  if (transferDebugValue(MI))\n    return;\n  if (transferDebugInstrRef(MI))\n    return;\n  if (transferRegisterCopy(MI))\n    return;\n  if (transferSpillOrRestoreInst(MI))\n    return;\n  transferRegisterDef(MI);\n}\n\nvoid InstrRefBasedLDV::produceMLocTransferFunction(\n    MachineFunction &MF, SmallVectorImpl<MLocTransferMap> &MLocTransfer,\n    unsigned MaxNumBlocks) {\n  // Because we try to optimize around register mask operands by ignoring regs\n  // that aren't currently tracked, we set up something ugly for later: RegMask\n  // operands that are seen earlier than the first use of a register, still need\n  // to clobber that register in the transfer function. But this information\n  // isn't actively recorded. Instead, we track each RegMask used in each block,\n  // and accumulated the clobbered but untracked registers in each block into\n  // the following bitvector. Later, if new values are tracked, we can add\n  // appropriate clobbers.\n  SmallVector<BitVector, 32> BlockMasks;\n  BlockMasks.resize(MaxNumBlocks);\n\n  // Reserve one bit per register for the masks described above.\n  unsigned BVWords = MachineOperand::getRegMaskSize(TRI->getNumRegs());\n  for (auto &BV : BlockMasks)\n    BV.resize(TRI->getNumRegs(), true);\n\n  // Step through all instructions and inhale the transfer function.\n  for (auto &MBB : MF) {\n    // Object fields that are read by trackers to know where we are in the\n    // function.\n    CurBB = MBB.getNumber();\n    CurInst = 1;\n\n    // Set all machine locations to a PHI value. For transfer function\n    // production only, this signifies the live-in value to the block.\n    MTracker->reset();\n    MTracker->setMPhis(CurBB);\n\n    // Step through each instruction in this block.\n    for (auto &MI : MBB) {\n      process(MI);\n      // Also accumulate fragment map.\n      if (MI.isDebugValue())\n        accumulateFragmentMap(MI);\n\n      // Create a map from the instruction number (if present) to the\n      // MachineInstr and its position.\n      if (uint64_t InstrNo = MI.peekDebugInstrNum()) {\n        auto InstrAndPos = std::make_pair(&MI, CurInst);\n        auto InsertResult =\n            DebugInstrNumToInstr.insert(std::make_pair(InstrNo, InstrAndPos));\n\n        // There should never be duplicate instruction numbers.\n        assert(InsertResult.second);\n        (void)InsertResult;\n      }\n\n      ++CurInst;\n    }\n\n    // Produce the transfer function, a map of machine location to new value. If\n    // any machine location has the live-in phi value from the start of the\n    // block, it's live-through and doesn't need recording in the transfer\n    // function.\n    for (auto Location : MTracker->locations()) {\n      LocIdx Idx = Location.Idx;\n      ValueIDNum &P = Location.Value;\n      if (P.isPHI() && P.getLoc() == Idx.asU64())\n        continue;\n\n      // Insert-or-update.\n      auto &TransferMap = MLocTransfer[CurBB];\n      auto Result = TransferMap.insert(std::make_pair(Idx.asU64(), P));\n      if (!Result.second)\n        Result.first->second = P;\n    }\n\n    // Accumulate any bitmask operands into the clobberred reg mask for this\n    // block.\n    for (auto &P : MTracker->Masks) {\n      BlockMasks[CurBB].clearBitsNotInMask(P.first->getRegMask(), BVWords);\n    }\n  }\n\n  // Compute a bitvector of all the registers that are tracked in this block.\n  const TargetLowering *TLI = MF.getSubtarget().getTargetLowering();\n  Register SP = TLI->getStackPointerRegisterToSaveRestore();\n  BitVector UsedRegs(TRI->getNumRegs());\n  for (auto Location : MTracker->locations()) {\n    unsigned ID = MTracker->LocIdxToLocID[Location.Idx];\n    if (ID >= TRI->getNumRegs() || ID == SP)\n      continue;\n    UsedRegs.set(ID);\n  }\n\n  // Check that any regmask-clobber of a register that gets tracked, is not\n  // live-through in the transfer function. It needs to be clobbered at the\n  // very least.\n  for (unsigned int I = 0; I < MaxNumBlocks; ++I) {\n    BitVector &BV = BlockMasks[I];\n    BV.flip();\n    BV &= UsedRegs;\n    // This produces all the bits that we clobber, but also use. Check that\n    // they're all clobbered or at least set in the designated transfer\n    // elem.\n    for (unsigned Bit : BV.set_bits()) {\n      unsigned ID = MTracker->getLocID(Bit, false);\n      LocIdx Idx = MTracker->LocIDToLocIdx[ID];\n      auto &TransferMap = MLocTransfer[I];\n\n      // Install a value representing the fact that this location is effectively\n      // written to in this block. As there's no reserved value, instead use\n      // a value number that is never generated. Pick the value number for the\n      // first instruction in the block, def'ing this location, which we know\n      // this block never used anyway.\n      ValueIDNum NotGeneratedNum = ValueIDNum(I, 1, Idx);\n      auto Result =\n        TransferMap.insert(std::make_pair(Idx.asU64(), NotGeneratedNum));\n      if (!Result.second) {\n        ValueIDNum &ValueID = Result.first->second;\n        if (ValueID.getBlock() == I && ValueID.isPHI())\n          // It was left as live-through. Set it to clobbered.\n          ValueID = NotGeneratedNum;\n      }\n    }\n  }\n}\n\nstd::tuple<bool, bool>\nInstrRefBasedLDV::mlocJoin(MachineBasicBlock &MBB,\n                           SmallPtrSet<const MachineBasicBlock *, 16> &Visited,\n                           ValueIDNum **OutLocs, ValueIDNum *InLocs) {\n  LLVM_DEBUG(dbgs() << \"join MBB: \" << MBB.getNumber() << \"\\n\");\n  bool Changed = false;\n  bool DowngradeOccurred = false;\n\n  // Collect predecessors that have been visited. Anything that hasn't been\n  // visited yet is a backedge on the first iteration, and the meet of it's\n  // lattice value for all locations will be unaffected.\n  SmallVector<const MachineBasicBlock *, 8> BlockOrders;\n  for (auto Pred : MBB.predecessors()) {\n    if (Visited.count(Pred)) {\n      BlockOrders.push_back(Pred);\n    }\n  }\n\n  // Visit predecessors in RPOT order.\n  auto Cmp = [&](const MachineBasicBlock *A, const MachineBasicBlock *B) {\n    return BBToOrder.find(A)->second < BBToOrder.find(B)->second;\n  };\n  llvm::sort(BlockOrders, Cmp);\n\n  // Skip entry block.\n  if (BlockOrders.size() == 0)\n    return std::tuple<bool, bool>(false, false);\n\n  // Step through all machine locations, then look at each predecessor and\n  // detect disagreements.\n  unsigned ThisBlockRPO = BBToOrder.find(&MBB)->second;\n  for (auto Location : MTracker->locations()) {\n    LocIdx Idx = Location.Idx;\n    // Pick out the first predecessors live-out value for this location. It's\n    // guaranteed to be not a backedge, as we order by RPO.\n    ValueIDNum BaseVal = OutLocs[BlockOrders[0]->getNumber()][Idx.asU64()];\n\n    // Some flags for whether there's a disagreement, and whether it's a\n    // disagreement with a backedge or not.\n    bool Disagree = false;\n    bool NonBackEdgeDisagree = false;\n\n    // Loop around everything that wasn't 'base'.\n    for (unsigned int I = 1; I < BlockOrders.size(); ++I) {\n      auto *MBB = BlockOrders[I];\n      if (BaseVal != OutLocs[MBB->getNumber()][Idx.asU64()]) {\n        // Live-out of a predecessor disagrees with the first predecessor.\n        Disagree = true;\n\n        // Test whether it's a disagreemnt in the backedges or not.\n        if (BBToOrder.find(MBB)->second < ThisBlockRPO) // might be self b/e\n          NonBackEdgeDisagree = true;\n      }\n    }\n\n    bool OverRide = false;\n    if (Disagree && !NonBackEdgeDisagree) {\n      // Only the backedges disagree. Consider demoting the livein\n      // lattice value, as per the file level comment. The value we consider\n      // demoting to is the value that the non-backedge predecessors agree on.\n      // The order of values is that non-PHIs are \\top, a PHI at this block\n      // \\bot, and phis between the two are ordered by their RPO number.\n      // If there's no agreement, or we've already demoted to this PHI value\n      // before, replace with a PHI value at this block.\n\n      // Calculate order numbers: zero means normal def, nonzero means RPO\n      // number.\n      unsigned BaseBlockRPONum = BBNumToRPO[BaseVal.getBlock()] + 1;\n      if (!BaseVal.isPHI())\n        BaseBlockRPONum = 0;\n\n      ValueIDNum &InLocID = InLocs[Idx.asU64()];\n      unsigned InLocRPONum = BBNumToRPO[InLocID.getBlock()] + 1;\n      if (!InLocID.isPHI())\n        InLocRPONum = 0;\n\n      // Should we ignore the disagreeing backedges, and override with the\n      // value the other predecessors agree on (in \"base\")?\n      unsigned ThisBlockRPONum = BBNumToRPO[MBB.getNumber()] + 1;\n      if (BaseBlockRPONum > InLocRPONum && BaseBlockRPONum < ThisBlockRPONum) {\n        // Override.\n        OverRide = true;\n        DowngradeOccurred = true;\n      }\n    }\n    // else: if we disagree in the non-backedges, then this is definitely\n    // a control flow merge where different values merge. Make it a PHI.\n\n    // Generate a phi...\n    ValueIDNum PHI = {(uint64_t)MBB.getNumber(), 0, Idx};\n    ValueIDNum NewVal = (Disagree && !OverRide) ? PHI : BaseVal;\n    if (InLocs[Idx.asU64()] != NewVal) {\n      Changed |= true;\n      InLocs[Idx.asU64()] = NewVal;\n    }\n  }\n\n  // TODO: Reimplement NumInserted and NumRemoved.\n  return std::tuple<bool, bool>(Changed, DowngradeOccurred);\n}\n\nvoid InstrRefBasedLDV::mlocDataflow(\n    ValueIDNum **MInLocs, ValueIDNum **MOutLocs,\n    SmallVectorImpl<MLocTransferMap> &MLocTransfer) {\n  std::priority_queue<unsigned int, std::vector<unsigned int>,\n                      std::greater<unsigned int>>\n      Worklist, Pending;\n\n  // We track what is on the current and pending worklist to avoid inserting\n  // the same thing twice. We could avoid this with a custom priority queue,\n  // but this is probably not worth it.\n  SmallPtrSet<MachineBasicBlock *, 16> OnPending, OnWorklist;\n\n  // Initialize worklist with every block to be visited.\n  for (unsigned int I = 0; I < BBToOrder.size(); ++I) {\n    Worklist.push(I);\n    OnWorklist.insert(OrderToBB[I]);\n  }\n\n  MTracker->reset();\n\n  // Set inlocs for entry block -- each as a PHI at the entry block. Represents\n  // the incoming value to the function.\n  MTracker->setMPhis(0);\n  for (auto Location : MTracker->locations())\n    MInLocs[0][Location.Idx.asU64()] = Location.Value;\n\n  SmallPtrSet<const MachineBasicBlock *, 16> Visited;\n  while (!Worklist.empty() || !Pending.empty()) {\n    // Vector for storing the evaluated block transfer function.\n    SmallVector<std::pair<LocIdx, ValueIDNum>, 32> ToRemap;\n\n    while (!Worklist.empty()) {\n      MachineBasicBlock *MBB = OrderToBB[Worklist.top()];\n      CurBB = MBB->getNumber();\n      Worklist.pop();\n\n      // Join the values in all predecessor blocks.\n      bool InLocsChanged, DowngradeOccurred;\n      std::tie(InLocsChanged, DowngradeOccurred) =\n          mlocJoin(*MBB, Visited, MOutLocs, MInLocs[CurBB]);\n      InLocsChanged |= Visited.insert(MBB).second;\n\n      // If a downgrade occurred, book us in for re-examination on the next\n      // iteration.\n      if (DowngradeOccurred && OnPending.insert(MBB).second)\n        Pending.push(BBToOrder[MBB]);\n\n      // Don't examine transfer function if we've visited this loc at least\n      // once, and inlocs haven't changed.\n      if (!InLocsChanged)\n        continue;\n\n      // Load the current set of live-ins into MLocTracker.\n      MTracker->loadFromArray(MInLocs[CurBB], CurBB);\n\n      // Each element of the transfer function can be a new def, or a read of\n      // a live-in value. Evaluate each element, and store to \"ToRemap\".\n      ToRemap.clear();\n      for (auto &P : MLocTransfer[CurBB]) {\n        if (P.second.getBlock() == CurBB && P.second.isPHI()) {\n          // This is a movement of whatever was live in. Read it.\n          ValueIDNum NewID = MTracker->getNumAtPos(P.second.getLoc());\n          ToRemap.push_back(std::make_pair(P.first, NewID));\n        } else {\n          // It's a def. Just set it.\n          assert(P.second.getBlock() == CurBB);\n          ToRemap.push_back(std::make_pair(P.first, P.second));\n        }\n      }\n\n      // Commit the transfer function changes into mloc tracker, which\n      // transforms the contents of the MLocTracker into the live-outs.\n      for (auto &P : ToRemap)\n        MTracker->setMLoc(P.first, P.second);\n\n      // Now copy out-locs from mloc tracker into out-loc vector, checking\n      // whether changes have occurred. These changes can have come from both\n      // the transfer function, and mlocJoin.\n      bool OLChanged = false;\n      for (auto Location : MTracker->locations()) {\n        OLChanged |= MOutLocs[CurBB][Location.Idx.asU64()] != Location.Value;\n        MOutLocs[CurBB][Location.Idx.asU64()] = Location.Value;\n      }\n\n      MTracker->reset();\n\n      // No need to examine successors again if out-locs didn't change.\n      if (!OLChanged)\n        continue;\n\n      // All successors should be visited: put any back-edges on the pending\n      // list for the next dataflow iteration, and any other successors to be\n      // visited this iteration, if they're not going to be already.\n      for (auto s : MBB->successors()) {\n        // Does branching to this successor represent a back-edge?\n        if (BBToOrder[s] > BBToOrder[MBB]) {\n          // No: visit it during this dataflow iteration.\n          if (OnWorklist.insert(s).second)\n            Worklist.push(BBToOrder[s]);\n        } else {\n          // Yes: visit it on the next iteration.\n          if (OnPending.insert(s).second)\n            Pending.push(BBToOrder[s]);\n        }\n      }\n    }\n\n    Worklist.swap(Pending);\n    std::swap(OnPending, OnWorklist);\n    OnPending.clear();\n    // At this point, pending must be empty, since it was just the empty\n    // worklist\n    assert(Pending.empty() && \"Pending should be empty\");\n  }\n\n  // Once all the live-ins don't change on mlocJoin(), we've reached a\n  // fixedpoint.\n}\n\nbool InstrRefBasedLDV::vlocDowngradeLattice(\n    const MachineBasicBlock &MBB, const DbgValue &OldLiveInLocation,\n    const SmallVectorImpl<InValueT> &Values, unsigned CurBlockRPONum) {\n  // Ranking value preference: see file level comment, the highest rank is\n  // a plain def, followed by PHI values in reverse post-order. Numerically,\n  // we assign all defs the rank '0', all PHIs their blocks RPO number plus\n  // one, and consider the lowest value the highest ranked.\n  int OldLiveInRank = BBNumToRPO[OldLiveInLocation.ID.getBlock()] + 1;\n  if (!OldLiveInLocation.ID.isPHI())\n    OldLiveInRank = 0;\n\n  // Allow any unresolvable conflict to be over-ridden.\n  if (OldLiveInLocation.Kind == DbgValue::NoVal) {\n    // Although if it was an unresolvable conflict from _this_ block, then\n    // all other seeking of downgrades and PHIs must have failed before hand.\n    if (OldLiveInLocation.BlockNo == (unsigned)MBB.getNumber())\n      return false;\n    OldLiveInRank = INT_MIN;\n  }\n\n  auto &InValue = *Values[0].second;\n\n  if (InValue.Kind == DbgValue::Const || InValue.Kind == DbgValue::NoVal)\n    return false;\n\n  unsigned ThisRPO = BBNumToRPO[InValue.ID.getBlock()];\n  int ThisRank = ThisRPO + 1;\n  if (!InValue.ID.isPHI())\n    ThisRank = 0;\n\n  // Too far down the lattice?\n  if (ThisRPO >= CurBlockRPONum)\n    return false;\n\n  // Higher in the lattice than what we've already explored?\n  if (ThisRank <= OldLiveInRank)\n    return false;\n\n  return true;\n}\n\nstd::tuple<Optional<ValueIDNum>, bool> InstrRefBasedLDV::pickVPHILoc(\n    MachineBasicBlock &MBB, const DebugVariable &Var, const LiveIdxT &LiveOuts,\n    ValueIDNum **MOutLocs, ValueIDNum **MInLocs,\n    const SmallVectorImpl<MachineBasicBlock *> &BlockOrders) {\n  // Collect a set of locations from predecessor where its live-out value can\n  // be found.\n  SmallVector<SmallVector<LocIdx, 4>, 8> Locs;\n  unsigned NumLocs = MTracker->getNumLocs();\n  unsigned BackEdgesStart = 0;\n\n  for (auto p : BlockOrders) {\n    // Pick out where backedges start in the list of predecessors. Relies on\n    // BlockOrders being sorted by RPO.\n    if (BBToOrder[p] < BBToOrder[&MBB])\n      ++BackEdgesStart;\n\n    // For each predecessor, create a new set of locations.\n    Locs.resize(Locs.size() + 1);\n    unsigned ThisBBNum = p->getNumber();\n    auto LiveOutMap = LiveOuts.find(p);\n    if (LiveOutMap == LiveOuts.end())\n      // This predecessor isn't in scope, it must have no live-in/live-out\n      // locations.\n      continue;\n\n    auto It = LiveOutMap->second->find(Var);\n    if (It == LiveOutMap->second->end())\n      // There's no value recorded for this variable in this predecessor,\n      // leave an empty set of locations.\n      continue;\n\n    const DbgValue &OutVal = It->second;\n\n    if (OutVal.Kind == DbgValue::Const || OutVal.Kind == DbgValue::NoVal)\n      // Consts and no-values cannot have locations we can join on.\n      continue;\n\n    assert(OutVal.Kind == DbgValue::Proposed || OutVal.Kind == DbgValue::Def);\n    ValueIDNum ValToLookFor = OutVal.ID;\n\n    // Search the live-outs of the predecessor for the specified value.\n    for (unsigned int I = 0; I < NumLocs; ++I) {\n      if (MOutLocs[ThisBBNum][I] == ValToLookFor)\n        Locs.back().push_back(LocIdx(I));\n    }\n  }\n\n  // If there were no locations at all, return an empty result.\n  if (Locs.empty())\n    return std::tuple<Optional<ValueIDNum>, bool>(None, false);\n\n  // Lambda for seeking a common location within a range of location-sets.\n  using LocsIt = SmallVector<SmallVector<LocIdx, 4>, 8>::iterator;\n  auto SeekLocation =\n      [&Locs](llvm::iterator_range<LocsIt> SearchRange) -> Optional<LocIdx> {\n    // Starting with the first set of locations, take the intersection with\n    // subsequent sets.\n    SmallVector<LocIdx, 4> base = Locs[0];\n    for (auto &S : SearchRange) {\n      SmallVector<LocIdx, 4> new_base;\n      std::set_intersection(base.begin(), base.end(), S.begin(), S.end(),\n                            std::inserter(new_base, new_base.begin()));\n      base = new_base;\n    }\n    if (base.empty())\n      return None;\n\n    // We now have a set of LocIdxes that contain the right output value in\n    // each of the predecessors. Pick the lowest; if there's a register loc,\n    // that'll be it.\n    return *base.begin();\n  };\n\n  // Search for a common location for all predecessors. If we can't, then fall\n  // back to only finding a common location between non-backedge predecessors.\n  bool ValidForAllLocs = true;\n  auto TheLoc = SeekLocation(Locs);\n  if (!TheLoc) {\n    ValidForAllLocs = false;\n    TheLoc =\n        SeekLocation(make_range(Locs.begin(), Locs.begin() + BackEdgesStart));\n  }\n\n  if (!TheLoc)\n    return std::tuple<Optional<ValueIDNum>, bool>(None, false);\n\n  // Return a PHI-value-number for the found location.\n  LocIdx L = *TheLoc;\n  ValueIDNum PHIVal = {(unsigned)MBB.getNumber(), 0, L};\n  return std::tuple<Optional<ValueIDNum>, bool>(PHIVal, ValidForAllLocs);\n}\n\nstd::tuple<bool, bool> InstrRefBasedLDV::vlocJoin(\n    MachineBasicBlock &MBB, LiveIdxT &VLOCOutLocs, LiveIdxT &VLOCInLocs,\n    SmallPtrSet<const MachineBasicBlock *, 16> *VLOCVisited, unsigned BBNum,\n    const SmallSet<DebugVariable, 4> &AllVars, ValueIDNum **MOutLocs,\n    ValueIDNum **MInLocs,\n    SmallPtrSet<const MachineBasicBlock *, 8> &InScopeBlocks,\n    SmallPtrSet<const MachineBasicBlock *, 8> &BlocksToExplore,\n    DenseMap<DebugVariable, DbgValue> &InLocsT) {\n  bool DowngradeOccurred = false;\n\n  // To emulate VarLocBasedImpl, process this block if it's not in scope but\n  // _does_ assign a variable value. No live-ins for this scope are transferred\n  // in though, so we can return immediately.\n  if (InScopeBlocks.count(&MBB) == 0 && !ArtificialBlocks.count(&MBB)) {\n    if (VLOCVisited)\n      return std::tuple<bool, bool>(true, false);\n    return std::tuple<bool, bool>(false, false);\n  }\n\n  LLVM_DEBUG(dbgs() << \"join MBB: \" << MBB.getNumber() << \"\\n\");\n  bool Changed = false;\n\n  // Find any live-ins computed in a prior iteration.\n  auto ILSIt = VLOCInLocs.find(&MBB);\n  assert(ILSIt != VLOCInLocs.end());\n  auto &ILS = *ILSIt->second;\n\n  // Order predecessors by RPOT order, for exploring them in that order.\n  SmallVector<MachineBasicBlock *, 8> BlockOrders(MBB.predecessors());\n\n  auto Cmp = [&](MachineBasicBlock *A, MachineBasicBlock *B) {\n    return BBToOrder[A] < BBToOrder[B];\n  };\n\n  llvm::sort(BlockOrders, Cmp);\n\n  unsigned CurBlockRPONum = BBToOrder[&MBB];\n\n  // Force a re-visit to loop heads in the first dataflow iteration.\n  // FIXME: if we could \"propose\" Const values this wouldn't be needed,\n  // because they'd need to be confirmed before being emitted.\n  if (!BlockOrders.empty() &&\n      BBToOrder[BlockOrders[BlockOrders.size() - 1]] >= CurBlockRPONum &&\n      VLOCVisited)\n    DowngradeOccurred = true;\n\n  auto ConfirmValue = [&InLocsT](const DebugVariable &DV, DbgValue VR) {\n    auto Result = InLocsT.insert(std::make_pair(DV, VR));\n    (void)Result;\n    assert(Result.second);\n  };\n\n  auto ConfirmNoVal = [&ConfirmValue, &MBB](const DebugVariable &Var, const DbgValueProperties &Properties) {\n    DbgValue NoLocPHIVal(MBB.getNumber(), Properties, DbgValue::NoVal);\n\n    ConfirmValue(Var, NoLocPHIVal);\n  };\n\n  // Attempt to join the values for each variable.\n  for (auto &Var : AllVars) {\n    // Collect all the DbgValues for this variable.\n    SmallVector<InValueT, 8> Values;\n    bool Bail = false;\n    unsigned BackEdgesStart = 0;\n    for (auto p : BlockOrders) {\n      // If the predecessor isn't in scope / to be explored, we'll never be\n      // able to join any locations.\n      if (!BlocksToExplore.contains(p)) {\n        Bail = true;\n        break;\n      }\n\n      // Don't attempt to handle unvisited predecessors: they're implicitly\n      // \"unknown\"s in the lattice.\n      if (VLOCVisited && !VLOCVisited->count(p))\n        continue;\n\n      // If the predecessors OutLocs is absent, there's not much we can do.\n      auto OL = VLOCOutLocs.find(p);\n      if (OL == VLOCOutLocs.end()) {\n        Bail = true;\n        break;\n      }\n\n      // No live-out value for this predecessor also means we can't produce\n      // a joined value.\n      auto VIt = OL->second->find(Var);\n      if (VIt == OL->second->end()) {\n        Bail = true;\n        break;\n      }\n\n      // Keep track of where back-edges begin in the Values vector. Relies on\n      // BlockOrders being sorted by RPO.\n      unsigned ThisBBRPONum = BBToOrder[p];\n      if (ThisBBRPONum < CurBlockRPONum)\n        ++BackEdgesStart;\n\n      Values.push_back(std::make_pair(p, &VIt->second));\n    }\n\n    // If there were no values, or one of the predecessors couldn't have a\n    // value, then give up immediately. It's not safe to produce a live-in\n    // value.\n    if (Bail || Values.size() == 0)\n      continue;\n\n    // Enumeration identifying the current state of the predecessors values.\n    enum {\n      Unset = 0,\n      Agreed,       // All preds agree on the variable value.\n      PropDisagree, // All preds agree, but the value kind is Proposed in some.\n      BEDisagree,   // Only back-edges disagree on variable value.\n      PHINeeded,    // Non-back-edge predecessors have conflicing values.\n      NoSolution    // Conflicting Value metadata makes solution impossible.\n    } OurState = Unset;\n\n    // All (non-entry) blocks have at least one non-backedge predecessor.\n    // Pick the variable value from the first of these, to compare against\n    // all others.\n    const DbgValue &FirstVal = *Values[0].second;\n    const ValueIDNum &FirstID = FirstVal.ID;\n\n    // Scan for variable values that can't be resolved: if they have different\n    // DIExpressions, different indirectness, or are mixed constants /\n    // non-constants.\n    for (auto &V : Values) {\n      if (V.second->Properties != FirstVal.Properties)\n        OurState = NoSolution;\n      if (V.second->Kind == DbgValue::Const && FirstVal.Kind != DbgValue::Const)\n        OurState = NoSolution;\n    }\n\n    // Flags diagnosing _how_ the values disagree.\n    bool NonBackEdgeDisagree = false;\n    bool DisagreeOnPHINess = false;\n    bool IDDisagree = false;\n    bool Disagree = false;\n    if (OurState == Unset) {\n      for (auto &V : Values) {\n        if (*V.second == FirstVal)\n          continue; // No disagreement.\n\n        Disagree = true;\n\n        // Flag whether the value number actually diagrees.\n        if (V.second->ID != FirstID)\n          IDDisagree = true;\n\n        // Distinguish whether disagreement happens in backedges or not.\n        // Relies on Values (and BlockOrders) being sorted by RPO.\n        unsigned ThisBBRPONum = BBToOrder[V.first];\n        if (ThisBBRPONum < CurBlockRPONum)\n          NonBackEdgeDisagree = true;\n\n        // Is there a difference in whether the value is definite or only\n        // proposed?\n        if (V.second->Kind != FirstVal.Kind &&\n            (V.second->Kind == DbgValue::Proposed ||\n             V.second->Kind == DbgValue::Def) &&\n            (FirstVal.Kind == DbgValue::Proposed ||\n             FirstVal.Kind == DbgValue::Def))\n          DisagreeOnPHINess = true;\n      }\n\n      // Collect those flags together and determine an overall state for\n      // what extend the predecessors agree on a live-in value.\n      if (!Disagree)\n        OurState = Agreed;\n      else if (!IDDisagree && DisagreeOnPHINess)\n        OurState = PropDisagree;\n      else if (!NonBackEdgeDisagree)\n        OurState = BEDisagree;\n      else\n        OurState = PHINeeded;\n    }\n\n    // An extra indicator: if we only disagree on whether the value is a\n    // Def, or proposed, then also flag whether that disagreement happens\n    // in backedges only.\n    bool PropOnlyInBEs = Disagree && !IDDisagree && DisagreeOnPHINess &&\n                         !NonBackEdgeDisagree && FirstVal.Kind == DbgValue::Def;\n\n    const auto &Properties = FirstVal.Properties;\n\n    auto OldLiveInIt = ILS.find(Var);\n    const DbgValue *OldLiveInLocation =\n        (OldLiveInIt != ILS.end()) ? &OldLiveInIt->second : nullptr;\n\n    bool OverRide = false;\n    if (OurState == BEDisagree && OldLiveInLocation) {\n      // Only backedges disagree: we can consider downgrading. If there was a\n      // previous live-in value, use it to work out whether the current\n      // incoming value represents a lattice downgrade or not.\n      OverRide =\n          vlocDowngradeLattice(MBB, *OldLiveInLocation, Values, CurBlockRPONum);\n    }\n\n    // Use the current state of predecessor agreement and other flags to work\n    // out what to do next. Possibilities include:\n    //  * Accept a value all predecessors agree on, or accept one that\n    //    represents a step down the exploration lattice,\n    //  * Use a PHI value number, if one can be found,\n    //  * Propose a PHI value number, and see if it gets confirmed later,\n    //  * Emit a 'NoVal' value, indicating we couldn't resolve anything.\n    if (OurState == Agreed) {\n      // Easiest solution: all predecessors agree on the variable value.\n      ConfirmValue(Var, FirstVal);\n    } else if (OurState == BEDisagree && OverRide) {\n      // Only backedges disagree, and the other predecessors have produced\n      // a new live-in value further down the exploration lattice.\n      DowngradeOccurred = true;\n      ConfirmValue(Var, FirstVal);\n    } else if (OurState == PropDisagree) {\n      // Predecessors agree on value, but some say it's only a proposed value.\n      // Propagate it as proposed: unless it was proposed in this block, in\n      // which case we're able to confirm the value.\n      if (FirstID.getBlock() == (uint64_t)MBB.getNumber() && FirstID.isPHI()) {\n        ConfirmValue(Var, DbgValue(FirstID, Properties, DbgValue::Def));\n      } else if (PropOnlyInBEs) {\n        // If only backedges disagree, a higher (in RPO) block confirmed this\n        // location, and we need to propagate it into this loop.\n        ConfirmValue(Var, DbgValue(FirstID, Properties, DbgValue::Def));\n      } else {\n        // Otherwise; a Def meeting a Proposed is still a Proposed.\n        ConfirmValue(Var, DbgValue(FirstID, Properties, DbgValue::Proposed));\n      }\n    } else if ((OurState == PHINeeded || OurState == BEDisagree)) {\n      // Predecessors disagree and can't be downgraded: this can only be\n      // solved with a PHI. Use pickVPHILoc to go look for one.\n      Optional<ValueIDNum> VPHI;\n      bool AllEdgesVPHI = false;\n      std::tie(VPHI, AllEdgesVPHI) =\n          pickVPHILoc(MBB, Var, VLOCOutLocs, MOutLocs, MInLocs, BlockOrders);\n\n      if (VPHI && AllEdgesVPHI) {\n        // There's a PHI value that's valid for all predecessors -- we can use\n        // it. If any of the non-backedge predecessors have proposed values\n        // though, this PHI is also only proposed, until the predecessors are\n        // confirmed.\n        DbgValue::KindT K = DbgValue::Def;\n        for (unsigned int I = 0; I < BackEdgesStart; ++I)\n          if (Values[I].second->Kind == DbgValue::Proposed)\n            K = DbgValue::Proposed;\n\n        ConfirmValue(Var, DbgValue(*VPHI, Properties, K));\n      } else if (VPHI) {\n        // There's a PHI value, but it's only legal for backedges. Leave this\n        // as a proposed PHI value: it might come back on the backedges,\n        // and allow us to confirm it in the future.\n        DbgValue NoBEValue = DbgValue(*VPHI, Properties, DbgValue::Proposed);\n        ConfirmValue(Var, NoBEValue);\n      } else {\n        ConfirmNoVal(Var, Properties);\n      }\n    } else {\n      // Otherwise: we don't know. Emit a \"phi but no real loc\" phi.\n      ConfirmNoVal(Var, Properties);\n    }\n  }\n\n  // Store newly calculated in-locs into VLOCInLocs, if they've changed.\n  Changed = ILS != InLocsT;\n  if (Changed)\n    ILS = InLocsT;\n\n  return std::tuple<bool, bool>(Changed, DowngradeOccurred);\n}\n\nvoid InstrRefBasedLDV::vlocDataflow(\n    const LexicalScope *Scope, const DILocation *DILoc,\n    const SmallSet<DebugVariable, 4> &VarsWeCareAbout,\n    SmallPtrSetImpl<MachineBasicBlock *> &AssignBlocks, LiveInsT &Output,\n    ValueIDNum **MOutLocs, ValueIDNum **MInLocs,\n    SmallVectorImpl<VLocTracker> &AllTheVLocs) {\n  // This method is much like mlocDataflow: but focuses on a single\n  // LexicalScope at a time. Pick out a set of blocks and variables that are\n  // to have their value assignments solved, then run our dataflow algorithm\n  // until a fixedpoint is reached.\n  std::priority_queue<unsigned int, std::vector<unsigned int>,\n                      std::greater<unsigned int>>\n      Worklist, Pending;\n  SmallPtrSet<MachineBasicBlock *, 16> OnWorklist, OnPending;\n\n  // The set of blocks we'll be examining.\n  SmallPtrSet<const MachineBasicBlock *, 8> BlocksToExplore;\n\n  // The order in which to examine them (RPO).\n  SmallVector<MachineBasicBlock *, 8> BlockOrders;\n\n  // RPO ordering function.\n  auto Cmp = [&](MachineBasicBlock *A, MachineBasicBlock *B) {\n    return BBToOrder[A] < BBToOrder[B];\n  };\n\n  LS.getMachineBasicBlocks(DILoc, BlocksToExplore);\n\n  // A separate container to distinguish \"blocks we're exploring\" versus\n  // \"blocks that are potentially in scope. See comment at start of vlocJoin.\n  SmallPtrSet<const MachineBasicBlock *, 8> InScopeBlocks = BlocksToExplore;\n\n  // Old LiveDebugValues tracks variable locations that come out of blocks\n  // not in scope, where DBG_VALUEs occur. This is something we could\n  // legitimately ignore, but lets allow it for now.\n  if (EmulateOldLDV)\n    BlocksToExplore.insert(AssignBlocks.begin(), AssignBlocks.end());\n\n  // We also need to propagate variable values through any artificial blocks\n  // that immediately follow blocks in scope.\n  DenseSet<const MachineBasicBlock *> ToAdd;\n\n  // Helper lambda: For a given block in scope, perform a depth first search\n  // of all the artificial successors, adding them to the ToAdd collection.\n  auto AccumulateArtificialBlocks =\n      [this, &ToAdd, &BlocksToExplore,\n       &InScopeBlocks](const MachineBasicBlock *MBB) {\n        // Depth-first-search state: each node is a block and which successor\n        // we're currently exploring.\n        SmallVector<std::pair<const MachineBasicBlock *,\n                              MachineBasicBlock::const_succ_iterator>,\n                    8>\n            DFS;\n\n        // Find any artificial successors not already tracked.\n        for (auto *succ : MBB->successors()) {\n          if (BlocksToExplore.count(succ) || InScopeBlocks.count(succ))\n            continue;\n          if (!ArtificialBlocks.count(succ))\n            continue;\n          DFS.push_back(std::make_pair(succ, succ->succ_begin()));\n          ToAdd.insert(succ);\n        }\n\n        // Search all those blocks, depth first.\n        while (!DFS.empty()) {\n          const MachineBasicBlock *CurBB = DFS.back().first;\n          MachineBasicBlock::const_succ_iterator &CurSucc = DFS.back().second;\n          // Walk back if we've explored this blocks successors to the end.\n          if (CurSucc == CurBB->succ_end()) {\n            DFS.pop_back();\n            continue;\n          }\n\n          // If the current successor is artificial and unexplored, descend into\n          // it.\n          if (!ToAdd.count(*CurSucc) && ArtificialBlocks.count(*CurSucc)) {\n            DFS.push_back(std::make_pair(*CurSucc, (*CurSucc)->succ_begin()));\n            ToAdd.insert(*CurSucc);\n            continue;\n          }\n\n          ++CurSucc;\n        }\n      };\n\n  // Search in-scope blocks and those containing a DBG_VALUE from this scope\n  // for artificial successors.\n  for (auto *MBB : BlocksToExplore)\n    AccumulateArtificialBlocks(MBB);\n  for (auto *MBB : InScopeBlocks)\n    AccumulateArtificialBlocks(MBB);\n\n  BlocksToExplore.insert(ToAdd.begin(), ToAdd.end());\n  InScopeBlocks.insert(ToAdd.begin(), ToAdd.end());\n\n  // Single block scope: not interesting! No propagation at all. Note that\n  // this could probably go above ArtificialBlocks without damage, but\n  // that then produces output differences from original-live-debug-values,\n  // which propagates from a single block into many artificial ones.\n  if (BlocksToExplore.size() == 1)\n    return;\n\n  // Picks out relevants blocks RPO order and sort them.\n  for (auto *MBB : BlocksToExplore)\n    BlockOrders.push_back(const_cast<MachineBasicBlock *>(MBB));\n\n  llvm::sort(BlockOrders, Cmp);\n  unsigned NumBlocks = BlockOrders.size();\n\n  // Allocate some vectors for storing the live ins and live outs. Large.\n  SmallVector<DenseMap<DebugVariable, DbgValue>, 32> LiveIns, LiveOuts;\n  LiveIns.resize(NumBlocks);\n  LiveOuts.resize(NumBlocks);\n\n  // Produce by-MBB indexes of live-in/live-outs, to ease lookup within\n  // vlocJoin.\n  LiveIdxT LiveOutIdx, LiveInIdx;\n  LiveOutIdx.reserve(NumBlocks);\n  LiveInIdx.reserve(NumBlocks);\n  for (unsigned I = 0; I < NumBlocks; ++I) {\n    LiveOutIdx[BlockOrders[I]] = &LiveOuts[I];\n    LiveInIdx[BlockOrders[I]] = &LiveIns[I];\n  }\n\n  for (auto *MBB : BlockOrders) {\n    Worklist.push(BBToOrder[MBB]);\n    OnWorklist.insert(MBB);\n  }\n\n  // Iterate over all the blocks we selected, propagating variable values.\n  bool FirstTrip = true;\n  SmallPtrSet<const MachineBasicBlock *, 16> VLOCVisited;\n  while (!Worklist.empty() || !Pending.empty()) {\n    while (!Worklist.empty()) {\n      auto *MBB = OrderToBB[Worklist.top()];\n      CurBB = MBB->getNumber();\n      Worklist.pop();\n\n      DenseMap<DebugVariable, DbgValue> JoinedInLocs;\n\n      // Join values from predecessors. Updates LiveInIdx, and writes output\n      // into JoinedInLocs.\n      bool InLocsChanged, DowngradeOccurred;\n      std::tie(InLocsChanged, DowngradeOccurred) = vlocJoin(\n          *MBB, LiveOutIdx, LiveInIdx, (FirstTrip) ? &VLOCVisited : nullptr,\n          CurBB, VarsWeCareAbout, MOutLocs, MInLocs, InScopeBlocks,\n          BlocksToExplore, JoinedInLocs);\n\n      bool FirstVisit = VLOCVisited.insert(MBB).second;\n\n      // Always explore transfer function if inlocs changed, or if we've not\n      // visited this block before.\n      InLocsChanged |= FirstVisit;\n\n      // If a downgrade occurred, book us in for re-examination on the next\n      // iteration.\n      if (DowngradeOccurred && OnPending.insert(MBB).second)\n        Pending.push(BBToOrder[MBB]);\n\n      if (!InLocsChanged)\n        continue;\n\n      // Do transfer function.\n      auto &VTracker = AllTheVLocs[MBB->getNumber()];\n      for (auto &Transfer : VTracker.Vars) {\n        // Is this var we're mangling in this scope?\n        if (VarsWeCareAbout.count(Transfer.first)) {\n          // Erase on empty transfer (DBG_VALUE $noreg).\n          if (Transfer.second.Kind == DbgValue::Undef) {\n            JoinedInLocs.erase(Transfer.first);\n          } else {\n            // Insert new variable value; or overwrite.\n            auto NewValuePair = std::make_pair(Transfer.first, Transfer.second);\n            auto Result = JoinedInLocs.insert(NewValuePair);\n            if (!Result.second)\n              Result.first->second = Transfer.second;\n          }\n        }\n      }\n\n      // Did the live-out locations change?\n      bool OLChanged = JoinedInLocs != *LiveOutIdx[MBB];\n\n      // If they haven't changed, there's no need to explore further.\n      if (!OLChanged)\n        continue;\n\n      // Commit to the live-out record.\n      *LiveOutIdx[MBB] = JoinedInLocs;\n\n      // We should visit all successors. Ensure we'll visit any non-backedge\n      // successors during this dataflow iteration; book backedge successors\n      // to be visited next time around.\n      for (auto s : MBB->successors()) {\n        // Ignore out of scope / not-to-be-explored successors.\n        if (LiveInIdx.find(s) == LiveInIdx.end())\n          continue;\n\n        if (BBToOrder[s] > BBToOrder[MBB]) {\n          if (OnWorklist.insert(s).second)\n            Worklist.push(BBToOrder[s]);\n        } else if (OnPending.insert(s).second && (FirstTrip || OLChanged)) {\n          Pending.push(BBToOrder[s]);\n        }\n      }\n    }\n    Worklist.swap(Pending);\n    std::swap(OnWorklist, OnPending);\n    OnPending.clear();\n    assert(Pending.empty());\n    FirstTrip = false;\n  }\n\n  // Dataflow done. Now what? Save live-ins. Ignore any that are still marked\n  // as being variable-PHIs, because those did not have their machine-PHI\n  // value confirmed. Such variable values are places that could have been\n  // PHIs, but are not.\n  for (auto *MBB : BlockOrders) {\n    auto &VarMap = *LiveInIdx[MBB];\n    for (auto &P : VarMap) {\n      if (P.second.Kind == DbgValue::Proposed ||\n          P.second.Kind == DbgValue::NoVal)\n        continue;\n      Output[MBB->getNumber()].push_back(P);\n    }\n  }\n\n  BlockOrders.clear();\n  BlocksToExplore.clear();\n}\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\nvoid InstrRefBasedLDV::dump_mloc_transfer(\n    const MLocTransferMap &mloc_transfer) const {\n  for (auto &P : mloc_transfer) {\n    std::string foo = MTracker->LocIdxToName(P.first);\n    std::string bar = MTracker->IDAsString(P.second);\n    dbgs() << \"Loc \" << foo << \" --> \" << bar << \"\\n\";\n  }\n}\n#endif\n\nvoid InstrRefBasedLDV::emitLocations(\n    MachineFunction &MF, LiveInsT SavedLiveIns, ValueIDNum **MInLocs,\n    DenseMap<DebugVariable, unsigned> &AllVarsNumbering) {\n  TTracker = new TransferTracker(TII, MTracker, MF, *TRI, CalleeSavedRegs);\n  unsigned NumLocs = MTracker->getNumLocs();\n\n  // For each block, load in the machine value locations and variable value\n  // live-ins, then step through each instruction in the block. New DBG_VALUEs\n  // to be inserted will be created along the way.\n  for (MachineBasicBlock &MBB : MF) {\n    unsigned bbnum = MBB.getNumber();\n    MTracker->reset();\n    MTracker->loadFromArray(MInLocs[bbnum], bbnum);\n    TTracker->loadInlocs(MBB, MInLocs[bbnum], SavedLiveIns[MBB.getNumber()],\n                         NumLocs);\n\n    CurBB = bbnum;\n    CurInst = 1;\n    for (auto &MI : MBB) {\n      process(MI);\n      TTracker->checkInstForNewValues(CurInst, MI.getIterator());\n      ++CurInst;\n    }\n  }\n\n  // We have to insert DBG_VALUEs in a consistent order, otherwise they appeaer\n  // in DWARF in different orders. Use the order that they appear when walking\n  // through each block / each instruction, stored in AllVarsNumbering.\n  auto OrderDbgValues = [&](const MachineInstr *A,\n                            const MachineInstr *B) -> bool {\n    DebugVariable VarA(A->getDebugVariable(), A->getDebugExpression(),\n                       A->getDebugLoc()->getInlinedAt());\n    DebugVariable VarB(B->getDebugVariable(), B->getDebugExpression(),\n                       B->getDebugLoc()->getInlinedAt());\n    return AllVarsNumbering.find(VarA)->second <\n           AllVarsNumbering.find(VarB)->second;\n  };\n\n  // Go through all the transfers recorded in the TransferTracker -- this is\n  // both the live-ins to a block, and any movements of values that happen\n  // in the middle.\n  for (auto &P : TTracker->Transfers) {\n    // Sort them according to appearance order.\n    llvm::sort(P.Insts, OrderDbgValues);\n    // Insert either before or after the designated point...\n    if (P.MBB) {\n      MachineBasicBlock &MBB = *P.MBB;\n      for (auto *MI : P.Insts) {\n        MBB.insert(P.Pos, MI);\n      }\n    } else {\n      MachineBasicBlock &MBB = *P.Pos->getParent();\n      for (auto *MI : P.Insts) {\n        MBB.insertAfter(P.Pos, MI);\n      }\n    }\n  }\n}\n\nvoid InstrRefBasedLDV::initialSetup(MachineFunction &MF) {\n  // Build some useful data structures.\n  auto hasNonArtificialLocation = [](const MachineInstr &MI) -> bool {\n    if (const DebugLoc &DL = MI.getDebugLoc())\n      return DL.getLine() != 0;\n    return false;\n  };\n  // Collect a set of all the artificial blocks.\n  for (auto &MBB : MF)\n    if (none_of(MBB.instrs(), hasNonArtificialLocation))\n      ArtificialBlocks.insert(&MBB);\n\n  // Compute mappings of block <=> RPO order.\n  ReversePostOrderTraversal<MachineFunction *> RPOT(&MF);\n  unsigned int RPONumber = 0;\n  for (MachineBasicBlock *MBB : RPOT) {\n    OrderToBB[RPONumber] = MBB;\n    BBToOrder[MBB] = RPONumber;\n    BBNumToRPO[MBB->getNumber()] = RPONumber;\n    ++RPONumber;\n  }\n}\n\n/// Calculate the liveness information for the given machine function and\n/// extend ranges across basic blocks.\nbool InstrRefBasedLDV::ExtendRanges(MachineFunction &MF,\n                                    TargetPassConfig *TPC) {\n  // No subprogram means this function contains no debuginfo.\n  if (!MF.getFunction().getSubprogram())\n    return false;\n\n  LLVM_DEBUG(dbgs() << \"\\nDebug Range Extension\\n\");\n  this->TPC = TPC;\n\n  TRI = MF.getSubtarget().getRegisterInfo();\n  TII = MF.getSubtarget().getInstrInfo();\n  TFI = MF.getSubtarget().getFrameLowering();\n  TFI->getCalleeSaves(MF, CalleeSavedRegs);\n  LS.initialize(MF);\n\n  MTracker =\n      new MLocTracker(MF, *TII, *TRI, *MF.getSubtarget().getTargetLowering());\n  VTracker = nullptr;\n  TTracker = nullptr;\n\n  SmallVector<MLocTransferMap, 32> MLocTransfer;\n  SmallVector<VLocTracker, 8> vlocs;\n  LiveInsT SavedLiveIns;\n\n  int MaxNumBlocks = -1;\n  for (auto &MBB : MF)\n    MaxNumBlocks = std::max(MBB.getNumber(), MaxNumBlocks);\n  assert(MaxNumBlocks >= 0);\n  ++MaxNumBlocks;\n\n  MLocTransfer.resize(MaxNumBlocks);\n  vlocs.resize(MaxNumBlocks);\n  SavedLiveIns.resize(MaxNumBlocks);\n\n  initialSetup(MF);\n\n  produceMLocTransferFunction(MF, MLocTransfer, MaxNumBlocks);\n\n  // Allocate and initialize two array-of-arrays for the live-in and live-out\n  // machine values. The outer dimension is the block number; while the inner\n  // dimension is a LocIdx from MLocTracker.\n  ValueIDNum **MOutLocs = new ValueIDNum *[MaxNumBlocks];\n  ValueIDNum **MInLocs = new ValueIDNum *[MaxNumBlocks];\n  unsigned NumLocs = MTracker->getNumLocs();\n  for (int i = 0; i < MaxNumBlocks; ++i) {\n    MOutLocs[i] = new ValueIDNum[NumLocs];\n    MInLocs[i] = new ValueIDNum[NumLocs];\n  }\n\n  // Solve the machine value dataflow problem using the MLocTransfer function,\n  // storing the computed live-ins / live-outs into the array-of-arrays. We use\n  // both live-ins and live-outs for decision making in the variable value\n  // dataflow problem.\n  mlocDataflow(MInLocs, MOutLocs, MLocTransfer);\n\n  // Walk back through each block / instruction, collecting DBG_VALUE\n  // instructions and recording what machine value their operands refer to.\n  for (auto &OrderPair : OrderToBB) {\n    MachineBasicBlock &MBB = *OrderPair.second;\n    CurBB = MBB.getNumber();\n    VTracker = &vlocs[CurBB];\n    VTracker->MBB = &MBB;\n    MTracker->loadFromArray(MInLocs[CurBB], CurBB);\n    CurInst = 1;\n    for (auto &MI : MBB) {\n      process(MI);\n      ++CurInst;\n    }\n    MTracker->reset();\n  }\n\n  // Number all variables in the order that they appear, to be used as a stable\n  // insertion order later.\n  DenseMap<DebugVariable, unsigned> AllVarsNumbering;\n\n  // Map from one LexicalScope to all the variables in that scope.\n  DenseMap<const LexicalScope *, SmallSet<DebugVariable, 4>> ScopeToVars;\n\n  // Map from One lexical scope to all blocks in that scope.\n  DenseMap<const LexicalScope *, SmallPtrSet<MachineBasicBlock *, 4>>\n      ScopeToBlocks;\n\n  // Store a DILocation that describes a scope.\n  DenseMap<const LexicalScope *, const DILocation *> ScopeToDILocation;\n\n  // To mirror old LiveDebugValues, enumerate variables in RPOT order. Otherwise\n  // the order is unimportant, it just has to be stable.\n  for (unsigned int I = 0; I < OrderToBB.size(); ++I) {\n    auto *MBB = OrderToBB[I];\n    auto *VTracker = &vlocs[MBB->getNumber()];\n    // Collect each variable with a DBG_VALUE in this block.\n    for (auto &idx : VTracker->Vars) {\n      const auto &Var = idx.first;\n      const DILocation *ScopeLoc = VTracker->Scopes[Var];\n      assert(ScopeLoc != nullptr);\n      auto *Scope = LS.findLexicalScope(ScopeLoc);\n\n      // No insts in scope -> shouldn't have been recorded.\n      assert(Scope != nullptr);\n\n      AllVarsNumbering.insert(std::make_pair(Var, AllVarsNumbering.size()));\n      ScopeToVars[Scope].insert(Var);\n      ScopeToBlocks[Scope].insert(VTracker->MBB);\n      ScopeToDILocation[Scope] = ScopeLoc;\n    }\n  }\n\n  // OK. Iterate over scopes: there might be something to be said for\n  // ordering them by size/locality, but that's for the future. For each scope,\n  // solve the variable value problem, producing a map of variables to values\n  // in SavedLiveIns.\n  for (auto &P : ScopeToVars) {\n    vlocDataflow(P.first, ScopeToDILocation[P.first], P.second,\n                 ScopeToBlocks[P.first], SavedLiveIns, MOutLocs, MInLocs,\n                 vlocs);\n  }\n\n  // Using the computed value locations and variable values for each block,\n  // create the DBG_VALUE instructions representing the extended variable\n  // locations.\n  emitLocations(MF, SavedLiveIns, MInLocs, AllVarsNumbering);\n\n  for (int Idx = 0; Idx < MaxNumBlocks; ++Idx) {\n    delete[] MOutLocs[Idx];\n    delete[] MInLocs[Idx];\n  }\n  delete[] MOutLocs;\n  delete[] MInLocs;\n\n  // Did we actually make any changes? If we created any DBG_VALUEs, then yes.\n  bool Changed = TTracker->Transfers.size() != 0;\n\n  delete MTracker;\n  delete TTracker;\n  MTracker = nullptr;\n  VTracker = nullptr;\n  TTracker = nullptr;\n\n  ArtificialBlocks.clear();\n  OrderToBB.clear();\n  BBToOrder.clear();\n  BBNumToRPO.clear();\n  DebugInstrNumToInstr.clear();\n\n  return Changed;\n}\n\nLDVImpl *llvm::makeInstrRefBasedLiveDebugValues() {\n  return new InstrRefBasedLDV();\n}\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 75, "line": 226}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 75, "line": 226}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "2041f4ad26dcf4b89e430f670613e258", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 226}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "f741e236c78ff694bd9394409777918f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 230}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 75, "line": 230}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "9cba4f3cc5055d1104456657080a5852", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 230}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "9892a3eeccea1cc93658e9d8119c0e9d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 263}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 75, "line": 263}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "0988d77cd3a4323f251dc11f84df7dfd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 263}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "eee70ed92a9ea12c5b69379ae1deaf09", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 267}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 75, "line": 267}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "42219184e5b4cd5be1b81937ed971fac", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 267}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "9c1a0a0c33bb91e8cbf5f6eeb8b3fd23", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 271}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 75, "line": 271}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "e5b157259024e1c467c40b7f8cef1fd2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 271}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "2e1e7b64c609aaa2f125497aede36d1a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 275}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 75, "line": 275}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "89aa506a1284159de63da2220bb5602a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 275}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "217a88e3be3beed428c105737334c805", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 279}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 75, "line": 279}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "4c8b3ca722a736ef4d9de04fd55103fa", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 279}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "0bea34fdb9d0b6ea05d59c3c9443e672", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 337}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 75, "line": 337}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "db32e5f3127eb5745d153d7835f8ef03", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 337}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "9c37942ac5b981e4a4f0b3ea8317ff8e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 341}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 75, "line": 341}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "95252c517d2cf1fbce6c2798f503f8dc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 341}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "5e2e3830740cbf73fcde825e22f0bc57", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 346}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 75, "line": 346}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "2f7344df484e790f1a91345f60ac8588", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 346}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "d88bbb0d83b7e4fec34436e74b845348", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 379}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 75, "line": 379}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "6418f22a3b3ed7eba5663690c1ede6af", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 379}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "4f970ccb5aa341560ea299c15f3216d2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 383}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 75, "line": 383}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "05a387178560d3be1391ad9f41ca2f0a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 383}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "d3bea5ba968cfb6c5bff0ab6b8919d8e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 75, "line": 475}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 75, "line": 475}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "1c5dfd732c62d971483158fa62cf691a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 75, "line": 475}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "69f773f1739b13461fddbc9f664a75d9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 75, "line": 480}, "message": "mark 'noexcept'"}, {"location": {"col": 10, "file": 75, "line": 480}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "95fa99bdc6b561a9dc457f68e63f02af", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 75, "line": 480}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "d1fffb91b1c4b64c9519ef4f3d60eb23", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 865}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 75, "line": 865}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "ec291b24c2ad1f42cd3880241346773a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 865}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "1097de06bf395855f6d723b73a4912d4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 880}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 75, "line": 880}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "a130e7a1b16edba3cfdf2b8392a68cd9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 75, "line": 880}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp", "reportHash": "3fc626923b4080dc4849337c509271f2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
