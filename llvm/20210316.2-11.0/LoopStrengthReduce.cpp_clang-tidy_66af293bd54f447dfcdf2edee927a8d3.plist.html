<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"59": {"id": 59, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp", "content": "//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This transformation analyzes and transforms the induction variables (and\n// computations derived from them) into forms suitable for efficient execution\n// on the target.\n//\n// This pass performs a strength reduction on array references inside loops that\n// have as one or more of their components the loop induction variable, it\n// rewrites expressions to take advantage of scaled-index addressing modes\n// available on the target, and it performs a variety of other optimizations\n// related to loop induction variables.\n//\n// Terminology note: this code has a lot of handling for \"post-increment\" or\n// \"post-inc\" users. This is not talking about post-increment addressing modes;\n// it is instead talking about code like this:\n//\n//   %i = phi [ 0, %entry ], [ %i.next, %latch ]\n//   ...\n//   %i.next = add %i, 1\n//   %c = icmp eq %i.next, %n\n//\n// The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however\n// it's useful to think about these as the same register, with some uses using\n// the value of the register before the add and some using it after. In this\n// example, the icmp is a post-increment user, since it uses %i.next, which is\n// the value of the induction variable after the increment. The other common\n// case of post-increment users is users outside the loop.\n//\n// TODO: More sophistication in the way Formulae are generated and filtered.\n//\n// TODO: Handle multiple loops at a time.\n//\n// TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead\n//       of a GlobalValue?\n//\n// TODO: When truncation is free, truncate ICmp users' operands to make it a\n//       smaller encoding (on x86 at least).\n//\n// TODO: When a negated register is used by an add (such as in a list of\n//       multiple base registers, or as the increment expression in an addrec),\n//       we may not actually need both reg and (-1 * reg) in registers; the\n//       negation can be implemented by using a sub instead of an add. The\n//       lack of support for taking this into consideration when making\n//       register pressure decisions is partly worked around by the \"Special\"\n//       use kind.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/Transforms/Scalar/LoopStrengthReduce.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Analysis/AssumptionCache.h\"\n#include \"llvm/Analysis/IVUsers.h\"\n#include \"llvm/Analysis/LoopAnalysisManager.h\"\n#include \"llvm/Analysis/LoopInfo.h\"\n#include \"llvm/Analysis/LoopPass.h\"\n#include \"llvm/Analysis/MemorySSA.h\"\n#include \"llvm/Analysis/MemorySSAUpdater.h\"\n#include \"llvm/Analysis/ScalarEvolution.h\"\n#include \"llvm/Analysis/ScalarEvolutionExpressions.h\"\n#include \"llvm/Analysis/ScalarEvolutionNormalization.h\"\n#include \"llvm/Analysis/TargetLibraryInfo.h\"\n#include \"llvm/Analysis/TargetTransformInfo.h\"\n#include \"llvm/Analysis/ValueTracking.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Dominators.h\"\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/OperandTraits.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/PassManager.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Use.h\"\n#include \"llvm/IR/User.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"llvm/InitializePasses.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Transforms/Scalar.h\"\n#include \"llvm/Transforms/Utils.h\"\n#include \"llvm/Transforms/Utils/BasicBlockUtils.h\"\n#include \"llvm/Transforms/Utils/Local.h\"\n#include \"llvm/Transforms/Utils/ScalarEvolutionExpander.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <iterator>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <utility>\n\nusing namespace llvm;\n\n#define DEBUG_TYPE \"loop-reduce\"\n\n/// MaxIVUsers is an arbitrary threshold that provides an early opportunity for\n/// bail out. This threshold is far beyond the number of users that LSR can\n/// conceivably solve, so it should not affect generated code, but catches the\n/// worst cases before LSR burns too much compile time and stack space.\nstatic const unsigned MaxIVUsers = 200;\n\n// Temporary flag to cleanup congruent phis after LSR phi expansion.\n// It's currently disabled until we can determine whether it's truly useful or\n// not. The flag should be removed after the v3.0 release.\n// This is now needed for ivchains.\nstatic cl::opt<bool> EnablePhiElim(\n  \"enable-lsr-phielim\", cl::Hidden, cl::init(true),\n  cl::desc(\"Enable LSR phi elimination\"));\n\n// The flag adds instruction count to solutions cost comparision.\nstatic cl::opt<bool> InsnsCost(\n  \"lsr-insns-cost\", cl::Hidden, cl::init(true),\n  cl::desc(\"Add instruction count to a LSR cost model\"));\n\n// Flag to choose how to narrow complex lsr solution\nstatic cl::opt<bool> LSRExpNarrow(\n  \"lsr-exp-narrow\", cl::Hidden, cl::init(false),\n  cl::desc(\"Narrow LSR complex solution using\"\n           \" expectation of registers number\"));\n\n// Flag to narrow search space by filtering non-optimal formulae with\n// the same ScaledReg and Scale.\nstatic cl::opt<bool> FilterSameScaledReg(\n    \"lsr-filter-same-scaled-reg\", cl::Hidden, cl::init(true),\n    cl::desc(\"Narrow LSR search space by filtering non-optimal formulae\"\n             \" with the same ScaledReg and Scale\"));\n\nstatic cl::opt<TTI::AddressingModeKind> PreferredAddresingMode(\n  \"lsr-preferred-addressing-mode\", cl::Hidden, cl::init(TTI::AMK_None),\n   cl::desc(\"A flag that overrides the target's preferred addressing mode.\"),\n   cl::values(clEnumValN(TTI::AMK_None,\n                         \"none\",\n                         \"Don't prefer any addressing mode\"),\n              clEnumValN(TTI::AMK_PreIndexed,\n                         \"preindexed\",\n                         \"Prefer pre-indexed addressing mode\"),\n              clEnumValN(TTI::AMK_PostIndexed,\n                         \"postindexed\",\n                         \"Prefer post-indexed addressing mode\")));\n\nstatic cl::opt<unsigned> ComplexityLimit(\n  \"lsr-complexity-limit\", cl::Hidden,\n  cl::init(std::numeric_limits<uint16_t>::max()),\n  cl::desc(\"LSR search space complexity limit\"));\n\nstatic cl::opt<unsigned> SetupCostDepthLimit(\n    \"lsr-setupcost-depth-limit\", cl::Hidden, cl::init(7),\n    cl::desc(\"The limit on recursion depth for LSRs setup cost\"));\n\n#ifndef NDEBUG\n// Stress test IV chain generation.\nstatic cl::opt<bool> StressIVChain(\n  \"stress-ivchain\", cl::Hidden, cl::init(false),\n  cl::desc(\"Stress test LSR IV chains\"));\n#else\nstatic bool StressIVChain = false;\n#endif\n\nnamespace {\n\nstruct MemAccessTy {\n  /// Used in situations where the accessed memory type is unknown.\n  static const unsigned UnknownAddressSpace =\n      std::numeric_limits<unsigned>::max();\n\n  Type *MemTy = nullptr;\n  unsigned AddrSpace = UnknownAddressSpace;\n\n  MemAccessTy() = default;\n  MemAccessTy(Type *Ty, unsigned AS) : MemTy(Ty), AddrSpace(AS) {}\n\n  bool operator==(MemAccessTy Other) const {\n    return MemTy == Other.MemTy && AddrSpace == Other.AddrSpace;\n  }\n\n  bool operator!=(MemAccessTy Other) const { return !(*this == Other); }\n\n  static MemAccessTy getUnknown(LLVMContext &Ctx,\n                                unsigned AS = UnknownAddressSpace) {\n    return MemAccessTy(Type::getVoidTy(Ctx), AS);\n  }\n\n  Type *getType() { return MemTy; }\n};\n\n/// This class holds data which is used to order reuse candidates.\nclass RegSortData {\npublic:\n  /// This represents the set of LSRUse indices which reference\n  /// a particular register.\n  SmallBitVector UsedByIndices;\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n};\n\n} // end anonymous namespace\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\nvoid RegSortData::print(raw_ostream &OS) const {\n  OS << \"[NumUses=\" << UsedByIndices.count() << ']';\n}\n\nLLVM_DUMP_METHOD void RegSortData::dump() const {\n  print(errs()); errs() << '\\n';\n}\n#endif\n\nnamespace {\n\n/// Map register candidates to information about how they are used.\nclass RegUseTracker {\n  using RegUsesTy = DenseMap<const SCEV *, RegSortData>;\n\n  RegUsesTy RegUsesMap;\n  SmallVector<const SCEV *, 16> RegSequence;\n\npublic:\n  void countRegister(const SCEV *Reg, size_t LUIdx);\n  void dropRegister(const SCEV *Reg, size_t LUIdx);\n  void swapAndDropUse(size_t LUIdx, size_t LastLUIdx);\n\n  bool isRegUsedByUsesOtherThan(const SCEV *Reg, size_t LUIdx) const;\n\n  const SmallBitVector &getUsedByIndices(const SCEV *Reg) const;\n\n  void clear();\n\n  using iterator = SmallVectorImpl<const SCEV *>::iterator;\n  using const_iterator = SmallVectorImpl<const SCEV *>::const_iterator;\n\n  iterator begin() { return RegSequence.begin(); }\n  iterator end()   { return RegSequence.end(); }\n  const_iterator begin() const { return RegSequence.begin(); }\n  const_iterator end() const   { return RegSequence.end(); }\n};\n\n} // end anonymous namespace\n\nvoid\nRegUseTracker::countRegister(const SCEV *Reg, size_t LUIdx) {\n  std::pair<RegUsesTy::iterator, bool> Pair =\n    RegUsesMap.insert(std::make_pair(Reg, RegSortData()));\n  RegSortData &RSD = Pair.first->second;\n  if (Pair.second)\n    RegSequence.push_back(Reg);\n  RSD.UsedByIndices.resize(std::max(RSD.UsedByIndices.size(), LUIdx + 1));\n  RSD.UsedByIndices.set(LUIdx);\n}\n\nvoid\nRegUseTracker::dropRegister(const SCEV *Reg, size_t LUIdx) {\n  RegUsesTy::iterator It = RegUsesMap.find(Reg);\n  assert(It != RegUsesMap.end());\n  RegSortData &RSD = It->second;\n  assert(RSD.UsedByIndices.size() > LUIdx);\n  RSD.UsedByIndices.reset(LUIdx);\n}\n\nvoid\nRegUseTracker::swapAndDropUse(size_t LUIdx, size_t LastLUIdx) {\n  assert(LUIdx <= LastLUIdx);\n\n  // Update RegUses. The data structure is not optimized for this purpose;\n  // we must iterate through it and update each of the bit vectors.\n  for (auto &Pair : RegUsesMap) {\n    SmallBitVector &UsedByIndices = Pair.second.UsedByIndices;\n    if (LUIdx < UsedByIndices.size())\n      UsedByIndices[LUIdx] =\n        LastLUIdx < UsedByIndices.size() ? UsedByIndices[LastLUIdx] : false;\n    UsedByIndices.resize(std::min(UsedByIndices.size(), LastLUIdx));\n  }\n}\n\nbool\nRegUseTracker::isRegUsedByUsesOtherThan(const SCEV *Reg, size_t LUIdx) const {\n  RegUsesTy::const_iterator I = RegUsesMap.find(Reg);\n  if (I == RegUsesMap.end())\n    return false;\n  const SmallBitVector &UsedByIndices = I->second.UsedByIndices;\n  int i = UsedByIndices.find_first();\n  if (i == -1) return false;\n  if ((size_t)i != LUIdx) return true;\n  return UsedByIndices.find_next(i) != -1;\n}\n\nconst SmallBitVector &RegUseTracker::getUsedByIndices(const SCEV *Reg) const {\n  RegUsesTy::const_iterator I = RegUsesMap.find(Reg);\n  assert(I != RegUsesMap.end() && \"Unknown register!\");\n  return I->second.UsedByIndices;\n}\n\nvoid RegUseTracker::clear() {\n  RegUsesMap.clear();\n  RegSequence.clear();\n}\n\nnamespace {\n\n/// This class holds information that describes a formula for computing\n/// satisfying a use. It may include broken-out immediates and scaled registers.\nstruct Formula {\n  /// Global base address used for complex addressing.\n  GlobalValue *BaseGV = nullptr;\n\n  /// Base offset for complex addressing.\n  int64_t BaseOffset = 0;\n\n  /// Whether any complex addressing has a base register.\n  bool HasBaseReg = false;\n\n  /// The scale of any complex addressing.\n  int64_t Scale = 0;\n\n  /// The list of \"base\" registers for this use. When this is non-empty. The\n  /// canonical representation of a formula is\n  /// 1. BaseRegs.size > 1 implies ScaledReg != NULL and\n  /// 2. ScaledReg != NULL implies Scale != 1 || !BaseRegs.empty().\n  /// 3. The reg containing recurrent expr related with currect loop in the\n  /// formula should be put in the ScaledReg.\n  /// #1 enforces that the scaled register is always used when at least two\n  /// registers are needed by the formula: e.g., reg1 + reg2 is reg1 + 1 * reg2.\n  /// #2 enforces that 1 * reg is reg.\n  /// #3 ensures invariant regs with respect to current loop can be combined\n  /// together in LSR codegen.\n  /// This invariant can be temporarily broken while building a formula.\n  /// However, every formula inserted into the LSRInstance must be in canonical\n  /// form.\n  SmallVector<const SCEV *, 4> BaseRegs;\n\n  /// The 'scaled' register for this use. This should be non-null when Scale is\n  /// not zero.\n  const SCEV *ScaledReg = nullptr;\n\n  /// An additional constant offset which added near the use. This requires a\n  /// temporary register, but the offset itself can live in an add immediate\n  /// field rather than a register.\n  int64_t UnfoldedOffset = 0;\n\n  Formula() = default;\n\n  void initialMatch(const SCEV *S, Loop *L, ScalarEvolution &SE);\n\n  bool isCanonical(const Loop &L) const;\n\n  void canonicalize(const Loop &L);\n\n  bool unscale();\n\n  bool hasZeroEnd() const;\n\n  size_t getNumRegs() const;\n  Type *getType() const;\n\n  void deleteBaseReg(const SCEV *&S);\n\n  bool referencesReg(const SCEV *S) const;\n  bool hasRegsUsedByUsesOtherThan(size_t LUIdx,\n                                  const RegUseTracker &RegUses) const;\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n};\n\n} // end anonymous namespace\n\n/// Recursion helper for initialMatch.\nstatic void DoInitialMatch(const SCEV *S, Loop *L,\n                           SmallVectorImpl<const SCEV *> &Good,\n                           SmallVectorImpl<const SCEV *> &Bad,\n                           ScalarEvolution &SE) {\n  // Collect expressions which properly dominate the loop header.\n  if (SE.properlyDominates(S, L->getHeader())) {\n    Good.push_back(S);\n    return;\n  }\n\n  // Look at add operands.\n  if (const SCEVAddExpr *Add = dyn_cast<SCEVAddExpr>(S)) {\n    for (const SCEV *S : Add->operands())\n      DoInitialMatch(S, L, Good, Bad, SE);\n    return;\n  }\n\n  // Look at addrec operands.\n  if (const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(S))\n    if (!AR->getStart()->isZero() && AR->isAffine()) {\n      DoInitialMatch(AR->getStart(), L, Good, Bad, SE);\n      DoInitialMatch(SE.getAddRecExpr(SE.getConstant(AR->getType(), 0),\n                                      AR->getStepRecurrence(SE),\n                                      // FIXME: AR->getNoWrapFlags()\n                                      AR->getLoop(), SCEV::FlagAnyWrap),\n                     L, Good, Bad, SE);\n      return;\n    }\n\n  // Handle a multiplication by -1 (negation) if it didn't fold.\n  if (const SCEVMulExpr *Mul = dyn_cast<SCEVMulExpr>(S))\n    if (Mul->getOperand(0)->isAllOnesValue()) {\n      SmallVector<const SCEV *, 4> Ops(drop_begin(Mul->operands()));\n      const SCEV *NewMul = SE.getMulExpr(Ops);\n\n      SmallVector<const SCEV *, 4> MyGood;\n      SmallVector<const SCEV *, 4> MyBad;\n      DoInitialMatch(NewMul, L, MyGood, MyBad, SE);\n      const SCEV *NegOne = SE.getSCEV(ConstantInt::getAllOnesValue(\n        SE.getEffectiveSCEVType(NewMul->getType())));\n      for (const SCEV *S : MyGood)\n        Good.push_back(SE.getMulExpr(NegOne, S));\n      for (const SCEV *S : MyBad)\n        Bad.push_back(SE.getMulExpr(NegOne, S));\n      return;\n    }\n\n  // Ok, we can't do anything interesting. Just stuff the whole thing into a\n  // register and hope for the best.\n  Bad.push_back(S);\n}\n\n/// Incorporate loop-variant parts of S into this Formula, attempting to keep\n/// all loop-invariant and loop-computable values in a single base register.\nvoid Formula::initialMatch(const SCEV *S, Loop *L, ScalarEvolution &SE) {\n  SmallVector<const SCEV *, 4> Good;\n  SmallVector<const SCEV *, 4> Bad;\n  DoInitialMatch(S, L, Good, Bad, SE);\n  if (!Good.empty()) {\n    const SCEV *Sum = SE.getAddExpr(Good);\n    if (!Sum->isZero())\n      BaseRegs.push_back(Sum);\n    HasBaseReg = true;\n  }\n  if (!Bad.empty()) {\n    const SCEV *Sum = SE.getAddExpr(Bad);\n    if (!Sum->isZero())\n      BaseRegs.push_back(Sum);\n    HasBaseReg = true;\n  }\n  canonicalize(*L);\n}\n\n/// Check whether or not this formula satisfies the canonical\n/// representation.\n/// \\see Formula::BaseRegs.\nbool Formula::isCanonical(const Loop &L) const {\n  if (!ScaledReg)\n    return BaseRegs.size() <= 1;\n\n  if (Scale != 1)\n    return true;\n\n  if (Scale == 1 && BaseRegs.empty())\n    return false;\n\n  const SCEVAddRecExpr *SAR = dyn_cast<const SCEVAddRecExpr>(ScaledReg);\n  if (SAR && SAR->getLoop() == &L)\n    return true;\n\n  // If ScaledReg is not a recurrent expr, or it is but its loop is not current\n  // loop, meanwhile BaseRegs contains a recurrent expr reg related with current\n  // loop, we want to swap the reg in BaseRegs with ScaledReg.\n  auto I = find_if(BaseRegs, [&](const SCEV *S) {\n    return isa<const SCEVAddRecExpr>(S) &&\n           (cast<SCEVAddRecExpr>(S)->getLoop() == &L);\n  });\n  return I == BaseRegs.end();\n}\n\n/// Helper method to morph a formula into its canonical representation.\n/// \\see Formula::BaseRegs.\n/// Every formula having more than one base register, must use the ScaledReg\n/// field. Otherwise, we would have to do special cases everywhere in LSR\n/// to treat reg1 + reg2 + ... the same way as reg1 + 1*reg2 + ...\n/// On the other hand, 1*reg should be canonicalized into reg.\nvoid Formula::canonicalize(const Loop &L) {\n  if (isCanonical(L))\n    return;\n  // So far we did not need this case. This is easy to implement but it is\n  // useless to maintain dead code. Beside it could hurt compile time.\n  assert(!BaseRegs.empty() && \"1*reg => reg, should not be needed.\");\n\n  // Keep the invariant sum in BaseRegs and one of the variant sum in ScaledReg.\n  if (!ScaledReg) {\n    ScaledReg = BaseRegs.pop_back_val();\n    Scale = 1;\n  }\n\n  // If ScaledReg is an invariant with respect to L, find the reg from\n  // BaseRegs containing the recurrent expr related with Loop L. Swap the\n  // reg with ScaledReg.\n  const SCEVAddRecExpr *SAR = dyn_cast<const SCEVAddRecExpr>(ScaledReg);\n  if (!SAR || SAR->getLoop() != &L) {\n    auto I = find_if(BaseRegs, [&](const SCEV *S) {\n      return isa<const SCEVAddRecExpr>(S) &&\n             (cast<SCEVAddRecExpr>(S)->getLoop() == &L);\n    });\n    if (I != BaseRegs.end())\n      std::swap(ScaledReg, *I);\n  }\n}\n\n/// Get rid of the scale in the formula.\n/// In other words, this method morphes reg1 + 1*reg2 into reg1 + reg2.\n/// \\return true if it was possible to get rid of the scale, false otherwise.\n/// \\note After this operation the formula may not be in the canonical form.\nbool Formula::unscale() {\n  if (Scale != 1)\n    return false;\n  Scale = 0;\n  BaseRegs.push_back(ScaledReg);\n  ScaledReg = nullptr;\n  return true;\n}\n\nbool Formula::hasZeroEnd() const {\n  if (UnfoldedOffset || BaseOffset)\n    return false;\n  if (BaseRegs.size() != 1 || ScaledReg)\n    return false;\n  return true;\n}\n\n/// Return the total number of register operands used by this formula. This does\n/// not include register uses implied by non-constant addrec strides.\nsize_t Formula::getNumRegs() const {\n  return !!ScaledReg + BaseRegs.size();\n}\n\n/// Return the type of this formula, if it has one, or null otherwise. This type\n/// is meaningless except for the bit size.\nType *Formula::getType() const {\n  return !BaseRegs.empty() ? BaseRegs.front()->getType() :\n         ScaledReg ? ScaledReg->getType() :\n         BaseGV ? BaseGV->getType() :\n         nullptr;\n}\n\n/// Delete the given base reg from the BaseRegs list.\nvoid Formula::deleteBaseReg(const SCEV *&S) {\n  if (&S != &BaseRegs.back())\n    std::swap(S, BaseRegs.back());\n  BaseRegs.pop_back();\n}\n\n/// Test if this formula references the given register.\nbool Formula::referencesReg(const SCEV *S) const {\n  return S == ScaledReg || is_contained(BaseRegs, S);\n}\n\n/// Test whether this formula uses registers which are used by uses other than\n/// the use with the given index.\nbool Formula::hasRegsUsedByUsesOtherThan(size_t LUIdx,\n                                         const RegUseTracker &RegUses) const {\n  if (ScaledReg)\n    if (RegUses.isRegUsedByUsesOtherThan(ScaledReg, LUIdx))\n      return true;\n  for (const SCEV *BaseReg : BaseRegs)\n    if (RegUses.isRegUsedByUsesOtherThan(BaseReg, LUIdx))\n      return true;\n  return false;\n}\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\nvoid Formula::print(raw_ostream &OS) const {\n  bool First = true;\n  if (BaseGV) {\n    if (!First) OS << \" + \"; else First = false;\n    BaseGV->printAsOperand(OS, /*PrintType=*/false);\n  }\n  if (BaseOffset != 0) {\n    if (!First) OS << \" + \"; else First = false;\n    OS << BaseOffset;\n  }\n  for (const SCEV *BaseReg : BaseRegs) {\n    if (!First) OS << \" + \"; else First = false;\n    OS << \"reg(\" << *BaseReg << ')';\n  }\n  if (HasBaseReg && BaseRegs.empty()) {\n    if (!First) OS << \" + \"; else First = false;\n    OS << \"**error: HasBaseReg**\";\n  } else if (!HasBaseReg && !BaseRegs.empty()) {\n    if (!First) OS << \" + \"; else First = false;\n    OS << \"**error: !HasBaseReg**\";\n  }\n  if (Scale != 0) {\n    if (!First) OS << \" + \"; else First = false;\n    OS << Scale << \"*reg(\";\n    if (ScaledReg)\n      OS << *ScaledReg;\n    else\n      OS << \"<unknown>\";\n    OS << ')';\n  }\n  if (UnfoldedOffset != 0) {\n    if (!First) OS << \" + \";\n    OS << \"imm(\" << UnfoldedOffset << ')';\n  }\n}\n\nLLVM_DUMP_METHOD void Formula::dump() const {\n  print(errs()); errs() << '\\n';\n}\n#endif\n\n/// Return true if the given addrec can be sign-extended without changing its\n/// value.\nstatic bool isAddRecSExtable(const SCEVAddRecExpr *AR, ScalarEvolution &SE) {\n  Type *WideTy =\n    IntegerType::get(SE.getContext(), SE.getTypeSizeInBits(AR->getType()) + 1);\n  return isa<SCEVAddRecExpr>(SE.getSignExtendExpr(AR, WideTy));\n}\n\n/// Return true if the given add can be sign-extended without changing its\n/// value.\nstatic bool isAddSExtable(const SCEVAddExpr *A, ScalarEvolution &SE) {\n  Type *WideTy =\n    IntegerType::get(SE.getContext(), SE.getTypeSizeInBits(A->getType()) + 1);\n  return isa<SCEVAddExpr>(SE.getSignExtendExpr(A, WideTy));\n}\n\n/// Return true if the given mul can be sign-extended without changing its\n/// value.\nstatic bool isMulSExtable(const SCEVMulExpr *M, ScalarEvolution &SE) {\n  Type *WideTy =\n    IntegerType::get(SE.getContext(),\n                     SE.getTypeSizeInBits(M->getType()) * M->getNumOperands());\n  return isa<SCEVMulExpr>(SE.getSignExtendExpr(M, WideTy));\n}\n\n/// Return an expression for LHS /s RHS, if it can be determined and if the\n/// remainder is known to be zero, or null otherwise. If IgnoreSignificantBits\n/// is true, expressions like (X * Y) /s Y are simplified to Y, ignoring that\n/// the multiplication may overflow, which is useful when the result will be\n/// used in a context where the most significant bits are ignored.\nstatic const SCEV *getExactSDiv(const SCEV *LHS, const SCEV *RHS,\n                                ScalarEvolution &SE,\n                                bool IgnoreSignificantBits = false) {\n  // Handle the trivial case, which works for any SCEV type.\n  if (LHS == RHS)\n    return SE.getConstant(LHS->getType(), 1);\n\n  // Handle a few RHS special cases.\n  const SCEVConstant *RC = dyn_cast<SCEVConstant>(RHS);\n  if (RC) {\n    const APInt &RA = RC->getAPInt();\n    // Handle x /s -1 as x * -1, to give ScalarEvolution a chance to do\n    // some folding.\n    if (RA.isAllOnesValue())\n      return SE.getMulExpr(LHS, RC);\n    // Handle x /s 1 as x.\n    if (RA == 1)\n      return LHS;\n  }\n\n  // Check for a division of a constant by a constant.\n  if (const SCEVConstant *C = dyn_cast<SCEVConstant>(LHS)) {\n    if (!RC)\n      return nullptr;\n    const APInt &LA = C->getAPInt();\n    const APInt &RA = RC->getAPInt();\n    if (LA.srem(RA) != 0)\n      return nullptr;\n    return SE.getConstant(LA.sdiv(RA));\n  }\n\n  // Distribute the sdiv over addrec operands, if the addrec doesn't overflow.\n  if (const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(LHS)) {\n    if ((IgnoreSignificantBits || isAddRecSExtable(AR, SE)) && AR->isAffine()) {\n      const SCEV *Step = getExactSDiv(AR->getStepRecurrence(SE), RHS, SE,\n                                      IgnoreSignificantBits);\n      if (!Step) return nullptr;\n      const SCEV *Start = getExactSDiv(AR->getStart(), RHS, SE,\n                                       IgnoreSignificantBits);\n      if (!Start) return nullptr;\n      // FlagNW is independent of the start value, step direction, and is\n      // preserved with smaller magnitude steps.\n      // FIXME: AR->getNoWrapFlags(SCEV::FlagNW)\n      return SE.getAddRecExpr(Start, Step, AR->getLoop(), SCEV::FlagAnyWrap);\n    }\n    return nullptr;\n  }\n\n  // Distribute the sdiv over add operands, if the add doesn't overflow.\n  if (const SCEVAddExpr *Add = dyn_cast<SCEVAddExpr>(LHS)) {\n    if (IgnoreSignificantBits || isAddSExtable(Add, SE)) {\n      SmallVector<const SCEV *, 8> Ops;\n      for (const SCEV *S : Add->operands()) {\n        const SCEV *Op = getExactSDiv(S, RHS, SE, IgnoreSignificantBits);\n        if (!Op) return nullptr;\n        Ops.push_back(Op);\n      }\n      return SE.getAddExpr(Ops);\n    }\n    return nullptr;\n  }\n\n  // Check for a multiply operand that we can pull RHS out of.\n  if (const SCEVMulExpr *Mul = dyn_cast<SCEVMulExpr>(LHS)) {\n    if (IgnoreSignificantBits || isMulSExtable(Mul, SE)) {\n      SmallVector<const SCEV *, 4> Ops;\n      bool Found = false;\n      for (const SCEV *S : Mul->operands()) {\n        if (!Found)\n          if (const SCEV *Q = getExactSDiv(S, RHS, SE,\n                                           IgnoreSignificantBits)) {\n            S = Q;\n            Found = true;\n          }\n        Ops.push_back(S);\n      }\n      return Found ? SE.getMulExpr(Ops) : nullptr;\n    }\n    return nullptr;\n  }\n\n  // Otherwise we don't know.\n  return nullptr;\n}\n\n/// If S involves the addition of a constant integer value, return that integer\n/// value, and mutate S to point to a new SCEV with that value excluded.\nstatic int64_t ExtractImmediate(const SCEV *&S, ScalarEvolution &SE) {\n  if (const SCEVConstant *C = dyn_cast<SCEVConstant>(S)) {\n    if (C->getAPInt().getMinSignedBits() <= 64) {\n      S = SE.getConstant(C->getType(), 0);\n      return C->getValue()->getSExtValue();\n    }\n  } else if (const SCEVAddExpr *Add = dyn_cast<SCEVAddExpr>(S)) {\n    SmallVector<const SCEV *, 8> NewOps(Add->operands());\n    int64_t Result = ExtractImmediate(NewOps.front(), SE);\n    if (Result != 0)\n      S = SE.getAddExpr(NewOps);\n    return Result;\n  } else if (const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(S)) {\n    SmallVector<const SCEV *, 8> NewOps(AR->operands());\n    int64_t Result = ExtractImmediate(NewOps.front(), SE);\n    if (Result != 0)\n      S = SE.getAddRecExpr(NewOps, AR->getLoop(),\n                           // FIXME: AR->getNoWrapFlags(SCEV::FlagNW)\n                           SCEV::FlagAnyWrap);\n    return Result;\n  }\n  return 0;\n}\n\n/// If S involves the addition of a GlobalValue address, return that symbol, and\n/// mutate S to point to a new SCEV with that value excluded.\nstatic GlobalValue *ExtractSymbol(const SCEV *&S, ScalarEvolution &SE) {\n  if (const SCEVUnknown *U = dyn_cast<SCEVUnknown>(S)) {\n    if (GlobalValue *GV = dyn_cast<GlobalValue>(U->getValue())) {\n      S = SE.getConstant(GV->getType(), 0);\n      return GV;\n    }\n  } else if (const SCEVAddExpr *Add = dyn_cast<SCEVAddExpr>(S)) {\n    SmallVector<const SCEV *, 8> NewOps(Add->operands());\n    GlobalValue *Result = ExtractSymbol(NewOps.back(), SE);\n    if (Result)\n      S = SE.getAddExpr(NewOps);\n    return Result;\n  } else if (const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(S)) {\n    SmallVector<const SCEV *, 8> NewOps(AR->operands());\n    GlobalValue *Result = ExtractSymbol(NewOps.front(), SE);\n    if (Result)\n      S = SE.getAddRecExpr(NewOps, AR->getLoop(),\n                           // FIXME: AR->getNoWrapFlags(SCEV::FlagNW)\n                           SCEV::FlagAnyWrap);\n    return Result;\n  }\n  return nullptr;\n}\n\n/// Returns true if the specified instruction is using the specified value as an\n/// address.\nstatic bool isAddressUse(const TargetTransformInfo &TTI,\n                         Instruction *Inst, Value *OperandVal) {\n  bool isAddress = isa<LoadInst>(Inst);\n  if (StoreInst *SI = dyn_cast<StoreInst>(Inst)) {\n    if (SI->getPointerOperand() == OperandVal)\n      isAddress = true;\n  } else if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst)) {\n    // Addressing modes can also be folded into prefetches and a variety\n    // of intrinsics.\n    switch (II->getIntrinsicID()) {\n    case Intrinsic::memset:\n    case Intrinsic::prefetch:\n    case Intrinsic::masked_load:\n      if (II->getArgOperand(0) == OperandVal)\n        isAddress = true;\n      break;\n    case Intrinsic::masked_store:\n      if (II->getArgOperand(1) == OperandVal)\n        isAddress = true;\n      break;\n    case Intrinsic::memmove:\n    case Intrinsic::memcpy:\n      if (II->getArgOperand(0) == OperandVal ||\n          II->getArgOperand(1) == OperandVal)\n        isAddress = true;\n      break;\n    default: {\n      MemIntrinsicInfo IntrInfo;\n      if (TTI.getTgtMemIntrinsic(II, IntrInfo)) {\n        if (IntrInfo.PtrVal == OperandVal)\n          isAddress = true;\n      }\n    }\n    }\n  } else if (AtomicRMWInst *RMW = dyn_cast<AtomicRMWInst>(Inst)) {\n    if (RMW->getPointerOperand() == OperandVal)\n      isAddress = true;\n  } else if (AtomicCmpXchgInst *CmpX = dyn_cast<AtomicCmpXchgInst>(Inst)) {\n    if (CmpX->getPointerOperand() == OperandVal)\n      isAddress = true;\n  }\n  return isAddress;\n}\n\n/// Return the type of the memory being accessed.\nstatic MemAccessTy getAccessType(const TargetTransformInfo &TTI,\n                                 Instruction *Inst, Value *OperandVal) {\n  MemAccessTy AccessTy(Inst->getType(), MemAccessTy::UnknownAddressSpace);\n  if (const StoreInst *SI = dyn_cast<StoreInst>(Inst)) {\n    AccessTy.MemTy = SI->getOperand(0)->getType();\n    AccessTy.AddrSpace = SI->getPointerAddressSpace();\n  } else if (const LoadInst *LI = dyn_cast<LoadInst>(Inst)) {\n    AccessTy.AddrSpace = LI->getPointerAddressSpace();\n  } else if (const AtomicRMWInst *RMW = dyn_cast<AtomicRMWInst>(Inst)) {\n    AccessTy.AddrSpace = RMW->getPointerAddressSpace();\n  } else if (const AtomicCmpXchgInst *CmpX = dyn_cast<AtomicCmpXchgInst>(Inst)) {\n    AccessTy.AddrSpace = CmpX->getPointerAddressSpace();\n  } else if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(Inst)) {\n    switch (II->getIntrinsicID()) {\n    case Intrinsic::prefetch:\n    case Intrinsic::memset:\n      AccessTy.AddrSpace = II->getArgOperand(0)->getType()->getPointerAddressSpace();\n      AccessTy.MemTy = OperandVal->getType();\n      break;\n    case Intrinsic::memmove:\n    case Intrinsic::memcpy:\n      AccessTy.AddrSpace = OperandVal->getType()->getPointerAddressSpace();\n      AccessTy.MemTy = OperandVal->getType();\n      break;\n    case Intrinsic::masked_load:\n      AccessTy.AddrSpace =\n          II->getArgOperand(0)->getType()->getPointerAddressSpace();\n      break;\n    case Intrinsic::masked_store:\n      AccessTy.MemTy = II->getOperand(0)->getType();\n      AccessTy.AddrSpace =\n          II->getArgOperand(1)->getType()->getPointerAddressSpace();\n      break;\n    default: {\n      MemIntrinsicInfo IntrInfo;\n      if (TTI.getTgtMemIntrinsic(II, IntrInfo) && IntrInfo.PtrVal) {\n        AccessTy.AddrSpace\n          = IntrInfo.PtrVal->getType()->getPointerAddressSpace();\n      }\n\n      break;\n    }\n    }\n  }\n\n  // All pointers have the same requirements, so canonicalize them to an\n  // arbitrary pointer type to minimize variation.\n  if (PointerType *PTy = dyn_cast<PointerType>(AccessTy.MemTy))\n    AccessTy.MemTy = PointerType::get(IntegerType::get(PTy->getContext(), 1),\n                                      PTy->getAddressSpace());\n\n  return AccessTy;\n}\n\n/// Return true if this AddRec is already a phi in its loop.\nstatic bool isExistingPhi(const SCEVAddRecExpr *AR, ScalarEvolution &SE) {\n  for (PHINode &PN : AR->getLoop()->getHeader()->phis()) {\n    if (SE.isSCEVable(PN.getType()) &&\n        (SE.getEffectiveSCEVType(PN.getType()) ==\n         SE.getEffectiveSCEVType(AR->getType())) &&\n        SE.getSCEV(&PN) == AR)\n      return true;\n  }\n  return false;\n}\n\n/// Check if expanding this expression is likely to incur significant cost. This\n/// is tricky because SCEV doesn't track which expressions are actually computed\n/// by the current IR.\n///\n/// We currently allow expansion of IV increments that involve adds,\n/// multiplication by constants, and AddRecs from existing phis.\n///\n/// TODO: Allow UDivExpr if we can find an existing IV increment that is an\n/// obvious multiple of the UDivExpr.\nstatic bool isHighCostExpansion(const SCEV *S,\n                                SmallPtrSetImpl<const SCEV*> &Processed,\n                                ScalarEvolution &SE) {\n  // Zero/One operand expressions\n  switch (S->getSCEVType()) {\n  case scUnknown:\n  case scConstant:\n    return false;\n  case scTruncate:\n    return isHighCostExpansion(cast<SCEVTruncateExpr>(S)->getOperand(),\n                               Processed, SE);\n  case scZeroExtend:\n    return isHighCostExpansion(cast<SCEVZeroExtendExpr>(S)->getOperand(),\n                               Processed, SE);\n  case scSignExtend:\n    return isHighCostExpansion(cast<SCEVSignExtendExpr>(S)->getOperand(),\n                               Processed, SE);\n  default:\n    break;\n  }\n\n  if (!Processed.insert(S).second)\n    return false;\n\n  if (const SCEVAddExpr *Add = dyn_cast<SCEVAddExpr>(S)) {\n    for (const SCEV *S : Add->operands()) {\n      if (isHighCostExpansion(S, Processed, SE))\n        return true;\n    }\n    return false;\n  }\n\n  if (const SCEVMulExpr *Mul = dyn_cast<SCEVMulExpr>(S)) {\n    if (Mul->getNumOperands() == 2) {\n      // Multiplication by a constant is ok\n      if (isa<SCEVConstant>(Mul->getOperand(0)))\n        return isHighCostExpansion(Mul->getOperand(1), Processed, SE);\n\n      // If we have the value of one operand, check if an existing\n      // multiplication already generates this expression.\n      if (const SCEVUnknown *U = dyn_cast<SCEVUnknown>(Mul->getOperand(1))) {\n        Value *UVal = U->getValue();\n        for (User *UR : UVal->users()) {\n          // If U is a constant, it may be used by a ConstantExpr.\n          Instruction *UI = dyn_cast<Instruction>(UR);\n          if (UI && UI->getOpcode() == Instruction::Mul &&\n              SE.isSCEVable(UI->getType())) {\n            return SE.getSCEV(UI) == Mul;\n          }\n        }\n      }\n    }\n  }\n\n  if (const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(S)) {\n    if (isExistingPhi(AR, SE))\n      return false;\n  }\n\n  // Fow now, consider any other type of expression (div/mul/min/max) high cost.\n  return true;\n}\n\nnamespace {\n\nclass LSRUse;\n\n} // end anonymous namespace\n\n/// Check if the addressing mode defined by \\p F is completely\n/// folded in \\p LU at isel time.\n/// This includes address-mode folding and special icmp tricks.\n/// This function returns true if \\p LU can accommodate what \\p F\n/// defines and up to 1 base + 1 scaled + offset.\n/// In other words, if \\p F has several base registers, this function may\n/// still return true. Therefore, users still need to account for\n/// additional base registers and/or unfolded offsets to derive an\n/// accurate cost model.\nstatic bool isAMCompletelyFolded(const TargetTransformInfo &TTI,\n                                 const LSRUse &LU, const Formula &F);\n\n// Get the cost of the scaling factor used in F for LU.\nstatic unsigned getScalingFactorCost(const TargetTransformInfo &TTI,\n                                     const LSRUse &LU, const Formula &F,\n                                     const Loop &L);\n\nnamespace {\n\n/// This class is used to measure and compare candidate formulae.\nclass Cost {\n  const Loop *L = nullptr;\n  ScalarEvolution *SE = nullptr;\n  const TargetTransformInfo *TTI = nullptr;\n  TargetTransformInfo::LSRCost C;\n  TTI::AddressingModeKind AMK = TTI::AMK_None;\n\npublic:\n  Cost() = delete;\n  Cost(const Loop *L, ScalarEvolution &SE, const TargetTransformInfo &TTI,\n       TTI::AddressingModeKind AMK) :\n    L(L), SE(&SE), TTI(&TTI), AMK(AMK) {\n    C.Insns = 0;\n    C.NumRegs = 0;\n    C.AddRecCost = 0;\n    C.NumIVMuls = 0;\n    C.NumBaseAdds = 0;\n    C.ImmCost = 0;\n    C.SetupCost = 0;\n    C.ScaleCost = 0;\n  }\n\n  bool isLess(Cost &Other);\n\n  void Lose();\n\n#ifndef NDEBUG\n  // Once any of the metrics loses, they must all remain losers.\n  bool isValid() {\n    return ((C.Insns | C.NumRegs | C.AddRecCost | C.NumIVMuls | C.NumBaseAdds\n             | C.ImmCost | C.SetupCost | C.ScaleCost) != ~0u)\n      || ((C.Insns & C.NumRegs & C.AddRecCost & C.NumIVMuls & C.NumBaseAdds\n           & C.ImmCost & C.SetupCost & C.ScaleCost) == ~0u);\n  }\n#endif\n\n  bool isLoser() {\n    assert(isValid() && \"invalid cost\");\n    return C.NumRegs == ~0u;\n  }\n\n  void RateFormula(const Formula &F,\n                   SmallPtrSetImpl<const SCEV *> &Regs,\n                   const DenseSet<const SCEV *> &VisitedRegs,\n                   const LSRUse &LU,\n                   SmallPtrSetImpl<const SCEV *> *LoserRegs = nullptr);\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n\nprivate:\n  void RateRegister(const Formula &F, const SCEV *Reg,\n                    SmallPtrSetImpl<const SCEV *> &Regs);\n  void RatePrimaryRegister(const Formula &F, const SCEV *Reg,\n                           SmallPtrSetImpl<const SCEV *> &Regs,\n                           SmallPtrSetImpl<const SCEV *> *LoserRegs);\n};\n\n/// An operand value in an instruction which is to be replaced with some\n/// equivalent, possibly strength-reduced, replacement.\nstruct LSRFixup {\n  /// The instruction which will be updated.\n  Instruction *UserInst = nullptr;\n\n  /// The operand of the instruction which will be replaced. The operand may be\n  /// used more than once; every instance will be replaced.\n  Value *OperandValToReplace = nullptr;\n\n  /// If this user is to use the post-incremented value of an induction\n  /// variable, this set is non-empty and holds the loops associated with the\n  /// induction variable.\n  PostIncLoopSet PostIncLoops;\n\n  /// A constant offset to be added to the LSRUse expression.  This allows\n  /// multiple fixups to share the same LSRUse with different offsets, for\n  /// example in an unrolled loop.\n  int64_t Offset = 0;\n\n  LSRFixup() = default;\n\n  bool isUseFullyOutsideLoop(const Loop *L) const;\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n};\n\n/// A DenseMapInfo implementation for holding DenseMaps and DenseSets of sorted\n/// SmallVectors of const SCEV*.\nstruct UniquifierDenseMapInfo {\n  static SmallVector<const SCEV *, 4> getEmptyKey() {\n    SmallVector<const SCEV *, 4>  V;\n    V.push_back(reinterpret_cast<const SCEV *>(-1));\n    return V;\n  }\n\n  static SmallVector<const SCEV *, 4> getTombstoneKey() {\n    SmallVector<const SCEV *, 4> V;\n    V.push_back(reinterpret_cast<const SCEV *>(-2));\n    return V;\n  }\n\n  static unsigned getHashValue(const SmallVector<const SCEV *, 4> &V) {\n    return static_cast<unsigned>(hash_combine_range(V.begin(), V.end()));\n  }\n\n  static bool isEqual(const SmallVector<const SCEV *, 4> &LHS,\n                      const SmallVector<const SCEV *, 4> &RHS) {\n    return LHS == RHS;\n  }\n};\n\n/// This class holds the state that LSR keeps for each use in IVUsers, as well\n/// as uses invented by LSR itself. It includes information about what kinds of\n/// things can be folded into the user, information about the user itself, and\n/// information about how the use may be satisfied.  TODO: Represent multiple\n/// users of the same expression in common?\nclass LSRUse {\n  DenseSet<SmallVector<const SCEV *, 4>, UniquifierDenseMapInfo> Uniquifier;\n\npublic:\n  /// An enum for a kind of use, indicating what types of scaled and immediate\n  /// operands it might support.\n  enum KindType {\n    Basic,   ///< A normal use, with no folding.\n    Special, ///< A special case of basic, allowing -1 scales.\n    Address, ///< An address use; folding according to TargetLowering\n    ICmpZero ///< An equality icmp with both operands folded into one.\n    // TODO: Add a generic icmp too?\n  };\n\n  using SCEVUseKindPair = PointerIntPair<const SCEV *, 2, KindType>;\n\n  KindType Kind;\n  MemAccessTy AccessTy;\n\n  /// The list of operands which are to be replaced.\n  SmallVector<LSRFixup, 8> Fixups;\n\n  /// Keep track of the min and max offsets of the fixups.\n  int64_t MinOffset = std::numeric_limits<int64_t>::max();\n  int64_t MaxOffset = std::numeric_limits<int64_t>::min();\n\n  /// This records whether all of the fixups using this LSRUse are outside of\n  /// the loop, in which case some special-case heuristics may be used.\n  bool AllFixupsOutsideLoop = true;\n\n  /// RigidFormula is set to true to guarantee that this use will be associated\n  /// with a single formula--the one that initially matched. Some SCEV\n  /// expressions cannot be expanded. This allows LSR to consider the registers\n  /// used by those expressions without the need to expand them later after\n  /// changing the formula.\n  bool RigidFormula = false;\n\n  /// This records the widest use type for any fixup using this\n  /// LSRUse. FindUseWithSimilarFormula can't consider uses with different max\n  /// fixup widths to be equivalent, because the narrower one may be relying on\n  /// the implicit truncation to truncate away bogus bits.\n  Type *WidestFixupType = nullptr;\n\n  /// A list of ways to build a value that can satisfy this user.  After the\n  /// list is populated, one of these is selected heuristically and used to\n  /// formulate a replacement for OperandValToReplace in UserInst.\n  SmallVector<Formula, 12> Formulae;\n\n  /// The set of register candidates used by all formulae in this LSRUse.\n  SmallPtrSet<const SCEV *, 4> Regs;\n\n  LSRUse(KindType K, MemAccessTy AT) : Kind(K), AccessTy(AT) {}\n\n  LSRFixup &getNewFixup() {\n    Fixups.push_back(LSRFixup());\n    return Fixups.back();\n  }\n\n  void pushFixup(LSRFixup &f) {\n    Fixups.push_back(f);\n    if (f.Offset > MaxOffset)\n      MaxOffset = f.Offset;\n    if (f.Offset < MinOffset)\n      MinOffset = f.Offset;\n  }\n\n  bool HasFormulaWithSameRegs(const Formula &F) const;\n  float getNotSelectedProbability(const SCEV *Reg) const;\n  bool InsertFormula(const Formula &F, const Loop &L);\n  void DeleteFormula(Formula &F);\n  void RecomputeRegs(size_t LUIdx, RegUseTracker &Reguses);\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n};\n\n} // end anonymous namespace\n\nstatic bool isAMCompletelyFolded(const TargetTransformInfo &TTI,\n                                 LSRUse::KindType Kind, MemAccessTy AccessTy,\n                                 GlobalValue *BaseGV, int64_t BaseOffset,\n                                 bool HasBaseReg, int64_t Scale,\n                                 Instruction *Fixup = nullptr);\n\nstatic unsigned getSetupCost(const SCEV *Reg, unsigned Depth) {\n  if (isa<SCEVUnknown>(Reg) || isa<SCEVConstant>(Reg))\n    return 1;\n  if (Depth == 0)\n    return 0;\n  if (const auto *S = dyn_cast<SCEVAddRecExpr>(Reg))\n    return getSetupCost(S->getStart(), Depth - 1);\n  if (auto S = dyn_cast<SCEVIntegralCastExpr>(Reg))\n    return getSetupCost(S->getOperand(), Depth - 1);\n  if (auto S = dyn_cast<SCEVNAryExpr>(Reg))\n    return std::accumulate(S->op_begin(), S->op_end(), 0,\n                           [&](unsigned i, const SCEV *Reg) {\n                             return i + getSetupCost(Reg, Depth - 1);\n                           });\n  if (auto S = dyn_cast<SCEVUDivExpr>(Reg))\n    return getSetupCost(S->getLHS(), Depth - 1) +\n           getSetupCost(S->getRHS(), Depth - 1);\n  return 0;\n}\n\n/// Tally up interesting quantities from the given register.\nvoid Cost::RateRegister(const Formula &F, const SCEV *Reg,\n                        SmallPtrSetImpl<const SCEV *> &Regs) {\n  if (const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(Reg)) {\n    // If this is an addrec for another loop, it should be an invariant\n    // with respect to L since L is the innermost loop (at least\n    // for now LSR only handles innermost loops).\n    if (AR->getLoop() != L) {\n      // If the AddRec exists, consider it's register free and leave it alone.\n      if (isExistingPhi(AR, *SE) && AMK != TTI::AMK_PostIndexed)\n        return;\n\n      // It is bad to allow LSR for current loop to add induction variables\n      // for its sibling loops.\n      if (!AR->getLoop()->contains(L)) {\n        Lose();\n        return;\n      }\n\n      // Otherwise, it will be an invariant with respect to Loop L.\n      ++C.NumRegs;\n      return;\n    }\n\n    unsigned LoopCost = 1;\n    if (TTI->isIndexedLoadLegal(TTI->MIM_PostInc, AR->getType()) ||\n        TTI->isIndexedStoreLegal(TTI->MIM_PostInc, AR->getType())) {\n\n      // If the step size matches the base offset, we could use pre-indexed\n      // addressing.\n      if (AMK == TTI::AMK_PreIndexed) {\n        if (auto *Step = dyn_cast<SCEVConstant>(AR->getStepRecurrence(*SE)))\n          if (Step->getAPInt() == F.BaseOffset)\n            LoopCost = 0;\n      } else if (AMK == TTI::AMK_PostIndexed) {\n        const SCEV *LoopStep = AR->getStepRecurrence(*SE);\n        if (isa<SCEVConstant>(LoopStep)) {\n          const SCEV *LoopStart = AR->getStart();\n          if (!isa<SCEVConstant>(LoopStart) &&\n              SE->isLoopInvariant(LoopStart, L))\n            LoopCost = 0;\n        }\n      }\n    }\n    C.AddRecCost += LoopCost;\n\n    // Add the step value register, if it needs one.\n    // TODO: The non-affine case isn't precisely modeled here.\n    if (!AR->isAffine() || !isa<SCEVConstant>(AR->getOperand(1))) {\n      if (!Regs.count(AR->getOperand(1))) {\n        RateRegister(F, AR->getOperand(1), Regs);\n        if (isLoser())\n          return;\n      }\n    }\n  }\n  ++C.NumRegs;\n\n  // Rough heuristic; favor registers which don't require extra setup\n  // instructions in the preheader.\n  C.SetupCost += getSetupCost(Reg, SetupCostDepthLimit);\n  // Ensure we don't, even with the recusion limit, produce invalid costs.\n  C.SetupCost = std::min<unsigned>(C.SetupCost, 1 << 16);\n\n  C.NumIVMuls += isa<SCEVMulExpr>(Reg) &&\n               SE->hasComputableLoopEvolution(Reg, L);\n}\n\n/// Record this register in the set. If we haven't seen it before, rate\n/// it. Optional LoserRegs provides a way to declare any formula that refers to\n/// one of those regs an instant loser.\nvoid Cost::RatePrimaryRegister(const Formula &F, const SCEV *Reg,\n                               SmallPtrSetImpl<const SCEV *> &Regs,\n                               SmallPtrSetImpl<const SCEV *> *LoserRegs) {\n  if (LoserRegs && LoserRegs->count(Reg)) {\n    Lose();\n    return;\n  }\n  if (Regs.insert(Reg).second) {\n    RateRegister(F, Reg, Regs);\n    if (LoserRegs && isLoser())\n      LoserRegs->insert(Reg);\n  }\n}\n\nvoid Cost::RateFormula(const Formula &F,\n                       SmallPtrSetImpl<const SCEV *> &Regs,\n                       const DenseSet<const SCEV *> &VisitedRegs,\n                       const LSRUse &LU,\n                       SmallPtrSetImpl<const SCEV *> *LoserRegs) {\n  assert(F.isCanonical(*L) && \"Cost is accurate only for canonical formula\");\n  // Tally up the registers.\n  unsigned PrevAddRecCost = C.AddRecCost;\n  unsigned PrevNumRegs = C.NumRegs;\n  unsigned PrevNumBaseAdds = C.NumBaseAdds;\n  if (const SCEV *ScaledReg = F.ScaledReg) {\n    if (VisitedRegs.count(ScaledReg)) {\n      Lose();\n      return;\n    }\n    RatePrimaryRegister(F, ScaledReg, Regs, LoserRegs);\n    if (isLoser())\n      return;\n  }\n  for (const SCEV *BaseReg : F.BaseRegs) {\n    if (VisitedRegs.count(BaseReg)) {\n      Lose();\n      return;\n    }\n    RatePrimaryRegister(F, BaseReg, Regs, LoserRegs);\n    if (isLoser())\n      return;\n  }\n\n  // Determine how many (unfolded) adds we'll need inside the loop.\n  size_t NumBaseParts = F.getNumRegs();\n  if (NumBaseParts > 1)\n    // Do not count the base and a possible second register if the target\n    // allows to fold 2 registers.\n    C.NumBaseAdds +=\n        NumBaseParts - (1 + (F.Scale && isAMCompletelyFolded(*TTI, LU, F)));\n  C.NumBaseAdds += (F.UnfoldedOffset != 0);\n\n  // Accumulate non-free scaling amounts.\n  C.ScaleCost += getScalingFactorCost(*TTI, LU, F, *L);\n\n  // Tally up the non-zero immediates.\n  for (const LSRFixup &Fixup : LU.Fixups) {\n    int64_t O = Fixup.Offset;\n    int64_t Offset = (uint64_t)O + F.BaseOffset;\n    if (F.BaseGV)\n      C.ImmCost += 64; // Handle symbolic values conservatively.\n                     // TODO: This should probably be the pointer size.\n    else if (Offset != 0)\n      C.ImmCost += APInt(64, Offset, true).getMinSignedBits();\n\n    // Check with target if this offset with this instruction is\n    // specifically not supported.\n    if (LU.Kind == LSRUse::Address && Offset != 0 &&\n        !isAMCompletelyFolded(*TTI, LSRUse::Address, LU.AccessTy, F.BaseGV,\n                              Offset, F.HasBaseReg, F.Scale, Fixup.UserInst))\n      C.NumBaseAdds++;\n  }\n\n  // If we don't count instruction cost exit here.\n  if (!InsnsCost) {\n    assert(isValid() && \"invalid cost\");\n    return;\n  }\n\n  // Treat every new register that exceeds TTI.getNumberOfRegisters() - 1 as\n  // additional instruction (at least fill).\n  // TODO: Need distinguish register class?\n  unsigned TTIRegNum = TTI->getNumberOfRegisters(\n                       TTI->getRegisterClassForType(false, F.getType())) - 1;\n  if (C.NumRegs > TTIRegNum) {\n    // Cost already exceeded TTIRegNum, then only newly added register can add\n    // new instructions.\n    if (PrevNumRegs > TTIRegNum)\n      C.Insns += (C.NumRegs - PrevNumRegs);\n    else\n      C.Insns += (C.NumRegs - TTIRegNum);\n  }\n\n  // If ICmpZero formula ends with not 0, it could not be replaced by\n  // just add or sub. We'll need to compare final result of AddRec.\n  // That means we'll need an additional instruction. But if the target can\n  // macro-fuse a compare with a branch, don't count this extra instruction.\n  // For -10 + {0, +, 1}:\n  // i = i + 1;\n  // cmp i, 10\n  //\n  // For {-10, +, 1}:\n  // i = i + 1;\n  if (LU.Kind == LSRUse::ICmpZero && !F.hasZeroEnd() &&\n      !TTI->canMacroFuseCmp())\n    C.Insns++;\n  // Each new AddRec adds 1 instruction to calculation.\n  C.Insns += (C.AddRecCost - PrevAddRecCost);\n\n  // BaseAdds adds instructions for unfolded registers.\n  if (LU.Kind != LSRUse::ICmpZero)\n    C.Insns += C.NumBaseAdds - PrevNumBaseAdds;\n  assert(isValid() && \"invalid cost\");\n}\n\n/// Set this cost to a losing value.\nvoid Cost::Lose() {\n  C.Insns = std::numeric_limits<unsigned>::max();\n  C.NumRegs = std::numeric_limits<unsigned>::max();\n  C.AddRecCost = std::numeric_limits<unsigned>::max();\n  C.NumIVMuls = std::numeric_limits<unsigned>::max();\n  C.NumBaseAdds = std::numeric_limits<unsigned>::max();\n  C.ImmCost = std::numeric_limits<unsigned>::max();\n  C.SetupCost = std::numeric_limits<unsigned>::max();\n  C.ScaleCost = std::numeric_limits<unsigned>::max();\n}\n\n/// Choose the lower cost.\nbool Cost::isLess(Cost &Other) {\n  if (InsnsCost.getNumOccurrences() > 0 && InsnsCost &&\n      C.Insns != Other.C.Insns)\n    return C.Insns < Other.C.Insns;\n  return TTI->isLSRCostLess(C, Other.C);\n}\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\nvoid Cost::print(raw_ostream &OS) const {\n  if (InsnsCost)\n    OS << C.Insns << \" instruction\" << (C.Insns == 1 ? \" \" : \"s \");\n  OS << C.NumRegs << \" reg\" << (C.NumRegs == 1 ? \"\" : \"s\");\n  if (C.AddRecCost != 0)\n    OS << \", with addrec cost \" << C.AddRecCost;\n  if (C.NumIVMuls != 0)\n    OS << \", plus \" << C.NumIVMuls << \" IV mul\"\n       << (C.NumIVMuls == 1 ? \"\" : \"s\");\n  if (C.NumBaseAdds != 0)\n    OS << \", plus \" << C.NumBaseAdds << \" base add\"\n       << (C.NumBaseAdds == 1 ? \"\" : \"s\");\n  if (C.ScaleCost != 0)\n    OS << \", plus \" << C.ScaleCost << \" scale cost\";\n  if (C.ImmCost != 0)\n    OS << \", plus \" << C.ImmCost << \" imm cost\";\n  if (C.SetupCost != 0)\n    OS << \", plus \" << C.SetupCost << \" setup cost\";\n}\n\nLLVM_DUMP_METHOD void Cost::dump() const {\n  print(errs()); errs() << '\\n';\n}\n#endif\n\n/// Test whether this fixup always uses its value outside of the given loop.\nbool LSRFixup::isUseFullyOutsideLoop(const Loop *L) const {\n  // PHI nodes use their value in their incoming blocks.\n  if (const PHINode *PN = dyn_cast<PHINode>(UserInst)) {\n    for (unsigned i = 0, e = PN->getNumIncomingValues(); i != e; ++i)\n      if (PN->getIncomingValue(i) == OperandValToReplace &&\n          L->contains(PN->getIncomingBlock(i)))\n        return false;\n    return true;\n  }\n\n  return !L->contains(UserInst);\n}\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\nvoid LSRFixup::print(raw_ostream &OS) const {\n  OS << \"UserInst=\";\n  // Store is common and interesting enough to be worth special-casing.\n  if (StoreInst *Store = dyn_cast<StoreInst>(UserInst)) {\n    OS << \"store \";\n    Store->getOperand(0)->printAsOperand(OS, /*PrintType=*/false);\n  } else if (UserInst->getType()->isVoidTy())\n    OS << UserInst->getOpcodeName();\n  else\n    UserInst->printAsOperand(OS, /*PrintType=*/false);\n\n  OS << \", OperandValToReplace=\";\n  OperandValToReplace->printAsOperand(OS, /*PrintType=*/false);\n\n  for (const Loop *PIL : PostIncLoops) {\n    OS << \", PostIncLoop=\";\n    PIL->getHeader()->printAsOperand(OS, /*PrintType=*/false);\n  }\n\n  if (Offset != 0)\n    OS << \", Offset=\" << Offset;\n}\n\nLLVM_DUMP_METHOD void LSRFixup::dump() const {\n  print(errs()); errs() << '\\n';\n}\n#endif\n\n/// Test whether this use as a formula which has the same registers as the given\n/// formula.\nbool LSRUse::HasFormulaWithSameRegs(const Formula &F) const {\n  SmallVector<const SCEV *, 4> Key = F.BaseRegs;\n  if (F.ScaledReg) Key.push_back(F.ScaledReg);\n  // Unstable sort by host order ok, because this is only used for uniquifying.\n  llvm::sort(Key);\n  return Uniquifier.count(Key);\n}\n\n/// The function returns a probability of selecting formula without Reg.\nfloat LSRUse::getNotSelectedProbability(const SCEV *Reg) const {\n  unsigned FNum = 0;\n  for (const Formula &F : Formulae)\n    if (F.referencesReg(Reg))\n      FNum++;\n  return ((float)(Formulae.size() - FNum)) / Formulae.size();\n}\n\n/// If the given formula has not yet been inserted, add it to the list, and\n/// return true. Return false otherwise.  The formula must be in canonical form.\nbool LSRUse::InsertFormula(const Formula &F, const Loop &L) {\n  assert(F.isCanonical(L) && \"Invalid canonical representation\");\n\n  if (!Formulae.empty() && RigidFormula)\n    return false;\n\n  SmallVector<const SCEV *, 4> Key = F.BaseRegs;\n  if (F.ScaledReg) Key.push_back(F.ScaledReg);\n  // Unstable sort by host order ok, because this is only used for uniquifying.\n  llvm::sort(Key);\n\n  if (!Uniquifier.insert(Key).second)\n    return false;\n\n  // Using a register to hold the value of 0 is not profitable.\n  assert((!F.ScaledReg || !F.ScaledReg->isZero()) &&\n         \"Zero allocated in a scaled register!\");\n#ifndef NDEBUG\n  for (const SCEV *BaseReg : F.BaseRegs)\n    assert(!BaseReg->isZero() && \"Zero allocated in a base register!\");\n#endif\n\n  // Add the formula to the list.\n  Formulae.push_back(F);\n\n  // Record registers now being used by this use.\n  Regs.insert(F.BaseRegs.begin(), F.BaseRegs.end());\n  if (F.ScaledReg)\n    Regs.insert(F.ScaledReg);\n\n  return true;\n}\n\n/// Remove the given formula from this use's list.\nvoid LSRUse::DeleteFormula(Formula &F) {\n  if (&F != &Formulae.back())\n    std::swap(F, Formulae.back());\n  Formulae.pop_back();\n}\n\n/// Recompute the Regs field, and update RegUses.\nvoid LSRUse::RecomputeRegs(size_t LUIdx, RegUseTracker &RegUses) {\n  // Now that we've filtered out some formulae, recompute the Regs set.\n  SmallPtrSet<const SCEV *, 4> OldRegs = std::move(Regs);\n  Regs.clear();\n  for (const Formula &F : Formulae) {\n    if (F.ScaledReg) Regs.insert(F.ScaledReg);\n    Regs.insert(F.BaseRegs.begin(), F.BaseRegs.end());\n  }\n\n  // Update the RegTracker.\n  for (const SCEV *S : OldRegs)\n    if (!Regs.count(S))\n      RegUses.dropRegister(S, LUIdx);\n}\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\nvoid LSRUse::print(raw_ostream &OS) const {\n  OS << \"LSR Use: Kind=\";\n  switch (Kind) {\n  case Basic:    OS << \"Basic\"; break;\n  case Special:  OS << \"Special\"; break;\n  case ICmpZero: OS << \"ICmpZero\"; break;\n  case Address:\n    OS << \"Address of \";\n    if (AccessTy.MemTy->isPointerTy())\n      OS << \"pointer\"; // the full pointer type could be really verbose\n    else {\n      OS << *AccessTy.MemTy;\n    }\n\n    OS << \" in addrspace(\" << AccessTy.AddrSpace << ')';\n  }\n\n  OS << \", Offsets={\";\n  bool NeedComma = false;\n  for (const LSRFixup &Fixup : Fixups) {\n    if (NeedComma) OS << ',';\n    OS << Fixup.Offset;\n    NeedComma = true;\n  }\n  OS << '}';\n\n  if (AllFixupsOutsideLoop)\n    OS << \", all-fixups-outside-loop\";\n\n  if (WidestFixupType)\n    OS << \", widest fixup type: \" << *WidestFixupType;\n}\n\nLLVM_DUMP_METHOD void LSRUse::dump() const {\n  print(errs()); errs() << '\\n';\n}\n#endif\n\nstatic bool isAMCompletelyFolded(const TargetTransformInfo &TTI,\n                                 LSRUse::KindType Kind, MemAccessTy AccessTy,\n                                 GlobalValue *BaseGV, int64_t BaseOffset,\n                                 bool HasBaseReg, int64_t Scale,\n                                 Instruction *Fixup/*= nullptr*/) {\n  switch (Kind) {\n  case LSRUse::Address:\n    return TTI.isLegalAddressingMode(AccessTy.MemTy, BaseGV, BaseOffset,\n                                     HasBaseReg, Scale, AccessTy.AddrSpace, Fixup);\n\n  case LSRUse::ICmpZero:\n    // There's not even a target hook for querying whether it would be legal to\n    // fold a GV into an ICmp.\n    if (BaseGV)\n      return false;\n\n    // ICmp only has two operands; don't allow more than two non-trivial parts.\n    if (Scale != 0 && HasBaseReg && BaseOffset != 0)\n      return false;\n\n    // ICmp only supports no scale or a -1 scale, as we can \"fold\" a -1 scale by\n    // putting the scaled register in the other operand of the icmp.\n    if (Scale != 0 && Scale != -1)\n      return false;\n\n    // If we have low-level target information, ask the target if it can fold an\n    // integer immediate on an icmp.\n    if (BaseOffset != 0) {\n      // We have one of:\n      // ICmpZero     BaseReg + BaseOffset => ICmp BaseReg, -BaseOffset\n      // ICmpZero -1*ScaleReg + BaseOffset => ICmp ScaleReg, BaseOffset\n      // Offs is the ICmp immediate.\n      if (Scale == 0)\n        // The cast does the right thing with\n        // std::numeric_limits<int64_t>::min().\n        BaseOffset = -(uint64_t)BaseOffset;\n      return TTI.isLegalICmpImmediate(BaseOffset);\n    }\n\n    // ICmpZero BaseReg + -1*ScaleReg => ICmp BaseReg, ScaleReg\n    return true;\n\n  case LSRUse::Basic:\n    // Only handle single-register values.\n    return !BaseGV && Scale == 0 && BaseOffset == 0;\n\n  case LSRUse::Special:\n    // Special case Basic to handle -1 scales.\n    return !BaseGV && (Scale == 0 || Scale == -1) && BaseOffset == 0;\n  }\n\n  llvm_unreachable(\"Invalid LSRUse Kind!\");\n}\n\nstatic bool isAMCompletelyFolded(const TargetTransformInfo &TTI,\n                                 int64_t MinOffset, int64_t MaxOffset,\n                                 LSRUse::KindType Kind, MemAccessTy AccessTy,\n                                 GlobalValue *BaseGV, int64_t BaseOffset,\n                                 bool HasBaseReg, int64_t Scale) {\n  // Check for overflow.\n  if (((int64_t)((uint64_t)BaseOffset + MinOffset) > BaseOffset) !=\n      (MinOffset > 0))\n    return false;\n  MinOffset = (uint64_t)BaseOffset + MinOffset;\n  if (((int64_t)((uint64_t)BaseOffset + MaxOffset) > BaseOffset) !=\n      (MaxOffset > 0))\n    return false;\n  MaxOffset = (uint64_t)BaseOffset + MaxOffset;\n\n  return isAMCompletelyFolded(TTI, Kind, AccessTy, BaseGV, MinOffset,\n                              HasBaseReg, Scale) &&\n         isAMCompletelyFolded(TTI, Kind, AccessTy, BaseGV, MaxOffset,\n                              HasBaseReg, Scale);\n}\n\nstatic bool isAMCompletelyFolded(const TargetTransformInfo &TTI,\n                                 int64_t MinOffset, int64_t MaxOffset,\n                                 LSRUse::KindType Kind, MemAccessTy AccessTy,\n                                 const Formula &F, const Loop &L) {\n  // For the purpose of isAMCompletelyFolded either having a canonical formula\n  // or a scale not equal to zero is correct.\n  // Problems may arise from non canonical formulae having a scale == 0.\n  // Strictly speaking it would best to just rely on canonical formulae.\n  // However, when we generate the scaled formulae, we first check that the\n  // scaling factor is profitable before computing the actual ScaledReg for\n  // compile time sake.\n  assert((F.isCanonical(L) || F.Scale != 0));\n  return isAMCompletelyFolded(TTI, MinOffset, MaxOffset, Kind, AccessTy,\n                              F.BaseGV, F.BaseOffset, F.HasBaseReg, F.Scale);\n}\n\n/// Test whether we know how to expand the current formula.\nstatic bool isLegalUse(const TargetTransformInfo &TTI, int64_t MinOffset,\n                       int64_t MaxOffset, LSRUse::KindType Kind,\n                       MemAccessTy AccessTy, GlobalValue *BaseGV,\n                       int64_t BaseOffset, bool HasBaseReg, int64_t Scale) {\n  // We know how to expand completely foldable formulae.\n  return isAMCompletelyFolded(TTI, MinOffset, MaxOffset, Kind, AccessTy, BaseGV,\n                              BaseOffset, HasBaseReg, Scale) ||\n         // Or formulae that use a base register produced by a sum of base\n         // registers.\n         (Scale == 1 &&\n          isAMCompletelyFolded(TTI, MinOffset, MaxOffset, Kind, AccessTy,\n                               BaseGV, BaseOffset, true, 0));\n}\n\nstatic bool isLegalUse(const TargetTransformInfo &TTI, int64_t MinOffset,\n                       int64_t MaxOffset, LSRUse::KindType Kind,\n                       MemAccessTy AccessTy, const Formula &F) {\n  return isLegalUse(TTI, MinOffset, MaxOffset, Kind, AccessTy, F.BaseGV,\n                    F.BaseOffset, F.HasBaseReg, F.Scale);\n}\n\nstatic bool isAMCompletelyFolded(const TargetTransformInfo &TTI,\n                                 const LSRUse &LU, const Formula &F) {\n  // Target may want to look at the user instructions.\n  if (LU.Kind == LSRUse::Address && TTI.LSRWithInstrQueries()) {\n    for (const LSRFixup &Fixup : LU.Fixups)\n      if (!isAMCompletelyFolded(TTI, LSRUse::Address, LU.AccessTy, F.BaseGV,\n                                (F.BaseOffset + Fixup.Offset), F.HasBaseReg,\n                                F.Scale, Fixup.UserInst))\n        return false;\n    return true;\n  }\n\n  return isAMCompletelyFolded(TTI, LU.MinOffset, LU.MaxOffset, LU.Kind,\n                              LU.AccessTy, F.BaseGV, F.BaseOffset, F.HasBaseReg,\n                              F.Scale);\n}\n\nstatic unsigned getScalingFactorCost(const TargetTransformInfo &TTI,\n                                     const LSRUse &LU, const Formula &F,\n                                     const Loop &L) {\n  if (!F.Scale)\n    return 0;\n\n  // If the use is not completely folded in that instruction, we will have to\n  // pay an extra cost only for scale != 1.\n  if (!isAMCompletelyFolded(TTI, LU.MinOffset, LU.MaxOffset, LU.Kind,\n                            LU.AccessTy, F, L))\n    return F.Scale != 1;\n\n  switch (LU.Kind) {\n  case LSRUse::Address: {\n    // Check the scaling factor cost with both the min and max offsets.\n    int ScaleCostMinOffset = TTI.getScalingFactorCost(\n        LU.AccessTy.MemTy, F.BaseGV, F.BaseOffset + LU.MinOffset, F.HasBaseReg,\n        F.Scale, LU.AccessTy.AddrSpace);\n    int ScaleCostMaxOffset = TTI.getScalingFactorCost(\n        LU.AccessTy.MemTy, F.BaseGV, F.BaseOffset + LU.MaxOffset, F.HasBaseReg,\n        F.Scale, LU.AccessTy.AddrSpace);\n\n    assert(ScaleCostMinOffset >= 0 && ScaleCostMaxOffset >= 0 &&\n           \"Legal addressing mode has an illegal cost!\");\n    return std::max(ScaleCostMinOffset, ScaleCostMaxOffset);\n  }\n  case LSRUse::ICmpZero:\n  case LSRUse::Basic:\n  case LSRUse::Special:\n    // The use is completely folded, i.e., everything is folded into the\n    // instruction.\n    return 0;\n  }\n\n  llvm_unreachable(\"Invalid LSRUse Kind!\");\n}\n\nstatic bool isAlwaysFoldable(const TargetTransformInfo &TTI,\n                             LSRUse::KindType Kind, MemAccessTy AccessTy,\n                             GlobalValue *BaseGV, int64_t BaseOffset,\n                             bool HasBaseReg) {\n  // Fast-path: zero is always foldable.\n  if (BaseOffset == 0 && !BaseGV) return true;\n\n  // Conservatively, create an address with an immediate and a\n  // base and a scale.\n  int64_t Scale = Kind == LSRUse::ICmpZero ? -1 : 1;\n\n  // Canonicalize a scale of 1 to a base register if the formula doesn't\n  // already have a base register.\n  if (!HasBaseReg && Scale == 1) {\n    Scale = 0;\n    HasBaseReg = true;\n  }\n\n  return isAMCompletelyFolded(TTI, Kind, AccessTy, BaseGV, BaseOffset,\n                              HasBaseReg, Scale);\n}\n\nstatic bool isAlwaysFoldable(const TargetTransformInfo &TTI,\n                             ScalarEvolution &SE, int64_t MinOffset,\n                             int64_t MaxOffset, LSRUse::KindType Kind,\n                             MemAccessTy AccessTy, const SCEV *S,\n                             bool HasBaseReg) {\n  // Fast-path: zero is always foldable.\n  if (S->isZero()) return true;\n\n  // Conservatively, create an address with an immediate and a\n  // base and a scale.\n  int64_t BaseOffset = ExtractImmediate(S, SE);\n  GlobalValue *BaseGV = ExtractSymbol(S, SE);\n\n  // If there's anything else involved, it's not foldable.\n  if (!S->isZero()) return false;\n\n  // Fast-path: zero is always foldable.\n  if (BaseOffset == 0 && !BaseGV) return true;\n\n  // Conservatively, create an address with an immediate and a\n  // base and a scale.\n  int64_t Scale = Kind == LSRUse::ICmpZero ? -1 : 1;\n\n  return isAMCompletelyFolded(TTI, MinOffset, MaxOffset, Kind, AccessTy, BaseGV,\n                              BaseOffset, HasBaseReg, Scale);\n}\n\nnamespace {\n\n/// An individual increment in a Chain of IV increments.  Relate an IV user to\n/// an expression that computes the IV it uses from the IV used by the previous\n/// link in the Chain.\n///\n/// For the head of a chain, IncExpr holds the absolute SCEV expression for the\n/// original IVOperand. The head of the chain's IVOperand is only valid during\n/// chain collection, before LSR replaces IV users. During chain generation,\n/// IncExpr can be used to find the new IVOperand that computes the same\n/// expression.\nstruct IVInc {\n  Instruction *UserInst;\n  Value* IVOperand;\n  const SCEV *IncExpr;\n\n  IVInc(Instruction *U, Value *O, const SCEV *E)\n      : UserInst(U), IVOperand(O), IncExpr(E) {}\n};\n\n// The list of IV increments in program order.  We typically add the head of a\n// chain without finding subsequent links.\nstruct IVChain {\n  SmallVector<IVInc, 1> Incs;\n  const SCEV *ExprBase = nullptr;\n\n  IVChain() = default;\n  IVChain(const IVInc &Head, const SCEV *Base)\n      : Incs(1, Head), ExprBase(Base) {}\n\n  using const_iterator = SmallVectorImpl<IVInc>::const_iterator;\n\n  // Return the first increment in the chain.\n  const_iterator begin() const {\n    assert(!Incs.empty());\n    return std::next(Incs.begin());\n  }\n  const_iterator end() const {\n    return Incs.end();\n  }\n\n  // Returns true if this chain contains any increments.\n  bool hasIncs() const { return Incs.size() >= 2; }\n\n  // Add an IVInc to the end of this chain.\n  void add(const IVInc &X) { Incs.push_back(X); }\n\n  // Returns the last UserInst in the chain.\n  Instruction *tailUserInst() const { return Incs.back().UserInst; }\n\n  // Returns true if IncExpr can be profitably added to this chain.\n  bool isProfitableIncrement(const SCEV *OperExpr,\n                             const SCEV *IncExpr,\n                             ScalarEvolution&);\n};\n\n/// Helper for CollectChains to track multiple IV increment uses.  Distinguish\n/// between FarUsers that definitely cross IV increments and NearUsers that may\n/// be used between IV increments.\nstruct ChainUsers {\n  SmallPtrSet<Instruction*, 4> FarUsers;\n  SmallPtrSet<Instruction*, 4> NearUsers;\n};\n\n/// This class holds state for the main loop strength reduction logic.\nclass LSRInstance {\n  IVUsers &IU;\n  ScalarEvolution &SE;\n  DominatorTree &DT;\n  LoopInfo &LI;\n  AssumptionCache &AC;\n  TargetLibraryInfo &TLI;\n  const TargetTransformInfo &TTI;\n  Loop *const L;\n  MemorySSAUpdater *MSSAU;\n  TTI::AddressingModeKind AMK;\n  bool Changed = false;\n\n  /// This is the insert position that the current loop's induction variable\n  /// increment should be placed. In simple loops, this is the latch block's\n  /// terminator. But in more complicated cases, this is a position which will\n  /// dominate all the in-loop post-increment users.\n  Instruction *IVIncInsertPos = nullptr;\n\n  /// Interesting factors between use strides.\n  ///\n  /// We explicitly use a SetVector which contains a SmallSet, instead of the\n  /// default, a SmallDenseSet, because we need to use the full range of\n  /// int64_ts, and there's currently no good way of doing that with\n  /// SmallDenseSet.\n  SetVector<int64_t, SmallVector<int64_t, 8>, SmallSet<int64_t, 8>> Factors;\n\n  /// Interesting use types, to facilitate truncation reuse.\n  SmallSetVector<Type *, 4> Types;\n\n  /// The list of interesting uses.\n  mutable SmallVector<LSRUse, 16> Uses;\n\n  /// Track which uses use which register candidates.\n  RegUseTracker RegUses;\n\n  // Limit the number of chains to avoid quadratic behavior. We don't expect to\n  // have more than a few IV increment chains in a loop. Missing a Chain falls\n  // back to normal LSR behavior for those uses.\n  static const unsigned MaxChains = 8;\n\n  /// IV users can form a chain of IV increments.\n  SmallVector<IVChain, MaxChains> IVChainVec;\n\n  /// IV users that belong to profitable IVChains.\n  SmallPtrSet<Use*, MaxChains> IVIncSet;\n\n  void OptimizeShadowIV();\n  bool FindIVUserForCond(ICmpInst *Cond, IVStrideUse *&CondUse);\n  ICmpInst *OptimizeMax(ICmpInst *Cond, IVStrideUse* &CondUse);\n  void OptimizeLoopTermCond();\n\n  void ChainInstruction(Instruction *UserInst, Instruction *IVOper,\n                        SmallVectorImpl<ChainUsers> &ChainUsersVec);\n  void FinalizeChain(IVChain &Chain);\n  void CollectChains();\n  void GenerateIVChain(const IVChain &Chain, SCEVExpander &Rewriter,\n                       SmallVectorImpl<WeakTrackingVH> &DeadInsts);\n\n  void CollectInterestingTypesAndFactors();\n  void CollectFixupsAndInitialFormulae();\n\n  // Support for sharing of LSRUses between LSRFixups.\n  using UseMapTy = DenseMap<LSRUse::SCEVUseKindPair, size_t>;\n  UseMapTy UseMap;\n\n  bool reconcileNewOffset(LSRUse &LU, int64_t NewOffset, bool HasBaseReg,\n                          LSRUse::KindType Kind, MemAccessTy AccessTy);\n\n  std::pair<size_t, int64_t> getUse(const SCEV *&Expr, LSRUse::KindType Kind,\n                                    MemAccessTy AccessTy);\n\n  void DeleteUse(LSRUse &LU, size_t LUIdx);\n\n  LSRUse *FindUseWithSimilarFormula(const Formula &F, const LSRUse &OrigLU);\n\n  void InsertInitialFormula(const SCEV *S, LSRUse &LU, size_t LUIdx);\n  void InsertSupplementalFormula(const SCEV *S, LSRUse &LU, size_t LUIdx);\n  void CountRegisters(const Formula &F, size_t LUIdx);\n  bool InsertFormula(LSRUse &LU, unsigned LUIdx, const Formula &F);\n\n  void CollectLoopInvariantFixupsAndFormulae();\n\n  void GenerateReassociations(LSRUse &LU, unsigned LUIdx, Formula Base,\n                              unsigned Depth = 0);\n\n  void GenerateReassociationsImpl(LSRUse &LU, unsigned LUIdx,\n                                  const Formula &Base, unsigned Depth,\n                                  size_t Idx, bool IsScaledReg = false);\n  void GenerateCombinations(LSRUse &LU, unsigned LUIdx, Formula Base);\n  void GenerateSymbolicOffsetsImpl(LSRUse &LU, unsigned LUIdx,\n                                   const Formula &Base, size_t Idx,\n                                   bool IsScaledReg = false);\n  void GenerateSymbolicOffsets(LSRUse &LU, unsigned LUIdx, Formula Base);\n  void GenerateConstantOffsetsImpl(LSRUse &LU, unsigned LUIdx,\n                                   const Formula &Base,\n                                   const SmallVectorImpl<int64_t> &Worklist,\n                                   size_t Idx, bool IsScaledReg = false);\n  void GenerateConstantOffsets(LSRUse &LU, unsigned LUIdx, Formula Base);\n  void GenerateICmpZeroScales(LSRUse &LU, unsigned LUIdx, Formula Base);\n  void GenerateScales(LSRUse &LU, unsigned LUIdx, Formula Base);\n  void GenerateTruncates(LSRUse &LU, unsigned LUIdx, Formula Base);\n  void GenerateCrossUseConstantOffsets();\n  void GenerateAllReuseFormulae();\n\n  void FilterOutUndesirableDedicatedRegisters();\n\n  size_t EstimateSearchSpaceComplexity() const;\n  void NarrowSearchSpaceByDetectingSupersets();\n  void NarrowSearchSpaceByCollapsingUnrolledCode();\n  void NarrowSearchSpaceByRefilteringUndesirableDedicatedRegisters();\n  void NarrowSearchSpaceByFilterFormulaWithSameScaledReg();\n  void NarrowSearchSpaceByFilterPostInc();\n  void NarrowSearchSpaceByDeletingCostlyFormulas();\n  void NarrowSearchSpaceByPickingWinnerRegs();\n  void NarrowSearchSpaceUsingHeuristics();\n\n  void SolveRecurse(SmallVectorImpl<const Formula *> &Solution,\n                    Cost &SolutionCost,\n                    SmallVectorImpl<const Formula *> &Workspace,\n                    const Cost &CurCost,\n                    const SmallPtrSet<const SCEV *, 16> &CurRegs,\n                    DenseSet<const SCEV *> &VisitedRegs) const;\n  void Solve(SmallVectorImpl<const Formula *> &Solution) const;\n\n  BasicBlock::iterator\n    HoistInsertPosition(BasicBlock::iterator IP,\n                        const SmallVectorImpl<Instruction *> &Inputs) const;\n  BasicBlock::iterator\n    AdjustInsertPositionForExpand(BasicBlock::iterator IP,\n                                  const LSRFixup &LF,\n                                  const LSRUse &LU,\n                                  SCEVExpander &Rewriter) const;\n\n  Value *Expand(const LSRUse &LU, const LSRFixup &LF, const Formula &F,\n                BasicBlock::iterator IP, SCEVExpander &Rewriter,\n                SmallVectorImpl<WeakTrackingVH> &DeadInsts) const;\n  void RewriteForPHI(PHINode *PN, const LSRUse &LU, const LSRFixup &LF,\n                     const Formula &F, SCEVExpander &Rewriter,\n                     SmallVectorImpl<WeakTrackingVH> &DeadInsts) const;\n  void Rewrite(const LSRUse &LU, const LSRFixup &LF, const Formula &F,\n               SCEVExpander &Rewriter,\n               SmallVectorImpl<WeakTrackingVH> &DeadInsts) const;\n  void ImplementSolution(const SmallVectorImpl<const Formula *> &Solution);\n\npublic:\n  LSRInstance(Loop *L, IVUsers &IU, ScalarEvolution &SE, DominatorTree &DT,\n              LoopInfo &LI, const TargetTransformInfo &TTI, AssumptionCache &AC,\n              TargetLibraryInfo &TLI, MemorySSAUpdater *MSSAU);\n\n  bool getChanged() const { return Changed; }\n\n  void print_factors_and_types(raw_ostream &OS) const;\n  void print_fixups(raw_ostream &OS) const;\n  void print_uses(raw_ostream &OS) const;\n  void print(raw_ostream &OS) const;\n  void dump() const;\n};\n\n} // end anonymous namespace\n\n/// If IV is used in a int-to-float cast inside the loop then try to eliminate\n/// the cast operation.\nvoid LSRInstance::OptimizeShadowIV() {\n  const SCEV *BackedgeTakenCount = SE.getBackedgeTakenCount(L);\n  if (isa<SCEVCouldNotCompute>(BackedgeTakenCount))\n    return;\n\n  for (IVUsers::const_iterator UI = IU.begin(), E = IU.end();\n       UI != E; /* empty */) {\n    IVUsers::const_iterator CandidateUI = UI;\n    ++UI;\n    Instruction *ShadowUse = CandidateUI->getUser();\n    Type *DestTy = nullptr;\n    bool IsSigned = false;\n\n    /* If shadow use is a int->float cast then insert a second IV\n       to eliminate this cast.\n\n         for (unsigned i = 0; i < n; ++i)\n           foo((double)i);\n\n       is transformed into\n\n         double d = 0.0;\n         for (unsigned i = 0; i < n; ++i, ++d)\n           foo(d);\n    */\n    if (UIToFPInst *UCast = dyn_cast<UIToFPInst>(CandidateUI->getUser())) {\n      IsSigned = false;\n      DestTy = UCast->getDestTy();\n    }\n    else if (SIToFPInst *SCast = dyn_cast<SIToFPInst>(CandidateUI->getUser())) {\n      IsSigned = true;\n      DestTy = SCast->getDestTy();\n    }\n    if (!DestTy) continue;\n\n    // If target does not support DestTy natively then do not apply\n    // this transformation.\n    if (!TTI.isTypeLegal(DestTy)) continue;\n\n    PHINode *PH = dyn_cast<PHINode>(ShadowUse->getOperand(0));\n    if (!PH) continue;\n    if (PH->getNumIncomingValues() != 2) continue;\n\n    // If the calculation in integers overflows, the result in FP type will\n    // differ. So we only can do this transformation if we are guaranteed to not\n    // deal with overflowing values\n    const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(SE.getSCEV(PH));\n    if (!AR) continue;\n    if (IsSigned && !AR->hasNoSignedWrap()) continue;\n    if (!IsSigned && !AR->hasNoUnsignedWrap()) continue;\n\n    Type *SrcTy = PH->getType();\n    int Mantissa = DestTy->getFPMantissaWidth();\n    if (Mantissa == -1) continue;\n    if ((int)SE.getTypeSizeInBits(SrcTy) > Mantissa)\n      continue;\n\n    unsigned Entry, Latch;\n    if (PH->getIncomingBlock(0) == L->getLoopPreheader()) {\n      Entry = 0;\n      Latch = 1;\n    } else {\n      Entry = 1;\n      Latch = 0;\n    }\n\n    ConstantInt *Init = dyn_cast<ConstantInt>(PH->getIncomingValue(Entry));\n    if (!Init) continue;\n    Constant *NewInit = ConstantFP::get(DestTy, IsSigned ?\n                                        (double)Init->getSExtValue() :\n                                        (double)Init->getZExtValue());\n\n    BinaryOperator *Incr =\n      dyn_cast<BinaryOperator>(PH->getIncomingValue(Latch));\n    if (!Incr) continue;\n    if (Incr->getOpcode() != Instruction::Add\n        && Incr->getOpcode() != Instruction::Sub)\n      continue;\n\n    /* Initialize new IV, double d = 0.0 in above example. */\n    ConstantInt *C = nullptr;\n    if (Incr->getOperand(0) == PH)\n      C = dyn_cast<ConstantInt>(Incr->getOperand(1));\n    else if (Incr->getOperand(1) == PH)\n      C = dyn_cast<ConstantInt>(Incr->getOperand(0));\n    else\n      continue;\n\n    if (!C) continue;\n\n    // Ignore negative constants, as the code below doesn't handle them\n    // correctly. TODO: Remove this restriction.\n    if (!C->getValue().isStrictlyPositive()) continue;\n\n    /* Add new PHINode. */\n    PHINode *NewPH = PHINode::Create(DestTy, 2, \"IV.S.\", PH);\n\n    /* create new increment. '++d' in above example. */\n    Constant *CFP = ConstantFP::get(DestTy, C->getZExtValue());\n    BinaryOperator *NewIncr =\n      BinaryOperator::Create(Incr->getOpcode() == Instruction::Add ?\n                               Instruction::FAdd : Instruction::FSub,\n                             NewPH, CFP, \"IV.S.next.\", Incr);\n\n    NewPH->addIncoming(NewInit, PH->getIncomingBlock(Entry));\n    NewPH->addIncoming(NewIncr, PH->getIncomingBlock(Latch));\n\n    /* Remove cast operation */\n    ShadowUse->replaceAllUsesWith(NewPH);\n    ShadowUse->eraseFromParent();\n    Changed = true;\n    break;\n  }\n}\n\n/// If Cond has an operand that is an expression of an IV, set the IV user and\n/// stride information and return true, otherwise return false.\nbool LSRInstance::FindIVUserForCond(ICmpInst *Cond, IVStrideUse *&CondUse) {\n  for (IVStrideUse &U : IU)\n    if (U.getUser() == Cond) {\n      // NOTE: we could handle setcc instructions with multiple uses here, but\n      // InstCombine does it as well for simple uses, it's not clear that it\n      // occurs enough in real life to handle.\n      CondUse = &U;\n      return true;\n    }\n  return false;\n}\n\n/// Rewrite the loop's terminating condition if it uses a max computation.\n///\n/// This is a narrow solution to a specific, but acute, problem. For loops\n/// like this:\n///\n///   i = 0;\n///   do {\n///     p[i] = 0.0;\n///   } while (++i < n);\n///\n/// the trip count isn't just 'n', because 'n' might not be positive. And\n/// unfortunately this can come up even for loops where the user didn't use\n/// a C do-while loop. For example, seemingly well-behaved top-test loops\n/// will commonly be lowered like this:\n///\n///   if (n > 0) {\n///     i = 0;\n///     do {\n///       p[i] = 0.0;\n///     } while (++i < n);\n///   }\n///\n/// and then it's possible for subsequent optimization to obscure the if\n/// test in such a way that indvars can't find it.\n///\n/// When indvars can't find the if test in loops like this, it creates a\n/// max expression, which allows it to give the loop a canonical\n/// induction variable:\n///\n///   i = 0;\n///   max = n < 1 ? 1 : n;\n///   do {\n///     p[i] = 0.0;\n///   } while (++i != max);\n///\n/// Canonical induction variables are necessary because the loop passes\n/// are designed around them. The most obvious example of this is the\n/// LoopInfo analysis, which doesn't remember trip count values. It\n/// expects to be able to rediscover the trip count each time it is\n/// needed, and it does this using a simple analysis that only succeeds if\n/// the loop has a canonical induction variable.\n///\n/// However, when it comes time to generate code, the maximum operation\n/// can be quite costly, especially if it's inside of an outer loop.\n///\n/// This function solves this problem by detecting this type of loop and\n/// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting\n/// the instructions for the maximum computation.\nICmpInst *LSRInstance::OptimizeMax(ICmpInst *Cond, IVStrideUse* &CondUse) {\n  // Check that the loop matches the pattern we're looking for.\n  if (Cond->getPredicate() != CmpInst::ICMP_EQ &&\n      Cond->getPredicate() != CmpInst::ICMP_NE)\n    return Cond;\n\n  SelectInst *Sel = dyn_cast<SelectInst>(Cond->getOperand(1));\n  if (!Sel || !Sel->hasOneUse()) return Cond;\n\n  const SCEV *BackedgeTakenCount = SE.getBackedgeTakenCount(L);\n  if (isa<SCEVCouldNotCompute>(BackedgeTakenCount))\n    return Cond;\n  const SCEV *One = SE.getConstant(BackedgeTakenCount->getType(), 1);\n\n  // Add one to the backedge-taken count to get the trip count.\n  const SCEV *IterationCount = SE.getAddExpr(One, BackedgeTakenCount);\n  if (IterationCount != SE.getSCEV(Sel)) return Cond;\n\n  // Check for a max calculation that matches the pattern. There's no check\n  // for ICMP_ULE here because the comparison would be with zero, which\n  // isn't interesting.\n  CmpInst::Predicate Pred = ICmpInst::BAD_ICMP_PREDICATE;\n  const SCEVNAryExpr *Max = nullptr;\n  if (const SCEVSMaxExpr *S = dyn_cast<SCEVSMaxExpr>(BackedgeTakenCount)) {\n    Pred = ICmpInst::ICMP_SLE;\n    Max = S;\n  } else if (const SCEVSMaxExpr *S = dyn_cast<SCEVSMaxExpr>(IterationCount)) {\n    Pred = ICmpInst::ICMP_SLT;\n    Max = S;\n  } else if (const SCEVUMaxExpr *U = dyn_cast<SCEVUMaxExpr>(IterationCount)) {\n    Pred = ICmpInst::ICMP_ULT;\n    Max = U;\n  } else {\n    // No match; bail.\n    return Cond;\n  }\n\n  // To handle a max with more than two operands, this optimization would\n  // require additional checking and setup.\n  if (Max->getNumOperands() != 2)\n    return Cond;\n\n  const SCEV *MaxLHS = Max->getOperand(0);\n  const SCEV *MaxRHS = Max->getOperand(1);\n\n  // ScalarEvolution canonicalizes constants to the left. For < and >, look\n  // for a comparison with 1. For <= and >=, a comparison with zero.\n  if (!MaxLHS ||\n      (ICmpInst::isTrueWhenEqual(Pred) ? !MaxLHS->isZero() : (MaxLHS != One)))\n    return Cond;\n\n  // Check the relevant induction variable for conformance to\n  // the pattern.\n  const SCEV *IV = SE.getSCEV(Cond->getOperand(0));\n  const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(IV);\n  if (!AR || !AR->isAffine() ||\n      AR->getStart() != One ||\n      AR->getStepRecurrence(SE) != One)\n    return Cond;\n\n  assert(AR->getLoop() == L &&\n         \"Loop condition operand is an addrec in a different loop!\");\n\n  // Check the right operand of the select, and remember it, as it will\n  // be used in the new comparison instruction.\n  Value *NewRHS = nullptr;\n  if (ICmpInst::isTrueWhenEqual(Pred)) {\n    // Look for n+1, and grab n.\n    if (AddOperator *BO = dyn_cast<AddOperator>(Sel->getOperand(1)))\n      if (ConstantInt *BO1 = dyn_cast<ConstantInt>(BO->getOperand(1)))\n         if (BO1->isOne() && SE.getSCEV(BO->getOperand(0)) == MaxRHS)\n           NewRHS = BO->getOperand(0);\n    if (AddOperator *BO = dyn_cast<AddOperator>(Sel->getOperand(2)))\n      if (ConstantInt *BO1 = dyn_cast<ConstantInt>(BO->getOperand(1)))\n        if (BO1->isOne() && SE.getSCEV(BO->getOperand(0)) == MaxRHS)\n          NewRHS = BO->getOperand(0);\n    if (!NewRHS)\n      return Cond;\n  } else if (SE.getSCEV(Sel->getOperand(1)) == MaxRHS)\n    NewRHS = Sel->getOperand(1);\n  else if (SE.getSCEV(Sel->getOperand(2)) == MaxRHS)\n    NewRHS = Sel->getOperand(2);\n  else if (const SCEVUnknown *SU = dyn_cast<SCEVUnknown>(MaxRHS))\n    NewRHS = SU->getValue();\n  else\n    // Max doesn't match expected pattern.\n    return Cond;\n\n  // Determine the new comparison opcode. It may be signed or unsigned,\n  // and the original comparison may be either equality or inequality.\n  if (Cond->getPredicate() == CmpInst::ICMP_EQ)\n    Pred = CmpInst::getInversePredicate(Pred);\n\n  // Ok, everything looks ok to change the condition into an SLT or SGE and\n  // delete the max calculation.\n  ICmpInst *NewCond =\n    new ICmpInst(Cond, Pred, Cond->getOperand(0), NewRHS, \"scmp\");\n\n  // Delete the max calculation instructions.\n  Cond->replaceAllUsesWith(NewCond);\n  CondUse->setUser(NewCond);\n  Instruction *Cmp = cast<Instruction>(Sel->getOperand(0));\n  Cond->eraseFromParent();\n  Sel->eraseFromParent();\n  if (Cmp->use_empty())\n    Cmp->eraseFromParent();\n  return NewCond;\n}\n\n/// Change loop terminating condition to use the postinc iv when possible.\nvoid\nLSRInstance::OptimizeLoopTermCond() {\n  SmallPtrSet<Instruction *, 4> PostIncs;\n\n  // We need a different set of heuristics for rotated and non-rotated loops.\n  // If a loop is rotated then the latch is also the backedge, so inserting\n  // post-inc expressions just before the latch is ideal. To reduce live ranges\n  // it also makes sense to rewrite terminating conditions to use post-inc\n  // expressions.\n  //\n  // If the loop is not rotated then the latch is not a backedge; the latch\n  // check is done in the loop head. Adding post-inc expressions before the\n  // latch will cause overlapping live-ranges of pre-inc and post-inc expressions\n  // in the loop body. In this case we do *not* want to use post-inc expressions\n  // in the latch check, and we want to insert post-inc expressions before\n  // the backedge.\n  BasicBlock *LatchBlock = L->getLoopLatch();\n  SmallVector<BasicBlock*, 8> ExitingBlocks;\n  L->getExitingBlocks(ExitingBlocks);\n  if (llvm::all_of(ExitingBlocks, [&LatchBlock](const BasicBlock *BB) {\n        return LatchBlock != BB;\n      })) {\n    // The backedge doesn't exit the loop; treat this as a head-tested loop.\n    IVIncInsertPos = LatchBlock->getTerminator();\n    return;\n  }\n\n  // Otherwise treat this as a rotated loop.\n  for (BasicBlock *ExitingBlock : ExitingBlocks) {\n    // Get the terminating condition for the loop if possible.  If we\n    // can, we want to change it to use a post-incremented version of its\n    // induction variable, to allow coalescing the live ranges for the IV into\n    // one register value.\n\n    BranchInst *TermBr = dyn_cast<BranchInst>(ExitingBlock->getTerminator());\n    if (!TermBr)\n      continue;\n    // FIXME: Overly conservative, termination condition could be an 'or' etc..\n    if (TermBr->isUnconditional() || !isa<ICmpInst>(TermBr->getCondition()))\n      continue;\n\n    // Search IVUsesByStride to find Cond's IVUse if there is one.\n    IVStrideUse *CondUse = nullptr;\n    ICmpInst *Cond = cast<ICmpInst>(TermBr->getCondition());\n    if (!FindIVUserForCond(Cond, CondUse))\n      continue;\n\n    // If the trip count is computed in terms of a max (due to ScalarEvolution\n    // being unable to find a sufficient guard, for example), change the loop\n    // comparison to use SLT or ULT instead of NE.\n    // One consequence of doing this now is that it disrupts the count-down\n    // optimization. That's not always a bad thing though, because in such\n    // cases it may still be worthwhile to avoid a max.\n    Cond = OptimizeMax(Cond, CondUse);\n\n    // If this exiting block dominates the latch block, it may also use\n    // the post-inc value if it won't be shared with other uses.\n    // Check for dominance.\n    if (!DT.dominates(ExitingBlock, LatchBlock))\n      continue;\n\n    // Conservatively avoid trying to use the post-inc value in non-latch\n    // exits if there may be pre-inc users in intervening blocks.\n    if (LatchBlock != ExitingBlock)\n      for (IVUsers::const_iterator UI = IU.begin(), E = IU.end(); UI != E; ++UI)\n        // Test if the use is reachable from the exiting block. This dominator\n        // query is a conservative approximation of reachability.\n        if (&*UI != CondUse &&\n            !DT.properlyDominates(UI->getUser()->getParent(), ExitingBlock)) {\n          // Conservatively assume there may be reuse if the quotient of their\n          // strides could be a legal scale.\n          const SCEV *A = IU.getStride(*CondUse, L);\n          const SCEV *B = IU.getStride(*UI, L);\n          if (!A || !B) continue;\n          if (SE.getTypeSizeInBits(A->getType()) !=\n              SE.getTypeSizeInBits(B->getType())) {\n            if (SE.getTypeSizeInBits(A->getType()) >\n                SE.getTypeSizeInBits(B->getType()))\n              B = SE.getSignExtendExpr(B, A->getType());\n            else\n              A = SE.getSignExtendExpr(A, B->getType());\n          }\n          if (const SCEVConstant *D =\n                dyn_cast_or_null<SCEVConstant>(getExactSDiv(B, A, SE))) {\n            const ConstantInt *C = D->getValue();\n            // Stride of one or negative one can have reuse with non-addresses.\n            if (C->isOne() || C->isMinusOne())\n              goto decline_post_inc;\n            // Avoid weird situations.\n            if (C->getValue().getMinSignedBits() >= 64 ||\n                C->getValue().isMinSignedValue())\n              goto decline_post_inc;\n            // Check for possible scaled-address reuse.\n            if (isAddressUse(TTI, UI->getUser(), UI->getOperandValToReplace())) {\n              MemAccessTy AccessTy = getAccessType(\n                  TTI, UI->getUser(), UI->getOperandValToReplace());\n              int64_t Scale = C->getSExtValue();\n              if (TTI.isLegalAddressingMode(AccessTy.MemTy, /*BaseGV=*/nullptr,\n                                            /*BaseOffset=*/0,\n                                            /*HasBaseReg=*/false, Scale,\n                                            AccessTy.AddrSpace))\n                goto decline_post_inc;\n              Scale = -Scale;\n              if (TTI.isLegalAddressingMode(AccessTy.MemTy, /*BaseGV=*/nullptr,\n                                            /*BaseOffset=*/0,\n                                            /*HasBaseReg=*/false, Scale,\n                                            AccessTy.AddrSpace))\n                goto decline_post_inc;\n            }\n          }\n        }\n\n    LLVM_DEBUG(dbgs() << \"  Change loop exiting icmp to use postinc iv: \"\n                      << *Cond << '\\n');\n\n    // It's possible for the setcc instruction to be anywhere in the loop, and\n    // possible for it to have multiple users.  If it is not immediately before\n    // the exiting block branch, move it.\n    if (&*++BasicBlock::iterator(Cond) != TermBr) {\n      if (Cond->hasOneUse()) {\n        Cond->moveBefore(TermBr);\n      } else {\n        // Clone the terminating condition and insert into the loopend.\n        ICmpInst *OldCond = Cond;\n        Cond = cast<ICmpInst>(Cond->clone());\n        Cond->setName(L->getHeader()->getName() + \".termcond\");\n        ExitingBlock->getInstList().insert(TermBr->getIterator(), Cond);\n\n        // Clone the IVUse, as the old use still exists!\n        CondUse = &IU.AddUser(Cond, CondUse->getOperandValToReplace());\n        TermBr->replaceUsesOfWith(OldCond, Cond);\n      }\n    }\n\n    // If we get to here, we know that we can transform the setcc instruction to\n    // use the post-incremented version of the IV, allowing us to coalesce the\n    // live ranges for the IV correctly.\n    CondUse->transformToPostInc(L);\n    Changed = true;\n\n    PostIncs.insert(Cond);\n  decline_post_inc:;\n  }\n\n  // Determine an insertion point for the loop induction variable increment. It\n  // must dominate all the post-inc comparisons we just set up, and it must\n  // dominate the loop latch edge.\n  IVIncInsertPos = L->getLoopLatch()->getTerminator();\n  for (Instruction *Inst : PostIncs) {\n    BasicBlock *BB =\n      DT.findNearestCommonDominator(IVIncInsertPos->getParent(),\n                                    Inst->getParent());\n    if (BB == Inst->getParent())\n      IVIncInsertPos = Inst;\n    else if (BB != IVIncInsertPos->getParent())\n      IVIncInsertPos = BB->getTerminator();\n  }\n}\n\n/// Determine if the given use can accommodate a fixup at the given offset and\n/// other details. If so, update the use and return true.\nbool LSRInstance::reconcileNewOffset(LSRUse &LU, int64_t NewOffset,\n                                     bool HasBaseReg, LSRUse::KindType Kind,\n                                     MemAccessTy AccessTy) {\n  int64_t NewMinOffset = LU.MinOffset;\n  int64_t NewMaxOffset = LU.MaxOffset;\n  MemAccessTy NewAccessTy = AccessTy;\n\n  // Check for a mismatched kind. It's tempting to collapse mismatched kinds to\n  // something conservative, however this can pessimize in the case that one of\n  // the uses will have all its uses outside the loop, for example.\n  if (LU.Kind != Kind)\n    return false;\n\n  // Check for a mismatched access type, and fall back conservatively as needed.\n  // TODO: Be less conservative when the type is similar and can use the same\n  // addressing modes.\n  if (Kind == LSRUse::Address) {\n    if (AccessTy.MemTy != LU.AccessTy.MemTy) {\n      NewAccessTy = MemAccessTy::getUnknown(AccessTy.MemTy->getContext(),\n                                            AccessTy.AddrSpace);\n    }\n  }\n\n  // Conservatively assume HasBaseReg is true for now.\n  if (NewOffset < LU.MinOffset) {\n    if (!isAlwaysFoldable(TTI, Kind, NewAccessTy, /*BaseGV=*/nullptr,\n                          LU.MaxOffset - NewOffset, HasBaseReg))\n      return false;\n    NewMinOffset = NewOffset;\n  } else if (NewOffset > LU.MaxOffset) {\n    if (!isAlwaysFoldable(TTI, Kind, NewAccessTy, /*BaseGV=*/nullptr,\n                          NewOffset - LU.MinOffset, HasBaseReg))\n      return false;\n    NewMaxOffset = NewOffset;\n  }\n\n  // Update the use.\n  LU.MinOffset = NewMinOffset;\n  LU.MaxOffset = NewMaxOffset;\n  LU.AccessTy = NewAccessTy;\n  return true;\n}\n\n/// Return an LSRUse index and an offset value for a fixup which needs the given\n/// expression, with the given kind and optional access type.  Either reuse an\n/// existing use or create a new one, as needed.\nstd::pair<size_t, int64_t> LSRInstance::getUse(const SCEV *&Expr,\n                                               LSRUse::KindType Kind,\n                                               MemAccessTy AccessTy) {\n  const SCEV *Copy = Expr;\n  int64_t Offset = ExtractImmediate(Expr, SE);\n\n  // Basic uses can't accept any offset, for example.\n  if (!isAlwaysFoldable(TTI, Kind, AccessTy, /*BaseGV=*/ nullptr,\n                        Offset, /*HasBaseReg=*/ true)) {\n    Expr = Copy;\n    Offset = 0;\n  }\n\n  std::pair<UseMapTy::iterator, bool> P =\n    UseMap.insert(std::make_pair(LSRUse::SCEVUseKindPair(Expr, Kind), 0));\n  if (!P.second) {\n    // A use already existed with this base.\n    size_t LUIdx = P.first->second;\n    LSRUse &LU = Uses[LUIdx];\n    if (reconcileNewOffset(LU, Offset, /*HasBaseReg=*/true, Kind, AccessTy))\n      // Reuse this use.\n      return std::make_pair(LUIdx, Offset);\n  }\n\n  // Create a new use.\n  size_t LUIdx = Uses.size();\n  P.first->second = LUIdx;\n  Uses.push_back(LSRUse(Kind, AccessTy));\n  LSRUse &LU = Uses[LUIdx];\n\n  LU.MinOffset = Offset;\n  LU.MaxOffset = Offset;\n  return std::make_pair(LUIdx, Offset);\n}\n\n/// Delete the given use from the Uses list.\nvoid LSRInstance::DeleteUse(LSRUse &LU, size_t LUIdx) {\n  if (&LU != &Uses.back())\n    std::swap(LU, Uses.back());\n  Uses.pop_back();\n\n  // Update RegUses.\n  RegUses.swapAndDropUse(LUIdx, Uses.size());\n}\n\n/// Look for a use distinct from OrigLU which is has a formula that has the same\n/// registers as the given formula.\nLSRUse *\nLSRInstance::FindUseWithSimilarFormula(const Formula &OrigF,\n                                       const LSRUse &OrigLU) {\n  // Search all uses for the formula. This could be more clever.\n  for (size_t LUIdx = 0, NumUses = Uses.size(); LUIdx != NumUses; ++LUIdx) {\n    LSRUse &LU = Uses[LUIdx];\n    // Check whether this use is close enough to OrigLU, to see whether it's\n    // worthwhile looking through its formulae.\n    // Ignore ICmpZero uses because they may contain formulae generated by\n    // GenerateICmpZeroScales, in which case adding fixup offsets may\n    // be invalid.\n    if (&LU != &OrigLU &&\n        LU.Kind != LSRUse::ICmpZero &&\n        LU.Kind == OrigLU.Kind && OrigLU.AccessTy == LU.AccessTy &&\n        LU.WidestFixupType == OrigLU.WidestFixupType &&\n        LU.HasFormulaWithSameRegs(OrigF)) {\n      // Scan through this use's formulae.\n      for (const Formula &F : LU.Formulae) {\n        // Check to see if this formula has the same registers and symbols\n        // as OrigF.\n        if (F.BaseRegs == OrigF.BaseRegs &&\n            F.ScaledReg == OrigF.ScaledReg &&\n            F.BaseGV == OrigF.BaseGV &&\n            F.Scale == OrigF.Scale &&\n            F.UnfoldedOffset == OrigF.UnfoldedOffset) {\n          if (F.BaseOffset == 0)\n            return &LU;\n          // This is the formula where all the registers and symbols matched;\n          // there aren't going to be any others. Since we declined it, we\n          // can skip the rest of the formulae and proceed to the next LSRUse.\n          break;\n        }\n      }\n    }\n  }\n\n  // Nothing looked good.\n  return nullptr;\n}\n\nvoid LSRInstance::CollectInterestingTypesAndFactors() {\n  SmallSetVector<const SCEV *, 4> Strides;\n\n  // Collect interesting types and strides.\n  SmallVector<const SCEV *, 4> Worklist;\n  for (const IVStrideUse &U : IU) {\n    const SCEV *Expr = IU.getExpr(U);\n\n    // Collect interesting types.\n    Types.insert(SE.getEffectiveSCEVType(Expr->getType()));\n\n    // Add strides for mentioned loops.\n    Worklist.push_back(Expr);\n    do {\n      const SCEV *S = Worklist.pop_back_val();\n      if (const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(S)) {\n        if (AR->getLoop() == L)\n          Strides.insert(AR->getStepRecurrence(SE));\n        Worklist.push_back(AR->getStart());\n      } else if (const SCEVAddExpr *Add = dyn_cast<SCEVAddExpr>(S)) {\n        Worklist.append(Add->op_begin(), Add->op_end());\n      }\n    } while (!Worklist.empty());\n  }\n\n  // Compute interesting factors from the set of interesting strides.\n  for (SmallSetVector<const SCEV *, 4>::const_iterator\n       I = Strides.begin(), E = Strides.end(); I != E; ++I)\n    for (SmallSetVector<const SCEV *, 4>::const_iterator NewStrideIter =\n         std::next(I); NewStrideIter != E; ++NewStrideIter) {\n      const SCEV *OldStride = *I;\n      const SCEV *NewStride = *NewStrideIter;\n\n      if (SE.getTypeSizeInBits(OldStride->getType()) !=\n          SE.getTypeSizeInBits(NewStride->getType())) {\n        if (SE.getTypeSizeInBits(OldStride->getType()) >\n            SE.getTypeSizeInBits(NewStride->getType()))\n          NewStride = SE.getSignExtendExpr(NewStride, OldStride->getType());\n        else\n          OldStride = SE.getSignExtendExpr(OldStride, NewStride->getType());\n      }\n      if (const SCEVConstant *Factor =\n            dyn_cast_or_null<SCEVConstant>(getExactSDiv(NewStride, OldStride,\n                                                        SE, true))) {\n        if (Factor->getAPInt().getMinSignedBits() <= 64)\n          Factors.insert(Factor->getAPInt().getSExtValue());\n      } else if (const SCEVConstant *Factor =\n                   dyn_cast_or_null<SCEVConstant>(getExactSDiv(OldStride,\n                                                               NewStride,\n                                                               SE, true))) {\n        if (Factor->getAPInt().getMinSignedBits() <= 64)\n          Factors.insert(Factor->getAPInt().getSExtValue());\n      }\n    }\n\n  // If all uses use the same type, don't bother looking for truncation-based\n  // reuse.\n  if (Types.size() == 1)\n    Types.clear();\n\n  LLVM_DEBUG(print_factors_and_types(dbgs()));\n}\n\n/// Helper for CollectChains that finds an IV operand (computed by an AddRec in\n/// this loop) within [OI,OE) or returns OE. If IVUsers mapped Instructions to\n/// IVStrideUses, we could partially skip this.\nstatic User::op_iterator\nfindIVOperand(User::op_iterator OI, User::op_iterator OE,\n              Loop *L, ScalarEvolution &SE) {\n  for(; OI != OE; ++OI) {\n    if (Instruction *Oper = dyn_cast<Instruction>(*OI)) {\n      if (!SE.isSCEVable(Oper->getType()))\n        continue;\n\n      if (const SCEVAddRecExpr *AR =\n          dyn_cast<SCEVAddRecExpr>(SE.getSCEV(Oper))) {\n        if (AR->getLoop() == L)\n          break;\n      }\n    }\n  }\n  return OI;\n}\n\n/// IVChain logic must consistently peek base TruncInst operands, so wrap it in\n/// a convenient helper.\nstatic Value *getWideOperand(Value *Oper) {\n  if (TruncInst *Trunc = dyn_cast<TruncInst>(Oper))\n    return Trunc->getOperand(0);\n  return Oper;\n}\n\n/// Return true if we allow an IV chain to include both types.\nstatic bool isCompatibleIVType(Value *LVal, Value *RVal) {\n  Type *LType = LVal->getType();\n  Type *RType = RVal->getType();\n  return (LType == RType) || (LType->isPointerTy() && RType->isPointerTy() &&\n                              // Different address spaces means (possibly)\n                              // different types of the pointer implementation,\n                              // e.g. i16 vs i32 so disallow that.\n                              (LType->getPointerAddressSpace() ==\n                               RType->getPointerAddressSpace()));\n}\n\n/// Return an approximation of this SCEV expression's \"base\", or NULL for any\n/// constant. Returning the expression itself is conservative. Returning a\n/// deeper subexpression is more precise and valid as long as it isn't less\n/// complex than another subexpression. For expressions involving multiple\n/// unscaled values, we need to return the pointer-type SCEVUnknown. This avoids\n/// forming chains across objects, such as: PrevOper==a[i], IVOper==b[i],\n/// IVInc==b-a.\n///\n/// Since SCEVUnknown is the rightmost type, and pointers are the rightmost\n/// SCEVUnknown, we simply return the rightmost SCEV operand.\nstatic const SCEV *getExprBase(const SCEV *S) {\n  switch (S->getSCEVType()) {\n  default: // uncluding scUnknown.\n    return S;\n  case scConstant:\n    return nullptr;\n  case scTruncate:\n    return getExprBase(cast<SCEVTruncateExpr>(S)->getOperand());\n  case scZeroExtend:\n    return getExprBase(cast<SCEVZeroExtendExpr>(S)->getOperand());\n  case scSignExtend:\n    return getExprBase(cast<SCEVSignExtendExpr>(S)->getOperand());\n  case scAddExpr: {\n    // Skip over scaled operands (scMulExpr) to follow add operands as long as\n    // there's nothing more complex.\n    // FIXME: not sure if we want to recognize negation.\n    const SCEVAddExpr *Add = cast<SCEVAddExpr>(S);\n    for (std::reverse_iterator<SCEVAddExpr::op_iterator> I(Add->op_end()),\n           E(Add->op_begin()); I != E; ++I) {\n      const SCEV *SubExpr = *I;\n      if (SubExpr->getSCEVType() == scAddExpr)\n        return getExprBase(SubExpr);\n\n      if (SubExpr->getSCEVType() != scMulExpr)\n        return SubExpr;\n    }\n    return S; // all operands are scaled, be conservative.\n  }\n  case scAddRecExpr:\n    return getExprBase(cast<SCEVAddRecExpr>(S)->getStart());\n  }\n  llvm_unreachable(\"Unknown SCEV kind!\");\n}\n\n/// Return true if the chain increment is profitable to expand into a loop\n/// invariant value, which may require its own register. A profitable chain\n/// increment will be an offset relative to the same base. We allow such offsets\n/// to potentially be used as chain increment as long as it's not obviously\n/// expensive to expand using real instructions.\nbool IVChain::isProfitableIncrement(const SCEV *OperExpr,\n                                    const SCEV *IncExpr,\n                                    ScalarEvolution &SE) {\n  // Aggressively form chains when -stress-ivchain.\n  if (StressIVChain)\n    return true;\n\n  // Do not replace a constant offset from IV head with a nonconstant IV\n  // increment.\n  if (!isa<SCEVConstant>(IncExpr)) {\n    const SCEV *HeadExpr = SE.getSCEV(getWideOperand(Incs[0].IVOperand));\n    if (isa<SCEVConstant>(SE.getMinusSCEV(OperExpr, HeadExpr)))\n      return false;\n  }\n\n  SmallPtrSet<const SCEV*, 8> Processed;\n  return !isHighCostExpansion(IncExpr, Processed, SE);\n}\n\n/// Return true if the number of registers needed for the chain is estimated to\n/// be less than the number required for the individual IV users. First prohibit\n/// any IV users that keep the IV live across increments (the Users set should\n/// be empty). Next count the number and type of increments in the chain.\n///\n/// Chaining IVs can lead to considerable code bloat if ISEL doesn't\n/// effectively use postinc addressing modes. Only consider it profitable it the\n/// increments can be computed in fewer registers when chained.\n///\n/// TODO: Consider IVInc free if it's already used in another chains.\nstatic bool isProfitableChain(IVChain &Chain,\n                              SmallPtrSetImpl<Instruction *> &Users,\n                              ScalarEvolution &SE,\n                              const TargetTransformInfo &TTI) {\n  if (StressIVChain)\n    return true;\n\n  if (!Chain.hasIncs())\n    return false;\n\n  if (!Users.empty()) {\n    LLVM_DEBUG(dbgs() << \"Chain: \" << *Chain.Incs[0].UserInst << \" users:\\n\";\n               for (Instruction *Inst\n                    : Users) { dbgs() << \"  \" << *Inst << \"\\n\"; });\n    return false;\n  }\n  assert(!Chain.Incs.empty() && \"empty IV chains are not allowed\");\n\n  // The chain itself may require a register, so intialize cost to 1.\n  int cost = 1;\n\n  // A complete chain likely eliminates the need for keeping the original IV in\n  // a register. LSR does not currently know how to form a complete chain unless\n  // the header phi already exists.\n  if (isa<PHINode>(Chain.tailUserInst())\n      && SE.getSCEV(Chain.tailUserInst()) == Chain.Incs[0].IncExpr) {\n    --cost;\n  }\n  const SCEV *LastIncExpr = nullptr;\n  unsigned NumConstIncrements = 0;\n  unsigned NumVarIncrements = 0;\n  unsigned NumReusedIncrements = 0;\n\n  if (TTI.isProfitableLSRChainElement(Chain.Incs[0].UserInst))\n    return true;\n\n  for (const IVInc &Inc : Chain) {\n    if (TTI.isProfitableLSRChainElement(Inc.UserInst))\n      return true;\n    if (Inc.IncExpr->isZero())\n      continue;\n\n    // Incrementing by zero or some constant is neutral. We assume constants can\n    // be folded into an addressing mode or an add's immediate operand.\n    if (isa<SCEVConstant>(Inc.IncExpr)) {\n      ++NumConstIncrements;\n      continue;\n    }\n\n    if (Inc.IncExpr == LastIncExpr)\n      ++NumReusedIncrements;\n    else\n      ++NumVarIncrements;\n\n    LastIncExpr = Inc.IncExpr;\n  }\n  // An IV chain with a single increment is handled by LSR's postinc\n  // uses. However, a chain with multiple increments requires keeping the IV's\n  // value live longer than it needs to be if chained.\n  if (NumConstIncrements > 1)\n    --cost;\n\n  // Materializing increment expressions in the preheader that didn't exist in\n  // the original code may cost a register. For example, sign-extended array\n  // indices can produce ridiculous increments like this:\n  // IV + ((sext i32 (2 * %s) to i64) + (-1 * (sext i32 %s to i64)))\n  cost += NumVarIncrements;\n\n  // Reusing variable increments likely saves a register to hold the multiple of\n  // the stride.\n  cost -= NumReusedIncrements;\n\n  LLVM_DEBUG(dbgs() << \"Chain: \" << *Chain.Incs[0].UserInst << \" Cost: \" << cost\n                    << \"\\n\");\n\n  return cost < 0;\n}\n\n/// Add this IV user to an existing chain or make it the head of a new chain.\nvoid LSRInstance::ChainInstruction(Instruction *UserInst, Instruction *IVOper,\n                                   SmallVectorImpl<ChainUsers> &ChainUsersVec) {\n  // When IVs are used as types of varying widths, they are generally converted\n  // to a wider type with some uses remaining narrow under a (free) trunc.\n  Value *const NextIV = getWideOperand(IVOper);\n  const SCEV *const OperExpr = SE.getSCEV(NextIV);\n  const SCEV *const OperExprBase = getExprBase(OperExpr);\n\n  // Visit all existing chains. Check if its IVOper can be computed as a\n  // profitable loop invariant increment from the last link in the Chain.\n  unsigned ChainIdx = 0, NChains = IVChainVec.size();\n  const SCEV *LastIncExpr = nullptr;\n  for (; ChainIdx < NChains; ++ChainIdx) {\n    IVChain &Chain = IVChainVec[ChainIdx];\n\n    // Prune the solution space aggressively by checking that both IV operands\n    // are expressions that operate on the same unscaled SCEVUnknown. This\n    // \"base\" will be canceled by the subsequent getMinusSCEV call. Checking\n    // first avoids creating extra SCEV expressions.\n    if (!StressIVChain && Chain.ExprBase != OperExprBase)\n      continue;\n\n    Value *PrevIV = getWideOperand(Chain.Incs.back().IVOperand);\n    if (!isCompatibleIVType(PrevIV, NextIV))\n      continue;\n\n    // A phi node terminates a chain.\n    if (isa<PHINode>(UserInst) && isa<PHINode>(Chain.tailUserInst()))\n      continue;\n\n    // The increment must be loop-invariant so it can be kept in a register.\n    const SCEV *PrevExpr = SE.getSCEV(PrevIV);\n    const SCEV *IncExpr = SE.getMinusSCEV(OperExpr, PrevExpr);\n    if (!SE.isLoopInvariant(IncExpr, L))\n      continue;\n\n    if (Chain.isProfitableIncrement(OperExpr, IncExpr, SE)) {\n      LastIncExpr = IncExpr;\n      break;\n    }\n  }\n  // If we haven't found a chain, create a new one, unless we hit the max. Don't\n  // bother for phi nodes, because they must be last in the chain.\n  if (ChainIdx == NChains) {\n    if (isa<PHINode>(UserInst))\n      return;\n    if (NChains >= MaxChains && !StressIVChain) {\n      LLVM_DEBUG(dbgs() << \"IV Chain Limit\\n\");\n      return;\n    }\n    LastIncExpr = OperExpr;\n    // IVUsers may have skipped over sign/zero extensions. We don't currently\n    // attempt to form chains involving extensions unless they can be hoisted\n    // into this loop's AddRec.\n    if (!isa<SCEVAddRecExpr>(LastIncExpr))\n      return;\n    ++NChains;\n    IVChainVec.push_back(IVChain(IVInc(UserInst, IVOper, LastIncExpr),\n                                 OperExprBase));\n    ChainUsersVec.resize(NChains);\n    LLVM_DEBUG(dbgs() << \"IV Chain#\" << ChainIdx << \" Head: (\" << *UserInst\n                      << \") IV=\" << *LastIncExpr << \"\\n\");\n  } else {\n    LLVM_DEBUG(dbgs() << \"IV Chain#\" << ChainIdx << \"  Inc: (\" << *UserInst\n                      << \") IV+\" << *LastIncExpr << \"\\n\");\n    // Add this IV user to the end of the chain.\n    IVChainVec[ChainIdx].add(IVInc(UserInst, IVOper, LastIncExpr));\n  }\n  IVChain &Chain = IVChainVec[ChainIdx];\n\n  SmallPtrSet<Instruction*,4> &NearUsers = ChainUsersVec[ChainIdx].NearUsers;\n  // This chain's NearUsers become FarUsers.\n  if (!LastIncExpr->isZero()) {\n    ChainUsersVec[ChainIdx].FarUsers.insert(NearUsers.begin(),\n                                            NearUsers.end());\n    NearUsers.clear();\n  }\n\n  // All other uses of IVOperand become near uses of the chain.\n  // We currently ignore intermediate values within SCEV expressions, assuming\n  // they will eventually be used be the current chain, or can be computed\n  // from one of the chain increments. To be more precise we could\n  // transitively follow its user and only add leaf IV users to the set.\n  for (User *U : IVOper->users()) {\n    Instruction *OtherUse = dyn_cast<Instruction>(U);\n    if (!OtherUse)\n      continue;\n    // Uses in the chain will no longer be uses if the chain is formed.\n    // Include the head of the chain in this iteration (not Chain.begin()).\n    IVChain::const_iterator IncIter = Chain.Incs.begin();\n    IVChain::const_iterator IncEnd = Chain.Incs.end();\n    for( ; IncIter != IncEnd; ++IncIter) {\n      if (IncIter->UserInst == OtherUse)\n        break;\n    }\n    if (IncIter != IncEnd)\n      continue;\n\n    if (SE.isSCEVable(OtherUse->getType())\n        && !isa<SCEVUnknown>(SE.getSCEV(OtherUse))\n        && IU.isIVUserOrOperand(OtherUse)) {\n      continue;\n    }\n    NearUsers.insert(OtherUse);\n  }\n\n  // Since this user is part of the chain, it's no longer considered a use\n  // of the chain.\n  ChainUsersVec[ChainIdx].FarUsers.erase(UserInst);\n}\n\n/// Populate the vector of Chains.\n///\n/// This decreases ILP at the architecture level. Targets with ample registers,\n/// multiple memory ports, and no register renaming probably don't want\n/// this. However, such targets should probably disable LSR altogether.\n///\n/// The job of LSR is to make a reasonable choice of induction variables across\n/// the loop. Subsequent passes can easily \"unchain\" computation exposing more\n/// ILP *within the loop* if the target wants it.\n///\n/// Finding the best IV chain is potentially a scheduling problem. Since LSR\n/// will not reorder memory operations, it will recognize this as a chain, but\n/// will generate redundant IV increments. Ideally this would be corrected later\n/// by a smart scheduler:\n///        = A[i]\n///        = A[i+x]\n/// A[i]   =\n/// A[i+x] =\n///\n/// TODO: Walk the entire domtree within this loop, not just the path to the\n/// loop latch. This will discover chains on side paths, but requires\n/// maintaining multiple copies of the Chains state.\nvoid LSRInstance::CollectChains() {\n  LLVM_DEBUG(dbgs() << \"Collecting IV Chains.\\n\");\n  SmallVector<ChainUsers, 8> ChainUsersVec;\n\n  SmallVector<BasicBlock *,8> LatchPath;\n  BasicBlock *LoopHeader = L->getHeader();\n  for (DomTreeNode *Rung = DT.getNode(L->getLoopLatch());\n       Rung->getBlock() != LoopHeader; Rung = Rung->getIDom()) {\n    LatchPath.push_back(Rung->getBlock());\n  }\n  LatchPath.push_back(LoopHeader);\n\n  // Walk the instruction stream from the loop header to the loop latch.\n  for (BasicBlock *BB : reverse(LatchPath)) {\n    for (Instruction &I : *BB) {\n      // Skip instructions that weren't seen by IVUsers analysis.\n      if (isa<PHINode>(I) || !IU.isIVUserOrOperand(&I))\n        continue;\n\n      // Ignore users that are part of a SCEV expression. This way we only\n      // consider leaf IV Users. This effectively rediscovers a portion of\n      // IVUsers analysis but in program order this time.\n      if (SE.isSCEVable(I.getType()) && !isa<SCEVUnknown>(SE.getSCEV(&I)))\n          continue;\n\n      // Remove this instruction from any NearUsers set it may be in.\n      for (unsigned ChainIdx = 0, NChains = IVChainVec.size();\n           ChainIdx < NChains; ++ChainIdx) {\n        ChainUsersVec[ChainIdx].NearUsers.erase(&I);\n      }\n      // Search for operands that can be chained.\n      SmallPtrSet<Instruction*, 4> UniqueOperands;\n      User::op_iterator IVOpEnd = I.op_end();\n      User::op_iterator IVOpIter = findIVOperand(I.op_begin(), IVOpEnd, L, SE);\n      while (IVOpIter != IVOpEnd) {\n        Instruction *IVOpInst = cast<Instruction>(*IVOpIter);\n        if (UniqueOperands.insert(IVOpInst).second)\n          ChainInstruction(&I, IVOpInst, ChainUsersVec);\n        IVOpIter = findIVOperand(std::next(IVOpIter), IVOpEnd, L, SE);\n      }\n    } // Continue walking down the instructions.\n  } // Continue walking down the domtree.\n  // Visit phi backedges to determine if the chain can generate the IV postinc.\n  for (PHINode &PN : L->getHeader()->phis()) {\n    if (!SE.isSCEVable(PN.getType()))\n      continue;\n\n    Instruction *IncV =\n        dyn_cast<Instruction>(PN.getIncomingValueForBlock(L->getLoopLatch()));\n    if (IncV)\n      ChainInstruction(&PN, IncV, ChainUsersVec);\n  }\n  // Remove any unprofitable chains.\n  unsigned ChainIdx = 0;\n  for (unsigned UsersIdx = 0, NChains = IVChainVec.size();\n       UsersIdx < NChains; ++UsersIdx) {\n    if (!isProfitableChain(IVChainVec[UsersIdx],\n                           ChainUsersVec[UsersIdx].FarUsers, SE, TTI))\n      continue;\n    // Preserve the chain at UsesIdx.\n    if (ChainIdx != UsersIdx)\n      IVChainVec[ChainIdx] = IVChainVec[UsersIdx];\n    FinalizeChain(IVChainVec[ChainIdx]);\n    ++ChainIdx;\n  }\n  IVChainVec.resize(ChainIdx);\n}\n\nvoid LSRInstance::FinalizeChain(IVChain &Chain) {\n  assert(!Chain.Incs.empty() && \"empty IV chains are not allowed\");\n  LLVM_DEBUG(dbgs() << \"Final Chain: \" << *Chain.Incs[0].UserInst << \"\\n\");\n  \n  for (const IVInc &Inc : Chain) {\n    LLVM_DEBUG(dbgs() << \"        Inc: \" << *Inc.UserInst << \"\\n\");\n    auto UseI = find(Inc.UserInst->operands(), Inc.IVOperand);\n    assert(UseI != Inc.UserInst->op_end() && \"cannot find IV operand\");\n    IVIncSet.insert(UseI);\n  }\n}\n\n/// Return true if the IVInc can be folded into an addressing mode.\nstatic bool canFoldIVIncExpr(const SCEV *IncExpr, Instruction *UserInst,\n                             Value *Operand, const TargetTransformInfo &TTI) {\n  const SCEVConstant *IncConst = dyn_cast<SCEVConstant>(IncExpr);\n  if (!IncConst || !isAddressUse(TTI, UserInst, Operand))\n    return false;\n\n  if (IncConst->getAPInt().getMinSignedBits() > 64)\n    return false;\n\n  MemAccessTy AccessTy = getAccessType(TTI, UserInst, Operand);\n  int64_t IncOffset = IncConst->getValue()->getSExtValue();\n  if (!isAlwaysFoldable(TTI, LSRUse::Address, AccessTy, /*BaseGV=*/nullptr,\n                        IncOffset, /*HasBaseReg=*/false))\n    return false;\n\n  return true;\n}\n\n/// Generate an add or subtract for each IVInc in a chain to materialize the IV\n/// user's operand from the previous IV user's operand.\nvoid LSRInstance::GenerateIVChain(const IVChain &Chain, SCEVExpander &Rewriter,\n                                  SmallVectorImpl<WeakTrackingVH> &DeadInsts) {\n  // Find the new IVOperand for the head of the chain. It may have been replaced\n  // by LSR.\n  const IVInc &Head = Chain.Incs[0];\n  User::op_iterator IVOpEnd = Head.UserInst->op_end();\n  // findIVOperand returns IVOpEnd if it can no longer find a valid IV user.\n  User::op_iterator IVOpIter = findIVOperand(Head.UserInst->op_begin(),\n                                             IVOpEnd, L, SE);\n  Value *IVSrc = nullptr;\n  while (IVOpIter != IVOpEnd) {\n    IVSrc = getWideOperand(*IVOpIter);\n\n    // If this operand computes the expression that the chain needs, we may use\n    // it. (Check this after setting IVSrc which is used below.)\n    //\n    // Note that if Head.IncExpr is wider than IVSrc, then this phi is too\n    // narrow for the chain, so we can no longer use it. We do allow using a\n    // wider phi, assuming the LSR checked for free truncation. In that case we\n    // should already have a truncate on this operand such that\n    // getSCEV(IVSrc) == IncExpr.\n    if (SE.getSCEV(*IVOpIter) == Head.IncExpr\n        || SE.getSCEV(IVSrc) == Head.IncExpr) {\n      break;\n    }\n    IVOpIter = findIVOperand(std::next(IVOpIter), IVOpEnd, L, SE);\n  }\n  if (IVOpIter == IVOpEnd) {\n    // Gracefully give up on this chain.\n    LLVM_DEBUG(dbgs() << \"Concealed chain head: \" << *Head.UserInst << \"\\n\");\n    return;\n  }\n  assert(IVSrc && \"Failed to find IV chain source\");\n\n  LLVM_DEBUG(dbgs() << \"Generate chain at: \" << *IVSrc << \"\\n\");\n  Type *IVTy = IVSrc->getType();\n  Type *IntTy = SE.getEffectiveSCEVType(IVTy);\n  const SCEV *LeftOverExpr = nullptr;\n  for (const IVInc &Inc : Chain) {\n    Instruction *InsertPt = Inc.UserInst;\n    if (isa<PHINode>(InsertPt))\n      InsertPt = L->getLoopLatch()->getTerminator();\n\n    // IVOper will replace the current IV User's operand. IVSrc is the IV\n    // value currently held in a register.\n    Value *IVOper = IVSrc;\n    if (!Inc.IncExpr->isZero()) {\n      // IncExpr was the result of subtraction of two narrow values, so must\n      // be signed.\n      const SCEV *IncExpr = SE.getNoopOrSignExtend(Inc.IncExpr, IntTy);\n      LeftOverExpr = LeftOverExpr ?\n        SE.getAddExpr(LeftOverExpr, IncExpr) : IncExpr;\n    }\n    if (LeftOverExpr && !LeftOverExpr->isZero()) {\n      // Expand the IV increment.\n      Rewriter.clearPostInc();\n      Value *IncV = Rewriter.expandCodeFor(LeftOverExpr, IntTy, InsertPt);\n      const SCEV *IVOperExpr = SE.getAddExpr(SE.getUnknown(IVSrc),\n                                             SE.getUnknown(IncV));\n      IVOper = Rewriter.expandCodeFor(IVOperExpr, IVTy, InsertPt);\n\n      // If an IV increment can't be folded, use it as the next IV value.\n      if (!canFoldIVIncExpr(LeftOverExpr, Inc.UserInst, Inc.IVOperand, TTI)) {\n        assert(IVTy == IVOper->getType() && \"inconsistent IV increment type\");\n        IVSrc = IVOper;\n        LeftOverExpr = nullptr;\n      }\n    }\n    Type *OperTy = Inc.IVOperand->getType();\n    if (IVTy != OperTy) {\n      assert(SE.getTypeSizeInBits(IVTy) >= SE.getTypeSizeInBits(OperTy) &&\n             \"cannot extend a chained IV\");\n      IRBuilder<> Builder(InsertPt);\n      IVOper = Builder.CreateTruncOrBitCast(IVOper, OperTy, \"lsr.chain\");\n    }\n    Inc.UserInst->replaceUsesOfWith(Inc.IVOperand, IVOper);\n    if (auto *OperandIsInstr = dyn_cast<Instruction>(Inc.IVOperand))\n      DeadInsts.emplace_back(OperandIsInstr);\n  }\n  // If LSR created a new, wider phi, we may also replace its postinc. We only\n  // do this if we also found a wide value for the head of the chain.\n  if (isa<PHINode>(Chain.tailUserInst())) {\n    for (PHINode &Phi : L->getHeader()->phis()) {\n      if (!isCompatibleIVType(&Phi, IVSrc))\n        continue;\n      Instruction *PostIncV = dyn_cast<Instruction>(\n          Phi.getIncomingValueForBlock(L->getLoopLatch()));\n      if (!PostIncV || (SE.getSCEV(PostIncV) != SE.getSCEV(IVSrc)))\n        continue;\n      Value *IVOper = IVSrc;\n      Type *PostIncTy = PostIncV->getType();\n      if (IVTy != PostIncTy) {\n        assert(PostIncTy->isPointerTy() && \"mixing int/ptr IV types\");\n        IRBuilder<> Builder(L->getLoopLatch()->getTerminator());\n        Builder.SetCurrentDebugLocation(PostIncV->getDebugLoc());\n        IVOper = Builder.CreatePointerCast(IVSrc, PostIncTy, \"lsr.chain\");\n      }\n      Phi.replaceUsesOfWith(PostIncV, IVOper);\n      DeadInsts.emplace_back(PostIncV);\n    }\n  }\n}\n\nvoid LSRInstance::CollectFixupsAndInitialFormulae() {\n  BranchInst *ExitBranch = nullptr;\n  bool SaveCmp = TTI.canSaveCmp(L, &ExitBranch, &SE, &LI, &DT, &AC, &TLI);\n\n  for (const IVStrideUse &U : IU) {\n    Instruction *UserInst = U.getUser();\n    // Skip IV users that are part of profitable IV Chains.\n    User::op_iterator UseI =\n        find(UserInst->operands(), U.getOperandValToReplace());\n    assert(UseI != UserInst->op_end() && \"cannot find IV operand\");\n    if (IVIncSet.count(UseI)) {\n      LLVM_DEBUG(dbgs() << \"Use is in profitable chain: \" << **UseI << '\\n');\n      continue;\n    }\n\n    LSRUse::KindType Kind = LSRUse::Basic;\n    MemAccessTy AccessTy;\n    if (isAddressUse(TTI, UserInst, U.getOperandValToReplace())) {\n      Kind = LSRUse::Address;\n      AccessTy = getAccessType(TTI, UserInst, U.getOperandValToReplace());\n    }\n\n    const SCEV *S = IU.getExpr(U);\n    PostIncLoopSet TmpPostIncLoops = U.getPostIncLoops();\n\n    // Equality (== and !=) ICmps are special. We can rewrite (i == N) as\n    // (N - i == 0), and this allows (N - i) to be the expression that we work\n    // with rather than just N or i, so we can consider the register\n    // requirements for both N and i at the same time. Limiting this code to\n    // equality icmps is not a problem because all interesting loops use\n    // equality icmps, thanks to IndVarSimplify.\n    if (ICmpInst *CI = dyn_cast<ICmpInst>(UserInst)) {\n      // If CI can be saved in some target, like replaced inside hardware loop\n      // in PowerPC, no need to generate initial formulae for it.\n      if (SaveCmp && CI == dyn_cast<ICmpInst>(ExitBranch->getCondition()))\n        continue;\n      if (CI->isEquality()) {\n        // Swap the operands if needed to put the OperandValToReplace on the\n        // left, for consistency.\n        Value *NV = CI->getOperand(1);\n        if (NV == U.getOperandValToReplace()) {\n          CI->setOperand(1, CI->getOperand(0));\n          CI->setOperand(0, NV);\n          NV = CI->getOperand(1);\n          Changed = true;\n        }\n\n        // x == y  -->  x - y == 0\n        const SCEV *N = SE.getSCEV(NV);\n        if (SE.isLoopInvariant(N, L) && isSafeToExpand(N, SE)) {\n          // S is normalized, so normalize N before folding it into S\n          // to keep the result normalized.\n          N = normalizeForPostIncUse(N, TmpPostIncLoops, SE);\n          Kind = LSRUse::ICmpZero;\n          S = SE.getMinusSCEV(N, S);\n        }\n\n        // -1 and the negations of all interesting strides (except the negation\n        // of -1) are now also interesting.\n        for (size_t i = 0, e = Factors.size(); i != e; ++i)\n          if (Factors[i] != -1)\n            Factors.insert(-(uint64_t)Factors[i]);\n        Factors.insert(-1);\n      }\n    }\n\n    // Get or create an LSRUse.\n    std::pair<size_t, int64_t> P = getUse(S, Kind, AccessTy);\n    size_t LUIdx = P.first;\n    int64_t Offset = P.second;\n    LSRUse &LU = Uses[LUIdx];\n\n    // Record the fixup.\n    LSRFixup &LF = LU.getNewFixup();\n    LF.UserInst = UserInst;\n    LF.OperandValToReplace = U.getOperandValToReplace();\n    LF.PostIncLoops = TmpPostIncLoops;\n    LF.Offset = Offset;\n    LU.AllFixupsOutsideLoop &= LF.isUseFullyOutsideLoop(L);\n\n    if (!LU.WidestFixupType ||\n        SE.getTypeSizeInBits(LU.WidestFixupType) <\n        SE.getTypeSizeInBits(LF.OperandValToReplace->getType()))\n      LU.WidestFixupType = LF.OperandValToReplace->getType();\n\n    // If this is the first use of this LSRUse, give it a formula.\n    if (LU.Formulae.empty()) {\n      InsertInitialFormula(S, LU, LUIdx);\n      CountRegisters(LU.Formulae.back(), LUIdx);\n    }\n  }\n\n  LLVM_DEBUG(print_fixups(dbgs()));\n}\n\n/// Insert a formula for the given expression into the given use, separating out\n/// loop-variant portions from loop-invariant and loop-computable portions.\nvoid\nLSRInstance::InsertInitialFormula(const SCEV *S, LSRUse &LU, size_t LUIdx) {\n  // Mark uses whose expressions cannot be expanded.\n  if (!isSafeToExpand(S, SE))\n    LU.RigidFormula = true;\n\n  Formula F;\n  F.initialMatch(S, L, SE);\n  bool Inserted = InsertFormula(LU, LUIdx, F);\n  assert(Inserted && \"Initial formula already exists!\"); (void)Inserted;\n}\n\n/// Insert a simple single-register formula for the given expression into the\n/// given use.\nvoid\nLSRInstance::InsertSupplementalFormula(const SCEV *S,\n                                       LSRUse &LU, size_t LUIdx) {\n  Formula F;\n  F.BaseRegs.push_back(S);\n  F.HasBaseReg = true;\n  bool Inserted = InsertFormula(LU, LUIdx, F);\n  assert(Inserted && \"Supplemental formula already exists!\"); (void)Inserted;\n}\n\n/// Note which registers are used by the given formula, updating RegUses.\nvoid LSRInstance::CountRegisters(const Formula &F, size_t LUIdx) {\n  if (F.ScaledReg)\n    RegUses.countRegister(F.ScaledReg, LUIdx);\n  for (const SCEV *BaseReg : F.BaseRegs)\n    RegUses.countRegister(BaseReg, LUIdx);\n}\n\n/// If the given formula has not yet been inserted, add it to the list, and\n/// return true. Return false otherwise.\nbool LSRInstance::InsertFormula(LSRUse &LU, unsigned LUIdx, const Formula &F) {\n  // Do not insert formula that we will not be able to expand.\n  assert(isLegalUse(TTI, LU.MinOffset, LU.MaxOffset, LU.Kind, LU.AccessTy, F) &&\n         \"Formula is illegal\");\n\n  if (!LU.InsertFormula(F, *L))\n    return false;\n\n  CountRegisters(F, LUIdx);\n  return true;\n}\n\n/// Check for other uses of loop-invariant values which we're tracking. These\n/// other uses will pin these values in registers, making them less profitable\n/// for elimination.\n/// TODO: This currently misses non-constant addrec step registers.\n/// TODO: Should this give more weight to users inside the loop?\nvoid\nLSRInstance::CollectLoopInvariantFixupsAndFormulae() {\n  SmallVector<const SCEV *, 8> Worklist(RegUses.begin(), RegUses.end());\n  SmallPtrSet<const SCEV *, 32> Visited;\n\n  while (!Worklist.empty()) {\n    const SCEV *S = Worklist.pop_back_val();\n\n    // Don't process the same SCEV twice\n    if (!Visited.insert(S).second)\n      continue;\n\n    if (const SCEVNAryExpr *N = dyn_cast<SCEVNAryExpr>(S))\n      Worklist.append(N->op_begin(), N->op_end());\n    else if (const SCEVIntegralCastExpr *C = dyn_cast<SCEVIntegralCastExpr>(S))\n      Worklist.push_back(C->getOperand());\n    else if (const SCEVUDivExpr *D = dyn_cast<SCEVUDivExpr>(S)) {\n      Worklist.push_back(D->getLHS());\n      Worklist.push_back(D->getRHS());\n    } else if (const SCEVUnknown *US = dyn_cast<SCEVUnknown>(S)) {\n      const Value *V = US->getValue();\n      if (const Instruction *Inst = dyn_cast<Instruction>(V)) {\n        // Look for instructions defined outside the loop.\n        if (L->contains(Inst)) continue;\n      } else if (isa<UndefValue>(V))\n        // Undef doesn't have a live range, so it doesn't matter.\n        continue;\n      for (const Use &U : V->uses()) {\n        const Instruction *UserInst = dyn_cast<Instruction>(U.getUser());\n        // Ignore non-instructions.\n        if (!UserInst)\n          continue;\n        // Don't bother if the instruction is an EHPad.\n        if (UserInst->isEHPad())\n          continue;\n        // Ignore instructions in other functions (as can happen with\n        // Constants).\n        if (UserInst->getParent()->getParent() != L->getHeader()->getParent())\n          continue;\n        // Ignore instructions not dominated by the loop.\n        const BasicBlock *UseBB = !isa<PHINode>(UserInst) ?\n          UserInst->getParent() :\n          cast<PHINode>(UserInst)->getIncomingBlock(\n            PHINode::getIncomingValueNumForOperand(U.getOperandNo()));\n        if (!DT.dominates(L->getHeader(), UseBB))\n          continue;\n        // Don't bother if the instruction is in a BB which ends in an EHPad.\n        if (UseBB->getTerminator()->isEHPad())\n          continue;\n        // Don't bother rewriting PHIs in catchswitch blocks.\n        if (isa<CatchSwitchInst>(UserInst->getParent()->getTerminator()))\n          continue;\n        // Ignore uses which are part of other SCEV expressions, to avoid\n        // analyzing them multiple times.\n        if (SE.isSCEVable(UserInst->getType())) {\n          const SCEV *UserS = SE.getSCEV(const_cast<Instruction *>(UserInst));\n          // If the user is a no-op, look through to its uses.\n          if (!isa<SCEVUnknown>(UserS))\n            continue;\n          if (UserS == US) {\n            Worklist.push_back(\n              SE.getUnknown(const_cast<Instruction *>(UserInst)));\n            continue;\n          }\n        }\n        // Ignore icmp instructions which are already being analyzed.\n        if (const ICmpInst *ICI = dyn_cast<ICmpInst>(UserInst)) {\n          unsigned OtherIdx = !U.getOperandNo();\n          Value *OtherOp = const_cast<Value *>(ICI->getOperand(OtherIdx));\n          if (SE.hasComputableLoopEvolution(SE.getSCEV(OtherOp), L))\n            continue;\n        }\n\n        std::pair<size_t, int64_t> P = getUse(\n            S, LSRUse::Basic, MemAccessTy());\n        size_t LUIdx = P.first;\n        int64_t Offset = P.second;\n        LSRUse &LU = Uses[LUIdx];\n        LSRFixup &LF = LU.getNewFixup();\n        LF.UserInst = const_cast<Instruction *>(UserInst);\n        LF.OperandValToReplace = U;\n        LF.Offset = Offset;\n        LU.AllFixupsOutsideLoop &= LF.isUseFullyOutsideLoop(L);\n        if (!LU.WidestFixupType ||\n            SE.getTypeSizeInBits(LU.WidestFixupType) <\n            SE.getTypeSizeInBits(LF.OperandValToReplace->getType()))\n          LU.WidestFixupType = LF.OperandValToReplace->getType();\n        InsertSupplementalFormula(US, LU, LUIdx);\n        CountRegisters(LU.Formulae.back(), Uses.size() - 1);\n        break;\n      }\n    }\n  }\n}\n\n/// Split S into subexpressions which can be pulled out into separate\n/// registers. If C is non-null, multiply each subexpression by C.\n///\n/// Return remainder expression after factoring the subexpressions captured by\n/// Ops. If Ops is complete, return NULL.\nstatic const SCEV *CollectSubexprs(const SCEV *S, const SCEVConstant *C,\n                                   SmallVectorImpl<const SCEV *> &Ops,\n                                   const Loop *L,\n                                   ScalarEvolution &SE,\n                                   unsigned Depth = 0) {\n  // Arbitrarily cap recursion to protect compile time.\n  if (Depth >= 3)\n    return S;\n\n  if (const SCEVAddExpr *Add = dyn_cast<SCEVAddExpr>(S)) {\n    // Break out add operands.\n    for (const SCEV *S : Add->operands()) {\n      const SCEV *Remainder = CollectSubexprs(S, C, Ops, L, SE, Depth+1);\n      if (Remainder)\n        Ops.push_back(C ? SE.getMulExpr(C, Remainder) : Remainder);\n    }\n    return nullptr;\n  } else if (const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(S)) {\n    // Split a non-zero base out of an addrec.\n    if (AR->getStart()->isZero() || !AR->isAffine())\n      return S;\n\n    const SCEV *Remainder = CollectSubexprs(AR->getStart(),\n                                            C, Ops, L, SE, Depth+1);\n    // Split the non-zero AddRec unless it is part of a nested recurrence that\n    // does not pertain to this loop.\n    if (Remainder && (AR->getLoop() == L || !isa<SCEVAddRecExpr>(Remainder))) {\n      Ops.push_back(C ? SE.getMulExpr(C, Remainder) : Remainder);\n      Remainder = nullptr;\n    }\n    if (Remainder != AR->getStart()) {\n      if (!Remainder)\n        Remainder = SE.getConstant(AR->getType(), 0);\n      return SE.getAddRecExpr(Remainder,\n                              AR->getStepRecurrence(SE),\n                              AR->getLoop(),\n                              //FIXME: AR->getNoWrapFlags(SCEV::FlagNW)\n                              SCEV::FlagAnyWrap);\n    }\n  } else if (const SCEVMulExpr *Mul = dyn_cast<SCEVMulExpr>(S)) {\n    // Break (C * (a + b + c)) into C*a + C*b + C*c.\n    if (Mul->getNumOperands() != 2)\n      return S;\n    if (const SCEVConstant *Op0 =\n        dyn_cast<SCEVConstant>(Mul->getOperand(0))) {\n      C = C ? cast<SCEVConstant>(SE.getMulExpr(C, Op0)) : Op0;\n      const SCEV *Remainder =\n        CollectSubexprs(Mul->getOperand(1), C, Ops, L, SE, Depth+1);\n      if (Remainder)\n        Ops.push_back(SE.getMulExpr(C, Remainder));\n      return nullptr;\n    }\n  }\n  return S;\n}\n\n/// Return true if the SCEV represents a value that may end up as a\n/// post-increment operation.\nstatic bool mayUsePostIncMode(const TargetTransformInfo &TTI,\n                              LSRUse &LU, const SCEV *S, const Loop *L,\n                              ScalarEvolution &SE) {\n  if (LU.Kind != LSRUse::Address ||\n      !LU.AccessTy.getType()->isIntOrIntVectorTy())\n    return false;\n  const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(S);\n  if (!AR)\n    return false;\n  const SCEV *LoopStep = AR->getStepRecurrence(SE);\n  if (!isa<SCEVConstant>(LoopStep))\n    return false;\n  // Check if a post-indexed load/store can be used.\n  if (TTI.isIndexedLoadLegal(TTI.MIM_PostInc, AR->getType()) ||\n      TTI.isIndexedStoreLegal(TTI.MIM_PostInc, AR->getType())) {\n    const SCEV *LoopStart = AR->getStart();\n    if (!isa<SCEVConstant>(LoopStart) && SE.isLoopInvariant(LoopStart, L))\n      return true;\n  }\n  return false;\n}\n\n/// Helper function for LSRInstance::GenerateReassociations.\nvoid LSRInstance::GenerateReassociationsImpl(LSRUse &LU, unsigned LUIdx,\n                                             const Formula &Base,\n                                             unsigned Depth, size_t Idx,\n                                             bool IsScaledReg) {\n  const SCEV *BaseReg = IsScaledReg ? Base.ScaledReg : Base.BaseRegs[Idx];\n  // Don't generate reassociations for the base register of a value that\n  // may generate a post-increment operator. The reason is that the\n  // reassociations cause extra base+register formula to be created,\n  // and possibly chosen, but the post-increment is more efficient.\n  if (AMK == TTI::AMK_PostIndexed && mayUsePostIncMode(TTI, LU, BaseReg, L, SE))\n    return;\n  SmallVector<const SCEV *, 8> AddOps;\n  const SCEV *Remainder = CollectSubexprs(BaseReg, nullptr, AddOps, L, SE);\n  if (Remainder)\n    AddOps.push_back(Remainder);\n\n  if (AddOps.size() == 1)\n    return;\n\n  for (SmallVectorImpl<const SCEV *>::const_iterator J = AddOps.begin(),\n                                                     JE = AddOps.end();\n       J != JE; ++J) {\n    // Loop-variant \"unknown\" values are uninteresting; we won't be able to\n    // do anything meaningful with them.\n    if (isa<SCEVUnknown>(*J) && !SE.isLoopInvariant(*J, L))\n      continue;\n\n    // Don't pull a constant into a register if the constant could be folded\n    // into an immediate field.\n    if (isAlwaysFoldable(TTI, SE, LU.MinOffset, LU.MaxOffset, LU.Kind,\n                         LU.AccessTy, *J, Base.getNumRegs() > 1))\n      continue;\n\n    // Collect all operands except *J.\n    SmallVector<const SCEV *, 8> InnerAddOps(\n        ((const SmallVector<const SCEV *, 8> &)AddOps).begin(), J);\n    InnerAddOps.append(std::next(J),\n                       ((const SmallVector<const SCEV *, 8> &)AddOps).end());\n\n    // Don't leave just a constant behind in a register if the constant could\n    // be folded into an immediate field.\n    if (InnerAddOps.size() == 1 &&\n        isAlwaysFoldable(TTI, SE, LU.MinOffset, LU.MaxOffset, LU.Kind,\n                         LU.AccessTy, InnerAddOps[0], Base.getNumRegs() > 1))\n      continue;\n\n    const SCEV *InnerSum = SE.getAddExpr(InnerAddOps);\n    if (InnerSum->isZero())\n      continue;\n    Formula F = Base;\n\n    // Add the remaining pieces of the add back into the new formula.\n    const SCEVConstant *InnerSumSC = dyn_cast<SCEVConstant>(InnerSum);\n    if (InnerSumSC && SE.getTypeSizeInBits(InnerSumSC->getType()) <= 64 &&\n        TTI.isLegalAddImmediate((uint64_t)F.UnfoldedOffset +\n                                InnerSumSC->getValue()->getZExtValue())) {\n      F.UnfoldedOffset =\n          (uint64_t)F.UnfoldedOffset + InnerSumSC->getValue()->getZExtValue();\n      if (IsScaledReg)\n        F.ScaledReg = nullptr;\n      else\n        F.BaseRegs.erase(F.BaseRegs.begin() + Idx);\n    } else if (IsScaledReg)\n      F.ScaledReg = InnerSum;\n    else\n      F.BaseRegs[Idx] = InnerSum;\n\n    // Add J as its own register, or an unfolded immediate.\n    const SCEVConstant *SC = dyn_cast<SCEVConstant>(*J);\n    if (SC && SE.getTypeSizeInBits(SC->getType()) <= 64 &&\n        TTI.isLegalAddImmediate((uint64_t)F.UnfoldedOffset +\n                                SC->getValue()->getZExtValue()))\n      F.UnfoldedOffset =\n          (uint64_t)F.UnfoldedOffset + SC->getValue()->getZExtValue();\n    else\n      F.BaseRegs.push_back(*J);\n    // We may have changed the number of register in base regs, adjust the\n    // formula accordingly.\n    F.canonicalize(*L);\n\n    if (InsertFormula(LU, LUIdx, F))\n      // If that formula hadn't been seen before, recurse to find more like\n      // it.\n      // Add check on Log16(AddOps.size()) - same as Log2_32(AddOps.size()) >> 2)\n      // Because just Depth is not enough to bound compile time.\n      // This means that every time AddOps.size() is greater 16^x we will add\n      // x to Depth.\n      GenerateReassociations(LU, LUIdx, LU.Formulae.back(),\n                             Depth + 1 + (Log2_32(AddOps.size()) >> 2));\n  }\n}\n\n/// Split out subexpressions from adds and the bases of addrecs.\nvoid LSRInstance::GenerateReassociations(LSRUse &LU, unsigned LUIdx,\n                                         Formula Base, unsigned Depth) {\n  assert(Base.isCanonical(*L) && \"Input must be in the canonical form\");\n  // Arbitrarily cap recursion to protect compile time.\n  if (Depth >= 3)\n    return;\n\n  for (size_t i = 0, e = Base.BaseRegs.size(); i != e; ++i)\n    GenerateReassociationsImpl(LU, LUIdx, Base, Depth, i);\n\n  if (Base.Scale == 1)\n    GenerateReassociationsImpl(LU, LUIdx, Base, Depth,\n                               /* Idx */ -1, /* IsScaledReg */ true);\n}\n\n///  Generate a formula consisting of all of the loop-dominating registers added\n/// into a single register.\nvoid LSRInstance::GenerateCombinations(LSRUse &LU, unsigned LUIdx,\n                                       Formula Base) {\n  // This method is only interesting on a plurality of registers.\n  if (Base.BaseRegs.size() + (Base.Scale == 1) +\n      (Base.UnfoldedOffset != 0) <= 1)\n    return;\n\n  // Flatten the representation, i.e., reg1 + 1*reg2 => reg1 + reg2, before\n  // processing the formula.\n  Base.unscale();\n  SmallVector<const SCEV *, 4> Ops;\n  Formula NewBase = Base;\n  NewBase.BaseRegs.clear();\n  Type *CombinedIntegerType = nullptr;\n  for (const SCEV *BaseReg : Base.BaseRegs) {\n    if (SE.properlyDominates(BaseReg, L->getHeader()) &&\n        !SE.hasComputableLoopEvolution(BaseReg, L)) {\n      if (!CombinedIntegerType)\n        CombinedIntegerType = SE.getEffectiveSCEVType(BaseReg->getType());\n      Ops.push_back(BaseReg);\n    }\n    else\n      NewBase.BaseRegs.push_back(BaseReg);\n  }\n\n  // If no register is relevant, we're done.\n  if (Ops.size() == 0)\n    return;\n\n  // Utility function for generating the required variants of the combined\n  // registers.\n  auto GenerateFormula = [&](const SCEV *Sum) {\n    Formula F = NewBase;\n\n    // TODO: If Sum is zero, it probably means ScalarEvolution missed an\n    // opportunity to fold something. For now, just ignore such cases\n    // rather than proceed with zero in a register.\n    if (Sum->isZero())\n      return;\n\n    F.BaseRegs.push_back(Sum);\n    F.canonicalize(*L);\n    (void)InsertFormula(LU, LUIdx, F);\n  };\n\n  // If we collected at least two registers, generate a formula combining them.\n  if (Ops.size() > 1) {\n    SmallVector<const SCEV *, 4> OpsCopy(Ops); // Don't let SE modify Ops.\n    GenerateFormula(SE.getAddExpr(OpsCopy));\n  }\n\n  // If we have an unfolded offset, generate a formula combining it with the\n  // registers collected.\n  if (NewBase.UnfoldedOffset) {\n    assert(CombinedIntegerType && \"Missing a type for the unfolded offset\");\n    Ops.push_back(SE.getConstant(CombinedIntegerType, NewBase.UnfoldedOffset,\n                                 true));\n    NewBase.UnfoldedOffset = 0;\n    GenerateFormula(SE.getAddExpr(Ops));\n  }\n}\n\n/// Helper function for LSRInstance::GenerateSymbolicOffsets.\nvoid LSRInstance::GenerateSymbolicOffsetsImpl(LSRUse &LU, unsigned LUIdx,\n                                              const Formula &Base, size_t Idx,\n                                              bool IsScaledReg) {\n  const SCEV *G = IsScaledReg ? Base.ScaledReg : Base.BaseRegs[Idx];\n  GlobalValue *GV = ExtractSymbol(G, SE);\n  if (G->isZero() || !GV)\n    return;\n  Formula F = Base;\n  F.BaseGV = GV;\n  if (!isLegalUse(TTI, LU.MinOffset, LU.MaxOffset, LU.Kind, LU.AccessTy, F))\n    return;\n  if (IsScaledReg)\n    F.ScaledReg = G;\n  else\n    F.BaseRegs[Idx] = G;\n  (void)InsertFormula(LU, LUIdx, F);\n}\n\n/// Generate reuse formulae using symbolic offsets.\nvoid LSRInstance::GenerateSymbolicOffsets(LSRUse &LU, unsigned LUIdx,\n                                          Formula Base) {\n  // We can't add a symbolic offset if the address already contains one.\n  if (Base.BaseGV) return;\n\n  for (size_t i = 0, e = Base.BaseRegs.size(); i != e; ++i)\n    GenerateSymbolicOffsetsImpl(LU, LUIdx, Base, i);\n  if (Base.Scale == 1)\n    GenerateSymbolicOffsetsImpl(LU, LUIdx, Base, /* Idx */ -1,\n                                /* IsScaledReg */ true);\n}\n\n/// Helper function for LSRInstance::GenerateConstantOffsets.\nvoid LSRInstance::GenerateConstantOffsetsImpl(\n    LSRUse &LU, unsigned LUIdx, const Formula &Base,\n    const SmallVectorImpl<int64_t> &Worklist, size_t Idx, bool IsScaledReg) {\n\n  auto GenerateOffset = [&](const SCEV *G, int64_t Offset) {\n    Formula F = Base;\n    F.BaseOffset = (uint64_t)Base.BaseOffset - Offset;\n\n    if (isLegalUse(TTI, LU.MinOffset - Offset, LU.MaxOffset - Offset, LU.Kind,\n                   LU.AccessTy, F)) {\n      // Add the offset to the base register.\n      const SCEV *NewG = SE.getAddExpr(SE.getConstant(G->getType(), Offset), G);\n      // If it cancelled out, drop the base register, otherwise update it.\n      if (NewG->isZero()) {\n        if (IsScaledReg) {\n          F.Scale = 0;\n          F.ScaledReg = nullptr;\n        } else\n          F.deleteBaseReg(F.BaseRegs[Idx]);\n        F.canonicalize(*L);\n      } else if (IsScaledReg)\n        F.ScaledReg = NewG;\n      else\n        F.BaseRegs[Idx] = NewG;\n\n      (void)InsertFormula(LU, LUIdx, F);\n    }\n  };\n\n  const SCEV *G = IsScaledReg ? Base.ScaledReg : Base.BaseRegs[Idx];\n\n  // With constant offsets and constant steps, we can generate pre-inc\n  // accesses by having the offset equal the step. So, for access #0 with a\n  // step of 8, we generate a G - 8 base which would require the first access\n  // to be ((G - 8) + 8),+,8. The pre-indexed access then updates the pointer\n  // for itself and hopefully becomes the base for other accesses. This means\n  // means that a single pre-indexed access can be generated to become the new\n  // base pointer for each iteration of the loop, resulting in no extra add/sub\n  // instructions for pointer updating.\n  if (AMK == TTI::AMK_PreIndexed && LU.Kind == LSRUse::Address) {\n    if (auto *GAR = dyn_cast<SCEVAddRecExpr>(G)) {\n      if (auto *StepRec =\n          dyn_cast<SCEVConstant>(GAR->getStepRecurrence(SE))) {\n        const APInt &StepInt = StepRec->getAPInt();\n        int64_t Step = StepInt.isNegative() ?\n          StepInt.getSExtValue() : StepInt.getZExtValue();\n\n        for (int64_t Offset : Worklist) {\n          Offset -= Step;\n          GenerateOffset(G, Offset);\n        }\n      }\n    }\n  }\n  for (int64_t Offset : Worklist)\n    GenerateOffset(G, Offset);\n\n  int64_t Imm = ExtractImmediate(G, SE);\n  if (G->isZero() || Imm == 0)\n    return;\n  Formula F = Base;\n  F.BaseOffset = (uint64_t)F.BaseOffset + Imm;\n  if (!isLegalUse(TTI, LU.MinOffset, LU.MaxOffset, LU.Kind, LU.AccessTy, F))\n    return;\n  if (IsScaledReg) {\n    F.ScaledReg = G;\n  } else {\n    F.BaseRegs[Idx] = G;\n    // We may generate non canonical Formula if G is a recurrent expr reg\n    // related with current loop while F.ScaledReg is not.\n    F.canonicalize(*L);\n  }\n  (void)InsertFormula(LU, LUIdx, F);\n}\n\n/// GenerateConstantOffsets - Generate reuse formulae using symbolic offsets.\nvoid LSRInstance::GenerateConstantOffsets(LSRUse &LU, unsigned LUIdx,\n                                          Formula Base) {\n  // TODO: For now, just add the min and max offset, because it usually isn't\n  // worthwhile looking at everything inbetween.\n  SmallVector<int64_t, 2> Worklist;\n  Worklist.push_back(LU.MinOffset);\n  if (LU.MaxOffset != LU.MinOffset)\n    Worklist.push_back(LU.MaxOffset);\n\n  for (size_t i = 0, e = Base.BaseRegs.size(); i != e; ++i)\n    GenerateConstantOffsetsImpl(LU, LUIdx, Base, Worklist, i);\n  if (Base.Scale == 1)\n    GenerateConstantOffsetsImpl(LU, LUIdx, Base, Worklist, /* Idx */ -1,\n                                /* IsScaledReg */ true);\n}\n\n/// For ICmpZero, check to see if we can scale up the comparison. For example, x\n/// == y -> x*c == y*c.\nvoid LSRInstance::GenerateICmpZeroScales(LSRUse &LU, unsigned LUIdx,\n                                         Formula Base) {\n  if (LU.Kind != LSRUse::ICmpZero) return;\n\n  // Determine the integer type for the base formula.\n  Type *IntTy = Base.getType();\n  if (!IntTy) return;\n  if (SE.getTypeSizeInBits(IntTy) > 64) return;\n\n  // Don't do this if there is more than one offset.\n  if (LU.MinOffset != LU.MaxOffset) return;\n\n  // Check if transformation is valid. It is illegal to multiply pointer.\n  if (Base.ScaledReg && Base.ScaledReg->getType()->isPointerTy())\n    return;\n  for (const SCEV *BaseReg : Base.BaseRegs)\n    if (BaseReg->getType()->isPointerTy())\n      return;\n  assert(!Base.BaseGV && \"ICmpZero use is not legal!\");\n\n  // Check each interesting stride.\n  for (int64_t Factor : Factors) {\n    // Check that the multiplication doesn't overflow.\n    if (Base.BaseOffset == std::numeric_limits<int64_t>::min() && Factor == -1)\n      continue;\n    int64_t NewBaseOffset = (uint64_t)Base.BaseOffset * Factor;\n    if (NewBaseOffset / Factor != Base.BaseOffset)\n      continue;\n    // If the offset will be truncated at this use, check that it is in bounds.\n    if (!IntTy->isPointerTy() &&\n        !ConstantInt::isValueValidForType(IntTy, NewBaseOffset))\n      continue;\n\n    // Check that multiplying with the use offset doesn't overflow.\n    int64_t Offset = LU.MinOffset;\n    if (Offset == std::numeric_limits<int64_t>::min() && Factor == -1)\n      continue;\n    Offset = (uint64_t)Offset * Factor;\n    if (Offset / Factor != LU.MinOffset)\n      continue;\n    // If the offset will be truncated at this use, check that it is in bounds.\n    if (!IntTy->isPointerTy() &&\n        !ConstantInt::isValueValidForType(IntTy, Offset))\n      continue;\n\n    Formula F = Base;\n    F.BaseOffset = NewBaseOffset;\n\n    // Check that this scale is legal.\n    if (!isLegalUse(TTI, Offset, Offset, LU.Kind, LU.AccessTy, F))\n      continue;\n\n    // Compensate for the use having MinOffset built into it.\n    F.BaseOffset = (uint64_t)F.BaseOffset + Offset - LU.MinOffset;\n\n    const SCEV *FactorS = SE.getConstant(IntTy, Factor);\n\n    // Check that multiplying with each base register doesn't overflow.\n    for (size_t i = 0, e = F.BaseRegs.size(); i != e; ++i) {\n      F.BaseRegs[i] = SE.getMulExpr(F.BaseRegs[i], FactorS);\n      if (getExactSDiv(F.BaseRegs[i], FactorS, SE) != Base.BaseRegs[i])\n        goto next;\n    }\n\n    // Check that multiplying with the scaled register doesn't overflow.\n    if (F.ScaledReg) {\n      F.ScaledReg = SE.getMulExpr(F.ScaledReg, FactorS);\n      if (getExactSDiv(F.ScaledReg, FactorS, SE) != Base.ScaledReg)\n        continue;\n    }\n\n    // Check that multiplying with the unfolded offset doesn't overflow.\n    if (F.UnfoldedOffset != 0) {\n      if (F.UnfoldedOffset == std::numeric_limits<int64_t>::min() &&\n          Factor == -1)\n        continue;\n      F.UnfoldedOffset = (uint64_t)F.UnfoldedOffset * Factor;\n      if (F.UnfoldedOffset / Factor != Base.UnfoldedOffset)\n        continue;\n      // If the offset will be truncated, check that it is in bounds.\n      if (!IntTy->isPointerTy() &&\n          !ConstantInt::isValueValidForType(IntTy, F.UnfoldedOffset))\n        continue;\n    }\n\n    // If we make it here and it's legal, add it.\n    (void)InsertFormula(LU, LUIdx, F);\n  next:;\n  }\n}\n\n/// Generate stride factor reuse formulae by making use of scaled-offset address\n/// modes, for example.\nvoid LSRInstance::GenerateScales(LSRUse &LU, unsigned LUIdx, Formula Base) {\n  // Determine the integer type for the base formula.\n  Type *IntTy = Base.getType();\n  if (!IntTy) return;\n\n  // If this Formula already has a scaled register, we can't add another one.\n  // Try to unscale the formula to generate a better scale.\n  if (Base.Scale != 0 && !Base.unscale())\n    return;\n\n  assert(Base.Scale == 0 && \"unscale did not did its job!\");\n\n  // Check each interesting stride.\n  for (int64_t Factor : Factors) {\n    Base.Scale = Factor;\n    Base.HasBaseReg = Base.BaseRegs.size() > 1;\n    // Check whether this scale is going to be legal.\n    if (!isLegalUse(TTI, LU.MinOffset, LU.MaxOffset, LU.Kind, LU.AccessTy,\n                    Base)) {\n      // As a special-case, handle special out-of-loop Basic users specially.\n      // TODO: Reconsider this special case.\n      if (LU.Kind == LSRUse::Basic &&\n          isLegalUse(TTI, LU.MinOffset, LU.MaxOffset, LSRUse::Special,\n                     LU.AccessTy, Base) &&\n          LU.AllFixupsOutsideLoop)\n        LU.Kind = LSRUse::Special;\n      else\n        continue;\n    }\n    // For an ICmpZero, negating a solitary base register won't lead to\n    // new solutions.\n    if (LU.Kind == LSRUse::ICmpZero &&\n        !Base.HasBaseReg && Base.BaseOffset == 0 && !Base.BaseGV)\n      continue;\n    // For each addrec base reg, if its loop is current loop, apply the scale.\n    for (size_t i = 0, e = Base.BaseRegs.size(); i != e; ++i) {\n      const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(Base.BaseRegs[i]);\n      if (AR && (AR->getLoop() == L || LU.AllFixupsOutsideLoop)) {\n        const SCEV *FactorS = SE.getConstant(IntTy, Factor);\n        if (FactorS->isZero())\n          continue;\n        // Divide out the factor, ignoring high bits, since we'll be\n        // scaling the value back up in the end.\n        if (const SCEV *Quotient = getExactSDiv(AR, FactorS, SE, true)) {\n          // TODO: This could be optimized to avoid all the copying.\n          Formula F = Base;\n          F.ScaledReg = Quotient;\n          F.deleteBaseReg(F.BaseRegs[i]);\n          // The canonical representation of 1*reg is reg, which is already in\n          // Base. In that case, do not try to insert the formula, it will be\n          // rejected anyway.\n          if (F.Scale == 1 && (F.BaseRegs.empty() ||\n                               (AR->getLoop() != L && LU.AllFixupsOutsideLoop)))\n            continue;\n          // If AllFixupsOutsideLoop is true and F.Scale is 1, we may generate\n          // non canonical Formula with ScaledReg's loop not being L.\n          if (F.Scale == 1 && LU.AllFixupsOutsideLoop)\n            F.canonicalize(*L);\n          (void)InsertFormula(LU, LUIdx, F);\n        }\n      }\n    }\n  }\n}\n\n/// Generate reuse formulae from different IV types.\nvoid LSRInstance::GenerateTruncates(LSRUse &LU, unsigned LUIdx, Formula Base) {\n  // Don't bother truncating symbolic values.\n  if (Base.BaseGV) return;\n\n  // Determine the integer type for the base formula.\n  Type *DstTy = Base.getType();\n  if (!DstTy) return;\n  DstTy = SE.getEffectiveSCEVType(DstTy);\n\n  for (Type *SrcTy : Types) {\n    if (SrcTy != DstTy && TTI.isTruncateFree(SrcTy, DstTy)) {\n      Formula F = Base;\n\n      // Sometimes SCEV is able to prove zero during ext transform. It may\n      // happen if SCEV did not do all possible transforms while creating the\n      // initial node (maybe due to depth limitations), but it can do them while\n      // taking ext.\n      if (F.ScaledReg) {\n        const SCEV *NewScaledReg = SE.getAnyExtendExpr(F.ScaledReg, SrcTy);\n        if (NewScaledReg->isZero())\n         continue;\n        F.ScaledReg = NewScaledReg;\n      }\n      bool HasZeroBaseReg = false;\n      for (const SCEV *&BaseReg : F.BaseRegs) {\n        const SCEV *NewBaseReg = SE.getAnyExtendExpr(BaseReg, SrcTy);\n        if (NewBaseReg->isZero()) {\n          HasZeroBaseReg = true;\n          break;\n        }\n        BaseReg = NewBaseReg;\n      }\n      if (HasZeroBaseReg)\n        continue;\n\n      // TODO: This assumes we've done basic processing on all uses and\n      // have an idea what the register usage is.\n      if (!F.hasRegsUsedByUsesOtherThan(LUIdx, RegUses))\n        continue;\n\n      F.canonicalize(*L);\n      (void)InsertFormula(LU, LUIdx, F);\n    }\n  }\n}\n\nnamespace {\n\n/// Helper class for GenerateCrossUseConstantOffsets. It's used to defer\n/// modifications so that the search phase doesn't have to worry about the data\n/// structures moving underneath it.\nstruct WorkItem {\n  size_t LUIdx;\n  int64_t Imm;\n  const SCEV *OrigReg;\n\n  WorkItem(size_t LI, int64_t I, const SCEV *R)\n      : LUIdx(LI), Imm(I), OrigReg(R) {}\n\n  void print(raw_ostream &OS) const;\n  void dump() const;\n};\n\n} // end anonymous namespace\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\nvoid WorkItem::print(raw_ostream &OS) const {\n  OS << \"in formulae referencing \" << *OrigReg << \" in use \" << LUIdx\n     << \" , add offset \" << Imm;\n}\n\nLLVM_DUMP_METHOD void WorkItem::dump() const {\n  print(errs()); errs() << '\\n';\n}\n#endif\n\n/// Look for registers which are a constant distance apart and try to form reuse\n/// opportunities between them.\nvoid LSRInstance::GenerateCrossUseConstantOffsets() {\n  // Group the registers by their value without any added constant offset.\n  using ImmMapTy = std::map<int64_t, const SCEV *>;\n\n  DenseMap<const SCEV *, ImmMapTy> Map;\n  DenseMap<const SCEV *, SmallBitVector> UsedByIndicesMap;\n  SmallVector<const SCEV *, 8> Sequence;\n  for (const SCEV *Use : RegUses) {\n    const SCEV *Reg = Use; // Make a copy for ExtractImmediate to modify.\n    int64_t Imm = ExtractImmediate(Reg, SE);\n    auto Pair = Map.insert(std::make_pair(Reg, ImmMapTy()));\n    if (Pair.second)\n      Sequence.push_back(Reg);\n    Pair.first->second.insert(std::make_pair(Imm, Use));\n    UsedByIndicesMap[Reg] |= RegUses.getUsedByIndices(Use);\n  }\n\n  // Now examine each set of registers with the same base value. Build up\n  // a list of work to do and do the work in a separate step so that we're\n  // not adding formulae and register counts while we're searching.\n  SmallVector<WorkItem, 32> WorkItems;\n  SmallSet<std::pair<size_t, int64_t>, 32> UniqueItems;\n  for (const SCEV *Reg : Sequence) {\n    const ImmMapTy &Imms = Map.find(Reg)->second;\n\n    // It's not worthwhile looking for reuse if there's only one offset.\n    if (Imms.size() == 1)\n      continue;\n\n    LLVM_DEBUG(dbgs() << \"Generating cross-use offsets for \" << *Reg << ':';\n               for (const auto &Entry\n                    : Imms) dbgs()\n               << ' ' << Entry.first;\n               dbgs() << '\\n');\n\n    // Examine each offset.\n    for (ImmMapTy::const_iterator J = Imms.begin(), JE = Imms.end();\n         J != JE; ++J) {\n      const SCEV *OrigReg = J->second;\n\n      int64_t JImm = J->first;\n      const SmallBitVector &UsedByIndices = RegUses.getUsedByIndices(OrigReg);\n\n      if (!isa<SCEVConstant>(OrigReg) &&\n          UsedByIndicesMap[Reg].count() == 1) {\n        LLVM_DEBUG(dbgs() << \"Skipping cross-use reuse for \" << *OrigReg\n                          << '\\n');\n        continue;\n      }\n\n      // Conservatively examine offsets between this orig reg a few selected\n      // other orig regs.\n      int64_t First = Imms.begin()->first;\n      int64_t Last = std::prev(Imms.end())->first;\n      // Compute (First + Last)  / 2 without overflow using the fact that\n      // First + Last = 2 * (First + Last) + (First ^ Last).\n      int64_t Avg = (First & Last) + ((First ^ Last) >> 1);\n      // If the result is negative and First is odd and Last even (or vice versa),\n      // we rounded towards -inf. Add 1 in that case, to round towards 0.\n      Avg = Avg + ((First ^ Last) & ((uint64_t)Avg >> 63));\n      ImmMapTy::const_iterator OtherImms[] = {\n          Imms.begin(), std::prev(Imms.end()),\n         Imms.lower_bound(Avg)};\n      for (size_t i = 0, e = array_lengthof(OtherImms); i != e; ++i) {\n        ImmMapTy::const_iterator M = OtherImms[i];\n        if (M == J || M == JE) continue;\n\n        // Compute the difference between the two.\n        int64_t Imm = (uint64_t)JImm - M->first;\n        for (unsigned LUIdx : UsedByIndices.set_bits())\n          // Make a memo of this use, offset, and register tuple.\n          if (UniqueItems.insert(std::make_pair(LUIdx, Imm)).second)\n            WorkItems.push_back(WorkItem(LUIdx, Imm, OrigReg));\n      }\n    }\n  }\n\n  Map.clear();\n  Sequence.clear();\n  UsedByIndicesMap.clear();\n  UniqueItems.clear();\n\n  // Now iterate through the worklist and add new formulae.\n  for (const WorkItem &WI : WorkItems) {\n    size_t LUIdx = WI.LUIdx;\n    LSRUse &LU = Uses[LUIdx];\n    int64_t Imm = WI.Imm;\n    const SCEV *OrigReg = WI.OrigReg;\n\n    Type *IntTy = SE.getEffectiveSCEVType(OrigReg->getType());\n    const SCEV *NegImmS = SE.getSCEV(ConstantInt::get(IntTy, -(uint64_t)Imm));\n    unsigned BitWidth = SE.getTypeSizeInBits(IntTy);\n\n    // TODO: Use a more targeted data structure.\n    for (size_t L = 0, LE = LU.Formulae.size(); L != LE; ++L) {\n      Formula F = LU.Formulae[L];\n      // FIXME: The code for the scaled and unscaled registers looks\n      // very similar but slightly different. Investigate if they\n      // could be merged. That way, we would not have to unscale the\n      // Formula.\n      F.unscale();\n      // Use the immediate in the scaled register.\n      if (F.ScaledReg == OrigReg) {\n        int64_t Offset = (uint64_t)F.BaseOffset + Imm * (uint64_t)F.Scale;\n        // Don't create 50 + reg(-50).\n        if (F.referencesReg(SE.getSCEV(\n                   ConstantInt::get(IntTy, -(uint64_t)Offset))))\n          continue;\n        Formula NewF = F;\n        NewF.BaseOffset = Offset;\n        if (!isLegalUse(TTI, LU.MinOffset, LU.MaxOffset, LU.Kind, LU.AccessTy,\n                        NewF))\n          continue;\n        NewF.ScaledReg = SE.getAddExpr(NegImmS, NewF.ScaledReg);\n\n        // If the new scale is a constant in a register, and adding the constant\n        // value to the immediate would produce a value closer to zero than the\n        // immediate itself, then the formula isn't worthwhile.\n        if (const SCEVConstant *C = dyn_cast<SCEVConstant>(NewF.ScaledReg))\n          if (C->getValue()->isNegative() != (NewF.BaseOffset < 0) &&\n              (C->getAPInt().abs() * APInt(BitWidth, F.Scale))\n                  .ule(std::abs(NewF.BaseOffset)))\n            continue;\n\n        // OK, looks good.\n        NewF.canonicalize(*this->L);\n        (void)InsertFormula(LU, LUIdx, NewF);\n      } else {\n        // Use the immediate in a base register.\n        for (size_t N = 0, NE = F.BaseRegs.size(); N != NE; ++N) {\n          const SCEV *BaseReg = F.BaseRegs[N];\n          if (BaseReg != OrigReg)\n            continue;\n          Formula NewF = F;\n          NewF.BaseOffset = (uint64_t)NewF.BaseOffset + Imm;\n          if (!isLegalUse(TTI, LU.MinOffset, LU.MaxOffset,\n                          LU.Kind, LU.AccessTy, NewF)) {\n            if (AMK == TTI::AMK_PostIndexed &&\n                mayUsePostIncMode(TTI, LU, OrigReg, this->L, SE))\n              continue;\n            if (!TTI.isLegalAddImmediate((uint64_t)NewF.UnfoldedOffset + Imm))\n              continue;\n            NewF = F;\n            NewF.UnfoldedOffset = (uint64_t)NewF.UnfoldedOffset + Imm;\n          }\n          NewF.BaseRegs[N] = SE.getAddExpr(NegImmS, BaseReg);\n\n          // If the new formula has a constant in a register, and adding the\n          // constant value to the immediate would produce a value closer to\n          // zero than the immediate itself, then the formula isn't worthwhile.\n          for (const SCEV *NewReg : NewF.BaseRegs)\n            if (const SCEVConstant *C = dyn_cast<SCEVConstant>(NewReg))\n              if ((C->getAPInt() + NewF.BaseOffset)\n                      .abs()\n                      .slt(std::abs(NewF.BaseOffset)) &&\n                  (C->getAPInt() + NewF.BaseOffset).countTrailingZeros() >=\n                      countTrailingZeros<uint64_t>(NewF.BaseOffset))\n                goto skip_formula;\n\n          // Ok, looks good.\n          NewF.canonicalize(*this->L);\n          (void)InsertFormula(LU, LUIdx, NewF);\n          break;\n        skip_formula:;\n        }\n      }\n    }\n  }\n}\n\n/// Generate formulae for each use.\nvoid\nLSRInstance::GenerateAllReuseFormulae() {\n  // This is split into multiple loops so that hasRegsUsedByUsesOtherThan\n  // queries are more precise.\n  for (size_t LUIdx = 0, NumUses = Uses.size(); LUIdx != NumUses; ++LUIdx) {\n    LSRUse &LU = Uses[LUIdx];\n    for (size_t i = 0, f = LU.Formulae.size(); i != f; ++i)\n      GenerateReassociations(LU, LUIdx, LU.Formulae[i]);\n    for (size_t i = 0, f = LU.Formulae.size(); i != f; ++i)\n      GenerateCombinations(LU, LUIdx, LU.Formulae[i]);\n  }\n  for (size_t LUIdx = 0, NumUses = Uses.size(); LUIdx != NumUses; ++LUIdx) {\n    LSRUse &LU = Uses[LUIdx];\n    for (size_t i = 0, f = LU.Formulae.size(); i != f; ++i)\n      GenerateSymbolicOffsets(LU, LUIdx, LU.Formulae[i]);\n    for (size_t i = 0, f = LU.Formulae.size(); i != f; ++i)\n      GenerateConstantOffsets(LU, LUIdx, LU.Formulae[i]);\n    for (size_t i = 0, f = LU.Formulae.size(); i != f; ++i)\n      GenerateICmpZeroScales(LU, LUIdx, LU.Formulae[i]);\n    for (size_t i = 0, f = LU.Formulae.size(); i != f; ++i)\n      GenerateScales(LU, LUIdx, LU.Formulae[i]);\n  }\n  for (size_t LUIdx = 0, NumUses = Uses.size(); LUIdx != NumUses; ++LUIdx) {\n    LSRUse &LU = Uses[LUIdx];\n    for (size_t i = 0, f = LU.Formulae.size(); i != f; ++i)\n      GenerateTruncates(LU, LUIdx, LU.Formulae[i]);\n  }\n\n  GenerateCrossUseConstantOffsets();\n\n  LLVM_DEBUG(dbgs() << \"\\n\"\n                       \"After generating reuse formulae:\\n\";\n             print_uses(dbgs()));\n}\n\n/// If there are multiple formulae with the same set of registers used\n/// by other uses, pick the best one and delete the others.\nvoid LSRInstance::FilterOutUndesirableDedicatedRegisters() {\n  DenseSet<const SCEV *> VisitedRegs;\n  SmallPtrSet<const SCEV *, 16> Regs;\n  SmallPtrSet<const SCEV *, 16> LoserRegs;\n#ifndef NDEBUG\n  bool ChangedFormulae = false;\n#endif\n\n  // Collect the best formula for each unique set of shared registers. This\n  // is reset for each use.\n  using BestFormulaeTy =\n      DenseMap<SmallVector<const SCEV *, 4>, size_t, UniquifierDenseMapInfo>;\n\n  BestFormulaeTy BestFormulae;\n\n  for (size_t LUIdx = 0, NumUses = Uses.size(); LUIdx != NumUses; ++LUIdx) {\n    LSRUse &LU = Uses[LUIdx];\n    LLVM_DEBUG(dbgs() << \"Filtering for use \"; LU.print(dbgs());\n               dbgs() << '\\n');\n\n    bool Any = false;\n    for (size_t FIdx = 0, NumForms = LU.Formulae.size();\n         FIdx != NumForms; ++FIdx) {\n      Formula &F = LU.Formulae[FIdx];\n\n      // Some formulas are instant losers. For example, they may depend on\n      // nonexistent AddRecs from other loops. These need to be filtered\n      // immediately, otherwise heuristics could choose them over others leading\n      // to an unsatisfactory solution. Passing LoserRegs into RateFormula here\n      // avoids the need to recompute this information across formulae using the\n      // same bad AddRec. Passing LoserRegs is also essential unless we remove\n      // the corresponding bad register from the Regs set.\n      Cost CostF(L, SE, TTI, AMK);\n      Regs.clear();\n      CostF.RateFormula(F, Regs, VisitedRegs, LU, &LoserRegs);\n      if (CostF.isLoser()) {\n        // During initial formula generation, undesirable formulae are generated\n        // by uses within other loops that have some non-trivial address mode or\n        // use the postinc form of the IV. LSR needs to provide these formulae\n        // as the basis of rediscovering the desired formula that uses an AddRec\n        // corresponding to the existing phi. Once all formulae have been\n        // generated, these initial losers may be pruned.\n        LLVM_DEBUG(dbgs() << \"  Filtering loser \"; F.print(dbgs());\n                   dbgs() << \"\\n\");\n      }\n      else {\n        SmallVector<const SCEV *, 4> Key;\n        for (const SCEV *Reg : F.BaseRegs) {\n          if (RegUses.isRegUsedByUsesOtherThan(Reg, LUIdx))\n            Key.push_back(Reg);\n        }\n        if (F.ScaledReg &&\n            RegUses.isRegUsedByUsesOtherThan(F.ScaledReg, LUIdx))\n          Key.push_back(F.ScaledReg);\n        // Unstable sort by host order ok, because this is only used for\n        // uniquifying.\n        llvm::sort(Key);\n\n        std::pair<BestFormulaeTy::const_iterator, bool> P =\n          BestFormulae.insert(std::make_pair(Key, FIdx));\n        if (P.second)\n          continue;\n\n        Formula &Best = LU.Formulae[P.first->second];\n\n        Cost CostBest(L, SE, TTI, AMK);\n        Regs.clear();\n        CostBest.RateFormula(Best, Regs, VisitedRegs, LU);\n        if (CostF.isLess(CostBest))\n          std::swap(F, Best);\n        LLVM_DEBUG(dbgs() << \"  Filtering out formula \"; F.print(dbgs());\n                   dbgs() << \"\\n\"\n                             \"    in favor of formula \";\n                   Best.print(dbgs()); dbgs() << '\\n');\n      }\n#ifndef NDEBUG\n      ChangedFormulae = true;\n#endif\n      LU.DeleteFormula(F);\n      --FIdx;\n      --NumForms;\n      Any = true;\n    }\n\n    // Now that we've filtered out some formulae, recompute the Regs set.\n    if (Any)\n      LU.RecomputeRegs(LUIdx, RegUses);\n\n    // Reset this to prepare for the next use.\n    BestFormulae.clear();\n  }\n\n  LLVM_DEBUG(if (ChangedFormulae) {\n    dbgs() << \"\\n\"\n              \"After filtering out undesirable candidates:\\n\";\n    print_uses(dbgs());\n  });\n}\n\n/// Estimate the worst-case number of solutions the solver might have to\n/// consider. It almost never considers this many solutions because it prune the\n/// search space, but the pruning isn't always sufficient.\nsize_t LSRInstance::EstimateSearchSpaceComplexity() const {\n  size_t Power = 1;\n  for (const LSRUse &LU : Uses) {\n    size_t FSize = LU.Formulae.size();\n    if (FSize >= ComplexityLimit) {\n      Power = ComplexityLimit;\n      break;\n    }\n    Power *= FSize;\n    if (Power >= ComplexityLimit)\n      break;\n  }\n  return Power;\n}\n\n/// When one formula uses a superset of the registers of another formula, it\n/// won't help reduce register pressure (though it may not necessarily hurt\n/// register pressure); remove it to simplify the system.\nvoid LSRInstance::NarrowSearchSpaceByDetectingSupersets() {\n  if (EstimateSearchSpaceComplexity() >= ComplexityLimit) {\n    LLVM_DEBUG(dbgs() << \"The search space is too complex.\\n\");\n\n    LLVM_DEBUG(dbgs() << \"Narrowing the search space by eliminating formulae \"\n                         \"which use a superset of registers used by other \"\n                         \"formulae.\\n\");\n\n    for (size_t LUIdx = 0, NumUses = Uses.size(); LUIdx != NumUses; ++LUIdx) {\n      LSRUse &LU = Uses[LUIdx];\n      bool Any = false;\n      for (size_t i = 0, e = LU.Formulae.size(); i != e; ++i) {\n        Formula &F = LU.Formulae[i];\n        // Look for a formula with a constant or GV in a register. If the use\n        // also has a formula with that same value in an immediate field,\n        // delete the one that uses a register.\n        for (SmallVectorImpl<const SCEV *>::const_iterator\n             I = F.BaseRegs.begin(), E = F.BaseRegs.end(); I != E; ++I) {\n          if (const SCEVConstant *C = dyn_cast<SCEVConstant>(*I)) {\n            Formula NewF = F;\n            //FIXME: Formulas should store bitwidth to do wrapping properly.\n            //       See PR41034.\n            NewF.BaseOffset += (uint64_t)C->getValue()->getSExtValue();\n            NewF.BaseRegs.erase(NewF.BaseRegs.begin() +\n                                (I - F.BaseRegs.begin()));\n            if (LU.HasFormulaWithSameRegs(NewF)) {\n              LLVM_DEBUG(dbgs() << \"  Deleting \"; F.print(dbgs());\n                         dbgs() << '\\n');\n              LU.DeleteFormula(F);\n              --i;\n              --e;\n              Any = true;\n              break;\n            }\n          } else if (const SCEVUnknown *U = dyn_cast<SCEVUnknown>(*I)) {\n            if (GlobalValue *GV = dyn_cast<GlobalValue>(U->getValue()))\n              if (!F.BaseGV) {\n                Formula NewF = F;\n                NewF.BaseGV = GV;\n                NewF.BaseRegs.erase(NewF.BaseRegs.begin() +\n                                    (I - F.BaseRegs.begin()));\n                if (LU.HasFormulaWithSameRegs(NewF)) {\n                  LLVM_DEBUG(dbgs() << \"  Deleting \"; F.print(dbgs());\n                             dbgs() << '\\n');\n                  LU.DeleteFormula(F);\n                  --i;\n                  --e;\n                  Any = true;\n                  break;\n                }\n              }\n          }\n        }\n      }\n      if (Any)\n        LU.RecomputeRegs(LUIdx, RegUses);\n    }\n\n    LLVM_DEBUG(dbgs() << \"After pre-selection:\\n\"; print_uses(dbgs()));\n  }\n}\n\n/// When there are many registers for expressions like A, A+1, A+2, etc.,\n/// allocate a single register for them.\nvoid LSRInstance::NarrowSearchSpaceByCollapsingUnrolledCode() {\n  if (EstimateSearchSpaceComplexity() < ComplexityLimit) \n    return;\n\n  LLVM_DEBUG(\n      dbgs() << \"The search space is too complex.\\n\"\n                \"Narrowing the search space by assuming that uses separated \"\n                \"by a constant offset will use the same registers.\\n\");\n\n  // This is especially useful for unrolled loops.\n\n  for (size_t LUIdx = 0, NumUses = Uses.size(); LUIdx != NumUses; ++LUIdx) {\n    LSRUse &LU = Uses[LUIdx];\n    for (const Formula &F : LU.Formulae) {\n      if (F.BaseOffset == 0 || (F.Scale != 0 && F.Scale != 1))\n        continue;\n\n      LSRUse *LUThatHas = FindUseWithSimilarFormula(F, LU);\n      if (!LUThatHas)\n        continue;\n\n      if (!reconcileNewOffset(*LUThatHas, F.BaseOffset, /*HasBaseReg=*/ false,\n                              LU.Kind, LU.AccessTy))\n        continue;\n\n      LLVM_DEBUG(dbgs() << \"  Deleting use \"; LU.print(dbgs()); dbgs() << '\\n');\n\n      LUThatHas->AllFixupsOutsideLoop &= LU.AllFixupsOutsideLoop;\n\n      // Transfer the fixups of LU to LUThatHas.\n      for (LSRFixup &Fixup : LU.Fixups) {\n        Fixup.Offset += F.BaseOffset;\n        LUThatHas->pushFixup(Fixup);\n        LLVM_DEBUG(dbgs() << \"New fixup has offset \" << Fixup.Offset << '\\n');\n      }\n\n      // Delete formulae from the new use which are no longer legal.\n      bool Any = false;\n      for (size_t i = 0, e = LUThatHas->Formulae.size(); i != e; ++i) {\n        Formula &F = LUThatHas->Formulae[i];\n        if (!isLegalUse(TTI, LUThatHas->MinOffset, LUThatHas->MaxOffset,\n                        LUThatHas->Kind, LUThatHas->AccessTy, F)) {\n          LLVM_DEBUG(dbgs() << \"  Deleting \"; F.print(dbgs()); dbgs() << '\\n');\n          LUThatHas->DeleteFormula(F);\n          --i;\n          --e;\n          Any = true;\n        }\n      }\n\n      if (Any)\n        LUThatHas->RecomputeRegs(LUThatHas - &Uses.front(), RegUses);\n\n      // Delete the old use.\n      DeleteUse(LU, LUIdx);\n      --LUIdx;\n      --NumUses;\n      break;\n    }\n  }\n\n  LLVM_DEBUG(dbgs() << \"After pre-selection:\\n\"; print_uses(dbgs()));\n}\n\n/// Call FilterOutUndesirableDedicatedRegisters again, if necessary, now that\n/// we've done more filtering, as it may be able to find more formulae to\n/// eliminate.\nvoid LSRInstance::NarrowSearchSpaceByRefilteringUndesirableDedicatedRegisters(){\n  if (EstimateSearchSpaceComplexity() >= ComplexityLimit) {\n    LLVM_DEBUG(dbgs() << \"The search space is too complex.\\n\");\n\n    LLVM_DEBUG(dbgs() << \"Narrowing the search space by re-filtering out \"\n                         \"undesirable dedicated registers.\\n\");\n\n    FilterOutUndesirableDedicatedRegisters();\n\n    LLVM_DEBUG(dbgs() << \"After pre-selection:\\n\"; print_uses(dbgs()));\n  }\n}\n\n/// If a LSRUse has multiple formulae with the same ScaledReg and Scale.\n/// Pick the best one and delete the others.\n/// This narrowing heuristic is to keep as many formulae with different\n/// Scale and ScaledReg pair as possible while narrowing the search space.\n/// The benefit is that it is more likely to find out a better solution\n/// from a formulae set with more Scale and ScaledReg variations than\n/// a formulae set with the same Scale and ScaledReg. The picking winner\n/// reg heuristic will often keep the formulae with the same Scale and\n/// ScaledReg and filter others, and we want to avoid that if possible.\nvoid LSRInstance::NarrowSearchSpaceByFilterFormulaWithSameScaledReg() {\n  if (EstimateSearchSpaceComplexity() < ComplexityLimit)\n    return;\n\n  LLVM_DEBUG(\n      dbgs() << \"The search space is too complex.\\n\"\n                \"Narrowing the search space by choosing the best Formula \"\n                \"from the Formulae with the same Scale and ScaledReg.\\n\");\n\n  // Map the \"Scale * ScaledReg\" pair to the best formula of current LSRUse.\n  using BestFormulaeTy = DenseMap<std::pair<const SCEV *, int64_t>, size_t>;\n\n  BestFormulaeTy BestFormulae;\n#ifndef NDEBUG\n  bool ChangedFormulae = false;\n#endif\n  DenseSet<const SCEV *> VisitedRegs;\n  SmallPtrSet<const SCEV *, 16> Regs;\n\n  for (size_t LUIdx = 0, NumUses = Uses.size(); LUIdx != NumUses; ++LUIdx) {\n    LSRUse &LU = Uses[LUIdx];\n    LLVM_DEBUG(dbgs() << \"Filtering for use \"; LU.print(dbgs());\n               dbgs() << '\\n');\n\n    // Return true if Formula FA is better than Formula FB.\n    auto IsBetterThan = [&](Formula &FA, Formula &FB) {\n      // First we will try to choose the Formula with fewer new registers.\n      // For a register used by current Formula, the more the register is\n      // shared among LSRUses, the less we increase the register number\n      // counter of the formula.\n      size_t FARegNum = 0;\n      for (const SCEV *Reg : FA.BaseRegs) {\n        const SmallBitVector &UsedByIndices = RegUses.getUsedByIndices(Reg);\n        FARegNum += (NumUses - UsedByIndices.count() + 1);\n      }\n      size_t FBRegNum = 0;\n      for (const SCEV *Reg : FB.BaseRegs) {\n        const SmallBitVector &UsedByIndices = RegUses.getUsedByIndices(Reg);\n        FBRegNum += (NumUses - UsedByIndices.count() + 1);\n      }\n      if (FARegNum != FBRegNum)\n        return FARegNum < FBRegNum;\n\n      // If the new register numbers are the same, choose the Formula with\n      // less Cost.\n      Cost CostFA(L, SE, TTI, AMK);\n      Cost CostFB(L, SE, TTI, AMK);\n      Regs.clear();\n      CostFA.RateFormula(FA, Regs, VisitedRegs, LU);\n      Regs.clear();\n      CostFB.RateFormula(FB, Regs, VisitedRegs, LU);\n      return CostFA.isLess(CostFB);\n    };\n\n    bool Any = false;\n    for (size_t FIdx = 0, NumForms = LU.Formulae.size(); FIdx != NumForms;\n         ++FIdx) {\n      Formula &F = LU.Formulae[FIdx];\n      if (!F.ScaledReg)\n        continue;\n      auto P = BestFormulae.insert({{F.ScaledReg, F.Scale}, FIdx});\n      if (P.second)\n        continue;\n\n      Formula &Best = LU.Formulae[P.first->second];\n      if (IsBetterThan(F, Best))\n        std::swap(F, Best);\n      LLVM_DEBUG(dbgs() << \"  Filtering out formula \"; F.print(dbgs());\n                 dbgs() << \"\\n\"\n                           \"    in favor of formula \";\n                 Best.print(dbgs()); dbgs() << '\\n');\n#ifndef NDEBUG\n      ChangedFormulae = true;\n#endif\n      LU.DeleteFormula(F);\n      --FIdx;\n      --NumForms;\n      Any = true;\n    }\n    if (Any)\n      LU.RecomputeRegs(LUIdx, RegUses);\n\n    // Reset this to prepare for the next use.\n    BestFormulae.clear();\n  }\n\n  LLVM_DEBUG(if (ChangedFormulae) {\n    dbgs() << \"\\n\"\n              \"After filtering out undesirable candidates:\\n\";\n    print_uses(dbgs());\n  });\n}\n\n/// If we are over the complexity limit, filter out any post-inc prefering\n/// variables to only post-inc values.\nvoid LSRInstance::NarrowSearchSpaceByFilterPostInc() {\n  if (AMK != TTI::AMK_PostIndexed)\n    return;\n  if (EstimateSearchSpaceComplexity() < ComplexityLimit)\n    return;\n\n  LLVM_DEBUG(dbgs() << \"The search space is too complex.\\n\"\n                       \"Narrowing the search space by choosing the lowest \"\n                       \"register Formula for PostInc Uses.\\n\");\n\n  for (size_t LUIdx = 0, NumUses = Uses.size(); LUIdx != NumUses; ++LUIdx) {\n    LSRUse &LU = Uses[LUIdx];\n\n    if (LU.Kind != LSRUse::Address)\n      continue;\n    if (!TTI.isIndexedLoadLegal(TTI.MIM_PostInc, LU.AccessTy.getType()) &&\n        !TTI.isIndexedStoreLegal(TTI.MIM_PostInc, LU.AccessTy.getType()))\n      continue;\n\n    size_t MinRegs = std::numeric_limits<size_t>::max();\n    for (const Formula &F : LU.Formulae)\n      MinRegs = std::min(F.getNumRegs(), MinRegs);\n\n    bool Any = false;\n    for (size_t FIdx = 0, NumForms = LU.Formulae.size(); FIdx != NumForms;\n         ++FIdx) {\n      Formula &F = LU.Formulae[FIdx];\n      if (F.getNumRegs() > MinRegs) {\n        LLVM_DEBUG(dbgs() << \"  Filtering out formula \"; F.print(dbgs());\n                   dbgs() << \"\\n\");\n        LU.DeleteFormula(F);\n        --FIdx;\n        --NumForms;\n        Any = true;\n      }\n    }\n    if (Any)\n      LU.RecomputeRegs(LUIdx, RegUses);\n\n    if (EstimateSearchSpaceComplexity() < ComplexityLimit)\n      break;\n  }\n\n  LLVM_DEBUG(dbgs() << \"After pre-selection:\\n\"; print_uses(dbgs()));\n}\n\n/// The function delete formulas with high registers number expectation.\n/// Assuming we don't know the value of each formula (already delete\n/// all inefficient), generate probability of not selecting for each\n/// register.\n/// For example,\n/// Use1:\n///  reg(a) + reg({0,+,1})\n///  reg(a) + reg({-1,+,1}) + 1\n///  reg({a,+,1})\n/// Use2:\n///  reg(b) + reg({0,+,1})\n///  reg(b) + reg({-1,+,1}) + 1\n///  reg({b,+,1})\n/// Use3:\n///  reg(c) + reg(b) + reg({0,+,1})\n///  reg(c) + reg({b,+,1})\n///\n/// Probability of not selecting\n///                 Use1   Use2    Use3\n/// reg(a)         (1/3) *   1   *   1\n/// reg(b)           1   * (1/3) * (1/2)\n/// reg({0,+,1})   (2/3) * (2/3) * (1/2)\n/// reg({-1,+,1})  (2/3) * (2/3) *   1\n/// reg({a,+,1})   (2/3) *   1   *   1\n/// reg({b,+,1})     1   * (2/3) * (2/3)\n/// reg(c)           1   *   1   *   0\n///\n/// Now count registers number mathematical expectation for each formula:\n/// Note that for each use we exclude probability if not selecting for the use.\n/// For example for Use1 probability for reg(a) would be just 1 * 1 (excluding\n/// probabilty 1/3 of not selecting for Use1).\n/// Use1:\n///  reg(a) + reg({0,+,1})          1 + 1/3       -- to be deleted\n///  reg(a) + reg({-1,+,1}) + 1     1 + 4/9       -- to be deleted\n///  reg({a,+,1})                   1\n/// Use2:\n///  reg(b) + reg({0,+,1})          1/2 + 1/3     -- to be deleted\n///  reg(b) + reg({-1,+,1}) + 1     1/2 + 2/3     -- to be deleted\n///  reg({b,+,1})                   2/3\n/// Use3:\n///  reg(c) + reg(b) + reg({0,+,1}) 1 + 1/3 + 4/9 -- to be deleted\n///  reg(c) + reg({b,+,1})          1 + 2/3\nvoid LSRInstance::NarrowSearchSpaceByDeletingCostlyFormulas() {\n  if (EstimateSearchSpaceComplexity() < ComplexityLimit)\n    return;\n  // Ok, we have too many of formulae on our hands to conveniently handle.\n  // Use a rough heuristic to thin out the list.\n\n  // Set of Regs wich will be 100% used in final solution.\n  // Used in each formula of a solution (in example above this is reg(c)).\n  // We can skip them in calculations.\n  SmallPtrSet<const SCEV *, 4> UniqRegs;\n  LLVM_DEBUG(dbgs() << \"The search space is too complex.\\n\");\n\n  // Map each register to probability of not selecting\n  DenseMap <const SCEV *, float> RegNumMap;\n  for (const SCEV *Reg : RegUses) {\n    if (UniqRegs.count(Reg))\n      continue;\n    float PNotSel = 1;\n    for (const LSRUse &LU : Uses) {\n      if (!LU.Regs.count(Reg))\n        continue;\n      float P = LU.getNotSelectedProbability(Reg);\n      if (P != 0.0)\n        PNotSel *= P;\n      else\n        UniqRegs.insert(Reg);\n    }\n    RegNumMap.insert(std::make_pair(Reg, PNotSel));\n  }\n\n  LLVM_DEBUG(\n      dbgs() << \"Narrowing the search space by deleting costly formulas\\n\");\n\n  // Delete formulas where registers number expectation is high.\n  for (size_t LUIdx = 0, NumUses = Uses.size(); LUIdx != NumUses; ++LUIdx) {\n    LSRUse &LU = Uses[LUIdx];\n    // If nothing to delete - continue.\n    if (LU.Formulae.size() < 2)\n      continue;\n    // This is temporary solution to test performance. Float should be\n    // replaced with round independent type (based on integers) to avoid\n    // different results for different target builds.\n    float FMinRegNum = LU.Formulae[0].getNumRegs();\n    float FMinARegNum = LU.Formulae[0].getNumRegs();\n    size_t MinIdx = 0;\n    for (size_t i = 0, e = LU.Formulae.size(); i != e; ++i) {\n      Formula &F = LU.Formulae[i];\n      float FRegNum = 0;\n      float FARegNum = 0;\n      for (const SCEV *BaseReg : F.BaseRegs) {\n        if (UniqRegs.count(BaseReg))\n          continue;\n        FRegNum += RegNumMap[BaseReg] / LU.getNotSelectedProbability(BaseReg);\n        if (isa<SCEVAddRecExpr>(BaseReg))\n          FARegNum +=\n              RegNumMap[BaseReg] / LU.getNotSelectedProbability(BaseReg);\n      }\n      if (const SCEV *ScaledReg = F.ScaledReg) {\n        if (!UniqRegs.count(ScaledReg)) {\n          FRegNum +=\n              RegNumMap[ScaledReg] / LU.getNotSelectedProbability(ScaledReg);\n          if (isa<SCEVAddRecExpr>(ScaledReg))\n            FARegNum +=\n                RegNumMap[ScaledReg] / LU.getNotSelectedProbability(ScaledReg);\n        }\n      }\n      if (FMinRegNum > FRegNum ||\n          (FMinRegNum == FRegNum && FMinARegNum > FARegNum)) {\n        FMinRegNum = FRegNum;\n        FMinARegNum = FARegNum;\n        MinIdx = i;\n      }\n    }\n    LLVM_DEBUG(dbgs() << \"  The formula \"; LU.Formulae[MinIdx].print(dbgs());\n               dbgs() << \" with min reg num \" << FMinRegNum << '\\n');\n    if (MinIdx != 0)\n      std::swap(LU.Formulae[MinIdx], LU.Formulae[0]);\n    while (LU.Formulae.size() != 1) {\n      LLVM_DEBUG(dbgs() << \"  Deleting \"; LU.Formulae.back().print(dbgs());\n                 dbgs() << '\\n');\n      LU.Formulae.pop_back();\n    }\n    LU.RecomputeRegs(LUIdx, RegUses);\n    assert(LU.Formulae.size() == 1 && \"Should be exactly 1 min regs formula\");\n    Formula &F = LU.Formulae[0];\n    LLVM_DEBUG(dbgs() << \"  Leaving only \"; F.print(dbgs()); dbgs() << '\\n');\n    // When we choose the formula, the regs become unique.\n    UniqRegs.insert(F.BaseRegs.begin(), F.BaseRegs.end());\n    if (F.ScaledReg)\n      UniqRegs.insert(F.ScaledReg);\n  }\n  LLVM_DEBUG(dbgs() << \"After pre-selection:\\n\"; print_uses(dbgs()));\n}\n\n/// Pick a register which seems likely to be profitable, and then in any use\n/// which has any reference to that register, delete all formulae which do not\n/// reference that register.\nvoid LSRInstance::NarrowSearchSpaceByPickingWinnerRegs() {\n  // With all other options exhausted, loop until the system is simple\n  // enough to handle.\n  SmallPtrSet<const SCEV *, 4> Taken;\n  while (EstimateSearchSpaceComplexity() >= ComplexityLimit) {\n    // Ok, we have too many of formulae on our hands to conveniently handle.\n    // Use a rough heuristic to thin out the list.\n    LLVM_DEBUG(dbgs() << \"The search space is too complex.\\n\");\n\n    // Pick the register which is used by the most LSRUses, which is likely\n    // to be a good reuse register candidate.\n    const SCEV *Best = nullptr;\n    unsigned BestNum = 0;\n    for (const SCEV *Reg : RegUses) {\n      if (Taken.count(Reg))\n        continue;\n      if (!Best) {\n        Best = Reg;\n        BestNum = RegUses.getUsedByIndices(Reg).count();\n      } else {\n        unsigned Count = RegUses.getUsedByIndices(Reg).count();\n        if (Count > BestNum) {\n          Best = Reg;\n          BestNum = Count;\n        }\n      }\n    }\n    assert(Best && \"Failed to find best LSRUse candidate\");\n\n    LLVM_DEBUG(dbgs() << \"Narrowing the search space by assuming \" << *Best\n                      << \" will yield profitable reuse.\\n\");\n    Taken.insert(Best);\n\n    // In any use with formulae which references this register, delete formulae\n    // which don't reference it.\n    for (size_t LUIdx = 0, NumUses = Uses.size(); LUIdx != NumUses; ++LUIdx) {\n      LSRUse &LU = Uses[LUIdx];\n      if (!LU.Regs.count(Best)) continue;\n\n      bool Any = false;\n      for (size_t i = 0, e = LU.Formulae.size(); i != e; ++i) {\n        Formula &F = LU.Formulae[i];\n        if (!F.referencesReg(Best)) {\n          LLVM_DEBUG(dbgs() << \"  Deleting \"; F.print(dbgs()); dbgs() << '\\n');\n          LU.DeleteFormula(F);\n          --e;\n          --i;\n          Any = true;\n          assert(e != 0 && \"Use has no formulae left! Is Regs inconsistent?\");\n          continue;\n        }\n      }\n\n      if (Any)\n        LU.RecomputeRegs(LUIdx, RegUses);\n    }\n\n    LLVM_DEBUG(dbgs() << \"After pre-selection:\\n\"; print_uses(dbgs()));\n  }\n}\n\n/// If there are an extraordinary number of formulae to choose from, use some\n/// rough heuristics to prune down the number of formulae. This keeps the main\n/// solver from taking an extraordinary amount of time in some worst-case\n/// scenarios.\nvoid LSRInstance::NarrowSearchSpaceUsingHeuristics() {\n  NarrowSearchSpaceByDetectingSupersets();\n  NarrowSearchSpaceByCollapsingUnrolledCode();\n  NarrowSearchSpaceByRefilteringUndesirableDedicatedRegisters();\n  if (FilterSameScaledReg)\n    NarrowSearchSpaceByFilterFormulaWithSameScaledReg();\n  NarrowSearchSpaceByFilterPostInc();\n  if (LSRExpNarrow)\n    NarrowSearchSpaceByDeletingCostlyFormulas();\n  else\n    NarrowSearchSpaceByPickingWinnerRegs();\n}\n\n/// This is the recursive solver.\nvoid LSRInstance::SolveRecurse(SmallVectorImpl<const Formula *> &Solution,\n                               Cost &SolutionCost,\n                               SmallVectorImpl<const Formula *> &Workspace,\n                               const Cost &CurCost,\n                               const SmallPtrSet<const SCEV *, 16> &CurRegs,\n                               DenseSet<const SCEV *> &VisitedRegs) const {\n  // Some ideas:\n  //  - prune more:\n  //    - use more aggressive filtering\n  //    - sort the formula so that the most profitable solutions are found first\n  //    - sort the uses too\n  //  - search faster:\n  //    - don't compute a cost, and then compare. compare while computing a cost\n  //      and bail early.\n  //    - track register sets with SmallBitVector\n\n  const LSRUse &LU = Uses[Workspace.size()];\n\n  // If this use references any register that's already a part of the\n  // in-progress solution, consider it a requirement that a formula must\n  // reference that register in order to be considered. This prunes out\n  // unprofitable searching.\n  SmallSetVector<const SCEV *, 4> ReqRegs;\n  for (const SCEV *S : CurRegs)\n    if (LU.Regs.count(S))\n      ReqRegs.insert(S);\n\n  SmallPtrSet<const SCEV *, 16> NewRegs;\n  Cost NewCost(L, SE, TTI, AMK);\n  for (const Formula &F : LU.Formulae) {\n    // Ignore formulae which may not be ideal in terms of register reuse of\n    // ReqRegs.  The formula should use all required registers before\n    // introducing new ones.\n    // This can sometimes (notably when trying to favour postinc) lead to\n    // sub-optimial decisions. There it is best left to the cost modelling to\n    // get correct.\n    if (AMK != TTI::AMK_PostIndexed || LU.Kind != LSRUse::Address) {\n      int NumReqRegsToFind = std::min(F.getNumRegs(), ReqRegs.size());\n      for (const SCEV *Reg : ReqRegs) {\n        if ((F.ScaledReg && F.ScaledReg == Reg) ||\n            is_contained(F.BaseRegs, Reg)) {\n          --NumReqRegsToFind;\n          if (NumReqRegsToFind == 0)\n            break;\n        }\n      }\n      if (NumReqRegsToFind != 0) {\n        // If none of the formulae satisfied the required registers, then we could\n        // clear ReqRegs and try again. Currently, we simply give up in this case.\n        continue;\n      }\n    }\n\n    // Evaluate the cost of the current formula. If it's already worse than\n    // the current best, prune the search at that point.\n    NewCost = CurCost;\n    NewRegs = CurRegs;\n    NewCost.RateFormula(F, NewRegs, VisitedRegs, LU);\n    if (NewCost.isLess(SolutionCost)) {\n      Workspace.push_back(&F);\n      if (Workspace.size() != Uses.size()) {\n        SolveRecurse(Solution, SolutionCost, Workspace, NewCost,\n                     NewRegs, VisitedRegs);\n        if (F.getNumRegs() == 1 && Workspace.size() == 1)\n          VisitedRegs.insert(F.ScaledReg ? F.ScaledReg : F.BaseRegs[0]);\n      } else {\n        LLVM_DEBUG(dbgs() << \"New best at \"; NewCost.print(dbgs());\n                   dbgs() << \".\\nRegs:\\n\";\n                   for (const SCEV *S : NewRegs) dbgs()\n                      << \"- \" << *S << \"\\n\";\n                   dbgs() << '\\n');\n\n        SolutionCost = NewCost;\n        Solution = Workspace;\n      }\n      Workspace.pop_back();\n    }\n  }\n}\n\n/// Choose one formula from each use. Return the results in the given Solution\n/// vector.\nvoid LSRInstance::Solve(SmallVectorImpl<const Formula *> &Solution) const {\n  SmallVector<const Formula *, 8> Workspace;\n  Cost SolutionCost(L, SE, TTI, AMK);\n  SolutionCost.Lose();\n  Cost CurCost(L, SE, TTI, AMK);\n  SmallPtrSet<const SCEV *, 16> CurRegs;\n  DenseSet<const SCEV *> VisitedRegs;\n  Workspace.reserve(Uses.size());\n\n  // SolveRecurse does all the work.\n  SolveRecurse(Solution, SolutionCost, Workspace, CurCost,\n               CurRegs, VisitedRegs);\n  if (Solution.empty()) {\n    LLVM_DEBUG(dbgs() << \"\\nNo Satisfactory Solution\\n\");\n    return;\n  }\n\n  // Ok, we've now made all our decisions.\n  LLVM_DEBUG(dbgs() << \"\\n\"\n                       \"The chosen solution requires \";\n             SolutionCost.print(dbgs()); dbgs() << \":\\n\";\n             for (size_t i = 0, e = Uses.size(); i != e; ++i) {\n               dbgs() << \"  \";\n               Uses[i].print(dbgs());\n               dbgs() << \"\\n\"\n                         \"    \";\n               Solution[i]->print(dbgs());\n               dbgs() << '\\n';\n             });\n\n  assert(Solution.size() == Uses.size() && \"Malformed solution!\");\n}\n\n/// Helper for AdjustInsertPositionForExpand. Climb up the dominator tree far as\n/// we can go while still being dominated by the input positions. This helps\n/// canonicalize the insert position, which encourages sharing.\nBasicBlock::iterator\nLSRInstance::HoistInsertPosition(BasicBlock::iterator IP,\n                                 const SmallVectorImpl<Instruction *> &Inputs)\n                                                                         const {\n  Instruction *Tentative = &*IP;\n  while (true) {\n    bool AllDominate = true;\n    Instruction *BetterPos = nullptr;\n    // Don't bother attempting to insert before a catchswitch, their basic block\n    // cannot have other non-PHI instructions.\n    if (isa<CatchSwitchInst>(Tentative))\n      return IP;\n\n    for (Instruction *Inst : Inputs) {\n      if (Inst == Tentative || !DT.dominates(Inst, Tentative)) {\n        AllDominate = false;\n        break;\n      }\n      // Attempt to find an insert position in the middle of the block,\n      // instead of at the end, so that it can be used for other expansions.\n      if (Tentative->getParent() == Inst->getParent() &&\n          (!BetterPos || !DT.dominates(Inst, BetterPos)))\n        BetterPos = &*std::next(BasicBlock::iterator(Inst));\n    }\n    if (!AllDominate)\n      break;\n    if (BetterPos)\n      IP = BetterPos->getIterator();\n    else\n      IP = Tentative->getIterator();\n\n    const Loop *IPLoop = LI.getLoopFor(IP->getParent());\n    unsigned IPLoopDepth = IPLoop ? IPLoop->getLoopDepth() : 0;\n\n    BasicBlock *IDom;\n    for (DomTreeNode *Rung = DT.getNode(IP->getParent()); ; ) {\n      if (!Rung) return IP;\n      Rung = Rung->getIDom();\n      if (!Rung) return IP;\n      IDom = Rung->getBlock();\n\n      // Don't climb into a loop though.\n      const Loop *IDomLoop = LI.getLoopFor(IDom);\n      unsigned IDomDepth = IDomLoop ? IDomLoop->getLoopDepth() : 0;\n      if (IDomDepth <= IPLoopDepth &&\n          (IDomDepth != IPLoopDepth || IDomLoop == IPLoop))\n        break;\n    }\n\n    Tentative = IDom->getTerminator();\n  }\n\n  return IP;\n}\n\n/// Determine an input position which will be dominated by the operands and\n/// which will dominate the result.\nBasicBlock::iterator\nLSRInstance::AdjustInsertPositionForExpand(BasicBlock::iterator LowestIP,\n                                           const LSRFixup &LF,\n                                           const LSRUse &LU,\n                                           SCEVExpander &Rewriter) const {\n  // Collect some instructions which must be dominated by the\n  // expanding replacement. These must be dominated by any operands that\n  // will be required in the expansion.\n  SmallVector<Instruction *, 4> Inputs;\n  if (Instruction *I = dyn_cast<Instruction>(LF.OperandValToReplace))\n    Inputs.push_back(I);\n  if (LU.Kind == LSRUse::ICmpZero)\n    if (Instruction *I =\n          dyn_cast<Instruction>(cast<ICmpInst>(LF.UserInst)->getOperand(1)))\n      Inputs.push_back(I);\n  if (LF.PostIncLoops.count(L)) {\n    if (LF.isUseFullyOutsideLoop(L))\n      Inputs.push_back(L->getLoopLatch()->getTerminator());\n    else\n      Inputs.push_back(IVIncInsertPos);\n  }\n  // The expansion must also be dominated by the increment positions of any\n  // loops it for which it is using post-inc mode.\n  for (const Loop *PIL : LF.PostIncLoops) {\n    if (PIL == L) continue;\n\n    // Be dominated by the loop exit.\n    SmallVector<BasicBlock *, 4> ExitingBlocks;\n    PIL->getExitingBlocks(ExitingBlocks);\n    if (!ExitingBlocks.empty()) {\n      BasicBlock *BB = ExitingBlocks[0];\n      for (unsigned i = 1, e = ExitingBlocks.size(); i != e; ++i)\n        BB = DT.findNearestCommonDominator(BB, ExitingBlocks[i]);\n      Inputs.push_back(BB->getTerminator());\n    }\n  }\n\n  assert(!isa<PHINode>(LowestIP) && !LowestIP->isEHPad()\n         && !isa<DbgInfoIntrinsic>(LowestIP) &&\n         \"Insertion point must be a normal instruction\");\n\n  // Then, climb up the immediate dominator tree as far as we can go while\n  // still being dominated by the input positions.\n  BasicBlock::iterator IP = HoistInsertPosition(LowestIP, Inputs);\n\n  // Don't insert instructions before PHI nodes.\n  while (isa<PHINode>(IP)) ++IP;\n\n  // Ignore landingpad instructions.\n  while (IP->isEHPad()) ++IP;\n\n  // Ignore debug intrinsics.\n  while (isa<DbgInfoIntrinsic>(IP)) ++IP;\n\n  // Set IP below instructions recently inserted by SCEVExpander. This keeps the\n  // IP consistent across expansions and allows the previously inserted\n  // instructions to be reused by subsequent expansion.\n  while (Rewriter.isInsertedInstruction(&*IP) && IP != LowestIP)\n    ++IP;\n\n  return IP;\n}\n\n/// Emit instructions for the leading candidate expression for this LSRUse (this\n/// is called \"expanding\").\nValue *LSRInstance::Expand(const LSRUse &LU, const LSRFixup &LF,\n                           const Formula &F, BasicBlock::iterator IP,\n                           SCEVExpander &Rewriter,\n                           SmallVectorImpl<WeakTrackingVH> &DeadInsts) const {\n  if (LU.RigidFormula)\n    return LF.OperandValToReplace;\n\n  // Determine an input position which will be dominated by the operands and\n  // which will dominate the result.\n  IP = AdjustInsertPositionForExpand(IP, LF, LU, Rewriter);\n  Rewriter.setInsertPoint(&*IP);\n\n  // Inform the Rewriter if we have a post-increment use, so that it can\n  // perform an advantageous expansion.\n  Rewriter.setPostInc(LF.PostIncLoops);\n\n  // This is the type that the user actually needs.\n  Type *OpTy = LF.OperandValToReplace->getType();\n  // This will be the type that we'll initially expand to.\n  Type *Ty = F.getType();\n  if (!Ty)\n    // No type known; just expand directly to the ultimate type.\n    Ty = OpTy;\n  else if (SE.getEffectiveSCEVType(Ty) == SE.getEffectiveSCEVType(OpTy))\n    // Expand directly to the ultimate type if it's the right size.\n    Ty = OpTy;\n  // This is the type to do integer arithmetic in.\n  Type *IntTy = SE.getEffectiveSCEVType(Ty);\n\n  // Build up a list of operands to add together to form the full base.\n  SmallVector<const SCEV *, 8> Ops;\n\n  // Expand the BaseRegs portion.\n  for (const SCEV *Reg : F.BaseRegs) {\n    assert(!Reg->isZero() && \"Zero allocated in a base register!\");\n\n    // If we're expanding for a post-inc user, make the post-inc adjustment.\n    Reg = denormalizeForPostIncUse(Reg, LF.PostIncLoops, SE);\n    Ops.push_back(SE.getUnknown(Rewriter.expandCodeFor(Reg, nullptr)));\n  }\n\n  // Expand the ScaledReg portion.\n  Value *ICmpScaledV = nullptr;\n  if (F.Scale != 0) {\n    const SCEV *ScaledS = F.ScaledReg;\n\n    // If we're expanding for a post-inc user, make the post-inc adjustment.\n    PostIncLoopSet &Loops = const_cast<PostIncLoopSet &>(LF.PostIncLoops);\n    ScaledS = denormalizeForPostIncUse(ScaledS, Loops, SE);\n\n    if (LU.Kind == LSRUse::ICmpZero) {\n      // Expand ScaleReg as if it was part of the base regs.\n      if (F.Scale == 1)\n        Ops.push_back(\n            SE.getUnknown(Rewriter.expandCodeFor(ScaledS, nullptr)));\n      else {\n        // An interesting way of \"folding\" with an icmp is to use a negated\n        // scale, which we'll implement by inserting it into the other operand\n        // of the icmp.\n        assert(F.Scale == -1 &&\n               \"The only scale supported by ICmpZero uses is -1!\");\n        ICmpScaledV = Rewriter.expandCodeFor(ScaledS, nullptr);\n      }\n    } else {\n      // Otherwise just expand the scaled register and an explicit scale,\n      // which is expected to be matched as part of the address.\n\n      // Flush the operand list to suppress SCEVExpander hoisting address modes.\n      // Unless the addressing mode will not be folded.\n      if (!Ops.empty() && LU.Kind == LSRUse::Address &&\n          isAMCompletelyFolded(TTI, LU, F)) {\n        Value *FullV = Rewriter.expandCodeFor(SE.getAddExpr(Ops), nullptr);\n        Ops.clear();\n        Ops.push_back(SE.getUnknown(FullV));\n      }\n      ScaledS = SE.getUnknown(Rewriter.expandCodeFor(ScaledS, nullptr));\n      if (F.Scale != 1)\n        ScaledS =\n            SE.getMulExpr(ScaledS, SE.getConstant(ScaledS->getType(), F.Scale));\n      Ops.push_back(ScaledS);\n    }\n  }\n\n  // Expand the GV portion.\n  if (F.BaseGV) {\n    // Flush the operand list to suppress SCEVExpander hoisting.\n    if (!Ops.empty()) {\n      Value *FullV = Rewriter.expandCodeFor(SE.getAddExpr(Ops), Ty);\n      Ops.clear();\n      Ops.push_back(SE.getUnknown(FullV));\n    }\n    Ops.push_back(SE.getUnknown(F.BaseGV));\n  }\n\n  // Flush the operand list to suppress SCEVExpander hoisting of both folded and\n  // unfolded offsets. LSR assumes they both live next to their uses.\n  if (!Ops.empty()) {\n    Value *FullV = Rewriter.expandCodeFor(SE.getAddExpr(Ops), Ty);\n    Ops.clear();\n    Ops.push_back(SE.getUnknown(FullV));\n  }\n\n  // Expand the immediate portion.\n  int64_t Offset = (uint64_t)F.BaseOffset + LF.Offset;\n  if (Offset != 0) {\n    if (LU.Kind == LSRUse::ICmpZero) {\n      // The other interesting way of \"folding\" with an ICmpZero is to use a\n      // negated immediate.\n      if (!ICmpScaledV)\n        ICmpScaledV = ConstantInt::get(IntTy, -(uint64_t)Offset);\n      else {\n        Ops.push_back(SE.getUnknown(ICmpScaledV));\n        ICmpScaledV = ConstantInt::get(IntTy, Offset);\n      }\n    } else {\n      // Just add the immediate values. These again are expected to be matched\n      // as part of the address.\n      Ops.push_back(SE.getUnknown(ConstantInt::getSigned(IntTy, Offset)));\n    }\n  }\n\n  // Expand the unfolded offset portion.\n  int64_t UnfoldedOffset = F.UnfoldedOffset;\n  if (UnfoldedOffset != 0) {\n    // Just add the immediate values.\n    Ops.push_back(SE.getUnknown(ConstantInt::getSigned(IntTy,\n                                                       UnfoldedOffset)));\n  }\n\n  // Emit instructions summing all the operands.\n  const SCEV *FullS = Ops.empty() ?\n                      SE.getConstant(IntTy, 0) :\n                      SE.getAddExpr(Ops);\n  Value *FullV = Rewriter.expandCodeFor(FullS, Ty);\n\n  // We're done expanding now, so reset the rewriter.\n  Rewriter.clearPostInc();\n\n  // An ICmpZero Formula represents an ICmp which we're handling as a\n  // comparison against zero. Now that we've expanded an expression for that\n  // form, update the ICmp's other operand.\n  if (LU.Kind == LSRUse::ICmpZero) {\n    ICmpInst *CI = cast<ICmpInst>(LF.UserInst);\n    if (auto *OperandIsInstr = dyn_cast<Instruction>(CI->getOperand(1)))\n      DeadInsts.emplace_back(OperandIsInstr);\n    assert(!F.BaseGV && \"ICmp does not support folding a global value and \"\n                           \"a scale at the same time!\");\n    if (F.Scale == -1) {\n      if (ICmpScaledV->getType() != OpTy) {\n        Instruction *Cast =\n          CastInst::Create(CastInst::getCastOpcode(ICmpScaledV, false,\n                                                   OpTy, false),\n                           ICmpScaledV, OpTy, \"tmp\", CI);\n        ICmpScaledV = Cast;\n      }\n      CI->setOperand(1, ICmpScaledV);\n    } else {\n      // A scale of 1 means that the scale has been expanded as part of the\n      // base regs.\n      assert((F.Scale == 0 || F.Scale == 1) &&\n             \"ICmp does not support folding a global value and \"\n             \"a scale at the same time!\");\n      Constant *C = ConstantInt::getSigned(SE.getEffectiveSCEVType(OpTy),\n                                           -(uint64_t)Offset);\n      if (C->getType() != OpTy)\n        C = ConstantExpr::getCast(CastInst::getCastOpcode(C, false,\n                                                          OpTy, false),\n                                  C, OpTy);\n\n      CI->setOperand(1, C);\n    }\n  }\n\n  return FullV;\n}\n\n/// Helper for Rewrite. PHI nodes are special because the use of their operands\n/// effectively happens in their predecessor blocks, so the expression may need\n/// to be expanded in multiple places.\nvoid LSRInstance::RewriteForPHI(\n    PHINode *PN, const LSRUse &LU, const LSRFixup &LF, const Formula &F,\n    SCEVExpander &Rewriter, SmallVectorImpl<WeakTrackingVH> &DeadInsts) const {\n  DenseMap<BasicBlock *, Value *> Inserted;\n  for (unsigned i = 0, e = PN->getNumIncomingValues(); i != e; ++i)\n    if (PN->getIncomingValue(i) == LF.OperandValToReplace) {\n      bool needUpdateFixups = false;\n      BasicBlock *BB = PN->getIncomingBlock(i);\n\n      // If this is a critical edge, split the edge so that we do not insert\n      // the code on all predecessor/successor paths.  We do this unless this\n      // is the canonical backedge for this loop, which complicates post-inc\n      // users.\n      if (e != 1 && BB->getTerminator()->getNumSuccessors() > 1 &&\n          !isa<IndirectBrInst>(BB->getTerminator()) &&\n          !isa<CatchSwitchInst>(BB->getTerminator())) {\n        BasicBlock *Parent = PN->getParent();\n        Loop *PNLoop = LI.getLoopFor(Parent);\n        if (!PNLoop || Parent != PNLoop->getHeader()) {\n          // Split the critical edge.\n          BasicBlock *NewBB = nullptr;\n          if (!Parent->isLandingPad()) {\n            NewBB =\n                SplitCriticalEdge(BB, Parent,\n                                  CriticalEdgeSplittingOptions(&DT, &LI, MSSAU)\n                                      .setMergeIdenticalEdges()\n                                      .setKeepOneInputPHIs());\n          } else {\n            SmallVector<BasicBlock*, 2> NewBBs;\n            SplitLandingPadPredecessors(Parent, BB, \"\", \"\", NewBBs, &DT, &LI);\n            NewBB = NewBBs[0];\n          }\n          // If NewBB==NULL, then SplitCriticalEdge refused to split because all\n          // phi predecessors are identical. The simple thing to do is skip\n          // splitting in this case rather than complicate the API.\n          if (NewBB) {\n            // If PN is outside of the loop and BB is in the loop, we want to\n            // move the block to be immediately before the PHI block, not\n            // immediately after BB.\n            if (L->contains(BB) && !L->contains(PN))\n              NewBB->moveBefore(PN->getParent());\n\n            // Splitting the edge can reduce the number of PHI entries we have.\n            e = PN->getNumIncomingValues();\n            BB = NewBB;\n            i = PN->getBasicBlockIndex(BB);\n\n            needUpdateFixups = true;\n          }\n        }\n      }\n\n      std::pair<DenseMap<BasicBlock *, Value *>::iterator, bool> Pair =\n        Inserted.insert(std::make_pair(BB, static_cast<Value *>(nullptr)));\n      if (!Pair.second)\n        PN->setIncomingValue(i, Pair.first->second);\n      else {\n        Value *FullV = Expand(LU, LF, F, BB->getTerminator()->getIterator(),\n                              Rewriter, DeadInsts);\n\n        // If this is reuse-by-noop-cast, insert the noop cast.\n        Type *OpTy = LF.OperandValToReplace->getType();\n        if (FullV->getType() != OpTy)\n          FullV =\n            CastInst::Create(CastInst::getCastOpcode(FullV, false,\n                                                     OpTy, false),\n                             FullV, LF.OperandValToReplace->getType(),\n                             \"tmp\", BB->getTerminator());\n\n        PN->setIncomingValue(i, FullV);\n        Pair.first->second = FullV;\n      }\n\n      // If LSR splits critical edge and phi node has other pending\n      // fixup operands, we need to update those pending fixups. Otherwise\n      // formulae will not be implemented completely and some instructions\n      // will not be eliminated.\n      if (needUpdateFixups) {\n        for (size_t LUIdx = 0, NumUses = Uses.size(); LUIdx != NumUses; ++LUIdx)\n          for (LSRFixup &Fixup : Uses[LUIdx].Fixups)\n            // If fixup is supposed to rewrite some operand in the phi\n            // that was just updated, it may be already moved to\n            // another phi node. Such fixup requires update.\n            if (Fixup.UserInst == PN) {\n              // Check if the operand we try to replace still exists in the\n              // original phi.\n              bool foundInOriginalPHI = false;\n              for (const auto &val : PN->incoming_values())\n                if (val == Fixup.OperandValToReplace) {\n                  foundInOriginalPHI = true;\n                  break;\n                }\n\n              // If fixup operand found in original PHI - nothing to do.\n              if (foundInOriginalPHI)\n                continue;\n\n              // Otherwise it might be moved to another PHI and requires update.\n              // If fixup operand not found in any of the incoming blocks that\n              // means we have already rewritten it - nothing to do.\n              for (const auto &Block : PN->blocks())\n                for (BasicBlock::iterator I = Block->begin(); isa<PHINode>(I);\n                     ++I) {\n                  PHINode *NewPN = cast<PHINode>(I);\n                  for (const auto &val : NewPN->incoming_values())\n                    if (val == Fixup.OperandValToReplace)\n                      Fixup.UserInst = NewPN;\n                }\n            }\n      }\n    }\n}\n\n/// Emit instructions for the leading candidate expression for this LSRUse (this\n/// is called \"expanding\"), and update the UserInst to reference the newly\n/// expanded value.\nvoid LSRInstance::Rewrite(const LSRUse &LU, const LSRFixup &LF,\n                          const Formula &F, SCEVExpander &Rewriter,\n                          SmallVectorImpl<WeakTrackingVH> &DeadInsts) const {\n  // First, find an insertion point that dominates UserInst. For PHI nodes,\n  // find the nearest block which dominates all the relevant uses.\n  if (PHINode *PN = dyn_cast<PHINode>(LF.UserInst)) {\n    RewriteForPHI(PN, LU, LF, F, Rewriter, DeadInsts);\n  } else {\n    Value *FullV =\n      Expand(LU, LF, F, LF.UserInst->getIterator(), Rewriter, DeadInsts);\n\n    // If this is reuse-by-noop-cast, insert the noop cast.\n    Type *OpTy = LF.OperandValToReplace->getType();\n    if (FullV->getType() != OpTy) {\n      Instruction *Cast =\n        CastInst::Create(CastInst::getCastOpcode(FullV, false, OpTy, false),\n                         FullV, OpTy, \"tmp\", LF.UserInst);\n      FullV = Cast;\n    }\n\n    // Update the user. ICmpZero is handled specially here (for now) because\n    // Expand may have updated one of the operands of the icmp already, and\n    // its new value may happen to be equal to LF.OperandValToReplace, in\n    // which case doing replaceUsesOfWith leads to replacing both operands\n    // with the same value. TODO: Reorganize this.\n    if (LU.Kind == LSRUse::ICmpZero)\n      LF.UserInst->setOperand(0, FullV);\n    else\n      LF.UserInst->replaceUsesOfWith(LF.OperandValToReplace, FullV);\n  }\n\n  if (auto *OperandIsInstr = dyn_cast<Instruction>(LF.OperandValToReplace))\n    DeadInsts.emplace_back(OperandIsInstr);\n}\n\n/// Rewrite all the fixup locations with new values, following the chosen\n/// solution.\nvoid LSRInstance::ImplementSolution(\n    const SmallVectorImpl<const Formula *> &Solution) {\n  // Keep track of instructions we may have made dead, so that\n  // we can remove them after we are done working.\n  SmallVector<WeakTrackingVH, 16> DeadInsts;\n\n  SCEVExpander Rewriter(SE, L->getHeader()->getModule()->getDataLayout(), \"lsr\",\n                        false);\n#ifndef NDEBUG\n  Rewriter.setDebugType(DEBUG_TYPE);\n#endif\n  Rewriter.disableCanonicalMode();\n  Rewriter.enableLSRMode();\n  Rewriter.setIVIncInsertPos(L, IVIncInsertPos);\n\n  // Mark phi nodes that terminate chains so the expander tries to reuse them.\n  for (const IVChain &Chain : IVChainVec) {\n    if (PHINode *PN = dyn_cast<PHINode>(Chain.tailUserInst()))\n      Rewriter.setChainedPhi(PN);\n  }\n\n  // Expand the new value definitions and update the users.\n  for (size_t LUIdx = 0, NumUses = Uses.size(); LUIdx != NumUses; ++LUIdx)\n    for (const LSRFixup &Fixup : Uses[LUIdx].Fixups) {\n      Rewrite(Uses[LUIdx], Fixup, *Solution[LUIdx], Rewriter, DeadInsts);\n      Changed = true;\n    }\n\n  for (const IVChain &Chain : IVChainVec) {\n    GenerateIVChain(Chain, Rewriter, DeadInsts);\n    Changed = true;\n  }\n  // Clean up after ourselves. This must be done before deleting any\n  // instructions.\n  Rewriter.clear();\n\n  Changed |= RecursivelyDeleteTriviallyDeadInstructionsPermissive(DeadInsts,\n                                                                  &TLI, MSSAU);\n\n  // In our cost analysis above, we assume that each addrec consumes exactly\n  // one register, and arrange to have increments inserted just before the\n  // latch to maximimize the chance this is true.  However, if we reused\n  // existing IVs, we now need to move the increments to match our\n  // expectations.  Otherwise, our cost modeling results in us having a\n  // chosen a non-optimal result for the actual schedule.  (And yes, this\n  // scheduling decision does impact later codegen.)\n  for (PHINode &PN : L->getHeader()->phis()) {\n    BinaryOperator *BO = nullptr;\n    Value *Start = nullptr, *Step = nullptr;\n    if (!matchSimpleRecurrence(&PN, BO, Start, Step))\n      continue;\n\n    switch (BO->getOpcode()) {\n    case Instruction::Sub:\n      if (BO->getOperand(0) != &PN)\n        // sub is non-commutative - match handling elsewhere in LSR\n        continue;\n      break;\n    case Instruction::Add:\n      break;\n    default:\n      continue;\n    };\n\n    if (!isa<Constant>(Step))\n      // If not a constant step, might increase register pressure\n      // (We assume constants have been canonicalized to RHS)\n      continue;\n\n    if (BO->getParent() == IVIncInsertPos->getParent())\n      // Only bother moving across blocks.  Isel can handle block local case.\n      continue;\n\n    // Can we legally schedule inc at the desired point?\n    if (!llvm::all_of(BO->uses(),\n                      [&](Use &U) {return DT.dominates(IVIncInsertPos, U);}))\n      continue;\n    BO->moveBefore(IVIncInsertPos);\n    Changed = true;\n  }\n\n\n}\n\nLSRInstance::LSRInstance(Loop *L, IVUsers &IU, ScalarEvolution &SE,\n                         DominatorTree &DT, LoopInfo &LI,\n                         const TargetTransformInfo &TTI, AssumptionCache &AC,\n                         TargetLibraryInfo &TLI, MemorySSAUpdater *MSSAU)\n    : IU(IU), SE(SE), DT(DT), LI(LI), AC(AC), TLI(TLI), TTI(TTI), L(L),\n      MSSAU(MSSAU), AMK(PreferredAddresingMode.getNumOccurrences() > 0 ?\n        PreferredAddresingMode : TTI.getPreferredAddressingMode(L, &SE)) {\n  // If LoopSimplify form is not available, stay out of trouble.\n  if (!L->isLoopSimplifyForm())\n    return;\n\n  // If there's no interesting work to be done, bail early.\n  if (IU.empty()) return;\n\n  // If there's too much analysis to be done, bail early. We won't be able to\n  // model the problem anyway.\n  unsigned NumUsers = 0;\n  for (const IVStrideUse &U : IU) {\n    if (++NumUsers > MaxIVUsers) {\n      (void)U;\n      LLVM_DEBUG(dbgs() << \"LSR skipping loop, too many IV Users in \" << U\n                        << \"\\n\");\n      return;\n    }\n    // Bail out if we have a PHI on an EHPad that gets a value from a\n    // CatchSwitchInst.  Because the CatchSwitchInst cannot be split, there is\n    // no good place to stick any instructions.\n    if (auto *PN = dyn_cast<PHINode>(U.getUser())) {\n       auto *FirstNonPHI = PN->getParent()->getFirstNonPHI();\n       if (isa<FuncletPadInst>(FirstNonPHI) ||\n           isa<CatchSwitchInst>(FirstNonPHI))\n         for (BasicBlock *PredBB : PN->blocks())\n           if (isa<CatchSwitchInst>(PredBB->getFirstNonPHI()))\n             return;\n    }\n  }\n\n#ifndef NDEBUG\n  // All dominating loops must have preheaders, or SCEVExpander may not be able\n  // to materialize an AddRecExpr whose Start is an outer AddRecExpr.\n  //\n  // IVUsers analysis should only create users that are dominated by simple loop\n  // headers. Since this loop should dominate all of its users, its user list\n  // should be empty if this loop itself is not within a simple loop nest.\n  for (DomTreeNode *Rung = DT.getNode(L->getLoopPreheader());\n       Rung; Rung = Rung->getIDom()) {\n    BasicBlock *BB = Rung->getBlock();\n    const Loop *DomLoop = LI.getLoopFor(BB);\n    if (DomLoop && DomLoop->getHeader() == BB) {\n      assert(DomLoop->getLoopPreheader() && \"LSR needs a simplified loop nest\");\n    }\n  }\n#endif // DEBUG\n\n  LLVM_DEBUG(dbgs() << \"\\nLSR on loop \";\n             L->getHeader()->printAsOperand(dbgs(), /*PrintType=*/false);\n             dbgs() << \":\\n\");\n\n  // First, perform some low-level loop optimizations.\n  OptimizeShadowIV();\n  OptimizeLoopTermCond();\n\n  // If loop preparation eliminates all interesting IV users, bail.\n  if (IU.empty()) return;\n\n  // Skip nested loops until we can model them better with formulae.\n  if (!L->isInnermost()) {\n    LLVM_DEBUG(dbgs() << \"LSR skipping outer loop \" << *L << \"\\n\");\n    return;\n  }\n\n  // Start collecting data and preparing for the solver.\n  // If number of registers is not the major cost, we cannot benefit from the\n  // current profitable chain optimization which is based on number of\n  // registers.\n  // FIXME: add profitable chain optimization for other kinds major cost, for\n  // example number of instructions.\n  if (TTI.isNumRegsMajorCostOfLSR() || StressIVChain)\n    CollectChains();\n  CollectInterestingTypesAndFactors();\n  CollectFixupsAndInitialFormulae();\n  CollectLoopInvariantFixupsAndFormulae();\n\n  if (Uses.empty())\n    return;\n\n  LLVM_DEBUG(dbgs() << \"LSR found \" << Uses.size() << \" uses:\\n\";\n             print_uses(dbgs()));\n\n  // Now use the reuse data to generate a bunch of interesting ways\n  // to formulate the values needed for the uses.\n  GenerateAllReuseFormulae();\n\n  FilterOutUndesirableDedicatedRegisters();\n  NarrowSearchSpaceUsingHeuristics();\n\n  SmallVector<const Formula *, 8> Solution;\n  Solve(Solution);\n\n  // Release memory that is no longer needed.\n  Factors.clear();\n  Types.clear();\n  RegUses.clear();\n\n  if (Solution.empty())\n    return;\n\n#ifndef NDEBUG\n  // Formulae should be legal.\n  for (const LSRUse &LU : Uses) {\n    for (const Formula &F : LU.Formulae)\n      assert(isLegalUse(TTI, LU.MinOffset, LU.MaxOffset, LU.Kind, LU.AccessTy,\n                        F) && \"Illegal formula generated!\");\n  };\n#endif\n\n  // Now that we've decided what we want, make it so.\n  ImplementSolution(Solution);\n}\n\n#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)\nvoid LSRInstance::print_factors_and_types(raw_ostream &OS) const {\n  if (Factors.empty() && Types.empty()) return;\n\n  OS << \"LSR has identified the following interesting factors and types: \";\n  bool First = true;\n\n  for (int64_t Factor : Factors) {\n    if (!First) OS << \", \";\n    First = false;\n    OS << '*' << Factor;\n  }\n\n  for (Type *Ty : Types) {\n    if (!First) OS << \", \";\n    First = false;\n    OS << '(' << *Ty << ')';\n  }\n  OS << '\\n';\n}\n\nvoid LSRInstance::print_fixups(raw_ostream &OS) const {\n  OS << \"LSR is examining the following fixup sites:\\n\";\n  for (const LSRUse &LU : Uses)\n    for (const LSRFixup &LF : LU.Fixups) {\n      dbgs() << \"  \";\n      LF.print(OS);\n      OS << '\\n';\n    }\n}\n\nvoid LSRInstance::print_uses(raw_ostream &OS) const {\n  OS << \"LSR is examining the following uses:\\n\";\n  for (const LSRUse &LU : Uses) {\n    dbgs() << \"  \";\n    LU.print(OS);\n    OS << '\\n';\n    for (const Formula &F : LU.Formulae) {\n      OS << \"    \";\n      F.print(OS);\n      OS << '\\n';\n    }\n  }\n}\n\nvoid LSRInstance::print(raw_ostream &OS) const {\n  print_factors_and_types(OS);\n  print_fixups(OS);\n  print_uses(OS);\n}\n\nLLVM_DUMP_METHOD void LSRInstance::dump() const {\n  print(errs()); errs() << '\\n';\n}\n#endif\n\nnamespace {\n\nclass LoopStrengthReduce : public LoopPass {\npublic:\n  static char ID; // Pass ID, replacement for typeid\n\n  LoopStrengthReduce();\n\nprivate:\n  bool runOnLoop(Loop *L, LPPassManager &LPM) override;\n  void getAnalysisUsage(AnalysisUsage &AU) const override;\n};\n\n} // end anonymous namespace\n\nLoopStrengthReduce::LoopStrengthReduce() : LoopPass(ID) {\n  initializeLoopStrengthReducePass(*PassRegistry::getPassRegistry());\n}\n\nvoid LoopStrengthReduce::getAnalysisUsage(AnalysisUsage &AU) const {\n  // We split critical edges, so we change the CFG.  However, we do update\n  // many analyses if they are around.\n  AU.addPreservedID(LoopSimplifyID);\n\n  AU.addRequired<LoopInfoWrapperPass>();\n  AU.addPreserved<LoopInfoWrapperPass>();\n  AU.addRequiredID(LoopSimplifyID);\n  AU.addRequired<DominatorTreeWrapperPass>();\n  AU.addPreserved<DominatorTreeWrapperPass>();\n  AU.addRequired<ScalarEvolutionWrapperPass>();\n  AU.addPreserved<ScalarEvolutionWrapperPass>();\n  AU.addRequired<AssumptionCacheTracker>();\n  AU.addRequired<TargetLibraryInfoWrapperPass>();\n  // Requiring LoopSimplify a second time here prevents IVUsers from running\n  // twice, since LoopSimplify was invalidated by running ScalarEvolution.\n  AU.addRequiredID(LoopSimplifyID);\n  AU.addRequired<IVUsersWrapperPass>();\n  AU.addPreserved<IVUsersWrapperPass>();\n  AU.addRequired<TargetTransformInfoWrapperPass>();\n  AU.addPreserved<MemorySSAWrapperPass>();\n}\n\nusing EqualValues = SmallVector<std::tuple<WeakVH, int64_t>, 4>;\nusing EqualValuesMap =\n    DenseMap<std::pair<DbgValueInst *, unsigned>, EqualValues>;\nusing ExpressionMap = DenseMap<DbgValueInst *, DIExpression *>;\n\nstatic void DbgGatherEqualValues(Loop *L, ScalarEvolution &SE,\n                                 EqualValuesMap &DbgValueToEqualSet,\n                                 ExpressionMap &DbgValueToExpression) {\n  for (auto &B : L->getBlocks()) {\n    for (auto &I : *B) {\n      auto DVI = dyn_cast<DbgValueInst>(&I);\n      if (!DVI)\n        continue;\n      for (unsigned Idx = 0; Idx < DVI->getNumVariableLocationOps(); ++Idx) {\n        // TODO: We can duplicate results if the same arg appears more than\n        // once.\n        Value *V = DVI->getVariableLocationOp(Idx);\n        if (!V || !SE.isSCEVable(V->getType()))\n          continue;\n        auto DbgValueSCEV = SE.getSCEV(V);\n        EqualValues EqSet;\n        for (PHINode &Phi : L->getHeader()->phis()) {\n          if (V->getType() != Phi.getType())\n            continue;\n          if (!SE.isSCEVable(Phi.getType()))\n            continue;\n          auto PhiSCEV = SE.getSCEV(&Phi);\n          Optional<APInt> Offset =\n              SE.computeConstantDifference(DbgValueSCEV, PhiSCEV);\n          if (Offset && Offset->getMinSignedBits() <= 64)\n            EqSet.emplace_back(\n                std::make_tuple(&Phi, Offset.getValue().getSExtValue()));\n        }\n        DbgValueToEqualSet[{DVI, Idx}] = std::move(EqSet);\n        DbgValueToExpression[DVI] = DVI->getExpression();\n      }\n    }\n  }\n}\n\nstatic void DbgApplyEqualValues(EqualValuesMap &DbgValueToEqualSet,\n                                ExpressionMap &DbgValueToExpression) {\n  for (auto A : DbgValueToEqualSet) {\n    auto DVI = A.first.first;\n    auto Idx = A.first.second;\n    // Only update those that are now undef.\n    if (!isa_and_nonnull<UndefValue>(DVI->getVariableLocationOp(Idx)))\n      continue;\n    for (auto EV : A.second) {\n      auto EVHandle = std::get<WeakVH>(EV);\n      if (!EVHandle)\n        continue;\n      // The dbg.value may have had its value changed by LSR; refresh it from\n      // the map, but continue to update the mapped expression as it may be\n      // updated multiple times in this function.\n      auto DbgDIExpr = DbgValueToExpression[DVI];\n      auto Offset = std::get<int64_t>(EV);\n      DVI->replaceVariableLocationOp(Idx, EVHandle);\n      if (Offset) {\n        SmallVector<uint64_t, 8> Ops;\n        DIExpression::appendOffset(Ops, Offset);\n        DbgDIExpr = DIExpression::appendOpsToArg(DbgDIExpr, Ops, Idx, true);\n      }\n      DVI->setExpression(DbgDIExpr);\n      DbgValueToExpression[DVI] = DbgDIExpr;\n      break;\n    }\n  }\n}\n\nstatic bool ReduceLoopStrength(Loop *L, IVUsers &IU, ScalarEvolution &SE,\n                               DominatorTree &DT, LoopInfo &LI,\n                               const TargetTransformInfo &TTI,\n                               AssumptionCache &AC, TargetLibraryInfo &TLI,\n                               MemorySSA *MSSA) {\n\n  bool Changed = false;\n  std::unique_ptr<MemorySSAUpdater> MSSAU;\n  if (MSSA)\n    MSSAU = std::make_unique<MemorySSAUpdater>(MSSA);\n\n  // Run the main LSR transformation.\n  Changed |=\n      LSRInstance(L, IU, SE, DT, LI, TTI, AC, TLI, MSSAU.get()).getChanged();\n\n  // Debug preservation - before we start removing anything create equivalence\n  // sets for the llvm.dbg.value intrinsics.\n  EqualValuesMap DbgValueToEqualSet;\n  ExpressionMap DbgValueToExpression;\n  DbgGatherEqualValues(L, SE, DbgValueToEqualSet, DbgValueToExpression);\n\n  // Remove any extra phis created by processing inner loops.\n  Changed |= DeleteDeadPHIs(L->getHeader(), &TLI, MSSAU.get());\n  if (EnablePhiElim && L->isLoopSimplifyForm()) {\n    SmallVector<WeakTrackingVH, 16> DeadInsts;\n    const DataLayout &DL = L->getHeader()->getModule()->getDataLayout();\n    SCEVExpander Rewriter(SE, DL, \"lsr\", false);\n#ifndef NDEBUG\n    Rewriter.setDebugType(DEBUG_TYPE);\n#endif\n    unsigned numFolded = Rewriter.replaceCongruentIVs(L, &DT, DeadInsts, &TTI);\n    if (numFolded) {\n      Changed = true;\n      RecursivelyDeleteTriviallyDeadInstructionsPermissive(DeadInsts, &TLI,\n                                                           MSSAU.get());\n      DeleteDeadPHIs(L->getHeader(), &TLI, MSSAU.get());\n    }\n  }\n\n  DbgApplyEqualValues(DbgValueToEqualSet, DbgValueToExpression);\n\n  return Changed;\n}\n\nbool LoopStrengthReduce::runOnLoop(Loop *L, LPPassManager & /*LPM*/) {\n  if (skipLoop(L))\n    return false;\n\n  auto &IU = getAnalysis<IVUsersWrapperPass>().getIU();\n  auto &SE = getAnalysis<ScalarEvolutionWrapperPass>().getSE();\n  auto &DT = getAnalysis<DominatorTreeWrapperPass>().getDomTree();\n  auto &LI = getAnalysis<LoopInfoWrapperPass>().getLoopInfo();\n  const auto &TTI = getAnalysis<TargetTransformInfoWrapperPass>().getTTI(\n      *L->getHeader()->getParent());\n  auto &AC = getAnalysis<AssumptionCacheTracker>().getAssumptionCache(\n      *L->getHeader()->getParent());\n  auto &TLI = getAnalysis<TargetLibraryInfoWrapperPass>().getTLI(\n      *L->getHeader()->getParent());\n  auto *MSSAAnalysis = getAnalysisIfAvailable<MemorySSAWrapperPass>();\n  MemorySSA *MSSA = nullptr;\n  if (MSSAAnalysis)\n    MSSA = &MSSAAnalysis->getMSSA();\n  return ReduceLoopStrength(L, IU, SE, DT, LI, TTI, AC, TLI, MSSA);\n}\n\nPreservedAnalyses LoopStrengthReducePass::run(Loop &L, LoopAnalysisManager &AM,\n                                              LoopStandardAnalysisResults &AR,\n                                              LPMUpdater &) {\n  if (!ReduceLoopStrength(&L, AM.getResult<IVUsersAnalysis>(L, AR), AR.SE,\n                          AR.DT, AR.LI, AR.TTI, AR.AC, AR.TLI, AR.MSSA))\n    return PreservedAnalyses::all();\n\n  auto PA = getLoopPassPreservedAnalyses();\n  if (AR.MSSA)\n    PA.preserve<MemorySSAAnalysis>();\n  return PA;\n}\n\nchar LoopStrengthReduce::ID = 0;\n\nINITIALIZE_PASS_BEGIN(LoopStrengthReduce, \"loop-reduce\",\n                      \"Loop Strength Reduction\", false, false)\nINITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(ScalarEvolutionWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(IVUsersWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)\nINITIALIZE_PASS_DEPENDENCY(LoopSimplify)\nINITIALIZE_PASS_END(LoopStrengthReduce, \"loop-reduce\",\n                    \"Loop Strength Reduction\", false, false)\n\nPass *llvm::createLoopStrengthReducePass() { return new LoopStrengthReduce(); }\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 59, "line": 209}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 59, "line": 209}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp", "reportHash": "26a69a62d9cfadfb9575054046487608", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 59, "line": 209}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp", "reportHash": "f2d73562803a13f2fd00c8c2cb086d81", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 59, "line": 213}, "message": "mark 'noexcept'"}, {"location": {"col": 8, "file": 59, "line": 213}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp", "reportHash": "8f9e66bda6edd7ab9c71534b1c2e8399", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 59, "line": 213}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp", "reportHash": "61c26b7fc0a8e4a9a837fc21f8b49618", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
