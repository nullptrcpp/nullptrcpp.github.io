<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp", "content": "//===-- llvm/CodeGen/GlobalISel/LegalizerHelper.cpp -----------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file This file implements the LegalizerHelper class to legalize\n/// individual instructions and the LegalizeMachineIR wrapper pass for the\n/// primary legalization.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/CodeGen/GlobalISel/LegalizerHelper.h\"\n#include \"llvm/CodeGen/GlobalISel/CallLowering.h\"\n#include \"llvm/CodeGen/GlobalISel/GISelChangeObserver.h\"\n#include \"llvm/CodeGen/GlobalISel/LegalizerInfo.h\"\n#include \"llvm/CodeGen/GlobalISel/MIPatternMatch.h\"\n#include \"llvm/CodeGen/MachineRegisterInfo.h\"\n#include \"llvm/CodeGen/TargetFrameLowering.h\"\n#include \"llvm/CodeGen/TargetInstrInfo.h\"\n#include \"llvm/CodeGen/TargetLowering.h\"\n#include \"llvm/CodeGen/TargetSubtargetInfo.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\n#define DEBUG_TYPE \"legalizer\"\n\nusing namespace llvm;\nusing namespace LegalizeActions;\nusing namespace MIPatternMatch;\n\n/// Try to break down \\p OrigTy into \\p NarrowTy sized pieces.\n///\n/// Returns the number of \\p NarrowTy elements needed to reconstruct \\p OrigTy,\n/// with any leftover piece as type \\p LeftoverTy\n///\n/// Returns -1 in the first element of the pair if the breakdown is not\n/// satisfiable.\nstatic std::pair<int, int>\ngetNarrowTypeBreakDown(LLT OrigTy, LLT NarrowTy, LLT &LeftoverTy) {\n  assert(!LeftoverTy.isValid() && \"this is an out argument\");\n\n  unsigned Size = OrigTy.getSizeInBits();\n  unsigned NarrowSize = NarrowTy.getSizeInBits();\n  unsigned NumParts = Size / NarrowSize;\n  unsigned LeftoverSize = Size - NumParts * NarrowSize;\n  assert(Size > NarrowSize);\n\n  if (LeftoverSize == 0)\n    return {NumParts, 0};\n\n  if (NarrowTy.isVector()) {\n    unsigned EltSize = OrigTy.getScalarSizeInBits();\n    if (LeftoverSize % EltSize != 0)\n      return {-1, -1};\n    LeftoverTy = LLT::scalarOrVector(LeftoverSize / EltSize, EltSize);\n  } else {\n    LeftoverTy = LLT::scalar(LeftoverSize);\n  }\n\n  int NumLeftover = LeftoverSize / LeftoverTy.getSizeInBits();\n  return std::make_pair(NumParts, NumLeftover);\n}\n\nstatic Type *getFloatTypeForLLT(LLVMContext &Ctx, LLT Ty) {\n\n  if (!Ty.isScalar())\n    return nullptr;\n\n  switch (Ty.getSizeInBits()) {\n  case 16:\n    return Type::getHalfTy(Ctx);\n  case 32:\n    return Type::getFloatTy(Ctx);\n  case 64:\n    return Type::getDoubleTy(Ctx);\n  case 80:\n    return Type::getX86_FP80Ty(Ctx);\n  case 128:\n    return Type::getFP128Ty(Ctx);\n  default:\n    return nullptr;\n  }\n}\n\nLegalizerHelper::LegalizerHelper(MachineFunction &MF,\n                                 GISelChangeObserver &Observer,\n                                 MachineIRBuilder &Builder)\n    : MIRBuilder(Builder), Observer(Observer), MRI(MF.getRegInfo()),\n      LI(*MF.getSubtarget().getLegalizerInfo()),\n      TLI(*MF.getSubtarget().getTargetLowering()) { }\n\nLegalizerHelper::LegalizerHelper(MachineFunction &MF, const LegalizerInfo &LI,\n                                 GISelChangeObserver &Observer,\n                                 MachineIRBuilder &B)\n  : MIRBuilder(B), Observer(Observer), MRI(MF.getRegInfo()), LI(LI),\n    TLI(*MF.getSubtarget().getTargetLowering()) { }\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::legalizeInstrStep(MachineInstr &MI) {\n  LLVM_DEBUG(dbgs() << \"Legalizing: \" << MI);\n\n  MIRBuilder.setInstrAndDebugLoc(MI);\n\n  if (MI.getOpcode() == TargetOpcode::G_INTRINSIC ||\n      MI.getOpcode() == TargetOpcode::G_INTRINSIC_W_SIDE_EFFECTS)\n    return LI.legalizeIntrinsic(*this, MI) ? Legalized : UnableToLegalize;\n  auto Step = LI.getAction(MI, MRI);\n  switch (Step.Action) {\n  case Legal:\n    LLVM_DEBUG(dbgs() << \".. Already legal\\n\");\n    return AlreadyLegal;\n  case Libcall:\n    LLVM_DEBUG(dbgs() << \".. Convert to libcall\\n\");\n    return libcall(MI);\n  case NarrowScalar:\n    LLVM_DEBUG(dbgs() << \".. Narrow scalar\\n\");\n    return narrowScalar(MI, Step.TypeIdx, Step.NewType);\n  case WidenScalar:\n    LLVM_DEBUG(dbgs() << \".. Widen scalar\\n\");\n    return widenScalar(MI, Step.TypeIdx, Step.NewType);\n  case Bitcast:\n    LLVM_DEBUG(dbgs() << \".. Bitcast type\\n\");\n    return bitcast(MI, Step.TypeIdx, Step.NewType);\n  case Lower:\n    LLVM_DEBUG(dbgs() << \".. Lower\\n\");\n    return lower(MI, Step.TypeIdx, Step.NewType);\n  case FewerElements:\n    LLVM_DEBUG(dbgs() << \".. Reduce number of elements\\n\");\n    return fewerElementsVector(MI, Step.TypeIdx, Step.NewType);\n  case MoreElements:\n    LLVM_DEBUG(dbgs() << \".. Increase number of elements\\n\");\n    return moreElementsVector(MI, Step.TypeIdx, Step.NewType);\n  case Custom:\n    LLVM_DEBUG(dbgs() << \".. Custom legalization\\n\");\n    return LI.legalizeCustom(*this, MI) ? Legalized : UnableToLegalize;\n  default:\n    LLVM_DEBUG(dbgs() << \".. Unable to legalize\\n\");\n    return UnableToLegalize;\n  }\n}\n\nvoid LegalizerHelper::extractParts(Register Reg, LLT Ty, int NumParts,\n                                   SmallVectorImpl<Register> &VRegs) {\n  for (int i = 0; i < NumParts; ++i)\n    VRegs.push_back(MRI.createGenericVirtualRegister(Ty));\n  MIRBuilder.buildUnmerge(VRegs, Reg);\n}\n\nbool LegalizerHelper::extractParts(Register Reg, LLT RegTy,\n                                   LLT MainTy, LLT &LeftoverTy,\n                                   SmallVectorImpl<Register> &VRegs,\n                                   SmallVectorImpl<Register> &LeftoverRegs) {\n  assert(!LeftoverTy.isValid() && \"this is an out argument\");\n\n  unsigned RegSize = RegTy.getSizeInBits();\n  unsigned MainSize = MainTy.getSizeInBits();\n  unsigned NumParts = RegSize / MainSize;\n  unsigned LeftoverSize = RegSize - NumParts * MainSize;\n\n  // Use an unmerge when possible.\n  if (LeftoverSize == 0) {\n    for (unsigned I = 0; I < NumParts; ++I)\n      VRegs.push_back(MRI.createGenericVirtualRegister(MainTy));\n    MIRBuilder.buildUnmerge(VRegs, Reg);\n    return true;\n  }\n\n  if (MainTy.isVector()) {\n    unsigned EltSize = MainTy.getScalarSizeInBits();\n    if (LeftoverSize % EltSize != 0)\n      return false;\n    LeftoverTy = LLT::scalarOrVector(LeftoverSize / EltSize, EltSize);\n  } else {\n    LeftoverTy = LLT::scalar(LeftoverSize);\n  }\n\n  // For irregular sizes, extract the individual parts.\n  for (unsigned I = 0; I != NumParts; ++I) {\n    Register NewReg = MRI.createGenericVirtualRegister(MainTy);\n    VRegs.push_back(NewReg);\n    MIRBuilder.buildExtract(NewReg, Reg, MainSize * I);\n  }\n\n  for (unsigned Offset = MainSize * NumParts; Offset < RegSize;\n       Offset += LeftoverSize) {\n    Register NewReg = MRI.createGenericVirtualRegister(LeftoverTy);\n    LeftoverRegs.push_back(NewReg);\n    MIRBuilder.buildExtract(NewReg, Reg, Offset);\n  }\n\n  return true;\n}\n\nvoid LegalizerHelper::insertParts(Register DstReg,\n                                  LLT ResultTy, LLT PartTy,\n                                  ArrayRef<Register> PartRegs,\n                                  LLT LeftoverTy,\n                                  ArrayRef<Register> LeftoverRegs) {\n  if (!LeftoverTy.isValid()) {\n    assert(LeftoverRegs.empty());\n\n    if (!ResultTy.isVector()) {\n      MIRBuilder.buildMerge(DstReg, PartRegs);\n      return;\n    }\n\n    if (PartTy.isVector())\n      MIRBuilder.buildConcatVectors(DstReg, PartRegs);\n    else\n      MIRBuilder.buildBuildVector(DstReg, PartRegs);\n    return;\n  }\n\n  unsigned PartSize = PartTy.getSizeInBits();\n  unsigned LeftoverPartSize = LeftoverTy.getSizeInBits();\n\n  Register CurResultReg = MRI.createGenericVirtualRegister(ResultTy);\n  MIRBuilder.buildUndef(CurResultReg);\n\n  unsigned Offset = 0;\n  for (Register PartReg : PartRegs) {\n    Register NewResultReg = MRI.createGenericVirtualRegister(ResultTy);\n    MIRBuilder.buildInsert(NewResultReg, CurResultReg, PartReg, Offset);\n    CurResultReg = NewResultReg;\n    Offset += PartSize;\n  }\n\n  for (unsigned I = 0, E = LeftoverRegs.size(); I != E; ++I) {\n    // Use the original output register for the final insert to avoid a copy.\n    Register NewResultReg = (I + 1 == E) ?\n      DstReg : MRI.createGenericVirtualRegister(ResultTy);\n\n    MIRBuilder.buildInsert(NewResultReg, CurResultReg, LeftoverRegs[I], Offset);\n    CurResultReg = NewResultReg;\n    Offset += LeftoverPartSize;\n  }\n}\n\n/// Append the result registers of G_UNMERGE_VALUES \\p MI to \\p Regs.\nstatic void getUnmergeResults(SmallVectorImpl<Register> &Regs,\n                              const MachineInstr &MI) {\n  assert(MI.getOpcode() == TargetOpcode::G_UNMERGE_VALUES);\n\n  const int StartIdx = Regs.size();\n  const int NumResults = MI.getNumOperands() - 1;\n  Regs.resize(Regs.size() + NumResults);\n  for (int I = 0; I != NumResults; ++I)\n    Regs[StartIdx + I] = MI.getOperand(I).getReg();\n}\n\nvoid LegalizerHelper::extractGCDType(SmallVectorImpl<Register> &Parts,\n                                     LLT GCDTy, Register SrcReg) {\n  LLT SrcTy = MRI.getType(SrcReg);\n  if (SrcTy == GCDTy) {\n    // If the source already evenly divides the result type, we don't need to do\n    // anything.\n    Parts.push_back(SrcReg);\n  } else {\n    // Need to split into common type sized pieces.\n    auto Unmerge = MIRBuilder.buildUnmerge(GCDTy, SrcReg);\n    getUnmergeResults(Parts, *Unmerge);\n  }\n}\n\nLLT LegalizerHelper::extractGCDType(SmallVectorImpl<Register> &Parts, LLT DstTy,\n                                    LLT NarrowTy, Register SrcReg) {\n  LLT SrcTy = MRI.getType(SrcReg);\n  LLT GCDTy = getGCDType(getGCDType(SrcTy, NarrowTy), DstTy);\n  extractGCDType(Parts, GCDTy, SrcReg);\n  return GCDTy;\n}\n\nLLT LegalizerHelper::buildLCMMergePieces(LLT DstTy, LLT NarrowTy, LLT GCDTy,\n                                         SmallVectorImpl<Register> &VRegs,\n                                         unsigned PadStrategy) {\n  LLT LCMTy = getLCMType(DstTy, NarrowTy);\n\n  int NumParts = LCMTy.getSizeInBits() / NarrowTy.getSizeInBits();\n  int NumSubParts = NarrowTy.getSizeInBits() / GCDTy.getSizeInBits();\n  int NumOrigSrc = VRegs.size();\n\n  Register PadReg;\n\n  // Get a value we can use to pad the source value if the sources won't evenly\n  // cover the result type.\n  if (NumOrigSrc < NumParts * NumSubParts) {\n    if (PadStrategy == TargetOpcode::G_ZEXT)\n      PadReg = MIRBuilder.buildConstant(GCDTy, 0).getReg(0);\n    else if (PadStrategy == TargetOpcode::G_ANYEXT)\n      PadReg = MIRBuilder.buildUndef(GCDTy).getReg(0);\n    else {\n      assert(PadStrategy == TargetOpcode::G_SEXT);\n\n      // Shift the sign bit of the low register through the high register.\n      auto ShiftAmt =\n        MIRBuilder.buildConstant(LLT::scalar(64), GCDTy.getSizeInBits() - 1);\n      PadReg = MIRBuilder.buildAShr(GCDTy, VRegs.back(), ShiftAmt).getReg(0);\n    }\n  }\n\n  // Registers for the final merge to be produced.\n  SmallVector<Register, 4> Remerge(NumParts);\n\n  // Registers needed for intermediate merges, which will be merged into a\n  // source for Remerge.\n  SmallVector<Register, 4> SubMerge(NumSubParts);\n\n  // Once we've fully read off the end of the original source bits, we can reuse\n  // the same high bits for remaining padding elements.\n  Register AllPadReg;\n\n  // Build merges to the LCM type to cover the original result type.\n  for (int I = 0; I != NumParts; ++I) {\n    bool AllMergePartsArePadding = true;\n\n    // Build the requested merges to the requested type.\n    for (int J = 0; J != NumSubParts; ++J) {\n      int Idx = I * NumSubParts + J;\n      if (Idx >= NumOrigSrc) {\n        SubMerge[J] = PadReg;\n        continue;\n      }\n\n      SubMerge[J] = VRegs[Idx];\n\n      // There are meaningful bits here we can't reuse later.\n      AllMergePartsArePadding = false;\n    }\n\n    // If we've filled up a complete piece with padding bits, we can directly\n    // emit the natural sized constant if applicable, rather than a merge of\n    // smaller constants.\n    if (AllMergePartsArePadding && !AllPadReg) {\n      if (PadStrategy == TargetOpcode::G_ANYEXT)\n        AllPadReg = MIRBuilder.buildUndef(NarrowTy).getReg(0);\n      else if (PadStrategy == TargetOpcode::G_ZEXT)\n        AllPadReg = MIRBuilder.buildConstant(NarrowTy, 0).getReg(0);\n\n      // If this is a sign extension, we can't materialize a trivial constant\n      // with the right type and have to produce a merge.\n    }\n\n    if (AllPadReg) {\n      // Avoid creating additional instructions if we're just adding additional\n      // copies of padding bits.\n      Remerge[I] = AllPadReg;\n      continue;\n    }\n\n    if (NumSubParts == 1)\n      Remerge[I] = SubMerge[0];\n    else\n      Remerge[I] = MIRBuilder.buildMerge(NarrowTy, SubMerge).getReg(0);\n\n    // In the sign extend padding case, re-use the first all-signbit merge.\n    if (AllMergePartsArePadding && !AllPadReg)\n      AllPadReg = Remerge[I];\n  }\n\n  VRegs = std::move(Remerge);\n  return LCMTy;\n}\n\nvoid LegalizerHelper::buildWidenedRemergeToDst(Register DstReg, LLT LCMTy,\n                                               ArrayRef<Register> RemergeRegs) {\n  LLT DstTy = MRI.getType(DstReg);\n\n  // Create the merge to the widened source, and extract the relevant bits into\n  // the result.\n\n  if (DstTy == LCMTy) {\n    MIRBuilder.buildMerge(DstReg, RemergeRegs);\n    return;\n  }\n\n  auto Remerge = MIRBuilder.buildMerge(LCMTy, RemergeRegs);\n  if (DstTy.isScalar() && LCMTy.isScalar()) {\n    MIRBuilder.buildTrunc(DstReg, Remerge);\n    return;\n  }\n\n  if (LCMTy.isVector()) {\n    unsigned NumDefs = LCMTy.getSizeInBits() / DstTy.getSizeInBits();\n    SmallVector<Register, 8> UnmergeDefs(NumDefs);\n    UnmergeDefs[0] = DstReg;\n    for (unsigned I = 1; I != NumDefs; ++I)\n      UnmergeDefs[I] = MRI.createGenericVirtualRegister(DstTy);\n\n    MIRBuilder.buildUnmerge(UnmergeDefs,\n                            MIRBuilder.buildMerge(LCMTy, RemergeRegs));\n    return;\n  }\n\n  llvm_unreachable(\"unhandled case\");\n}\n\nstatic RTLIB::Libcall getRTLibDesc(unsigned Opcode, unsigned Size) {\n#define RTLIBCASE_INT(LibcallPrefix)                                           \\\n  do {                                                                         \\\n    switch (Size) {                                                            \\\n    case 32:                                                                   \\\n      return RTLIB::LibcallPrefix##32;                                         \\\n    case 64:                                                                   \\\n      return RTLIB::LibcallPrefix##64;                                         \\\n    case 128:                                                                  \\\n      return RTLIB::LibcallPrefix##128;                                        \\\n    default:                                                                   \\\n      llvm_unreachable(\"unexpected size\");                                     \\\n    }                                                                          \\\n  } while (0)\n\n#define RTLIBCASE(LibcallPrefix)                                               \\\n  do {                                                                         \\\n    switch (Size) {                                                            \\\n    case 32:                                                                   \\\n      return RTLIB::LibcallPrefix##32;                                         \\\n    case 64:                                                                   \\\n      return RTLIB::LibcallPrefix##64;                                         \\\n    case 80:                                                                   \\\n      return RTLIB::LibcallPrefix##80;                                         \\\n    case 128:                                                                  \\\n      return RTLIB::LibcallPrefix##128;                                        \\\n    default:                                                                   \\\n      llvm_unreachable(\"unexpected size\");                                     \\\n    }                                                                          \\\n  } while (0)\n\n  switch (Opcode) {\n  case TargetOpcode::G_SDIV:\n    RTLIBCASE_INT(SDIV_I);\n  case TargetOpcode::G_UDIV:\n    RTLIBCASE_INT(UDIV_I);\n  case TargetOpcode::G_SREM:\n    RTLIBCASE_INT(SREM_I);\n  case TargetOpcode::G_UREM:\n    RTLIBCASE_INT(UREM_I);\n  case TargetOpcode::G_CTLZ_ZERO_UNDEF:\n    RTLIBCASE_INT(CTLZ_I);\n  case TargetOpcode::G_FADD:\n    RTLIBCASE(ADD_F);\n  case TargetOpcode::G_FSUB:\n    RTLIBCASE(SUB_F);\n  case TargetOpcode::G_FMUL:\n    RTLIBCASE(MUL_F);\n  case TargetOpcode::G_FDIV:\n    RTLIBCASE(DIV_F);\n  case TargetOpcode::G_FEXP:\n    RTLIBCASE(EXP_F);\n  case TargetOpcode::G_FEXP2:\n    RTLIBCASE(EXP2_F);\n  case TargetOpcode::G_FREM:\n    RTLIBCASE(REM_F);\n  case TargetOpcode::G_FPOW:\n    RTLIBCASE(POW_F);\n  case TargetOpcode::G_FMA:\n    RTLIBCASE(FMA_F);\n  case TargetOpcode::G_FSIN:\n    RTLIBCASE(SIN_F);\n  case TargetOpcode::G_FCOS:\n    RTLIBCASE(COS_F);\n  case TargetOpcode::G_FLOG10:\n    RTLIBCASE(LOG10_F);\n  case TargetOpcode::G_FLOG:\n    RTLIBCASE(LOG_F);\n  case TargetOpcode::G_FLOG2:\n    RTLIBCASE(LOG2_F);\n  case TargetOpcode::G_FCEIL:\n    RTLIBCASE(CEIL_F);\n  case TargetOpcode::G_FFLOOR:\n    RTLIBCASE(FLOOR_F);\n  case TargetOpcode::G_FMINNUM:\n    RTLIBCASE(FMIN_F);\n  case TargetOpcode::G_FMAXNUM:\n    RTLIBCASE(FMAX_F);\n  case TargetOpcode::G_FSQRT:\n    RTLIBCASE(SQRT_F);\n  case TargetOpcode::G_FRINT:\n    RTLIBCASE(RINT_F);\n  case TargetOpcode::G_FNEARBYINT:\n    RTLIBCASE(NEARBYINT_F);\n  case TargetOpcode::G_INTRINSIC_ROUNDEVEN:\n    RTLIBCASE(ROUNDEVEN_F);\n  }\n  llvm_unreachable(\"Unknown libcall function\");\n}\n\n/// True if an instruction is in tail position in its caller. Intended for\n/// legalizing libcalls as tail calls when possible.\nstatic bool isLibCallInTailPosition(const TargetInstrInfo &TII,\n                                    MachineInstr &MI) {\n  MachineBasicBlock &MBB = *MI.getParent();\n  const Function &F = MBB.getParent()->getFunction();\n\n  // Conservatively require the attributes of the call to match those of\n  // the return. Ignore NoAlias and NonNull because they don't affect the\n  // call sequence.\n  AttributeList CallerAttrs = F.getAttributes();\n  if (AttrBuilder(CallerAttrs, AttributeList::ReturnIndex)\n          .removeAttribute(Attribute::NoAlias)\n          .removeAttribute(Attribute::NonNull)\n          .hasAttributes())\n    return false;\n\n  // It's not safe to eliminate the sign / zero extension of the return value.\n  if (CallerAttrs.hasAttribute(AttributeList::ReturnIndex, Attribute::ZExt) ||\n      CallerAttrs.hasAttribute(AttributeList::ReturnIndex, Attribute::SExt))\n    return false;\n\n  // Only tail call if the following instruction is a standard return.\n  auto Next = next_nodbg(MI.getIterator(), MBB.instr_end());\n  if (Next == MBB.instr_end() || TII.isTailCall(*Next) || !Next->isReturn())\n    return false;\n\n  return true;\n}\n\nLegalizerHelper::LegalizeResult\nllvm::createLibcall(MachineIRBuilder &MIRBuilder, const char *Name,\n                    const CallLowering::ArgInfo &Result,\n                    ArrayRef<CallLowering::ArgInfo> Args,\n                    const CallingConv::ID CC) {\n  auto &CLI = *MIRBuilder.getMF().getSubtarget().getCallLowering();\n\n  CallLowering::CallLoweringInfo Info;\n  Info.CallConv = CC;\n  Info.Callee = MachineOperand::CreateES(Name);\n  Info.OrigRet = Result;\n  std::copy(Args.begin(), Args.end(), std::back_inserter(Info.OrigArgs));\n  if (!CLI.lowerCall(MIRBuilder, Info))\n    return LegalizerHelper::UnableToLegalize;\n\n  return LegalizerHelper::Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nllvm::createLibcall(MachineIRBuilder &MIRBuilder, RTLIB::Libcall Libcall,\n                    const CallLowering::ArgInfo &Result,\n                    ArrayRef<CallLowering::ArgInfo> Args) {\n  auto &TLI = *MIRBuilder.getMF().getSubtarget().getTargetLowering();\n  const char *Name = TLI.getLibcallName(Libcall);\n  const CallingConv::ID CC = TLI.getLibcallCallingConv(Libcall);\n  return createLibcall(MIRBuilder, Name, Result, Args, CC);\n}\n\n// Useful for libcalls where all operands have the same type.\nstatic LegalizerHelper::LegalizeResult\nsimpleLibcall(MachineInstr &MI, MachineIRBuilder &MIRBuilder, unsigned Size,\n              Type *OpType) {\n  auto Libcall = getRTLibDesc(MI.getOpcode(), Size);\n\n  SmallVector<CallLowering::ArgInfo, 3> Args;\n  for (unsigned i = 1; i < MI.getNumOperands(); i++)\n    Args.push_back({MI.getOperand(i).getReg(), OpType});\n  return createLibcall(MIRBuilder, Libcall, {MI.getOperand(0).getReg(), OpType},\n                       Args);\n}\n\nLegalizerHelper::LegalizeResult\nllvm::createMemLibcall(MachineIRBuilder &MIRBuilder, MachineRegisterInfo &MRI,\n                       MachineInstr &MI) {\n  auto &Ctx = MIRBuilder.getMF().getFunction().getContext();\n\n  SmallVector<CallLowering::ArgInfo, 3> Args;\n  // Add all the args, except for the last which is an imm denoting 'tail'.\n  for (unsigned i = 0; i < MI.getNumOperands() - 1; ++i) {\n    Register Reg = MI.getOperand(i).getReg();\n\n    // Need derive an IR type for call lowering.\n    LLT OpLLT = MRI.getType(Reg);\n    Type *OpTy = nullptr;\n    if (OpLLT.isPointer())\n      OpTy = Type::getInt8PtrTy(Ctx, OpLLT.getAddressSpace());\n    else\n      OpTy = IntegerType::get(Ctx, OpLLT.getSizeInBits());\n    Args.push_back({Reg, OpTy});\n  }\n\n  auto &CLI = *MIRBuilder.getMF().getSubtarget().getCallLowering();\n  auto &TLI = *MIRBuilder.getMF().getSubtarget().getTargetLowering();\n  RTLIB::Libcall RTLibcall;\n  switch (MI.getOpcode()) {\n  case TargetOpcode::G_MEMCPY:\n    RTLibcall = RTLIB::MEMCPY;\n    break;\n  case TargetOpcode::G_MEMMOVE:\n    RTLibcall = RTLIB::MEMMOVE;\n    break;\n  case TargetOpcode::G_MEMSET:\n    RTLibcall = RTLIB::MEMSET;\n    break;\n  default:\n    return LegalizerHelper::UnableToLegalize;\n  }\n  const char *Name = TLI.getLibcallName(RTLibcall);\n\n  CallLowering::CallLoweringInfo Info;\n  Info.CallConv = TLI.getLibcallCallingConv(RTLibcall);\n  Info.Callee = MachineOperand::CreateES(Name);\n  Info.OrigRet = CallLowering::ArgInfo({0}, Type::getVoidTy(Ctx));\n  Info.IsTailCall = MI.getOperand(MI.getNumOperands() - 1).getImm() &&\n                    isLibCallInTailPosition(MIRBuilder.getTII(), MI);\n\n  std::copy(Args.begin(), Args.end(), std::back_inserter(Info.OrigArgs));\n  if (!CLI.lowerCall(MIRBuilder, Info))\n    return LegalizerHelper::UnableToLegalize;\n\n  if (Info.LoweredTailCall) {\n    assert(Info.IsTailCall && \"Lowered tail call when it wasn't a tail call?\");\n    // We must have a return following the call (or debug insts) to get past\n    // isLibCallInTailPosition.\n    do {\n      MachineInstr *Next = MI.getNextNode();\n      assert(Next && (Next->isReturn() || Next->isDebugInstr()) &&\n             \"Expected instr following MI to be return or debug inst?\");\n      // We lowered a tail call, so the call is now the return from the block.\n      // Delete the old return.\n      Next->eraseFromParent();\n    } while (MI.getNextNode());\n  }\n\n  return LegalizerHelper::Legalized;\n}\n\nstatic RTLIB::Libcall getConvRTLibDesc(unsigned Opcode, Type *ToType,\n                                       Type *FromType) {\n  auto ToMVT = MVT::getVT(ToType);\n  auto FromMVT = MVT::getVT(FromType);\n\n  switch (Opcode) {\n  case TargetOpcode::G_FPEXT:\n    return RTLIB::getFPEXT(FromMVT, ToMVT);\n  case TargetOpcode::G_FPTRUNC:\n    return RTLIB::getFPROUND(FromMVT, ToMVT);\n  case TargetOpcode::G_FPTOSI:\n    return RTLIB::getFPTOSINT(FromMVT, ToMVT);\n  case TargetOpcode::G_FPTOUI:\n    return RTLIB::getFPTOUINT(FromMVT, ToMVT);\n  case TargetOpcode::G_SITOFP:\n    return RTLIB::getSINTTOFP(FromMVT, ToMVT);\n  case TargetOpcode::G_UITOFP:\n    return RTLIB::getUINTTOFP(FromMVT, ToMVT);\n  }\n  llvm_unreachable(\"Unsupported libcall function\");\n}\n\nstatic LegalizerHelper::LegalizeResult\nconversionLibcall(MachineInstr &MI, MachineIRBuilder &MIRBuilder, Type *ToType,\n                  Type *FromType) {\n  RTLIB::Libcall Libcall = getConvRTLibDesc(MI.getOpcode(), ToType, FromType);\n  return createLibcall(MIRBuilder, Libcall, {MI.getOperand(0).getReg(), ToType},\n                       {{MI.getOperand(1).getReg(), FromType}});\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::libcall(MachineInstr &MI) {\n  LLT LLTy = MRI.getType(MI.getOperand(0).getReg());\n  unsigned Size = LLTy.getSizeInBits();\n  auto &Ctx = MIRBuilder.getMF().getFunction().getContext();\n\n  switch (MI.getOpcode()) {\n  default:\n    return UnableToLegalize;\n  case TargetOpcode::G_SDIV:\n  case TargetOpcode::G_UDIV:\n  case TargetOpcode::G_SREM:\n  case TargetOpcode::G_UREM:\n  case TargetOpcode::G_CTLZ_ZERO_UNDEF: {\n    Type *HLTy = IntegerType::get(Ctx, Size);\n    auto Status = simpleLibcall(MI, MIRBuilder, Size, HLTy);\n    if (Status != Legalized)\n      return Status;\n    break;\n  }\n  case TargetOpcode::G_FADD:\n  case TargetOpcode::G_FSUB:\n  case TargetOpcode::G_FMUL:\n  case TargetOpcode::G_FDIV:\n  case TargetOpcode::G_FMA:\n  case TargetOpcode::G_FPOW:\n  case TargetOpcode::G_FREM:\n  case TargetOpcode::G_FCOS:\n  case TargetOpcode::G_FSIN:\n  case TargetOpcode::G_FLOG10:\n  case TargetOpcode::G_FLOG:\n  case TargetOpcode::G_FLOG2:\n  case TargetOpcode::G_FEXP:\n  case TargetOpcode::G_FEXP2:\n  case TargetOpcode::G_FCEIL:\n  case TargetOpcode::G_FFLOOR:\n  case TargetOpcode::G_FMINNUM:\n  case TargetOpcode::G_FMAXNUM:\n  case TargetOpcode::G_FSQRT:\n  case TargetOpcode::G_FRINT:\n  case TargetOpcode::G_FNEARBYINT:\n  case TargetOpcode::G_INTRINSIC_ROUNDEVEN: {\n    Type *HLTy = getFloatTypeForLLT(Ctx, LLTy);\n    if (!HLTy || (Size != 32 && Size != 64 && Size != 80 && Size != 128)) {\n      LLVM_DEBUG(dbgs() << \"No libcall available for type \" << LLTy << \".\\n\");\n      return UnableToLegalize;\n    }\n    auto Status = simpleLibcall(MI, MIRBuilder, Size, HLTy);\n    if (Status != Legalized)\n      return Status;\n    break;\n  }\n  case TargetOpcode::G_FPEXT:\n  case TargetOpcode::G_FPTRUNC: {\n    Type *FromTy = getFloatTypeForLLT(Ctx,  MRI.getType(MI.getOperand(1).getReg()));\n    Type *ToTy = getFloatTypeForLLT(Ctx, MRI.getType(MI.getOperand(0).getReg()));\n    if (!FromTy || !ToTy)\n      return UnableToLegalize;\n    LegalizeResult Status = conversionLibcall(MI, MIRBuilder, ToTy, FromTy );\n    if (Status != Legalized)\n      return Status;\n    break;\n  }\n  case TargetOpcode::G_FPTOSI:\n  case TargetOpcode::G_FPTOUI: {\n    // FIXME: Support other types\n    unsigned FromSize = MRI.getType(MI.getOperand(1).getReg()).getSizeInBits();\n    unsigned ToSize = MRI.getType(MI.getOperand(0).getReg()).getSizeInBits();\n    if ((ToSize != 32 && ToSize != 64) || (FromSize != 32 && FromSize != 64))\n      return UnableToLegalize;\n    LegalizeResult Status = conversionLibcall(\n        MI, MIRBuilder,\n        ToSize == 32 ? Type::getInt32Ty(Ctx) : Type::getInt64Ty(Ctx),\n        FromSize == 64 ? Type::getDoubleTy(Ctx) : Type::getFloatTy(Ctx));\n    if (Status != Legalized)\n      return Status;\n    break;\n  }\n  case TargetOpcode::G_SITOFP:\n  case TargetOpcode::G_UITOFP: {\n    // FIXME: Support other types\n    unsigned FromSize = MRI.getType(MI.getOperand(1).getReg()).getSizeInBits();\n    unsigned ToSize = MRI.getType(MI.getOperand(0).getReg()).getSizeInBits();\n    if ((FromSize != 32 && FromSize != 64) || (ToSize != 32 && ToSize != 64))\n      return UnableToLegalize;\n    LegalizeResult Status = conversionLibcall(\n        MI, MIRBuilder,\n        ToSize == 64 ? Type::getDoubleTy(Ctx) : Type::getFloatTy(Ctx),\n        FromSize == 32 ? Type::getInt32Ty(Ctx) : Type::getInt64Ty(Ctx));\n    if (Status != Legalized)\n      return Status;\n    break;\n  }\n  case TargetOpcode::G_MEMCPY:\n  case TargetOpcode::G_MEMMOVE:\n  case TargetOpcode::G_MEMSET: {\n    LegalizeResult Result = createMemLibcall(MIRBuilder, *MIRBuilder.getMRI(), MI);\n    MI.eraseFromParent();\n    return Result;\n  }\n  }\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult LegalizerHelper::narrowScalar(MachineInstr &MI,\n                                                              unsigned TypeIdx,\n                                                              LLT NarrowTy) {\n  uint64_t SizeOp0 = MRI.getType(MI.getOperand(0).getReg()).getSizeInBits();\n  uint64_t NarrowSize = NarrowTy.getSizeInBits();\n\n  switch (MI.getOpcode()) {\n  default:\n    return UnableToLegalize;\n  case TargetOpcode::G_IMPLICIT_DEF: {\n    Register DstReg = MI.getOperand(0).getReg();\n    LLT DstTy = MRI.getType(DstReg);\n\n    // If SizeOp0 is not an exact multiple of NarrowSize, emit\n    // G_ANYEXT(G_IMPLICIT_DEF). Cast result to vector if needed.\n    // FIXME: Although this would also be legal for the general case, it causes\n    //  a lot of regressions in the emitted code (superfluous COPYs, artifact\n    //  combines not being hit). This seems to be a problem related to the\n    //  artifact combiner.\n    if (SizeOp0 % NarrowSize != 0) {\n      LLT ImplicitTy = NarrowTy;\n      if (DstTy.isVector())\n        ImplicitTy = LLT::vector(DstTy.getNumElements(), ImplicitTy);\n\n      Register ImplicitReg = MIRBuilder.buildUndef(ImplicitTy).getReg(0);\n      MIRBuilder.buildAnyExt(DstReg, ImplicitReg);\n\n      MI.eraseFromParent();\n      return Legalized;\n    }\n\n    int NumParts = SizeOp0 / NarrowSize;\n\n    SmallVector<Register, 2> DstRegs;\n    for (int i = 0; i < NumParts; ++i)\n      DstRegs.push_back(MIRBuilder.buildUndef(NarrowTy).getReg(0));\n\n    if (DstTy.isVector())\n      MIRBuilder.buildBuildVector(DstReg, DstRegs);\n    else\n      MIRBuilder.buildMerge(DstReg, DstRegs);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case TargetOpcode::G_CONSTANT: {\n    LLT Ty = MRI.getType(MI.getOperand(0).getReg());\n    const APInt &Val = MI.getOperand(1).getCImm()->getValue();\n    unsigned TotalSize = Ty.getSizeInBits();\n    unsigned NarrowSize = NarrowTy.getSizeInBits();\n    int NumParts = TotalSize / NarrowSize;\n\n    SmallVector<Register, 4> PartRegs;\n    for (int I = 0; I != NumParts; ++I) {\n      unsigned Offset = I * NarrowSize;\n      auto K = MIRBuilder.buildConstant(NarrowTy,\n                                        Val.lshr(Offset).trunc(NarrowSize));\n      PartRegs.push_back(K.getReg(0));\n    }\n\n    LLT LeftoverTy;\n    unsigned LeftoverBits = TotalSize - NumParts * NarrowSize;\n    SmallVector<Register, 1> LeftoverRegs;\n    if (LeftoverBits != 0) {\n      LeftoverTy = LLT::scalar(LeftoverBits);\n      auto K = MIRBuilder.buildConstant(\n        LeftoverTy,\n        Val.lshr(NumParts * NarrowSize).trunc(LeftoverBits));\n      LeftoverRegs.push_back(K.getReg(0));\n    }\n\n    insertParts(MI.getOperand(0).getReg(),\n                Ty, NarrowTy, PartRegs, LeftoverTy, LeftoverRegs);\n\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case TargetOpcode::G_SEXT:\n  case TargetOpcode::G_ZEXT:\n  case TargetOpcode::G_ANYEXT:\n    return narrowScalarExt(MI, TypeIdx, NarrowTy);\n  case TargetOpcode::G_TRUNC: {\n    if (TypeIdx != 1)\n      return UnableToLegalize;\n\n    uint64_t SizeOp1 = MRI.getType(MI.getOperand(1).getReg()).getSizeInBits();\n    if (NarrowTy.getSizeInBits() * 2 != SizeOp1) {\n      LLVM_DEBUG(dbgs() << \"Can't narrow trunc to type \" << NarrowTy << \"\\n\");\n      return UnableToLegalize;\n    }\n\n    auto Unmerge = MIRBuilder.buildUnmerge(NarrowTy, MI.getOperand(1));\n    MIRBuilder.buildCopy(MI.getOperand(0), Unmerge.getReg(0));\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  case TargetOpcode::G_FREEZE:\n    return reduceOperationWidth(MI, TypeIdx, NarrowTy);\n  case TargetOpcode::G_ADD:\n  case TargetOpcode::G_SUB:\n    return narrowScalarAddSub(MI, TypeIdx, NarrowTy);\n  case TargetOpcode::G_MUL:\n  case TargetOpcode::G_UMULH:\n    return narrowScalarMul(MI, NarrowTy);\n  case TargetOpcode::G_EXTRACT:\n    return narrowScalarExtract(MI, TypeIdx, NarrowTy);\n  case TargetOpcode::G_INSERT:\n    return narrowScalarInsert(MI, TypeIdx, NarrowTy);\n  case TargetOpcode::G_LOAD: {\n    auto &MMO = **MI.memoperands_begin();\n    Register DstReg = MI.getOperand(0).getReg();\n    LLT DstTy = MRI.getType(DstReg);\n    if (DstTy.isVector())\n      return UnableToLegalize;\n\n    if (8 * MMO.getSize() != DstTy.getSizeInBits()) {\n      Register TmpReg = MRI.createGenericVirtualRegister(NarrowTy);\n      MIRBuilder.buildLoad(TmpReg, MI.getOperand(1), MMO);\n      MIRBuilder.buildAnyExt(DstReg, TmpReg);\n      MI.eraseFromParent();\n      return Legalized;\n    }\n\n    return reduceLoadStoreWidth(MI, TypeIdx, NarrowTy);\n  }\n  case TargetOpcode::G_ZEXTLOAD:\n  case TargetOpcode::G_SEXTLOAD: {\n    bool ZExt = MI.getOpcode() == TargetOpcode::G_ZEXTLOAD;\n    Register DstReg = MI.getOperand(0).getReg();\n    Register PtrReg = MI.getOperand(1).getReg();\n\n    Register TmpReg = MRI.createGenericVirtualRegister(NarrowTy);\n    auto &MMO = **MI.memoperands_begin();\n    unsigned MemSize = MMO.getSizeInBits();\n\n    if (MemSize == NarrowSize) {\n      MIRBuilder.buildLoad(TmpReg, PtrReg, MMO);\n    } else if (MemSize < NarrowSize) {\n      MIRBuilder.buildLoadInstr(MI.getOpcode(), TmpReg, PtrReg, MMO);\n    } else if (MemSize > NarrowSize) {\n      // FIXME: Need to split the load.\n      return UnableToLegalize;\n    }\n\n    if (ZExt)\n      MIRBuilder.buildZExt(DstReg, TmpReg);\n    else\n      MIRBuilder.buildSExt(DstReg, TmpReg);\n\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case TargetOpcode::G_STORE: {\n    const auto &MMO = **MI.memoperands_begin();\n\n    Register SrcReg = MI.getOperand(0).getReg();\n    LLT SrcTy = MRI.getType(SrcReg);\n    if (SrcTy.isVector())\n      return UnableToLegalize;\n\n    int NumParts = SizeOp0 / NarrowSize;\n    unsigned HandledSize = NumParts * NarrowTy.getSizeInBits();\n    unsigned LeftoverBits = SrcTy.getSizeInBits() - HandledSize;\n    if (SrcTy.isVector() && LeftoverBits != 0)\n      return UnableToLegalize;\n\n    if (8 * MMO.getSize() != SrcTy.getSizeInBits()) {\n      Register TmpReg = MRI.createGenericVirtualRegister(NarrowTy);\n      auto &MMO = **MI.memoperands_begin();\n      MIRBuilder.buildTrunc(TmpReg, SrcReg);\n      MIRBuilder.buildStore(TmpReg, MI.getOperand(1), MMO);\n      MI.eraseFromParent();\n      return Legalized;\n    }\n\n    return reduceLoadStoreWidth(MI, 0, NarrowTy);\n  }\n  case TargetOpcode::G_SELECT:\n    return narrowScalarSelect(MI, TypeIdx, NarrowTy);\n  case TargetOpcode::G_AND:\n  case TargetOpcode::G_OR:\n  case TargetOpcode::G_XOR: {\n    // Legalize bitwise operation:\n    // A = BinOp<Ty> B, C\n    // into:\n    // B1, ..., BN = G_UNMERGE_VALUES B\n    // C1, ..., CN = G_UNMERGE_VALUES C\n    // A1 = BinOp<Ty/N> B1, C2\n    // ...\n    // AN = BinOp<Ty/N> BN, CN\n    // A = G_MERGE_VALUES A1, ..., AN\n    return narrowScalarBasic(MI, TypeIdx, NarrowTy);\n  }\n  case TargetOpcode::G_SHL:\n  case TargetOpcode::G_LSHR:\n  case TargetOpcode::G_ASHR:\n    return narrowScalarShift(MI, TypeIdx, NarrowTy);\n  case TargetOpcode::G_CTLZ:\n  case TargetOpcode::G_CTLZ_ZERO_UNDEF:\n  case TargetOpcode::G_CTTZ:\n  case TargetOpcode::G_CTTZ_ZERO_UNDEF:\n  case TargetOpcode::G_CTPOP:\n    if (TypeIdx == 1)\n      switch (MI.getOpcode()) {\n      case TargetOpcode::G_CTLZ:\n      case TargetOpcode::G_CTLZ_ZERO_UNDEF:\n        return narrowScalarCTLZ(MI, TypeIdx, NarrowTy);\n      case TargetOpcode::G_CTTZ:\n      case TargetOpcode::G_CTTZ_ZERO_UNDEF:\n        return narrowScalarCTTZ(MI, TypeIdx, NarrowTy);\n      case TargetOpcode::G_CTPOP:\n        return narrowScalarCTPOP(MI, TypeIdx, NarrowTy);\n      default:\n        return UnableToLegalize;\n      }\n\n    Observer.changingInstr(MI);\n    narrowScalarDst(MI, NarrowTy, 0, TargetOpcode::G_ZEXT);\n    Observer.changedInstr(MI);\n    return Legalized;\n  case TargetOpcode::G_INTTOPTR:\n    if (TypeIdx != 1)\n      return UnableToLegalize;\n\n    Observer.changingInstr(MI);\n    narrowScalarSrc(MI, NarrowTy, 1);\n    Observer.changedInstr(MI);\n    return Legalized;\n  case TargetOpcode::G_PTRTOINT:\n    if (TypeIdx != 0)\n      return UnableToLegalize;\n\n    Observer.changingInstr(MI);\n    narrowScalarDst(MI, NarrowTy, 0, TargetOpcode::G_ZEXT);\n    Observer.changedInstr(MI);\n    return Legalized;\n  case TargetOpcode::G_PHI: {\n    unsigned NumParts = SizeOp0 / NarrowSize;\n    SmallVector<Register, 2> DstRegs(NumParts);\n    SmallVector<SmallVector<Register, 2>, 2> SrcRegs(MI.getNumOperands() / 2);\n    Observer.changingInstr(MI);\n    for (unsigned i = 1; i < MI.getNumOperands(); i += 2) {\n      MachineBasicBlock &OpMBB = *MI.getOperand(i + 1).getMBB();\n      MIRBuilder.setInsertPt(OpMBB, OpMBB.getFirstTerminator());\n      extractParts(MI.getOperand(i).getReg(), NarrowTy, NumParts,\n                   SrcRegs[i / 2]);\n    }\n    MachineBasicBlock &MBB = *MI.getParent();\n    MIRBuilder.setInsertPt(MBB, MI);\n    for (unsigned i = 0; i < NumParts; ++i) {\n      DstRegs[i] = MRI.createGenericVirtualRegister(NarrowTy);\n      MachineInstrBuilder MIB =\n          MIRBuilder.buildInstr(TargetOpcode::G_PHI).addDef(DstRegs[i]);\n      for (unsigned j = 1; j < MI.getNumOperands(); j += 2)\n        MIB.addUse(SrcRegs[j / 2][i]).add(MI.getOperand(j + 1));\n    }\n    MIRBuilder.setInsertPt(MBB, MBB.getFirstNonPHI());\n    MIRBuilder.buildMerge(MI.getOperand(0), DstRegs);\n    Observer.changedInstr(MI);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case TargetOpcode::G_EXTRACT_VECTOR_ELT:\n  case TargetOpcode::G_INSERT_VECTOR_ELT: {\n    if (TypeIdx != 2)\n      return UnableToLegalize;\n\n    int OpIdx = MI.getOpcode() == TargetOpcode::G_EXTRACT_VECTOR_ELT ? 2 : 3;\n    Observer.changingInstr(MI);\n    narrowScalarSrc(MI, NarrowTy, OpIdx);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_ICMP: {\n    uint64_t SrcSize = MRI.getType(MI.getOperand(2).getReg()).getSizeInBits();\n    if (NarrowSize * 2 != SrcSize)\n      return UnableToLegalize;\n\n    Observer.changingInstr(MI);\n    Register LHSL = MRI.createGenericVirtualRegister(NarrowTy);\n    Register LHSH = MRI.createGenericVirtualRegister(NarrowTy);\n    MIRBuilder.buildUnmerge({LHSL, LHSH}, MI.getOperand(2));\n\n    Register RHSL = MRI.createGenericVirtualRegister(NarrowTy);\n    Register RHSH = MRI.createGenericVirtualRegister(NarrowTy);\n    MIRBuilder.buildUnmerge({RHSL, RHSH}, MI.getOperand(3));\n\n    CmpInst::Predicate Pred =\n        static_cast<CmpInst::Predicate>(MI.getOperand(1).getPredicate());\n    LLT ResTy = MRI.getType(MI.getOperand(0).getReg());\n\n    if (Pred == CmpInst::ICMP_EQ || Pred == CmpInst::ICMP_NE) {\n      MachineInstrBuilder XorL = MIRBuilder.buildXor(NarrowTy, LHSL, RHSL);\n      MachineInstrBuilder XorH = MIRBuilder.buildXor(NarrowTy, LHSH, RHSH);\n      MachineInstrBuilder Or = MIRBuilder.buildOr(NarrowTy, XorL, XorH);\n      MachineInstrBuilder Zero = MIRBuilder.buildConstant(NarrowTy, 0);\n      MIRBuilder.buildICmp(Pred, MI.getOperand(0), Or, Zero);\n    } else {\n      MachineInstrBuilder CmpH = MIRBuilder.buildICmp(Pred, ResTy, LHSH, RHSH);\n      MachineInstrBuilder CmpHEQ =\n          MIRBuilder.buildICmp(CmpInst::Predicate::ICMP_EQ, ResTy, LHSH, RHSH);\n      MachineInstrBuilder CmpLU = MIRBuilder.buildICmp(\n          ICmpInst::getUnsignedPredicate(Pred), ResTy, LHSL, RHSL);\n      MIRBuilder.buildSelect(MI.getOperand(0), CmpHEQ, CmpLU, CmpH);\n    }\n    Observer.changedInstr(MI);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case TargetOpcode::G_SEXT_INREG: {\n    if (TypeIdx != 0)\n      return UnableToLegalize;\n\n    int64_t SizeInBits = MI.getOperand(2).getImm();\n\n    // So long as the new type has more bits than the bits we're extending we\n    // don't need to break it apart.\n    if (NarrowTy.getScalarSizeInBits() >= SizeInBits) {\n      Observer.changingInstr(MI);\n      // We don't lose any non-extension bits by truncating the src and\n      // sign-extending the dst.\n      MachineOperand &MO1 = MI.getOperand(1);\n      auto TruncMIB = MIRBuilder.buildTrunc(NarrowTy, MO1);\n      MO1.setReg(TruncMIB.getReg(0));\n\n      MachineOperand &MO2 = MI.getOperand(0);\n      Register DstExt = MRI.createGenericVirtualRegister(NarrowTy);\n      MIRBuilder.setInsertPt(MIRBuilder.getMBB(), ++MIRBuilder.getInsertPt());\n      MIRBuilder.buildSExt(MO2, DstExt);\n      MO2.setReg(DstExt);\n      Observer.changedInstr(MI);\n      return Legalized;\n    }\n\n    // Break it apart. Components below the extension point are unmodified. The\n    // component containing the extension point becomes a narrower SEXT_INREG.\n    // Components above it are ashr'd from the component containing the\n    // extension point.\n    if (SizeOp0 % NarrowSize != 0)\n      return UnableToLegalize;\n    int NumParts = SizeOp0 / NarrowSize;\n\n    // List the registers where the destination will be scattered.\n    SmallVector<Register, 2> DstRegs;\n    // List the registers where the source will be split.\n    SmallVector<Register, 2> SrcRegs;\n\n    // Create all the temporary registers.\n    for (int i = 0; i < NumParts; ++i) {\n      Register SrcReg = MRI.createGenericVirtualRegister(NarrowTy);\n\n      SrcRegs.push_back(SrcReg);\n    }\n\n    // Explode the big arguments into smaller chunks.\n    MIRBuilder.buildUnmerge(SrcRegs, MI.getOperand(1));\n\n    Register AshrCstReg =\n        MIRBuilder.buildConstant(NarrowTy, NarrowTy.getScalarSizeInBits() - 1)\n            .getReg(0);\n    Register FullExtensionReg = 0;\n    Register PartialExtensionReg = 0;\n\n    // Do the operation on each small part.\n    for (int i = 0; i < NumParts; ++i) {\n      if ((i + 1) * NarrowTy.getScalarSizeInBits() < SizeInBits)\n        DstRegs.push_back(SrcRegs[i]);\n      else if (i * NarrowTy.getScalarSizeInBits() > SizeInBits) {\n        assert(PartialExtensionReg &&\n               \"Expected to visit partial extension before full\");\n        if (FullExtensionReg) {\n          DstRegs.push_back(FullExtensionReg);\n          continue;\n        }\n        DstRegs.push_back(\n            MIRBuilder.buildAShr(NarrowTy, PartialExtensionReg, AshrCstReg)\n                .getReg(0));\n        FullExtensionReg = DstRegs.back();\n      } else {\n        DstRegs.push_back(\n            MIRBuilder\n                .buildInstr(\n                    TargetOpcode::G_SEXT_INREG, {NarrowTy},\n                    {SrcRegs[i], SizeInBits % NarrowTy.getScalarSizeInBits()})\n                .getReg(0));\n        PartialExtensionReg = DstRegs.back();\n      }\n    }\n\n    // Gather the destination registers into the final destination.\n    Register DstReg = MI.getOperand(0).getReg();\n    MIRBuilder.buildMerge(DstReg, DstRegs);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case TargetOpcode::G_BSWAP:\n  case TargetOpcode::G_BITREVERSE: {\n    if (SizeOp0 % NarrowSize != 0)\n      return UnableToLegalize;\n\n    Observer.changingInstr(MI);\n    SmallVector<Register, 2> SrcRegs, DstRegs;\n    unsigned NumParts = SizeOp0 / NarrowSize;\n    extractParts(MI.getOperand(1).getReg(), NarrowTy, NumParts, SrcRegs);\n\n    for (unsigned i = 0; i < NumParts; ++i) {\n      auto DstPart = MIRBuilder.buildInstr(MI.getOpcode(), {NarrowTy},\n                                           {SrcRegs[NumParts - 1 - i]});\n      DstRegs.push_back(DstPart.getReg(0));\n    }\n\n    MIRBuilder.buildMerge(MI.getOperand(0), DstRegs);\n\n    Observer.changedInstr(MI);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case TargetOpcode::G_PTR_ADD:\n  case TargetOpcode::G_PTRMASK: {\n    if (TypeIdx != 1)\n      return UnableToLegalize;\n    Observer.changingInstr(MI);\n    narrowScalarSrc(MI, NarrowTy, 2);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_FPTOUI: {\n    if (TypeIdx != 0)\n      return UnableToLegalize;\n    Observer.changingInstr(MI);\n    narrowScalarDst(MI, NarrowTy, 0, TargetOpcode::G_ZEXT);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_FPTOSI: {\n    if (TypeIdx != 0)\n      return UnableToLegalize;\n    Observer.changingInstr(MI);\n    narrowScalarDst(MI, NarrowTy, 0, TargetOpcode::G_SEXT);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_FPEXT:\n    if (TypeIdx != 0)\n      return UnableToLegalize;\n    Observer.changingInstr(MI);\n    narrowScalarDst(MI, NarrowTy, 0, TargetOpcode::G_FPEXT);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n}\n\nRegister LegalizerHelper::coerceToScalar(Register Val) {\n  LLT Ty = MRI.getType(Val);\n  if (Ty.isScalar())\n    return Val;\n\n  const DataLayout &DL = MIRBuilder.getDataLayout();\n  LLT NewTy = LLT::scalar(Ty.getSizeInBits());\n  if (Ty.isPointer()) {\n    if (DL.isNonIntegralAddressSpace(Ty.getAddressSpace()))\n      return Register();\n    return MIRBuilder.buildPtrToInt(NewTy, Val).getReg(0);\n  }\n\n  Register NewVal = Val;\n\n  assert(Ty.isVector());\n  LLT EltTy = Ty.getElementType();\n  if (EltTy.isPointer())\n    NewVal = MIRBuilder.buildPtrToInt(NewTy, NewVal).getReg(0);\n  return MIRBuilder.buildBitcast(NewTy, NewVal).getReg(0);\n}\n\nvoid LegalizerHelper::widenScalarSrc(MachineInstr &MI, LLT WideTy,\n                                     unsigned OpIdx, unsigned ExtOpcode) {\n  MachineOperand &MO = MI.getOperand(OpIdx);\n  auto ExtB = MIRBuilder.buildInstr(ExtOpcode, {WideTy}, {MO});\n  MO.setReg(ExtB.getReg(0));\n}\n\nvoid LegalizerHelper::narrowScalarSrc(MachineInstr &MI, LLT NarrowTy,\n                                      unsigned OpIdx) {\n  MachineOperand &MO = MI.getOperand(OpIdx);\n  auto ExtB = MIRBuilder.buildTrunc(NarrowTy, MO);\n  MO.setReg(ExtB.getReg(0));\n}\n\nvoid LegalizerHelper::widenScalarDst(MachineInstr &MI, LLT WideTy,\n                                     unsigned OpIdx, unsigned TruncOpcode) {\n  MachineOperand &MO = MI.getOperand(OpIdx);\n  Register DstExt = MRI.createGenericVirtualRegister(WideTy);\n  MIRBuilder.setInsertPt(MIRBuilder.getMBB(), ++MIRBuilder.getInsertPt());\n  MIRBuilder.buildInstr(TruncOpcode, {MO}, {DstExt});\n  MO.setReg(DstExt);\n}\n\nvoid LegalizerHelper::narrowScalarDst(MachineInstr &MI, LLT NarrowTy,\n                                      unsigned OpIdx, unsigned ExtOpcode) {\n  MachineOperand &MO = MI.getOperand(OpIdx);\n  Register DstTrunc = MRI.createGenericVirtualRegister(NarrowTy);\n  MIRBuilder.setInsertPt(MIRBuilder.getMBB(), ++MIRBuilder.getInsertPt());\n  MIRBuilder.buildInstr(ExtOpcode, {MO}, {DstTrunc});\n  MO.setReg(DstTrunc);\n}\n\nvoid LegalizerHelper::moreElementsVectorDst(MachineInstr &MI, LLT WideTy,\n                                            unsigned OpIdx) {\n  MachineOperand &MO = MI.getOperand(OpIdx);\n  MIRBuilder.setInsertPt(MIRBuilder.getMBB(), ++MIRBuilder.getInsertPt());\n  MO.setReg(widenWithUnmerge(WideTy, MO.getReg()));\n}\n\nvoid LegalizerHelper::moreElementsVectorSrc(MachineInstr &MI, LLT MoreTy,\n                                            unsigned OpIdx) {\n  MachineOperand &MO = MI.getOperand(OpIdx);\n\n  LLT OldTy = MRI.getType(MO.getReg());\n  unsigned OldElts = OldTy.getNumElements();\n  unsigned NewElts = MoreTy.getNumElements();\n\n  unsigned NumParts = NewElts / OldElts;\n\n  // Use concat_vectors if the result is a multiple of the number of elements.\n  if (NumParts * OldElts == NewElts) {\n    SmallVector<Register, 8> Parts;\n    Parts.push_back(MO.getReg());\n\n    Register ImpDef = MIRBuilder.buildUndef(OldTy).getReg(0);\n    for (unsigned I = 1; I != NumParts; ++I)\n      Parts.push_back(ImpDef);\n\n    auto Concat = MIRBuilder.buildConcatVectors(MoreTy, Parts);\n    MO.setReg(Concat.getReg(0));\n    return;\n  }\n\n  Register MoreReg = MRI.createGenericVirtualRegister(MoreTy);\n  Register ImpDef = MIRBuilder.buildUndef(MoreTy).getReg(0);\n  MIRBuilder.buildInsert(MoreReg, ImpDef, MO.getReg(), 0);\n  MO.setReg(MoreReg);\n}\n\nvoid LegalizerHelper::bitcastSrc(MachineInstr &MI, LLT CastTy, unsigned OpIdx) {\n  MachineOperand &Op = MI.getOperand(OpIdx);\n  Op.setReg(MIRBuilder.buildBitcast(CastTy, Op).getReg(0));\n}\n\nvoid LegalizerHelper::bitcastDst(MachineInstr &MI, LLT CastTy, unsigned OpIdx) {\n  MachineOperand &MO = MI.getOperand(OpIdx);\n  Register CastDst = MRI.createGenericVirtualRegister(CastTy);\n  MIRBuilder.setInsertPt(MIRBuilder.getMBB(), ++MIRBuilder.getInsertPt());\n  MIRBuilder.buildBitcast(MO, CastDst);\n  MO.setReg(CastDst);\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::widenScalarMergeValues(MachineInstr &MI, unsigned TypeIdx,\n                                        LLT WideTy) {\n  if (TypeIdx != 1)\n    return UnableToLegalize;\n\n  Register DstReg = MI.getOperand(0).getReg();\n  LLT DstTy = MRI.getType(DstReg);\n  if (DstTy.isVector())\n    return UnableToLegalize;\n\n  Register Src1 = MI.getOperand(1).getReg();\n  LLT SrcTy = MRI.getType(Src1);\n  const int DstSize = DstTy.getSizeInBits();\n  const int SrcSize = SrcTy.getSizeInBits();\n  const int WideSize = WideTy.getSizeInBits();\n  const int NumMerge = (DstSize + WideSize - 1) / WideSize;\n\n  unsigned NumOps = MI.getNumOperands();\n  unsigned NumSrc = MI.getNumOperands() - 1;\n  unsigned PartSize = DstTy.getSizeInBits() / NumSrc;\n\n  if (WideSize >= DstSize) {\n    // Directly pack the bits in the target type.\n    Register ResultReg = MIRBuilder.buildZExt(WideTy, Src1).getReg(0);\n\n    for (unsigned I = 2; I != NumOps; ++I) {\n      const unsigned Offset = (I - 1) * PartSize;\n\n      Register SrcReg = MI.getOperand(I).getReg();\n      assert(MRI.getType(SrcReg) == LLT::scalar(PartSize));\n\n      auto ZextInput = MIRBuilder.buildZExt(WideTy, SrcReg);\n\n      Register NextResult = I + 1 == NumOps && WideTy == DstTy ? DstReg :\n        MRI.createGenericVirtualRegister(WideTy);\n\n      auto ShiftAmt = MIRBuilder.buildConstant(WideTy, Offset);\n      auto Shl = MIRBuilder.buildShl(WideTy, ZextInput, ShiftAmt);\n      MIRBuilder.buildOr(NextResult, ResultReg, Shl);\n      ResultReg = NextResult;\n    }\n\n    if (WideSize > DstSize)\n      MIRBuilder.buildTrunc(DstReg, ResultReg);\n    else if (DstTy.isPointer())\n      MIRBuilder.buildIntToPtr(DstReg, ResultReg);\n\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  // Unmerge the original values to the GCD type, and recombine to the next\n  // multiple greater than the original type.\n  //\n  // %3:_(s12) = G_MERGE_VALUES %0:_(s4), %1:_(s4), %2:_(s4) -> s6\n  // %4:_(s2), %5:_(s2) = G_UNMERGE_VALUES %0\n  // %6:_(s2), %7:_(s2) = G_UNMERGE_VALUES %1\n  // %8:_(s2), %9:_(s2) = G_UNMERGE_VALUES %2\n  // %10:_(s6) = G_MERGE_VALUES %4, %5, %6\n  // %11:_(s6) = G_MERGE_VALUES %7, %8, %9\n  // %12:_(s12) = G_MERGE_VALUES %10, %11\n  //\n  // Padding with undef if necessary:\n  //\n  // %2:_(s8) = G_MERGE_VALUES %0:_(s4), %1:_(s4) -> s6\n  // %3:_(s2), %4:_(s2) = G_UNMERGE_VALUES %0\n  // %5:_(s2), %6:_(s2) = G_UNMERGE_VALUES %1\n  // %7:_(s2) = G_IMPLICIT_DEF\n  // %8:_(s6) = G_MERGE_VALUES %3, %4, %5\n  // %9:_(s6) = G_MERGE_VALUES %6, %7, %7\n  // %10:_(s12) = G_MERGE_VALUES %8, %9\n\n  const int GCD = greatestCommonDivisor(SrcSize, WideSize);\n  LLT GCDTy = LLT::scalar(GCD);\n\n  SmallVector<Register, 8> Parts;\n  SmallVector<Register, 8> NewMergeRegs;\n  SmallVector<Register, 8> Unmerges;\n  LLT WideDstTy = LLT::scalar(NumMerge * WideSize);\n\n  // Decompose the original operands if they don't evenly divide.\n  for (int I = 1, E = MI.getNumOperands(); I != E; ++I) {\n    Register SrcReg = MI.getOperand(I).getReg();\n    if (GCD == SrcSize) {\n      Unmerges.push_back(SrcReg);\n    } else {\n      auto Unmerge = MIRBuilder.buildUnmerge(GCDTy, SrcReg);\n      for (int J = 0, JE = Unmerge->getNumOperands() - 1; J != JE; ++J)\n        Unmerges.push_back(Unmerge.getReg(J));\n    }\n  }\n\n  // Pad with undef to the next size that is a multiple of the requested size.\n  if (static_cast<int>(Unmerges.size()) != NumMerge * WideSize) {\n    Register UndefReg = MIRBuilder.buildUndef(GCDTy).getReg(0);\n    for (int I = Unmerges.size(); I != NumMerge * WideSize; ++I)\n      Unmerges.push_back(UndefReg);\n  }\n\n  const int PartsPerGCD = WideSize / GCD;\n\n  // Build merges of each piece.\n  ArrayRef<Register> Slicer(Unmerges);\n  for (int I = 0; I != NumMerge; ++I, Slicer = Slicer.drop_front(PartsPerGCD)) {\n    auto Merge = MIRBuilder.buildMerge(WideTy, Slicer.take_front(PartsPerGCD));\n    NewMergeRegs.push_back(Merge.getReg(0));\n  }\n\n  // A truncate may be necessary if the requested type doesn't evenly divide the\n  // original result type.\n  if (DstTy.getSizeInBits() == WideDstTy.getSizeInBits()) {\n    MIRBuilder.buildMerge(DstReg, NewMergeRegs);\n  } else {\n    auto FinalMerge = MIRBuilder.buildMerge(WideDstTy, NewMergeRegs);\n    MIRBuilder.buildTrunc(DstReg, FinalMerge.getReg(0));\n  }\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nRegister LegalizerHelper::widenWithUnmerge(LLT WideTy, Register OrigReg) {\n  Register WideReg = MRI.createGenericVirtualRegister(WideTy);\n  LLT OrigTy = MRI.getType(OrigReg);\n  LLT LCMTy = getLCMType(WideTy, OrigTy);\n\n  const int NumMergeParts = LCMTy.getSizeInBits() / WideTy.getSizeInBits();\n  const int NumUnmergeParts = LCMTy.getSizeInBits() / OrigTy.getSizeInBits();\n\n  Register UnmergeSrc = WideReg;\n\n  // Create a merge to the LCM type, padding with undef\n  // %0:_(<3 x s32>) = G_FOO => <4 x s32>\n  // =>\n  // %1:_(<4 x s32>) = G_FOO\n  // %2:_(<4 x s32>) = G_IMPLICIT_DEF\n  // %3:_(<12 x s32>) = G_CONCAT_VECTORS %1, %2, %2\n  // %0:_(<3 x s32>), %4:_, %5:_, %6:_ = G_UNMERGE_VALUES %3\n  if (NumMergeParts > 1) {\n    Register Undef = MIRBuilder.buildUndef(WideTy).getReg(0);\n    SmallVector<Register, 8> MergeParts(NumMergeParts, Undef);\n    MergeParts[0] = WideReg;\n    UnmergeSrc = MIRBuilder.buildMerge(LCMTy, MergeParts).getReg(0);\n  }\n\n  // Unmerge to the original register and pad with dead defs.\n  SmallVector<Register, 8> UnmergeResults(NumUnmergeParts);\n  UnmergeResults[0] = OrigReg;\n  for (int I = 1; I != NumUnmergeParts; ++I)\n    UnmergeResults[I] = MRI.createGenericVirtualRegister(OrigTy);\n\n  MIRBuilder.buildUnmerge(UnmergeResults, UnmergeSrc);\n  return WideReg;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::widenScalarUnmergeValues(MachineInstr &MI, unsigned TypeIdx,\n                                          LLT WideTy) {\n  if (TypeIdx != 0)\n    return UnableToLegalize;\n\n  int NumDst = MI.getNumOperands() - 1;\n  Register SrcReg = MI.getOperand(NumDst).getReg();\n  LLT SrcTy = MRI.getType(SrcReg);\n  if (SrcTy.isVector())\n    return UnableToLegalize;\n\n  Register Dst0Reg = MI.getOperand(0).getReg();\n  LLT DstTy = MRI.getType(Dst0Reg);\n  if (!DstTy.isScalar())\n    return UnableToLegalize;\n\n  if (WideTy.getSizeInBits() >= SrcTy.getSizeInBits()) {\n    if (SrcTy.isPointer()) {\n      const DataLayout &DL = MIRBuilder.getDataLayout();\n      if (DL.isNonIntegralAddressSpace(SrcTy.getAddressSpace())) {\n        LLVM_DEBUG(\n            dbgs() << \"Not casting non-integral address space integer\\n\");\n        return UnableToLegalize;\n      }\n\n      SrcTy = LLT::scalar(SrcTy.getSizeInBits());\n      SrcReg = MIRBuilder.buildPtrToInt(SrcTy, SrcReg).getReg(0);\n    }\n\n    // Widen SrcTy to WideTy. This does not affect the result, but since the\n    // user requested this size, it is probably better handled than SrcTy and\n    // should reduce the total number of legalization artifacts\n    if (WideTy.getSizeInBits() > SrcTy.getSizeInBits()) {\n      SrcTy = WideTy;\n      SrcReg = MIRBuilder.buildAnyExt(WideTy, SrcReg).getReg(0);\n    }\n\n    // Theres no unmerge type to target. Directly extract the bits from the\n    // source type\n    unsigned DstSize = DstTy.getSizeInBits();\n\n    MIRBuilder.buildTrunc(Dst0Reg, SrcReg);\n    for (int I = 1; I != NumDst; ++I) {\n      auto ShiftAmt = MIRBuilder.buildConstant(SrcTy, DstSize * I);\n      auto Shr = MIRBuilder.buildLShr(SrcTy, SrcReg, ShiftAmt);\n      MIRBuilder.buildTrunc(MI.getOperand(I), Shr);\n    }\n\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  // Extend the source to a wider type.\n  LLT LCMTy = getLCMType(SrcTy, WideTy);\n\n  Register WideSrc = SrcReg;\n  if (LCMTy.getSizeInBits() != SrcTy.getSizeInBits()) {\n    // TODO: If this is an integral address space, cast to integer and anyext.\n    if (SrcTy.isPointer()) {\n      LLVM_DEBUG(dbgs() << \"Widening pointer source types not implemented\\n\");\n      return UnableToLegalize;\n    }\n\n    WideSrc = MIRBuilder.buildAnyExt(LCMTy, WideSrc).getReg(0);\n  }\n\n  auto Unmerge = MIRBuilder.buildUnmerge(WideTy, WideSrc);\n\n  // Create a sequence of unmerges and merges to the original results. Since we\n  // may have widened the source, we will need to pad the results with dead defs\n  // to cover the source register.\n  // e.g. widen s48 to s64:\n  // %1:_(s48), %2:_(s48) = G_UNMERGE_VALUES %0:_(s96)\n  //\n  // =>\n  //  %4:_(s192) = G_ANYEXT %0:_(s96)\n  //  %5:_(s64), %6, %7 = G_UNMERGE_VALUES %4 ; Requested unmerge\n  //  ; unpack to GCD type, with extra dead defs\n  //  %8:_(s16), %9, %10, %11 = G_UNMERGE_VALUES %5:_(s64)\n  //  %12:_(s16), %13, dead %14, dead %15 = G_UNMERGE_VALUES %6:_(s64)\n  //  dead %16:_(s16), dead %17, dead %18, dead %18 = G_UNMERGE_VALUES %7:_(s64)\n  //  %1:_(s48) = G_MERGE_VALUES %8:_(s16), %9, %10   ; Remerge to destination\n  //  %2:_(s48) = G_MERGE_VALUES %11:_(s16), %12, %13 ; Remerge to destination\n  const LLT GCDTy = getGCDType(WideTy, DstTy);\n  const int NumUnmerge = Unmerge->getNumOperands() - 1;\n  const int PartsPerRemerge = DstTy.getSizeInBits() / GCDTy.getSizeInBits();\n\n  // Directly unmerge to the destination without going through a GCD type\n  // if possible\n  if (PartsPerRemerge == 1) {\n    const int PartsPerUnmerge = WideTy.getSizeInBits() / DstTy.getSizeInBits();\n\n    for (int I = 0; I != NumUnmerge; ++I) {\n      auto MIB = MIRBuilder.buildInstr(TargetOpcode::G_UNMERGE_VALUES);\n\n      for (int J = 0; J != PartsPerUnmerge; ++J) {\n        int Idx = I * PartsPerUnmerge + J;\n        if (Idx < NumDst)\n          MIB.addDef(MI.getOperand(Idx).getReg());\n        else {\n          // Create dead def for excess components.\n          MIB.addDef(MRI.createGenericVirtualRegister(DstTy));\n        }\n      }\n\n      MIB.addUse(Unmerge.getReg(I));\n    }\n  } else {\n    SmallVector<Register, 16> Parts;\n    for (int J = 0; J != NumUnmerge; ++J)\n      extractGCDType(Parts, GCDTy, Unmerge.getReg(J));\n\n    SmallVector<Register, 8> RemergeParts;\n    for (int I = 0; I != NumDst; ++I) {\n      for (int J = 0; J < PartsPerRemerge; ++J) {\n        const int Idx = I * PartsPerRemerge + J;\n        RemergeParts.emplace_back(Parts[Idx]);\n      }\n\n      MIRBuilder.buildMerge(MI.getOperand(I).getReg(), RemergeParts);\n      RemergeParts.clear();\n    }\n  }\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::widenScalarExtract(MachineInstr &MI, unsigned TypeIdx,\n                                    LLT WideTy) {\n  Register DstReg = MI.getOperand(0).getReg();\n  Register SrcReg = MI.getOperand(1).getReg();\n  LLT SrcTy = MRI.getType(SrcReg);\n\n  LLT DstTy = MRI.getType(DstReg);\n  unsigned Offset = MI.getOperand(2).getImm();\n\n  if (TypeIdx == 0) {\n    if (SrcTy.isVector() || DstTy.isVector())\n      return UnableToLegalize;\n\n    SrcOp Src(SrcReg);\n    if (SrcTy.isPointer()) {\n      // Extracts from pointers can be handled only if they are really just\n      // simple integers.\n      const DataLayout &DL = MIRBuilder.getDataLayout();\n      if (DL.isNonIntegralAddressSpace(SrcTy.getAddressSpace()))\n        return UnableToLegalize;\n\n      LLT SrcAsIntTy = LLT::scalar(SrcTy.getSizeInBits());\n      Src = MIRBuilder.buildPtrToInt(SrcAsIntTy, Src);\n      SrcTy = SrcAsIntTy;\n    }\n\n    if (DstTy.isPointer())\n      return UnableToLegalize;\n\n    if (Offset == 0) {\n      // Avoid a shift in the degenerate case.\n      MIRBuilder.buildTrunc(DstReg,\n                            MIRBuilder.buildAnyExtOrTrunc(WideTy, Src));\n      MI.eraseFromParent();\n      return Legalized;\n    }\n\n    // Do a shift in the source type.\n    LLT ShiftTy = SrcTy;\n    if (WideTy.getSizeInBits() > SrcTy.getSizeInBits()) {\n      Src = MIRBuilder.buildAnyExt(WideTy, Src);\n      ShiftTy = WideTy;\n    }\n\n    auto LShr = MIRBuilder.buildLShr(\n      ShiftTy, Src, MIRBuilder.buildConstant(ShiftTy, Offset));\n    MIRBuilder.buildTrunc(DstReg, LShr);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  if (SrcTy.isScalar()) {\n    Observer.changingInstr(MI);\n    widenScalarSrc(MI, WideTy, 1, TargetOpcode::G_ANYEXT);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n\n  if (!SrcTy.isVector())\n    return UnableToLegalize;\n\n  if (DstTy != SrcTy.getElementType())\n    return UnableToLegalize;\n\n  if (Offset % SrcTy.getScalarSizeInBits() != 0)\n    return UnableToLegalize;\n\n  Observer.changingInstr(MI);\n  widenScalarSrc(MI, WideTy, 1, TargetOpcode::G_ANYEXT);\n\n  MI.getOperand(2).setImm((WideTy.getSizeInBits() / SrcTy.getSizeInBits()) *\n                          Offset);\n  widenScalarDst(MI, WideTy.getScalarType(), 0);\n  Observer.changedInstr(MI);\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::widenScalarInsert(MachineInstr &MI, unsigned TypeIdx,\n                                   LLT WideTy) {\n  if (TypeIdx != 0 || WideTy.isVector())\n    return UnableToLegalize;\n  Observer.changingInstr(MI);\n  widenScalarSrc(MI, WideTy, 1, TargetOpcode::G_ANYEXT);\n  widenScalarDst(MI, WideTy);\n  Observer.changedInstr(MI);\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::widenScalarAddSubOverflow(MachineInstr &MI, unsigned TypeIdx,\n                                           LLT WideTy) {\n  if (TypeIdx == 1)\n    return UnableToLegalize; // TODO\n\n  unsigned Opcode;\n  unsigned ExtOpcode;\n  Optional<Register> CarryIn = None;\n  switch (MI.getOpcode()) {\n  default:\n    llvm_unreachable(\"Unexpected opcode!\");\n  case TargetOpcode::G_SADDO:\n    Opcode = TargetOpcode::G_ADD;\n    ExtOpcode = TargetOpcode::G_SEXT;\n    break;\n  case TargetOpcode::G_SSUBO:\n    Opcode = TargetOpcode::G_SUB;\n    ExtOpcode = TargetOpcode::G_SEXT;\n    break;\n  case TargetOpcode::G_UADDO:\n    Opcode = TargetOpcode::G_ADD;\n    ExtOpcode = TargetOpcode::G_ZEXT;\n    break;\n  case TargetOpcode::G_USUBO:\n    Opcode = TargetOpcode::G_SUB;\n    ExtOpcode = TargetOpcode::G_ZEXT;\n    break;\n  case TargetOpcode::G_SADDE:\n    Opcode = TargetOpcode::G_UADDE;\n    ExtOpcode = TargetOpcode::G_SEXT;\n    CarryIn = MI.getOperand(4).getReg();\n    break;\n  case TargetOpcode::G_SSUBE:\n    Opcode = TargetOpcode::G_USUBE;\n    ExtOpcode = TargetOpcode::G_SEXT;\n    CarryIn = MI.getOperand(4).getReg();\n    break;\n  case TargetOpcode::G_UADDE:\n    Opcode = TargetOpcode::G_UADDE;\n    ExtOpcode = TargetOpcode::G_ZEXT;\n    CarryIn = MI.getOperand(4).getReg();\n    break;\n  case TargetOpcode::G_USUBE:\n    Opcode = TargetOpcode::G_USUBE;\n    ExtOpcode = TargetOpcode::G_ZEXT;\n    CarryIn = MI.getOperand(4).getReg();\n    break;\n  }\n\n  auto LHSExt = MIRBuilder.buildInstr(ExtOpcode, {WideTy}, {MI.getOperand(2)});\n  auto RHSExt = MIRBuilder.buildInstr(ExtOpcode, {WideTy}, {MI.getOperand(3)});\n  // Do the arithmetic in the larger type.\n  Register NewOp;\n  if (CarryIn) {\n    LLT CarryOutTy = MRI.getType(MI.getOperand(1).getReg());\n    NewOp = MIRBuilder\n                .buildInstr(Opcode, {WideTy, CarryOutTy},\n                            {LHSExt, RHSExt, *CarryIn})\n                .getReg(0);\n  } else {\n    NewOp = MIRBuilder.buildInstr(Opcode, {WideTy}, {LHSExt, RHSExt}).getReg(0);\n  }\n  LLT OrigTy = MRI.getType(MI.getOperand(0).getReg());\n  auto TruncOp = MIRBuilder.buildTrunc(OrigTy, NewOp);\n  auto ExtOp = MIRBuilder.buildInstr(ExtOpcode, {WideTy}, {TruncOp});\n  // There is no overflow if the ExtOp is the same as NewOp.\n  MIRBuilder.buildICmp(CmpInst::ICMP_NE, MI.getOperand(1), NewOp, ExtOp);\n  // Now trunc the NewOp to the original result.\n  MIRBuilder.buildTrunc(MI.getOperand(0), NewOp);\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::widenScalarAddSubShlSat(MachineInstr &MI, unsigned TypeIdx,\n                                         LLT WideTy) {\n  bool IsSigned = MI.getOpcode() == TargetOpcode::G_SADDSAT ||\n                  MI.getOpcode() == TargetOpcode::G_SSUBSAT ||\n                  MI.getOpcode() == TargetOpcode::G_SSHLSAT;\n  bool IsShift = MI.getOpcode() == TargetOpcode::G_SSHLSAT ||\n                 MI.getOpcode() == TargetOpcode::G_USHLSAT;\n  // We can convert this to:\n  //   1. Any extend iN to iM\n  //   2. SHL by M-N\n  //   3. [US][ADD|SUB|SHL]SAT\n  //   4. L/ASHR by M-N\n  //\n  // It may be more efficient to lower this to a min and a max operation in\n  // the higher precision arithmetic if the promoted operation isn't legal,\n  // but this decision is up to the target's lowering request.\n  Register DstReg = MI.getOperand(0).getReg();\n\n  unsigned NewBits = WideTy.getScalarSizeInBits();\n  unsigned SHLAmount = NewBits - MRI.getType(DstReg).getScalarSizeInBits();\n\n  // Shifts must zero-extend the RHS to preserve the unsigned quantity, and\n  // must not left shift the RHS to preserve the shift amount.\n  auto LHS = MIRBuilder.buildAnyExt(WideTy, MI.getOperand(1));\n  auto RHS = IsShift ? MIRBuilder.buildZExt(WideTy, MI.getOperand(2))\n                     : MIRBuilder.buildAnyExt(WideTy, MI.getOperand(2));\n  auto ShiftK = MIRBuilder.buildConstant(WideTy, SHLAmount);\n  auto ShiftL = MIRBuilder.buildShl(WideTy, LHS, ShiftK);\n  auto ShiftR = IsShift ? RHS : MIRBuilder.buildShl(WideTy, RHS, ShiftK);\n\n  auto WideInst = MIRBuilder.buildInstr(MI.getOpcode(), {WideTy},\n                                        {ShiftL, ShiftR}, MI.getFlags());\n\n  // Use a shift that will preserve the number of sign bits when the trunc is\n  // folded away.\n  auto Result = IsSigned ? MIRBuilder.buildAShr(WideTy, WideInst, ShiftK)\n                         : MIRBuilder.buildLShr(WideTy, WideInst, ShiftK);\n\n  MIRBuilder.buildTrunc(DstReg, Result);\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::widenScalar(MachineInstr &MI, unsigned TypeIdx, LLT WideTy) {\n  switch (MI.getOpcode()) {\n  default:\n    return UnableToLegalize;\n  case TargetOpcode::G_EXTRACT:\n    return widenScalarExtract(MI, TypeIdx, WideTy);\n  case TargetOpcode::G_INSERT:\n    return widenScalarInsert(MI, TypeIdx, WideTy);\n  case TargetOpcode::G_MERGE_VALUES:\n    return widenScalarMergeValues(MI, TypeIdx, WideTy);\n  case TargetOpcode::G_UNMERGE_VALUES:\n    return widenScalarUnmergeValues(MI, TypeIdx, WideTy);\n  case TargetOpcode::G_SADDO:\n  case TargetOpcode::G_SSUBO:\n  case TargetOpcode::G_UADDO:\n  case TargetOpcode::G_USUBO:\n  case TargetOpcode::G_SADDE:\n  case TargetOpcode::G_SSUBE:\n  case TargetOpcode::G_UADDE:\n  case TargetOpcode::G_USUBE:\n    return widenScalarAddSubOverflow(MI, TypeIdx, WideTy);\n  case TargetOpcode::G_SADDSAT:\n  case TargetOpcode::G_SSUBSAT:\n  case TargetOpcode::G_SSHLSAT:\n  case TargetOpcode::G_UADDSAT:\n  case TargetOpcode::G_USUBSAT:\n  case TargetOpcode::G_USHLSAT:\n    return widenScalarAddSubShlSat(MI, TypeIdx, WideTy);\n  case TargetOpcode::G_CTTZ:\n  case TargetOpcode::G_CTTZ_ZERO_UNDEF:\n  case TargetOpcode::G_CTLZ:\n  case TargetOpcode::G_CTLZ_ZERO_UNDEF:\n  case TargetOpcode::G_CTPOP: {\n    if (TypeIdx == 0) {\n      Observer.changingInstr(MI);\n      widenScalarDst(MI, WideTy, 0);\n      Observer.changedInstr(MI);\n      return Legalized;\n    }\n\n    Register SrcReg = MI.getOperand(1).getReg();\n\n    // First ZEXT the input.\n    auto MIBSrc = MIRBuilder.buildZExt(WideTy, SrcReg);\n    LLT CurTy = MRI.getType(SrcReg);\n    if (MI.getOpcode() == TargetOpcode::G_CTTZ) {\n      // The count is the same in the larger type except if the original\n      // value was zero.  This can be handled by setting the bit just off\n      // the top of the original type.\n      auto TopBit =\n          APInt::getOneBitSet(WideTy.getSizeInBits(), CurTy.getSizeInBits());\n      MIBSrc = MIRBuilder.buildOr(\n        WideTy, MIBSrc, MIRBuilder.buildConstant(WideTy, TopBit));\n    }\n\n    // Perform the operation at the larger size.\n    auto MIBNewOp = MIRBuilder.buildInstr(MI.getOpcode(), {WideTy}, {MIBSrc});\n    // This is already the correct result for CTPOP and CTTZs\n    if (MI.getOpcode() == TargetOpcode::G_CTLZ ||\n        MI.getOpcode() == TargetOpcode::G_CTLZ_ZERO_UNDEF) {\n      // The correct result is NewOp - (Difference in widety and current ty).\n      unsigned SizeDiff = WideTy.getSizeInBits() - CurTy.getSizeInBits();\n      MIBNewOp = MIRBuilder.buildSub(\n          WideTy, MIBNewOp, MIRBuilder.buildConstant(WideTy, SizeDiff));\n    }\n\n    MIRBuilder.buildZExtOrTrunc(MI.getOperand(0), MIBNewOp);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case TargetOpcode::G_BSWAP: {\n    Observer.changingInstr(MI);\n    Register DstReg = MI.getOperand(0).getReg();\n\n    Register ShrReg = MRI.createGenericVirtualRegister(WideTy);\n    Register DstExt = MRI.createGenericVirtualRegister(WideTy);\n    Register ShiftAmtReg = MRI.createGenericVirtualRegister(WideTy);\n    widenScalarSrc(MI, WideTy, 1, TargetOpcode::G_ANYEXT);\n\n    MI.getOperand(0).setReg(DstExt);\n\n    MIRBuilder.setInsertPt(MIRBuilder.getMBB(), ++MIRBuilder.getInsertPt());\n\n    LLT Ty = MRI.getType(DstReg);\n    unsigned DiffBits = WideTy.getScalarSizeInBits() - Ty.getScalarSizeInBits();\n    MIRBuilder.buildConstant(ShiftAmtReg, DiffBits);\n    MIRBuilder.buildLShr(ShrReg, DstExt, ShiftAmtReg);\n\n    MIRBuilder.buildTrunc(DstReg, ShrReg);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_BITREVERSE: {\n    Observer.changingInstr(MI);\n\n    Register DstReg = MI.getOperand(0).getReg();\n    LLT Ty = MRI.getType(DstReg);\n    unsigned DiffBits = WideTy.getScalarSizeInBits() - Ty.getScalarSizeInBits();\n\n    Register DstExt = MRI.createGenericVirtualRegister(WideTy);\n    widenScalarSrc(MI, WideTy, 1, TargetOpcode::G_ANYEXT);\n    MI.getOperand(0).setReg(DstExt);\n    MIRBuilder.setInsertPt(MIRBuilder.getMBB(), ++MIRBuilder.getInsertPt());\n\n    auto ShiftAmt = MIRBuilder.buildConstant(WideTy, DiffBits);\n    auto Shift = MIRBuilder.buildLShr(WideTy, DstExt, ShiftAmt);\n    MIRBuilder.buildTrunc(DstReg, Shift);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_FREEZE:\n    Observer.changingInstr(MI);\n    widenScalarSrc(MI, WideTy, 1, TargetOpcode::G_ANYEXT);\n    widenScalarDst(MI, WideTy);\n    Observer.changedInstr(MI);\n    return Legalized;\n\n  case TargetOpcode::G_ADD:\n  case TargetOpcode::G_AND:\n  case TargetOpcode::G_MUL:\n  case TargetOpcode::G_OR:\n  case TargetOpcode::G_XOR:\n  case TargetOpcode::G_SUB:\n    // Perform operation at larger width (any extension is fines here, high bits\n    // don't affect the result) and then truncate the result back to the\n    // original type.\n    Observer.changingInstr(MI);\n    widenScalarSrc(MI, WideTy, 1, TargetOpcode::G_ANYEXT);\n    widenScalarSrc(MI, WideTy, 2, TargetOpcode::G_ANYEXT);\n    widenScalarDst(MI, WideTy);\n    Observer.changedInstr(MI);\n    return Legalized;\n\n  case TargetOpcode::G_SHL:\n    Observer.changingInstr(MI);\n\n    if (TypeIdx == 0) {\n      widenScalarSrc(MI, WideTy, 1, TargetOpcode::G_ANYEXT);\n      widenScalarDst(MI, WideTy);\n    } else {\n      assert(TypeIdx == 1);\n      // The \"number of bits to shift\" operand must preserve its value as an\n      // unsigned integer:\n      widenScalarSrc(MI, WideTy, 2, TargetOpcode::G_ZEXT);\n    }\n\n    Observer.changedInstr(MI);\n    return Legalized;\n\n  case TargetOpcode::G_SDIV:\n  case TargetOpcode::G_SREM:\n  case TargetOpcode::G_SMIN:\n  case TargetOpcode::G_SMAX:\n    Observer.changingInstr(MI);\n    widenScalarSrc(MI, WideTy, 1, TargetOpcode::G_SEXT);\n    widenScalarSrc(MI, WideTy, 2, TargetOpcode::G_SEXT);\n    widenScalarDst(MI, WideTy);\n    Observer.changedInstr(MI);\n    return Legalized;\n\n  case TargetOpcode::G_ASHR:\n  case TargetOpcode::G_LSHR:\n    Observer.changingInstr(MI);\n\n    if (TypeIdx == 0) {\n      unsigned CvtOp = MI.getOpcode() == TargetOpcode::G_ASHR ?\n        TargetOpcode::G_SEXT : TargetOpcode::G_ZEXT;\n\n      widenScalarSrc(MI, WideTy, 1, CvtOp);\n      widenScalarDst(MI, WideTy);\n    } else {\n      assert(TypeIdx == 1);\n      // The \"number of bits to shift\" operand must preserve its value as an\n      // unsigned integer:\n      widenScalarSrc(MI, WideTy, 2, TargetOpcode::G_ZEXT);\n    }\n\n    Observer.changedInstr(MI);\n    return Legalized;\n  case TargetOpcode::G_UDIV:\n  case TargetOpcode::G_UREM:\n  case TargetOpcode::G_UMIN:\n  case TargetOpcode::G_UMAX:\n    Observer.changingInstr(MI);\n    widenScalarSrc(MI, WideTy, 1, TargetOpcode::G_ZEXT);\n    widenScalarSrc(MI, WideTy, 2, TargetOpcode::G_ZEXT);\n    widenScalarDst(MI, WideTy);\n    Observer.changedInstr(MI);\n    return Legalized;\n\n  case TargetOpcode::G_SELECT:\n    Observer.changingInstr(MI);\n    if (TypeIdx == 0) {\n      // Perform operation at larger width (any extension is fine here, high\n      // bits don't affect the result) and then truncate the result back to the\n      // original type.\n      widenScalarSrc(MI, WideTy, 2, TargetOpcode::G_ANYEXT);\n      widenScalarSrc(MI, WideTy, 3, TargetOpcode::G_ANYEXT);\n      widenScalarDst(MI, WideTy);\n    } else {\n      bool IsVec = MRI.getType(MI.getOperand(1).getReg()).isVector();\n      // Explicit extension is required here since high bits affect the result.\n      widenScalarSrc(MI, WideTy, 1, MIRBuilder.getBoolExtOp(IsVec, false));\n    }\n    Observer.changedInstr(MI);\n    return Legalized;\n\n  case TargetOpcode::G_FPTOSI:\n  case TargetOpcode::G_FPTOUI:\n    Observer.changingInstr(MI);\n\n    if (TypeIdx == 0)\n      widenScalarDst(MI, WideTy);\n    else\n      widenScalarSrc(MI, WideTy, 1, TargetOpcode::G_FPEXT);\n\n    Observer.changedInstr(MI);\n    return Legalized;\n  case TargetOpcode::G_SITOFP:\n    Observer.changingInstr(MI);\n\n    if (TypeIdx == 0)\n      widenScalarDst(MI, WideTy, 0, TargetOpcode::G_FPTRUNC);\n    else\n      widenScalarSrc(MI, WideTy, 1, TargetOpcode::G_SEXT);\n\n    Observer.changedInstr(MI);\n    return Legalized;\n  case TargetOpcode::G_UITOFP:\n    Observer.changingInstr(MI);\n\n    if (TypeIdx == 0)\n      widenScalarDst(MI, WideTy, 0, TargetOpcode::G_FPTRUNC);\n    else\n      widenScalarSrc(MI, WideTy, 1, TargetOpcode::G_ZEXT);\n\n    Observer.changedInstr(MI);\n    return Legalized;\n  case TargetOpcode::G_LOAD:\n  case TargetOpcode::G_SEXTLOAD:\n  case TargetOpcode::G_ZEXTLOAD:\n    Observer.changingInstr(MI);\n    widenScalarDst(MI, WideTy);\n    Observer.changedInstr(MI);\n    return Legalized;\n\n  case TargetOpcode::G_STORE: {\n    if (TypeIdx != 0)\n      return UnableToLegalize;\n\n    LLT Ty = MRI.getType(MI.getOperand(0).getReg());\n    if (!Ty.isScalar())\n      return UnableToLegalize;\n\n    Observer.changingInstr(MI);\n\n    unsigned ExtType = Ty.getScalarSizeInBits() == 1 ?\n      TargetOpcode::G_ZEXT : TargetOpcode::G_ANYEXT;\n    widenScalarSrc(MI, WideTy, 0, ExtType);\n\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_CONSTANT: {\n    MachineOperand &SrcMO = MI.getOperand(1);\n    LLVMContext &Ctx = MIRBuilder.getMF().getFunction().getContext();\n    unsigned ExtOpc = LI.getExtOpcodeForWideningConstant(\n        MRI.getType(MI.getOperand(0).getReg()));\n    assert((ExtOpc == TargetOpcode::G_ZEXT || ExtOpc == TargetOpcode::G_SEXT ||\n            ExtOpc == TargetOpcode::G_ANYEXT) &&\n           \"Illegal Extend\");\n    const APInt &SrcVal = SrcMO.getCImm()->getValue();\n    const APInt &Val = (ExtOpc == TargetOpcode::G_SEXT)\n                           ? SrcVal.sext(WideTy.getSizeInBits())\n                           : SrcVal.zext(WideTy.getSizeInBits());\n    Observer.changingInstr(MI);\n    SrcMO.setCImm(ConstantInt::get(Ctx, Val));\n\n    widenScalarDst(MI, WideTy);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_FCONSTANT: {\n    MachineOperand &SrcMO = MI.getOperand(1);\n    LLVMContext &Ctx = MIRBuilder.getMF().getFunction().getContext();\n    APFloat Val = SrcMO.getFPImm()->getValueAPF();\n    bool LosesInfo;\n    switch (WideTy.getSizeInBits()) {\n    case 32:\n      Val.convert(APFloat::IEEEsingle(), APFloat::rmNearestTiesToEven,\n                  &LosesInfo);\n      break;\n    case 64:\n      Val.convert(APFloat::IEEEdouble(), APFloat::rmNearestTiesToEven,\n                  &LosesInfo);\n      break;\n    default:\n      return UnableToLegalize;\n    }\n\n    assert(!LosesInfo && \"extend should always be lossless\");\n\n    Observer.changingInstr(MI);\n    SrcMO.setFPImm(ConstantFP::get(Ctx, Val));\n\n    widenScalarDst(MI, WideTy, 0, TargetOpcode::G_FPTRUNC);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_IMPLICIT_DEF: {\n    Observer.changingInstr(MI);\n    widenScalarDst(MI, WideTy);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_BRCOND:\n    Observer.changingInstr(MI);\n    widenScalarSrc(MI, WideTy, 0, MIRBuilder.getBoolExtOp(false, false));\n    Observer.changedInstr(MI);\n    return Legalized;\n\n  case TargetOpcode::G_FCMP:\n    Observer.changingInstr(MI);\n    if (TypeIdx == 0)\n      widenScalarDst(MI, WideTy);\n    else {\n      widenScalarSrc(MI, WideTy, 2, TargetOpcode::G_FPEXT);\n      widenScalarSrc(MI, WideTy, 3, TargetOpcode::G_FPEXT);\n    }\n    Observer.changedInstr(MI);\n    return Legalized;\n\n  case TargetOpcode::G_ICMP:\n    Observer.changingInstr(MI);\n    if (TypeIdx == 0)\n      widenScalarDst(MI, WideTy);\n    else {\n      unsigned ExtOpcode = CmpInst::isSigned(static_cast<CmpInst::Predicate>(\n                               MI.getOperand(1).getPredicate()))\n                               ? TargetOpcode::G_SEXT\n                               : TargetOpcode::G_ZEXT;\n      widenScalarSrc(MI, WideTy, 2, ExtOpcode);\n      widenScalarSrc(MI, WideTy, 3, ExtOpcode);\n    }\n    Observer.changedInstr(MI);\n    return Legalized;\n\n  case TargetOpcode::G_PTR_ADD:\n    assert(TypeIdx == 1 && \"unable to legalize pointer of G_PTR_ADD\");\n    Observer.changingInstr(MI);\n    widenScalarSrc(MI, WideTy, 2, TargetOpcode::G_SEXT);\n    Observer.changedInstr(MI);\n    return Legalized;\n\n  case TargetOpcode::G_PHI: {\n    assert(TypeIdx == 0 && \"Expecting only Idx 0\");\n\n    Observer.changingInstr(MI);\n    for (unsigned I = 1; I < MI.getNumOperands(); I += 2) {\n      MachineBasicBlock &OpMBB = *MI.getOperand(I + 1).getMBB();\n      MIRBuilder.setInsertPt(OpMBB, OpMBB.getFirstTerminator());\n      widenScalarSrc(MI, WideTy, I, TargetOpcode::G_ANYEXT);\n    }\n\n    MachineBasicBlock &MBB = *MI.getParent();\n    MIRBuilder.setInsertPt(MBB, --MBB.getFirstNonPHI());\n    widenScalarDst(MI, WideTy);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_EXTRACT_VECTOR_ELT: {\n    if (TypeIdx == 0) {\n      Register VecReg = MI.getOperand(1).getReg();\n      LLT VecTy = MRI.getType(VecReg);\n      Observer.changingInstr(MI);\n\n      widenScalarSrc(MI, LLT::vector(VecTy.getNumElements(),\n                                     WideTy.getSizeInBits()),\n                     1, TargetOpcode::G_SEXT);\n\n      widenScalarDst(MI, WideTy, 0);\n      Observer.changedInstr(MI);\n      return Legalized;\n    }\n\n    if (TypeIdx != 2)\n      return UnableToLegalize;\n    Observer.changingInstr(MI);\n    // TODO: Probably should be zext\n    widenScalarSrc(MI, WideTy, 2, TargetOpcode::G_SEXT);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_INSERT_VECTOR_ELT: {\n    if (TypeIdx == 1) {\n      Observer.changingInstr(MI);\n\n      Register VecReg = MI.getOperand(1).getReg();\n      LLT VecTy = MRI.getType(VecReg);\n      LLT WideVecTy = LLT::vector(VecTy.getNumElements(), WideTy);\n\n      widenScalarSrc(MI, WideVecTy, 1, TargetOpcode::G_ANYEXT);\n      widenScalarSrc(MI, WideTy, 2, TargetOpcode::G_ANYEXT);\n      widenScalarDst(MI, WideVecTy, 0);\n      Observer.changedInstr(MI);\n      return Legalized;\n    }\n\n    if (TypeIdx == 2) {\n      Observer.changingInstr(MI);\n      // TODO: Probably should be zext\n      widenScalarSrc(MI, WideTy, 3, TargetOpcode::G_SEXT);\n      Observer.changedInstr(MI);\n      return Legalized;\n    }\n\n    return UnableToLegalize;\n  }\n  case TargetOpcode::G_FADD:\n  case TargetOpcode::G_FMUL:\n  case TargetOpcode::G_FSUB:\n  case TargetOpcode::G_FMA:\n  case TargetOpcode::G_FMAD:\n  case TargetOpcode::G_FNEG:\n  case TargetOpcode::G_FABS:\n  case TargetOpcode::G_FCANONICALIZE:\n  case TargetOpcode::G_FMINNUM:\n  case TargetOpcode::G_FMAXNUM:\n  case TargetOpcode::G_FMINNUM_IEEE:\n  case TargetOpcode::G_FMAXNUM_IEEE:\n  case TargetOpcode::G_FMINIMUM:\n  case TargetOpcode::G_FMAXIMUM:\n  case TargetOpcode::G_FDIV:\n  case TargetOpcode::G_FREM:\n  case TargetOpcode::G_FCEIL:\n  case TargetOpcode::G_FFLOOR:\n  case TargetOpcode::G_FCOS:\n  case TargetOpcode::G_FSIN:\n  case TargetOpcode::G_FLOG10:\n  case TargetOpcode::G_FLOG:\n  case TargetOpcode::G_FLOG2:\n  case TargetOpcode::G_FRINT:\n  case TargetOpcode::G_FNEARBYINT:\n  case TargetOpcode::G_FSQRT:\n  case TargetOpcode::G_FEXP:\n  case TargetOpcode::G_FEXP2:\n  case TargetOpcode::G_FPOW:\n  case TargetOpcode::G_INTRINSIC_TRUNC:\n  case TargetOpcode::G_INTRINSIC_ROUND:\n  case TargetOpcode::G_INTRINSIC_ROUNDEVEN:\n    assert(TypeIdx == 0);\n    Observer.changingInstr(MI);\n\n    for (unsigned I = 1, E = MI.getNumOperands(); I != E; ++I)\n      widenScalarSrc(MI, WideTy, I, TargetOpcode::G_FPEXT);\n\n    widenScalarDst(MI, WideTy, 0, TargetOpcode::G_FPTRUNC);\n    Observer.changedInstr(MI);\n    return Legalized;\n  case TargetOpcode::G_FPOWI: {\n    if (TypeIdx != 0)\n      return UnableToLegalize;\n    Observer.changingInstr(MI);\n    widenScalarSrc(MI, WideTy, 1, TargetOpcode::G_FPEXT);\n    widenScalarDst(MI, WideTy, 0, TargetOpcode::G_FPTRUNC);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_INTTOPTR:\n    if (TypeIdx != 1)\n      return UnableToLegalize;\n\n    Observer.changingInstr(MI);\n    widenScalarSrc(MI, WideTy, 1, TargetOpcode::G_ZEXT);\n    Observer.changedInstr(MI);\n    return Legalized;\n  case TargetOpcode::G_PTRTOINT:\n    if (TypeIdx != 0)\n      return UnableToLegalize;\n\n    Observer.changingInstr(MI);\n    widenScalarDst(MI, WideTy, 0);\n    Observer.changedInstr(MI);\n    return Legalized;\n  case TargetOpcode::G_BUILD_VECTOR: {\n    Observer.changingInstr(MI);\n\n    const LLT WideEltTy = TypeIdx == 1 ? WideTy : WideTy.getElementType();\n    for (int I = 1, E = MI.getNumOperands(); I != E; ++I)\n      widenScalarSrc(MI, WideEltTy, I, TargetOpcode::G_ANYEXT);\n\n    // Avoid changing the result vector type if the source element type was\n    // requested.\n    if (TypeIdx == 1) {\n      MI.setDesc(MIRBuilder.getTII().get(TargetOpcode::G_BUILD_VECTOR_TRUNC));\n    } else {\n      widenScalarDst(MI, WideTy, 0);\n    }\n\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_SEXT_INREG:\n    if (TypeIdx != 0)\n      return UnableToLegalize;\n\n    Observer.changingInstr(MI);\n    widenScalarSrc(MI, WideTy, 1, TargetOpcode::G_ANYEXT);\n    widenScalarDst(MI, WideTy, 0, TargetOpcode::G_TRUNC);\n    Observer.changedInstr(MI);\n    return Legalized;\n  case TargetOpcode::G_PTRMASK: {\n    if (TypeIdx != 1)\n      return UnableToLegalize;\n    Observer.changingInstr(MI);\n    widenScalarSrc(MI, WideTy, 2, TargetOpcode::G_ZEXT);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  }\n}\n\nstatic void getUnmergePieces(SmallVectorImpl<Register> &Pieces,\n                             MachineIRBuilder &B, Register Src, LLT Ty) {\n  auto Unmerge = B.buildUnmerge(Ty, Src);\n  for (int I = 0, E = Unmerge->getNumOperands() - 1; I != E; ++I)\n    Pieces.push_back(Unmerge.getReg(I));\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerBitcast(MachineInstr &MI) {\n  Register Dst = MI.getOperand(0).getReg();\n  Register Src = MI.getOperand(1).getReg();\n  LLT DstTy = MRI.getType(Dst);\n  LLT SrcTy = MRI.getType(Src);\n\n  if (SrcTy.isVector()) {\n    LLT SrcEltTy = SrcTy.getElementType();\n    SmallVector<Register, 8> SrcRegs;\n\n    if (DstTy.isVector()) {\n      int NumDstElt = DstTy.getNumElements();\n      int NumSrcElt = SrcTy.getNumElements();\n\n      LLT DstEltTy = DstTy.getElementType();\n      LLT DstCastTy = DstEltTy; // Intermediate bitcast result type\n      LLT SrcPartTy = SrcEltTy; // Original unmerge result type.\n\n      // If there's an element size mismatch, insert intermediate casts to match\n      // the result element type.\n      if (NumSrcElt < NumDstElt) { // Source element type is larger.\n        // %1:_(<4 x s8>) = G_BITCAST %0:_(<2 x s16>)\n        //\n        // =>\n        //\n        // %2:_(s16), %3:_(s16) = G_UNMERGE_VALUES %0\n        // %3:_(<2 x s8>) = G_BITCAST %2\n        // %4:_(<2 x s8>) = G_BITCAST %3\n        // %1:_(<4 x s16>) = G_CONCAT_VECTORS %3, %4\n        DstCastTy = LLT::vector(NumDstElt / NumSrcElt, DstEltTy);\n        SrcPartTy = SrcEltTy;\n      } else if (NumSrcElt > NumDstElt) { // Source element type is smaller.\n        //\n        // %1:_(<2 x s16>) = G_BITCAST %0:_(<4 x s8>)\n        //\n        // =>\n        //\n        // %2:_(<2 x s8>), %3:_(<2 x s8>) = G_UNMERGE_VALUES %0\n        // %3:_(s16) = G_BITCAST %2\n        // %4:_(s16) = G_BITCAST %3\n        // %1:_(<2 x s16>) = G_BUILD_VECTOR %3, %4\n        SrcPartTy = LLT::vector(NumSrcElt / NumDstElt, SrcEltTy);\n        DstCastTy = DstEltTy;\n      }\n\n      getUnmergePieces(SrcRegs, MIRBuilder, Src, SrcPartTy);\n      for (Register &SrcReg : SrcRegs)\n        SrcReg = MIRBuilder.buildBitcast(DstCastTy, SrcReg).getReg(0);\n    } else\n      getUnmergePieces(SrcRegs, MIRBuilder, Src, SrcEltTy);\n\n    MIRBuilder.buildMerge(Dst, SrcRegs);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  if (DstTy.isVector()) {\n    SmallVector<Register, 8> SrcRegs;\n    getUnmergePieces(SrcRegs, MIRBuilder, Src, DstTy.getElementType());\n    MIRBuilder.buildMerge(Dst, SrcRegs);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  return UnableToLegalize;\n}\n\n/// Figure out the bit offset into a register when coercing a vector index for\n/// the wide element type. This is only for the case when promoting vector to\n/// one with larger elements.\n//\n///\n/// %offset_idx = G_AND %idx, ~(-1 << Log2(DstEltSize / SrcEltSize))\n/// %offset_bits = G_SHL %offset_idx, Log2(SrcEltSize)\nstatic Register getBitcastWiderVectorElementOffset(MachineIRBuilder &B,\n                                                   Register Idx,\n                                                   unsigned NewEltSize,\n                                                   unsigned OldEltSize) {\n  const unsigned Log2EltRatio = Log2_32(NewEltSize / OldEltSize);\n  LLT IdxTy = B.getMRI()->getType(Idx);\n\n  // Now figure out the amount we need to shift to get the target bits.\n  auto OffsetMask = B.buildConstant(\n    IdxTy, ~(APInt::getAllOnesValue(IdxTy.getSizeInBits()) << Log2EltRatio));\n  auto OffsetIdx = B.buildAnd(IdxTy, Idx, OffsetMask);\n  return B.buildShl(IdxTy, OffsetIdx,\n                    B.buildConstant(IdxTy, Log2_32(OldEltSize))).getReg(0);\n}\n\n/// Perform a G_EXTRACT_VECTOR_ELT in a different sized vector element. If this\n/// is casting to a vector with a smaller element size, perform multiple element\n/// extracts and merge the results. If this is coercing to a vector with larger\n/// elements, index the bitcasted vector and extract the target element with bit\n/// operations. This is intended to force the indexing in the native register\n/// size for architectures that can dynamically index the register file.\nLegalizerHelper::LegalizeResult\nLegalizerHelper::bitcastExtractVectorElt(MachineInstr &MI, unsigned TypeIdx,\n                                         LLT CastTy) {\n  if (TypeIdx != 1)\n    return UnableToLegalize;\n\n  Register Dst = MI.getOperand(0).getReg();\n  Register SrcVec = MI.getOperand(1).getReg();\n  Register Idx = MI.getOperand(2).getReg();\n  LLT SrcVecTy = MRI.getType(SrcVec);\n  LLT IdxTy = MRI.getType(Idx);\n\n  LLT SrcEltTy = SrcVecTy.getElementType();\n  unsigned NewNumElts = CastTy.isVector() ? CastTy.getNumElements() : 1;\n  unsigned OldNumElts = SrcVecTy.getNumElements();\n\n  LLT NewEltTy = CastTy.isVector() ? CastTy.getElementType() : CastTy;\n  Register CastVec = MIRBuilder.buildBitcast(CastTy, SrcVec).getReg(0);\n\n  const unsigned NewEltSize = NewEltTy.getSizeInBits();\n  const unsigned OldEltSize = SrcEltTy.getSizeInBits();\n  if (NewNumElts > OldNumElts) {\n    // Decreasing the vector element size\n    //\n    // e.g. i64 = extract_vector_elt x:v2i64, y:i32\n    //  =>\n    //  v4i32:castx = bitcast x:v2i64\n    //\n    // i64 = bitcast\n    //   (v2i32 build_vector (i32 (extract_vector_elt castx, (2 * y))),\n    //                       (i32 (extract_vector_elt castx, (2 * y + 1)))\n    //\n    if (NewNumElts % OldNumElts != 0)\n      return UnableToLegalize;\n\n    // Type of the intermediate result vector.\n    const unsigned NewEltsPerOldElt = NewNumElts / OldNumElts;\n    LLT MidTy = LLT::scalarOrVector(NewEltsPerOldElt, NewEltTy);\n\n    auto NewEltsPerOldEltK = MIRBuilder.buildConstant(IdxTy, NewEltsPerOldElt);\n\n    SmallVector<Register, 8> NewOps(NewEltsPerOldElt);\n    auto NewBaseIdx = MIRBuilder.buildMul(IdxTy, Idx, NewEltsPerOldEltK);\n\n    for (unsigned I = 0; I < NewEltsPerOldElt; ++I) {\n      auto IdxOffset = MIRBuilder.buildConstant(IdxTy, I);\n      auto TmpIdx = MIRBuilder.buildAdd(IdxTy, NewBaseIdx, IdxOffset);\n      auto Elt = MIRBuilder.buildExtractVectorElement(NewEltTy, CastVec, TmpIdx);\n      NewOps[I] = Elt.getReg(0);\n    }\n\n    auto NewVec = MIRBuilder.buildBuildVector(MidTy, NewOps);\n    MIRBuilder.buildBitcast(Dst, NewVec);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  if (NewNumElts < OldNumElts) {\n    if (NewEltSize % OldEltSize != 0)\n      return UnableToLegalize;\n\n    // This only depends on powers of 2 because we use bit tricks to figure out\n    // the bit offset we need to shift to get the target element. A general\n    // expansion could emit division/multiply.\n    if (!isPowerOf2_32(NewEltSize / OldEltSize))\n      return UnableToLegalize;\n\n    // Increasing the vector element size.\n    // %elt:_(small_elt) = G_EXTRACT_VECTOR_ELT %vec:_(<N x small_elt>), %idx\n    //\n    //   =>\n    //\n    // %cast = G_BITCAST %vec\n    // %scaled_idx = G_LSHR %idx, Log2(DstEltSize / SrcEltSize)\n    // %wide_elt  = G_EXTRACT_VECTOR_ELT %cast, %scaled_idx\n    // %offset_idx = G_AND %idx, ~(-1 << Log2(DstEltSize / SrcEltSize))\n    // %offset_bits = G_SHL %offset_idx, Log2(SrcEltSize)\n    // %elt_bits = G_LSHR %wide_elt, %offset_bits\n    // %elt = G_TRUNC %elt_bits\n\n    const unsigned Log2EltRatio = Log2_32(NewEltSize / OldEltSize);\n    auto Log2Ratio = MIRBuilder.buildConstant(IdxTy, Log2EltRatio);\n\n    // Divide to get the index in the wider element type.\n    auto ScaledIdx = MIRBuilder.buildLShr(IdxTy, Idx, Log2Ratio);\n\n    Register WideElt = CastVec;\n    if (CastTy.isVector()) {\n      WideElt = MIRBuilder.buildExtractVectorElement(NewEltTy, CastVec,\n                                                     ScaledIdx).getReg(0);\n    }\n\n    // Compute the bit offset into the register of the target element.\n    Register OffsetBits = getBitcastWiderVectorElementOffset(\n      MIRBuilder, Idx, NewEltSize, OldEltSize);\n\n    // Shift the wide element to get the target element.\n    auto ExtractedBits = MIRBuilder.buildLShr(NewEltTy, WideElt, OffsetBits);\n    MIRBuilder.buildTrunc(Dst, ExtractedBits);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  return UnableToLegalize;\n}\n\n/// Emit code to insert \\p InsertReg into \\p TargetRet at \\p OffsetBits in \\p\n/// TargetReg, while preserving other bits in \\p TargetReg.\n///\n/// (InsertReg << Offset) | (TargetReg & ~(-1 >> InsertReg.size()) << Offset)\nstatic Register buildBitFieldInsert(MachineIRBuilder &B,\n                                    Register TargetReg, Register InsertReg,\n                                    Register OffsetBits) {\n  LLT TargetTy = B.getMRI()->getType(TargetReg);\n  LLT InsertTy = B.getMRI()->getType(InsertReg);\n  auto ZextVal = B.buildZExt(TargetTy, InsertReg);\n  auto ShiftedInsertVal = B.buildShl(TargetTy, ZextVal, OffsetBits);\n\n  // Produce a bitmask of the value to insert\n  auto EltMask = B.buildConstant(\n    TargetTy, APInt::getLowBitsSet(TargetTy.getSizeInBits(),\n                                   InsertTy.getSizeInBits()));\n  // Shift it into position\n  auto ShiftedMask = B.buildShl(TargetTy, EltMask, OffsetBits);\n  auto InvShiftedMask = B.buildNot(TargetTy, ShiftedMask);\n\n  // Clear out the bits in the wide element\n  auto MaskedOldElt = B.buildAnd(TargetTy, TargetReg, InvShiftedMask);\n\n  // The value to insert has all zeros already, so stick it into the masked\n  // wide element.\n  return B.buildOr(TargetTy, MaskedOldElt, ShiftedInsertVal).getReg(0);\n}\n\n/// Perform a G_INSERT_VECTOR_ELT in a different sized vector element. If this\n/// is increasing the element size, perform the indexing in the target element\n/// type, and use bit operations to insert at the element position. This is\n/// intended for architectures that can dynamically index the register file and\n/// want to force indexing in the native register size.\nLegalizerHelper::LegalizeResult\nLegalizerHelper::bitcastInsertVectorElt(MachineInstr &MI, unsigned TypeIdx,\n                                        LLT CastTy) {\n  if (TypeIdx != 0)\n    return UnableToLegalize;\n\n  Register Dst = MI.getOperand(0).getReg();\n  Register SrcVec = MI.getOperand(1).getReg();\n  Register Val = MI.getOperand(2).getReg();\n  Register Idx = MI.getOperand(3).getReg();\n\n  LLT VecTy = MRI.getType(Dst);\n  LLT IdxTy = MRI.getType(Idx);\n\n  LLT VecEltTy = VecTy.getElementType();\n  LLT NewEltTy = CastTy.isVector() ? CastTy.getElementType() : CastTy;\n  const unsigned NewEltSize = NewEltTy.getSizeInBits();\n  const unsigned OldEltSize = VecEltTy.getSizeInBits();\n\n  unsigned NewNumElts = CastTy.isVector() ? CastTy.getNumElements() : 1;\n  unsigned OldNumElts = VecTy.getNumElements();\n\n  Register CastVec = MIRBuilder.buildBitcast(CastTy, SrcVec).getReg(0);\n  if (NewNumElts < OldNumElts) {\n    if (NewEltSize % OldEltSize != 0)\n      return UnableToLegalize;\n\n    // This only depends on powers of 2 because we use bit tricks to figure out\n    // the bit offset we need to shift to get the target element. A general\n    // expansion could emit division/multiply.\n    if (!isPowerOf2_32(NewEltSize / OldEltSize))\n      return UnableToLegalize;\n\n    const unsigned Log2EltRatio = Log2_32(NewEltSize / OldEltSize);\n    auto Log2Ratio = MIRBuilder.buildConstant(IdxTy, Log2EltRatio);\n\n    // Divide to get the index in the wider element type.\n    auto ScaledIdx = MIRBuilder.buildLShr(IdxTy, Idx, Log2Ratio);\n\n    Register ExtractedElt = CastVec;\n    if (CastTy.isVector()) {\n      ExtractedElt = MIRBuilder.buildExtractVectorElement(NewEltTy, CastVec,\n                                                          ScaledIdx).getReg(0);\n    }\n\n    // Compute the bit offset into the register of the target element.\n    Register OffsetBits = getBitcastWiderVectorElementOffset(\n      MIRBuilder, Idx, NewEltSize, OldEltSize);\n\n    Register InsertedElt = buildBitFieldInsert(MIRBuilder, ExtractedElt,\n                                               Val, OffsetBits);\n    if (CastTy.isVector()) {\n      InsertedElt = MIRBuilder.buildInsertVectorElement(\n        CastTy, CastVec, InsertedElt, ScaledIdx).getReg(0);\n    }\n\n    MIRBuilder.buildBitcast(Dst, InsertedElt);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  return UnableToLegalize;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerLoad(MachineInstr &MI) {\n  // Lower to a memory-width G_LOAD and a G_SEXT/G_ZEXT/G_ANYEXT\n  Register DstReg = MI.getOperand(0).getReg();\n  Register PtrReg = MI.getOperand(1).getReg();\n  LLT DstTy = MRI.getType(DstReg);\n  auto &MMO = **MI.memoperands_begin();\n\n  if (DstTy.getSizeInBits() == MMO.getSizeInBits()) {\n    if (MI.getOpcode() == TargetOpcode::G_LOAD) {\n      // This load needs splitting into power of 2 sized loads.\n      if (DstTy.isVector())\n        return UnableToLegalize;\n      if (isPowerOf2_32(DstTy.getSizeInBits()))\n        return UnableToLegalize; // Don't know what we're being asked to do.\n\n      // Our strategy here is to generate anyextending loads for the smaller\n      // types up to next power-2 result type, and then combine the two larger\n      // result values together, before truncating back down to the non-pow-2\n      // type.\n      // E.g. v1 = i24 load =>\n      // v2 = i32 zextload (2 byte)\n      // v3 = i32 load (1 byte)\n      // v4 = i32 shl v3, 16\n      // v5 = i32 or v4, v2\n      // v1 = i24 trunc v5\n      // By doing this we generate the correct truncate which should get\n      // combined away as an artifact with a matching extend.\n      uint64_t LargeSplitSize = PowerOf2Floor(DstTy.getSizeInBits());\n      uint64_t SmallSplitSize = DstTy.getSizeInBits() - LargeSplitSize;\n\n      MachineFunction &MF = MIRBuilder.getMF();\n      MachineMemOperand *LargeMMO =\n        MF.getMachineMemOperand(&MMO, 0, LargeSplitSize / 8);\n      MachineMemOperand *SmallMMO = MF.getMachineMemOperand(\n        &MMO, LargeSplitSize / 8, SmallSplitSize / 8);\n\n      LLT PtrTy = MRI.getType(PtrReg);\n      unsigned AnyExtSize = NextPowerOf2(DstTy.getSizeInBits());\n      LLT AnyExtTy = LLT::scalar(AnyExtSize);\n      Register LargeLdReg = MRI.createGenericVirtualRegister(AnyExtTy);\n      Register SmallLdReg = MRI.createGenericVirtualRegister(AnyExtTy);\n      auto LargeLoad = MIRBuilder.buildLoadInstr(\n        TargetOpcode::G_ZEXTLOAD, LargeLdReg, PtrReg, *LargeMMO);\n\n      auto OffsetCst = MIRBuilder.buildConstant(\n        LLT::scalar(PtrTy.getSizeInBits()), LargeSplitSize / 8);\n      Register PtrAddReg = MRI.createGenericVirtualRegister(PtrTy);\n      auto SmallPtr =\n        MIRBuilder.buildPtrAdd(PtrAddReg, PtrReg, OffsetCst.getReg(0));\n      auto SmallLoad = MIRBuilder.buildLoad(SmallLdReg, SmallPtr.getReg(0),\n                                            *SmallMMO);\n\n      auto ShiftAmt = MIRBuilder.buildConstant(AnyExtTy, LargeSplitSize);\n      auto Shift = MIRBuilder.buildShl(AnyExtTy, SmallLoad, ShiftAmt);\n      auto Or = MIRBuilder.buildOr(AnyExtTy, Shift, LargeLoad);\n      MIRBuilder.buildTrunc(DstReg, {Or.getReg(0)});\n      MI.eraseFromParent();\n      return Legalized;\n    }\n\n    MIRBuilder.buildLoad(DstReg, PtrReg, MMO);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  if (DstTy.isScalar()) {\n    Register TmpReg =\n      MRI.createGenericVirtualRegister(LLT::scalar(MMO.getSizeInBits()));\n    MIRBuilder.buildLoad(TmpReg, PtrReg, MMO);\n    switch (MI.getOpcode()) {\n    default:\n      llvm_unreachable(\"Unexpected opcode\");\n    case TargetOpcode::G_LOAD:\n      MIRBuilder.buildAnyExtOrTrunc(DstReg, TmpReg);\n      break;\n    case TargetOpcode::G_SEXTLOAD:\n      MIRBuilder.buildSExt(DstReg, TmpReg);\n      break;\n    case TargetOpcode::G_ZEXTLOAD:\n      MIRBuilder.buildZExt(DstReg, TmpReg);\n      break;\n    }\n\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  return UnableToLegalize;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerStore(MachineInstr &MI) {\n  // Lower a non-power of 2 store into multiple pow-2 stores.\n  // E.g. split an i24 store into an i16 store + i8 store.\n  // We do this by first extending the stored value to the next largest power\n  // of 2 type, and then using truncating stores to store the components.\n  // By doing this, likewise with G_LOAD, generate an extend that can be\n  // artifact-combined away instead of leaving behind extracts.\n  Register SrcReg = MI.getOperand(0).getReg();\n  Register PtrReg = MI.getOperand(1).getReg();\n  LLT SrcTy = MRI.getType(SrcReg);\n  MachineMemOperand &MMO = **MI.memoperands_begin();\n  if (SrcTy.getSizeInBits() != MMO.getSizeInBits())\n    return UnableToLegalize;\n  if (SrcTy.isVector())\n    return UnableToLegalize;\n  if (isPowerOf2_32(SrcTy.getSizeInBits()))\n    return UnableToLegalize; // Don't know what we're being asked to do.\n\n  // Extend to the next pow-2.\n  const LLT ExtendTy = LLT::scalar(NextPowerOf2(SrcTy.getSizeInBits()));\n  auto ExtVal = MIRBuilder.buildAnyExt(ExtendTy, SrcReg);\n\n  // Obtain the smaller value by shifting away the larger value.\n  uint64_t LargeSplitSize = PowerOf2Floor(SrcTy.getSizeInBits());\n  uint64_t SmallSplitSize = SrcTy.getSizeInBits() - LargeSplitSize;\n  auto ShiftAmt = MIRBuilder.buildConstant(ExtendTy, LargeSplitSize);\n  auto SmallVal = MIRBuilder.buildLShr(ExtendTy, ExtVal, ShiftAmt);\n\n  // Generate the PtrAdd and truncating stores.\n  LLT PtrTy = MRI.getType(PtrReg);\n  auto OffsetCst = MIRBuilder.buildConstant(\n    LLT::scalar(PtrTy.getSizeInBits()), LargeSplitSize / 8);\n  Register PtrAddReg = MRI.createGenericVirtualRegister(PtrTy);\n  auto SmallPtr =\n    MIRBuilder.buildPtrAdd(PtrAddReg, PtrReg, OffsetCst.getReg(0));\n\n  MachineFunction &MF = MIRBuilder.getMF();\n  MachineMemOperand *LargeMMO =\n    MF.getMachineMemOperand(&MMO, 0, LargeSplitSize / 8);\n  MachineMemOperand *SmallMMO =\n    MF.getMachineMemOperand(&MMO, LargeSplitSize / 8, SmallSplitSize / 8);\n  MIRBuilder.buildStore(ExtVal.getReg(0), PtrReg, *LargeMMO);\n  MIRBuilder.buildStore(SmallVal.getReg(0), SmallPtr.getReg(0), *SmallMMO);\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::bitcast(MachineInstr &MI, unsigned TypeIdx, LLT CastTy) {\n  switch (MI.getOpcode()) {\n  case TargetOpcode::G_LOAD: {\n    if (TypeIdx != 0)\n      return UnableToLegalize;\n\n    Observer.changingInstr(MI);\n    bitcastDst(MI, CastTy, 0);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_STORE: {\n    if (TypeIdx != 0)\n      return UnableToLegalize;\n\n    Observer.changingInstr(MI);\n    bitcastSrc(MI, CastTy, 0);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_SELECT: {\n    if (TypeIdx != 0)\n      return UnableToLegalize;\n\n    if (MRI.getType(MI.getOperand(1).getReg()).isVector()) {\n      LLVM_DEBUG(\n          dbgs() << \"bitcast action not implemented for vector select\\n\");\n      return UnableToLegalize;\n    }\n\n    Observer.changingInstr(MI);\n    bitcastSrc(MI, CastTy, 2);\n    bitcastSrc(MI, CastTy, 3);\n    bitcastDst(MI, CastTy, 0);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_AND:\n  case TargetOpcode::G_OR:\n  case TargetOpcode::G_XOR: {\n    Observer.changingInstr(MI);\n    bitcastSrc(MI, CastTy, 1);\n    bitcastSrc(MI, CastTy, 2);\n    bitcastDst(MI, CastTy, 0);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_EXTRACT_VECTOR_ELT:\n    return bitcastExtractVectorElt(MI, TypeIdx, CastTy);\n  case TargetOpcode::G_INSERT_VECTOR_ELT:\n    return bitcastInsertVectorElt(MI, TypeIdx, CastTy);\n  default:\n    return UnableToLegalize;\n  }\n}\n\n// Legalize an instruction by changing the opcode in place.\nvoid LegalizerHelper::changeOpcode(MachineInstr &MI, unsigned NewOpcode) {\n    Observer.changingInstr(MI);\n    MI.setDesc(MIRBuilder.getTII().get(NewOpcode));\n    Observer.changedInstr(MI);\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lower(MachineInstr &MI, unsigned TypeIdx, LLT LowerHintTy) {\n  using namespace TargetOpcode;\n\n  switch(MI.getOpcode()) {\n  default:\n    return UnableToLegalize;\n  case TargetOpcode::G_BITCAST:\n    return lowerBitcast(MI);\n  case TargetOpcode::G_SREM:\n  case TargetOpcode::G_UREM: {\n    LLT Ty = MRI.getType(MI.getOperand(0).getReg());\n    auto Quot =\n        MIRBuilder.buildInstr(MI.getOpcode() == G_SREM ? G_SDIV : G_UDIV, {Ty},\n                              {MI.getOperand(1), MI.getOperand(2)});\n\n    auto Prod = MIRBuilder.buildMul(Ty, Quot, MI.getOperand(2));\n    MIRBuilder.buildSub(MI.getOperand(0), MI.getOperand(1), Prod);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case TargetOpcode::G_SADDO:\n  case TargetOpcode::G_SSUBO:\n    return lowerSADDO_SSUBO(MI);\n  case TargetOpcode::G_UMULH:\n  case TargetOpcode::G_SMULH:\n    return lowerSMULH_UMULH(MI);\n  case TargetOpcode::G_SMULO:\n  case TargetOpcode::G_UMULO: {\n    // Generate G_UMULH/G_SMULH to check for overflow and a normal G_MUL for the\n    // result.\n    Register Res = MI.getOperand(0).getReg();\n    Register Overflow = MI.getOperand(1).getReg();\n    Register LHS = MI.getOperand(2).getReg();\n    Register RHS = MI.getOperand(3).getReg();\n    LLT Ty = MRI.getType(Res);\n\n    unsigned Opcode = MI.getOpcode() == TargetOpcode::G_SMULO\n                          ? TargetOpcode::G_SMULH\n                          : TargetOpcode::G_UMULH;\n\n    Observer.changingInstr(MI);\n    const auto &TII = MIRBuilder.getTII();\n    MI.setDesc(TII.get(TargetOpcode::G_MUL));\n    MI.RemoveOperand(1);\n    Observer.changedInstr(MI);\n\n    auto HiPart = MIRBuilder.buildInstr(Opcode, {Ty}, {LHS, RHS});\n    auto Zero = MIRBuilder.buildConstant(Ty, 0);\n\n    // Move insert point forward so we can use the Res register if needed.\n    MIRBuilder.setInsertPt(MIRBuilder.getMBB(), ++MIRBuilder.getInsertPt());\n\n    // For *signed* multiply, overflow is detected by checking:\n    // (hi != (lo >> bitwidth-1))\n    if (Opcode == TargetOpcode::G_SMULH) {\n      auto ShiftAmt = MIRBuilder.buildConstant(Ty, Ty.getSizeInBits() - 1);\n      auto Shifted = MIRBuilder.buildAShr(Ty, Res, ShiftAmt);\n      MIRBuilder.buildICmp(CmpInst::ICMP_NE, Overflow, HiPart, Shifted);\n    } else {\n      MIRBuilder.buildICmp(CmpInst::ICMP_NE, Overflow, HiPart, Zero);\n    }\n    return Legalized;\n  }\n  case TargetOpcode::G_FNEG: {\n    Register Res = MI.getOperand(0).getReg();\n    LLT Ty = MRI.getType(Res);\n\n    // TODO: Handle vector types once we are able to\n    // represent them.\n    if (Ty.isVector())\n      return UnableToLegalize;\n    auto SignMask =\n        MIRBuilder.buildConstant(Ty, APInt::getSignMask(Ty.getSizeInBits()));\n    Register SubByReg = MI.getOperand(1).getReg();\n    MIRBuilder.buildXor(Res, SubByReg, SignMask);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case TargetOpcode::G_FSUB: {\n    Register Res = MI.getOperand(0).getReg();\n    LLT Ty = MRI.getType(Res);\n\n    // Lower (G_FSUB LHS, RHS) to (G_FADD LHS, (G_FNEG RHS)).\n    // First, check if G_FNEG is marked as Lower. If so, we may\n    // end up with an infinite loop as G_FSUB is used to legalize G_FNEG.\n    if (LI.getAction({G_FNEG, {Ty}}).Action == Lower)\n      return UnableToLegalize;\n    Register LHS = MI.getOperand(1).getReg();\n    Register RHS = MI.getOperand(2).getReg();\n    Register Neg = MRI.createGenericVirtualRegister(Ty);\n    MIRBuilder.buildFNeg(Neg, RHS);\n    MIRBuilder.buildFAdd(Res, LHS, Neg, MI.getFlags());\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case TargetOpcode::G_FMAD:\n    return lowerFMad(MI);\n  case TargetOpcode::G_FFLOOR:\n    return lowerFFloor(MI);\n  case TargetOpcode::G_INTRINSIC_ROUND:\n    return lowerIntrinsicRound(MI);\n  case TargetOpcode::G_INTRINSIC_ROUNDEVEN: {\n    // Since round even is the assumed rounding mode for unconstrained FP\n    // operations, rint and roundeven are the same operation.\n    changeOpcode(MI, TargetOpcode::G_FRINT);\n    return Legalized;\n  }\n  case TargetOpcode::G_ATOMIC_CMPXCHG_WITH_SUCCESS: {\n    Register OldValRes = MI.getOperand(0).getReg();\n    Register SuccessRes = MI.getOperand(1).getReg();\n    Register Addr = MI.getOperand(2).getReg();\n    Register CmpVal = MI.getOperand(3).getReg();\n    Register NewVal = MI.getOperand(4).getReg();\n    MIRBuilder.buildAtomicCmpXchg(OldValRes, Addr, CmpVal, NewVal,\n                                  **MI.memoperands_begin());\n    MIRBuilder.buildICmp(CmpInst::ICMP_EQ, SuccessRes, OldValRes, CmpVal);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case TargetOpcode::G_LOAD:\n  case TargetOpcode::G_SEXTLOAD:\n  case TargetOpcode::G_ZEXTLOAD:\n    return lowerLoad(MI);\n  case TargetOpcode::G_STORE:\n    return lowerStore(MI);\n  case TargetOpcode::G_CTLZ_ZERO_UNDEF:\n  case TargetOpcode::G_CTTZ_ZERO_UNDEF:\n  case TargetOpcode::G_CTLZ:\n  case TargetOpcode::G_CTTZ:\n  case TargetOpcode::G_CTPOP:\n    return lowerBitCount(MI);\n  case G_UADDO: {\n    Register Res = MI.getOperand(0).getReg();\n    Register CarryOut = MI.getOperand(1).getReg();\n    Register LHS = MI.getOperand(2).getReg();\n    Register RHS = MI.getOperand(3).getReg();\n\n    MIRBuilder.buildAdd(Res, LHS, RHS);\n    MIRBuilder.buildICmp(CmpInst::ICMP_ULT, CarryOut, Res, RHS);\n\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case G_UADDE: {\n    Register Res = MI.getOperand(0).getReg();\n    Register CarryOut = MI.getOperand(1).getReg();\n    Register LHS = MI.getOperand(2).getReg();\n    Register RHS = MI.getOperand(3).getReg();\n    Register CarryIn = MI.getOperand(4).getReg();\n    LLT Ty = MRI.getType(Res);\n\n    auto TmpRes = MIRBuilder.buildAdd(Ty, LHS, RHS);\n    auto ZExtCarryIn = MIRBuilder.buildZExt(Ty, CarryIn);\n    MIRBuilder.buildAdd(Res, TmpRes, ZExtCarryIn);\n    MIRBuilder.buildICmp(CmpInst::ICMP_ULT, CarryOut, Res, LHS);\n\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case G_USUBO: {\n    Register Res = MI.getOperand(0).getReg();\n    Register BorrowOut = MI.getOperand(1).getReg();\n    Register LHS = MI.getOperand(2).getReg();\n    Register RHS = MI.getOperand(3).getReg();\n\n    MIRBuilder.buildSub(Res, LHS, RHS);\n    MIRBuilder.buildICmp(CmpInst::ICMP_ULT, BorrowOut, LHS, RHS);\n\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case G_USUBE: {\n    Register Res = MI.getOperand(0).getReg();\n    Register BorrowOut = MI.getOperand(1).getReg();\n    Register LHS = MI.getOperand(2).getReg();\n    Register RHS = MI.getOperand(3).getReg();\n    Register BorrowIn = MI.getOperand(4).getReg();\n    const LLT CondTy = MRI.getType(BorrowOut);\n    const LLT Ty = MRI.getType(Res);\n\n    auto TmpRes = MIRBuilder.buildSub(Ty, LHS, RHS);\n    auto ZExtBorrowIn = MIRBuilder.buildZExt(Ty, BorrowIn);\n    MIRBuilder.buildSub(Res, TmpRes, ZExtBorrowIn);\n\n    auto LHS_EQ_RHS = MIRBuilder.buildICmp(CmpInst::ICMP_EQ, CondTy, LHS, RHS);\n    auto LHS_ULT_RHS = MIRBuilder.buildICmp(CmpInst::ICMP_ULT, CondTy, LHS, RHS);\n    MIRBuilder.buildSelect(BorrowOut, LHS_EQ_RHS, BorrowIn, LHS_ULT_RHS);\n\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case G_UITOFP:\n    return lowerUITOFP(MI);\n  case G_SITOFP:\n    return lowerSITOFP(MI);\n  case G_FPTOUI:\n    return lowerFPTOUI(MI);\n  case G_FPTOSI:\n    return lowerFPTOSI(MI);\n  case G_FPTRUNC:\n    return lowerFPTRUNC(MI);\n  case G_FPOWI:\n    return lowerFPOWI(MI);\n  case G_SMIN:\n  case G_SMAX:\n  case G_UMIN:\n  case G_UMAX:\n    return lowerMinMax(MI);\n  case G_FCOPYSIGN:\n    return lowerFCopySign(MI);\n  case G_FMINNUM:\n  case G_FMAXNUM:\n    return lowerFMinNumMaxNum(MI);\n  case G_MERGE_VALUES:\n    return lowerMergeValues(MI);\n  case G_UNMERGE_VALUES:\n    return lowerUnmergeValues(MI);\n  case TargetOpcode::G_SEXT_INREG: {\n    assert(MI.getOperand(2).isImm() && \"Expected immediate\");\n    int64_t SizeInBits = MI.getOperand(2).getImm();\n\n    Register DstReg = MI.getOperand(0).getReg();\n    Register SrcReg = MI.getOperand(1).getReg();\n    LLT DstTy = MRI.getType(DstReg);\n    Register TmpRes = MRI.createGenericVirtualRegister(DstTy);\n\n    auto MIBSz = MIRBuilder.buildConstant(DstTy, DstTy.getScalarSizeInBits() - SizeInBits);\n    MIRBuilder.buildShl(TmpRes, SrcReg, MIBSz->getOperand(0));\n    MIRBuilder.buildAShr(DstReg, TmpRes, MIBSz->getOperand(0));\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case G_EXTRACT_VECTOR_ELT:\n  case G_INSERT_VECTOR_ELT:\n    return lowerExtractInsertVectorElt(MI);\n  case G_SHUFFLE_VECTOR:\n    return lowerShuffleVector(MI);\n  case G_DYN_STACKALLOC:\n    return lowerDynStackAlloc(MI);\n  case G_EXTRACT:\n    return lowerExtract(MI);\n  case G_INSERT:\n    return lowerInsert(MI);\n  case G_BSWAP:\n    return lowerBswap(MI);\n  case G_BITREVERSE:\n    return lowerBitreverse(MI);\n  case G_READ_REGISTER:\n  case G_WRITE_REGISTER:\n    return lowerReadWriteRegister(MI);\n  case G_UADDSAT:\n  case G_USUBSAT: {\n    // Try to make a reasonable guess about which lowering strategy to use. The\n    // target can override this with custom lowering and calling the\n    // implementation functions.\n    LLT Ty = MRI.getType(MI.getOperand(0).getReg());\n    if (LI.isLegalOrCustom({G_UMIN, Ty}))\n      return lowerAddSubSatToMinMax(MI);\n    return lowerAddSubSatToAddoSubo(MI);\n  }\n  case G_SADDSAT:\n  case G_SSUBSAT: {\n    LLT Ty = MRI.getType(MI.getOperand(0).getReg());\n\n    // FIXME: It would probably make more sense to see if G_SADDO is preferred,\n    // since it's a shorter expansion. However, we would need to figure out the\n    // preferred boolean type for the carry out for the query.\n    if (LI.isLegalOrCustom({G_SMIN, Ty}) && LI.isLegalOrCustom({G_SMAX, Ty}))\n      return lowerAddSubSatToMinMax(MI);\n    return lowerAddSubSatToAddoSubo(MI);\n  }\n  case G_SSHLSAT:\n  case G_USHLSAT:\n    return lowerShlSat(MI);\n  case G_ABS: {\n    // Expand %res = G_ABS %a into:\n    // %v1 = G_ASHR %a, scalar_size-1\n    // %v2 = G_ADD %a, %v1\n    // %res = G_XOR %v2, %v1\n    LLT DstTy = MRI.getType(MI.getOperand(0).getReg());\n    Register OpReg = MI.getOperand(1).getReg();\n    auto ShiftAmt =\n        MIRBuilder.buildConstant(DstTy, DstTy.getScalarSizeInBits() - 1);\n    auto Shift =\n        MIRBuilder.buildAShr(DstTy, OpReg, ShiftAmt);\n    auto Add = MIRBuilder.buildAdd(DstTy, OpReg, Shift);\n    MIRBuilder.buildXor(MI.getOperand(0).getReg(), Add, Shift);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case G_SELECT:\n    return lowerSelect(MI);\n  }\n}\n\nAlign LegalizerHelper::getStackTemporaryAlignment(LLT Ty,\n                                                  Align MinAlign) const {\n  // FIXME: We're missing a way to go back from LLT to llvm::Type to query the\n  // datalayout for the preferred alignment. Also there should be a target hook\n  // for this to allow targets to reduce the alignment and ignore the\n  // datalayout. e.g. AMDGPU should always use a 4-byte alignment, regardless of\n  // the type.\n  return std::max(Align(PowerOf2Ceil(Ty.getSizeInBytes())), MinAlign);\n}\n\nMachineInstrBuilder\nLegalizerHelper::createStackTemporary(TypeSize Bytes, Align Alignment,\n                                      MachinePointerInfo &PtrInfo) {\n  MachineFunction &MF = MIRBuilder.getMF();\n  const DataLayout &DL = MIRBuilder.getDataLayout();\n  int FrameIdx = MF.getFrameInfo().CreateStackObject(Bytes, Alignment, false);\n\n  unsigned AddrSpace = DL.getAllocaAddrSpace();\n  LLT FramePtrTy = LLT::pointer(AddrSpace, DL.getPointerSizeInBits(AddrSpace));\n\n  PtrInfo = MachinePointerInfo::getFixedStack(MF, FrameIdx);\n  return MIRBuilder.buildFrameIndex(FramePtrTy, FrameIdx);\n}\n\nstatic Register clampDynamicVectorIndex(MachineIRBuilder &B, Register IdxReg,\n                                        LLT VecTy) {\n  int64_t IdxVal;\n  if (mi_match(IdxReg, *B.getMRI(), m_ICst(IdxVal)))\n    return IdxReg;\n\n  LLT IdxTy = B.getMRI()->getType(IdxReg);\n  unsigned NElts = VecTy.getNumElements();\n  if (isPowerOf2_32(NElts)) {\n    APInt Imm = APInt::getLowBitsSet(IdxTy.getSizeInBits(), Log2_32(NElts));\n    return B.buildAnd(IdxTy, IdxReg, B.buildConstant(IdxTy, Imm)).getReg(0);\n  }\n\n  return B.buildUMin(IdxTy, IdxReg, B.buildConstant(IdxTy, NElts - 1))\n      .getReg(0);\n}\n\nRegister LegalizerHelper::getVectorElementPointer(Register VecPtr, LLT VecTy,\n                                                  Register Index) {\n  LLT EltTy = VecTy.getElementType();\n\n  // Calculate the element offset and add it to the pointer.\n  unsigned EltSize = EltTy.getSizeInBits() / 8; // FIXME: should be ABI size.\n  assert(EltSize * 8 == EltTy.getSizeInBits() &&\n         \"Converting bits to bytes lost precision\");\n\n  Index = clampDynamicVectorIndex(MIRBuilder, Index, VecTy);\n\n  LLT IdxTy = MRI.getType(Index);\n  auto Mul = MIRBuilder.buildMul(IdxTy, Index,\n                                 MIRBuilder.buildConstant(IdxTy, EltSize));\n\n  LLT PtrTy = MRI.getType(VecPtr);\n  return MIRBuilder.buildPtrAdd(PtrTy, VecPtr, Mul).getReg(0);\n}\n\nLegalizerHelper::LegalizeResult LegalizerHelper::fewerElementsVectorImplicitDef(\n    MachineInstr &MI, unsigned TypeIdx, LLT NarrowTy) {\n  Register DstReg = MI.getOperand(0).getReg();\n  LLT DstTy = MRI.getType(DstReg);\n  LLT LCMTy = getLCMType(DstTy, NarrowTy);\n\n  unsigned NumParts = LCMTy.getSizeInBits() / NarrowTy.getSizeInBits();\n\n  auto NewUndef = MIRBuilder.buildUndef(NarrowTy);\n  SmallVector<Register, 8> Parts(NumParts, NewUndef.getReg(0));\n\n  buildWidenedRemergeToDst(DstReg, LCMTy, Parts);\n  MI.eraseFromParent();\n  return Legalized;\n}\n\n// Handle splitting vector operations which need to have the same number of\n// elements in each type index, but each type index may have a different element\n// type.\n//\n// e.g.  <4 x s64> = G_SHL <4 x s64>, <4 x s32> ->\n//       <2 x s64> = G_SHL <2 x s64>, <2 x s32>\n//       <2 x s64> = G_SHL <2 x s64>, <2 x s32>\n//\n// Also handles some irregular breakdown cases, e.g.\n// e.g.  <3 x s64> = G_SHL <3 x s64>, <3 x s32> ->\n//       <2 x s64> = G_SHL <2 x s64>, <2 x s32>\n//             s64 = G_SHL s64, s32\nLegalizerHelper::LegalizeResult\nLegalizerHelper::fewerElementsVectorMultiEltType(\n  MachineInstr &MI, unsigned TypeIdx, LLT NarrowTyArg) {\n  if (TypeIdx != 0)\n    return UnableToLegalize;\n\n  const LLT NarrowTy0 = NarrowTyArg;\n  const unsigned NewNumElts =\n      NarrowTy0.isVector() ? NarrowTy0.getNumElements() : 1;\n\n  const Register DstReg = MI.getOperand(0).getReg();\n  LLT DstTy = MRI.getType(DstReg);\n  LLT LeftoverTy0;\n\n  // All of the operands need to have the same number of elements, so if we can\n  // determine a type breakdown for the result type, we can for all of the\n  // source types.\n  int NumParts = getNarrowTypeBreakDown(DstTy, NarrowTy0, LeftoverTy0).first;\n  if (NumParts < 0)\n    return UnableToLegalize;\n\n  SmallVector<MachineInstrBuilder, 4> NewInsts;\n\n  SmallVector<Register, 4> DstRegs, LeftoverDstRegs;\n  SmallVector<Register, 4> PartRegs, LeftoverRegs;\n\n  for (unsigned I = 1, E = MI.getNumOperands(); I != E; ++I) {\n    Register SrcReg = MI.getOperand(I).getReg();\n    LLT SrcTyI = MRI.getType(SrcReg);\n    LLT NarrowTyI = LLT::scalarOrVector(NewNumElts, SrcTyI.getScalarType());\n    LLT LeftoverTyI;\n\n    // Split this operand into the requested typed registers, and any leftover\n    // required to reproduce the original type.\n    if (!extractParts(SrcReg, SrcTyI, NarrowTyI, LeftoverTyI, PartRegs,\n                      LeftoverRegs))\n      return UnableToLegalize;\n\n    if (I == 1) {\n      // For the first operand, create an instruction for each part and setup\n      // the result.\n      for (Register PartReg : PartRegs) {\n        Register PartDstReg = MRI.createGenericVirtualRegister(NarrowTy0);\n        NewInsts.push_back(MIRBuilder.buildInstrNoInsert(MI.getOpcode())\n                               .addDef(PartDstReg)\n                               .addUse(PartReg));\n        DstRegs.push_back(PartDstReg);\n      }\n\n      for (Register LeftoverReg : LeftoverRegs) {\n        Register PartDstReg = MRI.createGenericVirtualRegister(LeftoverTy0);\n        NewInsts.push_back(MIRBuilder.buildInstrNoInsert(MI.getOpcode())\n                               .addDef(PartDstReg)\n                               .addUse(LeftoverReg));\n        LeftoverDstRegs.push_back(PartDstReg);\n      }\n    } else {\n      assert(NewInsts.size() == PartRegs.size() + LeftoverRegs.size());\n\n      // Add the newly created operand splits to the existing instructions. The\n      // odd-sized pieces are ordered after the requested NarrowTyArg sized\n      // pieces.\n      unsigned InstCount = 0;\n      for (unsigned J = 0, JE = PartRegs.size(); J != JE; ++J)\n        NewInsts[InstCount++].addUse(PartRegs[J]);\n      for (unsigned J = 0, JE = LeftoverRegs.size(); J != JE; ++J)\n        NewInsts[InstCount++].addUse(LeftoverRegs[J]);\n    }\n\n    PartRegs.clear();\n    LeftoverRegs.clear();\n  }\n\n  // Insert the newly built operations and rebuild the result register.\n  for (auto &MIB : NewInsts)\n    MIRBuilder.insertInstr(MIB);\n\n  insertParts(DstReg, DstTy, NarrowTy0, DstRegs, LeftoverTy0, LeftoverDstRegs);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::fewerElementsVectorCasts(MachineInstr &MI, unsigned TypeIdx,\n                                          LLT NarrowTy) {\n  if (TypeIdx != 0)\n    return UnableToLegalize;\n\n  Register DstReg = MI.getOperand(0).getReg();\n  Register SrcReg = MI.getOperand(1).getReg();\n  LLT DstTy = MRI.getType(DstReg);\n  LLT SrcTy = MRI.getType(SrcReg);\n\n  LLT NarrowTy0 = NarrowTy;\n  LLT NarrowTy1;\n  unsigned NumParts;\n\n  if (NarrowTy.isVector()) {\n    // Uneven breakdown not handled.\n    NumParts = DstTy.getNumElements() / NarrowTy.getNumElements();\n    if (NumParts * NarrowTy.getNumElements() != DstTy.getNumElements())\n      return UnableToLegalize;\n\n    NarrowTy1 = LLT::vector(NarrowTy.getNumElements(), SrcTy.getElementType());\n  } else {\n    NumParts = DstTy.getNumElements();\n    NarrowTy1 = SrcTy.getElementType();\n  }\n\n  SmallVector<Register, 4> SrcRegs, DstRegs;\n  extractParts(SrcReg, NarrowTy1, NumParts, SrcRegs);\n\n  for (unsigned I = 0; I < NumParts; ++I) {\n    Register DstReg = MRI.createGenericVirtualRegister(NarrowTy0);\n    MachineInstr *NewInst =\n        MIRBuilder.buildInstr(MI.getOpcode(), {DstReg}, {SrcRegs[I]});\n\n    NewInst->setFlags(MI.getFlags());\n    DstRegs.push_back(DstReg);\n  }\n\n  if (NarrowTy.isVector())\n    MIRBuilder.buildConcatVectors(DstReg, DstRegs);\n  else\n    MIRBuilder.buildBuildVector(DstReg, DstRegs);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::fewerElementsVectorCmp(MachineInstr &MI, unsigned TypeIdx,\n                                        LLT NarrowTy) {\n  Register DstReg = MI.getOperand(0).getReg();\n  Register Src0Reg = MI.getOperand(2).getReg();\n  LLT DstTy = MRI.getType(DstReg);\n  LLT SrcTy = MRI.getType(Src0Reg);\n\n  unsigned NumParts;\n  LLT NarrowTy0, NarrowTy1;\n\n  if (TypeIdx == 0) {\n    unsigned NewElts = NarrowTy.isVector() ? NarrowTy.getNumElements() : 1;\n    unsigned OldElts = DstTy.getNumElements();\n\n    NarrowTy0 = NarrowTy;\n    NumParts = NarrowTy.isVector() ? (OldElts / NewElts) : DstTy.getNumElements();\n    NarrowTy1 = NarrowTy.isVector() ?\n      LLT::vector(NarrowTy.getNumElements(), SrcTy.getScalarSizeInBits()) :\n      SrcTy.getElementType();\n\n  } else {\n    unsigned NewElts = NarrowTy.isVector() ? NarrowTy.getNumElements() : 1;\n    unsigned OldElts = SrcTy.getNumElements();\n\n    NumParts = NarrowTy.isVector() ? (OldElts / NewElts) :\n      NarrowTy.getNumElements();\n    NarrowTy0 = LLT::vector(NarrowTy.getNumElements(),\n                            DstTy.getScalarSizeInBits());\n    NarrowTy1 = NarrowTy;\n  }\n\n  // FIXME: Don't know how to handle the situation where the small vectors\n  // aren't all the same size yet.\n  if (NarrowTy1.isVector() &&\n      NarrowTy1.getNumElements() * NumParts != DstTy.getNumElements())\n    return UnableToLegalize;\n\n  CmpInst::Predicate Pred\n    = static_cast<CmpInst::Predicate>(MI.getOperand(1).getPredicate());\n\n  SmallVector<Register, 2> Src1Regs, Src2Regs, DstRegs;\n  extractParts(MI.getOperand(2).getReg(), NarrowTy1, NumParts, Src1Regs);\n  extractParts(MI.getOperand(3).getReg(), NarrowTy1, NumParts, Src2Regs);\n\n  for (unsigned I = 0; I < NumParts; ++I) {\n    Register DstReg = MRI.createGenericVirtualRegister(NarrowTy0);\n    DstRegs.push_back(DstReg);\n\n    if (MI.getOpcode() == TargetOpcode::G_ICMP)\n      MIRBuilder.buildICmp(Pred, DstReg, Src1Regs[I], Src2Regs[I]);\n    else {\n      MachineInstr *NewCmp\n        = MIRBuilder.buildFCmp(Pred, DstReg, Src1Regs[I], Src2Regs[I]);\n      NewCmp->setFlags(MI.getFlags());\n    }\n  }\n\n  if (NarrowTy1.isVector())\n    MIRBuilder.buildConcatVectors(DstReg, DstRegs);\n  else\n    MIRBuilder.buildBuildVector(DstReg, DstRegs);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::fewerElementsVectorSelect(MachineInstr &MI, unsigned TypeIdx,\n                                           LLT NarrowTy) {\n  Register DstReg = MI.getOperand(0).getReg();\n  Register CondReg = MI.getOperand(1).getReg();\n\n  unsigned NumParts = 0;\n  LLT NarrowTy0, NarrowTy1;\n\n  LLT DstTy = MRI.getType(DstReg);\n  LLT CondTy = MRI.getType(CondReg);\n  unsigned Size = DstTy.getSizeInBits();\n\n  assert(TypeIdx == 0 || CondTy.isVector());\n\n  if (TypeIdx == 0) {\n    NarrowTy0 = NarrowTy;\n    NarrowTy1 = CondTy;\n\n    unsigned NarrowSize = NarrowTy0.getSizeInBits();\n    // FIXME: Don't know how to handle the situation where the small vectors\n    // aren't all the same size yet.\n    if (Size % NarrowSize != 0)\n      return UnableToLegalize;\n\n    NumParts = Size / NarrowSize;\n\n    // Need to break down the condition type\n    if (CondTy.isVector()) {\n      if (CondTy.getNumElements() == NumParts)\n        NarrowTy1 = CondTy.getElementType();\n      else\n        NarrowTy1 = LLT::vector(CondTy.getNumElements() / NumParts,\n                                CondTy.getScalarSizeInBits());\n    }\n  } else {\n    NumParts = CondTy.getNumElements();\n    if (NarrowTy.isVector()) {\n      // TODO: Handle uneven breakdown.\n      if (NumParts * NarrowTy.getNumElements() != CondTy.getNumElements())\n        return UnableToLegalize;\n\n      return UnableToLegalize;\n    } else {\n      NarrowTy0 = DstTy.getElementType();\n      NarrowTy1 = NarrowTy;\n    }\n  }\n\n  SmallVector<Register, 2> DstRegs, Src0Regs, Src1Regs, Src2Regs;\n  if (CondTy.isVector())\n    extractParts(MI.getOperand(1).getReg(), NarrowTy1, NumParts, Src0Regs);\n\n  extractParts(MI.getOperand(2).getReg(), NarrowTy0, NumParts, Src1Regs);\n  extractParts(MI.getOperand(3).getReg(), NarrowTy0, NumParts, Src2Regs);\n\n  for (unsigned i = 0; i < NumParts; ++i) {\n    Register DstReg = MRI.createGenericVirtualRegister(NarrowTy0);\n    MIRBuilder.buildSelect(DstReg, CondTy.isVector() ? Src0Regs[i] : CondReg,\n                           Src1Regs[i], Src2Regs[i]);\n    DstRegs.push_back(DstReg);\n  }\n\n  if (NarrowTy0.isVector())\n    MIRBuilder.buildConcatVectors(DstReg, DstRegs);\n  else\n    MIRBuilder.buildBuildVector(DstReg, DstRegs);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::fewerElementsVectorPhi(MachineInstr &MI, unsigned TypeIdx,\n                                        LLT NarrowTy) {\n  const Register DstReg = MI.getOperand(0).getReg();\n  LLT PhiTy = MRI.getType(DstReg);\n  LLT LeftoverTy;\n\n  // All of the operands need to have the same number of elements, so if we can\n  // determine a type breakdown for the result type, we can for all of the\n  // source types.\n  int NumParts, NumLeftover;\n  std::tie(NumParts, NumLeftover)\n    = getNarrowTypeBreakDown(PhiTy, NarrowTy, LeftoverTy);\n  if (NumParts < 0)\n    return UnableToLegalize;\n\n  SmallVector<Register, 4> DstRegs, LeftoverDstRegs;\n  SmallVector<MachineInstrBuilder, 4> NewInsts;\n\n  const int TotalNumParts = NumParts + NumLeftover;\n\n  // Insert the new phis in the result block first.\n  for (int I = 0; I != TotalNumParts; ++I) {\n    LLT Ty = I < NumParts ? NarrowTy : LeftoverTy;\n    Register PartDstReg = MRI.createGenericVirtualRegister(Ty);\n    NewInsts.push_back(MIRBuilder.buildInstr(TargetOpcode::G_PHI)\n                       .addDef(PartDstReg));\n    if (I < NumParts)\n      DstRegs.push_back(PartDstReg);\n    else\n      LeftoverDstRegs.push_back(PartDstReg);\n  }\n\n  MachineBasicBlock *MBB = MI.getParent();\n  MIRBuilder.setInsertPt(*MBB, MBB->getFirstNonPHI());\n  insertParts(DstReg, PhiTy, NarrowTy, DstRegs, LeftoverTy, LeftoverDstRegs);\n\n  SmallVector<Register, 4> PartRegs, LeftoverRegs;\n\n  // Insert code to extract the incoming values in each predecessor block.\n  for (unsigned I = 1, E = MI.getNumOperands(); I != E; I += 2) {\n    PartRegs.clear();\n    LeftoverRegs.clear();\n\n    Register SrcReg = MI.getOperand(I).getReg();\n    MachineBasicBlock &OpMBB = *MI.getOperand(I + 1).getMBB();\n    MIRBuilder.setInsertPt(OpMBB, OpMBB.getFirstTerminator());\n\n    LLT Unused;\n    if (!extractParts(SrcReg, PhiTy, NarrowTy, Unused, PartRegs,\n                      LeftoverRegs))\n      return UnableToLegalize;\n\n    // Add the newly created operand splits to the existing instructions. The\n    // odd-sized pieces are ordered after the requested NarrowTyArg sized\n    // pieces.\n    for (int J = 0; J != TotalNumParts; ++J) {\n      MachineInstrBuilder MIB = NewInsts[J];\n      MIB.addUse(J < NumParts ? PartRegs[J] : LeftoverRegs[J - NumParts]);\n      MIB.addMBB(&OpMBB);\n    }\n  }\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::fewerElementsVectorUnmergeValues(MachineInstr &MI,\n                                                  unsigned TypeIdx,\n                                                  LLT NarrowTy) {\n  if (TypeIdx != 1)\n    return UnableToLegalize;\n\n  const int NumDst = MI.getNumOperands() - 1;\n  const Register SrcReg = MI.getOperand(NumDst).getReg();\n  LLT SrcTy = MRI.getType(SrcReg);\n\n  LLT DstTy = MRI.getType(MI.getOperand(0).getReg());\n\n  // TODO: Create sequence of extracts.\n  if (DstTy == NarrowTy)\n    return UnableToLegalize;\n\n  LLT GCDTy = getGCDType(SrcTy, NarrowTy);\n  if (DstTy == GCDTy) {\n    // This would just be a copy of the same unmerge.\n    // TODO: Create extracts, pad with undef and create intermediate merges.\n    return UnableToLegalize;\n  }\n\n  auto Unmerge = MIRBuilder.buildUnmerge(GCDTy, SrcReg);\n  const int NumUnmerge = Unmerge->getNumOperands() - 1;\n  const int PartsPerUnmerge = NumDst / NumUnmerge;\n\n  for (int I = 0; I != NumUnmerge; ++I) {\n    auto MIB = MIRBuilder.buildInstr(TargetOpcode::G_UNMERGE_VALUES);\n\n    for (int J = 0; J != PartsPerUnmerge; ++J)\n      MIB.addDef(MI.getOperand(I * PartsPerUnmerge + J).getReg());\n    MIB.addUse(Unmerge.getReg(I));\n  }\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\n// Handle FewerElementsVector a G_BUILD_VECTOR or G_CONCAT_VECTORS that produces\n// a vector\n//\n// Create a G_BUILD_VECTOR or G_CONCAT_VECTORS of NarrowTy pieces, padding with\n// undef as necessary.\n//\n// %3:_(<3 x s16>) = G_BUILD_VECTOR %0, %1, %2\n//   -> <2 x s16>\n//\n// %4:_(s16) = G_IMPLICIT_DEF\n// %5:_(<2 x s16>) = G_BUILD_VECTOR %0, %1\n// %6:_(<2 x s16>) = G_BUILD_VECTOR %2, %4\n// %7:_(<2 x s16>) = G_IMPLICIT_DEF\n// %8:_(<6 x s16>) = G_CONCAT_VECTORS %5, %6, %7\n// %3:_(<3 x s16>), %8:_(<3 x s16>) = G_UNMERGE_VALUES %8\nLegalizerHelper::LegalizeResult\nLegalizerHelper::fewerElementsVectorMerge(MachineInstr &MI, unsigned TypeIdx,\n                                          LLT NarrowTy) {\n  Register DstReg = MI.getOperand(0).getReg();\n  LLT DstTy = MRI.getType(DstReg);\n  LLT SrcTy = MRI.getType(MI.getOperand(1).getReg());\n  LLT GCDTy = getGCDType(getGCDType(SrcTy, NarrowTy), DstTy);\n\n  // Break into a common type\n  SmallVector<Register, 16> Parts;\n  for (unsigned I = 1, E = MI.getNumOperands(); I != E; ++I)\n    extractGCDType(Parts, GCDTy, MI.getOperand(I).getReg());\n\n  // Build the requested new merge, padding with undef.\n  LLT LCMTy = buildLCMMergePieces(DstTy, NarrowTy, GCDTy, Parts,\n                                  TargetOpcode::G_ANYEXT);\n\n  // Pack into the original result register.\n  buildWidenedRemergeToDst(DstReg, LCMTy, Parts);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::fewerElementsVectorExtractInsertVectorElt(MachineInstr &MI,\n                                                           unsigned TypeIdx,\n                                                           LLT NarrowVecTy) {\n  Register DstReg = MI.getOperand(0).getReg();\n  Register SrcVec = MI.getOperand(1).getReg();\n  Register InsertVal;\n  bool IsInsert = MI.getOpcode() == TargetOpcode::G_INSERT_VECTOR_ELT;\n\n  assert((IsInsert ? TypeIdx == 0 : TypeIdx == 1) && \"not a vector type index\");\n  if (IsInsert)\n    InsertVal = MI.getOperand(2).getReg();\n\n  Register Idx = MI.getOperand(MI.getNumOperands() - 1).getReg();\n\n  // TODO: Handle total scalarization case.\n  if (!NarrowVecTy.isVector())\n    return UnableToLegalize;\n\n  LLT VecTy = MRI.getType(SrcVec);\n\n  // If the index is a constant, we can really break this down as you would\n  // expect, and index into the target size pieces.\n  int64_t IdxVal;\n  if (mi_match(Idx, MRI, m_ICst(IdxVal))) {\n    // Avoid out of bounds indexing the pieces.\n    if (IdxVal >= VecTy.getNumElements()) {\n      MIRBuilder.buildUndef(DstReg);\n      MI.eraseFromParent();\n      return Legalized;\n    }\n\n    SmallVector<Register, 8> VecParts;\n    LLT GCDTy = extractGCDType(VecParts, VecTy, NarrowVecTy, SrcVec);\n\n    // Build a sequence of NarrowTy pieces in VecParts for this operand.\n    LLT LCMTy = buildLCMMergePieces(VecTy, NarrowVecTy, GCDTy, VecParts,\n                                    TargetOpcode::G_ANYEXT);\n\n    unsigned NewNumElts = NarrowVecTy.getNumElements();\n\n    LLT IdxTy = MRI.getType(Idx);\n    int64_t PartIdx = IdxVal / NewNumElts;\n    auto NewIdx =\n        MIRBuilder.buildConstant(IdxTy, IdxVal - NewNumElts * PartIdx);\n\n    if (IsInsert) {\n      LLT PartTy = MRI.getType(VecParts[PartIdx]);\n\n      // Use the adjusted index to insert into one of the subvectors.\n      auto InsertPart = MIRBuilder.buildInsertVectorElement(\n          PartTy, VecParts[PartIdx], InsertVal, NewIdx);\n      VecParts[PartIdx] = InsertPart.getReg(0);\n\n      // Recombine the inserted subvector with the others to reform the result\n      // vector.\n      buildWidenedRemergeToDst(DstReg, LCMTy, VecParts);\n    } else {\n      MIRBuilder.buildExtractVectorElement(DstReg, VecParts[PartIdx], NewIdx);\n    }\n\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  // With a variable index, we can't perform the operation in a smaller type, so\n  // we're forced to expand this.\n  //\n  // TODO: We could emit a chain of compare/select to figure out which piece to\n  // index.\n  return lowerExtractInsertVectorElt(MI);\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::reduceLoadStoreWidth(MachineInstr &MI, unsigned TypeIdx,\n                                      LLT NarrowTy) {\n  // FIXME: Don't know how to handle secondary types yet.\n  if (TypeIdx != 0)\n    return UnableToLegalize;\n\n  MachineMemOperand *MMO = *MI.memoperands_begin();\n\n  // This implementation doesn't work for atomics. Give up instead of doing\n  // something invalid.\n  if (MMO->getOrdering() != AtomicOrdering::NotAtomic ||\n      MMO->getFailureOrdering() != AtomicOrdering::NotAtomic)\n    return UnableToLegalize;\n\n  bool IsLoad = MI.getOpcode() == TargetOpcode::G_LOAD;\n  Register ValReg = MI.getOperand(0).getReg();\n  Register AddrReg = MI.getOperand(1).getReg();\n  LLT ValTy = MRI.getType(ValReg);\n\n  // FIXME: Do we need a distinct NarrowMemory legalize action?\n  if (ValTy.getSizeInBits() != 8 * MMO->getSize()) {\n    LLVM_DEBUG(dbgs() << \"Can't narrow extload/truncstore\\n\");\n    return UnableToLegalize;\n  }\n\n  int NumParts = -1;\n  int NumLeftover = -1;\n  LLT LeftoverTy;\n  SmallVector<Register, 8> NarrowRegs, NarrowLeftoverRegs;\n  if (IsLoad) {\n    std::tie(NumParts, NumLeftover) = getNarrowTypeBreakDown(ValTy, NarrowTy, LeftoverTy);\n  } else {\n    if (extractParts(ValReg, ValTy, NarrowTy, LeftoverTy, NarrowRegs,\n                     NarrowLeftoverRegs)) {\n      NumParts = NarrowRegs.size();\n      NumLeftover = NarrowLeftoverRegs.size();\n    }\n  }\n\n  if (NumParts == -1)\n    return UnableToLegalize;\n\n  LLT PtrTy = MRI.getType(AddrReg);\n  const LLT OffsetTy = LLT::scalar(PtrTy.getSizeInBits());\n\n  unsigned TotalSize = ValTy.getSizeInBits();\n\n  // Split the load/store into PartTy sized pieces starting at Offset. If this\n  // is a load, return the new registers in ValRegs. For a store, each elements\n  // of ValRegs should be PartTy. Returns the next offset that needs to be\n  // handled.\n  auto splitTypePieces = [=](LLT PartTy, SmallVectorImpl<Register> &ValRegs,\n                             unsigned Offset) -> unsigned {\n    MachineFunction &MF = MIRBuilder.getMF();\n    unsigned PartSize = PartTy.getSizeInBits();\n    for (unsigned Idx = 0, E = NumParts; Idx != E && Offset < TotalSize;\n         Offset += PartSize, ++Idx) {\n      unsigned ByteSize = PartSize / 8;\n      unsigned ByteOffset = Offset / 8;\n      Register NewAddrReg;\n\n      MIRBuilder.materializePtrAdd(NewAddrReg, AddrReg, OffsetTy, ByteOffset);\n\n      MachineMemOperand *NewMMO =\n        MF.getMachineMemOperand(MMO, ByteOffset, ByteSize);\n\n      if (IsLoad) {\n        Register Dst = MRI.createGenericVirtualRegister(PartTy);\n        ValRegs.push_back(Dst);\n        MIRBuilder.buildLoad(Dst, NewAddrReg, *NewMMO);\n      } else {\n        MIRBuilder.buildStore(ValRegs[Idx], NewAddrReg, *NewMMO);\n      }\n    }\n\n    return Offset;\n  };\n\n  unsigned HandledOffset = splitTypePieces(NarrowTy, NarrowRegs, 0);\n\n  // Handle the rest of the register if this isn't an even type breakdown.\n  if (LeftoverTy.isValid())\n    splitTypePieces(LeftoverTy, NarrowLeftoverRegs, HandledOffset);\n\n  if (IsLoad) {\n    insertParts(ValReg, ValTy, NarrowTy, NarrowRegs,\n                LeftoverTy, NarrowLeftoverRegs);\n  }\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::reduceOperationWidth(MachineInstr &MI, unsigned int TypeIdx,\n                                      LLT NarrowTy) {\n  assert(TypeIdx == 0 && \"only one type index expected\");\n\n  const unsigned Opc = MI.getOpcode();\n  const int NumOps = MI.getNumOperands() - 1;\n  const Register DstReg = MI.getOperand(0).getReg();\n  const unsigned Flags = MI.getFlags();\n  const unsigned NarrowSize = NarrowTy.getSizeInBits();\n  const LLT NarrowScalarTy = LLT::scalar(NarrowSize);\n\n  assert(NumOps <= 3 && \"expected instruction with 1 result and 1-3 sources\");\n\n  // First of all check whether we are narrowing (changing the element type)\n  // or reducing the vector elements\n  const LLT DstTy = MRI.getType(DstReg);\n  const bool IsNarrow = NarrowTy.getScalarType() != DstTy.getScalarType();\n\n  SmallVector<Register, 8> ExtractedRegs[3];\n  SmallVector<Register, 8> Parts;\n\n  unsigned NarrowElts = NarrowTy.isVector() ? NarrowTy.getNumElements() : 1;\n\n  // Break down all the sources into NarrowTy pieces we can operate on. This may\n  // involve creating merges to a wider type, padded with undef.\n  for (int I = 0; I != NumOps; ++I) {\n    Register SrcReg = MI.getOperand(I + 1).getReg();\n    LLT SrcTy = MRI.getType(SrcReg);\n\n    // The type to narrow SrcReg to. For narrowing, this is a smaller scalar.\n    // For fewerElements, this is a smaller vector with the same element type.\n    LLT OpNarrowTy;\n    if (IsNarrow) {\n      OpNarrowTy = NarrowScalarTy;\n\n      // In case of narrowing, we need to cast vectors to scalars for this to\n      // work properly\n      // FIXME: Can we do without the bitcast here if we're narrowing?\n      if (SrcTy.isVector()) {\n        SrcTy = LLT::scalar(SrcTy.getSizeInBits());\n        SrcReg = MIRBuilder.buildBitcast(SrcTy, SrcReg).getReg(0);\n      }\n    } else {\n      OpNarrowTy = LLT::scalarOrVector(NarrowElts, SrcTy.getScalarType());\n    }\n\n    LLT GCDTy = extractGCDType(ExtractedRegs[I], SrcTy, OpNarrowTy, SrcReg);\n\n    // Build a sequence of NarrowTy pieces in ExtractedRegs for this operand.\n    buildLCMMergePieces(SrcTy, OpNarrowTy, GCDTy, ExtractedRegs[I],\n                        TargetOpcode::G_ANYEXT);\n  }\n\n  SmallVector<Register, 8> ResultRegs;\n\n  // Input operands for each sub-instruction.\n  SmallVector<SrcOp, 4> InputRegs(NumOps, Register());\n\n  int NumParts = ExtractedRegs[0].size();\n  const unsigned DstSize = DstTy.getSizeInBits();\n  const LLT DstScalarTy = LLT::scalar(DstSize);\n\n  // Narrowing needs to use scalar types\n  LLT DstLCMTy, NarrowDstTy;\n  if (IsNarrow) {\n    DstLCMTy = getLCMType(DstScalarTy, NarrowScalarTy);\n    NarrowDstTy = NarrowScalarTy;\n  } else {\n    DstLCMTy = getLCMType(DstTy, NarrowTy);\n    NarrowDstTy = NarrowTy;\n  }\n\n  // We widened the source registers to satisfy merge/unmerge size\n  // constraints. We'll have some extra fully undef parts.\n  const int NumRealParts = (DstSize + NarrowSize - 1) / NarrowSize;\n\n  for (int I = 0; I != NumRealParts; ++I) {\n    // Emit this instruction on each of the split pieces.\n    for (int J = 0; J != NumOps; ++J)\n      InputRegs[J] = ExtractedRegs[J][I];\n\n    auto Inst = MIRBuilder.buildInstr(Opc, {NarrowDstTy}, InputRegs, Flags);\n    ResultRegs.push_back(Inst.getReg(0));\n  }\n\n  // Fill out the widened result with undef instead of creating instructions\n  // with undef inputs.\n  int NumUndefParts = NumParts - NumRealParts;\n  if (NumUndefParts != 0)\n    ResultRegs.append(NumUndefParts,\n                      MIRBuilder.buildUndef(NarrowDstTy).getReg(0));\n\n  // Extract the possibly padded result. Use a scratch register if we need to do\n  // a final bitcast, otherwise use the original result register.\n  Register MergeDstReg;\n  if (IsNarrow && DstTy.isVector())\n    MergeDstReg = MRI.createGenericVirtualRegister(DstScalarTy);\n  else\n    MergeDstReg = DstReg;\n\n  buildWidenedRemergeToDst(MergeDstReg, DstLCMTy, ResultRegs);\n\n  // Recast to vector if we narrowed a vector\n  if (IsNarrow && DstTy.isVector())\n    MIRBuilder.buildBitcast(DstReg, MergeDstReg);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::fewerElementsVectorSextInReg(MachineInstr &MI, unsigned TypeIdx,\n                                              LLT NarrowTy) {\n  Register DstReg = MI.getOperand(0).getReg();\n  Register SrcReg = MI.getOperand(1).getReg();\n  int64_t Imm = MI.getOperand(2).getImm();\n\n  LLT DstTy = MRI.getType(DstReg);\n\n  SmallVector<Register, 8> Parts;\n  LLT GCDTy = extractGCDType(Parts, DstTy, NarrowTy, SrcReg);\n  LLT LCMTy = buildLCMMergePieces(DstTy, NarrowTy, GCDTy, Parts);\n\n  for (Register &R : Parts)\n    R = MIRBuilder.buildSExtInReg(NarrowTy, R, Imm).getReg(0);\n\n  buildWidenedRemergeToDst(DstReg, LCMTy, Parts);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::fewerElementsVector(MachineInstr &MI, unsigned TypeIdx,\n                                     LLT NarrowTy) {\n  using namespace TargetOpcode;\n\n  switch (MI.getOpcode()) {\n  case G_IMPLICIT_DEF:\n    return fewerElementsVectorImplicitDef(MI, TypeIdx, NarrowTy);\n  case G_TRUNC:\n  case G_AND:\n  case G_OR:\n  case G_XOR:\n  case G_ADD:\n  case G_SUB:\n  case G_MUL:\n  case G_PTR_ADD:\n  case G_SMULH:\n  case G_UMULH:\n  case G_FADD:\n  case G_FMUL:\n  case G_FSUB:\n  case G_FNEG:\n  case G_FABS:\n  case G_FCANONICALIZE:\n  case G_FDIV:\n  case G_FREM:\n  case G_FMA:\n  case G_FMAD:\n  case G_FPOW:\n  case G_FEXP:\n  case G_FEXP2:\n  case G_FLOG:\n  case G_FLOG2:\n  case G_FLOG10:\n  case G_FNEARBYINT:\n  case G_FCEIL:\n  case G_FFLOOR:\n  case G_FRINT:\n  case G_INTRINSIC_ROUND:\n  case G_INTRINSIC_ROUNDEVEN:\n  case G_INTRINSIC_TRUNC:\n  case G_FCOS:\n  case G_FSIN:\n  case G_FSQRT:\n  case G_BSWAP:\n  case G_BITREVERSE:\n  case G_SDIV:\n  case G_UDIV:\n  case G_SREM:\n  case G_UREM:\n  case G_SMIN:\n  case G_SMAX:\n  case G_UMIN:\n  case G_UMAX:\n  case G_FMINNUM:\n  case G_FMAXNUM:\n  case G_FMINNUM_IEEE:\n  case G_FMAXNUM_IEEE:\n  case G_FMINIMUM:\n  case G_FMAXIMUM:\n  case G_FSHL:\n  case G_FSHR:\n  case G_FREEZE:\n  case G_SADDSAT:\n  case G_SSUBSAT:\n  case G_UADDSAT:\n  case G_USUBSAT:\n    return reduceOperationWidth(MI, TypeIdx, NarrowTy);\n  case G_SHL:\n  case G_LSHR:\n  case G_ASHR:\n  case G_SSHLSAT:\n  case G_USHLSAT:\n  case G_CTLZ:\n  case G_CTLZ_ZERO_UNDEF:\n  case G_CTTZ:\n  case G_CTTZ_ZERO_UNDEF:\n  case G_CTPOP:\n  case G_FCOPYSIGN:\n    return fewerElementsVectorMultiEltType(MI, TypeIdx, NarrowTy);\n  case G_ZEXT:\n  case G_SEXT:\n  case G_ANYEXT:\n  case G_FPEXT:\n  case G_FPTRUNC:\n  case G_SITOFP:\n  case G_UITOFP:\n  case G_FPTOSI:\n  case G_FPTOUI:\n  case G_INTTOPTR:\n  case G_PTRTOINT:\n  case G_ADDRSPACE_CAST:\n    return fewerElementsVectorCasts(MI, TypeIdx, NarrowTy);\n  case G_ICMP:\n  case G_FCMP:\n    return fewerElementsVectorCmp(MI, TypeIdx, NarrowTy);\n  case G_SELECT:\n    return fewerElementsVectorSelect(MI, TypeIdx, NarrowTy);\n  case G_PHI:\n    return fewerElementsVectorPhi(MI, TypeIdx, NarrowTy);\n  case G_UNMERGE_VALUES:\n    return fewerElementsVectorUnmergeValues(MI, TypeIdx, NarrowTy);\n  case G_BUILD_VECTOR:\n    assert(TypeIdx == 0 && \"not a vector type index\");\n    return fewerElementsVectorMerge(MI, TypeIdx, NarrowTy);\n  case G_CONCAT_VECTORS:\n    if (TypeIdx != 1) // TODO: This probably does work as expected already.\n      return UnableToLegalize;\n    return fewerElementsVectorMerge(MI, TypeIdx, NarrowTy);\n  case G_EXTRACT_VECTOR_ELT:\n  case G_INSERT_VECTOR_ELT:\n    return fewerElementsVectorExtractInsertVectorElt(MI, TypeIdx, NarrowTy);\n  case G_LOAD:\n  case G_STORE:\n    return reduceLoadStoreWidth(MI, TypeIdx, NarrowTy);\n  case G_SEXT_INREG:\n    return fewerElementsVectorSextInReg(MI, TypeIdx, NarrowTy);\n  default:\n    return UnableToLegalize;\n  }\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::narrowScalarShiftByConstant(MachineInstr &MI, const APInt &Amt,\n                                             const LLT HalfTy, const LLT AmtTy) {\n\n  Register InL = MRI.createGenericVirtualRegister(HalfTy);\n  Register InH = MRI.createGenericVirtualRegister(HalfTy);\n  MIRBuilder.buildUnmerge({InL, InH}, MI.getOperand(1));\n\n  if (Amt.isNullValue()) {\n    MIRBuilder.buildMerge(MI.getOperand(0), {InL, InH});\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  LLT NVT = HalfTy;\n  unsigned NVTBits = HalfTy.getSizeInBits();\n  unsigned VTBits = 2 * NVTBits;\n\n  SrcOp Lo(Register(0)), Hi(Register(0));\n  if (MI.getOpcode() == TargetOpcode::G_SHL) {\n    if (Amt.ugt(VTBits)) {\n      Lo = Hi = MIRBuilder.buildConstant(NVT, 0);\n    } else if (Amt.ugt(NVTBits)) {\n      Lo = MIRBuilder.buildConstant(NVT, 0);\n      Hi = MIRBuilder.buildShl(NVT, InL,\n                               MIRBuilder.buildConstant(AmtTy, Amt - NVTBits));\n    } else if (Amt == NVTBits) {\n      Lo = MIRBuilder.buildConstant(NVT, 0);\n      Hi = InL;\n    } else {\n      Lo = MIRBuilder.buildShl(NVT, InL, MIRBuilder.buildConstant(AmtTy, Amt));\n      auto OrLHS =\n          MIRBuilder.buildShl(NVT, InH, MIRBuilder.buildConstant(AmtTy, Amt));\n      auto OrRHS = MIRBuilder.buildLShr(\n          NVT, InL, MIRBuilder.buildConstant(AmtTy, -Amt + NVTBits));\n      Hi = MIRBuilder.buildOr(NVT, OrLHS, OrRHS);\n    }\n  } else if (MI.getOpcode() == TargetOpcode::G_LSHR) {\n    if (Amt.ugt(VTBits)) {\n      Lo = Hi = MIRBuilder.buildConstant(NVT, 0);\n    } else if (Amt.ugt(NVTBits)) {\n      Lo = MIRBuilder.buildLShr(NVT, InH,\n                                MIRBuilder.buildConstant(AmtTy, Amt - NVTBits));\n      Hi = MIRBuilder.buildConstant(NVT, 0);\n    } else if (Amt == NVTBits) {\n      Lo = InH;\n      Hi = MIRBuilder.buildConstant(NVT, 0);\n    } else {\n      auto ShiftAmtConst = MIRBuilder.buildConstant(AmtTy, Amt);\n\n      auto OrLHS = MIRBuilder.buildLShr(NVT, InL, ShiftAmtConst);\n      auto OrRHS = MIRBuilder.buildShl(\n          NVT, InH, MIRBuilder.buildConstant(AmtTy, -Amt + NVTBits));\n\n      Lo = MIRBuilder.buildOr(NVT, OrLHS, OrRHS);\n      Hi = MIRBuilder.buildLShr(NVT, InH, ShiftAmtConst);\n    }\n  } else {\n    if (Amt.ugt(VTBits)) {\n      Hi = Lo = MIRBuilder.buildAShr(\n          NVT, InH, MIRBuilder.buildConstant(AmtTy, NVTBits - 1));\n    } else if (Amt.ugt(NVTBits)) {\n      Lo = MIRBuilder.buildAShr(NVT, InH,\n                                MIRBuilder.buildConstant(AmtTy, Amt - NVTBits));\n      Hi = MIRBuilder.buildAShr(NVT, InH,\n                                MIRBuilder.buildConstant(AmtTy, NVTBits - 1));\n    } else if (Amt == NVTBits) {\n      Lo = InH;\n      Hi = MIRBuilder.buildAShr(NVT, InH,\n                                MIRBuilder.buildConstant(AmtTy, NVTBits - 1));\n    } else {\n      auto ShiftAmtConst = MIRBuilder.buildConstant(AmtTy, Amt);\n\n      auto OrLHS = MIRBuilder.buildLShr(NVT, InL, ShiftAmtConst);\n      auto OrRHS = MIRBuilder.buildShl(\n          NVT, InH, MIRBuilder.buildConstant(AmtTy, -Amt + NVTBits));\n\n      Lo = MIRBuilder.buildOr(NVT, OrLHS, OrRHS);\n      Hi = MIRBuilder.buildAShr(NVT, InH, ShiftAmtConst);\n    }\n  }\n\n  MIRBuilder.buildMerge(MI.getOperand(0), {Lo, Hi});\n  MI.eraseFromParent();\n\n  return Legalized;\n}\n\n// TODO: Optimize if constant shift amount.\nLegalizerHelper::LegalizeResult\nLegalizerHelper::narrowScalarShift(MachineInstr &MI, unsigned TypeIdx,\n                                   LLT RequestedTy) {\n  if (TypeIdx == 1) {\n    Observer.changingInstr(MI);\n    narrowScalarSrc(MI, RequestedTy, 2);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n\n  Register DstReg = MI.getOperand(0).getReg();\n  LLT DstTy = MRI.getType(DstReg);\n  if (DstTy.isVector())\n    return UnableToLegalize;\n\n  Register Amt = MI.getOperand(2).getReg();\n  LLT ShiftAmtTy = MRI.getType(Amt);\n  const unsigned DstEltSize = DstTy.getScalarSizeInBits();\n  if (DstEltSize % 2 != 0)\n    return UnableToLegalize;\n\n  // Ignore the input type. We can only go to exactly half the size of the\n  // input. If that isn't small enough, the resulting pieces will be further\n  // legalized.\n  const unsigned NewBitSize = DstEltSize / 2;\n  const LLT HalfTy = LLT::scalar(NewBitSize);\n  const LLT CondTy = LLT::scalar(1);\n\n  if (const MachineInstr *KShiftAmt =\n          getOpcodeDef(TargetOpcode::G_CONSTANT, Amt, MRI)) {\n    return narrowScalarShiftByConstant(\n        MI, KShiftAmt->getOperand(1).getCImm()->getValue(), HalfTy, ShiftAmtTy);\n  }\n\n  // TODO: Expand with known bits.\n\n  // Handle the fully general expansion by an unknown amount.\n  auto NewBits = MIRBuilder.buildConstant(ShiftAmtTy, NewBitSize);\n\n  Register InL = MRI.createGenericVirtualRegister(HalfTy);\n  Register InH = MRI.createGenericVirtualRegister(HalfTy);\n  MIRBuilder.buildUnmerge({InL, InH}, MI.getOperand(1));\n\n  auto AmtExcess = MIRBuilder.buildSub(ShiftAmtTy, Amt, NewBits);\n  auto AmtLack = MIRBuilder.buildSub(ShiftAmtTy, NewBits, Amt);\n\n  auto Zero = MIRBuilder.buildConstant(ShiftAmtTy, 0);\n  auto IsShort = MIRBuilder.buildICmp(ICmpInst::ICMP_ULT, CondTy, Amt, NewBits);\n  auto IsZero = MIRBuilder.buildICmp(ICmpInst::ICMP_EQ, CondTy, Amt, Zero);\n\n  Register ResultRegs[2];\n  switch (MI.getOpcode()) {\n  case TargetOpcode::G_SHL: {\n    // Short: ShAmt < NewBitSize\n    auto LoS = MIRBuilder.buildShl(HalfTy, InL, Amt);\n\n    auto LoOr = MIRBuilder.buildLShr(HalfTy, InL, AmtLack);\n    auto HiOr = MIRBuilder.buildShl(HalfTy, InH, Amt);\n    auto HiS = MIRBuilder.buildOr(HalfTy, LoOr, HiOr);\n\n    // Long: ShAmt >= NewBitSize\n    auto LoL = MIRBuilder.buildConstant(HalfTy, 0);         // Lo part is zero.\n    auto HiL = MIRBuilder.buildShl(HalfTy, InL, AmtExcess); // Hi from Lo part.\n\n    auto Lo = MIRBuilder.buildSelect(HalfTy, IsShort, LoS, LoL);\n    auto Hi = MIRBuilder.buildSelect(\n        HalfTy, IsZero, InH, MIRBuilder.buildSelect(HalfTy, IsShort, HiS, HiL));\n\n    ResultRegs[0] = Lo.getReg(0);\n    ResultRegs[1] = Hi.getReg(0);\n    break;\n  }\n  case TargetOpcode::G_LSHR:\n  case TargetOpcode::G_ASHR: {\n    // Short: ShAmt < NewBitSize\n    auto HiS = MIRBuilder.buildInstr(MI.getOpcode(), {HalfTy}, {InH, Amt});\n\n    auto LoOr = MIRBuilder.buildLShr(HalfTy, InL, Amt);\n    auto HiOr = MIRBuilder.buildShl(HalfTy, InH, AmtLack);\n    auto LoS = MIRBuilder.buildOr(HalfTy, LoOr, HiOr);\n\n    // Long: ShAmt >= NewBitSize\n    MachineInstrBuilder HiL;\n    if (MI.getOpcode() == TargetOpcode::G_LSHR) {\n      HiL = MIRBuilder.buildConstant(HalfTy, 0);            // Hi part is zero.\n    } else {\n      auto ShiftAmt = MIRBuilder.buildConstant(ShiftAmtTy, NewBitSize - 1);\n      HiL = MIRBuilder.buildAShr(HalfTy, InH, ShiftAmt);    // Sign of Hi part.\n    }\n    auto LoL = MIRBuilder.buildInstr(MI.getOpcode(), {HalfTy},\n                                     {InH, AmtExcess});     // Lo from Hi part.\n\n    auto Lo = MIRBuilder.buildSelect(\n        HalfTy, IsZero, InL, MIRBuilder.buildSelect(HalfTy, IsShort, LoS, LoL));\n\n    auto Hi = MIRBuilder.buildSelect(HalfTy, IsShort, HiS, HiL);\n\n    ResultRegs[0] = Lo.getReg(0);\n    ResultRegs[1] = Hi.getReg(0);\n    break;\n  }\n  default:\n    llvm_unreachable(\"not a shift\");\n  }\n\n  MIRBuilder.buildMerge(DstReg, ResultRegs);\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::moreElementsVectorPhi(MachineInstr &MI, unsigned TypeIdx,\n                                       LLT MoreTy) {\n  assert(TypeIdx == 0 && \"Expecting only Idx 0\");\n\n  Observer.changingInstr(MI);\n  for (unsigned I = 1, E = MI.getNumOperands(); I != E; I += 2) {\n    MachineBasicBlock &OpMBB = *MI.getOperand(I + 1).getMBB();\n    MIRBuilder.setInsertPt(OpMBB, OpMBB.getFirstTerminator());\n    moreElementsVectorSrc(MI, MoreTy, I);\n  }\n\n  MachineBasicBlock &MBB = *MI.getParent();\n  MIRBuilder.setInsertPt(MBB, --MBB.getFirstNonPHI());\n  moreElementsVectorDst(MI, MoreTy, 0);\n  Observer.changedInstr(MI);\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::moreElementsVector(MachineInstr &MI, unsigned TypeIdx,\n                                    LLT MoreTy) {\n  unsigned Opc = MI.getOpcode();\n  switch (Opc) {\n  case TargetOpcode::G_IMPLICIT_DEF:\n  case TargetOpcode::G_LOAD: {\n    if (TypeIdx != 0)\n      return UnableToLegalize;\n    Observer.changingInstr(MI);\n    moreElementsVectorDst(MI, MoreTy, 0);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_STORE:\n    if (TypeIdx != 0)\n      return UnableToLegalize;\n    Observer.changingInstr(MI);\n    moreElementsVectorSrc(MI, MoreTy, 0);\n    Observer.changedInstr(MI);\n    return Legalized;\n  case TargetOpcode::G_AND:\n  case TargetOpcode::G_OR:\n  case TargetOpcode::G_XOR:\n  case TargetOpcode::G_SMIN:\n  case TargetOpcode::G_SMAX:\n  case TargetOpcode::G_UMIN:\n  case TargetOpcode::G_UMAX:\n  case TargetOpcode::G_FMINNUM:\n  case TargetOpcode::G_FMAXNUM:\n  case TargetOpcode::G_FMINNUM_IEEE:\n  case TargetOpcode::G_FMAXNUM_IEEE:\n  case TargetOpcode::G_FMINIMUM:\n  case TargetOpcode::G_FMAXIMUM: {\n    Observer.changingInstr(MI);\n    moreElementsVectorSrc(MI, MoreTy, 1);\n    moreElementsVectorSrc(MI, MoreTy, 2);\n    moreElementsVectorDst(MI, MoreTy, 0);\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_EXTRACT:\n    if (TypeIdx != 1)\n      return UnableToLegalize;\n    Observer.changingInstr(MI);\n    moreElementsVectorSrc(MI, MoreTy, 1);\n    Observer.changedInstr(MI);\n    return Legalized;\n  case TargetOpcode::G_INSERT:\n  case TargetOpcode::G_FREEZE:\n    if (TypeIdx != 0)\n      return UnableToLegalize;\n    Observer.changingInstr(MI);\n    moreElementsVectorSrc(MI, MoreTy, 1);\n    moreElementsVectorDst(MI, MoreTy, 0);\n    Observer.changedInstr(MI);\n    return Legalized;\n  case TargetOpcode::G_SELECT:\n    if (TypeIdx != 0)\n      return UnableToLegalize;\n    if (MRI.getType(MI.getOperand(1).getReg()).isVector())\n      return UnableToLegalize;\n\n    Observer.changingInstr(MI);\n    moreElementsVectorSrc(MI, MoreTy, 2);\n    moreElementsVectorSrc(MI, MoreTy, 3);\n    moreElementsVectorDst(MI, MoreTy, 0);\n    Observer.changedInstr(MI);\n    return Legalized;\n  case TargetOpcode::G_UNMERGE_VALUES: {\n    if (TypeIdx != 1)\n      return UnableToLegalize;\n\n    LLT DstTy = MRI.getType(MI.getOperand(0).getReg());\n    int NumDst = MI.getNumOperands() - 1;\n    moreElementsVectorSrc(MI, MoreTy, NumDst);\n\n    auto MIB = MIRBuilder.buildInstr(TargetOpcode::G_UNMERGE_VALUES);\n    for (int I = 0; I != NumDst; ++I)\n      MIB.addDef(MI.getOperand(I).getReg());\n\n    int NewNumDst = MoreTy.getSizeInBits() / DstTy.getSizeInBits();\n    for (int I = NumDst; I != NewNumDst; ++I)\n      MIB.addDef(MRI.createGenericVirtualRegister(DstTy));\n\n    MIB.addUse(MI.getOperand(NumDst).getReg());\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case TargetOpcode::G_PHI:\n    return moreElementsVectorPhi(MI, TypeIdx, MoreTy);\n  default:\n    return UnableToLegalize;\n  }\n}\n\nvoid LegalizerHelper::multiplyRegisters(SmallVectorImpl<Register> &DstRegs,\n                                        ArrayRef<Register> Src1Regs,\n                                        ArrayRef<Register> Src2Regs,\n                                        LLT NarrowTy) {\n  MachineIRBuilder &B = MIRBuilder;\n  unsigned SrcParts = Src1Regs.size();\n  unsigned DstParts = DstRegs.size();\n\n  unsigned DstIdx = 0; // Low bits of the result.\n  Register FactorSum =\n      B.buildMul(NarrowTy, Src1Regs[DstIdx], Src2Regs[DstIdx]).getReg(0);\n  DstRegs[DstIdx] = FactorSum;\n\n  unsigned CarrySumPrevDstIdx;\n  SmallVector<Register, 4> Factors;\n\n  for (DstIdx = 1; DstIdx < DstParts; DstIdx++) {\n    // Collect low parts of muls for DstIdx.\n    for (unsigned i = DstIdx + 1 < SrcParts ? 0 : DstIdx - SrcParts + 1;\n         i <= std::min(DstIdx, SrcParts - 1); ++i) {\n      MachineInstrBuilder Mul =\n          B.buildMul(NarrowTy, Src1Regs[DstIdx - i], Src2Regs[i]);\n      Factors.push_back(Mul.getReg(0));\n    }\n    // Collect high parts of muls from previous DstIdx.\n    for (unsigned i = DstIdx < SrcParts ? 0 : DstIdx - SrcParts;\n         i <= std::min(DstIdx - 1, SrcParts - 1); ++i) {\n      MachineInstrBuilder Umulh =\n          B.buildUMulH(NarrowTy, Src1Regs[DstIdx - 1 - i], Src2Regs[i]);\n      Factors.push_back(Umulh.getReg(0));\n    }\n    // Add CarrySum from additions calculated for previous DstIdx.\n    if (DstIdx != 1) {\n      Factors.push_back(CarrySumPrevDstIdx);\n    }\n\n    Register CarrySum;\n    // Add all factors and accumulate all carries into CarrySum.\n    if (DstIdx != DstParts - 1) {\n      MachineInstrBuilder Uaddo =\n          B.buildUAddo(NarrowTy, LLT::scalar(1), Factors[0], Factors[1]);\n      FactorSum = Uaddo.getReg(0);\n      CarrySum = B.buildZExt(NarrowTy, Uaddo.getReg(1)).getReg(0);\n      for (unsigned i = 2; i < Factors.size(); ++i) {\n        MachineInstrBuilder Uaddo =\n            B.buildUAddo(NarrowTy, LLT::scalar(1), FactorSum, Factors[i]);\n        FactorSum = Uaddo.getReg(0);\n        MachineInstrBuilder Carry = B.buildZExt(NarrowTy, Uaddo.getReg(1));\n        CarrySum = B.buildAdd(NarrowTy, CarrySum, Carry).getReg(0);\n      }\n    } else {\n      // Since value for the next index is not calculated, neither is CarrySum.\n      FactorSum = B.buildAdd(NarrowTy, Factors[0], Factors[1]).getReg(0);\n      for (unsigned i = 2; i < Factors.size(); ++i)\n        FactorSum = B.buildAdd(NarrowTy, FactorSum, Factors[i]).getReg(0);\n    }\n\n    CarrySumPrevDstIdx = CarrySum;\n    DstRegs[DstIdx] = FactorSum;\n    Factors.clear();\n  }\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::narrowScalarAddSub(MachineInstr &MI, unsigned TypeIdx,\n                                    LLT NarrowTy) {\n  if (TypeIdx != 0)\n    return UnableToLegalize;\n\n  Register DstReg = MI.getOperand(0).getReg();\n  LLT DstType = MRI.getType(DstReg);\n  // FIXME: add support for vector types\n  if (DstType.isVector())\n    return UnableToLegalize;\n\n  uint64_t SizeOp0 = DstType.getSizeInBits();\n  uint64_t NarrowSize = NarrowTy.getSizeInBits();\n\n  // FIXME: add support for when SizeOp0 isn't an exact multiple of\n  // NarrowSize.\n  if (SizeOp0 % NarrowSize != 0)\n    return UnableToLegalize;\n\n  // Expand in terms of carry-setting/consuming G_<Op>E instructions.\n  int NumParts = SizeOp0 / NarrowTy.getSizeInBits();\n\n  unsigned OpO, OpE;\n  switch (MI.getOpcode()) {\n  case TargetOpcode::G_ADD:\n    OpO = TargetOpcode::G_UADDO;\n    OpE = TargetOpcode::G_UADDE;\n    break;\n  case TargetOpcode::G_SUB:\n    OpO = TargetOpcode::G_USUBO;\n    OpE = TargetOpcode::G_USUBE;\n    break;\n  default:\n    llvm_unreachable(\"Unexpected add/sub opcode!\");\n  }\n\n  SmallVector<Register, 2> Src1Regs, Src2Regs, DstRegs;\n  extractParts(MI.getOperand(1).getReg(), NarrowTy, NumParts, Src1Regs);\n  extractParts(MI.getOperand(2).getReg(), NarrowTy, NumParts, Src2Regs);\n\n  Register CarryIn;\n  for (int i = 0; i < NumParts; ++i) {\n    Register DstReg = MRI.createGenericVirtualRegister(NarrowTy);\n    Register CarryOut = MRI.createGenericVirtualRegister(LLT::scalar(1));\n\n    if (i == 0)\n      MIRBuilder.buildInstr(OpO, {DstReg, CarryOut},\n                            {Src1Regs[i], Src2Regs[i]});\n    else {\n      MIRBuilder.buildInstr(OpE, {DstReg, CarryOut},\n                            {Src1Regs[i], Src2Regs[i], CarryIn});\n    }\n\n    DstRegs.push_back(DstReg);\n    CarryIn = CarryOut;\n  }\n  MIRBuilder.buildMerge(DstReg, DstRegs);\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::narrowScalarMul(MachineInstr &MI, LLT NarrowTy) {\n  Register DstReg = MI.getOperand(0).getReg();\n  Register Src1 = MI.getOperand(1).getReg();\n  Register Src2 = MI.getOperand(2).getReg();\n\n  LLT Ty = MRI.getType(DstReg);\n  if (Ty.isVector())\n    return UnableToLegalize;\n\n  unsigned SrcSize = MRI.getType(Src1).getSizeInBits();\n  unsigned DstSize = Ty.getSizeInBits();\n  unsigned NarrowSize = NarrowTy.getSizeInBits();\n  if (DstSize % NarrowSize != 0 || SrcSize % NarrowSize != 0)\n    return UnableToLegalize;\n\n  unsigned NumDstParts = DstSize / NarrowSize;\n  unsigned NumSrcParts = SrcSize / NarrowSize;\n  bool IsMulHigh = MI.getOpcode() == TargetOpcode::G_UMULH;\n  unsigned DstTmpParts = NumDstParts * (IsMulHigh ? 2 : 1);\n\n  SmallVector<Register, 2> Src1Parts, Src2Parts;\n  SmallVector<Register, 2> DstTmpRegs(DstTmpParts);\n  extractParts(Src1, NarrowTy, NumSrcParts, Src1Parts);\n  extractParts(Src2, NarrowTy, NumSrcParts, Src2Parts);\n  multiplyRegisters(DstTmpRegs, Src1Parts, Src2Parts, NarrowTy);\n\n  // Take only high half of registers if this is high mul.\n  ArrayRef<Register> DstRegs(\n      IsMulHigh ? &DstTmpRegs[DstTmpParts / 2] : &DstTmpRegs[0], NumDstParts);\n  MIRBuilder.buildMerge(DstReg, DstRegs);\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::narrowScalarExtract(MachineInstr &MI, unsigned TypeIdx,\n                                     LLT NarrowTy) {\n  if (TypeIdx != 1)\n    return UnableToLegalize;\n\n  uint64_t NarrowSize = NarrowTy.getSizeInBits();\n\n  int64_t SizeOp1 = MRI.getType(MI.getOperand(1).getReg()).getSizeInBits();\n  // FIXME: add support for when SizeOp1 isn't an exact multiple of\n  // NarrowSize.\n  if (SizeOp1 % NarrowSize != 0)\n    return UnableToLegalize;\n  int NumParts = SizeOp1 / NarrowSize;\n\n  SmallVector<Register, 2> SrcRegs, DstRegs;\n  SmallVector<uint64_t, 2> Indexes;\n  extractParts(MI.getOperand(1).getReg(), NarrowTy, NumParts, SrcRegs);\n\n  Register OpReg = MI.getOperand(0).getReg();\n  uint64_t OpStart = MI.getOperand(2).getImm();\n  uint64_t OpSize = MRI.getType(OpReg).getSizeInBits();\n  for (int i = 0; i < NumParts; ++i) {\n    unsigned SrcStart = i * NarrowSize;\n\n    if (SrcStart + NarrowSize <= OpStart || SrcStart >= OpStart + OpSize) {\n      // No part of the extract uses this subregister, ignore it.\n      continue;\n    } else if (SrcStart == OpStart && NarrowTy == MRI.getType(OpReg)) {\n      // The entire subregister is extracted, forward the value.\n      DstRegs.push_back(SrcRegs[i]);\n      continue;\n    }\n\n    // OpSegStart is where this destination segment would start in OpReg if it\n    // extended infinitely in both directions.\n    int64_t ExtractOffset;\n    uint64_t SegSize;\n    if (OpStart < SrcStart) {\n      ExtractOffset = 0;\n      SegSize = std::min(NarrowSize, OpStart + OpSize - SrcStart);\n    } else {\n      ExtractOffset = OpStart - SrcStart;\n      SegSize = std::min(SrcStart + NarrowSize - OpStart, OpSize);\n    }\n\n    Register SegReg = SrcRegs[i];\n    if (ExtractOffset != 0 || SegSize != NarrowSize) {\n      // A genuine extract is needed.\n      SegReg = MRI.createGenericVirtualRegister(LLT::scalar(SegSize));\n      MIRBuilder.buildExtract(SegReg, SrcRegs[i], ExtractOffset);\n    }\n\n    DstRegs.push_back(SegReg);\n  }\n\n  Register DstReg = MI.getOperand(0).getReg();\n  if (MRI.getType(DstReg).isVector())\n    MIRBuilder.buildBuildVector(DstReg, DstRegs);\n  else if (DstRegs.size() > 1)\n    MIRBuilder.buildMerge(DstReg, DstRegs);\n  else\n    MIRBuilder.buildCopy(DstReg, DstRegs[0]);\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::narrowScalarInsert(MachineInstr &MI, unsigned TypeIdx,\n                                    LLT NarrowTy) {\n  // FIXME: Don't know how to handle secondary types yet.\n  if (TypeIdx != 0)\n    return UnableToLegalize;\n\n  uint64_t SizeOp0 = MRI.getType(MI.getOperand(0).getReg()).getSizeInBits();\n  uint64_t NarrowSize = NarrowTy.getSizeInBits();\n\n  // FIXME: add support for when SizeOp0 isn't an exact multiple of\n  // NarrowSize.\n  if (SizeOp0 % NarrowSize != 0)\n    return UnableToLegalize;\n\n  int NumParts = SizeOp0 / NarrowSize;\n\n  SmallVector<Register, 2> SrcRegs, DstRegs;\n  SmallVector<uint64_t, 2> Indexes;\n  extractParts(MI.getOperand(1).getReg(), NarrowTy, NumParts, SrcRegs);\n\n  Register OpReg = MI.getOperand(2).getReg();\n  uint64_t OpStart = MI.getOperand(3).getImm();\n  uint64_t OpSize = MRI.getType(OpReg).getSizeInBits();\n  for (int i = 0; i < NumParts; ++i) {\n    unsigned DstStart = i * NarrowSize;\n\n    if (DstStart + NarrowSize <= OpStart || DstStart >= OpStart + OpSize) {\n      // No part of the insert affects this subregister, forward the original.\n      DstRegs.push_back(SrcRegs[i]);\n      continue;\n    } else if (DstStart == OpStart && NarrowTy == MRI.getType(OpReg)) {\n      // The entire subregister is defined by this insert, forward the new\n      // value.\n      DstRegs.push_back(OpReg);\n      continue;\n    }\n\n    // OpSegStart is where this destination segment would start in OpReg if it\n    // extended infinitely in both directions.\n    int64_t ExtractOffset, InsertOffset;\n    uint64_t SegSize;\n    if (OpStart < DstStart) {\n      InsertOffset = 0;\n      ExtractOffset = DstStart - OpStart;\n      SegSize = std::min(NarrowSize, OpStart + OpSize - DstStart);\n    } else {\n      InsertOffset = OpStart - DstStart;\n      ExtractOffset = 0;\n      SegSize =\n        std::min(NarrowSize - InsertOffset, OpStart + OpSize - DstStart);\n    }\n\n    Register SegReg = OpReg;\n    if (ExtractOffset != 0 || SegSize != OpSize) {\n      // A genuine extract is needed.\n      SegReg = MRI.createGenericVirtualRegister(LLT::scalar(SegSize));\n      MIRBuilder.buildExtract(SegReg, OpReg, ExtractOffset);\n    }\n\n    Register DstReg = MRI.createGenericVirtualRegister(NarrowTy);\n    MIRBuilder.buildInsert(DstReg, SrcRegs[i], SegReg, InsertOffset);\n    DstRegs.push_back(DstReg);\n  }\n\n  assert(DstRegs.size() == (unsigned)NumParts && \"not all parts covered\");\n  Register DstReg = MI.getOperand(0).getReg();\n  if(MRI.getType(DstReg).isVector())\n    MIRBuilder.buildBuildVector(DstReg, DstRegs);\n  else\n    MIRBuilder.buildMerge(DstReg, DstRegs);\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::narrowScalarBasic(MachineInstr &MI, unsigned TypeIdx,\n                                   LLT NarrowTy) {\n  Register DstReg = MI.getOperand(0).getReg();\n  LLT DstTy = MRI.getType(DstReg);\n\n  assert(MI.getNumOperands() == 3 && TypeIdx == 0);\n\n  SmallVector<Register, 4> DstRegs, DstLeftoverRegs;\n  SmallVector<Register, 4> Src0Regs, Src0LeftoverRegs;\n  SmallVector<Register, 4> Src1Regs, Src1LeftoverRegs;\n  LLT LeftoverTy;\n  if (!extractParts(MI.getOperand(1).getReg(), DstTy, NarrowTy, LeftoverTy,\n                    Src0Regs, Src0LeftoverRegs))\n    return UnableToLegalize;\n\n  LLT Unused;\n  if (!extractParts(MI.getOperand(2).getReg(), DstTy, NarrowTy, Unused,\n                    Src1Regs, Src1LeftoverRegs))\n    llvm_unreachable(\"inconsistent extractParts result\");\n\n  for (unsigned I = 0, E = Src1Regs.size(); I != E; ++I) {\n    auto Inst = MIRBuilder.buildInstr(MI.getOpcode(), {NarrowTy},\n                                        {Src0Regs[I], Src1Regs[I]});\n    DstRegs.push_back(Inst.getReg(0));\n  }\n\n  for (unsigned I = 0, E = Src1LeftoverRegs.size(); I != E; ++I) {\n    auto Inst = MIRBuilder.buildInstr(\n      MI.getOpcode(),\n      {LeftoverTy}, {Src0LeftoverRegs[I], Src1LeftoverRegs[I]});\n    DstLeftoverRegs.push_back(Inst.getReg(0));\n  }\n\n  insertParts(DstReg, DstTy, NarrowTy, DstRegs,\n              LeftoverTy, DstLeftoverRegs);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::narrowScalarExt(MachineInstr &MI, unsigned TypeIdx,\n                                 LLT NarrowTy) {\n  if (TypeIdx != 0)\n    return UnableToLegalize;\n\n  Register DstReg = MI.getOperand(0).getReg();\n  Register SrcReg = MI.getOperand(1).getReg();\n\n  LLT DstTy = MRI.getType(DstReg);\n  if (DstTy.isVector())\n    return UnableToLegalize;\n\n  SmallVector<Register, 8> Parts;\n  LLT GCDTy = extractGCDType(Parts, DstTy, NarrowTy, SrcReg);\n  LLT LCMTy = buildLCMMergePieces(DstTy, NarrowTy, GCDTy, Parts, MI.getOpcode());\n  buildWidenedRemergeToDst(DstReg, LCMTy, Parts);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::narrowScalarSelect(MachineInstr &MI, unsigned TypeIdx,\n                                    LLT NarrowTy) {\n  if (TypeIdx != 0)\n    return UnableToLegalize;\n\n  Register CondReg = MI.getOperand(1).getReg();\n  LLT CondTy = MRI.getType(CondReg);\n  if (CondTy.isVector()) // TODO: Handle vselect\n    return UnableToLegalize;\n\n  Register DstReg = MI.getOperand(0).getReg();\n  LLT DstTy = MRI.getType(DstReg);\n\n  SmallVector<Register, 4> DstRegs, DstLeftoverRegs;\n  SmallVector<Register, 4> Src1Regs, Src1LeftoverRegs;\n  SmallVector<Register, 4> Src2Regs, Src2LeftoverRegs;\n  LLT LeftoverTy;\n  if (!extractParts(MI.getOperand(2).getReg(), DstTy, NarrowTy, LeftoverTy,\n                    Src1Regs, Src1LeftoverRegs))\n    return UnableToLegalize;\n\n  LLT Unused;\n  if (!extractParts(MI.getOperand(3).getReg(), DstTy, NarrowTy, Unused,\n                    Src2Regs, Src2LeftoverRegs))\n    llvm_unreachable(\"inconsistent extractParts result\");\n\n  for (unsigned I = 0, E = Src1Regs.size(); I != E; ++I) {\n    auto Select = MIRBuilder.buildSelect(NarrowTy,\n                                         CondReg, Src1Regs[I], Src2Regs[I]);\n    DstRegs.push_back(Select.getReg(0));\n  }\n\n  for (unsigned I = 0, E = Src1LeftoverRegs.size(); I != E; ++I) {\n    auto Select = MIRBuilder.buildSelect(\n      LeftoverTy, CondReg, Src1LeftoverRegs[I], Src2LeftoverRegs[I]);\n    DstLeftoverRegs.push_back(Select.getReg(0));\n  }\n\n  insertParts(DstReg, DstTy, NarrowTy, DstRegs,\n              LeftoverTy, DstLeftoverRegs);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::narrowScalarCTLZ(MachineInstr &MI, unsigned TypeIdx,\n                                  LLT NarrowTy) {\n  if (TypeIdx != 1)\n    return UnableToLegalize;\n\n  Register DstReg = MI.getOperand(0).getReg();\n  Register SrcReg = MI.getOperand(1).getReg();\n  LLT DstTy = MRI.getType(DstReg);\n  LLT SrcTy = MRI.getType(SrcReg);\n  unsigned NarrowSize = NarrowTy.getSizeInBits();\n\n  if (SrcTy.isScalar() && SrcTy.getSizeInBits() == 2 * NarrowSize) {\n    const bool IsUndef = MI.getOpcode() == TargetOpcode::G_CTLZ_ZERO_UNDEF;\n\n    MachineIRBuilder &B = MIRBuilder;\n    auto UnmergeSrc = B.buildUnmerge(NarrowTy, SrcReg);\n    // ctlz(Hi:Lo) -> Hi == 0 ? (NarrowSize + ctlz(Lo)) : ctlz(Hi)\n    auto C_0 = B.buildConstant(NarrowTy, 0);\n    auto HiIsZero = B.buildICmp(CmpInst::ICMP_EQ, LLT::scalar(1),\n                                UnmergeSrc.getReg(1), C_0);\n    auto LoCTLZ = IsUndef ?\n      B.buildCTLZ_ZERO_UNDEF(DstTy, UnmergeSrc.getReg(0)) :\n      B.buildCTLZ(DstTy, UnmergeSrc.getReg(0));\n    auto C_NarrowSize = B.buildConstant(DstTy, NarrowSize);\n    auto HiIsZeroCTLZ = B.buildAdd(DstTy, LoCTLZ, C_NarrowSize);\n    auto HiCTLZ = B.buildCTLZ_ZERO_UNDEF(DstTy, UnmergeSrc.getReg(1));\n    B.buildSelect(DstReg, HiIsZero, HiIsZeroCTLZ, HiCTLZ);\n\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  return UnableToLegalize;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::narrowScalarCTTZ(MachineInstr &MI, unsigned TypeIdx,\n                                  LLT NarrowTy) {\n  if (TypeIdx != 1)\n    return UnableToLegalize;\n\n  Register DstReg = MI.getOperand(0).getReg();\n  Register SrcReg = MI.getOperand(1).getReg();\n  LLT DstTy = MRI.getType(DstReg);\n  LLT SrcTy = MRI.getType(SrcReg);\n  unsigned NarrowSize = NarrowTy.getSizeInBits();\n\n  if (SrcTy.isScalar() && SrcTy.getSizeInBits() == 2 * NarrowSize) {\n    const bool IsUndef = MI.getOpcode() == TargetOpcode::G_CTTZ_ZERO_UNDEF;\n\n    MachineIRBuilder &B = MIRBuilder;\n    auto UnmergeSrc = B.buildUnmerge(NarrowTy, SrcReg);\n    // cttz(Hi:Lo) -> Lo == 0 ? (cttz(Hi) + NarrowSize) : cttz(Lo)\n    auto C_0 = B.buildConstant(NarrowTy, 0);\n    auto LoIsZero = B.buildICmp(CmpInst::ICMP_EQ, LLT::scalar(1),\n                                UnmergeSrc.getReg(0), C_0);\n    auto HiCTTZ = IsUndef ?\n      B.buildCTTZ_ZERO_UNDEF(DstTy, UnmergeSrc.getReg(1)) :\n      B.buildCTTZ(DstTy, UnmergeSrc.getReg(1));\n    auto C_NarrowSize = B.buildConstant(DstTy, NarrowSize);\n    auto LoIsZeroCTTZ = B.buildAdd(DstTy, HiCTTZ, C_NarrowSize);\n    auto LoCTTZ = B.buildCTTZ_ZERO_UNDEF(DstTy, UnmergeSrc.getReg(0));\n    B.buildSelect(DstReg, LoIsZero, LoIsZeroCTTZ, LoCTTZ);\n\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  return UnableToLegalize;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::narrowScalarCTPOP(MachineInstr &MI, unsigned TypeIdx,\n                                   LLT NarrowTy) {\n  if (TypeIdx != 1)\n    return UnableToLegalize;\n\n  Register DstReg = MI.getOperand(0).getReg();\n  LLT DstTy = MRI.getType(DstReg);\n  LLT SrcTy = MRI.getType(MI.getOperand(1).getReg());\n  unsigned NarrowSize = NarrowTy.getSizeInBits();\n\n  if (SrcTy.isScalar() && SrcTy.getSizeInBits() == 2 * NarrowSize) {\n    auto UnmergeSrc = MIRBuilder.buildUnmerge(NarrowTy, MI.getOperand(1));\n\n    auto LoCTPOP = MIRBuilder.buildCTPOP(DstTy, UnmergeSrc.getReg(0));\n    auto HiCTPOP = MIRBuilder.buildCTPOP(DstTy, UnmergeSrc.getReg(1));\n    MIRBuilder.buildAdd(DstReg, HiCTPOP, LoCTPOP);\n\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  return UnableToLegalize;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerBitCount(MachineInstr &MI) {\n  unsigned Opc = MI.getOpcode();\n  const auto &TII = MIRBuilder.getTII();\n  auto isSupported = [this](const LegalityQuery &Q) {\n    auto QAction = LI.getAction(Q).Action;\n    return QAction == Legal || QAction == Libcall || QAction == Custom;\n  };\n  switch (Opc) {\n  default:\n    return UnableToLegalize;\n  case TargetOpcode::G_CTLZ_ZERO_UNDEF: {\n    // This trivially expands to CTLZ.\n    Observer.changingInstr(MI);\n    MI.setDesc(TII.get(TargetOpcode::G_CTLZ));\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_CTLZ: {\n    Register DstReg = MI.getOperand(0).getReg();\n    Register SrcReg = MI.getOperand(1).getReg();\n    LLT DstTy = MRI.getType(DstReg);\n    LLT SrcTy = MRI.getType(SrcReg);\n    unsigned Len = SrcTy.getSizeInBits();\n\n    if (isSupported({TargetOpcode::G_CTLZ_ZERO_UNDEF, {DstTy, SrcTy}})) {\n      // If CTLZ_ZERO_UNDEF is supported, emit that and a select for zero.\n      auto CtlzZU = MIRBuilder.buildCTLZ_ZERO_UNDEF(DstTy, SrcReg);\n      auto ZeroSrc = MIRBuilder.buildConstant(SrcTy, 0);\n      auto ICmp = MIRBuilder.buildICmp(\n          CmpInst::ICMP_EQ, SrcTy.changeElementSize(1), SrcReg, ZeroSrc);\n      auto LenConst = MIRBuilder.buildConstant(DstTy, Len);\n      MIRBuilder.buildSelect(DstReg, ICmp, LenConst, CtlzZU);\n      MI.eraseFromParent();\n      return Legalized;\n    }\n    // for now, we do this:\n    // NewLen = NextPowerOf2(Len);\n    // x = x | (x >> 1);\n    // x = x | (x >> 2);\n    // ...\n    // x = x | (x >>16);\n    // x = x | (x >>32); // for 64-bit input\n    // Upto NewLen/2\n    // return Len - popcount(x);\n    //\n    // Ref: \"Hacker's Delight\" by Henry Warren\n    Register Op = SrcReg;\n    unsigned NewLen = PowerOf2Ceil(Len);\n    for (unsigned i = 0; (1U << i) <= (NewLen / 2); ++i) {\n      auto MIBShiftAmt = MIRBuilder.buildConstant(SrcTy, 1ULL << i);\n      auto MIBOp = MIRBuilder.buildOr(\n          SrcTy, Op, MIRBuilder.buildLShr(SrcTy, Op, MIBShiftAmt));\n      Op = MIBOp.getReg(0);\n    }\n    auto MIBPop = MIRBuilder.buildCTPOP(DstTy, Op);\n    MIRBuilder.buildSub(MI.getOperand(0), MIRBuilder.buildConstant(DstTy, Len),\n                        MIBPop);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  case TargetOpcode::G_CTTZ_ZERO_UNDEF: {\n    // This trivially expands to CTTZ.\n    Observer.changingInstr(MI);\n    MI.setDesc(TII.get(TargetOpcode::G_CTTZ));\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n  case TargetOpcode::G_CTTZ: {\n    Register DstReg = MI.getOperand(0).getReg();\n    Register SrcReg = MI.getOperand(1).getReg();\n    LLT DstTy = MRI.getType(DstReg);\n    LLT SrcTy = MRI.getType(SrcReg);\n\n    unsigned Len = SrcTy.getSizeInBits();\n    if (isSupported({TargetOpcode::G_CTTZ_ZERO_UNDEF, {DstTy, SrcTy}})) {\n      // If CTTZ_ZERO_UNDEF is legal or custom, emit that and a select with\n      // zero.\n      auto CttzZU = MIRBuilder.buildCTTZ_ZERO_UNDEF(DstTy, SrcReg);\n      auto Zero = MIRBuilder.buildConstant(SrcTy, 0);\n      auto ICmp = MIRBuilder.buildICmp(\n          CmpInst::ICMP_EQ, DstTy.changeElementSize(1), SrcReg, Zero);\n      auto LenConst = MIRBuilder.buildConstant(DstTy, Len);\n      MIRBuilder.buildSelect(DstReg, ICmp, LenConst, CttzZU);\n      MI.eraseFromParent();\n      return Legalized;\n    }\n    // for now, we use: { return popcount(~x & (x - 1)); }\n    // unless the target has ctlz but not ctpop, in which case we use:\n    // { return 32 - nlz(~x & (x-1)); }\n    // Ref: \"Hacker's Delight\" by Henry Warren\n    auto MIBCstNeg1 = MIRBuilder.buildConstant(SrcTy, -1);\n    auto MIBNot = MIRBuilder.buildXor(SrcTy, SrcReg, MIBCstNeg1);\n    auto MIBTmp = MIRBuilder.buildAnd(\n        SrcTy, MIBNot, MIRBuilder.buildAdd(SrcTy, SrcReg, MIBCstNeg1));\n    if (!isSupported({TargetOpcode::G_CTPOP, {SrcTy, SrcTy}}) &&\n        isSupported({TargetOpcode::G_CTLZ, {SrcTy, SrcTy}})) {\n      auto MIBCstLen = MIRBuilder.buildConstant(SrcTy, Len);\n      MIRBuilder.buildSub(MI.getOperand(0), MIBCstLen,\n                          MIRBuilder.buildCTLZ(SrcTy, MIBTmp));\n      MI.eraseFromParent();\n      return Legalized;\n    }\n    MI.setDesc(TII.get(TargetOpcode::G_CTPOP));\n    MI.getOperand(1).setReg(MIBTmp.getReg(0));\n    return Legalized;\n  }\n  case TargetOpcode::G_CTPOP: {\n    Register SrcReg = MI.getOperand(1).getReg();\n    LLT Ty = MRI.getType(SrcReg);\n    unsigned Size = Ty.getSizeInBits();\n    MachineIRBuilder &B = MIRBuilder;\n\n    // Count set bits in blocks of 2 bits. Default approach would be\n    // B2Count = { val & 0x55555555 } + { (val >> 1) & 0x55555555 }\n    // We use following formula instead:\n    // B2Count = val - { (val >> 1) & 0x55555555 }\n    // since it gives same result in blocks of 2 with one instruction less.\n    auto C_1 = B.buildConstant(Ty, 1);\n    auto B2Set1LoTo1Hi = B.buildLShr(Ty, SrcReg, C_1);\n    APInt B2Mask1HiTo0 = APInt::getSplat(Size, APInt(8, 0x55));\n    auto C_B2Mask1HiTo0 = B.buildConstant(Ty, B2Mask1HiTo0);\n    auto B2Count1Hi = B.buildAnd(Ty, B2Set1LoTo1Hi, C_B2Mask1HiTo0);\n    auto B2Count = B.buildSub(Ty, SrcReg, B2Count1Hi);\n\n    // In order to get count in blocks of 4 add values from adjacent block of 2.\n    // B4Count = { B2Count & 0x33333333 } + { (B2Count >> 2) & 0x33333333 }\n    auto C_2 = B.buildConstant(Ty, 2);\n    auto B4Set2LoTo2Hi = B.buildLShr(Ty, B2Count, C_2);\n    APInt B4Mask2HiTo0 = APInt::getSplat(Size, APInt(8, 0x33));\n    auto C_B4Mask2HiTo0 = B.buildConstant(Ty, B4Mask2HiTo0);\n    auto B4HiB2Count = B.buildAnd(Ty, B4Set2LoTo2Hi, C_B4Mask2HiTo0);\n    auto B4LoB2Count = B.buildAnd(Ty, B2Count, C_B4Mask2HiTo0);\n    auto B4Count = B.buildAdd(Ty, B4HiB2Count, B4LoB2Count);\n\n    // For count in blocks of 8 bits we don't have to mask high 4 bits before\n    // addition since count value sits in range {0,...,8} and 4 bits are enough\n    // to hold such binary values. After addition high 4 bits still hold count\n    // of set bits in high 4 bit block, set them to zero and get 8 bit result.\n    // B8Count = { B4Count + (B4Count >> 4) } & 0x0F0F0F0F\n    auto C_4 = B.buildConstant(Ty, 4);\n    auto B8HiB4Count = B.buildLShr(Ty, B4Count, C_4);\n    auto B8CountDirty4Hi = B.buildAdd(Ty, B8HiB4Count, B4Count);\n    APInt B8Mask4HiTo0 = APInt::getSplat(Size, APInt(8, 0x0F));\n    auto C_B8Mask4HiTo0 = B.buildConstant(Ty, B8Mask4HiTo0);\n    auto B8Count = B.buildAnd(Ty, B8CountDirty4Hi, C_B8Mask4HiTo0);\n\n    assert(Size<=128 && \"Scalar size is too large for CTPOP lower algorithm\");\n    // 8 bits can hold CTPOP result of 128 bit int or smaller. Mul with this\n    // bitmask will set 8 msb in ResTmp to sum of all B8Counts in 8 bit blocks.\n    auto MulMask = B.buildConstant(Ty, APInt::getSplat(Size, APInt(8, 0x01)));\n    auto ResTmp = B.buildMul(Ty, B8Count, MulMask);\n\n    // Shift count result from 8 high bits to low bits.\n    auto C_SizeM8 = B.buildConstant(Ty, Size - 8);\n    B.buildLShr(MI.getOperand(0).getReg(), ResTmp, C_SizeM8);\n\n    MI.eraseFromParent();\n    return Legalized;\n  }\n  }\n}\n\n// Expand s32 = G_UITOFP s64 using bit operations to an IEEE float\n// representation.\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerU64ToF32BitOps(MachineInstr &MI) {\n  Register Dst = MI.getOperand(0).getReg();\n  Register Src = MI.getOperand(1).getReg();\n  const LLT S64 = LLT::scalar(64);\n  const LLT S32 = LLT::scalar(32);\n  const LLT S1 = LLT::scalar(1);\n\n  assert(MRI.getType(Src) == S64 && MRI.getType(Dst) == S32);\n\n  // unsigned cul2f(ulong u) {\n  //   uint lz = clz(u);\n  //   uint e = (u != 0) ? 127U + 63U - lz : 0;\n  //   u = (u << lz) & 0x7fffffffffffffffUL;\n  //   ulong t = u & 0xffffffffffUL;\n  //   uint v = (e << 23) | (uint)(u >> 40);\n  //   uint r = t > 0x8000000000UL ? 1U : (t == 0x8000000000UL ? v & 1U : 0U);\n  //   return as_float(v + r);\n  // }\n\n  auto Zero32 = MIRBuilder.buildConstant(S32, 0);\n  auto Zero64 = MIRBuilder.buildConstant(S64, 0);\n\n  auto LZ = MIRBuilder.buildCTLZ_ZERO_UNDEF(S32, Src);\n\n  auto K = MIRBuilder.buildConstant(S32, 127U + 63U);\n  auto Sub = MIRBuilder.buildSub(S32, K, LZ);\n\n  auto NotZero = MIRBuilder.buildICmp(CmpInst::ICMP_NE, S1, Src, Zero64);\n  auto E = MIRBuilder.buildSelect(S32, NotZero, Sub, Zero32);\n\n  auto Mask0 = MIRBuilder.buildConstant(S64, (-1ULL) >> 1);\n  auto ShlLZ = MIRBuilder.buildShl(S64, Src, LZ);\n\n  auto U = MIRBuilder.buildAnd(S64, ShlLZ, Mask0);\n\n  auto Mask1 = MIRBuilder.buildConstant(S64, 0xffffffffffULL);\n  auto T = MIRBuilder.buildAnd(S64, U, Mask1);\n\n  auto UShl = MIRBuilder.buildLShr(S64, U, MIRBuilder.buildConstant(S64, 40));\n  auto ShlE = MIRBuilder.buildShl(S32, E, MIRBuilder.buildConstant(S32, 23));\n  auto V = MIRBuilder.buildOr(S32, ShlE, MIRBuilder.buildTrunc(S32, UShl));\n\n  auto C = MIRBuilder.buildConstant(S64, 0x8000000000ULL);\n  auto RCmp = MIRBuilder.buildICmp(CmpInst::ICMP_UGT, S1, T, C);\n  auto TCmp = MIRBuilder.buildICmp(CmpInst::ICMP_EQ, S1, T, C);\n  auto One = MIRBuilder.buildConstant(S32, 1);\n\n  auto VTrunc1 = MIRBuilder.buildAnd(S32, V, One);\n  auto Select0 = MIRBuilder.buildSelect(S32, TCmp, VTrunc1, Zero32);\n  auto R = MIRBuilder.buildSelect(S32, RCmp, One, Select0);\n  MIRBuilder.buildAdd(Dst, V, R);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult LegalizerHelper::lowerUITOFP(MachineInstr &MI) {\n  Register Dst = MI.getOperand(0).getReg();\n  Register Src = MI.getOperand(1).getReg();\n  LLT DstTy = MRI.getType(Dst);\n  LLT SrcTy = MRI.getType(Src);\n\n  if (SrcTy == LLT::scalar(1)) {\n    auto True = MIRBuilder.buildFConstant(DstTy, 1.0);\n    auto False = MIRBuilder.buildFConstant(DstTy, 0.0);\n    MIRBuilder.buildSelect(Dst, Src, True, False);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  if (SrcTy != LLT::scalar(64))\n    return UnableToLegalize;\n\n  if (DstTy == LLT::scalar(32)) {\n    // TODO: SelectionDAG has several alternative expansions to port which may\n    // be more reasonble depending on the available instructions. If a target\n    // has sitofp, does not have CTLZ, or can efficiently use f64 as an\n    // intermediate type, this is probably worse.\n    return lowerU64ToF32BitOps(MI);\n  }\n\n  return UnableToLegalize;\n}\n\nLegalizerHelper::LegalizeResult LegalizerHelper::lowerSITOFP(MachineInstr &MI) {\n  Register Dst = MI.getOperand(0).getReg();\n  Register Src = MI.getOperand(1).getReg();\n  LLT DstTy = MRI.getType(Dst);\n  LLT SrcTy = MRI.getType(Src);\n\n  const LLT S64 = LLT::scalar(64);\n  const LLT S32 = LLT::scalar(32);\n  const LLT S1 = LLT::scalar(1);\n\n  if (SrcTy == S1) {\n    auto True = MIRBuilder.buildFConstant(DstTy, -1.0);\n    auto False = MIRBuilder.buildFConstant(DstTy, 0.0);\n    MIRBuilder.buildSelect(Dst, Src, True, False);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  if (SrcTy != S64)\n    return UnableToLegalize;\n\n  if (DstTy == S32) {\n    // signed cl2f(long l) {\n    //   long s = l >> 63;\n    //   float r = cul2f((l + s) ^ s);\n    //   return s ? -r : r;\n    // }\n    Register L = Src;\n    auto SignBit = MIRBuilder.buildConstant(S64, 63);\n    auto S = MIRBuilder.buildAShr(S64, L, SignBit);\n\n    auto LPlusS = MIRBuilder.buildAdd(S64, L, S);\n    auto Xor = MIRBuilder.buildXor(S64, LPlusS, S);\n    auto R = MIRBuilder.buildUITOFP(S32, Xor);\n\n    auto RNeg = MIRBuilder.buildFNeg(S32, R);\n    auto SignNotZero = MIRBuilder.buildICmp(CmpInst::ICMP_NE, S1, S,\n                                            MIRBuilder.buildConstant(S64, 0));\n    MIRBuilder.buildSelect(Dst, SignNotZero, RNeg, R);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  return UnableToLegalize;\n}\n\nLegalizerHelper::LegalizeResult LegalizerHelper::lowerFPTOUI(MachineInstr &MI) {\n  Register Dst = MI.getOperand(0).getReg();\n  Register Src = MI.getOperand(1).getReg();\n  LLT DstTy = MRI.getType(Dst);\n  LLT SrcTy = MRI.getType(Src);\n  const LLT S64 = LLT::scalar(64);\n  const LLT S32 = LLT::scalar(32);\n\n  if (SrcTy != S64 && SrcTy != S32)\n    return UnableToLegalize;\n  if (DstTy != S32 && DstTy != S64)\n    return UnableToLegalize;\n\n  // FPTOSI gives same result as FPTOUI for positive signed integers.\n  // FPTOUI needs to deal with fp values that convert to unsigned integers\n  // greater or equal to 2^31 for float or 2^63 for double. For brevity 2^Exp.\n\n  APInt TwoPExpInt = APInt::getSignMask(DstTy.getSizeInBits());\n  APFloat TwoPExpFP(SrcTy.getSizeInBits() == 32 ? APFloat::IEEEsingle()\n                                                : APFloat::IEEEdouble(),\n                    APInt::getNullValue(SrcTy.getSizeInBits()));\n  TwoPExpFP.convertFromAPInt(TwoPExpInt, false, APFloat::rmNearestTiesToEven);\n\n  MachineInstrBuilder FPTOSI = MIRBuilder.buildFPTOSI(DstTy, Src);\n\n  MachineInstrBuilder Threshold = MIRBuilder.buildFConstant(SrcTy, TwoPExpFP);\n  // For fp Value greater or equal to Threshold(2^Exp), we use FPTOSI on\n  // (Value - 2^Exp) and add 2^Exp by setting highest bit in result to 1.\n  MachineInstrBuilder FSub = MIRBuilder.buildFSub(SrcTy, Src, Threshold);\n  MachineInstrBuilder ResLowBits = MIRBuilder.buildFPTOSI(DstTy, FSub);\n  MachineInstrBuilder ResHighBit = MIRBuilder.buildConstant(DstTy, TwoPExpInt);\n  MachineInstrBuilder Res = MIRBuilder.buildXor(DstTy, ResLowBits, ResHighBit);\n\n  const LLT S1 = LLT::scalar(1);\n\n  MachineInstrBuilder FCMP =\n      MIRBuilder.buildFCmp(CmpInst::FCMP_ULT, S1, Src, Threshold);\n  MIRBuilder.buildSelect(Dst, FCMP, FPTOSI, Res);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult LegalizerHelper::lowerFPTOSI(MachineInstr &MI) {\n  Register Dst = MI.getOperand(0).getReg();\n  Register Src = MI.getOperand(1).getReg();\n  LLT DstTy = MRI.getType(Dst);\n  LLT SrcTy = MRI.getType(Src);\n  const LLT S64 = LLT::scalar(64);\n  const LLT S32 = LLT::scalar(32);\n\n  // FIXME: Only f32 to i64 conversions are supported.\n  if (SrcTy.getScalarType() != S32 || DstTy.getScalarType() != S64)\n    return UnableToLegalize;\n\n  // Expand f32 -> i64 conversion\n  // This algorithm comes from compiler-rt's implementation of fixsfdi:\n  // https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/builtins/fixsfdi.c\n\n  unsigned SrcEltBits = SrcTy.getScalarSizeInBits();\n\n  auto ExponentMask = MIRBuilder.buildConstant(SrcTy, 0x7F800000);\n  auto ExponentLoBit = MIRBuilder.buildConstant(SrcTy, 23);\n\n  auto AndExpMask = MIRBuilder.buildAnd(SrcTy, Src, ExponentMask);\n  auto ExponentBits = MIRBuilder.buildLShr(SrcTy, AndExpMask, ExponentLoBit);\n\n  auto SignMask = MIRBuilder.buildConstant(SrcTy,\n                                           APInt::getSignMask(SrcEltBits));\n  auto AndSignMask = MIRBuilder.buildAnd(SrcTy, Src, SignMask);\n  auto SignLowBit = MIRBuilder.buildConstant(SrcTy, SrcEltBits - 1);\n  auto Sign = MIRBuilder.buildAShr(SrcTy, AndSignMask, SignLowBit);\n  Sign = MIRBuilder.buildSExt(DstTy, Sign);\n\n  auto MantissaMask = MIRBuilder.buildConstant(SrcTy, 0x007FFFFF);\n  auto AndMantissaMask = MIRBuilder.buildAnd(SrcTy, Src, MantissaMask);\n  auto K = MIRBuilder.buildConstant(SrcTy, 0x00800000);\n\n  auto R = MIRBuilder.buildOr(SrcTy, AndMantissaMask, K);\n  R = MIRBuilder.buildZExt(DstTy, R);\n\n  auto Bias = MIRBuilder.buildConstant(SrcTy, 127);\n  auto Exponent = MIRBuilder.buildSub(SrcTy, ExponentBits, Bias);\n  auto SubExponent = MIRBuilder.buildSub(SrcTy, Exponent, ExponentLoBit);\n  auto ExponentSub = MIRBuilder.buildSub(SrcTy, ExponentLoBit, Exponent);\n\n  auto Shl = MIRBuilder.buildShl(DstTy, R, SubExponent);\n  auto Srl = MIRBuilder.buildLShr(DstTy, R, ExponentSub);\n\n  const LLT S1 = LLT::scalar(1);\n  auto CmpGt = MIRBuilder.buildICmp(CmpInst::ICMP_SGT,\n                                    S1, Exponent, ExponentLoBit);\n\n  R = MIRBuilder.buildSelect(DstTy, CmpGt, Shl, Srl);\n\n  auto XorSign = MIRBuilder.buildXor(DstTy, R, Sign);\n  auto Ret = MIRBuilder.buildSub(DstTy, XorSign, Sign);\n\n  auto ZeroSrcTy = MIRBuilder.buildConstant(SrcTy, 0);\n\n  auto ExponentLt0 = MIRBuilder.buildICmp(CmpInst::ICMP_SLT,\n                                          S1, Exponent, ZeroSrcTy);\n\n  auto ZeroDstTy = MIRBuilder.buildConstant(DstTy, 0);\n  MIRBuilder.buildSelect(Dst, ExponentLt0, ZeroDstTy, Ret);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\n// f64 -> f16 conversion using round-to-nearest-even rounding mode.\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerFPTRUNC_F64_TO_F16(MachineInstr &MI) {\n  Register Dst = MI.getOperand(0).getReg();\n  Register Src = MI.getOperand(1).getReg();\n\n  if (MRI.getType(Src).isVector()) // TODO: Handle vectors directly.\n    return UnableToLegalize;\n\n  const unsigned ExpMask = 0x7ff;\n  const unsigned ExpBiasf64 = 1023;\n  const unsigned ExpBiasf16 = 15;\n  const LLT S32 = LLT::scalar(32);\n  const LLT S1 = LLT::scalar(1);\n\n  auto Unmerge = MIRBuilder.buildUnmerge(S32, Src);\n  Register U = Unmerge.getReg(0);\n  Register UH = Unmerge.getReg(1);\n\n  auto E = MIRBuilder.buildLShr(S32, UH, MIRBuilder.buildConstant(S32, 20));\n  E = MIRBuilder.buildAnd(S32, E, MIRBuilder.buildConstant(S32, ExpMask));\n\n  // Subtract the fp64 exponent bias (1023) to get the real exponent and\n  // add the f16 bias (15) to get the biased exponent for the f16 format.\n  E = MIRBuilder.buildAdd(\n    S32, E, MIRBuilder.buildConstant(S32, -ExpBiasf64 + ExpBiasf16));\n\n  auto M = MIRBuilder.buildLShr(S32, UH, MIRBuilder.buildConstant(S32, 8));\n  M = MIRBuilder.buildAnd(S32, M, MIRBuilder.buildConstant(S32, 0xffe));\n\n  auto MaskedSig = MIRBuilder.buildAnd(S32, UH,\n                                       MIRBuilder.buildConstant(S32, 0x1ff));\n  MaskedSig = MIRBuilder.buildOr(S32, MaskedSig, U);\n\n  auto Zero = MIRBuilder.buildConstant(S32, 0);\n  auto SigCmpNE0 = MIRBuilder.buildICmp(CmpInst::ICMP_NE, S1, MaskedSig, Zero);\n  auto Lo40Set = MIRBuilder.buildZExt(S32, SigCmpNE0);\n  M = MIRBuilder.buildOr(S32, M, Lo40Set);\n\n  // (M != 0 ? 0x0200 : 0) | 0x7c00;\n  auto Bits0x200 = MIRBuilder.buildConstant(S32, 0x0200);\n  auto CmpM_NE0 = MIRBuilder.buildICmp(CmpInst::ICMP_NE, S1, M, Zero);\n  auto SelectCC = MIRBuilder.buildSelect(S32, CmpM_NE0, Bits0x200, Zero);\n\n  auto Bits0x7c00 = MIRBuilder.buildConstant(S32, 0x7c00);\n  auto I = MIRBuilder.buildOr(S32, SelectCC, Bits0x7c00);\n\n  // N = M | (E << 12);\n  auto EShl12 = MIRBuilder.buildShl(S32, E, MIRBuilder.buildConstant(S32, 12));\n  auto N = MIRBuilder.buildOr(S32, M, EShl12);\n\n  // B = clamp(1-E, 0, 13);\n  auto One = MIRBuilder.buildConstant(S32, 1);\n  auto OneSubExp = MIRBuilder.buildSub(S32, One, E);\n  auto B = MIRBuilder.buildSMax(S32, OneSubExp, Zero);\n  B = MIRBuilder.buildSMin(S32, B, MIRBuilder.buildConstant(S32, 13));\n\n  auto SigSetHigh = MIRBuilder.buildOr(S32, M,\n                                       MIRBuilder.buildConstant(S32, 0x1000));\n\n  auto D = MIRBuilder.buildLShr(S32, SigSetHigh, B);\n  auto D0 = MIRBuilder.buildShl(S32, D, B);\n\n  auto D0_NE_SigSetHigh = MIRBuilder.buildICmp(CmpInst::ICMP_NE, S1,\n                                             D0, SigSetHigh);\n  auto D1 = MIRBuilder.buildZExt(S32, D0_NE_SigSetHigh);\n  D = MIRBuilder.buildOr(S32, D, D1);\n\n  auto CmpELtOne = MIRBuilder.buildICmp(CmpInst::ICMP_SLT, S1, E, One);\n  auto V = MIRBuilder.buildSelect(S32, CmpELtOne, D, N);\n\n  auto VLow3 = MIRBuilder.buildAnd(S32, V, MIRBuilder.buildConstant(S32, 7));\n  V = MIRBuilder.buildLShr(S32, V, MIRBuilder.buildConstant(S32, 2));\n\n  auto VLow3Eq3 = MIRBuilder.buildICmp(CmpInst::ICMP_EQ, S1, VLow3,\n                                       MIRBuilder.buildConstant(S32, 3));\n  auto V0 = MIRBuilder.buildZExt(S32, VLow3Eq3);\n\n  auto VLow3Gt5 = MIRBuilder.buildICmp(CmpInst::ICMP_SGT, S1, VLow3,\n                                       MIRBuilder.buildConstant(S32, 5));\n  auto V1 = MIRBuilder.buildZExt(S32, VLow3Gt5);\n\n  V1 = MIRBuilder.buildOr(S32, V0, V1);\n  V = MIRBuilder.buildAdd(S32, V, V1);\n\n  auto CmpEGt30 = MIRBuilder.buildICmp(CmpInst::ICMP_SGT,  S1,\n                                       E, MIRBuilder.buildConstant(S32, 30));\n  V = MIRBuilder.buildSelect(S32, CmpEGt30,\n                             MIRBuilder.buildConstant(S32, 0x7c00), V);\n\n  auto CmpEGt1039 = MIRBuilder.buildICmp(CmpInst::ICMP_EQ, S1,\n                                         E, MIRBuilder.buildConstant(S32, 1039));\n  V = MIRBuilder.buildSelect(S32, CmpEGt1039, I, V);\n\n  // Extract the sign bit.\n  auto Sign = MIRBuilder.buildLShr(S32, UH, MIRBuilder.buildConstant(S32, 16));\n  Sign = MIRBuilder.buildAnd(S32, Sign, MIRBuilder.buildConstant(S32, 0x8000));\n\n  // Insert the sign bit\n  V = MIRBuilder.buildOr(S32, Sign, V);\n\n  MIRBuilder.buildTrunc(Dst, V);\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerFPTRUNC(MachineInstr &MI) {\n  Register Dst = MI.getOperand(0).getReg();\n  Register Src = MI.getOperand(1).getReg();\n\n  LLT DstTy = MRI.getType(Dst);\n  LLT SrcTy = MRI.getType(Src);\n  const LLT S64 = LLT::scalar(64);\n  const LLT S16 = LLT::scalar(16);\n\n  if (DstTy.getScalarType() == S16 && SrcTy.getScalarType() == S64)\n    return lowerFPTRUNC_F64_TO_F16(MI);\n\n  return UnableToLegalize;\n}\n\n// TODO: If RHS is a constant SelectionDAGBuilder expands this into a\n// multiplication tree.\nLegalizerHelper::LegalizeResult LegalizerHelper::lowerFPOWI(MachineInstr &MI) {\n  Register Dst = MI.getOperand(0).getReg();\n  Register Src0 = MI.getOperand(1).getReg();\n  Register Src1 = MI.getOperand(2).getReg();\n  LLT Ty = MRI.getType(Dst);\n\n  auto CvtSrc1 = MIRBuilder.buildSITOFP(Ty, Src1);\n  MIRBuilder.buildFPow(Dst, Src0, CvtSrc1, MI.getFlags());\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nstatic CmpInst::Predicate minMaxToCompare(unsigned Opc) {\n  switch (Opc) {\n  case TargetOpcode::G_SMIN:\n    return CmpInst::ICMP_SLT;\n  case TargetOpcode::G_SMAX:\n    return CmpInst::ICMP_SGT;\n  case TargetOpcode::G_UMIN:\n    return CmpInst::ICMP_ULT;\n  case TargetOpcode::G_UMAX:\n    return CmpInst::ICMP_UGT;\n  default:\n    llvm_unreachable(\"not in integer min/max\");\n  }\n}\n\nLegalizerHelper::LegalizeResult LegalizerHelper::lowerMinMax(MachineInstr &MI) {\n  Register Dst = MI.getOperand(0).getReg();\n  Register Src0 = MI.getOperand(1).getReg();\n  Register Src1 = MI.getOperand(2).getReg();\n\n  const CmpInst::Predicate Pred = minMaxToCompare(MI.getOpcode());\n  LLT CmpType = MRI.getType(Dst).changeElementSize(1);\n\n  auto Cmp = MIRBuilder.buildICmp(Pred, CmpType, Src0, Src1);\n  MIRBuilder.buildSelect(Dst, Cmp, Src0, Src1);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerFCopySign(MachineInstr &MI) {\n  Register Dst = MI.getOperand(0).getReg();\n  Register Src0 = MI.getOperand(1).getReg();\n  Register Src1 = MI.getOperand(2).getReg();\n\n  const LLT Src0Ty = MRI.getType(Src0);\n  const LLT Src1Ty = MRI.getType(Src1);\n\n  const int Src0Size = Src0Ty.getScalarSizeInBits();\n  const int Src1Size = Src1Ty.getScalarSizeInBits();\n\n  auto SignBitMask = MIRBuilder.buildConstant(\n    Src0Ty, APInt::getSignMask(Src0Size));\n\n  auto NotSignBitMask = MIRBuilder.buildConstant(\n    Src0Ty, APInt::getLowBitsSet(Src0Size, Src0Size - 1));\n\n  Register And0 = MIRBuilder.buildAnd(Src0Ty, Src0, NotSignBitMask).getReg(0);\n  Register And1;\n  if (Src0Ty == Src1Ty) {\n    And1 = MIRBuilder.buildAnd(Src1Ty, Src1, SignBitMask).getReg(0);\n  } else if (Src0Size > Src1Size) {\n    auto ShiftAmt = MIRBuilder.buildConstant(Src0Ty, Src0Size - Src1Size);\n    auto Zext = MIRBuilder.buildZExt(Src0Ty, Src1);\n    auto Shift = MIRBuilder.buildShl(Src0Ty, Zext, ShiftAmt);\n    And1 = MIRBuilder.buildAnd(Src0Ty, Shift, SignBitMask).getReg(0);\n  } else {\n    auto ShiftAmt = MIRBuilder.buildConstant(Src1Ty, Src1Size - Src0Size);\n    auto Shift = MIRBuilder.buildLShr(Src1Ty, Src1, ShiftAmt);\n    auto Trunc = MIRBuilder.buildTrunc(Src0Ty, Shift);\n    And1 = MIRBuilder.buildAnd(Src0Ty, Trunc, SignBitMask).getReg(0);\n  }\n\n  // Be careful about setting nsz/nnan/ninf on every instruction, since the\n  // constants are a nan and -0.0, but the final result should preserve\n  // everything.\n  unsigned Flags = MI.getFlags();\n  MIRBuilder.buildOr(Dst, And0, And1, Flags);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerFMinNumMaxNum(MachineInstr &MI) {\n  unsigned NewOp = MI.getOpcode() == TargetOpcode::G_FMINNUM ?\n    TargetOpcode::G_FMINNUM_IEEE : TargetOpcode::G_FMAXNUM_IEEE;\n\n  Register Dst = MI.getOperand(0).getReg();\n  Register Src0 = MI.getOperand(1).getReg();\n  Register Src1 = MI.getOperand(2).getReg();\n  LLT Ty = MRI.getType(Dst);\n\n  if (!MI.getFlag(MachineInstr::FmNoNans)) {\n    // Insert canonicalizes if it's possible we need to quiet to get correct\n    // sNaN behavior.\n\n    // Note this must be done here, and not as an optimization combine in the\n    // absence of a dedicate quiet-snan instruction as we're using an\n    // omni-purpose G_FCANONICALIZE.\n    if (!isKnownNeverSNaN(Src0, MRI))\n      Src0 = MIRBuilder.buildFCanonicalize(Ty, Src0, MI.getFlags()).getReg(0);\n\n    if (!isKnownNeverSNaN(Src1, MRI))\n      Src1 = MIRBuilder.buildFCanonicalize(Ty, Src1, MI.getFlags()).getReg(0);\n  }\n\n  // If there are no nans, it's safe to simply replace this with the non-IEEE\n  // version.\n  MIRBuilder.buildInstr(NewOp, {Dst}, {Src0, Src1}, MI.getFlags());\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult LegalizerHelper::lowerFMad(MachineInstr &MI) {\n  // Expand G_FMAD a, b, c -> G_FADD (G_FMUL a, b), c\n  Register DstReg = MI.getOperand(0).getReg();\n  LLT Ty = MRI.getType(DstReg);\n  unsigned Flags = MI.getFlags();\n\n  auto Mul = MIRBuilder.buildFMul(Ty, MI.getOperand(1), MI.getOperand(2),\n                                  Flags);\n  MIRBuilder.buildFAdd(DstReg, Mul, MI.getOperand(3), Flags);\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerIntrinsicRound(MachineInstr &MI) {\n  Register DstReg = MI.getOperand(0).getReg();\n  Register X = MI.getOperand(1).getReg();\n  const unsigned Flags = MI.getFlags();\n  const LLT Ty = MRI.getType(DstReg);\n  const LLT CondTy = Ty.changeElementSize(1);\n\n  // round(x) =>\n  //  t = trunc(x);\n  //  d = fabs(x - t);\n  //  o = copysign(1.0f, x);\n  //  return t + (d >= 0.5 ? o : 0.0);\n\n  auto T = MIRBuilder.buildIntrinsicTrunc(Ty, X, Flags);\n\n  auto Diff = MIRBuilder.buildFSub(Ty, X, T, Flags);\n  auto AbsDiff = MIRBuilder.buildFAbs(Ty, Diff, Flags);\n  auto Zero = MIRBuilder.buildFConstant(Ty, 0.0);\n  auto One = MIRBuilder.buildFConstant(Ty, 1.0);\n  auto Half = MIRBuilder.buildFConstant(Ty, 0.5);\n  auto SignOne = MIRBuilder.buildFCopysign(Ty, One, X);\n\n  auto Cmp = MIRBuilder.buildFCmp(CmpInst::FCMP_OGE, CondTy, AbsDiff, Half,\n                                  Flags);\n  auto Sel = MIRBuilder.buildSelect(Ty, Cmp, SignOne, Zero, Flags);\n\n  MIRBuilder.buildFAdd(DstReg, T, Sel, Flags);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerFFloor(MachineInstr &MI) {\n  Register DstReg = MI.getOperand(0).getReg();\n  Register SrcReg = MI.getOperand(1).getReg();\n  unsigned Flags = MI.getFlags();\n  LLT Ty = MRI.getType(DstReg);\n  const LLT CondTy = Ty.changeElementSize(1);\n\n  // result = trunc(src);\n  // if (src < 0.0 && src != result)\n  //   result += -1.0.\n\n  auto Trunc = MIRBuilder.buildIntrinsicTrunc(Ty, SrcReg, Flags);\n  auto Zero = MIRBuilder.buildFConstant(Ty, 0.0);\n\n  auto Lt0 = MIRBuilder.buildFCmp(CmpInst::FCMP_OLT, CondTy,\n                                  SrcReg, Zero, Flags);\n  auto NeTrunc = MIRBuilder.buildFCmp(CmpInst::FCMP_ONE, CondTy,\n                                      SrcReg, Trunc, Flags);\n  auto And = MIRBuilder.buildAnd(CondTy, Lt0, NeTrunc);\n  auto AddVal = MIRBuilder.buildSITOFP(Ty, And);\n\n  MIRBuilder.buildFAdd(DstReg, Trunc, AddVal, Flags);\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerMergeValues(MachineInstr &MI) {\n  const unsigned NumOps = MI.getNumOperands();\n  Register DstReg = MI.getOperand(0).getReg();\n  Register Src0Reg = MI.getOperand(1).getReg();\n  LLT DstTy = MRI.getType(DstReg);\n  LLT SrcTy = MRI.getType(Src0Reg);\n  unsigned PartSize = SrcTy.getSizeInBits();\n\n  LLT WideTy = LLT::scalar(DstTy.getSizeInBits());\n  Register ResultReg = MIRBuilder.buildZExt(WideTy, Src0Reg).getReg(0);\n\n  for (unsigned I = 2; I != NumOps; ++I) {\n    const unsigned Offset = (I - 1) * PartSize;\n\n    Register SrcReg = MI.getOperand(I).getReg();\n    auto ZextInput = MIRBuilder.buildZExt(WideTy, SrcReg);\n\n    Register NextResult = I + 1 == NumOps && WideTy == DstTy ? DstReg :\n      MRI.createGenericVirtualRegister(WideTy);\n\n    auto ShiftAmt = MIRBuilder.buildConstant(WideTy, Offset);\n    auto Shl = MIRBuilder.buildShl(WideTy, ZextInput, ShiftAmt);\n    MIRBuilder.buildOr(NextResult, ResultReg, Shl);\n    ResultReg = NextResult;\n  }\n\n  if (DstTy.isPointer()) {\n    if (MIRBuilder.getDataLayout().isNonIntegralAddressSpace(\n          DstTy.getAddressSpace())) {\n      LLVM_DEBUG(dbgs() << \"Not casting nonintegral address space\\n\");\n      return UnableToLegalize;\n    }\n\n    MIRBuilder.buildIntToPtr(DstReg, ResultReg);\n  }\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerUnmergeValues(MachineInstr &MI) {\n  const unsigned NumDst = MI.getNumOperands() - 1;\n  Register SrcReg = MI.getOperand(NumDst).getReg();\n  Register Dst0Reg = MI.getOperand(0).getReg();\n  LLT DstTy = MRI.getType(Dst0Reg);\n  if (DstTy.isPointer())\n    return UnableToLegalize; // TODO\n\n  SrcReg = coerceToScalar(SrcReg);\n  if (!SrcReg)\n    return UnableToLegalize;\n\n  // Expand scalarizing unmerge as bitcast to integer and shift.\n  LLT IntTy = MRI.getType(SrcReg);\n\n  MIRBuilder.buildTrunc(Dst0Reg, SrcReg);\n\n  const unsigned DstSize = DstTy.getSizeInBits();\n  unsigned Offset = DstSize;\n  for (unsigned I = 1; I != NumDst; ++I, Offset += DstSize) {\n    auto ShiftAmt = MIRBuilder.buildConstant(IntTy, Offset);\n    auto Shift = MIRBuilder.buildLShr(IntTy, SrcReg, ShiftAmt);\n    MIRBuilder.buildTrunc(MI.getOperand(I), Shift);\n  }\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\n/// Lower a vector extract or insert by writing the vector to a stack temporary\n/// and reloading the element or vector.\n///\n/// %dst = G_EXTRACT_VECTOR_ELT %vec, %idx\n///  =>\n///  %stack_temp = G_FRAME_INDEX\n///  G_STORE %vec, %stack_temp\n///  %idx = clamp(%idx, %vec.getNumElements())\n///  %element_ptr = G_PTR_ADD %stack_temp, %idx\n///  %dst = G_LOAD %element_ptr\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerExtractInsertVectorElt(MachineInstr &MI) {\n  Register DstReg = MI.getOperand(0).getReg();\n  Register SrcVec = MI.getOperand(1).getReg();\n  Register InsertVal;\n  if (MI.getOpcode() == TargetOpcode::G_INSERT_VECTOR_ELT)\n    InsertVal = MI.getOperand(2).getReg();\n\n  Register Idx = MI.getOperand(MI.getNumOperands() - 1).getReg();\n\n  LLT VecTy = MRI.getType(SrcVec);\n  LLT EltTy = VecTy.getElementType();\n  if (!EltTy.isByteSized()) { // Not implemented.\n    LLVM_DEBUG(dbgs() << \"Can't handle non-byte element vectors yet\\n\");\n    return UnableToLegalize;\n  }\n\n  unsigned EltBytes = EltTy.getSizeInBytes();\n  Align VecAlign = getStackTemporaryAlignment(VecTy);\n  Align EltAlign;\n\n  MachinePointerInfo PtrInfo;\n  auto StackTemp = createStackTemporary(TypeSize::Fixed(VecTy.getSizeInBytes()),\n                                        VecAlign, PtrInfo);\n  MIRBuilder.buildStore(SrcVec, StackTemp, PtrInfo, VecAlign);\n\n  // Get the pointer to the element, and be sure not to hit undefined behavior\n  // if the index is out of bounds.\n  Register EltPtr = getVectorElementPointer(StackTemp.getReg(0), VecTy, Idx);\n\n  int64_t IdxVal;\n  if (mi_match(Idx, MRI, m_ICst(IdxVal))) {\n    int64_t Offset = IdxVal * EltBytes;\n    PtrInfo = PtrInfo.getWithOffset(Offset);\n    EltAlign = commonAlignment(VecAlign, Offset);\n  } else {\n    // We lose information with a variable offset.\n    EltAlign = getStackTemporaryAlignment(EltTy);\n    PtrInfo = MachinePointerInfo(MRI.getType(EltPtr).getAddressSpace());\n  }\n\n  if (InsertVal) {\n    // Write the inserted element\n    MIRBuilder.buildStore(InsertVal, EltPtr, PtrInfo, EltAlign);\n\n    // Reload the whole vector.\n    MIRBuilder.buildLoad(DstReg, StackTemp, PtrInfo, VecAlign);\n  } else {\n    MIRBuilder.buildLoad(DstReg, EltPtr, PtrInfo, EltAlign);\n  }\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerShuffleVector(MachineInstr &MI) {\n  Register DstReg = MI.getOperand(0).getReg();\n  Register Src0Reg = MI.getOperand(1).getReg();\n  Register Src1Reg = MI.getOperand(2).getReg();\n  LLT Src0Ty = MRI.getType(Src0Reg);\n  LLT DstTy = MRI.getType(DstReg);\n  LLT IdxTy = LLT::scalar(32);\n\n  ArrayRef<int> Mask = MI.getOperand(3).getShuffleMask();\n\n  if (DstTy.isScalar()) {\n    if (Src0Ty.isVector())\n      return UnableToLegalize;\n\n    // This is just a SELECT.\n    assert(Mask.size() == 1 && \"Expected a single mask element\");\n    Register Val;\n    if (Mask[0] < 0 || Mask[0] > 1)\n      Val = MIRBuilder.buildUndef(DstTy).getReg(0);\n    else\n      Val = Mask[0] == 0 ? Src0Reg : Src1Reg;\n    MIRBuilder.buildCopy(DstReg, Val);\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  Register Undef;\n  SmallVector<Register, 32> BuildVec;\n  LLT EltTy = DstTy.getElementType();\n\n  for (int Idx : Mask) {\n    if (Idx < 0) {\n      if (!Undef.isValid())\n        Undef = MIRBuilder.buildUndef(EltTy).getReg(0);\n      BuildVec.push_back(Undef);\n      continue;\n    }\n\n    if (Src0Ty.isScalar()) {\n      BuildVec.push_back(Idx == 0 ? Src0Reg : Src1Reg);\n    } else {\n      int NumElts = Src0Ty.getNumElements();\n      Register SrcVec = Idx < NumElts ? Src0Reg : Src1Reg;\n      int ExtractIdx = Idx < NumElts ? Idx : Idx - NumElts;\n      auto IdxK = MIRBuilder.buildConstant(IdxTy, ExtractIdx);\n      auto Extract = MIRBuilder.buildExtractVectorElement(EltTy, SrcVec, IdxK);\n      BuildVec.push_back(Extract.getReg(0));\n    }\n  }\n\n  MIRBuilder.buildBuildVector(DstReg, BuildVec);\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerDynStackAlloc(MachineInstr &MI) {\n  const auto &MF = *MI.getMF();\n  const auto &TFI = *MF.getSubtarget().getFrameLowering();\n  if (TFI.getStackGrowthDirection() == TargetFrameLowering::StackGrowsUp)\n    return UnableToLegalize;\n\n  Register Dst = MI.getOperand(0).getReg();\n  Register AllocSize = MI.getOperand(1).getReg();\n  Align Alignment = assumeAligned(MI.getOperand(2).getImm());\n\n  LLT PtrTy = MRI.getType(Dst);\n  LLT IntPtrTy = LLT::scalar(PtrTy.getSizeInBits());\n\n  Register SPReg = TLI.getStackPointerRegisterToSaveRestore();\n  auto SPTmp = MIRBuilder.buildCopy(PtrTy, SPReg);\n  SPTmp = MIRBuilder.buildCast(IntPtrTy, SPTmp);\n\n  // Subtract the final alloc from the SP. We use G_PTRTOINT here so we don't\n  // have to generate an extra instruction to negate the alloc and then use\n  // G_PTR_ADD to add the negative offset.\n  auto Alloc = MIRBuilder.buildSub(IntPtrTy, SPTmp, AllocSize);\n  if (Alignment > Align(1)) {\n    APInt AlignMask(IntPtrTy.getSizeInBits(), Alignment.value(), true);\n    AlignMask.negate();\n    auto AlignCst = MIRBuilder.buildConstant(IntPtrTy, AlignMask);\n    Alloc = MIRBuilder.buildAnd(IntPtrTy, Alloc, AlignCst);\n  }\n\n  SPTmp = MIRBuilder.buildCast(PtrTy, Alloc);\n  MIRBuilder.buildCopy(SPReg, SPTmp);\n  MIRBuilder.buildCopy(Dst, SPTmp);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerExtract(MachineInstr &MI) {\n  Register Dst = MI.getOperand(0).getReg();\n  Register Src = MI.getOperand(1).getReg();\n  unsigned Offset = MI.getOperand(2).getImm();\n\n  LLT DstTy = MRI.getType(Dst);\n  LLT SrcTy = MRI.getType(Src);\n\n  if (DstTy.isScalar() &&\n      (SrcTy.isScalar() ||\n       (SrcTy.isVector() && DstTy == SrcTy.getElementType()))) {\n    LLT SrcIntTy = SrcTy;\n    if (!SrcTy.isScalar()) {\n      SrcIntTy = LLT::scalar(SrcTy.getSizeInBits());\n      Src = MIRBuilder.buildBitcast(SrcIntTy, Src).getReg(0);\n    }\n\n    if (Offset == 0)\n      MIRBuilder.buildTrunc(Dst, Src);\n    else {\n      auto ShiftAmt = MIRBuilder.buildConstant(SrcIntTy, Offset);\n      auto Shr = MIRBuilder.buildLShr(SrcIntTy, Src, ShiftAmt);\n      MIRBuilder.buildTrunc(Dst, Shr);\n    }\n\n    MI.eraseFromParent();\n    return Legalized;\n  }\n\n  return UnableToLegalize;\n}\n\nLegalizerHelper::LegalizeResult LegalizerHelper::lowerInsert(MachineInstr &MI) {\n  Register Dst = MI.getOperand(0).getReg();\n  Register Src = MI.getOperand(1).getReg();\n  Register InsertSrc = MI.getOperand(2).getReg();\n  uint64_t Offset = MI.getOperand(3).getImm();\n\n  LLT DstTy = MRI.getType(Src);\n  LLT InsertTy = MRI.getType(InsertSrc);\n\n  if (InsertTy.isVector() ||\n      (DstTy.isVector() && DstTy.getElementType() != InsertTy))\n    return UnableToLegalize;\n\n  const DataLayout &DL = MIRBuilder.getDataLayout();\n  if ((DstTy.isPointer() &&\n       DL.isNonIntegralAddressSpace(DstTy.getAddressSpace())) ||\n      (InsertTy.isPointer() &&\n       DL.isNonIntegralAddressSpace(InsertTy.getAddressSpace()))) {\n    LLVM_DEBUG(dbgs() << \"Not casting non-integral address space integer\\n\");\n    return UnableToLegalize;\n  }\n\n  LLT IntDstTy = DstTy;\n\n  if (!DstTy.isScalar()) {\n    IntDstTy = LLT::scalar(DstTy.getSizeInBits());\n    Src = MIRBuilder.buildCast(IntDstTy, Src).getReg(0);\n  }\n\n  if (!InsertTy.isScalar()) {\n    const LLT IntInsertTy = LLT::scalar(InsertTy.getSizeInBits());\n    InsertSrc = MIRBuilder.buildPtrToInt(IntInsertTy, InsertSrc).getReg(0);\n  }\n\n  Register ExtInsSrc = MIRBuilder.buildZExt(IntDstTy, InsertSrc).getReg(0);\n  if (Offset != 0) {\n    auto ShiftAmt = MIRBuilder.buildConstant(IntDstTy, Offset);\n    ExtInsSrc = MIRBuilder.buildShl(IntDstTy, ExtInsSrc, ShiftAmt).getReg(0);\n  }\n\n  APInt MaskVal = APInt::getBitsSetWithWrap(\n      DstTy.getSizeInBits(), Offset + InsertTy.getSizeInBits(), Offset);\n\n  auto Mask = MIRBuilder.buildConstant(IntDstTy, MaskVal);\n  auto MaskedSrc = MIRBuilder.buildAnd(IntDstTy, Src, Mask);\n  auto Or = MIRBuilder.buildOr(IntDstTy, MaskedSrc, ExtInsSrc);\n\n  MIRBuilder.buildCast(Dst, Or);\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerSADDO_SSUBO(MachineInstr &MI) {\n  Register Dst0 = MI.getOperand(0).getReg();\n  Register Dst1 = MI.getOperand(1).getReg();\n  Register LHS = MI.getOperand(2).getReg();\n  Register RHS = MI.getOperand(3).getReg();\n  const bool IsAdd = MI.getOpcode() == TargetOpcode::G_SADDO;\n\n  LLT Ty = MRI.getType(Dst0);\n  LLT BoolTy = MRI.getType(Dst1);\n\n  if (IsAdd)\n    MIRBuilder.buildAdd(Dst0, LHS, RHS);\n  else\n    MIRBuilder.buildSub(Dst0, LHS, RHS);\n\n  // TODO: If SADDSAT/SSUBSAT is legal, compare results to detect overflow.\n\n  auto Zero = MIRBuilder.buildConstant(Ty, 0);\n\n  // For an addition, the result should be less than one of the operands (LHS)\n  // if and only if the other operand (RHS) is negative, otherwise there will\n  // be overflow.\n  // For a subtraction, the result should be less than one of the operands\n  // (LHS) if and only if the other operand (RHS) is (non-zero) positive,\n  // otherwise there will be overflow.\n  auto ResultLowerThanLHS =\n      MIRBuilder.buildICmp(CmpInst::ICMP_SLT, BoolTy, Dst0, LHS);\n  auto ConditionRHS = MIRBuilder.buildICmp(\n      IsAdd ? CmpInst::ICMP_SLT : CmpInst::ICMP_SGT, BoolTy, RHS, Zero);\n\n  MIRBuilder.buildXor(Dst1, ConditionRHS, ResultLowerThanLHS);\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerAddSubSatToMinMax(MachineInstr &MI) {\n  Register Res = MI.getOperand(0).getReg();\n  Register LHS = MI.getOperand(1).getReg();\n  Register RHS = MI.getOperand(2).getReg();\n  LLT Ty = MRI.getType(Res);\n  bool IsSigned;\n  bool IsAdd;\n  unsigned BaseOp;\n  switch (MI.getOpcode()) {\n  default:\n    llvm_unreachable(\"unexpected addsat/subsat opcode\");\n  case TargetOpcode::G_UADDSAT:\n    IsSigned = false;\n    IsAdd = true;\n    BaseOp = TargetOpcode::G_ADD;\n    break;\n  case TargetOpcode::G_SADDSAT:\n    IsSigned = true;\n    IsAdd = true;\n    BaseOp = TargetOpcode::G_ADD;\n    break;\n  case TargetOpcode::G_USUBSAT:\n    IsSigned = false;\n    IsAdd = false;\n    BaseOp = TargetOpcode::G_SUB;\n    break;\n  case TargetOpcode::G_SSUBSAT:\n    IsSigned = true;\n    IsAdd = false;\n    BaseOp = TargetOpcode::G_SUB;\n    break;\n  }\n\n  if (IsSigned) {\n    // sadd.sat(a, b) ->\n    //   hi = 0x7fffffff - smax(a, 0)\n    //   lo = 0x80000000 - smin(a, 0)\n    //   a + smin(smax(lo, b), hi)\n    // ssub.sat(a, b) ->\n    //   lo = smax(a, -1) - 0x7fffffff\n    //   hi = smin(a, -1) - 0x80000000\n    //   a - smin(smax(lo, b), hi)\n    // TODO: AMDGPU can use a \"median of 3\" instruction here:\n    //   a +/- med3(lo, b, hi)\n    uint64_t NumBits = Ty.getScalarSizeInBits();\n    auto MaxVal =\n        MIRBuilder.buildConstant(Ty, APInt::getSignedMaxValue(NumBits));\n    auto MinVal =\n        MIRBuilder.buildConstant(Ty, APInt::getSignedMinValue(NumBits));\n    MachineInstrBuilder Hi, Lo;\n    if (IsAdd) {\n      auto Zero = MIRBuilder.buildConstant(Ty, 0);\n      Hi = MIRBuilder.buildSub(Ty, MaxVal, MIRBuilder.buildSMax(Ty, LHS, Zero));\n      Lo = MIRBuilder.buildSub(Ty, MinVal, MIRBuilder.buildSMin(Ty, LHS, Zero));\n    } else {\n      auto NegOne = MIRBuilder.buildConstant(Ty, -1);\n      Lo = MIRBuilder.buildSub(Ty, MIRBuilder.buildSMax(Ty, LHS, NegOne),\n                               MaxVal);\n      Hi = MIRBuilder.buildSub(Ty, MIRBuilder.buildSMin(Ty, LHS, NegOne),\n                               MinVal);\n    }\n    auto RHSClamped =\n        MIRBuilder.buildSMin(Ty, MIRBuilder.buildSMax(Ty, Lo, RHS), Hi);\n    MIRBuilder.buildInstr(BaseOp, {Res}, {LHS, RHSClamped});\n  } else {\n    // uadd.sat(a, b) -> a + umin(~a, b)\n    // usub.sat(a, b) -> a - umin(a, b)\n    Register Not = IsAdd ? MIRBuilder.buildNot(Ty, LHS).getReg(0) : LHS;\n    auto Min = MIRBuilder.buildUMin(Ty, Not, RHS);\n    MIRBuilder.buildInstr(BaseOp, {Res}, {LHS, Min});\n  }\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerAddSubSatToAddoSubo(MachineInstr &MI) {\n  Register Res = MI.getOperand(0).getReg();\n  Register LHS = MI.getOperand(1).getReg();\n  Register RHS = MI.getOperand(2).getReg();\n  LLT Ty = MRI.getType(Res);\n  LLT BoolTy = Ty.changeElementSize(1);\n  bool IsSigned;\n  bool IsAdd;\n  unsigned OverflowOp;\n  switch (MI.getOpcode()) {\n  default:\n    llvm_unreachable(\"unexpected addsat/subsat opcode\");\n  case TargetOpcode::G_UADDSAT:\n    IsSigned = false;\n    IsAdd = true;\n    OverflowOp = TargetOpcode::G_UADDO;\n    break;\n  case TargetOpcode::G_SADDSAT:\n    IsSigned = true;\n    IsAdd = true;\n    OverflowOp = TargetOpcode::G_SADDO;\n    break;\n  case TargetOpcode::G_USUBSAT:\n    IsSigned = false;\n    IsAdd = false;\n    OverflowOp = TargetOpcode::G_USUBO;\n    break;\n  case TargetOpcode::G_SSUBSAT:\n    IsSigned = true;\n    IsAdd = false;\n    OverflowOp = TargetOpcode::G_SSUBO;\n    break;\n  }\n\n  auto OverflowRes =\n      MIRBuilder.buildInstr(OverflowOp, {Ty, BoolTy}, {LHS, RHS});\n  Register Tmp = OverflowRes.getReg(0);\n  Register Ov = OverflowRes.getReg(1);\n  MachineInstrBuilder Clamp;\n  if (IsSigned) {\n    // sadd.sat(a, b) ->\n    //   {tmp, ov} = saddo(a, b)\n    //   ov ? (tmp >>s 31) + 0x80000000 : r\n    // ssub.sat(a, b) ->\n    //   {tmp, ov} = ssubo(a, b)\n    //   ov ? (tmp >>s 31) + 0x80000000 : r\n    uint64_t NumBits = Ty.getScalarSizeInBits();\n    auto ShiftAmount = MIRBuilder.buildConstant(Ty, NumBits - 1);\n    auto Sign = MIRBuilder.buildAShr(Ty, Tmp, ShiftAmount);\n    auto MinVal =\n        MIRBuilder.buildConstant(Ty, APInt::getSignedMinValue(NumBits));\n    Clamp = MIRBuilder.buildAdd(Ty, Sign, MinVal);\n  } else {\n    // uadd.sat(a, b) ->\n    //   {tmp, ov} = uaddo(a, b)\n    //   ov ? 0xffffffff : tmp\n    // usub.sat(a, b) ->\n    //   {tmp, ov} = usubo(a, b)\n    //   ov ? 0 : tmp\n    Clamp = MIRBuilder.buildConstant(Ty, IsAdd ? -1 : 0);\n  }\n  MIRBuilder.buildSelect(Res, Ov, Clamp, Tmp);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerShlSat(MachineInstr &MI) {\n  assert((MI.getOpcode() == TargetOpcode::G_SSHLSAT ||\n          MI.getOpcode() == TargetOpcode::G_USHLSAT) &&\n         \"Expected shlsat opcode!\");\n  bool IsSigned = MI.getOpcode() == TargetOpcode::G_SSHLSAT;\n  Register Res = MI.getOperand(0).getReg();\n  Register LHS = MI.getOperand(1).getReg();\n  Register RHS = MI.getOperand(2).getReg();\n  LLT Ty = MRI.getType(Res);\n  LLT BoolTy = Ty.changeElementSize(1);\n\n  unsigned BW = Ty.getScalarSizeInBits();\n  auto Result = MIRBuilder.buildShl(Ty, LHS, RHS);\n  auto Orig = IsSigned ? MIRBuilder.buildAShr(Ty, Result, RHS)\n                       : MIRBuilder.buildLShr(Ty, Result, RHS);\n\n  MachineInstrBuilder SatVal;\n  if (IsSigned) {\n    auto SatMin = MIRBuilder.buildConstant(Ty, APInt::getSignedMinValue(BW));\n    auto SatMax = MIRBuilder.buildConstant(Ty, APInt::getSignedMaxValue(BW));\n    auto Cmp = MIRBuilder.buildICmp(CmpInst::ICMP_SLT, BoolTy, LHS,\n                                    MIRBuilder.buildConstant(Ty, 0));\n    SatVal = MIRBuilder.buildSelect(Ty, Cmp, SatMin, SatMax);\n  } else {\n    SatVal = MIRBuilder.buildConstant(Ty, APInt::getMaxValue(BW));\n  }\n  auto Ov = MIRBuilder.buildICmp(CmpInst::ICMP_NE, BoolTy, LHS, Orig);\n  MIRBuilder.buildSelect(Res, Ov, SatVal, Result);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerBswap(MachineInstr &MI) {\n  Register Dst = MI.getOperand(0).getReg();\n  Register Src = MI.getOperand(1).getReg();\n  const LLT Ty = MRI.getType(Src);\n  unsigned SizeInBytes = (Ty.getScalarSizeInBits() + 7) / 8;\n  unsigned BaseShiftAmt = (SizeInBytes - 1) * 8;\n\n  // Swap most and least significant byte, set remaining bytes in Res to zero.\n  auto ShiftAmt = MIRBuilder.buildConstant(Ty, BaseShiftAmt);\n  auto LSByteShiftedLeft = MIRBuilder.buildShl(Ty, Src, ShiftAmt);\n  auto MSByteShiftedRight = MIRBuilder.buildLShr(Ty, Src, ShiftAmt);\n  auto Res = MIRBuilder.buildOr(Ty, MSByteShiftedRight, LSByteShiftedLeft);\n\n  // Set i-th high/low byte in Res to i-th low/high byte from Src.\n  for (unsigned i = 1; i < SizeInBytes / 2; ++i) {\n    // AND with Mask leaves byte i unchanged and sets remaining bytes to 0.\n    APInt APMask(SizeInBytes * 8, 0xFF << (i * 8));\n    auto Mask = MIRBuilder.buildConstant(Ty, APMask);\n    auto ShiftAmt = MIRBuilder.buildConstant(Ty, BaseShiftAmt - 16 * i);\n    // Low byte shifted left to place of high byte: (Src & Mask) << ShiftAmt.\n    auto LoByte = MIRBuilder.buildAnd(Ty, Src, Mask);\n    auto LoShiftedLeft = MIRBuilder.buildShl(Ty, LoByte, ShiftAmt);\n    Res = MIRBuilder.buildOr(Ty, Res, LoShiftedLeft);\n    // High byte shifted right to place of low byte: (Src >> ShiftAmt) & Mask.\n    auto SrcShiftedRight = MIRBuilder.buildLShr(Ty, Src, ShiftAmt);\n    auto HiShiftedRight = MIRBuilder.buildAnd(Ty, SrcShiftedRight, Mask);\n    Res = MIRBuilder.buildOr(Ty, Res, HiShiftedRight);\n  }\n  Res.getInstr()->getOperand(0).setReg(Dst);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\n//{ (Src & Mask) >> N } | { (Src << N) & Mask }\nstatic MachineInstrBuilder SwapN(unsigned N, DstOp Dst, MachineIRBuilder &B,\n                                 MachineInstrBuilder Src, APInt Mask) {\n  const LLT Ty = Dst.getLLTTy(*B.getMRI());\n  MachineInstrBuilder C_N = B.buildConstant(Ty, N);\n  MachineInstrBuilder MaskLoNTo0 = B.buildConstant(Ty, Mask);\n  auto LHS = B.buildLShr(Ty, B.buildAnd(Ty, Src, MaskLoNTo0), C_N);\n  auto RHS = B.buildAnd(Ty, B.buildShl(Ty, Src, C_N), MaskLoNTo0);\n  return B.buildOr(Dst, LHS, RHS);\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerBitreverse(MachineInstr &MI) {\n  Register Dst = MI.getOperand(0).getReg();\n  Register Src = MI.getOperand(1).getReg();\n  const LLT Ty = MRI.getType(Src);\n  unsigned Size = Ty.getSizeInBits();\n\n  MachineInstrBuilder BSWAP =\n      MIRBuilder.buildInstr(TargetOpcode::G_BSWAP, {Ty}, {Src});\n\n  // swap high and low 4 bits in 8 bit blocks 7654|3210 -> 3210|7654\n  //    [(val & 0xF0F0F0F0) >> 4] | [(val & 0x0F0F0F0F) << 4]\n  // -> [(val & 0xF0F0F0F0) >> 4] | [(val << 4) & 0xF0F0F0F0]\n  MachineInstrBuilder Swap4 =\n      SwapN(4, Ty, MIRBuilder, BSWAP, APInt::getSplat(Size, APInt(8, 0xF0)));\n\n  // swap high and low 2 bits in 4 bit blocks 32|10 76|54 -> 10|32 54|76\n  //    [(val & 0xCCCCCCCC) >> 2] & [(val & 0x33333333) << 2]\n  // -> [(val & 0xCCCCCCCC) >> 2] & [(val << 2) & 0xCCCCCCCC]\n  MachineInstrBuilder Swap2 =\n      SwapN(2, Ty, MIRBuilder, Swap4, APInt::getSplat(Size, APInt(8, 0xCC)));\n\n  // swap high and low 1 bit in 2 bit blocks 1|0 3|2 5|4 7|6 -> 0|1 2|3 4|5 6|7\n  //    [(val & 0xAAAAAAAA) >> 1] & [(val & 0x55555555) << 1]\n  // -> [(val & 0xAAAAAAAA) >> 1] & [(val << 1) & 0xAAAAAAAA]\n  SwapN(1, Dst, MIRBuilder, Swap2, APInt::getSplat(Size, APInt(8, 0xAA)));\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerReadWriteRegister(MachineInstr &MI) {\n  MachineFunction &MF = MIRBuilder.getMF();\n\n  bool IsRead = MI.getOpcode() == TargetOpcode::G_READ_REGISTER;\n  int NameOpIdx = IsRead ? 1 : 0;\n  int ValRegIndex = IsRead ? 0 : 1;\n\n  Register ValReg = MI.getOperand(ValRegIndex).getReg();\n  const LLT Ty = MRI.getType(ValReg);\n  const MDString *RegStr = cast<MDString>(\n    cast<MDNode>(MI.getOperand(NameOpIdx).getMetadata())->getOperand(0));\n\n  Register PhysReg = TLI.getRegisterByName(RegStr->getString().data(), Ty, MF);\n  if (!PhysReg.isValid())\n    return UnableToLegalize;\n\n  if (IsRead)\n    MIRBuilder.buildCopy(ValReg, PhysReg);\n  else\n    MIRBuilder.buildCopy(PhysReg, ValReg);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult\nLegalizerHelper::lowerSMULH_UMULH(MachineInstr &MI) {\n  bool IsSigned = MI.getOpcode() == TargetOpcode::G_SMULH;\n  unsigned ExtOp = IsSigned ? TargetOpcode::G_SEXT : TargetOpcode::G_ZEXT;\n  Register Result = MI.getOperand(0).getReg();\n  LLT OrigTy = MRI.getType(Result);\n  auto SizeInBits = OrigTy.getScalarSizeInBits();\n  LLT WideTy = OrigTy.changeElementSize(SizeInBits * 2);\n\n  auto LHS = MIRBuilder.buildInstr(ExtOp, {WideTy}, {MI.getOperand(1)});\n  auto RHS = MIRBuilder.buildInstr(ExtOp, {WideTy}, {MI.getOperand(2)});\n  auto Mul = MIRBuilder.buildMul(WideTy, LHS, RHS);\n  unsigned ShiftOp = IsSigned ? TargetOpcode::G_ASHR : TargetOpcode::G_LSHR;\n\n  auto ShiftAmt = MIRBuilder.buildConstant(WideTy, SizeInBits);\n  auto Shifted = MIRBuilder.buildInstr(ShiftOp, {WideTy}, {Mul, ShiftAmt});\n  MIRBuilder.buildTrunc(Result, Shifted);\n\n  MI.eraseFromParent();\n  return Legalized;\n}\n\nLegalizerHelper::LegalizeResult LegalizerHelper::lowerSelect(MachineInstr &MI) {\n  // Implement vector G_SELECT in terms of XOR, AND, OR.\n  Register DstReg = MI.getOperand(0).getReg();\n  Register MaskReg = MI.getOperand(1).getReg();\n  Register Op1Reg = MI.getOperand(2).getReg();\n  Register Op2Reg = MI.getOperand(3).getReg();\n  LLT DstTy = MRI.getType(DstReg);\n  LLT MaskTy = MRI.getType(MaskReg);\n  LLT Op1Ty = MRI.getType(Op1Reg);\n  if (!DstTy.isVector())\n    return UnableToLegalize;\n\n  // Vector selects can have a scalar predicate. If so, splat into a vector and\n  // finish for later legalization attempts to try again.\n  if (MaskTy.isScalar()) {\n    Register MaskElt = MaskReg;\n    if (MaskTy.getSizeInBits() < DstTy.getScalarSizeInBits())\n      MaskElt = MIRBuilder.buildSExt(DstTy.getElementType(), MaskElt).getReg(0);\n    // Generate a vector splat idiom to be pattern matched later.\n    auto ShufSplat = MIRBuilder.buildShuffleSplat(DstTy, MaskElt);\n    Observer.changingInstr(MI);\n    MI.getOperand(1).setReg(ShufSplat.getReg(0));\n    Observer.changedInstr(MI);\n    return Legalized;\n  }\n\n  if (MaskTy.getSizeInBits() != Op1Ty.getSizeInBits()) {\n    return UnableToLegalize;\n  }\n\n  auto NotMask = MIRBuilder.buildNot(MaskTy, MaskReg);\n  auto NewOp1 = MIRBuilder.buildAnd(MaskTy, Op1Reg, MaskReg);\n  auto NewOp2 = MIRBuilder.buildAnd(MaskTy, Op2Reg, NotMask);\n  MIRBuilder.buildOr(DstReg, NewOp1, NewOp2);\n  MI.eraseFromParent();\n  return Legalized;\n}\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h", "content": "//== llvm/CodeGen/GlobalISel/LegalizerHelper.h ---------------- -*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file A pass to convert the target-illegal operations created by IR -> MIR\n/// translation into ones the target expects to be able to select. This may\n/// occur in multiple phases, for example G_ADD <2 x i8> -> G_ADD <2 x i16> ->\n/// G_ADD <4 x i16>.\n///\n/// The LegalizerHelper class is where most of the work happens, and is\n/// designed to be callable from other passes that find themselves with an\n/// illegal instruction.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CODEGEN_GLOBALISEL_LEGALIZERHELPER_H\n#define LLVM_CODEGEN_GLOBALISEL_LEGALIZERHELPER_H\n\n#include \"llvm/CodeGen/GlobalISel/CallLowering.h\"\n#include \"llvm/CodeGen/GlobalISel/MachineIRBuilder.h\"\n#include \"llvm/CodeGen/LowLevelType.h\"\n#include \"llvm/CodeGen/MachineFunctionPass.h\"\n#include \"llvm/CodeGen/RuntimeLibcalls.h\"\n\nnamespace llvm {\n// Forward declarations.\nclass LegalizerInfo;\nclass Legalizer;\nclass MachineRegisterInfo;\nclass GISelChangeObserver;\nclass TargetLowering;\n\nclass LegalizerHelper {\npublic:\n  /// Expose MIRBuilder so clients can set their own RecordInsertInstruction\n  /// functions\n  MachineIRBuilder &MIRBuilder;\n\n  /// To keep track of changes made by the LegalizerHelper.\n  GISelChangeObserver &Observer;\n\nprivate:\n  MachineRegisterInfo &MRI;\n  const LegalizerInfo &LI;\n  const TargetLowering &TLI;\n\npublic:\n  enum LegalizeResult {\n    /// Instruction was already legal and no change was made to the\n    /// MachineFunction.\n    AlreadyLegal,\n\n    /// Instruction has been legalized and the MachineFunction changed.\n    Legalized,\n\n    /// Some kind of error has occurred and we could not legalize this\n    /// instruction.\n    UnableToLegalize,\n  };\n\n  /// Expose LegalizerInfo so the clients can re-use.\n  const LegalizerInfo &getLegalizerInfo() const { return LI; }\n  const TargetLowering &getTargetLowering() const { return TLI; }\n\n  LegalizerHelper(MachineFunction &MF, GISelChangeObserver &Observer,\n                  MachineIRBuilder &B);\n  LegalizerHelper(MachineFunction &MF, const LegalizerInfo &LI,\n                  GISelChangeObserver &Observer, MachineIRBuilder &B);\n\n  /// Replace \\p MI by a sequence of legal instructions that can implement the\n  /// same operation. Note that this means \\p MI may be deleted, so any iterator\n  /// steps should be performed before calling this function. \\p Helper should\n  /// be initialized to the MachineFunction containing \\p MI.\n  ///\n  /// Considered as an opaque blob, the legal code will use and define the same\n  /// registers as \\p MI.\n  LegalizeResult legalizeInstrStep(MachineInstr &MI);\n\n  /// Legalize an instruction by emiting a runtime library call instead.\n  LegalizeResult libcall(MachineInstr &MI);\n\n  /// Legalize an instruction by reducing the width of the underlying scalar\n  /// type.\n  LegalizeResult narrowScalar(MachineInstr &MI, unsigned TypeIdx, LLT NarrowTy);\n\n  /// Legalize an instruction by performing the operation on a wider scalar type\n  /// (for example a 16-bit addition can be safely performed at 32-bits\n  /// precision, ignoring the unused bits).\n  LegalizeResult widenScalar(MachineInstr &MI, unsigned TypeIdx, LLT WideTy);\n\n  /// Legalize an instruction by replacing the value type\n  LegalizeResult bitcast(MachineInstr &MI, unsigned TypeIdx, LLT Ty);\n\n  /// Legalize an instruction by splitting it into simpler parts, hopefully\n  /// understood by the target.\n  LegalizeResult lower(MachineInstr &MI, unsigned TypeIdx, LLT Ty);\n\n  /// Legalize a vector instruction by splitting into multiple components, each\n  /// acting on the same scalar type as the original but with fewer elements.\n  LegalizeResult fewerElementsVector(MachineInstr &MI, unsigned TypeIdx,\n                                     LLT NarrowTy);\n\n  /// Legalize a vector instruction by increasing the number of vector elements\n  /// involved and ignoring the added elements later.\n  LegalizeResult moreElementsVector(MachineInstr &MI, unsigned TypeIdx,\n                                    LLT MoreTy);\n\n  /// Cast the given value to an LLT::scalar with an equivalent size. Returns\n  /// the register to use if an instruction was inserted. Returns the original\n  /// register if no coercion was necessary.\n  //\n  // This may also fail and return Register() if there is no legal way to cast.\n  Register coerceToScalar(Register Val);\n\n  /// Legalize a single operand \\p OpIdx of the machine instruction \\p MI as a\n  /// Use by extending the operand's type to \\p WideTy using the specified \\p\n  /// ExtOpcode for the extension instruction, and replacing the vreg of the\n  /// operand in place.\n  void widenScalarSrc(MachineInstr &MI, LLT WideTy, unsigned OpIdx,\n                      unsigned ExtOpcode);\n\n  /// Legalize a single operand \\p OpIdx of the machine instruction \\p MI as a\n  /// Use by truncating the operand's type to \\p NarrowTy using G_TRUNC, and\n  /// replacing the vreg of the operand in place.\n  void narrowScalarSrc(MachineInstr &MI, LLT NarrowTy, unsigned OpIdx);\n\n  /// Legalize a single operand \\p OpIdx of the machine instruction \\p MI as a\n  /// Def by extending the operand's type to \\p WideTy and truncating it back\n  /// with the \\p TruncOpcode, and replacing the vreg of the operand in place.\n  void widenScalarDst(MachineInstr &MI, LLT WideTy, unsigned OpIdx = 0,\n                      unsigned TruncOpcode = TargetOpcode::G_TRUNC);\n\n  // Legalize a single operand \\p OpIdx of the machine instruction \\p MI as a\n  // Def by truncating the operand's type to \\p NarrowTy, replacing in place and\n  // extending back with \\p ExtOpcode.\n  void narrowScalarDst(MachineInstr &MI, LLT NarrowTy, unsigned OpIdx,\n                       unsigned ExtOpcode);\n  /// Legalize a single operand \\p OpIdx of the machine instruction \\p MI as a\n  /// Def by performing it with additional vector elements and extracting the\n  /// result elements, and replacing the vreg of the operand in place.\n  void moreElementsVectorDst(MachineInstr &MI, LLT MoreTy, unsigned OpIdx);\n\n  /// Legalize a single operand \\p OpIdx of the machine instruction \\p MI as a\n  /// Use by producing a vector with undefined high elements, extracting the\n  /// original vector type, and replacing the vreg of the operand in place.\n  void moreElementsVectorSrc(MachineInstr &MI, LLT MoreTy, unsigned OpIdx);\n\n  /// Legalize a single operand \\p OpIdx of the machine instruction \\p MI as a\n  /// use by inserting a G_BITCAST to \\p CastTy\n  void bitcastSrc(MachineInstr &MI, LLT CastTy, unsigned OpIdx);\n\n  /// Legalize a single operand \\p OpIdx of the machine instruction \\p MI as a\n  /// def by inserting a G_BITCAST from \\p CastTy\n  void bitcastDst(MachineInstr &MI, LLT CastTy, unsigned OpIdx);\n\n  /// Widen \\p OrigReg to \\p WideTy by merging to a wider type, padding with\n  /// G_IMPLICIT_DEF, and producing dead results.\n  Register widenWithUnmerge(LLT WideTy, Register OrigReg);\n\nprivate:\n  LegalizeResult\n  widenScalarMergeValues(MachineInstr &MI, unsigned TypeIdx, LLT WideTy);\n  LegalizeResult\n  widenScalarUnmergeValues(MachineInstr &MI, unsigned TypeIdx, LLT WideTy);\n  LegalizeResult\n  widenScalarExtract(MachineInstr &MI, unsigned TypeIdx, LLT WideTy);\n  LegalizeResult\n  widenScalarInsert(MachineInstr &MI, unsigned TypeIdx, LLT WideTy);\n  LegalizeResult widenScalarAddSubOverflow(MachineInstr &MI, unsigned TypeIdx,\n                                           LLT WideTy);\n  LegalizeResult widenScalarAddSubShlSat(MachineInstr &MI, unsigned TypeIdx,\n                                         LLT WideTy);\n\n  /// Helper function to split a wide generic register into bitwise blocks with\n  /// the given Type (which implies the number of blocks needed). The generic\n  /// registers created are appended to Ops, starting at bit 0 of Reg.\n  void extractParts(Register Reg, LLT Ty, int NumParts,\n                    SmallVectorImpl<Register> &VRegs);\n\n  /// Version which handles irregular splits.\n  bool extractParts(Register Reg, LLT RegTy, LLT MainTy,\n                    LLT &LeftoverTy,\n                    SmallVectorImpl<Register> &VRegs,\n                    SmallVectorImpl<Register> &LeftoverVRegs);\n\n  /// Helper function to build a wide generic register \\p DstReg of type \\p\n  /// RegTy from smaller parts. This will produce a G_MERGE_VALUES,\n  /// G_BUILD_VECTOR, G_CONCAT_VECTORS, or sequence of G_INSERT as appropriate\n  /// for the types.\n  ///\n  /// \\p PartRegs must be registers of type \\p PartTy.\n  ///\n  /// If \\p ResultTy does not evenly break into \\p PartTy sized pieces, the\n  /// remainder must be specified with \\p LeftoverRegs of type \\p LeftoverTy.\n  void insertParts(Register DstReg, LLT ResultTy,\n                   LLT PartTy, ArrayRef<Register> PartRegs,\n                   LLT LeftoverTy = LLT(), ArrayRef<Register> LeftoverRegs = {});\n\n  /// Unmerge \\p SrcReg into smaller sized values, and append them to \\p\n  /// Parts. The elements of \\p Parts will be the greatest common divisor type\n  /// of \\p DstTy, \\p NarrowTy and the type of \\p SrcReg. This will compute and\n  /// return the GCD type.\n  LLT extractGCDType(SmallVectorImpl<Register> &Parts, LLT DstTy,\n                     LLT NarrowTy, Register SrcReg);\n\n  /// Unmerge \\p SrcReg into \\p GCDTy typed registers. This will append all of\n  /// the unpacked registers to \\p Parts. This version is if the common unmerge\n  /// type is already known.\n  void extractGCDType(SmallVectorImpl<Register> &Parts, LLT GCDTy,\n                      Register SrcReg);\n\n  /// Produce a merge of values in \\p VRegs to define \\p DstReg. Perform a merge\n  /// from the least common multiple type, and convert as appropriate to \\p\n  /// DstReg.\n  ///\n  /// \\p VRegs should each have type \\p GCDTy. This type should be greatest\n  /// common divisor type of \\p DstReg, \\p NarrowTy, and an undetermined source\n  /// type.\n  ///\n  /// \\p NarrowTy is the desired result merge source type. If the source value\n  /// needs to be widened to evenly cover \\p DstReg, inserts high bits\n  /// corresponding to the extension opcode \\p PadStrategy.\n  ///\n  /// \\p VRegs will be cleared, and the the result \\p NarrowTy register pieces\n  /// will replace it. Returns The complete LCMTy that \\p VRegs will cover when\n  /// merged.\n  LLT buildLCMMergePieces(LLT DstTy, LLT NarrowTy, LLT GCDTy,\n                          SmallVectorImpl<Register> &VRegs,\n                          unsigned PadStrategy = TargetOpcode::G_ANYEXT);\n\n  /// Merge the values in \\p RemergeRegs to an \\p LCMTy typed value. Extract the\n  /// low bits into \\p DstReg. This is intended to use the outputs from\n  /// buildLCMMergePieces after processing.\n  void buildWidenedRemergeToDst(Register DstReg, LLT LCMTy,\n                                ArrayRef<Register> RemergeRegs);\n\n  /// Perform generic multiplication of values held in multiple registers.\n  /// Generated instructions use only types NarrowTy and i1.\n  /// Destination can be same or two times size of the source.\n  void multiplyRegisters(SmallVectorImpl<Register> &DstRegs,\n                         ArrayRef<Register> Src1Regs,\n                         ArrayRef<Register> Src2Regs, LLT NarrowTy);\n\n  void changeOpcode(MachineInstr &MI, unsigned NewOpcode);\n\npublic:\n  /// Return the alignment to use for a stack temporary object with the given\n  /// type.\n  Align getStackTemporaryAlignment(LLT Type, Align MinAlign = Align()) const;\n\n  /// Create a stack temporary based on the size in bytes and the alignment\n  MachineInstrBuilder createStackTemporary(TypeSize Bytes, Align Alignment,\n                                           MachinePointerInfo &PtrInfo);\n\n  /// Get a pointer to vector element \\p Index located in memory for a vector of\n  /// type \\p VecTy starting at a base address of \\p VecPtr. If \\p Index is out\n  /// of bounds the returned pointer is unspecified, but will be within the\n  /// vector bounds.\n  Register getVectorElementPointer(Register VecPtr, LLT VecTy, Register Index);\n\n  LegalizeResult fewerElementsVectorImplicitDef(MachineInstr &MI,\n                                                unsigned TypeIdx, LLT NarrowTy);\n\n  /// Legalize a instruction with a vector type where each operand may have a\n  /// different element type. All type indexes must have the same number of\n  /// elements.\n  LegalizeResult fewerElementsVectorMultiEltType(MachineInstr &MI,\n                                                 unsigned TypeIdx, LLT NarrowTy);\n\n  LegalizeResult fewerElementsVectorCasts(MachineInstr &MI, unsigned TypeIdx,\n                                          LLT NarrowTy);\n\n  LegalizeResult\n  fewerElementsVectorCmp(MachineInstr &MI, unsigned TypeIdx, LLT NarrowTy);\n\n  LegalizeResult\n  fewerElementsVectorSelect(MachineInstr &MI, unsigned TypeIdx, LLT NarrowTy);\n\n  LegalizeResult fewerElementsVectorPhi(MachineInstr &MI,\n                                        unsigned TypeIdx, LLT NarrowTy);\n\n  LegalizeResult moreElementsVectorPhi(MachineInstr &MI, unsigned TypeIdx,\n                                       LLT MoreTy);\n\n  LegalizeResult fewerElementsVectorUnmergeValues(MachineInstr &MI,\n                                                  unsigned TypeIdx,\n                                                  LLT NarrowTy);\n  LegalizeResult fewerElementsVectorMerge(MachineInstr &MI, unsigned TypeIdx,\n                                          LLT NarrowTy);\n  LegalizeResult fewerElementsVectorExtractInsertVectorElt(MachineInstr &MI,\n                                                           unsigned TypeIdx,\n                                                           LLT NarrowTy);\n\n  LegalizeResult\n  reduceLoadStoreWidth(MachineInstr &MI, unsigned TypeIdx, LLT NarrowTy);\n\n  /// Legalize an instruction by reducing the operation width, either by\n  /// narrowing the type of the operation or by reducing the number of elements\n  /// of a vector.\n  /// The used strategy (narrow vs. fewerElements) is decided by \\p NarrowTy.\n  /// Narrow is used if the scalar type of \\p NarrowTy and \\p DstTy differ,\n  /// fewerElements is used when the scalar type is the same but the number of\n  /// elements between \\p NarrowTy and \\p DstTy differ.\n  LegalizeResult reduceOperationWidth(MachineInstr &MI, unsigned TypeIdx,\n                                      LLT NarrowTy);\n\n  LegalizeResult fewerElementsVectorSextInReg(MachineInstr &MI, unsigned TypeIdx,\n                                              LLT NarrowTy);\n\n  LegalizeResult narrowScalarShiftByConstant(MachineInstr &MI, const APInt &Amt,\n                                             LLT HalfTy, LLT ShiftAmtTy);\n\n  LegalizeResult narrowScalarShift(MachineInstr &MI, unsigned TypeIdx, LLT Ty);\n  LegalizeResult narrowScalarAddSub(MachineInstr &MI, unsigned TypeIdx,\n                                    LLT NarrowTy);\n  LegalizeResult narrowScalarMul(MachineInstr &MI, LLT Ty);\n  LegalizeResult narrowScalarExtract(MachineInstr &MI, unsigned TypeIdx, LLT Ty);\n  LegalizeResult narrowScalarInsert(MachineInstr &MI, unsigned TypeIdx, LLT Ty);\n\n  LegalizeResult narrowScalarBasic(MachineInstr &MI, unsigned TypeIdx, LLT Ty);\n  LegalizeResult narrowScalarExt(MachineInstr &MI, unsigned TypeIdx, LLT Ty);\n  LegalizeResult narrowScalarSelect(MachineInstr &MI, unsigned TypeIdx, LLT Ty);\n  LegalizeResult narrowScalarCTLZ(MachineInstr &MI, unsigned TypeIdx, LLT Ty);\n  LegalizeResult narrowScalarCTTZ(MachineInstr &MI, unsigned TypeIdx, LLT Ty);\n  LegalizeResult narrowScalarCTPOP(MachineInstr &MI, unsigned TypeIdx, LLT Ty);\n\n  /// Perform Bitcast legalize action on G_EXTRACT_VECTOR_ELT.\n  LegalizeResult bitcastExtractVectorElt(MachineInstr &MI, unsigned TypeIdx,\n                                         LLT CastTy);\n\n  /// Perform Bitcast legalize action on G_INSERT_VECTOR_ELT.\n  LegalizeResult bitcastInsertVectorElt(MachineInstr &MI, unsigned TypeIdx,\n                                        LLT CastTy);\n\n  LegalizeResult lowerBitcast(MachineInstr &MI);\n  LegalizeResult lowerLoad(MachineInstr &MI);\n  LegalizeResult lowerStore(MachineInstr &MI);\n  LegalizeResult lowerBitCount(MachineInstr &MI);\n\n  LegalizeResult lowerU64ToF32BitOps(MachineInstr &MI);\n  LegalizeResult lowerUITOFP(MachineInstr &MI);\n  LegalizeResult lowerSITOFP(MachineInstr &MI);\n  LegalizeResult lowerFPTOUI(MachineInstr &MI);\n  LegalizeResult lowerFPTOSI(MachineInstr &MI);\n\n  LegalizeResult lowerFPTRUNC_F64_TO_F16(MachineInstr &MI);\n  LegalizeResult lowerFPTRUNC(MachineInstr &MI);\n  LegalizeResult lowerFPOWI(MachineInstr &MI);\n\n  LegalizeResult lowerMinMax(MachineInstr &MI);\n  LegalizeResult lowerFCopySign(MachineInstr &MI);\n  LegalizeResult lowerFMinNumMaxNum(MachineInstr &MI);\n  LegalizeResult lowerFMad(MachineInstr &MI);\n  LegalizeResult lowerIntrinsicRound(MachineInstr &MI);\n  LegalizeResult lowerFFloor(MachineInstr &MI);\n  LegalizeResult lowerMergeValues(MachineInstr &MI);\n  LegalizeResult lowerUnmergeValues(MachineInstr &MI);\n  LegalizeResult lowerExtractInsertVectorElt(MachineInstr &MI);\n  LegalizeResult lowerShuffleVector(MachineInstr &MI);\n  LegalizeResult lowerDynStackAlloc(MachineInstr &MI);\n  LegalizeResult lowerExtract(MachineInstr &MI);\n  LegalizeResult lowerInsert(MachineInstr &MI);\n  LegalizeResult lowerSADDO_SSUBO(MachineInstr &MI);\n  LegalizeResult lowerAddSubSatToMinMax(MachineInstr &MI);\n  LegalizeResult lowerAddSubSatToAddoSubo(MachineInstr &MI);\n  LegalizeResult lowerShlSat(MachineInstr &MI);\n  LegalizeResult lowerBswap(MachineInstr &MI);\n  LegalizeResult lowerBitreverse(MachineInstr &MI);\n  LegalizeResult lowerReadWriteRegister(MachineInstr &MI);\n  LegalizeResult lowerSMULH_UMULH(MachineInstr &MI);\n  LegalizeResult lowerSelect(MachineInstr &MI);\n\n};\n\n/// Helper function that creates a libcall to the given \\p Name using the given\n/// calling convention \\p CC.\nLegalizerHelper::LegalizeResult\ncreateLibcall(MachineIRBuilder &MIRBuilder, const char *Name,\n              const CallLowering::ArgInfo &Result,\n              ArrayRef<CallLowering::ArgInfo> Args, CallingConv::ID CC);\n\n/// Helper function that creates the given libcall.\nLegalizerHelper::LegalizeResult\ncreateLibcall(MachineIRBuilder &MIRBuilder, RTLIB::Libcall Libcall,\n              const CallLowering::ArgInfo &Result,\n              ArrayRef<CallLowering::ArgInfo> Args);\n\n/// Create a libcall to memcpy et al.\nLegalizerHelper::LegalizeResult createMemLibcall(MachineIRBuilder &MIRBuilder,\n                                                 MachineRegisterInfo &MRI,\n                                                 MachineInstr &MI);\n\n} // End namespace llvm.\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 23, "file": 2, "line": 1270}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 145}, "message": "differing parameters are named here: ('MoreTy'), in definition: ('WideTy')"}, {"location": {"col": 8, "file": 1, "line": 145}, "message": "function 'llvm::LegalizerHelper::moreElementsVectorDst' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h", "reportHash": "b00677d9d07602c346cc451b4a889210", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 23, "file": 2, "line": 153}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 1, "line": 185}, "message": "differing parameters are named here: ('LeftoverVRegs'), in definition: ('LeftoverRegs')"}, {"location": {"col": 8, "file": 1, "line": 185}, "message": "function 'llvm::LegalizerHelper::extractParts' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h", "reportHash": "f7c453e0b6b87c92bec1d6a592e03d24", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 2, "line": 3646}, "message": "the definition seen here"}, {"location": {"col": 18, "file": 1, "line": 294}, "message": "differing parameters are named here: ('NarrowTy'), in definition: ('NarrowVecTy')"}, {"location": {"col": 18, "file": 1, "line": 294}, "message": "function 'llvm::LegalizerHelper::fewerElementsVectorExtractInsertVectorElt' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h", "reportHash": "ab8ebc3a5722255fc9a8d1342fbdc3d4", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
